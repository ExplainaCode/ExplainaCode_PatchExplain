record_number,buggy_code,fixed_code
1001,"void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != BUNDLE_MAGIC) {
    throw new IllegalStateException(""String_Node_Str"" + Integer.toHexString(magic));
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  p.setDataPosition(0);
  if (mMap != null) {
    if (mFdsKnown) {
      mHasFds|=p.hasFileDescriptors();
    }
    int N=p.readInt();
    p.readArrayMapSafelyInternal(mMap,N,mClassLoader);
    p.recycle();
  }
 else {
    mParcelledData=p;
    mHasFds=p.hasFileDescriptors();
    mFdsKnown=true;
  }
}","void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != BUNDLE_MAGIC) {
    throw new IllegalStateException(""String_Node_Str"" + Integer.toHexString(magic));
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ length+ ""String_Node_Str""+ offset);
  p.setDataPosition(0);
  mParcelledData=p;
  mHasFds=p.hasFileDescriptors();
  mFdsKnown=true;
}"
1002,"/** 
 * Read and return a new Bundle object from the parcel at the current dataPosition(), using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects. Returns null if the previously written Bundle object was null.
 */
public final Bundle readBundle(ClassLoader loader){
  int length=readInt();
  if (length < 0) {
    return null;
  }
  final Bundle bundle=new Bundle(this,length);
  if (loader != null) {
    bundle.setClassLoader(loader);
  }
  return bundle;
}","/** 
 * Read and return a new Bundle object from the parcel at the current dataPosition(), using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects. Returns null if the previously written Bundle object was null.
 */
public final Bundle readBundle(ClassLoader loader){
  int length=readInt();
  if (length < 0) {
    if (Bundle.DEBUG)     Log.d(TAG,""String_Node_Str"" + length);
    return null;
  }
  final Bundle bundle=new Bundle(this,length);
  if (loader != null) {
    bundle.setClassLoader(loader);
  }
  return bundle;
}"
1003,"/** 
 * @hide Like  {@link #clear}, but doesn't reduce the capacity of the ArrayMap.
 */
public void erase(){
  if (mSize > 0) {
    final int N=mSize << 1;
    final Object[] array=mArray;
    for (int i=0; i < N; i++) {
      array[i]=null;
    }
  }
}","/** 
 * @hide Like  {@link #clear}, but doesn't reduce the capacity of the ArrayMap.
 */
public void erase(){
  if (mSize > 0) {
    final int N=mSize << 1;
    final Object[] array=mArray;
    for (int i=0; i < N; i++) {
      array[i]=null;
    }
    mSize=0;
  }
}"
1004,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_SCREEN_ON)) {
    mWifiController.sendMessage(CMD_SCREEN_ON);
  }
 else   if (action.equals(Intent.ACTION_SCREEN_OFF)) {
    mWifiController.sendMessage(CMD_SCREEN_OFF);
  }
 else   if (action.equals(Intent.ACTION_BATTERY_CHANGED)) {
    int pluggedType=intent.getIntExtra(""String_Node_Str"",0);
    mWifiController.sendMessage(CMD_BATTERY_CHANGED,pluggedType,0,null);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE,BluetoothAdapter.STATE_DISCONNECTED);
    mWifiStateMachine.sendBluetoothAdapterStateChange(state);
  }
 else   if (action.equals(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED)) {
    boolean emergencyMode=intent.getBooleanExtra(""String_Node_Str"",false);
    mWifiController.sendMessage(CMD_EMERGENCY_MODE_CHANGED,emergencyMode ? 1 : 0,0);
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_SCREEN_ON)) {
    mWifiController.sendMessage(CMD_SCREEN_ON);
  }
 else   if (action.equals(Intent.ACTION_USER_PRESENT)) {
    mWifiController.sendMessage(CMD_USER_PRESENT);
  }
 else   if (action.equals(Intent.ACTION_SCREEN_OFF)) {
    mWifiController.sendMessage(CMD_SCREEN_OFF);
  }
 else   if (action.equals(Intent.ACTION_BATTERY_CHANGED)) {
    int pluggedType=intent.getIntExtra(""String_Node_Str"",0);
    mWifiController.sendMessage(CMD_BATTERY_CHANGED,pluggedType,0,null);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE,BluetoothAdapter.STATE_DISCONNECTED);
    mWifiStateMachine.sendBluetoothAdapterStateChange(state);
  }
 else   if (action.equals(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED)) {
    boolean emergencyMode=intent.getBooleanExtra(""String_Node_Str"",false);
    mWifiController.sendMessage(CMD_EMERGENCY_MODE_CHANGED,emergencyMode ? 1 : 0,0);
  }
}"
1005,"private void registerForBroadcasts(){
  IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(Intent.ACTION_SCREEN_ON);
  intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
  intentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  intentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
  intentFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
  intentFilter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
  mContext.registerReceiver(mReceiver,intentFilter);
}","private void registerForBroadcasts(){
  IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(Intent.ACTION_SCREEN_ON);
  intentFilter.addAction(Intent.ACTION_USER_PRESENT);
  intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
  intentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  intentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
  intentFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
  intentFilter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
  mContext.registerReceiver(mReceiver,intentFilter);
}"
1006,"/** 
 * Read the variables from the supplicant daemon that are needed to fill in the WifiConfiguration object.
 * @param config the {@link WifiConfiguration} object to be filled in.
 */
private void readNetworkVariables(WifiConfiguration config){
  int netId=config.networkId;
  if (netId < 0)   return;
  String value;
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.ssidVarName);
  if (!TextUtils.isEmpty(value)) {
    if (value.charAt(0) != '""') {
      config.SSID=""String_Node_Str"" + WifiSsid.createFromHex(value).toString() + ""String_Node_Str"";
    }
 else {
      config.SSID=value;
    }
  }
 else {
    config.SSID=null;
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.bssidVarName);
  if (!TextUtils.isEmpty(value)) {
    config.BSSID=value;
  }
 else {
    config.BSSID=null;
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.priorityVarName);
  config.priority=-1;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.priority=Integer.parseInt(value);
    }
 catch (    NumberFormatException ignore) {
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.hiddenSSIDVarName);
  config.hiddenSSID=false;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.hiddenSSID=Integer.parseInt(value) != 0;
    }
 catch (    NumberFormatException ignore) {
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.wepTxKeyIdxVarName);
  config.wepTxKeyIndex=-1;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.wepTxKeyIndex=Integer.parseInt(value);
    }
 catch (    NumberFormatException ignore) {
    }
  }
  for (int i=0; i < 4; i++) {
    value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.wepKeyVarNames[i]);
    if (!TextUtils.isEmpty(value)) {
      config.wepKeys[i]=value;
    }
 else {
      config.wepKeys[i]=null;
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.pskVarName);
  if (!TextUtils.isEmpty(value)) {
    config.preSharedKey=value;
  }
 else {
    config.preSharedKey=null;
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.Protocol.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.Protocol.strings);
      if (0 <= index) {
        config.allowedProtocols.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.KeyMgmt.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.KeyMgmt.strings);
      if (0 <= index) {
        config.allowedKeyManagement.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.AuthAlgorithm.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.AuthAlgorithm.strings);
      if (0 <= index) {
        config.allowedAuthAlgorithms.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.PairwiseCipher.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.PairwiseCipher.strings);
      if (0 <= index) {
        config.allowedPairwiseCiphers.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.GroupCipher.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.GroupCipher.strings);
      if (0 <= index) {
        config.allowedGroupCiphers.set(index);
      }
    }
  }
  if (config.enterpriseConfig == null) {
    config.enterpriseConfig=new WifiEnterpriseConfig();
  }
  HashMap<String,String> enterpriseFields=config.enterpriseConfig.getFields();
  for (  String key : WifiEnterpriseConfig.getSupplicantKeys()) {
    value=mWifiNative.getNetworkVariable(netId,key);
    if (!TextUtils.isEmpty(value)) {
      enterpriseFields.put(key,removeDoubleQuotes(value));
    }
 else {
      enterpriseFields.put(key,WifiEnterpriseConfig.EMPTY_VALUE);
    }
  }
  if (config.enterpriseConfig.migrateOldEapTlsNative(mWifiNative,netId)) {
    saveConfig();
  }
  config.enterpriseConfig.migrateCerts(mKeyStore);
}","/** 
 * Read the variables from the supplicant daemon that are needed to fill in the WifiConfiguration object.
 * @param config the {@link WifiConfiguration} object to be filled in.
 */
private void readNetworkVariables(WifiConfiguration config){
  int netId=config.networkId;
  if (netId < 0)   return;
  String value;
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.ssidVarName);
  if (!TextUtils.isEmpty(value)) {
    if (value.charAt(0) != '""') {
      config.SSID=""String_Node_Str"" + WifiSsid.createFromHex(value).toString() + ""String_Node_Str"";
    }
 else {
      config.SSID=value;
    }
  }
 else {
    config.SSID=null;
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.bssidVarName);
  if (!TextUtils.isEmpty(value)) {
    config.BSSID=value;
  }
 else {
    config.BSSID=null;
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.priorityVarName);
  config.priority=-1;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.priority=Integer.parseInt(value);
    }
 catch (    NumberFormatException ignore) {
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.hiddenSSIDVarName);
  config.hiddenSSID=false;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.hiddenSSID=Integer.parseInt(value) != 0;
    }
 catch (    NumberFormatException ignore) {
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.wepTxKeyIdxVarName);
  config.wepTxKeyIndex=-1;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.wepTxKeyIndex=Integer.parseInt(value);
    }
 catch (    NumberFormatException ignore) {
    }
  }
  for (int i=0; i < 4; i++) {
    value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.wepKeyVarNames[i]);
    if (!TextUtils.isEmpty(value)) {
      config.wepKeys[i]=value;
    }
 else {
      config.wepKeys[i]=null;
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.pskVarName);
  if (!TextUtils.isEmpty(value)) {
    config.preSharedKey=value;
  }
 else {
    config.preSharedKey=null;
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.Protocol.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.Protocol.strings);
      if (0 <= index) {
        config.allowedProtocols.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.KeyMgmt.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.KeyMgmt.strings);
      if (0 <= index) {
        config.allowedKeyManagement.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.AuthAlgorithm.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.AuthAlgorithm.strings);
      if (0 <= index) {
        config.allowedAuthAlgorithms.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.PairwiseCipher.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.PairwiseCipher.strings);
      if (0 <= index) {
        config.allowedPairwiseCiphers.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.GroupCipher.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.GroupCipher.strings);
      if (0 <= index) {
        config.allowedGroupCiphers.set(index);
      }
    }
  }
  if (config.enterpriseConfig == null) {
    config.enterpriseConfig=new WifiEnterpriseConfig();
  }
  HashMap<String,String> enterpriseFields=config.enterpriseConfig.getFields();
  for (  String key : WifiEnterpriseConfig.getSupplicantKeys()) {
    value=mWifiNative.getNetworkVariable(netId,key);
    if (!TextUtils.isEmpty(value)) {
      enterpriseFields.put(key,removeDoubleQuotes(value));
    }
 else {
      enterpriseFields.put(key,WifiEnterpriseConfig.EMPTY_VALUE);
    }
  }
  if (config.enterpriseConfig.migrateOldEapTlsNative(mWifiNative,netId)) {
    saveConfig();
  }
  config.enterpriseConfig.migrateCerts(mKeyStore);
  config.enterpriseConfig.initializeSoftwareKeystoreFlag(mKeyStore);
}"
1007,"boolean installKeys(android.security.KeyStore keyStore,String name){
  boolean ret=true;
  String privKeyName=Credentials.USER_PRIVATE_KEY + name;
  String userCertName=Credentials.USER_CERTIFICATE + name;
  String caCertName=Credentials.CA_CERTIFICATE + name;
  if (mClientCertificate != null) {
    byte[] privKeyData=mClientPrivateKey.getEncoded();
    ret=keyStore.importKey(privKeyName,privKeyData,Process.WIFI_UID,KeyStore.FLAG_ENCRYPTED);
    if (ret == false) {
      return ret;
    }
    ret=putCertInKeyStore(keyStore,userCertName,mClientCertificate);
    if (ret == false) {
      keyStore.delKey(privKeyName,Process.WIFI_UID);
      return ret;
    }
  }
  if (mCaCert != null) {
    ret=putCertInKeyStore(keyStore,caCertName,mCaCert);
    if (ret == false) {
      if (mClientCertificate != null) {
        keyStore.delKey(privKeyName,Process.WIFI_UID);
        keyStore.delete(userCertName,Process.WIFI_UID);
      }
      return ret;
    }
  }
  if (mClientCertificate != null) {
    setClientCertificateAlias(name);
    mClientPrivateKey=null;
    mClientCertificate=null;
  }
  if (mCaCert != null) {
    setCaCertificateAlias(name);
    mCaCert=null;
  }
  return ret;
}","boolean installKeys(android.security.KeyStore keyStore,String name){
  boolean ret=true;
  String privKeyName=Credentials.USER_PRIVATE_KEY + name;
  String userCertName=Credentials.USER_CERTIFICATE + name;
  String caCertName=Credentials.CA_CERTIFICATE + name;
  if (mClientCertificate != null) {
    byte[] privKeyData=mClientPrivateKey.getEncoded();
    if (isHardwareBackedKey(mClientPrivateKey)) {
      if (DBG)       Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
      ret=keyStore.importKey(privKeyName,privKeyData,Process.WIFI_UID,KeyStore.FLAG_NONE);
    }
 else {
      if (DBG)       Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str"");
      ret=keyStore.importKey(privKeyName,privKeyData,Process.WIFI_UID,KeyStore.FLAG_ENCRYPTED);
      mNeedsSoftwareKeystore=true;
    }
    if (ret == false) {
      return ret;
    }
    ret=putCertInKeyStore(keyStore,userCertName,mClientCertificate);
    if (ret == false) {
      keyStore.delKey(privKeyName,Process.WIFI_UID);
      return ret;
    }
  }
  if (mCaCert != null) {
    ret=putCertInKeyStore(keyStore,caCertName,mCaCert);
    if (ret == false) {
      if (mClientCertificate != null) {
        keyStore.delKey(privKeyName,Process.WIFI_UID);
        keyStore.delete(userCertName,Process.WIFI_UID);
      }
      return ret;
    }
  }
  if (mClientCertificate != null) {
    setClientCertificateAlias(name);
    mClientPrivateKey=null;
    mClientCertificate=null;
  }
  if (mCaCert != null) {
    setCaCertificateAlias(name);
    mCaCert=null;
  }
  return ret;
}"
1008,"void removeKeys(KeyStore keyStore){
  String client=getFieldValue(CLIENT_CERT_KEY,CLIENT_CERT_PREFIX);
  if (!TextUtils.isEmpty(client)) {
    keyStore.delKey(Credentials.USER_PRIVATE_KEY + client,Process.WIFI_UID);
    keyStore.delete(Credentials.USER_CERTIFICATE + client,Process.WIFI_UID);
  }
  String ca=getFieldValue(CA_CERT_KEY,CA_CERT_PREFIX);
  if (!TextUtils.isEmpty(ca)) {
    keyStore.delete(Credentials.CA_CERTIFICATE + ca,Process.WIFI_UID);
  }
}","void removeKeys(KeyStore keyStore){
  String client=getFieldValue(CLIENT_CERT_KEY,CLIENT_CERT_PREFIX);
  if (!TextUtils.isEmpty(client)) {
    if (DBG)     Slog.d(TAG,""String_Node_Str"");
    keyStore.delKey(Credentials.USER_PRIVATE_KEY + client,Process.WIFI_UID);
    keyStore.delete(Credentials.USER_CERTIFICATE + client,Process.WIFI_UID);
  }
  String ca=getFieldValue(CA_CERT_KEY,CA_CERT_PREFIX);
  if (!TextUtils.isEmpty(ca)) {
    if (DBG)     Slog.d(TAG,""String_Node_Str"");
    keyStore.delete(Credentials.CA_CERTIFICATE + ca,Process.WIFI_UID);
  }
}"
1009,"private boolean putCertInKeyStore(android.security.KeyStore keyStore,String name,Certificate cert){
  try {
    byte[] certData=Credentials.convertToPem(cert);
    return keyStore.put(name,certData,Process.WIFI_UID,KeyStore.FLAG_ENCRYPTED);
  }
 catch (  IOException e1) {
    return false;
  }
catch (  CertificateException e2) {
    return false;
  }
}","private boolean putCertInKeyStore(android.security.KeyStore keyStore,String name,Certificate cert){
  try {
    byte[] certData=Credentials.convertToPem(cert);
    if (DBG)     Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str"");
    return keyStore.put(name,certData,Process.WIFI_UID,KeyStore.FLAG_NONE);
  }
 catch (  IOException e1) {
    return false;
  }
catch (  CertificateException e2) {
    return false;
  }
}"
1010,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_SCREEN_ON)) {
    mWifiController.sendMessage(CMD_SCREEN_ON);
  }
 else   if (action.equals(Intent.ACTION_SCREEN_OFF)) {
    mWifiController.sendMessage(CMD_SCREEN_OFF);
  }
 else   if (action.equals(Intent.ACTION_BATTERY_CHANGED)) {
    int pluggedType=intent.getIntExtra(""String_Node_Str"",0);
    mWifiController.sendMessage(CMD_BATTERY_CHANGED,pluggedType,0,null);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE,BluetoothAdapter.STATE_DISCONNECTED);
    mWifiStateMachine.sendBluetoothAdapterStateChange(state);
  }
 else   if (action.equals(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED)) {
    boolean emergencyMode=intent.getBooleanExtra(""String_Node_Str"",false);
    mWifiController.sendMessage(CMD_EMERGENCY_MODE_CHANGED,emergencyMode ? 1 : 0,0);
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_SCREEN_ON)) {
    mWifiController.sendMessage(CMD_SCREEN_ON);
  }
 else   if (action.equals(Intent.ACTION_USER_PRESENT)) {
    mWifiController.sendMessage(CMD_USER_PRESENT);
  }
 else   if (action.equals(Intent.ACTION_SCREEN_OFF)) {
    mWifiController.sendMessage(CMD_SCREEN_OFF);
  }
 else   if (action.equals(Intent.ACTION_BATTERY_CHANGED)) {
    int pluggedType=intent.getIntExtra(""String_Node_Str"",0);
    mWifiController.sendMessage(CMD_BATTERY_CHANGED,pluggedType,0,null);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE,BluetoothAdapter.STATE_DISCONNECTED);
    mWifiStateMachine.sendBluetoothAdapterStateChange(state);
  }
 else   if (action.equals(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED)) {
    boolean emergencyMode=intent.getBooleanExtra(""String_Node_Str"",false);
    mWifiController.sendMessage(CMD_EMERGENCY_MODE_CHANGED,emergencyMode ? 1 : 0,0);
  }
}"
1011,"private void registerForBroadcasts(){
  IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(Intent.ACTION_SCREEN_ON);
  intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
  intentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  intentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
  intentFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
  intentFilter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
  mContext.registerReceiver(mReceiver,intentFilter);
}","private void registerForBroadcasts(){
  IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(Intent.ACTION_SCREEN_ON);
  intentFilter.addAction(Intent.ACTION_USER_PRESENT);
  intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
  intentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  intentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
  intentFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
  intentFilter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
  mContext.registerReceiver(mReceiver,intentFilter);
}"
1012,"/** 
 * Read the variables from the supplicant daemon that are needed to fill in the WifiConfiguration object.
 * @param config the {@link WifiConfiguration} object to be filled in.
 */
private void readNetworkVariables(WifiConfiguration config){
  int netId=config.networkId;
  if (netId < 0)   return;
  String value;
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.ssidVarName);
  if (!TextUtils.isEmpty(value)) {
    if (value.charAt(0) != '""') {
      config.SSID=""String_Node_Str"" + WifiSsid.createFromHex(value).toString() + ""String_Node_Str"";
    }
 else {
      config.SSID=value;
    }
  }
 else {
    config.SSID=null;
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.bssidVarName);
  if (!TextUtils.isEmpty(value)) {
    config.BSSID=value;
  }
 else {
    config.BSSID=null;
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.priorityVarName);
  config.priority=-1;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.priority=Integer.parseInt(value);
    }
 catch (    NumberFormatException ignore) {
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.hiddenSSIDVarName);
  config.hiddenSSID=false;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.hiddenSSID=Integer.parseInt(value) != 0;
    }
 catch (    NumberFormatException ignore) {
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.wepTxKeyIdxVarName);
  config.wepTxKeyIndex=-1;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.wepTxKeyIndex=Integer.parseInt(value);
    }
 catch (    NumberFormatException ignore) {
    }
  }
  for (int i=0; i < 4; i++) {
    value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.wepKeyVarNames[i]);
    if (!TextUtils.isEmpty(value)) {
      config.wepKeys[i]=value;
    }
 else {
      config.wepKeys[i]=null;
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.pskVarName);
  if (!TextUtils.isEmpty(value)) {
    config.preSharedKey=value;
  }
 else {
    config.preSharedKey=null;
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.Protocol.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.Protocol.strings);
      if (0 <= index) {
        config.allowedProtocols.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.KeyMgmt.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.KeyMgmt.strings);
      if (0 <= index) {
        config.allowedKeyManagement.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.AuthAlgorithm.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.AuthAlgorithm.strings);
      if (0 <= index) {
        config.allowedAuthAlgorithms.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.PairwiseCipher.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.PairwiseCipher.strings);
      if (0 <= index) {
        config.allowedPairwiseCiphers.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.GroupCipher.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.GroupCipher.strings);
      if (0 <= index) {
        config.allowedGroupCiphers.set(index);
      }
    }
  }
  if (config.enterpriseConfig == null) {
    config.enterpriseConfig=new WifiEnterpriseConfig();
  }
  HashMap<String,String> enterpriseFields=config.enterpriseConfig.getFields();
  for (  String key : WifiEnterpriseConfig.getSupplicantKeys()) {
    value=mWifiNative.getNetworkVariable(netId,key);
    if (!TextUtils.isEmpty(value)) {
      enterpriseFields.put(key,removeDoubleQuotes(value));
    }
 else {
      enterpriseFields.put(key,WifiEnterpriseConfig.EMPTY_VALUE);
    }
  }
  if (config.enterpriseConfig.migrateOldEapTlsNative(mWifiNative,netId)) {
    saveConfig();
  }
  config.enterpriseConfig.migrateCerts(mKeyStore);
}","/** 
 * Read the variables from the supplicant daemon that are needed to fill in the WifiConfiguration object.
 * @param config the {@link WifiConfiguration} object to be filled in.
 */
private void readNetworkVariables(WifiConfiguration config){
  int netId=config.networkId;
  if (netId < 0)   return;
  String value;
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.ssidVarName);
  if (!TextUtils.isEmpty(value)) {
    if (value.charAt(0) != '""') {
      config.SSID=""String_Node_Str"" + WifiSsid.createFromHex(value).toString() + ""String_Node_Str"";
    }
 else {
      config.SSID=value;
    }
  }
 else {
    config.SSID=null;
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.bssidVarName);
  if (!TextUtils.isEmpty(value)) {
    config.BSSID=value;
  }
 else {
    config.BSSID=null;
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.priorityVarName);
  config.priority=-1;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.priority=Integer.parseInt(value);
    }
 catch (    NumberFormatException ignore) {
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.hiddenSSIDVarName);
  config.hiddenSSID=false;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.hiddenSSID=Integer.parseInt(value) != 0;
    }
 catch (    NumberFormatException ignore) {
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.wepTxKeyIdxVarName);
  config.wepTxKeyIndex=-1;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.wepTxKeyIndex=Integer.parseInt(value);
    }
 catch (    NumberFormatException ignore) {
    }
  }
  for (int i=0; i < 4; i++) {
    value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.wepKeyVarNames[i]);
    if (!TextUtils.isEmpty(value)) {
      config.wepKeys[i]=value;
    }
 else {
      config.wepKeys[i]=null;
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.pskVarName);
  if (!TextUtils.isEmpty(value)) {
    config.preSharedKey=value;
  }
 else {
    config.preSharedKey=null;
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.Protocol.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.Protocol.strings);
      if (0 <= index) {
        config.allowedProtocols.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.KeyMgmt.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.KeyMgmt.strings);
      if (0 <= index) {
        config.allowedKeyManagement.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.AuthAlgorithm.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.AuthAlgorithm.strings);
      if (0 <= index) {
        config.allowedAuthAlgorithms.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.PairwiseCipher.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.PairwiseCipher.strings);
      if (0 <= index) {
        config.allowedPairwiseCiphers.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.GroupCipher.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.GroupCipher.strings);
      if (0 <= index) {
        config.allowedGroupCiphers.set(index);
      }
    }
  }
  if (config.enterpriseConfig == null) {
    config.enterpriseConfig=new WifiEnterpriseConfig();
  }
  HashMap<String,String> enterpriseFields=config.enterpriseConfig.getFields();
  for (  String key : WifiEnterpriseConfig.getSupplicantKeys()) {
    value=mWifiNative.getNetworkVariable(netId,key);
    if (!TextUtils.isEmpty(value)) {
      enterpriseFields.put(key,removeDoubleQuotes(value));
    }
 else {
      enterpriseFields.put(key,WifiEnterpriseConfig.EMPTY_VALUE);
    }
  }
  if (config.enterpriseConfig.migrateOldEapTlsNative(mWifiNative,netId)) {
    saveConfig();
  }
  config.enterpriseConfig.migrateCerts(mKeyStore);
  config.enterpriseConfig.initializeSoftwareKeystoreFlag(mKeyStore);
}"
1013,"boolean installKeys(android.security.KeyStore keyStore,String name){
  boolean ret=true;
  String privKeyName=Credentials.USER_PRIVATE_KEY + name;
  String userCertName=Credentials.USER_CERTIFICATE + name;
  String caCertName=Credentials.CA_CERTIFICATE + name;
  if (mClientCertificate != null) {
    byte[] privKeyData=mClientPrivateKey.getEncoded();
    ret=keyStore.importKey(privKeyName,privKeyData,Process.WIFI_UID,KeyStore.FLAG_ENCRYPTED);
    if (ret == false) {
      return ret;
    }
    ret=putCertInKeyStore(keyStore,userCertName,mClientCertificate);
    if (ret == false) {
      keyStore.delKey(privKeyName,Process.WIFI_UID);
      return ret;
    }
  }
  if (mCaCert != null) {
    ret=putCertInKeyStore(keyStore,caCertName,mCaCert);
    if (ret == false) {
      if (mClientCertificate != null) {
        keyStore.delKey(privKeyName,Process.WIFI_UID);
        keyStore.delete(userCertName,Process.WIFI_UID);
      }
      return ret;
    }
  }
  if (mClientCertificate != null) {
    setClientCertificateAlias(name);
    mClientPrivateKey=null;
    mClientCertificate=null;
  }
  if (mCaCert != null) {
    setCaCertificateAlias(name);
    mCaCert=null;
  }
  return ret;
}","boolean installKeys(android.security.KeyStore keyStore,String name){
  boolean ret=true;
  String privKeyName=Credentials.USER_PRIVATE_KEY + name;
  String userCertName=Credentials.USER_CERTIFICATE + name;
  String caCertName=Credentials.CA_CERTIFICATE + name;
  if (mClientCertificate != null) {
    byte[] privKeyData=mClientPrivateKey.getEncoded();
    if (isHardwareBackedKey(mClientPrivateKey)) {
      if (DBG)       Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
      ret=keyStore.importKey(privKeyName,privKeyData,Process.WIFI_UID,KeyStore.FLAG_NONE);
    }
 else {
      if (DBG)       Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str"");
      ret=keyStore.importKey(privKeyName,privKeyData,Process.WIFI_UID,KeyStore.FLAG_ENCRYPTED);
      mNeedsSoftwareKeystore=true;
    }
    if (ret == false) {
      return ret;
    }
    ret=putCertInKeyStore(keyStore,userCertName,mClientCertificate);
    if (ret == false) {
      keyStore.delKey(privKeyName,Process.WIFI_UID);
      return ret;
    }
  }
  if (mCaCert != null) {
    ret=putCertInKeyStore(keyStore,caCertName,mCaCert);
    if (ret == false) {
      if (mClientCertificate != null) {
        keyStore.delKey(privKeyName,Process.WIFI_UID);
        keyStore.delete(userCertName,Process.WIFI_UID);
      }
      return ret;
    }
  }
  if (mClientCertificate != null) {
    setClientCertificateAlias(name);
    mClientPrivateKey=null;
    mClientCertificate=null;
  }
  if (mCaCert != null) {
    setCaCertificateAlias(name);
    mCaCert=null;
  }
  return ret;
}"
1014,"void removeKeys(KeyStore keyStore){
  String client=getFieldValue(CLIENT_CERT_KEY,CLIENT_CERT_PREFIX);
  if (!TextUtils.isEmpty(client)) {
    keyStore.delKey(Credentials.USER_PRIVATE_KEY + client,Process.WIFI_UID);
    keyStore.delete(Credentials.USER_CERTIFICATE + client,Process.WIFI_UID);
  }
  String ca=getFieldValue(CA_CERT_KEY,CA_CERT_PREFIX);
  if (!TextUtils.isEmpty(ca)) {
    keyStore.delete(Credentials.CA_CERTIFICATE + ca,Process.WIFI_UID);
  }
}","void removeKeys(KeyStore keyStore){
  String client=getFieldValue(CLIENT_CERT_KEY,CLIENT_CERT_PREFIX);
  if (!TextUtils.isEmpty(client)) {
    if (DBG)     Slog.d(TAG,""String_Node_Str"");
    keyStore.delKey(Credentials.USER_PRIVATE_KEY + client,Process.WIFI_UID);
    keyStore.delete(Credentials.USER_CERTIFICATE + client,Process.WIFI_UID);
  }
  String ca=getFieldValue(CA_CERT_KEY,CA_CERT_PREFIX);
  if (!TextUtils.isEmpty(ca)) {
    if (DBG)     Slog.d(TAG,""String_Node_Str"");
    keyStore.delete(Credentials.CA_CERTIFICATE + ca,Process.WIFI_UID);
  }
}"
1015,"private boolean putCertInKeyStore(android.security.KeyStore keyStore,String name,Certificate cert){
  try {
    byte[] certData=Credentials.convertToPem(cert);
    return keyStore.put(name,certData,Process.WIFI_UID,KeyStore.FLAG_ENCRYPTED);
  }
 catch (  IOException e1) {
    return false;
  }
catch (  CertificateException e2) {
    return false;
  }
}","private boolean putCertInKeyStore(android.security.KeyStore keyStore,String name,Certificate cert){
  try {
    byte[] certData=Credentials.convertToPem(cert);
    if (DBG)     Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str"");
    return keyStore.put(name,certData,Process.WIFI_UID,KeyStore.FLAG_NONE);
  }
 catch (  IOException e1) {
    return false;
  }
catch (  CertificateException e2) {
    return false;
  }
}"
1016,"@Override public boolean bindService(Intent service,ServiceConnection conn,int flags){
  warnIfCallingFromSystemProcess();
  return bindServiceAsUser(service,conn,flags,Process.myUserHandle());
}","@Override public boolean bindService(Intent service,ServiceConnection conn,int flags){
  warnIfCallingFromSystemProcess();
  return bindServiceCommon(service,conn,flags,Process.myUserHandle());
}"
1017,"@Override public ComponentName startServiceAsUser(Intent service,UserHandle user){
  try {
    if (service.getComponent() == null && service.getPackage() == null) {
      if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.KITKAT) {
        IllegalArgumentException ex=new IllegalArgumentException(""String_Node_Str"" + service);
        Log.e(TAG,""String_Node_Str"",ex);
      }
    }
    service.prepareToLeaveProcess();
    ComponentName cn=ActivityManagerNative.getDefault().startService(mMainThread.getApplicationThread(),service,service.resolveTypeIfNeeded(getContentResolver()),user.getIdentifier());
    if (cn != null) {
      if (cn.getPackageName().equals(""String_Node_Str"")) {
        throw new SecurityException(""String_Node_Str"" + service + ""String_Node_Str""+ cn.getClassName());
      }
 else       if (cn.getPackageName().equals(""String_Node_Str"")) {
        throw new SecurityException(""String_Node_Str"" + service + ""String_Node_Str""+ cn.getClassName());
      }
    }
    return cn;
  }
 catch (  RemoteException e) {
    return null;
  }
}","@Override public ComponentName startServiceAsUser(Intent service,UserHandle user){
  return startServiceCommon(service,user);
}"
1018,"@Override public boolean stopServiceAsUser(Intent service,UserHandle user){
  try {
    if (service.getComponent() == null && service.getPackage() == null) {
      if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.KITKAT) {
        IllegalArgumentException ex=new IllegalArgumentException(""String_Node_Str"" + service);
        Log.e(TAG,""String_Node_Str"",ex);
      }
    }
    service.prepareToLeaveProcess();
    int res=ActivityManagerNative.getDefault().stopService(mMainThread.getApplicationThread(),service,service.resolveTypeIfNeeded(getContentResolver()),user.getIdentifier());
    if (res < 0) {
      throw new SecurityException(""String_Node_Str"" + service);
    }
    return res != 0;
  }
 catch (  RemoteException e) {
    return false;
  }
}","@Override public boolean stopServiceAsUser(Intent service,UserHandle user){
  return stopServiceCommon(service,user);
}"
1019,"/** 
 * @hide 
 */
@Override public boolean bindServiceAsUser(Intent service,ServiceConnection conn,int flags,UserHandle user){
  IServiceConnection sd;
  if (conn == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (mPackageInfo != null) {
    sd=mPackageInfo.getServiceDispatcher(conn,getOuterContext(),mMainThread.getHandler(),flags);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (service.getComponent() == null && service.getPackage() == null) {
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.KITKAT) {
      IllegalArgumentException ex=new IllegalArgumentException(""String_Node_Str"" + service);
      Log.e(TAG,""String_Node_Str"",ex);
    }
  }
  try {
    IBinder token=getActivityToken();
    if (token == null && (flags & BIND_AUTO_CREATE) == 0 && mPackageInfo != null && mPackageInfo.getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
      flags|=BIND_WAIVE_PRIORITY;
    }
    service.prepareToLeaveProcess();
    int res=ActivityManagerNative.getDefault().bindService(mMainThread.getApplicationThread(),getActivityToken(),service,service.resolveTypeIfNeeded(getContentResolver()),sd,flags,user.getIdentifier());
    if (res < 0) {
      throw new SecurityException(""String_Node_Str"" + service);
    }
    return res != 0;
  }
 catch (  RemoteException e) {
    return false;
  }
}","/** 
 * @hide 
 */
@Override public boolean bindServiceAsUser(Intent service,ServiceConnection conn,int flags,UserHandle user){
  return bindServiceCommon(service,conn,flags,user);
}"
1020,"@Override public ComponentName startService(Intent service){
  warnIfCallingFromSystemProcess();
  return startServiceAsUser(service,mUser);
}","@Override public ComponentName startService(Intent service){
  warnIfCallingFromSystemProcess();
  return startServiceCommon(service,mUser);
}"
1021,"@Override public boolean stopService(Intent service){
  warnIfCallingFromSystemProcess();
  return stopServiceAsUser(service,mUser);
}","@Override public boolean stopService(Intent service){
  warnIfCallingFromSystemProcess();
  return stopServiceCommon(service,mUser);
}"
1022,"@Override public boolean bindService(Intent service,ServiceConnection conn,int flags){
  warnIfCallingFromSystemProcess();
  return bindServiceAsUser(service,conn,flags,Process.myUserHandle());
}","@Override public boolean bindService(Intent service,ServiceConnection conn,int flags){
  warnIfCallingFromSystemProcess();
  return bindServiceCommon(service,conn,flags,Process.myUserHandle());
}"
1023,"@Override public ComponentName startServiceAsUser(Intent service,UserHandle user){
  try {
    if (service.getComponent() == null && service.getPackage() == null) {
      if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.KITKAT) {
        IllegalArgumentException ex=new IllegalArgumentException(""String_Node_Str"" + service);
        Log.e(TAG,""String_Node_Str"",ex);
      }
    }
    service.prepareToLeaveProcess();
    ComponentName cn=ActivityManagerNative.getDefault().startService(mMainThread.getApplicationThread(),service,service.resolveTypeIfNeeded(getContentResolver()),user.getIdentifier());
    if (cn != null) {
      if (cn.getPackageName().equals(""String_Node_Str"")) {
        throw new SecurityException(""String_Node_Str"" + service + ""String_Node_Str""+ cn.getClassName());
      }
 else       if (cn.getPackageName().equals(""String_Node_Str"")) {
        throw new SecurityException(""String_Node_Str"" + service + ""String_Node_Str""+ cn.getClassName());
      }
    }
    return cn;
  }
 catch (  RemoteException e) {
    return null;
  }
}","@Override public ComponentName startServiceAsUser(Intent service,UserHandle user){
  return startServiceCommon(service,user);
}"
1024,"@Override public boolean stopServiceAsUser(Intent service,UserHandle user){
  try {
    if (service.getComponent() == null && service.getPackage() == null) {
      if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.KITKAT) {
        IllegalArgumentException ex=new IllegalArgumentException(""String_Node_Str"" + service);
        Log.e(TAG,""String_Node_Str"",ex);
      }
    }
    service.prepareToLeaveProcess();
    int res=ActivityManagerNative.getDefault().stopService(mMainThread.getApplicationThread(),service,service.resolveTypeIfNeeded(getContentResolver()),user.getIdentifier());
    if (res < 0) {
      throw new SecurityException(""String_Node_Str"" + service);
    }
    return res != 0;
  }
 catch (  RemoteException e) {
    return false;
  }
}","@Override public boolean stopServiceAsUser(Intent service,UserHandle user){
  return stopServiceCommon(service,user);
}"
1025,"/** 
 * @hide 
 */
@Override public boolean bindServiceAsUser(Intent service,ServiceConnection conn,int flags,UserHandle user){
  IServiceConnection sd;
  if (conn == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (mPackageInfo != null) {
    sd=mPackageInfo.getServiceDispatcher(conn,getOuterContext(),mMainThread.getHandler(),flags);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (service.getComponent() == null && service.getPackage() == null) {
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.KITKAT) {
      IllegalArgumentException ex=new IllegalArgumentException(""String_Node_Str"" + service);
      Log.e(TAG,""String_Node_Str"",ex);
    }
  }
  try {
    IBinder token=getActivityToken();
    if (token == null && (flags & BIND_AUTO_CREATE) == 0 && mPackageInfo != null && mPackageInfo.getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
      flags|=BIND_WAIVE_PRIORITY;
    }
    service.prepareToLeaveProcess();
    int res=ActivityManagerNative.getDefault().bindService(mMainThread.getApplicationThread(),getActivityToken(),service,service.resolveTypeIfNeeded(getContentResolver()),sd,flags,user.getIdentifier());
    if (res < 0) {
      throw new SecurityException(""String_Node_Str"" + service);
    }
    return res != 0;
  }
 catch (  RemoteException e) {
    return false;
  }
}","/** 
 * @hide 
 */
@Override public boolean bindServiceAsUser(Intent service,ServiceConnection conn,int flags,UserHandle user){
  return bindServiceCommon(service,conn,flags,user);
}"
1026,"@Override public ComponentName startService(Intent service){
  warnIfCallingFromSystemProcess();
  return startServiceAsUser(service,mUser);
}","@Override public ComponentName startService(Intent service){
  warnIfCallingFromSystemProcess();
  return startServiceCommon(service,mUser);
}"
1027,"@Override public boolean stopService(Intent service){
  warnIfCallingFromSystemProcess();
  return stopServiceAsUser(service,mUser);
}","@Override public boolean stopService(Intent service){
  warnIfCallingFromSystemProcess();
  return stopServiceCommon(service,mUser);
}"
1028,"/** 
 * TODO: optimize this later (getting just the value part of a Bundle with a single pair) once Bundle.forPair() above is implemented with a special single-value Map implementation/serialization. Note: value in single-pair Bundle may be null.
 * @hide
 */
public String getPairValue(){
  unparcel();
  int size=mMap.size();
  if (size > 1) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
  if (size == 0) {
    return null;
  }
  Object o=mMap.valueAt(0);
  try {
    return (String)o;
  }
 catch (  ClassCastException e) {
    typeWarning(""String_Node_Str"",o,""String_Node_Str"",e);
    return null;
  }
}","/** 
 * TODO: optimize this later (getting just the value part of a Bundle with a single pair) once Bundle.forPair() above is implemented with a special single-value Map implementation/serialization. Note: value in single-pair Bundle may be null.
 * @hide
 */
public String getPairValue(){
  unparcel();
  int size=mMap.size();
  if (size > 1) {
    Log.w(TAG,""String_Node_Str"");
  }
  if (size == 0) {
    return null;
  }
  Object o=mMap.valueAt(0);
  try {
    return (String)o;
  }
 catch (  ClassCastException e) {
    typeWarning(""String_Node_Str"",o,""String_Node_Str"",e);
    return null;
  }
}"
1029,"/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      parcel.writeInt(-1);
      parcel.writeInt(BUNDLE_MAGIC);
      int oldPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int newPos=parcel.dataPosition();
      parcel.setDataPosition(oldPos - 8);
      int length=newPos - oldPos;
      parcel.writeInt(length);
      parcel.setDataPosition(newPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}","/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      int lengthPos=parcel.dataPosition();
      parcel.writeInt(-1);
      parcel.writeInt(BUNDLE_MAGIC);
      int startPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int endPos=parcel.dataPosition();
      parcel.setDataPosition(lengthPos);
      int length=endPos - startPos;
      parcel.writeInt(length);
      parcel.setDataPosition(endPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}"
1030,"/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    return;
  }
  int N=mParcelledData.readInt();
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new ArrayMap<String,Object>(N);
  }
 else {
    mMap.erase();
    mMap.ensureCapacity(N);
  }
  mParcelledData.readArrayMapInternal(mMap,N,mClassLoader);
  mParcelledData.recycle();
  mParcelledData=null;
}","/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
    return;
  }
  int N=mParcelledData.readInt();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ N+ ""String_Node_Str"");
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new ArrayMap<String,Object>(N);
  }
 else {
    mMap.erase();
    mMap.ensureCapacity(N);
  }
  mParcelledData.readArrayMapInternal(mMap,N,mClassLoader);
  mParcelledData.recycle();
  mParcelledData=null;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ mMap);
}"
1031,"void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != BUNDLE_MAGIC) {
    throw new IllegalStateException(""String_Node_Str"" + Integer.toHexString(magic));
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  p.setDataPosition(0);
  if (mMap != null) {
    if (mFdsKnown) {
      mHasFds|=p.hasFileDescriptors();
    }
    int N=p.readInt();
    p.readArrayMapSafelyInternal(mMap,N,mClassLoader);
    p.recycle();
  }
 else {
    mParcelledData=p;
    mHasFds=p.hasFileDescriptors();
    mFdsKnown=true;
  }
}","void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != BUNDLE_MAGIC) {
    throw new IllegalStateException(""String_Node_Str"" + Integer.toHexString(magic));
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ length+ ""String_Node_Str""+ offset);
  p.setDataPosition(0);
  mParcelledData=p;
  mHasFds=p.hasFileDescriptors();
  mFdsKnown=true;
}"
1032,"/** 
 * Read and return a new Bundle object from the parcel at the current dataPosition(), using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects. Returns null if the previously written Bundle object was null.
 */
public final Bundle readBundle(ClassLoader loader){
  int length=readInt();
  if (length < 0) {
    return null;
  }
  final Bundle bundle=new Bundle(this,length);
  if (loader != null) {
    bundle.setClassLoader(loader);
  }
  return bundle;
}","/** 
 * Read and return a new Bundle object from the parcel at the current dataPosition(), using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects. Returns null if the previously written Bundle object was null.
 */
public final Bundle readBundle(ClassLoader loader){
  int length=readInt();
  if (length < 0) {
    if (Bundle.DEBUG)     Log.d(TAG,""String_Node_Str"" + length);
    return null;
  }
  final Bundle bundle=new Bundle(this,length);
  if (loader != null) {
    bundle.setClassLoader(loader);
  }
  return bundle;
}"
1033,"/** 
 * @hide Like  {@link #clear}, but doesn't reduce the capacity of the ArrayMap.
 */
public void erase(){
  if (mSize > 0) {
    final int N=mSize << 1;
    final Object[] array=mArray;
    for (int i=0; i < N; i++) {
      array[i]=null;
    }
  }
}","/** 
 * @hide Like  {@link #clear}, but doesn't reduce the capacity of the ArrayMap.
 */
public void erase(){
  if (mSize > 0) {
    final int N=mSize << 1;
    final Object[] array=mArray;
    for (int i=0; i < N; i++) {
      array[i]=null;
    }
    mSize=0;
  }
}"
1034,"@Override public boolean bindService(Intent service,ServiceConnection conn,int flags){
  warnIfCallingFromSystemProcess();
  return bindServiceAsUser(service,conn,flags,Process.myUserHandle());
}","@Override public boolean bindService(Intent service,ServiceConnection conn,int flags){
  warnIfCallingFromSystemProcess();
  return bindServiceCommon(service,conn,flags,Process.myUserHandle());
}"
1035,"@Override public ComponentName startServiceAsUser(Intent service,UserHandle user){
  try {
    if (service.getComponent() == null && service.getPackage() == null) {
      if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.KITKAT) {
        IllegalArgumentException ex=new IllegalArgumentException(""String_Node_Str"" + service);
        Log.e(TAG,""String_Node_Str"",ex);
      }
    }
    service.prepareToLeaveProcess();
    ComponentName cn=ActivityManagerNative.getDefault().startService(mMainThread.getApplicationThread(),service,service.resolveTypeIfNeeded(getContentResolver()),user.getIdentifier());
    if (cn != null) {
      if (cn.getPackageName().equals(""String_Node_Str"")) {
        throw new SecurityException(""String_Node_Str"" + service + ""String_Node_Str""+ cn.getClassName());
      }
 else       if (cn.getPackageName().equals(""String_Node_Str"")) {
        throw new SecurityException(""String_Node_Str"" + service + ""String_Node_Str""+ cn.getClassName());
      }
    }
    return cn;
  }
 catch (  RemoteException e) {
    return null;
  }
}","@Override public ComponentName startServiceAsUser(Intent service,UserHandle user){
  return startServiceCommon(service,user);
}"
1036,"@Override public boolean stopServiceAsUser(Intent service,UserHandle user){
  try {
    if (service.getComponent() == null && service.getPackage() == null) {
      if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.KITKAT) {
        IllegalArgumentException ex=new IllegalArgumentException(""String_Node_Str"" + service);
        Log.e(TAG,""String_Node_Str"",ex);
      }
    }
    service.prepareToLeaveProcess();
    int res=ActivityManagerNative.getDefault().stopService(mMainThread.getApplicationThread(),service,service.resolveTypeIfNeeded(getContentResolver()),user.getIdentifier());
    if (res < 0) {
      throw new SecurityException(""String_Node_Str"" + service);
    }
    return res != 0;
  }
 catch (  RemoteException e) {
    return false;
  }
}","@Override public boolean stopServiceAsUser(Intent service,UserHandle user){
  return stopServiceCommon(service,user);
}"
1037,"/** 
 * @hide 
 */
@Override public boolean bindServiceAsUser(Intent service,ServiceConnection conn,int flags,UserHandle user){
  IServiceConnection sd;
  if (conn == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (mPackageInfo != null) {
    sd=mPackageInfo.getServiceDispatcher(conn,getOuterContext(),mMainThread.getHandler(),flags);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (service.getComponent() == null && service.getPackage() == null) {
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.KITKAT) {
      IllegalArgumentException ex=new IllegalArgumentException(""String_Node_Str"" + service);
      Log.e(TAG,""String_Node_Str"",ex);
    }
  }
  try {
    IBinder token=getActivityToken();
    if (token == null && (flags & BIND_AUTO_CREATE) == 0 && mPackageInfo != null && mPackageInfo.getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
      flags|=BIND_WAIVE_PRIORITY;
    }
    service.prepareToLeaveProcess();
    int res=ActivityManagerNative.getDefault().bindService(mMainThread.getApplicationThread(),getActivityToken(),service,service.resolveTypeIfNeeded(getContentResolver()),sd,flags,user.getIdentifier());
    if (res < 0) {
      throw new SecurityException(""String_Node_Str"" + service);
    }
    return res != 0;
  }
 catch (  RemoteException e) {
    return false;
  }
}","/** 
 * @hide 
 */
@Override public boolean bindServiceAsUser(Intent service,ServiceConnection conn,int flags,UserHandle user){
  return bindServiceCommon(service,conn,flags,user);
}"
1038,"@Override public ComponentName startService(Intent service){
  warnIfCallingFromSystemProcess();
  return startServiceAsUser(service,mUser);
}","@Override public ComponentName startService(Intent service){
  warnIfCallingFromSystemProcess();
  return startServiceCommon(service,mUser);
}"
1039,"@Override public boolean stopService(Intent service){
  warnIfCallingFromSystemProcess();
  return stopServiceAsUser(service,mUser);
}","@Override public boolean stopService(Intent service){
  warnIfCallingFromSystemProcess();
  return stopServiceCommon(service,mUser);
}"
1040,"/** 
 * TODO: optimize this later (getting just the value part of a Bundle with a single pair) once Bundle.forPair() above is implemented with a special single-value Map implementation/serialization. Note: value in single-pair Bundle may be null.
 * @hide
 */
public String getPairValue(){
  unparcel();
  int size=mMap.size();
  if (size > 1) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
  if (size == 0) {
    return null;
  }
  Object o=mMap.valueAt(0);
  try {
    return (String)o;
  }
 catch (  ClassCastException e) {
    typeWarning(""String_Node_Str"",o,""String_Node_Str"",e);
    return null;
  }
}","/** 
 * TODO: optimize this later (getting just the value part of a Bundle with a single pair) once Bundle.forPair() above is implemented with a special single-value Map implementation/serialization. Note: value in single-pair Bundle may be null.
 * @hide
 */
public String getPairValue(){
  unparcel();
  int size=mMap.size();
  if (size > 1) {
    Log.w(TAG,""String_Node_Str"");
  }
  if (size == 0) {
    return null;
  }
  Object o=mMap.valueAt(0);
  try {
    return (String)o;
  }
 catch (  ClassCastException e) {
    typeWarning(""String_Node_Str"",o,""String_Node_Str"",e);
    return null;
  }
}"
1041,"/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      parcel.writeInt(-1);
      parcel.writeInt(BUNDLE_MAGIC);
      int oldPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int newPos=parcel.dataPosition();
      parcel.setDataPosition(oldPos - 8);
      int length=newPos - oldPos;
      parcel.writeInt(length);
      parcel.setDataPosition(newPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}","/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      int lengthPos=parcel.dataPosition();
      parcel.writeInt(-1);
      parcel.writeInt(BUNDLE_MAGIC);
      int startPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int endPos=parcel.dataPosition();
      parcel.setDataPosition(lengthPos);
      int length=endPos - startPos;
      parcel.writeInt(length);
      parcel.setDataPosition(endPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}"
1042,"/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    return;
  }
  int N=mParcelledData.readInt();
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new ArrayMap<String,Object>(N);
  }
 else {
    mMap.erase();
    mMap.ensureCapacity(N);
  }
  mParcelledData.readArrayMapInternal(mMap,N,mClassLoader);
  mParcelledData.recycle();
  mParcelledData=null;
}","/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
    return;
  }
  int N=mParcelledData.readInt();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ N+ ""String_Node_Str"");
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new ArrayMap<String,Object>(N);
  }
 else {
    mMap.erase();
    mMap.ensureCapacity(N);
  }
  mParcelledData.readArrayMapInternal(mMap,N,mClassLoader);
  mParcelledData.recycle();
  mParcelledData=null;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ mMap);
}"
1043,"void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != BUNDLE_MAGIC) {
    throw new IllegalStateException(""String_Node_Str"" + Integer.toHexString(magic));
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  p.setDataPosition(0);
  if (mMap != null) {
    if (mFdsKnown) {
      mHasFds|=p.hasFileDescriptors();
    }
    int N=p.readInt();
    p.readArrayMapSafelyInternal(mMap,N,mClassLoader);
    p.recycle();
  }
 else {
    mParcelledData=p;
    mHasFds=p.hasFileDescriptors();
    mFdsKnown=true;
  }
}","void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != BUNDLE_MAGIC) {
    throw new IllegalStateException(""String_Node_Str"" + Integer.toHexString(magic));
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ length+ ""String_Node_Str""+ offset);
  p.setDataPosition(0);
  mParcelledData=p;
  mHasFds=p.hasFileDescriptors();
  mFdsKnown=true;
}"
1044,"/** 
 * Read and return a new Bundle object from the parcel at the current dataPosition(), using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects. Returns null if the previously written Bundle object was null.
 */
public final Bundle readBundle(ClassLoader loader){
  int length=readInt();
  if (length < 0) {
    return null;
  }
  final Bundle bundle=new Bundle(this,length);
  if (loader != null) {
    bundle.setClassLoader(loader);
  }
  return bundle;
}","/** 
 * Read and return a new Bundle object from the parcel at the current dataPosition(), using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects. Returns null if the previously written Bundle object was null.
 */
public final Bundle readBundle(ClassLoader loader){
  int length=readInt();
  if (length < 0) {
    if (Bundle.DEBUG)     Log.d(TAG,""String_Node_Str"" + length);
    return null;
  }
  final Bundle bundle=new Bundle(this,length);
  if (loader != null) {
    bundle.setClassLoader(loader);
  }
  return bundle;
}"
1045,"/** 
 * @hide Like  {@link #clear}, but doesn't reduce the capacity of the ArrayMap.
 */
public void erase(){
  if (mSize > 0) {
    final int N=mSize << 1;
    final Object[] array=mArray;
    for (int i=0; i < N; i++) {
      array[i]=null;
    }
  }
}","/** 
 * @hide Like  {@link #clear}, but doesn't reduce the capacity of the ArrayMap.
 */
public void erase(){
  if (mSize > 0) {
    final int N=mSize << 1;
    final Object[] array=mArray;
    for (int i=0; i < N; i++) {
      array[i]=null;
    }
    mSize=0;
  }
}"
1046,"/** 
 * TODO: optimize this later (getting just the value part of a Bundle with a single pair) once Bundle.forPair() above is implemented with a special single-value Map implementation/serialization. Note: value in single-pair Bundle may be null.
 * @hide
 */
public String getPairValue(){
  unparcel();
  int size=mMap.size();
  if (size > 1) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
  if (size == 0) {
    return null;
  }
  Object o=mMap.valueAt(0);
  try {
    return (String)o;
  }
 catch (  ClassCastException e) {
    typeWarning(""String_Node_Str"",o,""String_Node_Str"",e);
    return null;
  }
}","/** 
 * TODO: optimize this later (getting just the value part of a Bundle with a single pair) once Bundle.forPair() above is implemented with a special single-value Map implementation/serialization. Note: value in single-pair Bundle may be null.
 * @hide
 */
public String getPairValue(){
  unparcel();
  int size=mMap.size();
  if (size > 1) {
    Log.w(TAG,""String_Node_Str"");
  }
  if (size == 0) {
    return null;
  }
  Object o=mMap.valueAt(0);
  try {
    return (String)o;
  }
 catch (  ClassCastException e) {
    typeWarning(""String_Node_Str"",o,""String_Node_Str"",e);
    return null;
  }
}"
1047,"/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      parcel.writeInt(-1);
      parcel.writeInt(BUNDLE_MAGIC);
      int oldPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int newPos=parcel.dataPosition();
      parcel.setDataPosition(oldPos - 8);
      int length=newPos - oldPos;
      parcel.writeInt(length);
      parcel.setDataPosition(newPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}","/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      int lengthPos=parcel.dataPosition();
      parcel.writeInt(-1);
      parcel.writeInt(BUNDLE_MAGIC);
      int startPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int endPos=parcel.dataPosition();
      parcel.setDataPosition(lengthPos);
      int length=endPos - startPos;
      parcel.writeInt(length);
      parcel.setDataPosition(endPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}"
1048,"/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    return;
  }
  int N=mParcelledData.readInt();
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new ArrayMap<String,Object>(N);
  }
 else {
    mMap.erase();
    mMap.ensureCapacity(N);
  }
  mParcelledData.readArrayMapInternal(mMap,N,mClassLoader);
  mParcelledData.recycle();
  mParcelledData=null;
}","/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
    return;
  }
  int N=mParcelledData.readInt();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ N+ ""String_Node_Str"");
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new ArrayMap<String,Object>(N);
  }
 else {
    mMap.erase();
    mMap.ensureCapacity(N);
  }
  mParcelledData.readArrayMapInternal(mMap,N,mClassLoader);
  mParcelledData.recycle();
  mParcelledData=null;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ mMap);
}"
1049,"void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != BUNDLE_MAGIC) {
    throw new IllegalStateException(""String_Node_Str"" + Integer.toHexString(magic));
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  p.setDataPosition(0);
  if (mMap != null) {
    if (mFdsKnown) {
      mHasFds|=p.hasFileDescriptors();
    }
    int N=p.readInt();
    p.readArrayMapSafelyInternal(mMap,N,mClassLoader);
    p.recycle();
  }
 else {
    mParcelledData=p;
    mHasFds=p.hasFileDescriptors();
    mFdsKnown=true;
  }
}","void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != BUNDLE_MAGIC) {
    throw new IllegalStateException(""String_Node_Str"" + Integer.toHexString(magic));
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ length+ ""String_Node_Str""+ offset);
  p.setDataPosition(0);
  mParcelledData=p;
  mHasFds=p.hasFileDescriptors();
  mFdsKnown=true;
}"
1050,"/** 
 * Read and return a new Bundle object from the parcel at the current dataPosition(), using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects. Returns null if the previously written Bundle object was null.
 */
public final Bundle readBundle(ClassLoader loader){
  int length=readInt();
  if (length < 0) {
    return null;
  }
  final Bundle bundle=new Bundle(this,length);
  if (loader != null) {
    bundle.setClassLoader(loader);
  }
  return bundle;
}","/** 
 * Read and return a new Bundle object from the parcel at the current dataPosition(), using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects. Returns null if the previously written Bundle object was null.
 */
public final Bundle readBundle(ClassLoader loader){
  int length=readInt();
  if (length < 0) {
    if (Bundle.DEBUG)     Log.d(TAG,""String_Node_Str"" + length);
    return null;
  }
  final Bundle bundle=new Bundle(this,length);
  if (loader != null) {
    bundle.setClassLoader(loader);
  }
  return bundle;
}"
1051,"/** 
 * @hide Like  {@link #clear}, but doesn't reduce the capacity of the ArrayMap.
 */
public void erase(){
  if (mSize > 0) {
    final int N=mSize << 1;
    final Object[] array=mArray;
    for (int i=0; i < N; i++) {
      array[i]=null;
    }
  }
}","/** 
 * @hide Like  {@link #clear}, but doesn't reduce the capacity of the ArrayMap.
 */
public void erase(){
  if (mSize > 0) {
    final int N=mSize << 1;
    final Object[] array=mArray;
    for (int i=0; i < N; i++) {
      array[i]=null;
    }
    mSize=0;
  }
}"
1052,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_SCREEN_ON)) {
    mWifiController.sendMessage(CMD_SCREEN_ON);
  }
 else   if (action.equals(Intent.ACTION_SCREEN_OFF)) {
    mWifiController.sendMessage(CMD_SCREEN_OFF);
  }
 else   if (action.equals(Intent.ACTION_BATTERY_CHANGED)) {
    int pluggedType=intent.getIntExtra(""String_Node_Str"",0);
    mWifiController.sendMessage(CMD_BATTERY_CHANGED,pluggedType,0,null);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE,BluetoothAdapter.STATE_DISCONNECTED);
    mWifiStateMachine.sendBluetoothAdapterStateChange(state);
  }
 else   if (action.equals(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED)) {
    boolean emergencyMode=intent.getBooleanExtra(""String_Node_Str"",false);
    mWifiController.sendMessage(CMD_EMERGENCY_MODE_CHANGED,emergencyMode ? 1 : 0,0);
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_SCREEN_ON)) {
    mWifiController.sendMessage(CMD_SCREEN_ON);
  }
 else   if (action.equals(Intent.ACTION_USER_PRESENT)) {
    mWifiController.sendMessage(CMD_USER_PRESENT);
  }
 else   if (action.equals(Intent.ACTION_SCREEN_OFF)) {
    mWifiController.sendMessage(CMD_SCREEN_OFF);
  }
 else   if (action.equals(Intent.ACTION_BATTERY_CHANGED)) {
    int pluggedType=intent.getIntExtra(""String_Node_Str"",0);
    mWifiController.sendMessage(CMD_BATTERY_CHANGED,pluggedType,0,null);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE,BluetoothAdapter.STATE_DISCONNECTED);
    mWifiStateMachine.sendBluetoothAdapterStateChange(state);
  }
 else   if (action.equals(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED)) {
    boolean emergencyMode=intent.getBooleanExtra(""String_Node_Str"",false);
    mWifiController.sendMessage(CMD_EMERGENCY_MODE_CHANGED,emergencyMode ? 1 : 0,0);
  }
}"
1053,"private void registerForBroadcasts(){
  IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(Intent.ACTION_SCREEN_ON);
  intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
  intentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  intentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
  intentFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
  intentFilter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
  mContext.registerReceiver(mReceiver,intentFilter);
}","private void registerForBroadcasts(){
  IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(Intent.ACTION_SCREEN_ON);
  intentFilter.addAction(Intent.ACTION_USER_PRESENT);
  intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
  intentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  intentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
  intentFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
  intentFilter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
  mContext.registerReceiver(mReceiver,intentFilter);
}"
1054,"/** 
 * Read the variables from the supplicant daemon that are needed to fill in the WifiConfiguration object.
 * @param config the {@link WifiConfiguration} object to be filled in.
 */
private void readNetworkVariables(WifiConfiguration config){
  int netId=config.networkId;
  if (netId < 0)   return;
  String value;
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.ssidVarName);
  if (!TextUtils.isEmpty(value)) {
    if (value.charAt(0) != '""') {
      config.SSID=""String_Node_Str"" + WifiSsid.createFromHex(value).toString() + ""String_Node_Str"";
    }
 else {
      config.SSID=value;
    }
  }
 else {
    config.SSID=null;
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.bssidVarName);
  if (!TextUtils.isEmpty(value)) {
    config.BSSID=value;
  }
 else {
    config.BSSID=null;
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.priorityVarName);
  config.priority=-1;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.priority=Integer.parseInt(value);
    }
 catch (    NumberFormatException ignore) {
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.hiddenSSIDVarName);
  config.hiddenSSID=false;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.hiddenSSID=Integer.parseInt(value) != 0;
    }
 catch (    NumberFormatException ignore) {
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.wepTxKeyIdxVarName);
  config.wepTxKeyIndex=-1;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.wepTxKeyIndex=Integer.parseInt(value);
    }
 catch (    NumberFormatException ignore) {
    }
  }
  for (int i=0; i < 4; i++) {
    value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.wepKeyVarNames[i]);
    if (!TextUtils.isEmpty(value)) {
      config.wepKeys[i]=value;
    }
 else {
      config.wepKeys[i]=null;
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.pskVarName);
  if (!TextUtils.isEmpty(value)) {
    config.preSharedKey=value;
  }
 else {
    config.preSharedKey=null;
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.Protocol.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.Protocol.strings);
      if (0 <= index) {
        config.allowedProtocols.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.KeyMgmt.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.KeyMgmt.strings);
      if (0 <= index) {
        config.allowedKeyManagement.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.AuthAlgorithm.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.AuthAlgorithm.strings);
      if (0 <= index) {
        config.allowedAuthAlgorithms.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.PairwiseCipher.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.PairwiseCipher.strings);
      if (0 <= index) {
        config.allowedPairwiseCiphers.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.GroupCipher.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.GroupCipher.strings);
      if (0 <= index) {
        config.allowedGroupCiphers.set(index);
      }
    }
  }
  if (config.enterpriseConfig == null) {
    config.enterpriseConfig=new WifiEnterpriseConfig();
  }
  HashMap<String,String> enterpriseFields=config.enterpriseConfig.getFields();
  for (  String key : WifiEnterpriseConfig.getSupplicantKeys()) {
    value=mWifiNative.getNetworkVariable(netId,key);
    if (!TextUtils.isEmpty(value)) {
      enterpriseFields.put(key,removeDoubleQuotes(value));
    }
 else {
      enterpriseFields.put(key,WifiEnterpriseConfig.EMPTY_VALUE);
    }
  }
  if (config.enterpriseConfig.migrateOldEapTlsNative(mWifiNative,netId)) {
    saveConfig();
  }
  config.enterpriseConfig.migrateCerts(mKeyStore);
}","/** 
 * Read the variables from the supplicant daemon that are needed to fill in the WifiConfiguration object.
 * @param config the {@link WifiConfiguration} object to be filled in.
 */
private void readNetworkVariables(WifiConfiguration config){
  int netId=config.networkId;
  if (netId < 0)   return;
  String value;
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.ssidVarName);
  if (!TextUtils.isEmpty(value)) {
    if (value.charAt(0) != '""') {
      config.SSID=""String_Node_Str"" + WifiSsid.createFromHex(value).toString() + ""String_Node_Str"";
    }
 else {
      config.SSID=value;
    }
  }
 else {
    config.SSID=null;
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.bssidVarName);
  if (!TextUtils.isEmpty(value)) {
    config.BSSID=value;
  }
 else {
    config.BSSID=null;
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.priorityVarName);
  config.priority=-1;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.priority=Integer.parseInt(value);
    }
 catch (    NumberFormatException ignore) {
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.hiddenSSIDVarName);
  config.hiddenSSID=false;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.hiddenSSID=Integer.parseInt(value) != 0;
    }
 catch (    NumberFormatException ignore) {
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.wepTxKeyIdxVarName);
  config.wepTxKeyIndex=-1;
  if (!TextUtils.isEmpty(value)) {
    try {
      config.wepTxKeyIndex=Integer.parseInt(value);
    }
 catch (    NumberFormatException ignore) {
    }
  }
  for (int i=0; i < 4; i++) {
    value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.wepKeyVarNames[i]);
    if (!TextUtils.isEmpty(value)) {
      config.wepKeys[i]=value;
    }
 else {
      config.wepKeys[i]=null;
    }
  }
  value=mWifiNative.getNetworkVariable(netId,WifiConfiguration.pskVarName);
  if (!TextUtils.isEmpty(value)) {
    config.preSharedKey=value;
  }
 else {
    config.preSharedKey=null;
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.Protocol.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.Protocol.strings);
      if (0 <= index) {
        config.allowedProtocols.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.KeyMgmt.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.KeyMgmt.strings);
      if (0 <= index) {
        config.allowedKeyManagement.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.AuthAlgorithm.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.AuthAlgorithm.strings);
      if (0 <= index) {
        config.allowedAuthAlgorithms.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.PairwiseCipher.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.PairwiseCipher.strings);
      if (0 <= index) {
        config.allowedPairwiseCiphers.set(index);
      }
    }
  }
  value=mWifiNative.getNetworkVariable(config.networkId,WifiConfiguration.GroupCipher.varName);
  if (!TextUtils.isEmpty(value)) {
    String vals[]=value.split(""String_Node_Str"");
    for (    String val : vals) {
      int index=lookupString(val,WifiConfiguration.GroupCipher.strings);
      if (0 <= index) {
        config.allowedGroupCiphers.set(index);
      }
    }
  }
  if (config.enterpriseConfig == null) {
    config.enterpriseConfig=new WifiEnterpriseConfig();
  }
  HashMap<String,String> enterpriseFields=config.enterpriseConfig.getFields();
  for (  String key : WifiEnterpriseConfig.getSupplicantKeys()) {
    value=mWifiNative.getNetworkVariable(netId,key);
    if (!TextUtils.isEmpty(value)) {
      enterpriseFields.put(key,removeDoubleQuotes(value));
    }
 else {
      enterpriseFields.put(key,WifiEnterpriseConfig.EMPTY_VALUE);
    }
  }
  if (config.enterpriseConfig.migrateOldEapTlsNative(mWifiNative,netId)) {
    saveConfig();
  }
  config.enterpriseConfig.migrateCerts(mKeyStore);
  config.enterpriseConfig.initializeSoftwareKeystoreFlag(mKeyStore);
}"
1055,"boolean installKeys(android.security.KeyStore keyStore,String name){
  boolean ret=true;
  String privKeyName=Credentials.USER_PRIVATE_KEY + name;
  String userCertName=Credentials.USER_CERTIFICATE + name;
  String caCertName=Credentials.CA_CERTIFICATE + name;
  if (mClientCertificate != null) {
    byte[] privKeyData=mClientPrivateKey.getEncoded();
    ret=keyStore.importKey(privKeyName,privKeyData,Process.WIFI_UID,KeyStore.FLAG_ENCRYPTED);
    if (ret == false) {
      return ret;
    }
    ret=putCertInKeyStore(keyStore,userCertName,mClientCertificate);
    if (ret == false) {
      keyStore.delKey(privKeyName,Process.WIFI_UID);
      return ret;
    }
  }
  if (mCaCert != null) {
    ret=putCertInKeyStore(keyStore,caCertName,mCaCert);
    if (ret == false) {
      if (mClientCertificate != null) {
        keyStore.delKey(privKeyName,Process.WIFI_UID);
        keyStore.delete(userCertName,Process.WIFI_UID);
      }
      return ret;
    }
  }
  if (mClientCertificate != null) {
    setClientCertificateAlias(name);
    mClientPrivateKey=null;
    mClientCertificate=null;
  }
  if (mCaCert != null) {
    setCaCertificateAlias(name);
    mCaCert=null;
  }
  return ret;
}","boolean installKeys(android.security.KeyStore keyStore,String name){
  boolean ret=true;
  String privKeyName=Credentials.USER_PRIVATE_KEY + name;
  String userCertName=Credentials.USER_CERTIFICATE + name;
  String caCertName=Credentials.CA_CERTIFICATE + name;
  if (mClientCertificate != null) {
    byte[] privKeyData=mClientPrivateKey.getEncoded();
    if (isHardwareBackedKey(mClientPrivateKey)) {
      if (DBG)       Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
      ret=keyStore.importKey(privKeyName,privKeyData,Process.WIFI_UID,KeyStore.FLAG_NONE);
    }
 else {
      if (DBG)       Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str"");
      ret=keyStore.importKey(privKeyName,privKeyData,Process.WIFI_UID,KeyStore.FLAG_ENCRYPTED);
      mNeedsSoftwareKeystore=true;
    }
    if (ret == false) {
      return ret;
    }
    ret=putCertInKeyStore(keyStore,userCertName,mClientCertificate);
    if (ret == false) {
      keyStore.delKey(privKeyName,Process.WIFI_UID);
      return ret;
    }
  }
  if (mCaCert != null) {
    ret=putCertInKeyStore(keyStore,caCertName,mCaCert);
    if (ret == false) {
      if (mClientCertificate != null) {
        keyStore.delKey(privKeyName,Process.WIFI_UID);
        keyStore.delete(userCertName,Process.WIFI_UID);
      }
      return ret;
    }
  }
  if (mClientCertificate != null) {
    setClientCertificateAlias(name);
    mClientPrivateKey=null;
    mClientCertificate=null;
  }
  if (mCaCert != null) {
    setCaCertificateAlias(name);
    mCaCert=null;
  }
  return ret;
}"
1056,"void removeKeys(KeyStore keyStore){
  String client=getFieldValue(CLIENT_CERT_KEY,CLIENT_CERT_PREFIX);
  if (!TextUtils.isEmpty(client)) {
    keyStore.delKey(Credentials.USER_PRIVATE_KEY + client,Process.WIFI_UID);
    keyStore.delete(Credentials.USER_CERTIFICATE + client,Process.WIFI_UID);
  }
  String ca=getFieldValue(CA_CERT_KEY,CA_CERT_PREFIX);
  if (!TextUtils.isEmpty(ca)) {
    keyStore.delete(Credentials.CA_CERTIFICATE + ca,Process.WIFI_UID);
  }
}","void removeKeys(KeyStore keyStore){
  String client=getFieldValue(CLIENT_CERT_KEY,CLIENT_CERT_PREFIX);
  if (!TextUtils.isEmpty(client)) {
    if (DBG)     Slog.d(TAG,""String_Node_Str"");
    keyStore.delKey(Credentials.USER_PRIVATE_KEY + client,Process.WIFI_UID);
    keyStore.delete(Credentials.USER_CERTIFICATE + client,Process.WIFI_UID);
  }
  String ca=getFieldValue(CA_CERT_KEY,CA_CERT_PREFIX);
  if (!TextUtils.isEmpty(ca)) {
    if (DBG)     Slog.d(TAG,""String_Node_Str"");
    keyStore.delete(Credentials.CA_CERTIFICATE + ca,Process.WIFI_UID);
  }
}"
1057,"private boolean putCertInKeyStore(android.security.KeyStore keyStore,String name,Certificate cert){
  try {
    byte[] certData=Credentials.convertToPem(cert);
    return keyStore.put(name,certData,Process.WIFI_UID,KeyStore.FLAG_ENCRYPTED);
  }
 catch (  IOException e1) {
    return false;
  }
catch (  CertificateException e2) {
    return false;
  }
}","private boolean putCertInKeyStore(android.security.KeyStore keyStore,String name,Certificate cert){
  try {
    byte[] certData=Credentials.convertToPem(cert);
    if (DBG)     Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str"");
    return keyStore.put(name,certData,Process.WIFI_UID,KeyStore.FLAG_NONE);
  }
 catch (  IOException e1) {
    return false;
  }
catch (  CertificateException e2) {
    return false;
  }
}"
1058,"/** 
 * What a Terrible Failure: Report an exception that should never happen. Similar to   {@link #wtf(String,Throwable)}, with a message as well.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 * @param tr An exception to log.  May be null.
 */
public static int wtf(String tag,String msg,Throwable tr){
  TerribleFailure what=new TerribleFailure(msg,tr);
  int bytes=println_native(LOG_ID_MAIN,ASSERT,tag,msg + '\n' + getStackTraceString(tr));
  sWtfHandler.onTerribleFailure(tag,what);
  return bytes;
}","static int wtf(int logId,String tag,String msg,Throwable tr){
  TerribleFailure what=new TerribleFailure(msg,tr);
  int bytes=println_native(logId,ASSERT,tag,msg + '\n' + getStackTraceString(tr));
  sWtfHandler.onTerribleFailure(tag,what);
  return bytes;
}"
1059,"void dumpFilteredSummaryLocked(PrintWriter pw,String header,String prefix,int[] screenStates,int[] memStates,int[] procStates,int[] sortProcStates,long now,long totalTime,String reqPackage){
  ArrayList<ProcessState> procs=collectProcessesLocked(screenStates,memStates,procStates,sortProcStates,now,reqPackage);
  if (procs.size() > 0) {
    if (header != null) {
      pw.println();
      pw.println(header);
    }
    dumpProcessSummaryLocked(pw,prefix,procs,screenStates,memStates,sortProcStates,now,totalTime);
  }
}","void dumpFilteredSummaryLocked(PrintWriter pw,String header,String prefix,int[] screenStates,int[] memStates,int[] procStates,int[] sortProcStates,long now,long totalTime,String reqPackage,boolean activeOnly){
  ArrayList<ProcessState> procs=collectProcessesLocked(screenStates,memStates,procStates,sortProcStates,now,reqPackage,activeOnly);
  if (procs.size() > 0) {
    if (header != null) {
      pw.println();
      pw.println(header);
    }
    dumpProcessSummaryLocked(pw,prefix,procs,screenStates,memStates,sortProcStates,now,totalTime);
  }
}"
1060,"public void setExecuting(boolean executing,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addDuration(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
    updateRunning(memFactor,now);
  }
}","public void setExecuting(boolean executing,int memFactor,long now){
  if (mOwner == null) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addDuration(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
    updateRunning(memFactor,now);
  }
}"
1061,"private void ensureNotDead(){
  if (!mDead) {
    return;
  }
  throw new IllegalStateException(""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
}","private void ensureNotDead(){
  if (!mDead) {
    return;
  }
  Slog.wtfStack(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
}"
1062,"public ProcessStats.ServiceState getServiceStateLocked(String packageName,int uid,String processName,String className){
  final ProcessStats.PackageState as=getPackageStateLocked(packageName,uid);
  ProcessStats.ServiceState ss=as.mServices.get(className);
  if (ss != null) {
    return ss;
  }
  final ProcessStats.ProcessState ps=processName != null ? getProcessStateLocked(packageName,uid,processName) : null;
  ss=new ProcessStats.ServiceState(this,packageName,className,processName,ps);
  as.mServices.put(className,ss);
  return ss;
}","public ProcessStats.ServiceState getServiceStateLocked(String packageName,int uid,String processName,String className){
  final ProcessStats.PackageState as=getPackageStateLocked(packageName,uid);
  ProcessStats.ServiceState ss=as.mServices.get(className);
  if (ss != null) {
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + ss);
    return ss;
  }
  final ProcessStats.ProcessState ps=processName != null ? getProcessStateLocked(packageName,uid,processName) : null;
  ss=new ProcessStats.ServiceState(this,packageName,className,processName,ps);
  as.mServices.put(className,ss);
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + ss + ""String_Node_Str""+ ps);
  return ss;
}"
1063,"private int[] readTableFromParcel(Parcel in,String name,String what){
  final int size=in.readInt();
  if (size < 0) {
    Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ size);
    return BAD_TABLE;
  }
  if (size == 0) {
    return null;
  }
  final int[] table=new int[size];
  for (int i=0; i < size; i++) {
    table[i]=in.readInt();
    if (DEBUG)     Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ i+ ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
    if (!validateLongOffset(table[i])) {
      Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
      return null;
    }
  }
  return table;
}","private int[] readTableFromParcel(Parcel in,String name,String what){
  final int size=in.readInt();
  if (size < 0) {
    Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ size);
    return BAD_TABLE;
  }
  if (size == 0) {
    return null;
  }
  final int[] table=new int[size];
  for (int i=0; i < size; i++) {
    table[i]=in.readInt();
    if (DEBUG_PARCEL)     Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ i+ ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
    if (!validateLongOffset(table[i])) {
      Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
      return null;
    }
  }
  return table;
}"
1064,"public void makeActive(){
  if (mActive == 0) {
    mProc.incActiveServices();
  }
  mActive++;
}","public void makeActive(){
  ensureNotDead();
  mActive=true;
}"
1065,"public void makeInactive(){
  mActive--;
  if (mActive == 0) {
    mProc.decActiveServices();
  }
}","public void makeInactive(){
  mActive=false;
}"
1066,"public ProcessState getProcessStateLocked(String packageName,int uid,String processName){
  final PackageState pkgState=getPackageStateLocked(packageName,uid);
  ProcessState ps=pkgState.mProcesses.get(processName);
  if (ps != null) {
    return ps;
  }
  ProcessState commonProc=mProcesses.get(processName,uid);
  if (commonProc == null) {
    commonProc=new ProcessState(this,packageName,uid,processName);
    mProcesses.put(processName,uid,commonProc);
  }
  if (!commonProc.mMultiPackage) {
    if (packageName.equals(commonProc.mPackage)) {
      ps=commonProc;
    }
 else {
      commonProc.mMultiPackage=true;
      long now=SystemClock.uptimeMillis();
      final PackageState commonPkgState=getPackageStateLocked(commonProc.mPackage,uid);
      if (commonPkgState != null) {
        commonPkgState.mProcesses.put(commonProc.mName,commonProc.clone(commonProc.mPackage,now));
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + commonProc.mPackage + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc.mName);
      }
      ps=new ProcessState(commonProc,packageName,uid,processName,now);
    }
  }
 else {
    ps=new ProcessState(commonProc,packageName,uid,processName,SystemClock.uptimeMillis());
  }
  pkgState.mProcesses.put(processName,ps);
  return ps;
}","public ProcessState getProcessStateLocked(String packageName,int uid,String processName){
  final PackageState pkgState=getPackageStateLocked(packageName,uid);
  ProcessState ps=pkgState.mProcesses.get(processName);
  if (ps != null) {
    return ps;
  }
  ProcessState commonProc=mProcesses.get(processName,uid);
  if (commonProc == null) {
    commonProc=new ProcessState(this,packageName,uid,processName);
    mProcesses.put(processName,uid,commonProc);
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + commonProc);
  }
  if (!commonProc.mMultiPackage) {
    if (packageName.equals(commonProc.mPackage)) {
      ps=commonProc;
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + commonProc);
    }
 else {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"");
      commonProc.mMultiPackage=true;
      long now=SystemClock.uptimeMillis();
      final PackageState commonPkgState=getPackageStateLocked(commonProc.mPackage,uid);
      if (commonPkgState != null) {
        ProcessState cloned=commonProc.clone(commonProc.mPackage,now);
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"" + commonProc.mPackage + ""String_Node_Str""+ cloned);
        commonPkgState.mProcesses.put(commonProc.mName,cloned);
        for (int i=commonPkgState.mServices.size() - 1; i >= 0; i--) {
          ServiceState ss=commonPkgState.mServices.valueAt(i);
          if (ss.mProc == commonProc) {
            if (DEBUG)             Slog.d(TAG,""String_Node_Str"" + ss);
            ss.mProc=cloned;
          }
 else           if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"" + ss);
          }
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + commonProc.mPackage + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc.mName);
      }
      ps=new ProcessState(commonProc,packageName,uid,processName,now);
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + ps);
    }
  }
 else {
    ps=new ProcessState(commonProc,packageName,uid,processName,SystemClock.uptimeMillis());
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + ps);
  }
  pkgState.mProcesses.put(processName,ps);
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + ps);
  return ps;
}"
1067,"void incActiveServices(){
  if (mCommonProcess != this) {
    mCommonProcess.incActiveServices();
  }
  mNumActiveServices++;
}","void incActiveServices(String serviceName){
  if (DEBUG && ""String_Node_Str"".equals(mName)) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.d(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ (mNumActiveServices + 1),here);
  }
  if (mCommonProcess != this) {
    mCommonProcess.incActiveServices(serviceName);
  }
  mNumActiveServices++;
}"
1068,"public void dumpSummaryLocked(PrintWriter pw,String reqPackage,long now){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  dumpFilteredSummaryLocked(pw,null,""String_Node_Str"",ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,NON_CACHED_PROC_STATES,now,totalTime,reqPackage);
  pw.println();
  dumpTotalsLocked(pw,now);
}","public void dumpSummaryLocked(PrintWriter pw,String reqPackage,long now,boolean activeOnly){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  dumpFilteredSummaryLocked(pw,null,""String_Node_Str"",ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,NON_CACHED_PROC_STATES,now,totalTime,reqPackage,activeOnly);
  pw.println();
  dumpTotalsLocked(pw,now);
}"
1069,"boolean validateLongOffset(int off){
  int arr=(off >> OFFSET_ARRAY_SHIFT) & OFFSET_ARRAY_MASK;
  if (arr >= mLongs.size()) {
    return false;
  }
  int idx=(off >> OFFSET_INDEX_SHIFT) & OFFSET_INDEX_MASK;
  if (idx >= LONGS_SIZE) {
    return false;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + printLongOffset(off) + ""String_Node_Str""+ getLong(off,0));
  return true;
}","boolean validateLongOffset(int off){
  int arr=(off >> OFFSET_ARRAY_SHIFT) & OFFSET_ARRAY_MASK;
  if (arr >= mLongs.size()) {
    return false;
  }
  int idx=(off >> OFFSET_INDEX_SHIFT) & OFFSET_INDEX_MASK;
  if (idx >= LONGS_SIZE) {
    return false;
  }
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"" + printLongOffset(off) + ""String_Node_Str""+ getLong(off,0));
  return true;
}"
1070,"public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpSummary,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (!dumpSummary || dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        pw.print(""String_Node_Str"");
        pw.println(svc.mProcessName);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mRunCount,ServiceState.SERVICE_RUN,svc.mRunState,svc.mRunStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,!dumpSummary || dumpAll);
        if (dumpAll) {
          pw.print(""String_Node_Str"");
          pw.println(svc.mActive);
        }
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    int numShownProcs=0, numTotalProcs=0;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        numTotalProcs++;
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        numShownProcs++;
        if (!printedHeader) {
          pw.println();
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
        if (dumpAll) {
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
    }
    if (dumpAll) {
      pw.println();
      pw.print(""String_Node_Str"");
      pw.print(numShownProcs);
      pw.print(""String_Node_Str"");
      pw.print(numTotalProcs);
      pw.println(""String_Node_Str"");
    }
    pw.println();
    if (dumpSummary) {
      pw.println(""String_Node_Str"");
      dumpSummaryLocked(pw,reqPackage,now);
    }
 else {
      dumpTotalsLocked(pw,now);
    }
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}","public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpSummary,boolean dumpAll,boolean activeOnly){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (!dumpSummary || dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (activeOnly && !proc.isInUse()) {
            pw.print(""String_Node_Str"");
            pw.print(pkgState.mProcesses.keyAt(iproc));
            pw.println(""String_Node_Str"");
            continue;
          }
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (activeOnly && !proc.isInUse()) {
            continue;
          }
          procs.add(proc);
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        if (activeOnly && !svc.isInUse()) {
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mServices.keyAt(isvc));
          pw.println(""String_Node_Str"");
          continue;
        }
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(svc.mProcessName);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mRunCount,ServiceState.SERVICE_RUN,svc.mRunState,svc.mRunStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,!dumpSummary || dumpAll);
        if (dumpAll) {
          if (svc.mOwner != null) {
            pw.print(""String_Node_Str"");
            pw.println(svc.mOwner);
          }
        }
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    int numShownProcs=0, numTotalProcs=0;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        numTotalProcs++;
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        numShownProcs++;
        if (!printedHeader) {
          pw.println();
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        if (activeOnly && !proc.isInUse()) {
          pw.print(""String_Node_Str"");
          pw.print(procName);
          pw.println(""String_Node_Str"");
          continue;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
        if (dumpAll) {
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
    }
    if (dumpAll) {
      pw.println();
      pw.print(""String_Node_Str"");
      pw.print(numShownProcs);
      pw.print(""String_Node_Str"");
      pw.print(numTotalProcs);
      pw.println(""String_Node_Str"");
    }
    pw.println();
    if (dumpSummary) {
      pw.println(""String_Node_Str"");
      dumpSummaryLocked(pw,reqPackage,now,activeOnly);
    }
 else {
      dumpTotalsLocked(pw,now);
    }
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}"
1071,"static byte[] readFully(InputStream stream,int[] outLen) throws IOException {
  int pos=0;
  final int initialAvail=stream.available();
  byte[] data=new byte[initialAvail > 0 ? (initialAvail + 1) : 16384];
  while (true) {
    int amt=stream.read(data,pos,data.length - pos);
    if (DEBUG)     Slog.i(""String_Node_Str"",""String_Node_Str"" + amt + ""String_Node_Str""+ pos+ ""String_Node_Str""+ data.length);
    if (amt < 0) {
      if (DEBUG)       Slog.i(""String_Node_Str"",""String_Node_Str"" + pos + ""String_Node_Str""+ data.length);
      outLen[0]=pos;
      return data;
    }
    pos+=amt;
    if (pos >= data.length) {
      byte[] newData=new byte[pos + 16384];
      if (DEBUG)       Slog.i(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ newData.length);
      System.arraycopy(data,0,newData,0,pos);
      data=newData;
    }
  }
}","static byte[] readFully(InputStream stream,int[] outLen) throws IOException {
  int pos=0;
  final int initialAvail=stream.available();
  byte[] data=new byte[initialAvail > 0 ? (initialAvail + 1) : 16384];
  while (true) {
    int amt=stream.read(data,pos,data.length - pos);
    if (DEBUG_PARCEL)     Slog.i(""String_Node_Str"",""String_Node_Str"" + amt + ""String_Node_Str""+ pos+ ""String_Node_Str""+ data.length);
    if (amt < 0) {
      if (DEBUG_PARCEL)       Slog.i(""String_Node_Str"",""String_Node_Str"" + pos + ""String_Node_Str""+ data.length);
      outLen[0]=pos;
      return data;
    }
    pos+=amt;
    if (pos >= data.length) {
      byte[] newData=new byte[pos + 16384];
      if (DEBUG_PARCEL)       Slog.i(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ newData.length);
      System.arraycopy(data,0,newData,0,pos);
      data=newData;
    }
  }
}"
1072,"public void setStarted(boolean started,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final boolean wasStarted=mStartedState != STATE_NOTHING;
  final int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addDuration(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    mProc=mProc.pullFixedProc(mPackage);
    if (wasStarted != started) {
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
    updateRunning(memFactor,now);
  }
}","public void setStarted(boolean started,int memFactor,long now){
  if (mOwner == null) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final boolean wasStarted=mStartedState != STATE_NOTHING;
  final int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addDuration(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    mProc=mProc.pullFixedProc(mPackage);
    if (wasStarted != started) {
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
    updateRunning(memFactor,now);
  }
}"
1073,"public ArrayList<ProcessState> collectProcessesLocked(int[] screenStates,int[] memStates,int[] procStates,int sortProcStates[],long now,String reqPackage){
  ArraySet<ProcessState> foundProcs=new ArraySet<ProcessState>();
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    if (reqPackage != null && !reqPackage.equals(pkgMap.keyAt(ip))) {
      continue;
    }
    SparseArray<PackageState> procs=pkgMap.valueAt(ip);
    for (int iu=0; iu < procs.size(); iu++) {
      PackageState state=procs.valueAt(iu);
      for (int iproc=0; iproc < state.mProcesses.size(); iproc++) {
        ProcessState proc=state.mProcesses.valueAt(iproc);
        foundProcs.add(proc.mCommonProcess);
      }
    }
  }
  ArrayList<ProcessState> outProcs=new ArrayList<ProcessState>(foundProcs.size());
  for (int i=0; i < foundProcs.size(); i++) {
    ProcessState proc=foundProcs.valueAt(i);
    if (computeProcessTimeLocked(proc,screenStates,memStates,procStates,now) > 0) {
      outProcs.add(proc);
      if (procStates != sortProcStates) {
        computeProcessTimeLocked(proc,screenStates,memStates,sortProcStates,now);
      }
    }
  }
  Collections.sort(outProcs,new Comparator<ProcessState>(){
    @Override public int compare(    ProcessState lhs,    ProcessState rhs){
      if (lhs.mTmpTotalTime < rhs.mTmpTotalTime) {
        return -1;
      }
 else       if (lhs.mTmpTotalTime > rhs.mTmpTotalTime) {
        return 1;
      }
      return 0;
    }
  }
);
  return outProcs;
}","public ArrayList<ProcessState> collectProcessesLocked(int[] screenStates,int[] memStates,int[] procStates,int sortProcStates[],long now,String reqPackage,boolean activeOnly){
  ArraySet<ProcessState> foundProcs=new ArraySet<ProcessState>();
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    if (reqPackage != null && !reqPackage.equals(pkgMap.keyAt(ip))) {
      continue;
    }
    SparseArray<PackageState> procs=pkgMap.valueAt(ip);
    for (int iu=0; iu < procs.size(); iu++) {
      PackageState state=procs.valueAt(iu);
      for (int iproc=0; iproc < state.mProcesses.size(); iproc++) {
        ProcessState proc=state.mProcesses.valueAt(iproc);
        if (activeOnly && !proc.isInUse()) {
          continue;
        }
        foundProcs.add(proc.mCommonProcess);
      }
    }
  }
  ArrayList<ProcessState> outProcs=new ArrayList<ProcessState>(foundProcs.size());
  for (int i=0; i < foundProcs.size(); i++) {
    ProcessState proc=foundProcs.valueAt(i);
    if (computeProcessTimeLocked(proc,screenStates,memStates,procStates,now) > 0) {
      outProcs.add(proc);
      if (procStates != sortProcStates) {
        computeProcessTimeLocked(proc,screenStates,memStates,sortProcStates,now);
      }
    }
  }
  Collections.sort(outProcs,new Comparator<ProcessState>(){
    @Override public int compare(    ProcessState lhs,    ProcessState rhs){
      if (lhs.mTmpTotalTime < rhs.mTmpTotalTime) {
        return -1;
      }
 else       if (lhs.mTmpTotalTime > rhs.mTmpTotalTime) {
        return 1;
      }
      return 0;
    }
  }
);
  return outProcs;
}"
1074,"void writeDurationsToParcel(Parcel out){
  out.writeInt(mDurationsTableSize);
  for (int i=0; i < mDurationsTableSize; i++) {
    if (DEBUG)     Slog.i(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ i+ ""String_Node_Str""+ printLongOffset(mDurationsTable[i]));
    out.writeInt(mDurationsTable[i]);
  }
}","void writeDurationsToParcel(Parcel out){
  out.writeInt(mDurationsTableSize);
  for (int i=0; i < mDurationsTableSize; i++) {
    if (DEBUG_PARCEL)     Slog.i(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ i+ ""String_Node_Str""+ printLongOffset(mDurationsTable[i]));
    out.writeInt(mDurationsTable[i]);
  }
}"
1075,"void decStartedServices(int memFactor,long now){
  if (mCommonProcess != this) {
    mCommonProcess.decStartedServices(memFactor,now);
  }
  mNumStartedServices--;
  if (mNumStartedServices == 0 && mCurState == STATE_SERVICE_RESTARTING) {
    setState(STATE_NOTHING,memFactor,now,null);
  }
 else   if (mNumStartedServices < 0) {
    throw new IllegalStateException(""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName);
  }
}","void decStartedServices(int memFactor,long now){
  if (mCommonProcess != this) {
    mCommonProcess.decStartedServices(memFactor,now);
  }
  mNumStartedServices--;
  if (mNumStartedServices == 0 && mCurState == STATE_SERVICE_RESTARTING) {
    setState(STATE_NOTHING,memFactor,now,null);
  }
 else   if (mNumStartedServices < 0) {
    Slog.wtfStack(TAG,""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName);
    mNumStartedServices=0;
  }
}"
1076,"void decActiveServices(){
  if (mCommonProcess != this) {
    mCommonProcess.decActiveServices();
  }
  mNumActiveServices--;
  if (mNumActiveServices < 0) {
    throw new IllegalStateException(""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName);
  }
}","void decActiveServices(String serviceName){
  if (DEBUG && ""String_Node_Str"".equals(mName)) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.d(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ (mNumActiveServices - 1),here);
  }
  if (mCommonProcess != this) {
    mCommonProcess.decActiveServices(serviceName);
  }
  mNumActiveServices--;
  if (mNumActiveServices < 0) {
    Slog.wtfStack(TAG,""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName+ ""String_Node_Str""+ serviceName);
    mNumActiveServices=0;
  }
}"
1077,"private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (mDead && proc.mCommonProcess != proc) {
    Log.wtf(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
    proc=mStats.getProcessStateLocked(proc.mPackage,proc.mUid,proc.mName);
  }
  if (proc.mMultiPackage) {
    PackageState pkg=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid);
    if (pkg == null) {
      throw new IllegalStateException(""String_Node_Str"" + pkgList.keyAt(index) + ""String_Node_Str""+ proc.mName);
    }
    proc=pkg.mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}","private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (mDead && proc.mCommonProcess != proc) {
    Log.wtf(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
    proc=mStats.getProcessStateLocked(proc.mPackage,proc.mUid,proc.mName);
  }
  if (proc.mMultiPackage) {
    PackageState pkg=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid);
    if (pkg == null) {
      throw new IllegalStateException(""String_Node_Str"" + pkgList.keyAt(index) + ""String_Node_Str""+ proc.mUid+ ""String_Node_Str""+ proc.mName);
    }
    proc=pkg.mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"" + proc.mName + ""String_Node_Str""+ pkg.mPackageName+ ""String_Node_Str""+ pkg.mUid);
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}"
1078,"ProcessState clone(String pkg,long now){
  ProcessState pnew=new ProcessState(this,pkg,mUid,mName,now);
  copyDurationsTo(pnew);
  if (mPssTable != null) {
    mStats.mAddLongTable=new int[mPssTable.length];
    mStats.mAddLongTableSize=0;
    for (int i=0; i < mPssTableSize; i++) {
      int origEnt=mPssTable[i];
      int type=(origEnt >> OFFSET_TYPE_SHIFT) & OFFSET_TYPE_MASK;
      int newOff=mStats.addLongData(i,type,PSS_COUNT);
      mStats.mAddLongTable[i]=newOff | type;
      for (int j=0; j < PSS_COUNT; j++) {
        mStats.setLong(newOff,j,mStats.getLong(origEnt,j));
      }
    }
    pnew.mPssTable=mStats.mAddLongTable;
    pnew.mPssTableSize=mStats.mAddLongTableSize;
  }
  pnew.mNumExcessiveWake=mNumExcessiveWake;
  pnew.mNumExcessiveCpu=mNumExcessiveCpu;
  pnew.mNumCachedKill=mNumCachedKill;
  pnew.mMinCachedKillPss=mMinCachedKillPss;
  pnew.mAvgCachedKillPss=mAvgCachedKillPss;
  pnew.mMaxCachedKillPss=mMaxCachedKillPss;
  pnew.mActive=mActive;
  pnew.mNumStartedServices=mNumStartedServices;
  return pnew;
}","ProcessState clone(String pkg,long now){
  ProcessState pnew=new ProcessState(this,pkg,mUid,mName,now);
  copyDurationsTo(pnew);
  if (mPssTable != null) {
    mStats.mAddLongTable=new int[mPssTable.length];
    mStats.mAddLongTableSize=0;
    for (int i=0; i < mPssTableSize; i++) {
      int origEnt=mPssTable[i];
      int type=(origEnt >> OFFSET_TYPE_SHIFT) & OFFSET_TYPE_MASK;
      int newOff=mStats.addLongData(i,type,PSS_COUNT);
      mStats.mAddLongTable[i]=newOff | type;
      for (int j=0; j < PSS_COUNT; j++) {
        mStats.setLong(newOff,j,mStats.getLong(origEnt,j));
      }
    }
    pnew.mPssTable=mStats.mAddLongTable;
    pnew.mPssTableSize=mStats.mAddLongTableSize;
  }
  pnew.mNumExcessiveWake=mNumExcessiveWake;
  pnew.mNumExcessiveCpu=mNumExcessiveCpu;
  pnew.mNumCachedKill=mNumCachedKill;
  pnew.mMinCachedKillPss=mMinCachedKillPss;
  pnew.mAvgCachedKillPss=mAvgCachedKillPss;
  pnew.mMaxCachedKillPss=mMaxCachedKillPss;
  pnew.mActive=mActive;
  pnew.mNumActiveServices=mNumActiveServices;
  pnew.mNumStartedServices=mNumStartedServices;
  return pnew;
}"
1079,"public void setBound(boolean bound,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addDuration(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
    updateRunning(memFactor,now);
  }
}","public void setBound(boolean bound,int memFactor,long now){
  if (mOwner == null) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addDuration(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
    updateRunning(memFactor,now);
  }
}"
1080,"public boolean isInUse(){
  return mActive > 0;
}","public boolean isInUse(){
  return mOwner != null;
}"
1081,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    Slog.w(""String_Node_Str"",""String_Node_Str"",e);
    throw e;
  }
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.wtf(""String_Node_Str"",""String_Node_Str"",e);
    }
    throw e;
  }
}"
1082,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.wtf(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}"
1083,"private void serviceDoneExecutingLocked(ServiceRecord r,boolean inStopping){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inStopping+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inStopping) {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r);
        mStoppingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (inStopping) {
        r.tracker.makeInactive();
        r.tracker=null;
      }
    }
  }
}","private void serviceDoneExecutingLocked(ServiceRecord r,boolean inDestroying,boolean finishing){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inDestroying+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inDestroying) {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r);
        mDestroyingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (finishing) {
        r.tracker.clearCurrentOwner(r);
        r.tracker=null;
      }
    }
  }
}"
1084,"/** 
 * Prints a list of ServiceRecords (dumpsys activity services)
 */
void dumpServicesLocked(FileDescriptor fd,PrintWriter pw,String[] args,int opti,boolean dumpAll,boolean dumpClient,String dumpPackage){
  boolean needSep=false;
  boolean printedAnything=false;
  ItemMatcher matcher=new ItemMatcher();
  matcher.build(args,opti);
  pw.println(""String_Node_Str"");
  try {
    int[] users=mAm.getUsersLocked();
    for (    int user : users) {
      ServiceMap smap=getServiceMap(user);
      boolean printed=false;
      if (smap.mServicesByName.size() > 0) {
        long nowReal=SystemClock.elapsedRealtime();
        needSep=false;
        for (int si=0; si < smap.mServicesByName.size(); si++) {
          ServiceRecord r=smap.mServicesByName.valueAt(si);
          if (!matcher.match(r,r.name)) {
            continue;
          }
          if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
            continue;
          }
          if (!printed) {
            if (printedAnything) {
              pw.println();
            }
            pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
            printed=true;
          }
          printedAnything=true;
          if (needSep) {
            pw.println();
          }
          pw.print(""String_Node_Str"");
          pw.println(r);
          if (dumpAll) {
            r.dump(pw,""String_Node_Str"");
            needSep=true;
          }
 else {
            pw.print(""String_Node_Str"");
            pw.println(r.app);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(r.createTime,nowReal,pw);
            pw.print(""String_Node_Str"");
            pw.print(r.startRequested);
            pw.print(""String_Node_Str"");
            pw.println(r.connections.size());
            if (r.connections.size() > 0) {
              pw.println(""String_Node_Str"");
              for (int conni=0; conni < r.connections.size(); conni++) {
                ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
                for (int i=0; i < clist.size(); i++) {
                  ConnectionRecord conn=clist.get(i);
                  pw.print(""String_Node_Str"");
                  pw.print(conn.binding.intent.intent.getIntent().toShortString(false,false,false,false));
                  pw.print(""String_Node_Str"");
                  ProcessRecord proc=conn.binding.client;
                  pw.println(proc != null ? proc.toShortString() : ""String_Node_Str"");
                }
              }
            }
          }
          if (dumpClient && r.app != null && r.app.thread != null) {
            pw.println(""String_Node_Str"");
            pw.flush();
            try {
              TransferPipe tp=new TransferPipe();
              try {
                r.app.thread.dumpService(tp.getWriteFd().getFileDescriptor(),r,args);
                tp.setBufferPrefix(""String_Node_Str"");
                tp.go(fd,2000);
              }
  finally {
                tp.kill();
              }
            }
 catch (            IOException e) {
              pw.println(""String_Node_Str"" + e);
            }
catch (            RemoteException e) {
              pw.println(""String_Node_Str"");
            }
            needSep=true;
          }
        }
        needSep|=printed;
      }
      printed=false;
      for (int si=0, SN=smap.mDelayedStartList.size(); si < SN; si++) {
        ServiceRecord r=smap.mDelayedStartList.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
      printed=false;
      for (int si=0, SN=smap.mStartingBackground.size(); si < SN; si++) {
        ServiceRecord r=smap.mStartingBackground.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
    }
  }
 catch (  Exception e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mPendingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mPendingServices.size(); i++) {
      ServiceRecord r=mPendingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mRestartingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mRestartingServices.size(); i++) {
      ServiceRecord r=mRestartingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mStoppingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mStoppingServices.size(); i++) {
      ServiceRecord r=mStoppingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (dumpAll) {
    boolean printed=false;
    for (int ic=0; ic < mServiceConnections.size(); ic++) {
      ArrayList<ConnectionRecord> r=mServiceConnections.valueAt(ic);
      for (int i=0; i < r.size(); i++) {
        ConnectionRecord cr=r.get(i);
        if (!matcher.match(cr.binding.service,cr.binding.service.name)) {
          continue;
        }
        if (dumpPackage != null && (cr.binding.client == null || !dumpPackage.equals(cr.binding.client.info.packageName))) {
          continue;
        }
        printedAnything=true;
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
        }
        pw.print(""String_Node_Str"");
        pw.println(cr);
        cr.dump(pw,""String_Node_Str"");
      }
    }
  }
  if (!printedAnything) {
    pw.println(""String_Node_Str"");
  }
}","/** 
 * Prints a list of ServiceRecords (dumpsys activity services)
 */
void dumpServicesLocked(FileDescriptor fd,PrintWriter pw,String[] args,int opti,boolean dumpAll,boolean dumpClient,String dumpPackage){
  boolean needSep=false;
  boolean printedAnything=false;
  ItemMatcher matcher=new ItemMatcher();
  matcher.build(args,opti);
  pw.println(""String_Node_Str"");
  try {
    int[] users=mAm.getUsersLocked();
    for (    int user : users) {
      ServiceMap smap=getServiceMap(user);
      boolean printed=false;
      if (smap.mServicesByName.size() > 0) {
        long nowReal=SystemClock.elapsedRealtime();
        needSep=false;
        for (int si=0; si < smap.mServicesByName.size(); si++) {
          ServiceRecord r=smap.mServicesByName.valueAt(si);
          if (!matcher.match(r,r.name)) {
            continue;
          }
          if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
            continue;
          }
          if (!printed) {
            if (printedAnything) {
              pw.println();
            }
            pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
            printed=true;
          }
          printedAnything=true;
          if (needSep) {
            pw.println();
          }
          pw.print(""String_Node_Str"");
          pw.println(r);
          if (dumpAll) {
            r.dump(pw,""String_Node_Str"");
            needSep=true;
          }
 else {
            pw.print(""String_Node_Str"");
            pw.println(r.app);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(r.createTime,nowReal,pw);
            pw.print(""String_Node_Str"");
            pw.print(r.startRequested);
            pw.print(""String_Node_Str"");
            pw.println(r.connections.size());
            if (r.connections.size() > 0) {
              pw.println(""String_Node_Str"");
              for (int conni=0; conni < r.connections.size(); conni++) {
                ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
                for (int i=0; i < clist.size(); i++) {
                  ConnectionRecord conn=clist.get(i);
                  pw.print(""String_Node_Str"");
                  pw.print(conn.binding.intent.intent.getIntent().toShortString(false,false,false,false));
                  pw.print(""String_Node_Str"");
                  ProcessRecord proc=conn.binding.client;
                  pw.println(proc != null ? proc.toShortString() : ""String_Node_Str"");
                }
              }
            }
          }
          if (dumpClient && r.app != null && r.app.thread != null) {
            pw.println(""String_Node_Str"");
            pw.flush();
            try {
              TransferPipe tp=new TransferPipe();
              try {
                r.app.thread.dumpService(tp.getWriteFd().getFileDescriptor(),r,args);
                tp.setBufferPrefix(""String_Node_Str"");
                tp.go(fd,2000);
              }
  finally {
                tp.kill();
              }
            }
 catch (            IOException e) {
              pw.println(""String_Node_Str"" + e);
            }
catch (            RemoteException e) {
              pw.println(""String_Node_Str"");
            }
            needSep=true;
          }
        }
        needSep|=printed;
      }
      printed=false;
      for (int si=0, SN=smap.mDelayedStartList.size(); si < SN; si++) {
        ServiceRecord r=smap.mDelayedStartList.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
      printed=false;
      for (int si=0, SN=smap.mStartingBackground.size(); si < SN; si++) {
        ServiceRecord r=smap.mStartingBackground.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
    }
  }
 catch (  Exception e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mPendingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mPendingServices.size(); i++) {
      ServiceRecord r=mPendingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mRestartingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mRestartingServices.size(); i++) {
      ServiceRecord r=mRestartingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mDestroyingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mDestroyingServices.size(); i++) {
      ServiceRecord r=mDestroyingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (dumpAll) {
    boolean printed=false;
    for (int ic=0; ic < mServiceConnections.size(); ic++) {
      ArrayList<ConnectionRecord> r=mServiceConnections.valueAt(ic);
      for (int i=0; i < r.size(); i++) {
        ConnectionRecord cr=r.get(i);
        if (!matcher.match(cr.binding.service,cr.binding.service.name)) {
          continue;
        }
        if (dumpPackage != null && (cr.binding.client == null || !dumpPackage.equals(cr.binding.client.info.packageName))) {
          continue;
        }
        printedAnything=true;
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
        }
        pw.print(""String_Node_Str"");
        pw.println(cr);
        cr.dump(pw,""String_Node_Str"");
      }
    }
  }
  if (!printedAnything) {
    pw.println(""String_Node_Str"");
  }
}"
1085,"final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    if (sr.tracker != null) {
      sr.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
    }
    if (mStoppingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
    if (sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
  }
  int i=mStoppingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mStoppingServices.get(i);
    if (sr.app == app) {
      mStoppingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}","final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
    if (sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}"
1086,"void publishServiceLocked(ServiceRecord r,Intent intent,IBinder service){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ intent+ ""String_Node_Str""+ service);
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (b != null && !b.received) {
        b.binder=service;
        b.requested=true;
        b.received=true;
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
          for (int i=0; i < clist.size(); i++) {
            ConnectionRecord c=clist.get(i);
            if (!filter.equals(c.binding.intent.intent)) {
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c.binding.intent.intent);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + intent);
              continue;
            }
            if (DEBUG_SERVICE)             Slog.v(TAG,""String_Node_Str"" + c);
            try {
              c.conn.connected(r.name,service);
            }
 catch (            Exception e) {
              Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
            }
          }
        }
      }
      serviceDoneExecutingLocked(r,mStoppingServices.contains(r));
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","void publishServiceLocked(ServiceRecord r,Intent intent,IBinder service){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ intent+ ""String_Node_Str""+ service);
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (b != null && !b.received) {
        b.binder=service;
        b.requested=true;
        b.received=true;
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
          for (int i=0; i < clist.size(); i++) {
            ConnectionRecord c=clist.get(i);
            if (!filter.equals(c.binding.intent.intent)) {
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c.binding.intent.intent);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + intent);
              continue;
            }
            if (DEBUG_SERVICE)             Slog.v(TAG,""String_Node_Str"" + c);
            try {
              c.conn.connected(r.name,service);
            }
 catch (            Exception e) {
              Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
            }
          }
        }
      }
      serviceDoneExecutingLocked(r,mDestroyingServices.contains(r),false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
1087,"void unbindFinishedLocked(ServiceRecord r,Intent intent,boolean doRebind){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ b+ ""String_Node_Str""+ (b != null ? b.apps.size() : 0));
      boolean inStopping=mStoppingServices.contains(r);
      if (b != null) {
        if (b.apps.size() > 0 && !inStopping) {
          boolean inFg=false;
          for (int i=b.apps.size() - 1; i >= 0; i--) {
            ProcessRecord client=b.apps.valueAt(i).client;
            if (client != null && client.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE) {
              inFg=true;
              break;
            }
          }
          requestServiceBindingLocked(r,b,inFg,true);
        }
 else {
          b.doRebind=true;
        }
      }
      serviceDoneExecutingLocked(r,inStopping);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","void unbindFinishedLocked(ServiceRecord r,Intent intent,boolean doRebind){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ b+ ""String_Node_Str""+ (b != null ? b.apps.size() : 0));
      boolean inDestroying=mDestroyingServices.contains(r);
      if (b != null) {
        if (b.apps.size() > 0 && !inDestroying) {
          boolean inFg=false;
          for (int i=b.apps.size() - 1; i >= 0; i--) {
            ProcessRecord client=b.apps.valueAt(i).client;
            if (client != null && client.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE) {
              inFg=true;
              break;
            }
          }
          requestServiceBindingLocked(r,b,inFg,true);
        }
 else {
          b.doRebind=true;
        }
      }
      serviceDoneExecutingLocked(r,inDestroying,false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
1088,"private final void bringDownServiceIfNeededLocked(ServiceRecord r,boolean knowConn,boolean hasConn){
  if (r.startRequested) {
    return;
  }
  if (!knowConn) {
    hasConn=r.hasAutoCreateConnections();
  }
  if (hasConn) {
    return;
  }
  if (mPendingServices.contains(r)) {
    return;
  }
  bringDownServiceLocked(r);
}","private final void bringDownServiceIfNeededLocked(ServiceRecord r,boolean knowConn,boolean hasConn){
  if (isServiceNeeded(r,knowConn,hasConn)) {
    return;
  }
  if (mPendingServices.contains(r)) {
    return;
  }
  bringDownServiceLocked(r);
}"
1089,"private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mStoppingServices.add(r);
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.makeInactive();
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}","private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}"
1090,"void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceDoneExecutingLocked(s,true);
      }
    }
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}","void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceDoneExecutingLocked(s,true,true);
      }
    }
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}"
1091,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  if (code == SYSPROPS_TRANSACTION) {
    ArrayList<IBinder> procs=new ArrayList<IBinder>();
synchronized (this) {
      final int NP=mProcessNames.getMap().size();
      for (int ip=0; ip < NP; ip++) {
        SparseArray<ProcessRecord> apps=mProcessNames.getMap().valueAt(ip);
        final int NA=apps.size();
        for (int ia=0; ia < NA; ia++) {
          ProcessRecord app=apps.valueAt(ia);
          if (app.thread != null) {
            procs.add(app.thread.asBinder());
          }
        }
      }
    }
    int N=procs.size();
    for (int i=0; i < N; i++) {
      Parcel data2=Parcel.obtain();
      try {
        procs.get(i).transact(IBinder.SYSPROPS_TRANSACTION,data2,null,0);
      }
 catch (      RemoteException e) {
      }
      data2.recycle();
    }
  }
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  if (code == SYSPROPS_TRANSACTION) {
    ArrayList<IBinder> procs=new ArrayList<IBinder>();
synchronized (this) {
      final int NP=mProcessNames.getMap().size();
      for (int ip=0; ip < NP; ip++) {
        SparseArray<ProcessRecord> apps=mProcessNames.getMap().valueAt(ip);
        final int NA=apps.size();
        for (int ia=0; ia < NA; ia++) {
          ProcessRecord app=apps.valueAt(ia);
          if (app.thread != null) {
            procs.add(app.thread.asBinder());
          }
        }
      }
    }
    int N=procs.size();
    for (int i=0; i < N; i++) {
      Parcel data2=Parcel.obtain();
      try {
        procs.get(i).transact(IBinder.SYSPROPS_TRANSACTION,data2,null,0);
      }
 catch (      RemoteException e) {
      }
      data2.recycle();
    }
  }
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.wtf(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}"
1092,"/** 
 * What a Terrible Failure: Report an exception that should never happen. Similar to   {@link #wtf(String,Throwable)}, with a message as well.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 * @param tr An exception to log.  May be null.
 */
public static int wtf(String tag,String msg,Throwable tr){
  TerribleFailure what=new TerribleFailure(msg,tr);
  int bytes=println_native(LOG_ID_MAIN,ASSERT,tag,msg + '\n' + getStackTraceString(tr));
  sWtfHandler.onTerribleFailure(tag,what);
  return bytes;
}","static int wtf(int logId,String tag,String msg,Throwable tr){
  TerribleFailure what=new TerribleFailure(msg,tr);
  int bytes=println_native(logId,ASSERT,tag,msg + '\n' + getStackTraceString(tr));
  sWtfHandler.onTerribleFailure(tag,what);
  return bytes;
}"
1093,"void dumpFilteredSummaryLocked(PrintWriter pw,String header,String prefix,int[] screenStates,int[] memStates,int[] procStates,int[] sortProcStates,long now,long totalTime,String reqPackage){
  ArrayList<ProcessState> procs=collectProcessesLocked(screenStates,memStates,procStates,sortProcStates,now,reqPackage);
  if (procs.size() > 0) {
    if (header != null) {
      pw.println();
      pw.println(header);
    }
    dumpProcessSummaryLocked(pw,prefix,procs,screenStates,memStates,sortProcStates,now,totalTime);
  }
}","void dumpFilteredSummaryLocked(PrintWriter pw,String header,String prefix,int[] screenStates,int[] memStates,int[] procStates,int[] sortProcStates,long now,long totalTime,String reqPackage,boolean activeOnly){
  ArrayList<ProcessState> procs=collectProcessesLocked(screenStates,memStates,procStates,sortProcStates,now,reqPackage,activeOnly);
  if (procs.size() > 0) {
    if (header != null) {
      pw.println();
      pw.println(header);
    }
    dumpProcessSummaryLocked(pw,prefix,procs,screenStates,memStates,sortProcStates,now,totalTime);
  }
}"
1094,"public void setExecuting(boolean executing,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addDuration(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
    updateRunning(memFactor,now);
  }
}","public void setExecuting(boolean executing,int memFactor,long now){
  if (mOwner == null) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addDuration(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
    updateRunning(memFactor,now);
  }
}"
1095,"private void ensureNotDead(){
  if (!mDead) {
    return;
  }
  throw new IllegalStateException(""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
}","private void ensureNotDead(){
  if (!mDead) {
    return;
  }
  Slog.wtfStack(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
}"
1096,"public ProcessStats.ServiceState getServiceStateLocked(String packageName,int uid,String processName,String className){
  final ProcessStats.PackageState as=getPackageStateLocked(packageName,uid);
  ProcessStats.ServiceState ss=as.mServices.get(className);
  if (ss != null) {
    return ss;
  }
  final ProcessStats.ProcessState ps=processName != null ? getProcessStateLocked(packageName,uid,processName) : null;
  ss=new ProcessStats.ServiceState(this,packageName,className,processName,ps);
  as.mServices.put(className,ss);
  return ss;
}","public ProcessStats.ServiceState getServiceStateLocked(String packageName,int uid,String processName,String className){
  final ProcessStats.PackageState as=getPackageStateLocked(packageName,uid);
  ProcessStats.ServiceState ss=as.mServices.get(className);
  if (ss != null) {
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + ss);
    return ss;
  }
  final ProcessStats.ProcessState ps=processName != null ? getProcessStateLocked(packageName,uid,processName) : null;
  ss=new ProcessStats.ServiceState(this,packageName,className,processName,ps);
  as.mServices.put(className,ss);
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + ss + ""String_Node_Str""+ ps);
  return ss;
}"
1097,"private int[] readTableFromParcel(Parcel in,String name,String what){
  final int size=in.readInt();
  if (size < 0) {
    Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ size);
    return BAD_TABLE;
  }
  if (size == 0) {
    return null;
  }
  final int[] table=new int[size];
  for (int i=0; i < size; i++) {
    table[i]=in.readInt();
    if (DEBUG)     Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ i+ ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
    if (!validateLongOffset(table[i])) {
      Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
      return null;
    }
  }
  return table;
}","private int[] readTableFromParcel(Parcel in,String name,String what){
  final int size=in.readInt();
  if (size < 0) {
    Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ size);
    return BAD_TABLE;
  }
  if (size == 0) {
    return null;
  }
  final int[] table=new int[size];
  for (int i=0; i < size; i++) {
    table[i]=in.readInt();
    if (DEBUG_PARCEL)     Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ i+ ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
    if (!validateLongOffset(table[i])) {
      Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
      return null;
    }
  }
  return table;
}"
1098,"public void makeActive(){
  if (mActive == 0) {
    mProc.incActiveServices();
  }
  mActive++;
}","public void makeActive(){
  ensureNotDead();
  mActive=true;
}"
1099,"public void makeInactive(){
  mActive--;
  if (mActive == 0) {
    mProc.decActiveServices();
  }
}","public void makeInactive(){
  mActive=false;
}"
1100,"public ProcessState getProcessStateLocked(String packageName,int uid,String processName){
  final PackageState pkgState=getPackageStateLocked(packageName,uid);
  ProcessState ps=pkgState.mProcesses.get(processName);
  if (ps != null) {
    return ps;
  }
  ProcessState commonProc=mProcesses.get(processName,uid);
  if (commonProc == null) {
    commonProc=new ProcessState(this,packageName,uid,processName);
    mProcesses.put(processName,uid,commonProc);
  }
  if (!commonProc.mMultiPackage) {
    if (packageName.equals(commonProc.mPackage)) {
      ps=commonProc;
    }
 else {
      commonProc.mMultiPackage=true;
      long now=SystemClock.uptimeMillis();
      final PackageState commonPkgState=getPackageStateLocked(commonProc.mPackage,uid);
      if (commonPkgState != null) {
        commonPkgState.mProcesses.put(commonProc.mName,commonProc.clone(commonProc.mPackage,now));
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + commonProc.mPackage + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc.mName);
      }
      ps=new ProcessState(commonProc,packageName,uid,processName,now);
    }
  }
 else {
    ps=new ProcessState(commonProc,packageName,uid,processName,SystemClock.uptimeMillis());
  }
  pkgState.mProcesses.put(processName,ps);
  return ps;
}","public ProcessState getProcessStateLocked(String packageName,int uid,String processName){
  final PackageState pkgState=getPackageStateLocked(packageName,uid);
  ProcessState ps=pkgState.mProcesses.get(processName);
  if (ps != null) {
    return ps;
  }
  ProcessState commonProc=mProcesses.get(processName,uid);
  if (commonProc == null) {
    commonProc=new ProcessState(this,packageName,uid,processName);
    mProcesses.put(processName,uid,commonProc);
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + commonProc);
  }
  if (!commonProc.mMultiPackage) {
    if (packageName.equals(commonProc.mPackage)) {
      ps=commonProc;
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + commonProc);
    }
 else {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"");
      commonProc.mMultiPackage=true;
      long now=SystemClock.uptimeMillis();
      final PackageState commonPkgState=getPackageStateLocked(commonProc.mPackage,uid);
      if (commonPkgState != null) {
        ProcessState cloned=commonProc.clone(commonProc.mPackage,now);
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"" + commonProc.mPackage + ""String_Node_Str""+ cloned);
        commonPkgState.mProcesses.put(commonProc.mName,cloned);
        for (int i=commonPkgState.mServices.size() - 1; i >= 0; i--) {
          ServiceState ss=commonPkgState.mServices.valueAt(i);
          if (ss.mProc == commonProc) {
            if (DEBUG)             Slog.d(TAG,""String_Node_Str"" + ss);
            ss.mProc=cloned;
          }
 else           if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"" + ss);
          }
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + commonProc.mPackage + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc.mName);
      }
      ps=new ProcessState(commonProc,packageName,uid,processName,now);
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + ps);
    }
  }
 else {
    ps=new ProcessState(commonProc,packageName,uid,processName,SystemClock.uptimeMillis());
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + ps);
  }
  pkgState.mProcesses.put(processName,ps);
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + ps);
  return ps;
}"
1101,"void incActiveServices(){
  if (mCommonProcess != this) {
    mCommonProcess.incActiveServices();
  }
  mNumActiveServices++;
}","void incActiveServices(String serviceName){
  if (DEBUG && ""String_Node_Str"".equals(mName)) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.d(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ (mNumActiveServices + 1),here);
  }
  if (mCommonProcess != this) {
    mCommonProcess.incActiveServices(serviceName);
  }
  mNumActiveServices++;
}"
1102,"public void dumpSummaryLocked(PrintWriter pw,String reqPackage,long now){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  dumpFilteredSummaryLocked(pw,null,""String_Node_Str"",ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,NON_CACHED_PROC_STATES,now,totalTime,reqPackage);
  pw.println();
  dumpTotalsLocked(pw,now);
}","public void dumpSummaryLocked(PrintWriter pw,String reqPackage,long now,boolean activeOnly){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  dumpFilteredSummaryLocked(pw,null,""String_Node_Str"",ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,NON_CACHED_PROC_STATES,now,totalTime,reqPackage,activeOnly);
  pw.println();
  dumpTotalsLocked(pw,now);
}"
1103,"boolean validateLongOffset(int off){
  int arr=(off >> OFFSET_ARRAY_SHIFT) & OFFSET_ARRAY_MASK;
  if (arr >= mLongs.size()) {
    return false;
  }
  int idx=(off >> OFFSET_INDEX_SHIFT) & OFFSET_INDEX_MASK;
  if (idx >= LONGS_SIZE) {
    return false;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + printLongOffset(off) + ""String_Node_Str""+ getLong(off,0));
  return true;
}","boolean validateLongOffset(int off){
  int arr=(off >> OFFSET_ARRAY_SHIFT) & OFFSET_ARRAY_MASK;
  if (arr >= mLongs.size()) {
    return false;
  }
  int idx=(off >> OFFSET_INDEX_SHIFT) & OFFSET_INDEX_MASK;
  if (idx >= LONGS_SIZE) {
    return false;
  }
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"" + printLongOffset(off) + ""String_Node_Str""+ getLong(off,0));
  return true;
}"
1104,"public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpSummary,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (!dumpSummary || dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        pw.print(""String_Node_Str"");
        pw.println(svc.mProcessName);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mRunCount,ServiceState.SERVICE_RUN,svc.mRunState,svc.mRunStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,!dumpSummary || dumpAll);
        if (dumpAll) {
          pw.print(""String_Node_Str"");
          pw.println(svc.mActive);
        }
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    int numShownProcs=0, numTotalProcs=0;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        numTotalProcs++;
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        numShownProcs++;
        if (!printedHeader) {
          pw.println();
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
        if (dumpAll) {
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
    }
    if (dumpAll) {
      pw.println();
      pw.print(""String_Node_Str"");
      pw.print(numShownProcs);
      pw.print(""String_Node_Str"");
      pw.print(numTotalProcs);
      pw.println(""String_Node_Str"");
    }
    pw.println();
    if (dumpSummary) {
      pw.println(""String_Node_Str"");
      dumpSummaryLocked(pw,reqPackage,now);
    }
 else {
      dumpTotalsLocked(pw,now);
    }
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}","public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpSummary,boolean dumpAll,boolean activeOnly){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (!dumpSummary || dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (activeOnly && !proc.isInUse()) {
            pw.print(""String_Node_Str"");
            pw.print(pkgState.mProcesses.keyAt(iproc));
            pw.println(""String_Node_Str"");
            continue;
          }
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (activeOnly && !proc.isInUse()) {
            continue;
          }
          procs.add(proc);
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        if (activeOnly && !svc.isInUse()) {
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mServices.keyAt(isvc));
          pw.println(""String_Node_Str"");
          continue;
        }
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(svc.mProcessName);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mRunCount,ServiceState.SERVICE_RUN,svc.mRunState,svc.mRunStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,!dumpSummary || dumpAll);
        if (dumpAll) {
          if (svc.mOwner != null) {
            pw.print(""String_Node_Str"");
            pw.println(svc.mOwner);
          }
        }
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    int numShownProcs=0, numTotalProcs=0;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        numTotalProcs++;
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        numShownProcs++;
        if (!printedHeader) {
          pw.println();
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        if (activeOnly && !proc.isInUse()) {
          pw.print(""String_Node_Str"");
          pw.print(procName);
          pw.println(""String_Node_Str"");
          continue;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
        if (dumpAll) {
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
    }
    if (dumpAll) {
      pw.println();
      pw.print(""String_Node_Str"");
      pw.print(numShownProcs);
      pw.print(""String_Node_Str"");
      pw.print(numTotalProcs);
      pw.println(""String_Node_Str"");
    }
    pw.println();
    if (dumpSummary) {
      pw.println(""String_Node_Str"");
      dumpSummaryLocked(pw,reqPackage,now,activeOnly);
    }
 else {
      dumpTotalsLocked(pw,now);
    }
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}"
1105,"static byte[] readFully(InputStream stream,int[] outLen) throws IOException {
  int pos=0;
  final int initialAvail=stream.available();
  byte[] data=new byte[initialAvail > 0 ? (initialAvail + 1) : 16384];
  while (true) {
    int amt=stream.read(data,pos,data.length - pos);
    if (DEBUG)     Slog.i(""String_Node_Str"",""String_Node_Str"" + amt + ""String_Node_Str""+ pos+ ""String_Node_Str""+ data.length);
    if (amt < 0) {
      if (DEBUG)       Slog.i(""String_Node_Str"",""String_Node_Str"" + pos + ""String_Node_Str""+ data.length);
      outLen[0]=pos;
      return data;
    }
    pos+=amt;
    if (pos >= data.length) {
      byte[] newData=new byte[pos + 16384];
      if (DEBUG)       Slog.i(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ newData.length);
      System.arraycopy(data,0,newData,0,pos);
      data=newData;
    }
  }
}","static byte[] readFully(InputStream stream,int[] outLen) throws IOException {
  int pos=0;
  final int initialAvail=stream.available();
  byte[] data=new byte[initialAvail > 0 ? (initialAvail + 1) : 16384];
  while (true) {
    int amt=stream.read(data,pos,data.length - pos);
    if (DEBUG_PARCEL)     Slog.i(""String_Node_Str"",""String_Node_Str"" + amt + ""String_Node_Str""+ pos+ ""String_Node_Str""+ data.length);
    if (amt < 0) {
      if (DEBUG_PARCEL)       Slog.i(""String_Node_Str"",""String_Node_Str"" + pos + ""String_Node_Str""+ data.length);
      outLen[0]=pos;
      return data;
    }
    pos+=amt;
    if (pos >= data.length) {
      byte[] newData=new byte[pos + 16384];
      if (DEBUG_PARCEL)       Slog.i(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ newData.length);
      System.arraycopy(data,0,newData,0,pos);
      data=newData;
    }
  }
}"
1106,"public void setStarted(boolean started,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final boolean wasStarted=mStartedState != STATE_NOTHING;
  final int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addDuration(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    mProc=mProc.pullFixedProc(mPackage);
    if (wasStarted != started) {
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
    updateRunning(memFactor,now);
  }
}","public void setStarted(boolean started,int memFactor,long now){
  if (mOwner == null) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final boolean wasStarted=mStartedState != STATE_NOTHING;
  final int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addDuration(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    mProc=mProc.pullFixedProc(mPackage);
    if (wasStarted != started) {
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
    updateRunning(memFactor,now);
  }
}"
1107,"public ArrayList<ProcessState> collectProcessesLocked(int[] screenStates,int[] memStates,int[] procStates,int sortProcStates[],long now,String reqPackage){
  ArraySet<ProcessState> foundProcs=new ArraySet<ProcessState>();
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    if (reqPackage != null && !reqPackage.equals(pkgMap.keyAt(ip))) {
      continue;
    }
    SparseArray<PackageState> procs=pkgMap.valueAt(ip);
    for (int iu=0; iu < procs.size(); iu++) {
      PackageState state=procs.valueAt(iu);
      for (int iproc=0; iproc < state.mProcesses.size(); iproc++) {
        ProcessState proc=state.mProcesses.valueAt(iproc);
        foundProcs.add(proc.mCommonProcess);
      }
    }
  }
  ArrayList<ProcessState> outProcs=new ArrayList<ProcessState>(foundProcs.size());
  for (int i=0; i < foundProcs.size(); i++) {
    ProcessState proc=foundProcs.valueAt(i);
    if (computeProcessTimeLocked(proc,screenStates,memStates,procStates,now) > 0) {
      outProcs.add(proc);
      if (procStates != sortProcStates) {
        computeProcessTimeLocked(proc,screenStates,memStates,sortProcStates,now);
      }
    }
  }
  Collections.sort(outProcs,new Comparator<ProcessState>(){
    @Override public int compare(    ProcessState lhs,    ProcessState rhs){
      if (lhs.mTmpTotalTime < rhs.mTmpTotalTime) {
        return -1;
      }
 else       if (lhs.mTmpTotalTime > rhs.mTmpTotalTime) {
        return 1;
      }
      return 0;
    }
  }
);
  return outProcs;
}","public ArrayList<ProcessState> collectProcessesLocked(int[] screenStates,int[] memStates,int[] procStates,int sortProcStates[],long now,String reqPackage,boolean activeOnly){
  ArraySet<ProcessState> foundProcs=new ArraySet<ProcessState>();
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    if (reqPackage != null && !reqPackage.equals(pkgMap.keyAt(ip))) {
      continue;
    }
    SparseArray<PackageState> procs=pkgMap.valueAt(ip);
    for (int iu=0; iu < procs.size(); iu++) {
      PackageState state=procs.valueAt(iu);
      for (int iproc=0; iproc < state.mProcesses.size(); iproc++) {
        ProcessState proc=state.mProcesses.valueAt(iproc);
        if (activeOnly && !proc.isInUse()) {
          continue;
        }
        foundProcs.add(proc.mCommonProcess);
      }
    }
  }
  ArrayList<ProcessState> outProcs=new ArrayList<ProcessState>(foundProcs.size());
  for (int i=0; i < foundProcs.size(); i++) {
    ProcessState proc=foundProcs.valueAt(i);
    if (computeProcessTimeLocked(proc,screenStates,memStates,procStates,now) > 0) {
      outProcs.add(proc);
      if (procStates != sortProcStates) {
        computeProcessTimeLocked(proc,screenStates,memStates,sortProcStates,now);
      }
    }
  }
  Collections.sort(outProcs,new Comparator<ProcessState>(){
    @Override public int compare(    ProcessState lhs,    ProcessState rhs){
      if (lhs.mTmpTotalTime < rhs.mTmpTotalTime) {
        return -1;
      }
 else       if (lhs.mTmpTotalTime > rhs.mTmpTotalTime) {
        return 1;
      }
      return 0;
    }
  }
);
  return outProcs;
}"
1108,"void writeDurationsToParcel(Parcel out){
  out.writeInt(mDurationsTableSize);
  for (int i=0; i < mDurationsTableSize; i++) {
    if (DEBUG)     Slog.i(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ i+ ""String_Node_Str""+ printLongOffset(mDurationsTable[i]));
    out.writeInt(mDurationsTable[i]);
  }
}","void writeDurationsToParcel(Parcel out){
  out.writeInt(mDurationsTableSize);
  for (int i=0; i < mDurationsTableSize; i++) {
    if (DEBUG_PARCEL)     Slog.i(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ i+ ""String_Node_Str""+ printLongOffset(mDurationsTable[i]));
    out.writeInt(mDurationsTable[i]);
  }
}"
1109,"void decStartedServices(int memFactor,long now){
  if (mCommonProcess != this) {
    mCommonProcess.decStartedServices(memFactor,now);
  }
  mNumStartedServices--;
  if (mNumStartedServices == 0 && mCurState == STATE_SERVICE_RESTARTING) {
    setState(STATE_NOTHING,memFactor,now,null);
  }
 else   if (mNumStartedServices < 0) {
    throw new IllegalStateException(""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName);
  }
}","void decStartedServices(int memFactor,long now){
  if (mCommonProcess != this) {
    mCommonProcess.decStartedServices(memFactor,now);
  }
  mNumStartedServices--;
  if (mNumStartedServices == 0 && mCurState == STATE_SERVICE_RESTARTING) {
    setState(STATE_NOTHING,memFactor,now,null);
  }
 else   if (mNumStartedServices < 0) {
    Slog.wtfStack(TAG,""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName);
    mNumStartedServices=0;
  }
}"
1110,"void decActiveServices(){
  if (mCommonProcess != this) {
    mCommonProcess.decActiveServices();
  }
  mNumActiveServices--;
  if (mNumActiveServices < 0) {
    throw new IllegalStateException(""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName);
  }
}","void decActiveServices(String serviceName){
  if (DEBUG && ""String_Node_Str"".equals(mName)) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.d(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ (mNumActiveServices - 1),here);
  }
  if (mCommonProcess != this) {
    mCommonProcess.decActiveServices(serviceName);
  }
  mNumActiveServices--;
  if (mNumActiveServices < 0) {
    Slog.wtfStack(TAG,""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName+ ""String_Node_Str""+ serviceName);
    mNumActiveServices=0;
  }
}"
1111,"private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (mDead && proc.mCommonProcess != proc) {
    Log.wtf(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
    proc=mStats.getProcessStateLocked(proc.mPackage,proc.mUid,proc.mName);
  }
  if (proc.mMultiPackage) {
    PackageState pkg=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid);
    if (pkg == null) {
      throw new IllegalStateException(""String_Node_Str"" + pkgList.keyAt(index) + ""String_Node_Str""+ proc.mName);
    }
    proc=pkg.mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}","private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (mDead && proc.mCommonProcess != proc) {
    Log.wtf(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
    proc=mStats.getProcessStateLocked(proc.mPackage,proc.mUid,proc.mName);
  }
  if (proc.mMultiPackage) {
    PackageState pkg=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid);
    if (pkg == null) {
      throw new IllegalStateException(""String_Node_Str"" + pkgList.keyAt(index) + ""String_Node_Str""+ proc.mUid+ ""String_Node_Str""+ proc.mName);
    }
    proc=pkg.mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"" + proc.mName + ""String_Node_Str""+ pkg.mPackageName+ ""String_Node_Str""+ pkg.mUid);
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}"
1112,"ProcessState clone(String pkg,long now){
  ProcessState pnew=new ProcessState(this,pkg,mUid,mName,now);
  copyDurationsTo(pnew);
  if (mPssTable != null) {
    mStats.mAddLongTable=new int[mPssTable.length];
    mStats.mAddLongTableSize=0;
    for (int i=0; i < mPssTableSize; i++) {
      int origEnt=mPssTable[i];
      int type=(origEnt >> OFFSET_TYPE_SHIFT) & OFFSET_TYPE_MASK;
      int newOff=mStats.addLongData(i,type,PSS_COUNT);
      mStats.mAddLongTable[i]=newOff | type;
      for (int j=0; j < PSS_COUNT; j++) {
        mStats.setLong(newOff,j,mStats.getLong(origEnt,j));
      }
    }
    pnew.mPssTable=mStats.mAddLongTable;
    pnew.mPssTableSize=mStats.mAddLongTableSize;
  }
  pnew.mNumExcessiveWake=mNumExcessiveWake;
  pnew.mNumExcessiveCpu=mNumExcessiveCpu;
  pnew.mNumCachedKill=mNumCachedKill;
  pnew.mMinCachedKillPss=mMinCachedKillPss;
  pnew.mAvgCachedKillPss=mAvgCachedKillPss;
  pnew.mMaxCachedKillPss=mMaxCachedKillPss;
  pnew.mActive=mActive;
  pnew.mNumStartedServices=mNumStartedServices;
  return pnew;
}","ProcessState clone(String pkg,long now){
  ProcessState pnew=new ProcessState(this,pkg,mUid,mName,now);
  copyDurationsTo(pnew);
  if (mPssTable != null) {
    mStats.mAddLongTable=new int[mPssTable.length];
    mStats.mAddLongTableSize=0;
    for (int i=0; i < mPssTableSize; i++) {
      int origEnt=mPssTable[i];
      int type=(origEnt >> OFFSET_TYPE_SHIFT) & OFFSET_TYPE_MASK;
      int newOff=mStats.addLongData(i,type,PSS_COUNT);
      mStats.mAddLongTable[i]=newOff | type;
      for (int j=0; j < PSS_COUNT; j++) {
        mStats.setLong(newOff,j,mStats.getLong(origEnt,j));
      }
    }
    pnew.mPssTable=mStats.mAddLongTable;
    pnew.mPssTableSize=mStats.mAddLongTableSize;
  }
  pnew.mNumExcessiveWake=mNumExcessiveWake;
  pnew.mNumExcessiveCpu=mNumExcessiveCpu;
  pnew.mNumCachedKill=mNumCachedKill;
  pnew.mMinCachedKillPss=mMinCachedKillPss;
  pnew.mAvgCachedKillPss=mAvgCachedKillPss;
  pnew.mMaxCachedKillPss=mMaxCachedKillPss;
  pnew.mActive=mActive;
  pnew.mNumActiveServices=mNumActiveServices;
  pnew.mNumStartedServices=mNumStartedServices;
  return pnew;
}"
1113,"public void setBound(boolean bound,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addDuration(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
    updateRunning(memFactor,now);
  }
}","public void setBound(boolean bound,int memFactor,long now){
  if (mOwner == null) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addDuration(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
    updateRunning(memFactor,now);
  }
}"
1114,"public boolean isInUse(){
  return mActive > 0;
}","public boolean isInUse(){
  return mOwner != null;
}"
1115,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    Slog.w(""String_Node_Str"",""String_Node_Str"",e);
    throw e;
  }
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.wtf(""String_Node_Str"",""String_Node_Str"",e);
    }
    throw e;
  }
}"
1116,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.wtf(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}"
1117,"private void serviceDoneExecutingLocked(ServiceRecord r,boolean inStopping){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inStopping+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inStopping) {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r);
        mStoppingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (inStopping) {
        r.tracker.makeInactive();
        r.tracker=null;
      }
    }
  }
}","private void serviceDoneExecutingLocked(ServiceRecord r,boolean inDestroying,boolean finishing){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inDestroying+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inDestroying) {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r);
        mDestroyingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (finishing) {
        r.tracker.clearCurrentOwner(r);
        r.tracker=null;
      }
    }
  }
}"
1118,"/** 
 * Prints a list of ServiceRecords (dumpsys activity services)
 */
void dumpServicesLocked(FileDescriptor fd,PrintWriter pw,String[] args,int opti,boolean dumpAll,boolean dumpClient,String dumpPackage){
  boolean needSep=false;
  boolean printedAnything=false;
  ItemMatcher matcher=new ItemMatcher();
  matcher.build(args,opti);
  pw.println(""String_Node_Str"");
  try {
    int[] users=mAm.getUsersLocked();
    for (    int user : users) {
      ServiceMap smap=getServiceMap(user);
      boolean printed=false;
      if (smap.mServicesByName.size() > 0) {
        long nowReal=SystemClock.elapsedRealtime();
        needSep=false;
        for (int si=0; si < smap.mServicesByName.size(); si++) {
          ServiceRecord r=smap.mServicesByName.valueAt(si);
          if (!matcher.match(r,r.name)) {
            continue;
          }
          if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
            continue;
          }
          if (!printed) {
            if (printedAnything) {
              pw.println();
            }
            pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
            printed=true;
          }
          printedAnything=true;
          if (needSep) {
            pw.println();
          }
          pw.print(""String_Node_Str"");
          pw.println(r);
          if (dumpAll) {
            r.dump(pw,""String_Node_Str"");
            needSep=true;
          }
 else {
            pw.print(""String_Node_Str"");
            pw.println(r.app);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(r.createTime,nowReal,pw);
            pw.print(""String_Node_Str"");
            pw.print(r.startRequested);
            pw.print(""String_Node_Str"");
            pw.println(r.connections.size());
            if (r.connections.size() > 0) {
              pw.println(""String_Node_Str"");
              for (int conni=0; conni < r.connections.size(); conni++) {
                ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
                for (int i=0; i < clist.size(); i++) {
                  ConnectionRecord conn=clist.get(i);
                  pw.print(""String_Node_Str"");
                  pw.print(conn.binding.intent.intent.getIntent().toShortString(false,false,false,false));
                  pw.print(""String_Node_Str"");
                  ProcessRecord proc=conn.binding.client;
                  pw.println(proc != null ? proc.toShortString() : ""String_Node_Str"");
                }
              }
            }
          }
          if (dumpClient && r.app != null && r.app.thread != null) {
            pw.println(""String_Node_Str"");
            pw.flush();
            try {
              TransferPipe tp=new TransferPipe();
              try {
                r.app.thread.dumpService(tp.getWriteFd().getFileDescriptor(),r,args);
                tp.setBufferPrefix(""String_Node_Str"");
                tp.go(fd,2000);
              }
  finally {
                tp.kill();
              }
            }
 catch (            IOException e) {
              pw.println(""String_Node_Str"" + e);
            }
catch (            RemoteException e) {
              pw.println(""String_Node_Str"");
            }
            needSep=true;
          }
        }
        needSep|=printed;
      }
      printed=false;
      for (int si=0, SN=smap.mDelayedStartList.size(); si < SN; si++) {
        ServiceRecord r=smap.mDelayedStartList.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
      printed=false;
      for (int si=0, SN=smap.mStartingBackground.size(); si < SN; si++) {
        ServiceRecord r=smap.mStartingBackground.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
    }
  }
 catch (  Exception e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mPendingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mPendingServices.size(); i++) {
      ServiceRecord r=mPendingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mRestartingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mRestartingServices.size(); i++) {
      ServiceRecord r=mRestartingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mStoppingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mStoppingServices.size(); i++) {
      ServiceRecord r=mStoppingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (dumpAll) {
    boolean printed=false;
    for (int ic=0; ic < mServiceConnections.size(); ic++) {
      ArrayList<ConnectionRecord> r=mServiceConnections.valueAt(ic);
      for (int i=0; i < r.size(); i++) {
        ConnectionRecord cr=r.get(i);
        if (!matcher.match(cr.binding.service,cr.binding.service.name)) {
          continue;
        }
        if (dumpPackage != null && (cr.binding.client == null || !dumpPackage.equals(cr.binding.client.info.packageName))) {
          continue;
        }
        printedAnything=true;
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
        }
        pw.print(""String_Node_Str"");
        pw.println(cr);
        cr.dump(pw,""String_Node_Str"");
      }
    }
  }
  if (!printedAnything) {
    pw.println(""String_Node_Str"");
  }
}","/** 
 * Prints a list of ServiceRecords (dumpsys activity services)
 */
void dumpServicesLocked(FileDescriptor fd,PrintWriter pw,String[] args,int opti,boolean dumpAll,boolean dumpClient,String dumpPackage){
  boolean needSep=false;
  boolean printedAnything=false;
  ItemMatcher matcher=new ItemMatcher();
  matcher.build(args,opti);
  pw.println(""String_Node_Str"");
  try {
    int[] users=mAm.getUsersLocked();
    for (    int user : users) {
      ServiceMap smap=getServiceMap(user);
      boolean printed=false;
      if (smap.mServicesByName.size() > 0) {
        long nowReal=SystemClock.elapsedRealtime();
        needSep=false;
        for (int si=0; si < smap.mServicesByName.size(); si++) {
          ServiceRecord r=smap.mServicesByName.valueAt(si);
          if (!matcher.match(r,r.name)) {
            continue;
          }
          if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
            continue;
          }
          if (!printed) {
            if (printedAnything) {
              pw.println();
            }
            pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
            printed=true;
          }
          printedAnything=true;
          if (needSep) {
            pw.println();
          }
          pw.print(""String_Node_Str"");
          pw.println(r);
          if (dumpAll) {
            r.dump(pw,""String_Node_Str"");
            needSep=true;
          }
 else {
            pw.print(""String_Node_Str"");
            pw.println(r.app);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(r.createTime,nowReal,pw);
            pw.print(""String_Node_Str"");
            pw.print(r.startRequested);
            pw.print(""String_Node_Str"");
            pw.println(r.connections.size());
            if (r.connections.size() > 0) {
              pw.println(""String_Node_Str"");
              for (int conni=0; conni < r.connections.size(); conni++) {
                ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
                for (int i=0; i < clist.size(); i++) {
                  ConnectionRecord conn=clist.get(i);
                  pw.print(""String_Node_Str"");
                  pw.print(conn.binding.intent.intent.getIntent().toShortString(false,false,false,false));
                  pw.print(""String_Node_Str"");
                  ProcessRecord proc=conn.binding.client;
                  pw.println(proc != null ? proc.toShortString() : ""String_Node_Str"");
                }
              }
            }
          }
          if (dumpClient && r.app != null && r.app.thread != null) {
            pw.println(""String_Node_Str"");
            pw.flush();
            try {
              TransferPipe tp=new TransferPipe();
              try {
                r.app.thread.dumpService(tp.getWriteFd().getFileDescriptor(),r,args);
                tp.setBufferPrefix(""String_Node_Str"");
                tp.go(fd,2000);
              }
  finally {
                tp.kill();
              }
            }
 catch (            IOException e) {
              pw.println(""String_Node_Str"" + e);
            }
catch (            RemoteException e) {
              pw.println(""String_Node_Str"");
            }
            needSep=true;
          }
        }
        needSep|=printed;
      }
      printed=false;
      for (int si=0, SN=smap.mDelayedStartList.size(); si < SN; si++) {
        ServiceRecord r=smap.mDelayedStartList.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
      printed=false;
      for (int si=0, SN=smap.mStartingBackground.size(); si < SN; si++) {
        ServiceRecord r=smap.mStartingBackground.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
    }
  }
 catch (  Exception e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mPendingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mPendingServices.size(); i++) {
      ServiceRecord r=mPendingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mRestartingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mRestartingServices.size(); i++) {
      ServiceRecord r=mRestartingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mDestroyingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mDestroyingServices.size(); i++) {
      ServiceRecord r=mDestroyingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (dumpAll) {
    boolean printed=false;
    for (int ic=0; ic < mServiceConnections.size(); ic++) {
      ArrayList<ConnectionRecord> r=mServiceConnections.valueAt(ic);
      for (int i=0; i < r.size(); i++) {
        ConnectionRecord cr=r.get(i);
        if (!matcher.match(cr.binding.service,cr.binding.service.name)) {
          continue;
        }
        if (dumpPackage != null && (cr.binding.client == null || !dumpPackage.equals(cr.binding.client.info.packageName))) {
          continue;
        }
        printedAnything=true;
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
        }
        pw.print(""String_Node_Str"");
        pw.println(cr);
        cr.dump(pw,""String_Node_Str"");
      }
    }
  }
  if (!printedAnything) {
    pw.println(""String_Node_Str"");
  }
}"
1119,"final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    if (sr.tracker != null) {
      sr.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
    }
    if (mStoppingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
    if (sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
  }
  int i=mStoppingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mStoppingServices.get(i);
    if (sr.app == app) {
      mStoppingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}","final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
    if (sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}"
1120,"void publishServiceLocked(ServiceRecord r,Intent intent,IBinder service){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ intent+ ""String_Node_Str""+ service);
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (b != null && !b.received) {
        b.binder=service;
        b.requested=true;
        b.received=true;
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
          for (int i=0; i < clist.size(); i++) {
            ConnectionRecord c=clist.get(i);
            if (!filter.equals(c.binding.intent.intent)) {
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c.binding.intent.intent);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + intent);
              continue;
            }
            if (DEBUG_SERVICE)             Slog.v(TAG,""String_Node_Str"" + c);
            try {
              c.conn.connected(r.name,service);
            }
 catch (            Exception e) {
              Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
            }
          }
        }
      }
      serviceDoneExecutingLocked(r,mStoppingServices.contains(r));
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","void publishServiceLocked(ServiceRecord r,Intent intent,IBinder service){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ intent+ ""String_Node_Str""+ service);
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (b != null && !b.received) {
        b.binder=service;
        b.requested=true;
        b.received=true;
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
          for (int i=0; i < clist.size(); i++) {
            ConnectionRecord c=clist.get(i);
            if (!filter.equals(c.binding.intent.intent)) {
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c.binding.intent.intent);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + intent);
              continue;
            }
            if (DEBUG_SERVICE)             Slog.v(TAG,""String_Node_Str"" + c);
            try {
              c.conn.connected(r.name,service);
            }
 catch (            Exception e) {
              Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
            }
          }
        }
      }
      serviceDoneExecutingLocked(r,mDestroyingServices.contains(r),false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
1121,"void unbindFinishedLocked(ServiceRecord r,Intent intent,boolean doRebind){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ b+ ""String_Node_Str""+ (b != null ? b.apps.size() : 0));
      boolean inStopping=mStoppingServices.contains(r);
      if (b != null) {
        if (b.apps.size() > 0 && !inStopping) {
          boolean inFg=false;
          for (int i=b.apps.size() - 1; i >= 0; i--) {
            ProcessRecord client=b.apps.valueAt(i).client;
            if (client != null && client.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE) {
              inFg=true;
              break;
            }
          }
          requestServiceBindingLocked(r,b,inFg,true);
        }
 else {
          b.doRebind=true;
        }
      }
      serviceDoneExecutingLocked(r,inStopping);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","void unbindFinishedLocked(ServiceRecord r,Intent intent,boolean doRebind){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ b+ ""String_Node_Str""+ (b != null ? b.apps.size() : 0));
      boolean inDestroying=mDestroyingServices.contains(r);
      if (b != null) {
        if (b.apps.size() > 0 && !inDestroying) {
          boolean inFg=false;
          for (int i=b.apps.size() - 1; i >= 0; i--) {
            ProcessRecord client=b.apps.valueAt(i).client;
            if (client != null && client.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE) {
              inFg=true;
              break;
            }
          }
          requestServiceBindingLocked(r,b,inFg,true);
        }
 else {
          b.doRebind=true;
        }
      }
      serviceDoneExecutingLocked(r,inDestroying,false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
1122,"private final void bringDownServiceIfNeededLocked(ServiceRecord r,boolean knowConn,boolean hasConn){
  if (r.startRequested) {
    return;
  }
  if (!knowConn) {
    hasConn=r.hasAutoCreateConnections();
  }
  if (hasConn) {
    return;
  }
  if (mPendingServices.contains(r)) {
    return;
  }
  bringDownServiceLocked(r);
}","private final void bringDownServiceIfNeededLocked(ServiceRecord r,boolean knowConn,boolean hasConn){
  if (isServiceNeeded(r,knowConn,hasConn)) {
    return;
  }
  if (mPendingServices.contains(r)) {
    return;
  }
  bringDownServiceLocked(r);
}"
1123,"private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mStoppingServices.add(r);
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.makeInactive();
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}","private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}"
1124,"void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceDoneExecutingLocked(s,true);
      }
    }
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}","void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceDoneExecutingLocked(s,true,true);
      }
    }
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}"
1125,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  if (code == SYSPROPS_TRANSACTION) {
    ArrayList<IBinder> procs=new ArrayList<IBinder>();
synchronized (this) {
      final int NP=mProcessNames.getMap().size();
      for (int ip=0; ip < NP; ip++) {
        SparseArray<ProcessRecord> apps=mProcessNames.getMap().valueAt(ip);
        final int NA=apps.size();
        for (int ia=0; ia < NA; ia++) {
          ProcessRecord app=apps.valueAt(ia);
          if (app.thread != null) {
            procs.add(app.thread.asBinder());
          }
        }
      }
    }
    int N=procs.size();
    for (int i=0; i < N; i++) {
      Parcel data2=Parcel.obtain();
      try {
        procs.get(i).transact(IBinder.SYSPROPS_TRANSACTION,data2,null,0);
      }
 catch (      RemoteException e) {
      }
      data2.recycle();
    }
  }
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  if (code == SYSPROPS_TRANSACTION) {
    ArrayList<IBinder> procs=new ArrayList<IBinder>();
synchronized (this) {
      final int NP=mProcessNames.getMap().size();
      for (int ip=0; ip < NP; ip++) {
        SparseArray<ProcessRecord> apps=mProcessNames.getMap().valueAt(ip);
        final int NA=apps.size();
        for (int ia=0; ia < NA; ia++) {
          ProcessRecord app=apps.valueAt(ia);
          if (app.thread != null) {
            procs.add(app.thread.asBinder());
          }
        }
      }
    }
    int N=procs.size();
    for (int i=0; i < N; i++) {
      Parcel data2=Parcel.obtain();
      try {
        procs.get(i).transact(IBinder.SYSPROPS_TRANSACTION,data2,null,0);
      }
 catch (      RemoteException e) {
      }
      data2.recycle();
    }
  }
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.wtf(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}"
1126,"/** 
 * What a Terrible Failure: Report an exception that should never happen. Similar to   {@link #wtf(String,Throwable)}, with a message as well.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 * @param tr An exception to log.  May be null.
 */
public static int wtf(String tag,String msg,Throwable tr){
  TerribleFailure what=new TerribleFailure(msg,tr);
  int bytes=println_native(LOG_ID_MAIN,ASSERT,tag,msg + '\n' + getStackTraceString(tr));
  sWtfHandler.onTerribleFailure(tag,what);
  return bytes;
}","static int wtf(int logId,String tag,String msg,Throwable tr){
  TerribleFailure what=new TerribleFailure(msg,tr);
  int bytes=println_native(logId,ASSERT,tag,msg + '\n' + getStackTraceString(tr));
  sWtfHandler.onTerribleFailure(tag,what);
  return bytes;
}"
1127,"void dumpFilteredSummaryLocked(PrintWriter pw,String header,String prefix,int[] screenStates,int[] memStates,int[] procStates,int[] sortProcStates,long now,long totalTime,String reqPackage){
  ArrayList<ProcessState> procs=collectProcessesLocked(screenStates,memStates,procStates,sortProcStates,now,reqPackage);
  if (procs.size() > 0) {
    if (header != null) {
      pw.println();
      pw.println(header);
    }
    dumpProcessSummaryLocked(pw,prefix,procs,screenStates,memStates,sortProcStates,now,totalTime);
  }
}","void dumpFilteredSummaryLocked(PrintWriter pw,String header,String prefix,int[] screenStates,int[] memStates,int[] procStates,int[] sortProcStates,long now,long totalTime,String reqPackage,boolean activeOnly){
  ArrayList<ProcessState> procs=collectProcessesLocked(screenStates,memStates,procStates,sortProcStates,now,reqPackage,activeOnly);
  if (procs.size() > 0) {
    if (header != null) {
      pw.println();
      pw.println(header);
    }
    dumpProcessSummaryLocked(pw,prefix,procs,screenStates,memStates,sortProcStates,now,totalTime);
  }
}"
1128,"public void setExecuting(boolean executing,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addDuration(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
    updateRunning(memFactor,now);
  }
}","public void setExecuting(boolean executing,int memFactor,long now){
  if (mOwner == null) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addDuration(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
    updateRunning(memFactor,now);
  }
}"
1129,"private void ensureNotDead(){
  if (!mDead) {
    return;
  }
  throw new IllegalStateException(""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
}","private void ensureNotDead(){
  if (!mDead) {
    return;
  }
  Slog.wtfStack(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
}"
1130,"public ProcessStats.ServiceState getServiceStateLocked(String packageName,int uid,String processName,String className){
  final ProcessStats.PackageState as=getPackageStateLocked(packageName,uid);
  ProcessStats.ServiceState ss=as.mServices.get(className);
  if (ss != null) {
    return ss;
  }
  final ProcessStats.ProcessState ps=processName != null ? getProcessStateLocked(packageName,uid,processName) : null;
  ss=new ProcessStats.ServiceState(this,packageName,className,processName,ps);
  as.mServices.put(className,ss);
  return ss;
}","public ProcessStats.ServiceState getServiceStateLocked(String packageName,int uid,String processName,String className){
  final ProcessStats.PackageState as=getPackageStateLocked(packageName,uid);
  ProcessStats.ServiceState ss=as.mServices.get(className);
  if (ss != null) {
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + ss);
    return ss;
  }
  final ProcessStats.ProcessState ps=processName != null ? getProcessStateLocked(packageName,uid,processName) : null;
  ss=new ProcessStats.ServiceState(this,packageName,className,processName,ps);
  as.mServices.put(className,ss);
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + ss + ""String_Node_Str""+ ps);
  return ss;
}"
1131,"private int[] readTableFromParcel(Parcel in,String name,String what){
  final int size=in.readInt();
  if (size < 0) {
    Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ size);
    return BAD_TABLE;
  }
  if (size == 0) {
    return null;
  }
  final int[] table=new int[size];
  for (int i=0; i < size; i++) {
    table[i]=in.readInt();
    if (DEBUG)     Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ i+ ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
    if (!validateLongOffset(table[i])) {
      Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
      return null;
    }
  }
  return table;
}","private int[] readTableFromParcel(Parcel in,String name,String what){
  final int size=in.readInt();
  if (size < 0) {
    Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ size);
    return BAD_TABLE;
  }
  if (size == 0) {
    return null;
  }
  final int[] table=new int[size];
  for (int i=0; i < size; i++) {
    table[i]=in.readInt();
    if (DEBUG_PARCEL)     Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ i+ ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
    if (!validateLongOffset(table[i])) {
      Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
      return null;
    }
  }
  return table;
}"
1132,"public void makeActive(){
  if (mActive == 0) {
    mProc.incActiveServices();
  }
  mActive++;
}","public void makeActive(){
  ensureNotDead();
  mActive=true;
}"
1133,"public void makeInactive(){
  mActive--;
  if (mActive == 0) {
    mProc.decActiveServices();
  }
}","public void makeInactive(){
  mActive=false;
}"
1134,"public ProcessState getProcessStateLocked(String packageName,int uid,String processName){
  final PackageState pkgState=getPackageStateLocked(packageName,uid);
  ProcessState ps=pkgState.mProcesses.get(processName);
  if (ps != null) {
    return ps;
  }
  ProcessState commonProc=mProcesses.get(processName,uid);
  if (commonProc == null) {
    commonProc=new ProcessState(this,packageName,uid,processName);
    mProcesses.put(processName,uid,commonProc);
  }
  if (!commonProc.mMultiPackage) {
    if (packageName.equals(commonProc.mPackage)) {
      ps=commonProc;
    }
 else {
      commonProc.mMultiPackage=true;
      long now=SystemClock.uptimeMillis();
      final PackageState commonPkgState=getPackageStateLocked(commonProc.mPackage,uid);
      if (commonPkgState != null) {
        commonPkgState.mProcesses.put(commonProc.mName,commonProc.clone(commonProc.mPackage,now));
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + commonProc.mPackage + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc.mName);
      }
      ps=new ProcessState(commonProc,packageName,uid,processName,now);
    }
  }
 else {
    ps=new ProcessState(commonProc,packageName,uid,processName,SystemClock.uptimeMillis());
  }
  pkgState.mProcesses.put(processName,ps);
  return ps;
}","public ProcessState getProcessStateLocked(String packageName,int uid,String processName){
  final PackageState pkgState=getPackageStateLocked(packageName,uid);
  ProcessState ps=pkgState.mProcesses.get(processName);
  if (ps != null) {
    return ps;
  }
  ProcessState commonProc=mProcesses.get(processName,uid);
  if (commonProc == null) {
    commonProc=new ProcessState(this,packageName,uid,processName);
    mProcesses.put(processName,uid,commonProc);
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + commonProc);
  }
  if (!commonProc.mMultiPackage) {
    if (packageName.equals(commonProc.mPackage)) {
      ps=commonProc;
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + commonProc);
    }
 else {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"");
      commonProc.mMultiPackage=true;
      long now=SystemClock.uptimeMillis();
      final PackageState commonPkgState=getPackageStateLocked(commonProc.mPackage,uid);
      if (commonPkgState != null) {
        ProcessState cloned=commonProc.clone(commonProc.mPackage,now);
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"" + commonProc.mPackage + ""String_Node_Str""+ cloned);
        commonPkgState.mProcesses.put(commonProc.mName,cloned);
        for (int i=commonPkgState.mServices.size() - 1; i >= 0; i--) {
          ServiceState ss=commonPkgState.mServices.valueAt(i);
          if (ss.mProc == commonProc) {
            if (DEBUG)             Slog.d(TAG,""String_Node_Str"" + ss);
            ss.mProc=cloned;
          }
 else           if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"" + ss);
          }
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + commonProc.mPackage + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc.mName);
      }
      ps=new ProcessState(commonProc,packageName,uid,processName,now);
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + ps);
    }
  }
 else {
    ps=new ProcessState(commonProc,packageName,uid,processName,SystemClock.uptimeMillis());
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + ps);
  }
  pkgState.mProcesses.put(processName,ps);
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + ps);
  return ps;
}"
1135,"void incActiveServices(){
  if (mCommonProcess != this) {
    mCommonProcess.incActiveServices();
  }
  mNumActiveServices++;
}","void incActiveServices(String serviceName){
  if (DEBUG && ""String_Node_Str"".equals(mName)) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.d(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ (mNumActiveServices + 1),here);
  }
  if (mCommonProcess != this) {
    mCommonProcess.incActiveServices(serviceName);
  }
  mNumActiveServices++;
}"
1136,"public void dumpSummaryLocked(PrintWriter pw,String reqPackage,long now){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  dumpFilteredSummaryLocked(pw,null,""String_Node_Str"",ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,NON_CACHED_PROC_STATES,now,totalTime,reqPackage);
  pw.println();
  dumpTotalsLocked(pw,now);
}","public void dumpSummaryLocked(PrintWriter pw,String reqPackage,long now,boolean activeOnly){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  dumpFilteredSummaryLocked(pw,null,""String_Node_Str"",ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,NON_CACHED_PROC_STATES,now,totalTime,reqPackage,activeOnly);
  pw.println();
  dumpTotalsLocked(pw,now);
}"
1137,"boolean validateLongOffset(int off){
  int arr=(off >> OFFSET_ARRAY_SHIFT) & OFFSET_ARRAY_MASK;
  if (arr >= mLongs.size()) {
    return false;
  }
  int idx=(off >> OFFSET_INDEX_SHIFT) & OFFSET_INDEX_MASK;
  if (idx >= LONGS_SIZE) {
    return false;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + printLongOffset(off) + ""String_Node_Str""+ getLong(off,0));
  return true;
}","boolean validateLongOffset(int off){
  int arr=(off >> OFFSET_ARRAY_SHIFT) & OFFSET_ARRAY_MASK;
  if (arr >= mLongs.size()) {
    return false;
  }
  int idx=(off >> OFFSET_INDEX_SHIFT) & OFFSET_INDEX_MASK;
  if (idx >= LONGS_SIZE) {
    return false;
  }
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"" + printLongOffset(off) + ""String_Node_Str""+ getLong(off,0));
  return true;
}"
1138,"public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpSummary,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (!dumpSummary || dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        pw.print(""String_Node_Str"");
        pw.println(svc.mProcessName);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mRunCount,ServiceState.SERVICE_RUN,svc.mRunState,svc.mRunStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,!dumpSummary || dumpAll);
        if (dumpAll) {
          pw.print(""String_Node_Str"");
          pw.println(svc.mActive);
        }
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    int numShownProcs=0, numTotalProcs=0;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        numTotalProcs++;
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        numShownProcs++;
        if (!printedHeader) {
          pw.println();
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
        if (dumpAll) {
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
    }
    if (dumpAll) {
      pw.println();
      pw.print(""String_Node_Str"");
      pw.print(numShownProcs);
      pw.print(""String_Node_Str"");
      pw.print(numTotalProcs);
      pw.println(""String_Node_Str"");
    }
    pw.println();
    if (dumpSummary) {
      pw.println(""String_Node_Str"");
      dumpSummaryLocked(pw,reqPackage,now);
    }
 else {
      dumpTotalsLocked(pw,now);
    }
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}","public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpSummary,boolean dumpAll,boolean activeOnly){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (!dumpSummary || dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (activeOnly && !proc.isInUse()) {
            pw.print(""String_Node_Str"");
            pw.print(pkgState.mProcesses.keyAt(iproc));
            pw.println(""String_Node_Str"");
            continue;
          }
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (activeOnly && !proc.isInUse()) {
            continue;
          }
          procs.add(proc);
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        if (activeOnly && !svc.isInUse()) {
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mServices.keyAt(isvc));
          pw.println(""String_Node_Str"");
          continue;
        }
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(svc.mProcessName);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mRunCount,ServiceState.SERVICE_RUN,svc.mRunState,svc.mRunStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,!dumpSummary || dumpAll);
        if (dumpAll) {
          if (svc.mOwner != null) {
            pw.print(""String_Node_Str"");
            pw.println(svc.mOwner);
          }
        }
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    int numShownProcs=0, numTotalProcs=0;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        numTotalProcs++;
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        numShownProcs++;
        if (!printedHeader) {
          pw.println();
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        if (activeOnly && !proc.isInUse()) {
          pw.print(""String_Node_Str"");
          pw.print(procName);
          pw.println(""String_Node_Str"");
          continue;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
        if (dumpAll) {
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
    }
    if (dumpAll) {
      pw.println();
      pw.print(""String_Node_Str"");
      pw.print(numShownProcs);
      pw.print(""String_Node_Str"");
      pw.print(numTotalProcs);
      pw.println(""String_Node_Str"");
    }
    pw.println();
    if (dumpSummary) {
      pw.println(""String_Node_Str"");
      dumpSummaryLocked(pw,reqPackage,now,activeOnly);
    }
 else {
      dumpTotalsLocked(pw,now);
    }
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}"
1139,"static byte[] readFully(InputStream stream,int[] outLen) throws IOException {
  int pos=0;
  final int initialAvail=stream.available();
  byte[] data=new byte[initialAvail > 0 ? (initialAvail + 1) : 16384];
  while (true) {
    int amt=stream.read(data,pos,data.length - pos);
    if (DEBUG)     Slog.i(""String_Node_Str"",""String_Node_Str"" + amt + ""String_Node_Str""+ pos+ ""String_Node_Str""+ data.length);
    if (amt < 0) {
      if (DEBUG)       Slog.i(""String_Node_Str"",""String_Node_Str"" + pos + ""String_Node_Str""+ data.length);
      outLen[0]=pos;
      return data;
    }
    pos+=amt;
    if (pos >= data.length) {
      byte[] newData=new byte[pos + 16384];
      if (DEBUG)       Slog.i(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ newData.length);
      System.arraycopy(data,0,newData,0,pos);
      data=newData;
    }
  }
}","static byte[] readFully(InputStream stream,int[] outLen) throws IOException {
  int pos=0;
  final int initialAvail=stream.available();
  byte[] data=new byte[initialAvail > 0 ? (initialAvail + 1) : 16384];
  while (true) {
    int amt=stream.read(data,pos,data.length - pos);
    if (DEBUG_PARCEL)     Slog.i(""String_Node_Str"",""String_Node_Str"" + amt + ""String_Node_Str""+ pos+ ""String_Node_Str""+ data.length);
    if (amt < 0) {
      if (DEBUG_PARCEL)       Slog.i(""String_Node_Str"",""String_Node_Str"" + pos + ""String_Node_Str""+ data.length);
      outLen[0]=pos;
      return data;
    }
    pos+=amt;
    if (pos >= data.length) {
      byte[] newData=new byte[pos + 16384];
      if (DEBUG_PARCEL)       Slog.i(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ newData.length);
      System.arraycopy(data,0,newData,0,pos);
      data=newData;
    }
  }
}"
1140,"public void setStarted(boolean started,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final boolean wasStarted=mStartedState != STATE_NOTHING;
  final int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addDuration(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    mProc=mProc.pullFixedProc(mPackage);
    if (wasStarted != started) {
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
    updateRunning(memFactor,now);
  }
}","public void setStarted(boolean started,int memFactor,long now){
  if (mOwner == null) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final boolean wasStarted=mStartedState != STATE_NOTHING;
  final int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addDuration(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    mProc=mProc.pullFixedProc(mPackage);
    if (wasStarted != started) {
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
    updateRunning(memFactor,now);
  }
}"
1141,"public ArrayList<ProcessState> collectProcessesLocked(int[] screenStates,int[] memStates,int[] procStates,int sortProcStates[],long now,String reqPackage){
  ArraySet<ProcessState> foundProcs=new ArraySet<ProcessState>();
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    if (reqPackage != null && !reqPackage.equals(pkgMap.keyAt(ip))) {
      continue;
    }
    SparseArray<PackageState> procs=pkgMap.valueAt(ip);
    for (int iu=0; iu < procs.size(); iu++) {
      PackageState state=procs.valueAt(iu);
      for (int iproc=0; iproc < state.mProcesses.size(); iproc++) {
        ProcessState proc=state.mProcesses.valueAt(iproc);
        foundProcs.add(proc.mCommonProcess);
      }
    }
  }
  ArrayList<ProcessState> outProcs=new ArrayList<ProcessState>(foundProcs.size());
  for (int i=0; i < foundProcs.size(); i++) {
    ProcessState proc=foundProcs.valueAt(i);
    if (computeProcessTimeLocked(proc,screenStates,memStates,procStates,now) > 0) {
      outProcs.add(proc);
      if (procStates != sortProcStates) {
        computeProcessTimeLocked(proc,screenStates,memStates,sortProcStates,now);
      }
    }
  }
  Collections.sort(outProcs,new Comparator<ProcessState>(){
    @Override public int compare(    ProcessState lhs,    ProcessState rhs){
      if (lhs.mTmpTotalTime < rhs.mTmpTotalTime) {
        return -1;
      }
 else       if (lhs.mTmpTotalTime > rhs.mTmpTotalTime) {
        return 1;
      }
      return 0;
    }
  }
);
  return outProcs;
}","public ArrayList<ProcessState> collectProcessesLocked(int[] screenStates,int[] memStates,int[] procStates,int sortProcStates[],long now,String reqPackage,boolean activeOnly){
  ArraySet<ProcessState> foundProcs=new ArraySet<ProcessState>();
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    if (reqPackage != null && !reqPackage.equals(pkgMap.keyAt(ip))) {
      continue;
    }
    SparseArray<PackageState> procs=pkgMap.valueAt(ip);
    for (int iu=0; iu < procs.size(); iu++) {
      PackageState state=procs.valueAt(iu);
      for (int iproc=0; iproc < state.mProcesses.size(); iproc++) {
        ProcessState proc=state.mProcesses.valueAt(iproc);
        if (activeOnly && !proc.isInUse()) {
          continue;
        }
        foundProcs.add(proc.mCommonProcess);
      }
    }
  }
  ArrayList<ProcessState> outProcs=new ArrayList<ProcessState>(foundProcs.size());
  for (int i=0; i < foundProcs.size(); i++) {
    ProcessState proc=foundProcs.valueAt(i);
    if (computeProcessTimeLocked(proc,screenStates,memStates,procStates,now) > 0) {
      outProcs.add(proc);
      if (procStates != sortProcStates) {
        computeProcessTimeLocked(proc,screenStates,memStates,sortProcStates,now);
      }
    }
  }
  Collections.sort(outProcs,new Comparator<ProcessState>(){
    @Override public int compare(    ProcessState lhs,    ProcessState rhs){
      if (lhs.mTmpTotalTime < rhs.mTmpTotalTime) {
        return -1;
      }
 else       if (lhs.mTmpTotalTime > rhs.mTmpTotalTime) {
        return 1;
      }
      return 0;
    }
  }
);
  return outProcs;
}"
1142,"void writeDurationsToParcel(Parcel out){
  out.writeInt(mDurationsTableSize);
  for (int i=0; i < mDurationsTableSize; i++) {
    if (DEBUG)     Slog.i(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ i+ ""String_Node_Str""+ printLongOffset(mDurationsTable[i]));
    out.writeInt(mDurationsTable[i]);
  }
}","void writeDurationsToParcel(Parcel out){
  out.writeInt(mDurationsTableSize);
  for (int i=0; i < mDurationsTableSize; i++) {
    if (DEBUG_PARCEL)     Slog.i(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ i+ ""String_Node_Str""+ printLongOffset(mDurationsTable[i]));
    out.writeInt(mDurationsTable[i]);
  }
}"
1143,"void decStartedServices(int memFactor,long now){
  if (mCommonProcess != this) {
    mCommonProcess.decStartedServices(memFactor,now);
  }
  mNumStartedServices--;
  if (mNumStartedServices == 0 && mCurState == STATE_SERVICE_RESTARTING) {
    setState(STATE_NOTHING,memFactor,now,null);
  }
 else   if (mNumStartedServices < 0) {
    throw new IllegalStateException(""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName);
  }
}","void decStartedServices(int memFactor,long now){
  if (mCommonProcess != this) {
    mCommonProcess.decStartedServices(memFactor,now);
  }
  mNumStartedServices--;
  if (mNumStartedServices == 0 && mCurState == STATE_SERVICE_RESTARTING) {
    setState(STATE_NOTHING,memFactor,now,null);
  }
 else   if (mNumStartedServices < 0) {
    Slog.wtfStack(TAG,""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName);
    mNumStartedServices=0;
  }
}"
1144,"void decActiveServices(){
  if (mCommonProcess != this) {
    mCommonProcess.decActiveServices();
  }
  mNumActiveServices--;
  if (mNumActiveServices < 0) {
    throw new IllegalStateException(""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName);
  }
}","void decActiveServices(String serviceName){
  if (DEBUG && ""String_Node_Str"".equals(mName)) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.d(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ (mNumActiveServices - 1),here);
  }
  if (mCommonProcess != this) {
    mCommonProcess.decActiveServices(serviceName);
  }
  mNumActiveServices--;
  if (mNumActiveServices < 0) {
    Slog.wtfStack(TAG,""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName+ ""String_Node_Str""+ serviceName);
    mNumActiveServices=0;
  }
}"
1145,"private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (mDead && proc.mCommonProcess != proc) {
    Log.wtf(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
    proc=mStats.getProcessStateLocked(proc.mPackage,proc.mUid,proc.mName);
  }
  if (proc.mMultiPackage) {
    PackageState pkg=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid);
    if (pkg == null) {
      throw new IllegalStateException(""String_Node_Str"" + pkgList.keyAt(index) + ""String_Node_Str""+ proc.mName);
    }
    proc=pkg.mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}","private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (mDead && proc.mCommonProcess != proc) {
    Log.wtf(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
    proc=mStats.getProcessStateLocked(proc.mPackage,proc.mUid,proc.mName);
  }
  if (proc.mMultiPackage) {
    PackageState pkg=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid);
    if (pkg == null) {
      throw new IllegalStateException(""String_Node_Str"" + pkgList.keyAt(index) + ""String_Node_Str""+ proc.mUid+ ""String_Node_Str""+ proc.mName);
    }
    proc=pkg.mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"" + proc.mName + ""String_Node_Str""+ pkg.mPackageName+ ""String_Node_Str""+ pkg.mUid);
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}"
1146,"ProcessState clone(String pkg,long now){
  ProcessState pnew=new ProcessState(this,pkg,mUid,mName,now);
  copyDurationsTo(pnew);
  if (mPssTable != null) {
    mStats.mAddLongTable=new int[mPssTable.length];
    mStats.mAddLongTableSize=0;
    for (int i=0; i < mPssTableSize; i++) {
      int origEnt=mPssTable[i];
      int type=(origEnt >> OFFSET_TYPE_SHIFT) & OFFSET_TYPE_MASK;
      int newOff=mStats.addLongData(i,type,PSS_COUNT);
      mStats.mAddLongTable[i]=newOff | type;
      for (int j=0; j < PSS_COUNT; j++) {
        mStats.setLong(newOff,j,mStats.getLong(origEnt,j));
      }
    }
    pnew.mPssTable=mStats.mAddLongTable;
    pnew.mPssTableSize=mStats.mAddLongTableSize;
  }
  pnew.mNumExcessiveWake=mNumExcessiveWake;
  pnew.mNumExcessiveCpu=mNumExcessiveCpu;
  pnew.mNumCachedKill=mNumCachedKill;
  pnew.mMinCachedKillPss=mMinCachedKillPss;
  pnew.mAvgCachedKillPss=mAvgCachedKillPss;
  pnew.mMaxCachedKillPss=mMaxCachedKillPss;
  pnew.mActive=mActive;
  pnew.mNumStartedServices=mNumStartedServices;
  return pnew;
}","ProcessState clone(String pkg,long now){
  ProcessState pnew=new ProcessState(this,pkg,mUid,mName,now);
  copyDurationsTo(pnew);
  if (mPssTable != null) {
    mStats.mAddLongTable=new int[mPssTable.length];
    mStats.mAddLongTableSize=0;
    for (int i=0; i < mPssTableSize; i++) {
      int origEnt=mPssTable[i];
      int type=(origEnt >> OFFSET_TYPE_SHIFT) & OFFSET_TYPE_MASK;
      int newOff=mStats.addLongData(i,type,PSS_COUNT);
      mStats.mAddLongTable[i]=newOff | type;
      for (int j=0; j < PSS_COUNT; j++) {
        mStats.setLong(newOff,j,mStats.getLong(origEnt,j));
      }
    }
    pnew.mPssTable=mStats.mAddLongTable;
    pnew.mPssTableSize=mStats.mAddLongTableSize;
  }
  pnew.mNumExcessiveWake=mNumExcessiveWake;
  pnew.mNumExcessiveCpu=mNumExcessiveCpu;
  pnew.mNumCachedKill=mNumCachedKill;
  pnew.mMinCachedKillPss=mMinCachedKillPss;
  pnew.mAvgCachedKillPss=mAvgCachedKillPss;
  pnew.mMaxCachedKillPss=mMaxCachedKillPss;
  pnew.mActive=mActive;
  pnew.mNumActiveServices=mNumActiveServices;
  pnew.mNumStartedServices=mNumStartedServices;
  return pnew;
}"
1147,"public void setBound(boolean bound,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addDuration(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
    updateRunning(memFactor,now);
  }
}","public void setBound(boolean bound,int memFactor,long now){
  if (mOwner == null) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addDuration(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
    updateRunning(memFactor,now);
  }
}"
1148,"public boolean isInUse(){
  return mActive > 0;
}","public boolean isInUse(){
  return mOwner != null;
}"
1149,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    Slog.w(""String_Node_Str"",""String_Node_Str"",e);
    throw e;
  }
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.wtf(""String_Node_Str"",""String_Node_Str"",e);
    }
    throw e;
  }
}"
1150,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.wtf(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}"
1151,"private void serviceDoneExecutingLocked(ServiceRecord r,boolean inStopping){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inStopping+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inStopping) {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r);
        mStoppingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (inStopping) {
        r.tracker.makeInactive();
        r.tracker=null;
      }
    }
  }
}","private void serviceDoneExecutingLocked(ServiceRecord r,boolean inDestroying,boolean finishing){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inDestroying+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inDestroying) {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r);
        mDestroyingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (finishing) {
        r.tracker.clearCurrentOwner(r);
        r.tracker=null;
      }
    }
  }
}"
1152,"/** 
 * Prints a list of ServiceRecords (dumpsys activity services)
 */
void dumpServicesLocked(FileDescriptor fd,PrintWriter pw,String[] args,int opti,boolean dumpAll,boolean dumpClient,String dumpPackage){
  boolean needSep=false;
  boolean printedAnything=false;
  ItemMatcher matcher=new ItemMatcher();
  matcher.build(args,opti);
  pw.println(""String_Node_Str"");
  try {
    int[] users=mAm.getUsersLocked();
    for (    int user : users) {
      ServiceMap smap=getServiceMap(user);
      boolean printed=false;
      if (smap.mServicesByName.size() > 0) {
        long nowReal=SystemClock.elapsedRealtime();
        needSep=false;
        for (int si=0; si < smap.mServicesByName.size(); si++) {
          ServiceRecord r=smap.mServicesByName.valueAt(si);
          if (!matcher.match(r,r.name)) {
            continue;
          }
          if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
            continue;
          }
          if (!printed) {
            if (printedAnything) {
              pw.println();
            }
            pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
            printed=true;
          }
          printedAnything=true;
          if (needSep) {
            pw.println();
          }
          pw.print(""String_Node_Str"");
          pw.println(r);
          if (dumpAll) {
            r.dump(pw,""String_Node_Str"");
            needSep=true;
          }
 else {
            pw.print(""String_Node_Str"");
            pw.println(r.app);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(r.createTime,nowReal,pw);
            pw.print(""String_Node_Str"");
            pw.print(r.startRequested);
            pw.print(""String_Node_Str"");
            pw.println(r.connections.size());
            if (r.connections.size() > 0) {
              pw.println(""String_Node_Str"");
              for (int conni=0; conni < r.connections.size(); conni++) {
                ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
                for (int i=0; i < clist.size(); i++) {
                  ConnectionRecord conn=clist.get(i);
                  pw.print(""String_Node_Str"");
                  pw.print(conn.binding.intent.intent.getIntent().toShortString(false,false,false,false));
                  pw.print(""String_Node_Str"");
                  ProcessRecord proc=conn.binding.client;
                  pw.println(proc != null ? proc.toShortString() : ""String_Node_Str"");
                }
              }
            }
          }
          if (dumpClient && r.app != null && r.app.thread != null) {
            pw.println(""String_Node_Str"");
            pw.flush();
            try {
              TransferPipe tp=new TransferPipe();
              try {
                r.app.thread.dumpService(tp.getWriteFd().getFileDescriptor(),r,args);
                tp.setBufferPrefix(""String_Node_Str"");
                tp.go(fd,2000);
              }
  finally {
                tp.kill();
              }
            }
 catch (            IOException e) {
              pw.println(""String_Node_Str"" + e);
            }
catch (            RemoteException e) {
              pw.println(""String_Node_Str"");
            }
            needSep=true;
          }
        }
        needSep|=printed;
      }
      printed=false;
      for (int si=0, SN=smap.mDelayedStartList.size(); si < SN; si++) {
        ServiceRecord r=smap.mDelayedStartList.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
      printed=false;
      for (int si=0, SN=smap.mStartingBackground.size(); si < SN; si++) {
        ServiceRecord r=smap.mStartingBackground.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
    }
  }
 catch (  Exception e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mPendingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mPendingServices.size(); i++) {
      ServiceRecord r=mPendingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mRestartingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mRestartingServices.size(); i++) {
      ServiceRecord r=mRestartingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mStoppingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mStoppingServices.size(); i++) {
      ServiceRecord r=mStoppingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (dumpAll) {
    boolean printed=false;
    for (int ic=0; ic < mServiceConnections.size(); ic++) {
      ArrayList<ConnectionRecord> r=mServiceConnections.valueAt(ic);
      for (int i=0; i < r.size(); i++) {
        ConnectionRecord cr=r.get(i);
        if (!matcher.match(cr.binding.service,cr.binding.service.name)) {
          continue;
        }
        if (dumpPackage != null && (cr.binding.client == null || !dumpPackage.equals(cr.binding.client.info.packageName))) {
          continue;
        }
        printedAnything=true;
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
        }
        pw.print(""String_Node_Str"");
        pw.println(cr);
        cr.dump(pw,""String_Node_Str"");
      }
    }
  }
  if (!printedAnything) {
    pw.println(""String_Node_Str"");
  }
}","/** 
 * Prints a list of ServiceRecords (dumpsys activity services)
 */
void dumpServicesLocked(FileDescriptor fd,PrintWriter pw,String[] args,int opti,boolean dumpAll,boolean dumpClient,String dumpPackage){
  boolean needSep=false;
  boolean printedAnything=false;
  ItemMatcher matcher=new ItemMatcher();
  matcher.build(args,opti);
  pw.println(""String_Node_Str"");
  try {
    int[] users=mAm.getUsersLocked();
    for (    int user : users) {
      ServiceMap smap=getServiceMap(user);
      boolean printed=false;
      if (smap.mServicesByName.size() > 0) {
        long nowReal=SystemClock.elapsedRealtime();
        needSep=false;
        for (int si=0; si < smap.mServicesByName.size(); si++) {
          ServiceRecord r=smap.mServicesByName.valueAt(si);
          if (!matcher.match(r,r.name)) {
            continue;
          }
          if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
            continue;
          }
          if (!printed) {
            if (printedAnything) {
              pw.println();
            }
            pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
            printed=true;
          }
          printedAnything=true;
          if (needSep) {
            pw.println();
          }
          pw.print(""String_Node_Str"");
          pw.println(r);
          if (dumpAll) {
            r.dump(pw,""String_Node_Str"");
            needSep=true;
          }
 else {
            pw.print(""String_Node_Str"");
            pw.println(r.app);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(r.createTime,nowReal,pw);
            pw.print(""String_Node_Str"");
            pw.print(r.startRequested);
            pw.print(""String_Node_Str"");
            pw.println(r.connections.size());
            if (r.connections.size() > 0) {
              pw.println(""String_Node_Str"");
              for (int conni=0; conni < r.connections.size(); conni++) {
                ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
                for (int i=0; i < clist.size(); i++) {
                  ConnectionRecord conn=clist.get(i);
                  pw.print(""String_Node_Str"");
                  pw.print(conn.binding.intent.intent.getIntent().toShortString(false,false,false,false));
                  pw.print(""String_Node_Str"");
                  ProcessRecord proc=conn.binding.client;
                  pw.println(proc != null ? proc.toShortString() : ""String_Node_Str"");
                }
              }
            }
          }
          if (dumpClient && r.app != null && r.app.thread != null) {
            pw.println(""String_Node_Str"");
            pw.flush();
            try {
              TransferPipe tp=new TransferPipe();
              try {
                r.app.thread.dumpService(tp.getWriteFd().getFileDescriptor(),r,args);
                tp.setBufferPrefix(""String_Node_Str"");
                tp.go(fd,2000);
              }
  finally {
                tp.kill();
              }
            }
 catch (            IOException e) {
              pw.println(""String_Node_Str"" + e);
            }
catch (            RemoteException e) {
              pw.println(""String_Node_Str"");
            }
            needSep=true;
          }
        }
        needSep|=printed;
      }
      printed=false;
      for (int si=0, SN=smap.mDelayedStartList.size(); si < SN; si++) {
        ServiceRecord r=smap.mDelayedStartList.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
      printed=false;
      for (int si=0, SN=smap.mStartingBackground.size(); si < SN; si++) {
        ServiceRecord r=smap.mStartingBackground.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
    }
  }
 catch (  Exception e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mPendingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mPendingServices.size(); i++) {
      ServiceRecord r=mPendingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mRestartingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mRestartingServices.size(); i++) {
      ServiceRecord r=mRestartingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mDestroyingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mDestroyingServices.size(); i++) {
      ServiceRecord r=mDestroyingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (dumpAll) {
    boolean printed=false;
    for (int ic=0; ic < mServiceConnections.size(); ic++) {
      ArrayList<ConnectionRecord> r=mServiceConnections.valueAt(ic);
      for (int i=0; i < r.size(); i++) {
        ConnectionRecord cr=r.get(i);
        if (!matcher.match(cr.binding.service,cr.binding.service.name)) {
          continue;
        }
        if (dumpPackage != null && (cr.binding.client == null || !dumpPackage.equals(cr.binding.client.info.packageName))) {
          continue;
        }
        printedAnything=true;
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
        }
        pw.print(""String_Node_Str"");
        pw.println(cr);
        cr.dump(pw,""String_Node_Str"");
      }
    }
  }
  if (!printedAnything) {
    pw.println(""String_Node_Str"");
  }
}"
1153,"final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    if (sr.tracker != null) {
      sr.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
    }
    if (mStoppingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
    if (sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
  }
  int i=mStoppingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mStoppingServices.get(i);
    if (sr.app == app) {
      mStoppingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}","final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
    if (sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}"
1154,"void publishServiceLocked(ServiceRecord r,Intent intent,IBinder service){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ intent+ ""String_Node_Str""+ service);
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (b != null && !b.received) {
        b.binder=service;
        b.requested=true;
        b.received=true;
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
          for (int i=0; i < clist.size(); i++) {
            ConnectionRecord c=clist.get(i);
            if (!filter.equals(c.binding.intent.intent)) {
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c.binding.intent.intent);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + intent);
              continue;
            }
            if (DEBUG_SERVICE)             Slog.v(TAG,""String_Node_Str"" + c);
            try {
              c.conn.connected(r.name,service);
            }
 catch (            Exception e) {
              Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
            }
          }
        }
      }
      serviceDoneExecutingLocked(r,mStoppingServices.contains(r));
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","void publishServiceLocked(ServiceRecord r,Intent intent,IBinder service){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ intent+ ""String_Node_Str""+ service);
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (b != null && !b.received) {
        b.binder=service;
        b.requested=true;
        b.received=true;
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
          for (int i=0; i < clist.size(); i++) {
            ConnectionRecord c=clist.get(i);
            if (!filter.equals(c.binding.intent.intent)) {
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c.binding.intent.intent);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + intent);
              continue;
            }
            if (DEBUG_SERVICE)             Slog.v(TAG,""String_Node_Str"" + c);
            try {
              c.conn.connected(r.name,service);
            }
 catch (            Exception e) {
              Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
            }
          }
        }
      }
      serviceDoneExecutingLocked(r,mDestroyingServices.contains(r),false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
1155,"void unbindFinishedLocked(ServiceRecord r,Intent intent,boolean doRebind){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ b+ ""String_Node_Str""+ (b != null ? b.apps.size() : 0));
      boolean inStopping=mStoppingServices.contains(r);
      if (b != null) {
        if (b.apps.size() > 0 && !inStopping) {
          boolean inFg=false;
          for (int i=b.apps.size() - 1; i >= 0; i--) {
            ProcessRecord client=b.apps.valueAt(i).client;
            if (client != null && client.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE) {
              inFg=true;
              break;
            }
          }
          requestServiceBindingLocked(r,b,inFg,true);
        }
 else {
          b.doRebind=true;
        }
      }
      serviceDoneExecutingLocked(r,inStopping);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","void unbindFinishedLocked(ServiceRecord r,Intent intent,boolean doRebind){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ b+ ""String_Node_Str""+ (b != null ? b.apps.size() : 0));
      boolean inDestroying=mDestroyingServices.contains(r);
      if (b != null) {
        if (b.apps.size() > 0 && !inDestroying) {
          boolean inFg=false;
          for (int i=b.apps.size() - 1; i >= 0; i--) {
            ProcessRecord client=b.apps.valueAt(i).client;
            if (client != null && client.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE) {
              inFg=true;
              break;
            }
          }
          requestServiceBindingLocked(r,b,inFg,true);
        }
 else {
          b.doRebind=true;
        }
      }
      serviceDoneExecutingLocked(r,inDestroying,false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
1156,"private final void bringDownServiceIfNeededLocked(ServiceRecord r,boolean knowConn,boolean hasConn){
  if (r.startRequested) {
    return;
  }
  if (!knowConn) {
    hasConn=r.hasAutoCreateConnections();
  }
  if (hasConn) {
    return;
  }
  if (mPendingServices.contains(r)) {
    return;
  }
  bringDownServiceLocked(r);
}","private final void bringDownServiceIfNeededLocked(ServiceRecord r,boolean knowConn,boolean hasConn){
  if (isServiceNeeded(r,knowConn,hasConn)) {
    return;
  }
  if (mPendingServices.contains(r)) {
    return;
  }
  bringDownServiceLocked(r);
}"
1157,"private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mStoppingServices.add(r);
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.makeInactive();
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}","private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}"
1158,"void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceDoneExecutingLocked(s,true);
      }
    }
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}","void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceDoneExecutingLocked(s,true,true);
      }
    }
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}"
1159,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  if (code == SYSPROPS_TRANSACTION) {
    ArrayList<IBinder> procs=new ArrayList<IBinder>();
synchronized (this) {
      final int NP=mProcessNames.getMap().size();
      for (int ip=0; ip < NP; ip++) {
        SparseArray<ProcessRecord> apps=mProcessNames.getMap().valueAt(ip);
        final int NA=apps.size();
        for (int ia=0; ia < NA; ia++) {
          ProcessRecord app=apps.valueAt(ia);
          if (app.thread != null) {
            procs.add(app.thread.asBinder());
          }
        }
      }
    }
    int N=procs.size();
    for (int i=0; i < N; i++) {
      Parcel data2=Parcel.obtain();
      try {
        procs.get(i).transact(IBinder.SYSPROPS_TRANSACTION,data2,null,0);
      }
 catch (      RemoteException e) {
      }
      data2.recycle();
    }
  }
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  if (code == SYSPROPS_TRANSACTION) {
    ArrayList<IBinder> procs=new ArrayList<IBinder>();
synchronized (this) {
      final int NP=mProcessNames.getMap().size();
      for (int ip=0; ip < NP; ip++) {
        SparseArray<ProcessRecord> apps=mProcessNames.getMap().valueAt(ip);
        final int NA=apps.size();
        for (int ia=0; ia < NA; ia++) {
          ProcessRecord app=apps.valueAt(ia);
          if (app.thread != null) {
            procs.add(app.thread.asBinder());
          }
        }
      }
    }
    int N=procs.size();
    for (int i=0; i < N; i++) {
      Parcel data2=Parcel.obtain();
      try {
        procs.get(i).transact(IBinder.SYSPROPS_TRANSACTION,data2,null,0);
      }
 catch (      RemoteException e) {
      }
      data2.recycle();
    }
  }
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.wtf(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}"
1160,"/** 
 * What a Terrible Failure: Report an exception that should never happen. Similar to   {@link #wtf(String,Throwable)}, with a message as well.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 * @param tr An exception to log.  May be null.
 */
public static int wtf(String tag,String msg,Throwable tr){
  TerribleFailure what=new TerribleFailure(msg,tr);
  int bytes=println_native(LOG_ID_MAIN,ASSERT,tag,msg + '\n' + getStackTraceString(tr));
  sWtfHandler.onTerribleFailure(tag,what);
  return bytes;
}","static int wtf(int logId,String tag,String msg,Throwable tr){
  TerribleFailure what=new TerribleFailure(msg,tr);
  int bytes=println_native(logId,ASSERT,tag,msg + '\n' + getStackTraceString(tr));
  sWtfHandler.onTerribleFailure(tag,what);
  return bytes;
}"
1161,"void dumpFilteredSummaryLocked(PrintWriter pw,String header,String prefix,int[] screenStates,int[] memStates,int[] procStates,int[] sortProcStates,long now,long totalTime,String reqPackage){
  ArrayList<ProcessState> procs=collectProcessesLocked(screenStates,memStates,procStates,sortProcStates,now,reqPackage);
  if (procs.size() > 0) {
    if (header != null) {
      pw.println();
      pw.println(header);
    }
    dumpProcessSummaryLocked(pw,prefix,procs,screenStates,memStates,sortProcStates,now,totalTime);
  }
}","void dumpFilteredSummaryLocked(PrintWriter pw,String header,String prefix,int[] screenStates,int[] memStates,int[] procStates,int[] sortProcStates,long now,long totalTime,String reqPackage,boolean activeOnly){
  ArrayList<ProcessState> procs=collectProcessesLocked(screenStates,memStates,procStates,sortProcStates,now,reqPackage,activeOnly);
  if (procs.size() > 0) {
    if (header != null) {
      pw.println();
      pw.println(header);
    }
    dumpProcessSummaryLocked(pw,prefix,procs,screenStates,memStates,sortProcStates,now,totalTime);
  }
}"
1162,"public void setExecuting(boolean executing,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addDuration(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
    updateRunning(memFactor,now);
  }
}","public void setExecuting(boolean executing,int memFactor,long now){
  if (mOwner == null) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addDuration(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
    updateRunning(memFactor,now);
  }
}"
1163,"private void ensureNotDead(){
  if (!mDead) {
    return;
  }
  throw new IllegalStateException(""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
}","private void ensureNotDead(){
  if (!mDead) {
    return;
  }
  Slog.wtfStack(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
}"
1164,"public ProcessStats.ServiceState getServiceStateLocked(String packageName,int uid,String processName,String className){
  final ProcessStats.PackageState as=getPackageStateLocked(packageName,uid);
  ProcessStats.ServiceState ss=as.mServices.get(className);
  if (ss != null) {
    return ss;
  }
  final ProcessStats.ProcessState ps=processName != null ? getProcessStateLocked(packageName,uid,processName) : null;
  ss=new ProcessStats.ServiceState(this,packageName,className,processName,ps);
  as.mServices.put(className,ss);
  return ss;
}","public ProcessStats.ServiceState getServiceStateLocked(String packageName,int uid,String processName,String className){
  final ProcessStats.PackageState as=getPackageStateLocked(packageName,uid);
  ProcessStats.ServiceState ss=as.mServices.get(className);
  if (ss != null) {
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + ss);
    return ss;
  }
  final ProcessStats.ProcessState ps=processName != null ? getProcessStateLocked(packageName,uid,processName) : null;
  ss=new ProcessStats.ServiceState(this,packageName,className,processName,ps);
  as.mServices.put(className,ss);
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + ss + ""String_Node_Str""+ ps);
  return ss;
}"
1165,"private int[] readTableFromParcel(Parcel in,String name,String what){
  final int size=in.readInt();
  if (size < 0) {
    Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ size);
    return BAD_TABLE;
  }
  if (size == 0) {
    return null;
  }
  final int[] table=new int[size];
  for (int i=0; i < size; i++) {
    table[i]=in.readInt();
    if (DEBUG)     Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ i+ ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
    if (!validateLongOffset(table[i])) {
      Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
      return null;
    }
  }
  return table;
}","private int[] readTableFromParcel(Parcel in,String name,String what){
  final int size=in.readInt();
  if (size < 0) {
    Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ size);
    return BAD_TABLE;
  }
  if (size == 0) {
    return null;
  }
  final int[] table=new int[size];
  for (int i=0; i < size; i++) {
    table[i]=in.readInt();
    if (DEBUG_PARCEL)     Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ i+ ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
    if (!validateLongOffset(table[i])) {
      Slog.w(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ ProcessStats.printLongOffset(table[i]));
      return null;
    }
  }
  return table;
}"
1166,"public void makeActive(){
  if (mActive == 0) {
    mProc.incActiveServices();
  }
  mActive++;
}","public void makeActive(){
  ensureNotDead();
  mActive=true;
}"
1167,"public void makeInactive(){
  mActive--;
  if (mActive == 0) {
    mProc.decActiveServices();
  }
}","public void makeInactive(){
  mActive=false;
}"
1168,"public ProcessState getProcessStateLocked(String packageName,int uid,String processName){
  final PackageState pkgState=getPackageStateLocked(packageName,uid);
  ProcessState ps=pkgState.mProcesses.get(processName);
  if (ps != null) {
    return ps;
  }
  ProcessState commonProc=mProcesses.get(processName,uid);
  if (commonProc == null) {
    commonProc=new ProcessState(this,packageName,uid,processName);
    mProcesses.put(processName,uid,commonProc);
  }
  if (!commonProc.mMultiPackage) {
    if (packageName.equals(commonProc.mPackage)) {
      ps=commonProc;
    }
 else {
      commonProc.mMultiPackage=true;
      long now=SystemClock.uptimeMillis();
      final PackageState commonPkgState=getPackageStateLocked(commonProc.mPackage,uid);
      if (commonPkgState != null) {
        commonPkgState.mProcesses.put(commonProc.mName,commonProc.clone(commonProc.mPackage,now));
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + commonProc.mPackage + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc.mName);
      }
      ps=new ProcessState(commonProc,packageName,uid,processName,now);
    }
  }
 else {
    ps=new ProcessState(commonProc,packageName,uid,processName,SystemClock.uptimeMillis());
  }
  pkgState.mProcesses.put(processName,ps);
  return ps;
}","public ProcessState getProcessStateLocked(String packageName,int uid,String processName){
  final PackageState pkgState=getPackageStateLocked(packageName,uid);
  ProcessState ps=pkgState.mProcesses.get(processName);
  if (ps != null) {
    return ps;
  }
  ProcessState commonProc=mProcesses.get(processName,uid);
  if (commonProc == null) {
    commonProc=new ProcessState(this,packageName,uid,processName);
    mProcesses.put(processName,uid,commonProc);
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + commonProc);
  }
  if (!commonProc.mMultiPackage) {
    if (packageName.equals(commonProc.mPackage)) {
      ps=commonProc;
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + commonProc);
    }
 else {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"");
      commonProc.mMultiPackage=true;
      long now=SystemClock.uptimeMillis();
      final PackageState commonPkgState=getPackageStateLocked(commonProc.mPackage,uid);
      if (commonPkgState != null) {
        ProcessState cloned=commonProc.clone(commonProc.mPackage,now);
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"" + commonProc.mPackage + ""String_Node_Str""+ cloned);
        commonPkgState.mProcesses.put(commonProc.mName,cloned);
        for (int i=commonPkgState.mServices.size() - 1; i >= 0; i--) {
          ServiceState ss=commonPkgState.mServices.valueAt(i);
          if (ss.mProc == commonProc) {
            if (DEBUG)             Slog.d(TAG,""String_Node_Str"" + ss);
            ss.mProc=cloned;
          }
 else           if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"" + ss);
          }
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + commonProc.mPackage + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc.mName);
      }
      ps=new ProcessState(commonProc,packageName,uid,processName,now);
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + ps);
    }
  }
 else {
    ps=new ProcessState(commonProc,packageName,uid,processName,SystemClock.uptimeMillis());
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + ps);
  }
  pkgState.mProcesses.put(processName,ps);
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + ps);
  return ps;
}"
1169,"void incActiveServices(){
  if (mCommonProcess != this) {
    mCommonProcess.incActiveServices();
  }
  mNumActiveServices++;
}","void incActiveServices(String serviceName){
  if (DEBUG && ""String_Node_Str"".equals(mName)) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.d(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ (mNumActiveServices + 1),here);
  }
  if (mCommonProcess != this) {
    mCommonProcess.incActiveServices(serviceName);
  }
  mNumActiveServices++;
}"
1170,"public void dumpSummaryLocked(PrintWriter pw,String reqPackage,long now){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  dumpFilteredSummaryLocked(pw,null,""String_Node_Str"",ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,NON_CACHED_PROC_STATES,now,totalTime,reqPackage);
  pw.println();
  dumpTotalsLocked(pw,now);
}","public void dumpSummaryLocked(PrintWriter pw,String reqPackage,long now,boolean activeOnly){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  dumpFilteredSummaryLocked(pw,null,""String_Node_Str"",ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,NON_CACHED_PROC_STATES,now,totalTime,reqPackage,activeOnly);
  pw.println();
  dumpTotalsLocked(pw,now);
}"
1171,"boolean validateLongOffset(int off){
  int arr=(off >> OFFSET_ARRAY_SHIFT) & OFFSET_ARRAY_MASK;
  if (arr >= mLongs.size()) {
    return false;
  }
  int idx=(off >> OFFSET_INDEX_SHIFT) & OFFSET_INDEX_MASK;
  if (idx >= LONGS_SIZE) {
    return false;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + printLongOffset(off) + ""String_Node_Str""+ getLong(off,0));
  return true;
}","boolean validateLongOffset(int off){
  int arr=(off >> OFFSET_ARRAY_SHIFT) & OFFSET_ARRAY_MASK;
  if (arr >= mLongs.size()) {
    return false;
  }
  int idx=(off >> OFFSET_INDEX_SHIFT) & OFFSET_INDEX_MASK;
  if (idx >= LONGS_SIZE) {
    return false;
  }
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"" + printLongOffset(off) + ""String_Node_Str""+ getLong(off,0));
  return true;
}"
1172,"public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpSummary,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (!dumpSummary || dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        pw.print(""String_Node_Str"");
        pw.println(svc.mProcessName);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mRunCount,ServiceState.SERVICE_RUN,svc.mRunState,svc.mRunStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,!dumpSummary || dumpAll);
        if (dumpAll) {
          pw.print(""String_Node_Str"");
          pw.println(svc.mActive);
        }
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    int numShownProcs=0, numTotalProcs=0;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        numTotalProcs++;
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        numShownProcs++;
        if (!printedHeader) {
          pw.println();
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
        if (dumpAll) {
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
    }
    if (dumpAll) {
      pw.println();
      pw.print(""String_Node_Str"");
      pw.print(numShownProcs);
      pw.print(""String_Node_Str"");
      pw.print(numTotalProcs);
      pw.println(""String_Node_Str"");
    }
    pw.println();
    if (dumpSummary) {
      pw.println(""String_Node_Str"");
      dumpSummaryLocked(pw,reqPackage,now);
    }
 else {
      dumpTotalsLocked(pw,now);
    }
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}","public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpSummary,boolean dumpAll,boolean activeOnly){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (!dumpSummary || dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (activeOnly && !proc.isInUse()) {
            pw.print(""String_Node_Str"");
            pw.print(pkgState.mProcesses.keyAt(iproc));
            pw.println(""String_Node_Str"");
            continue;
          }
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (activeOnly && !proc.isInUse()) {
            continue;
          }
          procs.add(proc);
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        if (activeOnly && !svc.isInUse()) {
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mServices.keyAt(isvc));
          pw.println(""String_Node_Str"");
          continue;
        }
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(svc.mProcessName);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mRunCount,ServiceState.SERVICE_RUN,svc.mRunState,svc.mRunStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,!dumpSummary || dumpAll);
        if (dumpAll) {
          if (svc.mOwner != null) {
            pw.print(""String_Node_Str"");
            pw.println(svc.mOwner);
          }
        }
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    int numShownProcs=0, numTotalProcs=0;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        numTotalProcs++;
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        numShownProcs++;
        if (!printedHeader) {
          pw.println();
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        if (activeOnly && !proc.isInUse()) {
          pw.print(""String_Node_Str"");
          pw.print(procName);
          pw.println(""String_Node_Str"");
          continue;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
        if (dumpAll) {
          dumpProcessInternalLocked(pw,""String_Node_Str"",proc,dumpAll);
        }
      }
    }
    if (dumpAll) {
      pw.println();
      pw.print(""String_Node_Str"");
      pw.print(numShownProcs);
      pw.print(""String_Node_Str"");
      pw.print(numTotalProcs);
      pw.println(""String_Node_Str"");
    }
    pw.println();
    if (dumpSummary) {
      pw.println(""String_Node_Str"");
      dumpSummaryLocked(pw,reqPackage,now,activeOnly);
    }
 else {
      dumpTotalsLocked(pw,now);
    }
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}"
1173,"static byte[] readFully(InputStream stream,int[] outLen) throws IOException {
  int pos=0;
  final int initialAvail=stream.available();
  byte[] data=new byte[initialAvail > 0 ? (initialAvail + 1) : 16384];
  while (true) {
    int amt=stream.read(data,pos,data.length - pos);
    if (DEBUG)     Slog.i(""String_Node_Str"",""String_Node_Str"" + amt + ""String_Node_Str""+ pos+ ""String_Node_Str""+ data.length);
    if (amt < 0) {
      if (DEBUG)       Slog.i(""String_Node_Str"",""String_Node_Str"" + pos + ""String_Node_Str""+ data.length);
      outLen[0]=pos;
      return data;
    }
    pos+=amt;
    if (pos >= data.length) {
      byte[] newData=new byte[pos + 16384];
      if (DEBUG)       Slog.i(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ newData.length);
      System.arraycopy(data,0,newData,0,pos);
      data=newData;
    }
  }
}","static byte[] readFully(InputStream stream,int[] outLen) throws IOException {
  int pos=0;
  final int initialAvail=stream.available();
  byte[] data=new byte[initialAvail > 0 ? (initialAvail + 1) : 16384];
  while (true) {
    int amt=stream.read(data,pos,data.length - pos);
    if (DEBUG_PARCEL)     Slog.i(""String_Node_Str"",""String_Node_Str"" + amt + ""String_Node_Str""+ pos+ ""String_Node_Str""+ data.length);
    if (amt < 0) {
      if (DEBUG_PARCEL)       Slog.i(""String_Node_Str"",""String_Node_Str"" + pos + ""String_Node_Str""+ data.length);
      outLen[0]=pos;
      return data;
    }
    pos+=amt;
    if (pos >= data.length) {
      byte[] newData=new byte[pos + 16384];
      if (DEBUG_PARCEL)       Slog.i(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ newData.length);
      System.arraycopy(data,0,newData,0,pos);
      data=newData;
    }
  }
}"
1174,"public void setStarted(boolean started,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final boolean wasStarted=mStartedState != STATE_NOTHING;
  final int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addDuration(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    mProc=mProc.pullFixedProc(mPackage);
    if (wasStarted != started) {
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
    updateRunning(memFactor,now);
  }
}","public void setStarted(boolean started,int memFactor,long now){
  if (mOwner == null) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final boolean wasStarted=mStartedState != STATE_NOTHING;
  final int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addDuration(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    mProc=mProc.pullFixedProc(mPackage);
    if (wasStarted != started) {
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
    updateRunning(memFactor,now);
  }
}"
1175,"public ArrayList<ProcessState> collectProcessesLocked(int[] screenStates,int[] memStates,int[] procStates,int sortProcStates[],long now,String reqPackage){
  ArraySet<ProcessState> foundProcs=new ArraySet<ProcessState>();
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    if (reqPackage != null && !reqPackage.equals(pkgMap.keyAt(ip))) {
      continue;
    }
    SparseArray<PackageState> procs=pkgMap.valueAt(ip);
    for (int iu=0; iu < procs.size(); iu++) {
      PackageState state=procs.valueAt(iu);
      for (int iproc=0; iproc < state.mProcesses.size(); iproc++) {
        ProcessState proc=state.mProcesses.valueAt(iproc);
        foundProcs.add(proc.mCommonProcess);
      }
    }
  }
  ArrayList<ProcessState> outProcs=new ArrayList<ProcessState>(foundProcs.size());
  for (int i=0; i < foundProcs.size(); i++) {
    ProcessState proc=foundProcs.valueAt(i);
    if (computeProcessTimeLocked(proc,screenStates,memStates,procStates,now) > 0) {
      outProcs.add(proc);
      if (procStates != sortProcStates) {
        computeProcessTimeLocked(proc,screenStates,memStates,sortProcStates,now);
      }
    }
  }
  Collections.sort(outProcs,new Comparator<ProcessState>(){
    @Override public int compare(    ProcessState lhs,    ProcessState rhs){
      if (lhs.mTmpTotalTime < rhs.mTmpTotalTime) {
        return -1;
      }
 else       if (lhs.mTmpTotalTime > rhs.mTmpTotalTime) {
        return 1;
      }
      return 0;
    }
  }
);
  return outProcs;
}","public ArrayList<ProcessState> collectProcessesLocked(int[] screenStates,int[] memStates,int[] procStates,int sortProcStates[],long now,String reqPackage,boolean activeOnly){
  ArraySet<ProcessState> foundProcs=new ArraySet<ProcessState>();
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    if (reqPackage != null && !reqPackage.equals(pkgMap.keyAt(ip))) {
      continue;
    }
    SparseArray<PackageState> procs=pkgMap.valueAt(ip);
    for (int iu=0; iu < procs.size(); iu++) {
      PackageState state=procs.valueAt(iu);
      for (int iproc=0; iproc < state.mProcesses.size(); iproc++) {
        ProcessState proc=state.mProcesses.valueAt(iproc);
        if (activeOnly && !proc.isInUse()) {
          continue;
        }
        foundProcs.add(proc.mCommonProcess);
      }
    }
  }
  ArrayList<ProcessState> outProcs=new ArrayList<ProcessState>(foundProcs.size());
  for (int i=0; i < foundProcs.size(); i++) {
    ProcessState proc=foundProcs.valueAt(i);
    if (computeProcessTimeLocked(proc,screenStates,memStates,procStates,now) > 0) {
      outProcs.add(proc);
      if (procStates != sortProcStates) {
        computeProcessTimeLocked(proc,screenStates,memStates,sortProcStates,now);
      }
    }
  }
  Collections.sort(outProcs,new Comparator<ProcessState>(){
    @Override public int compare(    ProcessState lhs,    ProcessState rhs){
      if (lhs.mTmpTotalTime < rhs.mTmpTotalTime) {
        return -1;
      }
 else       if (lhs.mTmpTotalTime > rhs.mTmpTotalTime) {
        return 1;
      }
      return 0;
    }
  }
);
  return outProcs;
}"
1176,"void writeDurationsToParcel(Parcel out){
  out.writeInt(mDurationsTableSize);
  for (int i=0; i < mDurationsTableSize; i++) {
    if (DEBUG)     Slog.i(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ i+ ""String_Node_Str""+ printLongOffset(mDurationsTable[i]));
    out.writeInt(mDurationsTable[i]);
  }
}","void writeDurationsToParcel(Parcel out){
  out.writeInt(mDurationsTableSize);
  for (int i=0; i < mDurationsTableSize; i++) {
    if (DEBUG_PARCEL)     Slog.i(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ i+ ""String_Node_Str""+ printLongOffset(mDurationsTable[i]));
    out.writeInt(mDurationsTable[i]);
  }
}"
1177,"void decStartedServices(int memFactor,long now){
  if (mCommonProcess != this) {
    mCommonProcess.decStartedServices(memFactor,now);
  }
  mNumStartedServices--;
  if (mNumStartedServices == 0 && mCurState == STATE_SERVICE_RESTARTING) {
    setState(STATE_NOTHING,memFactor,now,null);
  }
 else   if (mNumStartedServices < 0) {
    throw new IllegalStateException(""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName);
  }
}","void decStartedServices(int memFactor,long now){
  if (mCommonProcess != this) {
    mCommonProcess.decStartedServices(memFactor,now);
  }
  mNumStartedServices--;
  if (mNumStartedServices == 0 && mCurState == STATE_SERVICE_RESTARTING) {
    setState(STATE_NOTHING,memFactor,now,null);
  }
 else   if (mNumStartedServices < 0) {
    Slog.wtfStack(TAG,""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName);
    mNumStartedServices=0;
  }
}"
1178,"void decActiveServices(){
  if (mCommonProcess != this) {
    mCommonProcess.decActiveServices();
  }
  mNumActiveServices--;
  if (mNumActiveServices < 0) {
    throw new IllegalStateException(""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName);
  }
}","void decActiveServices(String serviceName){
  if (DEBUG && ""String_Node_Str"".equals(mName)) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.d(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ (mNumActiveServices - 1),here);
  }
  if (mCommonProcess != this) {
    mCommonProcess.decActiveServices(serviceName);
  }
  mNumActiveServices--;
  if (mNumActiveServices < 0) {
    Slog.wtfStack(TAG,""String_Node_Str"" + mPackage + ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mName+ ""String_Node_Str""+ serviceName);
    mNumActiveServices=0;
  }
}"
1179,"private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (mDead && proc.mCommonProcess != proc) {
    Log.wtf(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
    proc=mStats.getProcessStateLocked(proc.mPackage,proc.mUid,proc.mName);
  }
  if (proc.mMultiPackage) {
    PackageState pkg=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid);
    if (pkg == null) {
      throw new IllegalStateException(""String_Node_Str"" + pkgList.keyAt(index) + ""String_Node_Str""+ proc.mName);
    }
    proc=pkg.mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}","private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (mDead && proc.mCommonProcess != proc) {
    Log.wtf(TAG,""String_Node_Str"" + mName + ""String_Node_Str""+ mPackage+ ""String_Node_Str""+ mUid+ ""String_Node_Str""+ mCommonProcess.mName);
    proc=mStats.getProcessStateLocked(proc.mPackage,proc.mUid,proc.mName);
  }
  if (proc.mMultiPackage) {
    PackageState pkg=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid);
    if (pkg == null) {
      throw new IllegalStateException(""String_Node_Str"" + pkgList.keyAt(index) + ""String_Node_Str""+ proc.mUid+ ""String_Node_Str""+ proc.mName);
    }
    proc=pkg.mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"" + proc.mName + ""String_Node_Str""+ pkg.mPackageName+ ""String_Node_Str""+ pkg.mUid);
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}"
1180,"ProcessState clone(String pkg,long now){
  ProcessState pnew=new ProcessState(this,pkg,mUid,mName,now);
  copyDurationsTo(pnew);
  if (mPssTable != null) {
    mStats.mAddLongTable=new int[mPssTable.length];
    mStats.mAddLongTableSize=0;
    for (int i=0; i < mPssTableSize; i++) {
      int origEnt=mPssTable[i];
      int type=(origEnt >> OFFSET_TYPE_SHIFT) & OFFSET_TYPE_MASK;
      int newOff=mStats.addLongData(i,type,PSS_COUNT);
      mStats.mAddLongTable[i]=newOff | type;
      for (int j=0; j < PSS_COUNT; j++) {
        mStats.setLong(newOff,j,mStats.getLong(origEnt,j));
      }
    }
    pnew.mPssTable=mStats.mAddLongTable;
    pnew.mPssTableSize=mStats.mAddLongTableSize;
  }
  pnew.mNumExcessiveWake=mNumExcessiveWake;
  pnew.mNumExcessiveCpu=mNumExcessiveCpu;
  pnew.mNumCachedKill=mNumCachedKill;
  pnew.mMinCachedKillPss=mMinCachedKillPss;
  pnew.mAvgCachedKillPss=mAvgCachedKillPss;
  pnew.mMaxCachedKillPss=mMaxCachedKillPss;
  pnew.mActive=mActive;
  pnew.mNumStartedServices=mNumStartedServices;
  return pnew;
}","ProcessState clone(String pkg,long now){
  ProcessState pnew=new ProcessState(this,pkg,mUid,mName,now);
  copyDurationsTo(pnew);
  if (mPssTable != null) {
    mStats.mAddLongTable=new int[mPssTable.length];
    mStats.mAddLongTableSize=0;
    for (int i=0; i < mPssTableSize; i++) {
      int origEnt=mPssTable[i];
      int type=(origEnt >> OFFSET_TYPE_SHIFT) & OFFSET_TYPE_MASK;
      int newOff=mStats.addLongData(i,type,PSS_COUNT);
      mStats.mAddLongTable[i]=newOff | type;
      for (int j=0; j < PSS_COUNT; j++) {
        mStats.setLong(newOff,j,mStats.getLong(origEnt,j));
      }
    }
    pnew.mPssTable=mStats.mAddLongTable;
    pnew.mPssTableSize=mStats.mAddLongTableSize;
  }
  pnew.mNumExcessiveWake=mNumExcessiveWake;
  pnew.mNumExcessiveCpu=mNumExcessiveCpu;
  pnew.mNumCachedKill=mNumCachedKill;
  pnew.mMinCachedKillPss=mMinCachedKillPss;
  pnew.mAvgCachedKillPss=mAvgCachedKillPss;
  pnew.mMaxCachedKillPss=mMaxCachedKillPss;
  pnew.mActive=mActive;
  pnew.mNumActiveServices=mNumActiveServices;
  pnew.mNumStartedServices=mNumStartedServices;
  return pnew;
}"
1181,"public void setBound(boolean bound,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addDuration(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
    updateRunning(memFactor,now);
  }
}","public void setBound(boolean bound,int memFactor,long now){
  if (mOwner == null) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addDuration(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
    updateRunning(memFactor,now);
  }
}"
1182,"public boolean isInUse(){
  return mActive > 0;
}","public boolean isInUse(){
  return mOwner != null;
}"
1183,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    Slog.w(""String_Node_Str"",""String_Node_Str"",e);
    throw e;
  }
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.wtf(""String_Node_Str"",""String_Node_Str"",e);
    }
    throw e;
  }
}"
1184,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.wtf(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}"
1185,"private void serviceDoneExecutingLocked(ServiceRecord r,boolean inStopping){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inStopping+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inStopping) {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r);
        mStoppingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (inStopping) {
        r.tracker.makeInactive();
        r.tracker=null;
      }
    }
  }
}","private void serviceDoneExecutingLocked(ServiceRecord r,boolean inDestroying,boolean finishing){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inDestroying+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inDestroying) {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r);
        mDestroyingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (finishing) {
        r.tracker.clearCurrentOwner(r);
        r.tracker=null;
      }
    }
  }
}"
1186,"/** 
 * Prints a list of ServiceRecords (dumpsys activity services)
 */
void dumpServicesLocked(FileDescriptor fd,PrintWriter pw,String[] args,int opti,boolean dumpAll,boolean dumpClient,String dumpPackage){
  boolean needSep=false;
  boolean printedAnything=false;
  ItemMatcher matcher=new ItemMatcher();
  matcher.build(args,opti);
  pw.println(""String_Node_Str"");
  try {
    int[] users=mAm.getUsersLocked();
    for (    int user : users) {
      ServiceMap smap=getServiceMap(user);
      boolean printed=false;
      if (smap.mServicesByName.size() > 0) {
        long nowReal=SystemClock.elapsedRealtime();
        needSep=false;
        for (int si=0; si < smap.mServicesByName.size(); si++) {
          ServiceRecord r=smap.mServicesByName.valueAt(si);
          if (!matcher.match(r,r.name)) {
            continue;
          }
          if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
            continue;
          }
          if (!printed) {
            if (printedAnything) {
              pw.println();
            }
            pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
            printed=true;
          }
          printedAnything=true;
          if (needSep) {
            pw.println();
          }
          pw.print(""String_Node_Str"");
          pw.println(r);
          if (dumpAll) {
            r.dump(pw,""String_Node_Str"");
            needSep=true;
          }
 else {
            pw.print(""String_Node_Str"");
            pw.println(r.app);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(r.createTime,nowReal,pw);
            pw.print(""String_Node_Str"");
            pw.print(r.startRequested);
            pw.print(""String_Node_Str"");
            pw.println(r.connections.size());
            if (r.connections.size() > 0) {
              pw.println(""String_Node_Str"");
              for (int conni=0; conni < r.connections.size(); conni++) {
                ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
                for (int i=0; i < clist.size(); i++) {
                  ConnectionRecord conn=clist.get(i);
                  pw.print(""String_Node_Str"");
                  pw.print(conn.binding.intent.intent.getIntent().toShortString(false,false,false,false));
                  pw.print(""String_Node_Str"");
                  ProcessRecord proc=conn.binding.client;
                  pw.println(proc != null ? proc.toShortString() : ""String_Node_Str"");
                }
              }
            }
          }
          if (dumpClient && r.app != null && r.app.thread != null) {
            pw.println(""String_Node_Str"");
            pw.flush();
            try {
              TransferPipe tp=new TransferPipe();
              try {
                r.app.thread.dumpService(tp.getWriteFd().getFileDescriptor(),r,args);
                tp.setBufferPrefix(""String_Node_Str"");
                tp.go(fd,2000);
              }
  finally {
                tp.kill();
              }
            }
 catch (            IOException e) {
              pw.println(""String_Node_Str"" + e);
            }
catch (            RemoteException e) {
              pw.println(""String_Node_Str"");
            }
            needSep=true;
          }
        }
        needSep|=printed;
      }
      printed=false;
      for (int si=0, SN=smap.mDelayedStartList.size(); si < SN; si++) {
        ServiceRecord r=smap.mDelayedStartList.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
      printed=false;
      for (int si=0, SN=smap.mStartingBackground.size(); si < SN; si++) {
        ServiceRecord r=smap.mStartingBackground.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
    }
  }
 catch (  Exception e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mPendingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mPendingServices.size(); i++) {
      ServiceRecord r=mPendingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mRestartingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mRestartingServices.size(); i++) {
      ServiceRecord r=mRestartingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mStoppingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mStoppingServices.size(); i++) {
      ServiceRecord r=mStoppingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (dumpAll) {
    boolean printed=false;
    for (int ic=0; ic < mServiceConnections.size(); ic++) {
      ArrayList<ConnectionRecord> r=mServiceConnections.valueAt(ic);
      for (int i=0; i < r.size(); i++) {
        ConnectionRecord cr=r.get(i);
        if (!matcher.match(cr.binding.service,cr.binding.service.name)) {
          continue;
        }
        if (dumpPackage != null && (cr.binding.client == null || !dumpPackage.equals(cr.binding.client.info.packageName))) {
          continue;
        }
        printedAnything=true;
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
        }
        pw.print(""String_Node_Str"");
        pw.println(cr);
        cr.dump(pw,""String_Node_Str"");
      }
    }
  }
  if (!printedAnything) {
    pw.println(""String_Node_Str"");
  }
}","/** 
 * Prints a list of ServiceRecords (dumpsys activity services)
 */
void dumpServicesLocked(FileDescriptor fd,PrintWriter pw,String[] args,int opti,boolean dumpAll,boolean dumpClient,String dumpPackage){
  boolean needSep=false;
  boolean printedAnything=false;
  ItemMatcher matcher=new ItemMatcher();
  matcher.build(args,opti);
  pw.println(""String_Node_Str"");
  try {
    int[] users=mAm.getUsersLocked();
    for (    int user : users) {
      ServiceMap smap=getServiceMap(user);
      boolean printed=false;
      if (smap.mServicesByName.size() > 0) {
        long nowReal=SystemClock.elapsedRealtime();
        needSep=false;
        for (int si=0; si < smap.mServicesByName.size(); si++) {
          ServiceRecord r=smap.mServicesByName.valueAt(si);
          if (!matcher.match(r,r.name)) {
            continue;
          }
          if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
            continue;
          }
          if (!printed) {
            if (printedAnything) {
              pw.println();
            }
            pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
            printed=true;
          }
          printedAnything=true;
          if (needSep) {
            pw.println();
          }
          pw.print(""String_Node_Str"");
          pw.println(r);
          if (dumpAll) {
            r.dump(pw,""String_Node_Str"");
            needSep=true;
          }
 else {
            pw.print(""String_Node_Str"");
            pw.println(r.app);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(r.createTime,nowReal,pw);
            pw.print(""String_Node_Str"");
            pw.print(r.startRequested);
            pw.print(""String_Node_Str"");
            pw.println(r.connections.size());
            if (r.connections.size() > 0) {
              pw.println(""String_Node_Str"");
              for (int conni=0; conni < r.connections.size(); conni++) {
                ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
                for (int i=0; i < clist.size(); i++) {
                  ConnectionRecord conn=clist.get(i);
                  pw.print(""String_Node_Str"");
                  pw.print(conn.binding.intent.intent.getIntent().toShortString(false,false,false,false));
                  pw.print(""String_Node_Str"");
                  ProcessRecord proc=conn.binding.client;
                  pw.println(proc != null ? proc.toShortString() : ""String_Node_Str"");
                }
              }
            }
          }
          if (dumpClient && r.app != null && r.app.thread != null) {
            pw.println(""String_Node_Str"");
            pw.flush();
            try {
              TransferPipe tp=new TransferPipe();
              try {
                r.app.thread.dumpService(tp.getWriteFd().getFileDescriptor(),r,args);
                tp.setBufferPrefix(""String_Node_Str"");
                tp.go(fd,2000);
              }
  finally {
                tp.kill();
              }
            }
 catch (            IOException e) {
              pw.println(""String_Node_Str"" + e);
            }
catch (            RemoteException e) {
              pw.println(""String_Node_Str"");
            }
            needSep=true;
          }
        }
        needSep|=printed;
      }
      printed=false;
      for (int si=0, SN=smap.mDelayedStartList.size(); si < SN; si++) {
        ServiceRecord r=smap.mDelayedStartList.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
      printed=false;
      for (int si=0, SN=smap.mStartingBackground.size(); si < SN; si++) {
        ServiceRecord r=smap.mStartingBackground.get(si);
        if (!matcher.match(r,r.name)) {
          continue;
        }
        if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
          continue;
        }
        if (!printed) {
          if (printedAnything) {
            pw.println();
          }
          pw.println(""String_Node_Str"" + user + ""String_Node_Str"");
          printed=true;
        }
        printedAnything=true;
        pw.print(""String_Node_Str"");
        pw.println(r);
      }
    }
  }
 catch (  Exception e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mPendingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mPendingServices.size(); i++) {
      ServiceRecord r=mPendingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mRestartingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mRestartingServices.size(); i++) {
      ServiceRecord r=mRestartingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (mDestroyingServices.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mDestroyingServices.size(); i++) {
      ServiceRecord r=mDestroyingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (dumpPackage != null && !dumpPackage.equals(r.appInfo.packageName)) {
        continue;
      }
      printedAnything=true;
      if (!printed) {
        if (needSep)         pw.println();
        needSep=true;
        pw.println(""String_Node_Str"");
        printed=true;
      }
      pw.print(""String_Node_Str"");
      pw.println(r);
      r.dump(pw,""String_Node_Str"");
    }
    needSep=true;
  }
  if (dumpAll) {
    boolean printed=false;
    for (int ic=0; ic < mServiceConnections.size(); ic++) {
      ArrayList<ConnectionRecord> r=mServiceConnections.valueAt(ic);
      for (int i=0; i < r.size(); i++) {
        ConnectionRecord cr=r.get(i);
        if (!matcher.match(cr.binding.service,cr.binding.service.name)) {
          continue;
        }
        if (dumpPackage != null && (cr.binding.client == null || !dumpPackage.equals(cr.binding.client.info.packageName))) {
          continue;
        }
        printedAnything=true;
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
        }
        pw.print(""String_Node_Str"");
        pw.println(cr);
        cr.dump(pw,""String_Node_Str"");
      }
    }
  }
  if (!printedAnything) {
    pw.println(""String_Node_Str"");
  }
}"
1187,"final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    if (sr.tracker != null) {
      sr.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
    }
    if (mStoppingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
    if (sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
  }
  int i=mStoppingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mStoppingServices.get(i);
    if (sr.app == app) {
      mStoppingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}","final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
    if (sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}"
1188,"void publishServiceLocked(ServiceRecord r,Intent intent,IBinder service){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ intent+ ""String_Node_Str""+ service);
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (b != null && !b.received) {
        b.binder=service;
        b.requested=true;
        b.received=true;
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
          for (int i=0; i < clist.size(); i++) {
            ConnectionRecord c=clist.get(i);
            if (!filter.equals(c.binding.intent.intent)) {
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c.binding.intent.intent);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + intent);
              continue;
            }
            if (DEBUG_SERVICE)             Slog.v(TAG,""String_Node_Str"" + c);
            try {
              c.conn.connected(r.name,service);
            }
 catch (            Exception e) {
              Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
            }
          }
        }
      }
      serviceDoneExecutingLocked(r,mStoppingServices.contains(r));
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","void publishServiceLocked(ServiceRecord r,Intent intent,IBinder service){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ intent+ ""String_Node_Str""+ service);
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (b != null && !b.received) {
        b.binder=service;
        b.requested=true;
        b.received=true;
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> clist=r.connections.valueAt(conni);
          for (int i=0; i < clist.size(); i++) {
            ConnectionRecord c=clist.get(i);
            if (!filter.equals(c.binding.intent.intent)) {
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + c.binding.intent.intent);
              if (DEBUG_SERVICE)               Slog.v(TAG,""String_Node_Str"" + intent);
              continue;
            }
            if (DEBUG_SERVICE)             Slog.v(TAG,""String_Node_Str"" + c);
            try {
              c.conn.connected(r.name,service);
            }
 catch (            Exception e) {
              Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
            }
          }
        }
      }
      serviceDoneExecutingLocked(r,mDestroyingServices.contains(r),false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
1189,"void unbindFinishedLocked(ServiceRecord r,Intent intent,boolean doRebind){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ b+ ""String_Node_Str""+ (b != null ? b.apps.size() : 0));
      boolean inStopping=mStoppingServices.contains(r);
      if (b != null) {
        if (b.apps.size() > 0 && !inStopping) {
          boolean inFg=false;
          for (int i=b.apps.size() - 1; i >= 0; i--) {
            ProcessRecord client=b.apps.valueAt(i).client;
            if (client != null && client.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE) {
              inFg=true;
              break;
            }
          }
          requestServiceBindingLocked(r,b,inFg,true);
        }
 else {
          b.doRebind=true;
        }
      }
      serviceDoneExecutingLocked(r,inStopping);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","void unbindFinishedLocked(ServiceRecord r,Intent intent,boolean doRebind){
  final long origId=Binder.clearCallingIdentity();
  try {
    if (r != null) {
      Intent.FilterComparison filter=new Intent.FilterComparison(intent);
      IntentBindRecord b=r.bindings.get(filter);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ b+ ""String_Node_Str""+ (b != null ? b.apps.size() : 0));
      boolean inDestroying=mDestroyingServices.contains(r);
      if (b != null) {
        if (b.apps.size() > 0 && !inDestroying) {
          boolean inFg=false;
          for (int i=b.apps.size() - 1; i >= 0; i--) {
            ProcessRecord client=b.apps.valueAt(i).client;
            if (client != null && client.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE) {
              inFg=true;
              break;
            }
          }
          requestServiceBindingLocked(r,b,inFg,true);
        }
 else {
          b.doRebind=true;
        }
      }
      serviceDoneExecutingLocked(r,inDestroying,false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
1190,"private final void bringDownServiceIfNeededLocked(ServiceRecord r,boolean knowConn,boolean hasConn){
  if (r.startRequested) {
    return;
  }
  if (!knowConn) {
    hasConn=r.hasAutoCreateConnections();
  }
  if (hasConn) {
    return;
  }
  if (mPendingServices.contains(r)) {
    return;
  }
  bringDownServiceLocked(r);
}","private final void bringDownServiceIfNeededLocked(ServiceRecord r,boolean knowConn,boolean hasConn){
  if (isServiceNeeded(r,knowConn,hasConn)) {
    return;
  }
  if (mPendingServices.contains(r)) {
    return;
  }
  bringDownServiceLocked(r);
}"
1191,"private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mStoppingServices.add(r);
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.makeInactive();
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}","private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}"
1192,"void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceDoneExecutingLocked(s,true);
      }
    }
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}","void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceDoneExecutingLocked(s,true,true);
      }
    }
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}"
1193,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  if (code == SYSPROPS_TRANSACTION) {
    ArrayList<IBinder> procs=new ArrayList<IBinder>();
synchronized (this) {
      final int NP=mProcessNames.getMap().size();
      for (int ip=0; ip < NP; ip++) {
        SparseArray<ProcessRecord> apps=mProcessNames.getMap().valueAt(ip);
        final int NA=apps.size();
        for (int ia=0; ia < NA; ia++) {
          ProcessRecord app=apps.valueAt(ia);
          if (app.thread != null) {
            procs.add(app.thread.asBinder());
          }
        }
      }
    }
    int N=procs.size();
    for (int i=0; i < N; i++) {
      Parcel data2=Parcel.obtain();
      try {
        procs.get(i).transact(IBinder.SYSPROPS_TRANSACTION,data2,null,0);
      }
 catch (      RemoteException e) {
      }
      data2.recycle();
    }
  }
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
  if (code == SYSPROPS_TRANSACTION) {
    ArrayList<IBinder> procs=new ArrayList<IBinder>();
synchronized (this) {
      final int NP=mProcessNames.getMap().size();
      for (int ip=0; ip < NP; ip++) {
        SparseArray<ProcessRecord> apps=mProcessNames.getMap().valueAt(ip);
        final int NA=apps.size();
        for (int ia=0; ia < NA; ia++) {
          ProcessRecord app=apps.valueAt(ia);
          if (app.thread != null) {
            procs.add(app.thread.asBinder());
          }
        }
      }
    }
    int N=procs.size();
    for (int i=0; i < N; i++) {
      Parcel data2=Parcel.obtain();
      try {
        procs.get(i).transact(IBinder.SYSPROPS_TRANSACTION,data2,null,0);
      }
 catch (      RemoteException e) {
      }
      data2.recycle();
    }
  }
  try {
    return super.onTransact(code,data,reply,flags);
  }
 catch (  RuntimeException e) {
    if (!(e instanceof SecurityException)) {
      Slog.wtf(TAG,""String_Node_Str"",e);
    }
    throw e;
  }
}"
1194,"public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}","public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}"
1195,"/** 
 * @hide 
 */
public void onPaused(boolean paused){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + paused);
    if (mStopped) {
      mStopped=false;
      scheduleNotification(NOTIFY_SEEK,0);
    }
 else {
      mPausing=paused;
      scheduleNotification(REFRESH_AND_NOTIFY_TIME,0);
    }
  }
}","/** 
 * @hide 
 */
public void onPaused(boolean paused){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + paused);
    if (mStopped) {
      scheduleNotification(NOTIFY_SEEK,0);
    }
 else {
      mPausing=paused;
      scheduleNotification(REFRESH_AND_NOTIFY_TIME,0);
    }
  }
}"
1196,"private void scheduleNotification(int type,long delayUs){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ delayUs);
  mEventHandler.removeMessages(NOTIFY);
  Message msg=mEventHandler.obtainMessage(NOTIFY,type,0);
  mEventHandler.sendMessageDelayed(msg,(int)(delayUs / 1000));
}","private void scheduleNotification(int type,long delayUs){
  if (mSeeking && (type == NOTIFY_TIME || type == REFRESH_AND_NOTIFY_TIME)) {
    return;
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ delayUs);
  mStopped=type == NOTIFY_STOP;
  mSeeking=type == NOTIFY_SEEK;
  mEventHandler.removeMessages(NOTIFY);
  Message msg=mEventHandler.obtainMessage(NOTIFY,type,0);
  mEventHandler.sendMessageDelayed(msg,(int)(delayUs / 1000));
}"
1197,"/** 
 * @hide 
 */
@Override public void onSeekComplete(MediaPlayer mp){
synchronized (this) {
    mStopped=false;
    scheduleNotification(NOTIFY_SEEK,0);
  }
}","/** 
 * @hide 
 */
@Override public void onSeekComplete(MediaPlayer mp){
synchronized (this) {
    scheduleNotification(NOTIFY_SEEK,0);
  }
}"
1198,"private synchronized void notifyTimedEvent(boolean refreshTime){
  long nowUs;
  try {
    nowUs=getCurrentTimeUs(refreshTime,true);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
    mPausing=true;
    nowUs=getCurrentTimeUs(refreshTime,true);
  }
  long nextTimeUs=nowUs;
  if (DEBUG) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(mLastTimeUs).append(""String_Node_Str"").append(nowUs).append(""String_Node_Str"");
    boolean first=true;
    for (    long time : mTimes) {
      if (time == NO_TIME) {
        continue;
      }
      if (!first)       sb.append(""String_Node_Str"");
      sb.append(time);
      first=false;
    }
    sb.append(""String_Node_Str"");
    Log.d(TAG,sb.toString());
  }
  Vector<MediaTimeProvider.OnMediaTimeListener> activatedListeners=new Vector<MediaTimeProvider.OnMediaTimeListener>();
  for (int ix=0; ix < mTimes.length; ix++) {
    if (mListeners[ix] == null) {
      break;
    }
    if (mTimes[ix] <= NO_TIME) {
    }
 else     if (mTimes[ix] <= nowUs + MAX_EARLY_CALLBACK_US) {
      activatedListeners.add(mListeners[ix]);
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mTimes[ix]=NO_TIME;
    }
 else     if (nextTimeUs == nowUs || mTimes[ix] < nextTimeUs) {
      nextTimeUs=mTimes[ix];
    }
  }
  if (nextTimeUs > nowUs && !mPaused) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + nextTimeUs + ""String_Node_Str""+ nowUs);
    scheduleNotification(NOTIFY_TIME,nextTimeUs - nowUs);
  }
 else {
    mEventHandler.removeMessages(NOTIFY);
  }
  for (  MediaTimeProvider.OnMediaTimeListener listener : activatedListeners) {
    listener.onTimedEvent(nowUs);
  }
}","private synchronized void notifyTimedEvent(boolean refreshTime){
  long nowUs;
  try {
    nowUs=getCurrentTimeUs(refreshTime,true);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
    mPausing=true;
    nowUs=getCurrentTimeUs(refreshTime,true);
  }
  long nextTimeUs=nowUs;
  if (mSeeking) {
    return;
  }
  if (DEBUG) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(mLastTimeUs).append(""String_Node_Str"").append(nowUs).append(""String_Node_Str"");
    boolean first=true;
    for (    long time : mTimes) {
      if (time == NO_TIME) {
        continue;
      }
      if (!first)       sb.append(""String_Node_Str"");
      sb.append(time);
      first=false;
    }
    sb.append(""String_Node_Str"");
    Log.d(TAG,sb.toString());
  }
  Vector<MediaTimeProvider.OnMediaTimeListener> activatedListeners=new Vector<MediaTimeProvider.OnMediaTimeListener>();
  for (int ix=0; ix < mTimes.length; ix++) {
    if (mListeners[ix] == null) {
      break;
    }
    if (mTimes[ix] <= NO_TIME) {
    }
 else     if (mTimes[ix] <= nowUs + MAX_EARLY_CALLBACK_US) {
      activatedListeners.add(mListeners[ix]);
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mTimes[ix]=NO_TIME;
    }
 else     if (nextTimeUs == nowUs || mTimes[ix] < nextTimeUs) {
      nextTimeUs=mTimes[ix];
    }
  }
  if (nextTimeUs > nowUs && !mPaused) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + nextTimeUs + ""String_Node_Str""+ nowUs);
    scheduleNotification(NOTIFY_TIME,nextTimeUs - nowUs);
  }
 else {
    mEventHandler.removeMessages(NOTIFY);
  }
  for (  MediaTimeProvider.OnMediaTimeListener listener : activatedListeners) {
    listener.onTimedEvent(nowUs);
  }
}"
1199,"/** 
 * @hide 
 */
public void onStopped(){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mPaused=true;
    mStopped=true;
    scheduleNotification(NOTIFY_STOP,0);
  }
}","/** 
 * @hide 
 */
public void onStopped(){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mPaused=true;
    scheduleNotification(NOTIFY_STOP,0);
  }
}"
1200,"private synchronized void notifySeek(){
  try {
    long timeUs=getCurrentTimeUs(true,false);
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + timeUs);
    for (    MediaTimeProvider.OnMediaTimeListener listener : mListeners) {
      if (listener == null) {
        break;
      }
      listener.onSeek(timeUs);
    }
  }
 catch (  IllegalStateException e) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mPausing=true;
    notifyTimedEvent(false);
  }
}","private synchronized void notifySeek(){
  mSeeking=false;
  try {
    long timeUs=getCurrentTimeUs(true,false);
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + timeUs);
    for (    MediaTimeProvider.OnMediaTimeListener listener : mListeners) {
      if (listener == null) {
        break;
      }
      listener.onSeek(timeUs);
    }
  }
 catch (  IllegalStateException e) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mPausing=true;
    notifyTimedEvent(false);
  }
}"
1201,"public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}","public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}"
1202,"/** 
 * @hide 
 */
public void onPaused(boolean paused){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + paused);
    if (mStopped) {
      mStopped=false;
      scheduleNotification(NOTIFY_SEEK,0);
    }
 else {
      mPausing=paused;
      scheduleNotification(REFRESH_AND_NOTIFY_TIME,0);
    }
  }
}","/** 
 * @hide 
 */
public void onPaused(boolean paused){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + paused);
    if (mStopped) {
      scheduleNotification(NOTIFY_SEEK,0);
    }
 else {
      mPausing=paused;
      scheduleNotification(REFRESH_AND_NOTIFY_TIME,0);
    }
  }
}"
1203,"private void scheduleNotification(int type,long delayUs){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ delayUs);
  mEventHandler.removeMessages(NOTIFY);
  Message msg=mEventHandler.obtainMessage(NOTIFY,type,0);
  mEventHandler.sendMessageDelayed(msg,(int)(delayUs / 1000));
}","private void scheduleNotification(int type,long delayUs){
  if (mSeeking && (type == NOTIFY_TIME || type == REFRESH_AND_NOTIFY_TIME)) {
    return;
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ delayUs);
  mStopped=type == NOTIFY_STOP;
  mSeeking=type == NOTIFY_SEEK;
  mEventHandler.removeMessages(NOTIFY);
  Message msg=mEventHandler.obtainMessage(NOTIFY,type,0);
  mEventHandler.sendMessageDelayed(msg,(int)(delayUs / 1000));
}"
1204,"/** 
 * @hide 
 */
@Override public void onSeekComplete(MediaPlayer mp){
synchronized (this) {
    mStopped=false;
    scheduleNotification(NOTIFY_SEEK,0);
  }
}","/** 
 * @hide 
 */
@Override public void onSeekComplete(MediaPlayer mp){
synchronized (this) {
    scheduleNotification(NOTIFY_SEEK,0);
  }
}"
1205,"private synchronized void notifyTimedEvent(boolean refreshTime){
  long nowUs;
  try {
    nowUs=getCurrentTimeUs(refreshTime,true);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
    mPausing=true;
    nowUs=getCurrentTimeUs(refreshTime,true);
  }
  long nextTimeUs=nowUs;
  if (DEBUG) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(mLastTimeUs).append(""String_Node_Str"").append(nowUs).append(""String_Node_Str"");
    boolean first=true;
    for (    long time : mTimes) {
      if (time == NO_TIME) {
        continue;
      }
      if (!first)       sb.append(""String_Node_Str"");
      sb.append(time);
      first=false;
    }
    sb.append(""String_Node_Str"");
    Log.d(TAG,sb.toString());
  }
  Vector<MediaTimeProvider.OnMediaTimeListener> activatedListeners=new Vector<MediaTimeProvider.OnMediaTimeListener>();
  for (int ix=0; ix < mTimes.length; ix++) {
    if (mListeners[ix] == null) {
      break;
    }
    if (mTimes[ix] <= NO_TIME) {
    }
 else     if (mTimes[ix] <= nowUs + MAX_EARLY_CALLBACK_US) {
      activatedListeners.add(mListeners[ix]);
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mTimes[ix]=NO_TIME;
    }
 else     if (nextTimeUs == nowUs || mTimes[ix] < nextTimeUs) {
      nextTimeUs=mTimes[ix];
    }
  }
  if (nextTimeUs > nowUs && !mPaused) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + nextTimeUs + ""String_Node_Str""+ nowUs);
    scheduleNotification(NOTIFY_TIME,nextTimeUs - nowUs);
  }
 else {
    mEventHandler.removeMessages(NOTIFY);
  }
  for (  MediaTimeProvider.OnMediaTimeListener listener : activatedListeners) {
    listener.onTimedEvent(nowUs);
  }
}","private synchronized void notifyTimedEvent(boolean refreshTime){
  long nowUs;
  try {
    nowUs=getCurrentTimeUs(refreshTime,true);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
    mPausing=true;
    nowUs=getCurrentTimeUs(refreshTime,true);
  }
  long nextTimeUs=nowUs;
  if (mSeeking) {
    return;
  }
  if (DEBUG) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(mLastTimeUs).append(""String_Node_Str"").append(nowUs).append(""String_Node_Str"");
    boolean first=true;
    for (    long time : mTimes) {
      if (time == NO_TIME) {
        continue;
      }
      if (!first)       sb.append(""String_Node_Str"");
      sb.append(time);
      first=false;
    }
    sb.append(""String_Node_Str"");
    Log.d(TAG,sb.toString());
  }
  Vector<MediaTimeProvider.OnMediaTimeListener> activatedListeners=new Vector<MediaTimeProvider.OnMediaTimeListener>();
  for (int ix=0; ix < mTimes.length; ix++) {
    if (mListeners[ix] == null) {
      break;
    }
    if (mTimes[ix] <= NO_TIME) {
    }
 else     if (mTimes[ix] <= nowUs + MAX_EARLY_CALLBACK_US) {
      activatedListeners.add(mListeners[ix]);
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mTimes[ix]=NO_TIME;
    }
 else     if (nextTimeUs == nowUs || mTimes[ix] < nextTimeUs) {
      nextTimeUs=mTimes[ix];
    }
  }
  if (nextTimeUs > nowUs && !mPaused) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + nextTimeUs + ""String_Node_Str""+ nowUs);
    scheduleNotification(NOTIFY_TIME,nextTimeUs - nowUs);
  }
 else {
    mEventHandler.removeMessages(NOTIFY);
  }
  for (  MediaTimeProvider.OnMediaTimeListener listener : activatedListeners) {
    listener.onTimedEvent(nowUs);
  }
}"
1206,"/** 
 * @hide 
 */
public void onStopped(){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mPaused=true;
    mStopped=true;
    scheduleNotification(NOTIFY_STOP,0);
  }
}","/** 
 * @hide 
 */
public void onStopped(){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mPaused=true;
    scheduleNotification(NOTIFY_STOP,0);
  }
}"
1207,"private synchronized void notifySeek(){
  try {
    long timeUs=getCurrentTimeUs(true,false);
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + timeUs);
    for (    MediaTimeProvider.OnMediaTimeListener listener : mListeners) {
      if (listener == null) {
        break;
      }
      listener.onSeek(timeUs);
    }
  }
 catch (  IllegalStateException e) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mPausing=true;
    notifyTimedEvent(false);
  }
}","private synchronized void notifySeek(){
  mSeeking=false;
  try {
    long timeUs=getCurrentTimeUs(true,false);
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + timeUs);
    for (    MediaTimeProvider.OnMediaTimeListener listener : mListeners) {
      if (listener == null) {
        break;
      }
      listener.onSeek(timeUs);
    }
  }
 catch (  IllegalStateException e) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mPausing=true;
    notifyTimedEvent(false);
  }
}"
1208,"/** 
 * Set whether SELinux is permissive or enforcing.
 * @param boolean representing whether to set SELinux to enforcing
 * @return a boolean representing whether the desired mode was set
 */
public static final native boolean setSELinuxEnforce(boolean value);","/** 
 * Set whether SELinux is permissive or enforcing.
 * @param value representing whether to set SELinux to enforcing
 * @return a boolean representing whether the desired mode was set
 */
public static final native boolean setSELinuxEnforce(boolean value);"
1209,"/** 
 * Gets the security context of a given process id. Use of this function is discouraged for Binder transactions. Use Binder.getCallingSecctx() instead.
 * @param pid an int representing the process id to check.
 * @return a String representing the security context of the given pid.
 */
public static final native String getPidContext(int pid);","/** 
 * Gets the security context of a given process id.
 * @param pid an int representing the process id to check.
 * @return a String representing the security context of the given pid.
 */
public static final native String getPidContext(int pid);"
1210,"/** 
 * Sets the value for the given SELinux boolean name.
 * @param String The name of the SELinux boolean.
 * @param Boolean The new value of the SELinux boolean.
 * @return a boolean indicating whether or not the operation succeeded.
 */
public static final native boolean setBooleanValue(String name,boolean value);","/** 
 * Sets the value for the given SELinux boolean name.
 * @param name The name of the SELinux boolean.
 * @param value The new value of the SELinux boolean.
 * @return a boolean indicating whether or not the operation succeeded.
 */
public static final native boolean setBooleanValue(String name,boolean value);"
1211,"/** 
 * Change the security context of an existing file object.
 * @param path representing the path of file object to relabel.
 * @param con new security context given as a String.
 * @return a boolean indicating whether the operation succeeded.
 */
public static final native boolean setFileContext(String path,String context);","/** 
 * Change the security context of an existing file object.
 * @param path representing the path of file object to relabel.
 * @param context new security context given as a String.
 * @return a boolean indicating whether the operation succeeded.
 */
public static final native boolean setFileContext(String path,String context);"
1212,"/** 
 * Gets the value for the given SELinux boolean name.
 * @param String The name of the SELinux boolean.
 * @return a boolean indicating whether the SELinux boolean is set.
 */
public static final native boolean getBooleanValue(String name);","/** 
 * Gets the value for the given SELinux boolean name.
 * @param name The name of the SELinux boolean.
 * @return a boolean indicating whether the SELinux boolean is set.
 */
public static final native boolean getBooleanValue(String name);"
1213,"/** 
 * Set whether SELinux is permissive or enforcing.
 * @param boolean representing whether to set SELinux to enforcing
 * @return a boolean representing whether the desired mode was set
 */
public static final native boolean setSELinuxEnforce(boolean value);","/** 
 * Set whether SELinux is permissive or enforcing.
 * @param value representing whether to set SELinux to enforcing
 * @return a boolean representing whether the desired mode was set
 */
public static final native boolean setSELinuxEnforce(boolean value);"
1214,"/** 
 * Gets the security context of a given process id. Use of this function is discouraged for Binder transactions. Use Binder.getCallingSecctx() instead.
 * @param pid an int representing the process id to check.
 * @return a String representing the security context of the given pid.
 */
public static final native String getPidContext(int pid);","/** 
 * Gets the security context of a given process id.
 * @param pid an int representing the process id to check.
 * @return a String representing the security context of the given pid.
 */
public static final native String getPidContext(int pid);"
1215,"/** 
 * Sets the value for the given SELinux boolean name.
 * @param String The name of the SELinux boolean.
 * @param Boolean The new value of the SELinux boolean.
 * @return a boolean indicating whether or not the operation succeeded.
 */
public static final native boolean setBooleanValue(String name,boolean value);","/** 
 * Sets the value for the given SELinux boolean name.
 * @param name The name of the SELinux boolean.
 * @param value The new value of the SELinux boolean.
 * @return a boolean indicating whether or not the operation succeeded.
 */
public static final native boolean setBooleanValue(String name,boolean value);"
1216,"/** 
 * Change the security context of an existing file object.
 * @param path representing the path of file object to relabel.
 * @param con new security context given as a String.
 * @return a boolean indicating whether the operation succeeded.
 */
public static final native boolean setFileContext(String path,String context);","/** 
 * Change the security context of an existing file object.
 * @param path representing the path of file object to relabel.
 * @param context new security context given as a String.
 * @return a boolean indicating whether the operation succeeded.
 */
public static final native boolean setFileContext(String path,String context);"
1217,"/** 
 * Gets the value for the given SELinux boolean name.
 * @param String The name of the SELinux boolean.
 * @return a boolean indicating whether the SELinux boolean is set.
 */
public static final native boolean getBooleanValue(String name);","/** 
 * Gets the value for the given SELinux boolean name.
 * @param name The name of the SELinux boolean.
 * @return a boolean indicating whether the SELinux boolean is set.
 */
public static final native boolean getBooleanValue(String name);"
1218,"/** 
 * Set whether SELinux is permissive or enforcing.
 * @param boolean representing whether to set SELinux to enforcing
 * @return a boolean representing whether the desired mode was set
 */
public static final native boolean setSELinuxEnforce(boolean value);","/** 
 * Set whether SELinux is permissive or enforcing.
 * @param value representing whether to set SELinux to enforcing
 * @return a boolean representing whether the desired mode was set
 */
public static final native boolean setSELinuxEnforce(boolean value);"
1219,"/** 
 * Gets the security context of a given process id. Use of this function is discouraged for Binder transactions. Use Binder.getCallingSecctx() instead.
 * @param pid an int representing the process id to check.
 * @return a String representing the security context of the given pid.
 */
public static final native String getPidContext(int pid);","/** 
 * Gets the security context of a given process id.
 * @param pid an int representing the process id to check.
 * @return a String representing the security context of the given pid.
 */
public static final native String getPidContext(int pid);"
1220,"/** 
 * Sets the value for the given SELinux boolean name.
 * @param String The name of the SELinux boolean.
 * @param Boolean The new value of the SELinux boolean.
 * @return a boolean indicating whether or not the operation succeeded.
 */
public static final native boolean setBooleanValue(String name,boolean value);","/** 
 * Sets the value for the given SELinux boolean name.
 * @param name The name of the SELinux boolean.
 * @param value The new value of the SELinux boolean.
 * @return a boolean indicating whether or not the operation succeeded.
 */
public static final native boolean setBooleanValue(String name,boolean value);"
1221,"/** 
 * Change the security context of an existing file object.
 * @param path representing the path of file object to relabel.
 * @param con new security context given as a String.
 * @return a boolean indicating whether the operation succeeded.
 */
public static final native boolean setFileContext(String path,String context);","/** 
 * Change the security context of an existing file object.
 * @param path representing the path of file object to relabel.
 * @param context new security context given as a String.
 * @return a boolean indicating whether the operation succeeded.
 */
public static final native boolean setFileContext(String path,String context);"
1222,"/** 
 * Gets the value for the given SELinux boolean name.
 * @param String The name of the SELinux boolean.
 * @return a boolean indicating whether the SELinux boolean is set.
 */
public static final native boolean getBooleanValue(String name);","/** 
 * Gets the value for the given SELinux boolean name.
 * @param name The name of the SELinux boolean.
 * @return a boolean indicating whether the SELinux boolean is set.
 */
public static final native boolean getBooleanValue(String name);"
1223,"/** 
 * Set whether SELinux is permissive or enforcing.
 * @param boolean representing whether to set SELinux to enforcing
 * @return a boolean representing whether the desired mode was set
 */
public static final native boolean setSELinuxEnforce(boolean value);","/** 
 * Set whether SELinux is permissive or enforcing.
 * @param value representing whether to set SELinux to enforcing
 * @return a boolean representing whether the desired mode was set
 */
public static final native boolean setSELinuxEnforce(boolean value);"
1224,"/** 
 * Gets the security context of a given process id. Use of this function is discouraged for Binder transactions. Use Binder.getCallingSecctx() instead.
 * @param pid an int representing the process id to check.
 * @return a String representing the security context of the given pid.
 */
public static final native String getPidContext(int pid);","/** 
 * Gets the security context of a given process id.
 * @param pid an int representing the process id to check.
 * @return a String representing the security context of the given pid.
 */
public static final native String getPidContext(int pid);"
1225,"/** 
 * Sets the value for the given SELinux boolean name.
 * @param String The name of the SELinux boolean.
 * @param Boolean The new value of the SELinux boolean.
 * @return a boolean indicating whether or not the operation succeeded.
 */
public static final native boolean setBooleanValue(String name,boolean value);","/** 
 * Sets the value for the given SELinux boolean name.
 * @param name The name of the SELinux boolean.
 * @param value The new value of the SELinux boolean.
 * @return a boolean indicating whether or not the operation succeeded.
 */
public static final native boolean setBooleanValue(String name,boolean value);"
1226,"/** 
 * Change the security context of an existing file object.
 * @param path representing the path of file object to relabel.
 * @param con new security context given as a String.
 * @return a boolean indicating whether the operation succeeded.
 */
public static final native boolean setFileContext(String path,String context);","/** 
 * Change the security context of an existing file object.
 * @param path representing the path of file object to relabel.
 * @param context new security context given as a String.
 * @return a boolean indicating whether the operation succeeded.
 */
public static final native boolean setFileContext(String path,String context);"
1227,"/** 
 * Gets the value for the given SELinux boolean name.
 * @param String The name of the SELinux boolean.
 * @return a boolean indicating whether the SELinux boolean is set.
 */
public static final native boolean getBooleanValue(String name);","/** 
 * Gets the value for the given SELinux boolean name.
 * @param name The name of the SELinux boolean.
 * @return a boolean indicating whether the SELinux boolean is set.
 */
public static final native boolean getBooleanValue(String name);"
1228,"@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.opToDefaultMode(curOp.op)) {
            curOp.mode=AppOpsManager.opToDefaultMode(curOp.op);
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (AppOpsManager.opAllowsReset(curOp.op) && curOp.mode != AppOpsManager.opToDefaultMode(curOp.op)) {
            curOp.mode=AppOpsManager.opToDefaultMode(curOp.op);
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}"
1229,"@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.opToDefaultMode(curOp.op)) {
            curOp.mode=AppOpsManager.opToDefaultMode(curOp.op);
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (AppOpsManager.opAllowsReset(curOp.op) && curOp.mode != AppOpsManager.opToDefaultMode(curOp.op)) {
            curOp.mode=AppOpsManager.opToDefaultMode(curOp.op);
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}"
1230,"@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.opToDefaultMode(curOp.op)) {
            curOp.mode=AppOpsManager.opToDefaultMode(curOp.op);
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (AppOpsManager.opAllowsReset(curOp.op) && curOp.mode != AppOpsManager.opToDefaultMode(curOp.op)) {
            curOp.mode=AppOpsManager.opToDefaultMode(curOp.op);
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}"
1231,"@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.opToDefaultMode(curOp.op)) {
            curOp.mode=AppOpsManager.opToDefaultMode(curOp.op);
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (AppOpsManager.opAllowsReset(curOp.op) && curOp.mode != AppOpsManager.opToDefaultMode(curOp.op)) {
            curOp.mode=AppOpsManager.opToDefaultMode(curOp.op);
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}"
1232,"private void dumpMemInfo(PrintWriter pw,Debug.MemoryInfo memInfo,boolean checkin,boolean dumpInfo,boolean dumpDalvik){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootImplCount();
  long appContextInstanceCount=Debug.countInstancesOfClass(ContextImpl.class);
  long activityInstanceCount=Debug.countInstancesOfClass(Activity.class);
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  long openSslSocketCount=Debug.countInstancesOfClass(OpenSSLSocketImpl.class);
  SQLiteDebug.PagerStats stats=SQLiteDebug.getDatabaseInfo();
  if (checkin) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.getTotalPss());
    pw.print(',');
    pw.print(memInfo.nativeSwappablePss);
    pw.print(',');
    pw.print(memInfo.dalvikSwappablePss);
    pw.print(',');
    pw.print(memInfo.otherSwappablePss);
    pw.print(',');
    pw.print(memInfo.getTotalSwappablePss());
    pw.print(',');
    pw.print(memInfo.nativeSharedDirty);
    pw.print(',');
    pw.print(memInfo.dalvikSharedDirty);
    pw.print(',');
    pw.print(memInfo.otherSharedDirty);
    pw.print(',');
    pw.print(memInfo.getTotalSharedDirty());
    pw.print(',');
    pw.print(memInfo.nativeSharedClean);
    pw.print(',');
    pw.print(memInfo.dalvikSharedClean);
    pw.print(',');
    pw.print(memInfo.otherSharedClean);
    pw.print(',');
    pw.print(memInfo.getTotalSharedClean());
    pw.print(',');
    pw.print(memInfo.nativePrivateDirty);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateDirty);
    pw.print(',');
    pw.print(memInfo.otherPrivateDirty);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateDirty());
    pw.print(',');
    pw.print(memInfo.nativePrivateClean);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateClean);
    pw.print(',');
    pw.print(memInfo.otherPrivateClean);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateClean());
    pw.print(',');
    for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
      pw.print(Debug.MemoryInfo.getOtherLabel(i));
      pw.print(',');
      pw.print(memInfo.getOtherPss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSwappablePss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedClean(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateClean(i));
      pw.print(',');
    }
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.pageCacheOverflow / 1024);
    pw.print(',');
    pw.print(stats.largestMemAlloc / 1024);
    for (int i=0; i < stats.dbStats.size(); i++) {
      DbStats dbStats=stats.dbStats.get(i);
      pw.print(',');
      pw.print(dbStats.dbName);
      pw.print(',');
      pw.print(dbStats.pageSize);
      pw.print(',');
      pw.print(dbStats.dbSize);
      pw.print(',');
      pw.print(dbStats.lookaside);
      pw.print(',');
      pw.print(dbStats.cache);
      pw.print(',');
      pw.print(dbStats.cache);
    }
    pw.println();
    return;
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.nativeSwappablePss,memInfo.nativeSharedDirty,memInfo.nativePrivateDirty,memInfo.nativeSharedClean,memInfo.nativePrivateClean,nativeMax,nativeAllocated,nativeFree);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.dalvikPss,memInfo.dalvikSwappablePss,memInfo.dalvikSharedDirty,memInfo.dalvikPrivateDirty,memInfo.dalvikSharedClean,memInfo.dalvikPrivateClean,dalvikMax,dalvikAllocated,dalvikFree);
  int otherPss=memInfo.otherPss;
  int otherSwappablePss=memInfo.otherSwappablePss;
  int otherSharedDirty=memInfo.otherSharedDirty;
  int otherPrivateDirty=memInfo.otherPrivateDirty;
  int otherSharedClean=memInfo.otherSharedClean;
  int otherPrivateClean=memInfo.otherPrivateClean;
  for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
    final int myPss=memInfo.getOtherPss(i);
    final int mySwappablePss=memInfo.getOtherSwappablePss(i);
    final int mySharedDirty=memInfo.getOtherSharedDirty(i);
    final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
    final int mySharedClean=memInfo.getOtherSharedClean(i);
    final int myPrivateClean=memInfo.getOtherPrivateClean(i);
    if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
      printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      otherPss-=myPss;
      otherSwappablePss-=mySwappablePss;
      otherSharedDirty-=mySharedDirty;
      otherPrivateDirty-=myPrivateDirty;
      otherSharedClean-=mySharedClean;
      otherPrivateClean-=myPrivateClean;
    }
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",otherPss,otherSwappablePss,otherSharedDirty,otherPrivateDirty,otherSharedClean,otherPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.getTotalPss(),memInfo.getTotalSwappablePss(),memInfo.getTotalSharedDirty(),memInfo.getTotalPrivateDirty(),memInfo.getTotalSharedClean(),memInfo.getTotalPrivateClean(),nativeMax + dalvikMax,nativeAllocated + dalvikAllocated,nativeFree + dalvikFree);
  if (dumpDalvik) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (int i=Debug.MemoryInfo.NUM_OTHER_STATS; i < Debug.MemoryInfo.NUM_OTHER_STATS + Debug.MemoryInfo.NUM_DVK_STATS; i++) {
      final int myPss=memInfo.getOtherPss(i);
      final int mySwappablePss=memInfo.getOtherSwappablePss(i);
      final int mySharedDirty=memInfo.getOtherSharedDirty(i);
      final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
      final int mySharedClean=memInfo.getOtherSharedClean(i);
      final int myPrivateClean=memInfo.getOtherPrivateClean(i);
      if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
        printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.memoryUsed / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.pageCacheOverflow / 1024,""String_Node_Str"",stats.largestMemAlloc / 1024);
  pw.println(""String_Node_Str"");
  int N=stats.dbStats.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    printRow(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < N; i++) {
      DbStats dbStats=stats.dbStats.get(i);
      printRow(pw,DB_INFO_FORMAT,(dbStats.pageSize > 0) ? String.valueOf(dbStats.pageSize) : ""String_Node_Str"",(dbStats.dbSize > 0) ? String.valueOf(dbStats.dbSize) : ""String_Node_Str"",(dbStats.lookaside > 0) ? String.valueOf(dbStats.lookaside) : ""String_Node_Str"",dbStats.cache,dbStats.dbName);
    }
  }
  String assetAlloc=AssetManager.getAssetAllocations();
  if (assetAlloc != null) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.print(assetAlloc);
  }
}","private void dumpMemInfo(PrintWriter pw,Debug.MemoryInfo memInfo,boolean checkin,boolean dumpFullInfo,boolean dumpDalvik){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootImplCount();
  long appContextInstanceCount=Debug.countInstancesOfClass(ContextImpl.class);
  long activityInstanceCount=Debug.countInstancesOfClass(Activity.class);
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  long openSslSocketCount=Debug.countInstancesOfClass(OpenSSLSocketImpl.class);
  SQLiteDebug.PagerStats stats=SQLiteDebug.getDatabaseInfo();
  if (checkin) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.getTotalPss());
    pw.print(',');
    pw.print(memInfo.nativeSwappablePss);
    pw.print(',');
    pw.print(memInfo.dalvikSwappablePss);
    pw.print(',');
    pw.print(memInfo.otherSwappablePss);
    pw.print(',');
    pw.print(memInfo.getTotalSwappablePss());
    pw.print(',');
    pw.print(memInfo.nativeSharedDirty);
    pw.print(',');
    pw.print(memInfo.dalvikSharedDirty);
    pw.print(',');
    pw.print(memInfo.otherSharedDirty);
    pw.print(',');
    pw.print(memInfo.getTotalSharedDirty());
    pw.print(',');
    pw.print(memInfo.nativeSharedClean);
    pw.print(',');
    pw.print(memInfo.dalvikSharedClean);
    pw.print(',');
    pw.print(memInfo.otherSharedClean);
    pw.print(',');
    pw.print(memInfo.getTotalSharedClean());
    pw.print(',');
    pw.print(memInfo.nativePrivateDirty);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateDirty);
    pw.print(',');
    pw.print(memInfo.otherPrivateDirty);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateDirty());
    pw.print(',');
    pw.print(memInfo.nativePrivateClean);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateClean);
    pw.print(',');
    pw.print(memInfo.otherPrivateClean);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateClean());
    pw.print(',');
    for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
      pw.print(Debug.MemoryInfo.getOtherLabel(i));
      pw.print(',');
      pw.print(memInfo.getOtherPss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSwappablePss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedClean(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateClean(i));
      pw.print(',');
    }
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.pageCacheOverflow / 1024);
    pw.print(',');
    pw.print(stats.largestMemAlloc / 1024);
    for (int i=0; i < stats.dbStats.size(); i++) {
      DbStats dbStats=stats.dbStats.get(i);
      pw.print(',');
      pw.print(dbStats.dbName);
      pw.print(',');
      pw.print(dbStats.pageSize);
      pw.print(',');
      pw.print(dbStats.dbSize);
      pw.print(',');
      pw.print(dbStats.lookaside);
      pw.print(',');
      pw.print(dbStats.cache);
      pw.print(',');
      pw.print(dbStats.cache);
    }
    pw.println();
    return;
  }
  if (dumpFullInfo) {
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.nativeSwappablePss,memInfo.nativeSharedDirty,memInfo.nativePrivateDirty,memInfo.nativeSharedClean,memInfo.nativePrivateClean,nativeMax,nativeAllocated,nativeFree);
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",memInfo.dalvikPss,memInfo.dalvikSwappablePss,memInfo.dalvikSharedDirty,memInfo.dalvikPrivateDirty,memInfo.dalvikSharedClean,memInfo.dalvikPrivateClean,dalvikMax,dalvikAllocated,dalvikFree);
  }
 else {
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.nativeSwappablePss,memInfo.nativePrivateDirty,memInfo.nativePrivateClean,nativeMax,nativeAllocated,nativeFree);
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.dalvikPss,memInfo.dalvikSwappablePss,memInfo.dalvikPrivateDirty,memInfo.dalvikPrivateClean,dalvikMax,dalvikAllocated,dalvikFree);
  }
  int otherPss=memInfo.otherPss;
  int otherSwappablePss=memInfo.otherSwappablePss;
  int otherSharedDirty=memInfo.otherSharedDirty;
  int otherPrivateDirty=memInfo.otherPrivateDirty;
  int otherSharedClean=memInfo.otherSharedClean;
  int otherPrivateClean=memInfo.otherPrivateClean;
  for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
    final int myPss=memInfo.getOtherPss(i);
    final int mySwappablePss=memInfo.getOtherSwappablePss(i);
    final int mySharedDirty=memInfo.getOtherSharedDirty(i);
    final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
    final int mySharedClean=memInfo.getOtherSharedClean(i);
    final int myPrivateClean=memInfo.getOtherPrivateClean(i);
    if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
      if (dumpFullInfo) {
        printRow(pw,HEAP_FULL_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else {
        printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,myPrivateDirty,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
      otherPss-=myPss;
      otherSwappablePss-=mySwappablePss;
      otherSharedDirty-=mySharedDirty;
      otherPrivateDirty-=myPrivateDirty;
      otherSharedClean-=mySharedClean;
      otherPrivateClean-=myPrivateClean;
    }
  }
  if (dumpFullInfo) {
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",otherPss,otherSwappablePss,otherSharedDirty,otherPrivateDirty,otherSharedClean,otherPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",memInfo.getTotalPss(),memInfo.getTotalSwappablePss(),memInfo.getTotalSharedDirty(),memInfo.getTotalPrivateDirty(),memInfo.getTotalSharedClean(),memInfo.getTotalPrivateClean(),nativeMax + dalvikMax,nativeAllocated + dalvikAllocated,nativeFree + dalvikFree);
  }
 else {
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",otherPss,otherSwappablePss,otherPrivateDirty,otherPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.getTotalPss(),memInfo.getTotalSwappablePss(),memInfo.getTotalPrivateDirty(),memInfo.getTotalPrivateClean(),nativeMax + dalvikMax,nativeAllocated + dalvikAllocated,nativeFree + dalvikFree);
  }
  if (dumpDalvik) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (int i=Debug.MemoryInfo.NUM_OTHER_STATS; i < Debug.MemoryInfo.NUM_OTHER_STATS + Debug.MemoryInfo.NUM_DVK_STATS; i++) {
      final int myPss=memInfo.getOtherPss(i);
      final int mySwappablePss=memInfo.getOtherSwappablePss(i);
      final int mySharedDirty=memInfo.getOtherSharedDirty(i);
      final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
      final int mySharedClean=memInfo.getOtherSharedClean(i);
      final int myPrivateClean=memInfo.getOtherPrivateClean(i);
      if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
        if (dumpFullInfo) {
          printRow(pw,HEAP_FULL_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
 else {
          printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,myPrivateDirty,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
      }
    }
  }
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.memoryUsed / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.pageCacheOverflow / 1024,""String_Node_Str"",stats.largestMemAlloc / 1024);
  pw.println(""String_Node_Str"");
  int N=stats.dbStats.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    printRow(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < N; i++) {
      DbStats dbStats=stats.dbStats.get(i);
      printRow(pw,DB_INFO_FORMAT,(dbStats.pageSize > 0) ? String.valueOf(dbStats.pageSize) : ""String_Node_Str"",(dbStats.dbSize > 0) ? String.valueOf(dbStats.dbSize) : ""String_Node_Str"",(dbStats.lookaside > 0) ? String.valueOf(dbStats.lookaside) : ""String_Node_Str"",dbStats.cache,dbStats.dbName);
    }
  }
  String assetAlloc=AssetManager.getAssetAllocations();
  if (assetAlloc != null) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.print(assetAlloc);
  }
}"
1233,"public long getCachedSize(){
  return mCachedSize;
}","public long getCachedSize(){
  return mInfos[Debug.MEMINFO_CACHED] * 1024;
}"
1234,"public long getTotalSize(){
  return mTotalSize;
}","public long getTotalSize(){
  return mInfos[Debug.MEMINFO_TOTAL] * 1024;
}"
1235,"public long getFreeSize(){
  return mFreeSize;
}","public long getFreeSize(){
  return mInfos[Debug.MEMINFO_FREE] * 1024;
}"
1236,"public void readMemInfo(){
  StrictMode.ThreadPolicy savedPolicy=StrictMode.allowThreadDiskReads();
  try {
    long[] infos=new long[Debug.MEMINFO_COUNT];
    Debug.getMemInfo(infos);
    mTotalSize=infos[Debug.MEMINFO_TOTAL] * 1024;
    mFreeSize=infos[Debug.MEMINFO_FREE] * 1024;
    mCachedSize=infos[Debug.MEMINFO_CACHED] * 1024;
  }
  finally {
    StrictMode.setThreadPolicy(savedPolicy);
  }
}","public void readMemInfo(){
  StrictMode.ThreadPolicy savedPolicy=StrictMode.allowThreadDiskReads();
  try {
    Debug.getMemInfo(mInfos);
  }
  finally {
    StrictMode.setThreadPolicy(savedPolicy);
  }
}"
1237,"private void dumpMemInfo(PrintWriter pw,Debug.MemoryInfo memInfo,boolean checkin,boolean dumpInfo,boolean dumpDalvik){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootImplCount();
  long appContextInstanceCount=Debug.countInstancesOfClass(ContextImpl.class);
  long activityInstanceCount=Debug.countInstancesOfClass(Activity.class);
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  long openSslSocketCount=Debug.countInstancesOfClass(OpenSSLSocketImpl.class);
  SQLiteDebug.PagerStats stats=SQLiteDebug.getDatabaseInfo();
  if (checkin) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.getTotalPss());
    pw.print(',');
    pw.print(memInfo.nativeSwappablePss);
    pw.print(',');
    pw.print(memInfo.dalvikSwappablePss);
    pw.print(',');
    pw.print(memInfo.otherSwappablePss);
    pw.print(',');
    pw.print(memInfo.getTotalSwappablePss());
    pw.print(',');
    pw.print(memInfo.nativeSharedDirty);
    pw.print(',');
    pw.print(memInfo.dalvikSharedDirty);
    pw.print(',');
    pw.print(memInfo.otherSharedDirty);
    pw.print(',');
    pw.print(memInfo.getTotalSharedDirty());
    pw.print(',');
    pw.print(memInfo.nativeSharedClean);
    pw.print(',');
    pw.print(memInfo.dalvikSharedClean);
    pw.print(',');
    pw.print(memInfo.otherSharedClean);
    pw.print(',');
    pw.print(memInfo.getTotalSharedClean());
    pw.print(',');
    pw.print(memInfo.nativePrivateDirty);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateDirty);
    pw.print(',');
    pw.print(memInfo.otherPrivateDirty);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateDirty());
    pw.print(',');
    pw.print(memInfo.nativePrivateClean);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateClean);
    pw.print(',');
    pw.print(memInfo.otherPrivateClean);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateClean());
    pw.print(',');
    for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
      pw.print(Debug.MemoryInfo.getOtherLabel(i));
      pw.print(',');
      pw.print(memInfo.getOtherPss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSwappablePss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedClean(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateClean(i));
      pw.print(',');
    }
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.pageCacheOverflow / 1024);
    pw.print(',');
    pw.print(stats.largestMemAlloc / 1024);
    for (int i=0; i < stats.dbStats.size(); i++) {
      DbStats dbStats=stats.dbStats.get(i);
      pw.print(',');
      pw.print(dbStats.dbName);
      pw.print(',');
      pw.print(dbStats.pageSize);
      pw.print(',');
      pw.print(dbStats.dbSize);
      pw.print(',');
      pw.print(dbStats.lookaside);
      pw.print(',');
      pw.print(dbStats.cache);
      pw.print(',');
      pw.print(dbStats.cache);
    }
    pw.println();
    return;
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.nativeSwappablePss,memInfo.nativeSharedDirty,memInfo.nativePrivateDirty,memInfo.nativeSharedClean,memInfo.nativePrivateClean,nativeMax,nativeAllocated,nativeFree);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.dalvikPss,memInfo.dalvikSwappablePss,memInfo.dalvikSharedDirty,memInfo.dalvikPrivateDirty,memInfo.dalvikSharedClean,memInfo.dalvikPrivateClean,dalvikMax,dalvikAllocated,dalvikFree);
  int otherPss=memInfo.otherPss;
  int otherSwappablePss=memInfo.otherSwappablePss;
  int otherSharedDirty=memInfo.otherSharedDirty;
  int otherPrivateDirty=memInfo.otherPrivateDirty;
  int otherSharedClean=memInfo.otherSharedClean;
  int otherPrivateClean=memInfo.otherPrivateClean;
  for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
    final int myPss=memInfo.getOtherPss(i);
    final int mySwappablePss=memInfo.getOtherSwappablePss(i);
    final int mySharedDirty=memInfo.getOtherSharedDirty(i);
    final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
    final int mySharedClean=memInfo.getOtherSharedClean(i);
    final int myPrivateClean=memInfo.getOtherPrivateClean(i);
    if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
      printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      otherPss-=myPss;
      otherSwappablePss-=mySwappablePss;
      otherSharedDirty-=mySharedDirty;
      otherPrivateDirty-=myPrivateDirty;
      otherSharedClean-=mySharedClean;
      otherPrivateClean-=myPrivateClean;
    }
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",otherPss,otherSwappablePss,otherSharedDirty,otherPrivateDirty,otherSharedClean,otherPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.getTotalPss(),memInfo.getTotalSwappablePss(),memInfo.getTotalSharedDirty(),memInfo.getTotalPrivateDirty(),memInfo.getTotalSharedClean(),memInfo.getTotalPrivateClean(),nativeMax + dalvikMax,nativeAllocated + dalvikAllocated,nativeFree + dalvikFree);
  if (dumpDalvik) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (int i=Debug.MemoryInfo.NUM_OTHER_STATS; i < Debug.MemoryInfo.NUM_OTHER_STATS + Debug.MemoryInfo.NUM_DVK_STATS; i++) {
      final int myPss=memInfo.getOtherPss(i);
      final int mySwappablePss=memInfo.getOtherSwappablePss(i);
      final int mySharedDirty=memInfo.getOtherSharedDirty(i);
      final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
      final int mySharedClean=memInfo.getOtherSharedClean(i);
      final int myPrivateClean=memInfo.getOtherPrivateClean(i);
      if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
        printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.memoryUsed / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.pageCacheOverflow / 1024,""String_Node_Str"",stats.largestMemAlloc / 1024);
  pw.println(""String_Node_Str"");
  int N=stats.dbStats.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    printRow(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < N; i++) {
      DbStats dbStats=stats.dbStats.get(i);
      printRow(pw,DB_INFO_FORMAT,(dbStats.pageSize > 0) ? String.valueOf(dbStats.pageSize) : ""String_Node_Str"",(dbStats.dbSize > 0) ? String.valueOf(dbStats.dbSize) : ""String_Node_Str"",(dbStats.lookaside > 0) ? String.valueOf(dbStats.lookaside) : ""String_Node_Str"",dbStats.cache,dbStats.dbName);
    }
  }
  String assetAlloc=AssetManager.getAssetAllocations();
  if (assetAlloc != null) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.print(assetAlloc);
  }
}","private void dumpMemInfo(PrintWriter pw,Debug.MemoryInfo memInfo,boolean checkin,boolean dumpFullInfo,boolean dumpDalvik){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootImplCount();
  long appContextInstanceCount=Debug.countInstancesOfClass(ContextImpl.class);
  long activityInstanceCount=Debug.countInstancesOfClass(Activity.class);
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  long openSslSocketCount=Debug.countInstancesOfClass(OpenSSLSocketImpl.class);
  SQLiteDebug.PagerStats stats=SQLiteDebug.getDatabaseInfo();
  if (checkin) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.getTotalPss());
    pw.print(',');
    pw.print(memInfo.nativeSwappablePss);
    pw.print(',');
    pw.print(memInfo.dalvikSwappablePss);
    pw.print(',');
    pw.print(memInfo.otherSwappablePss);
    pw.print(',');
    pw.print(memInfo.getTotalSwappablePss());
    pw.print(',');
    pw.print(memInfo.nativeSharedDirty);
    pw.print(',');
    pw.print(memInfo.dalvikSharedDirty);
    pw.print(',');
    pw.print(memInfo.otherSharedDirty);
    pw.print(',');
    pw.print(memInfo.getTotalSharedDirty());
    pw.print(',');
    pw.print(memInfo.nativeSharedClean);
    pw.print(',');
    pw.print(memInfo.dalvikSharedClean);
    pw.print(',');
    pw.print(memInfo.otherSharedClean);
    pw.print(',');
    pw.print(memInfo.getTotalSharedClean());
    pw.print(',');
    pw.print(memInfo.nativePrivateDirty);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateDirty);
    pw.print(',');
    pw.print(memInfo.otherPrivateDirty);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateDirty());
    pw.print(',');
    pw.print(memInfo.nativePrivateClean);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateClean);
    pw.print(',');
    pw.print(memInfo.otherPrivateClean);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateClean());
    pw.print(',');
    for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
      pw.print(Debug.MemoryInfo.getOtherLabel(i));
      pw.print(',');
      pw.print(memInfo.getOtherPss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSwappablePss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedClean(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateClean(i));
      pw.print(',');
    }
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.pageCacheOverflow / 1024);
    pw.print(',');
    pw.print(stats.largestMemAlloc / 1024);
    for (int i=0; i < stats.dbStats.size(); i++) {
      DbStats dbStats=stats.dbStats.get(i);
      pw.print(',');
      pw.print(dbStats.dbName);
      pw.print(',');
      pw.print(dbStats.pageSize);
      pw.print(',');
      pw.print(dbStats.dbSize);
      pw.print(',');
      pw.print(dbStats.lookaside);
      pw.print(',');
      pw.print(dbStats.cache);
      pw.print(',');
      pw.print(dbStats.cache);
    }
    pw.println();
    return;
  }
  if (dumpFullInfo) {
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.nativeSwappablePss,memInfo.nativeSharedDirty,memInfo.nativePrivateDirty,memInfo.nativeSharedClean,memInfo.nativePrivateClean,nativeMax,nativeAllocated,nativeFree);
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",memInfo.dalvikPss,memInfo.dalvikSwappablePss,memInfo.dalvikSharedDirty,memInfo.dalvikPrivateDirty,memInfo.dalvikSharedClean,memInfo.dalvikPrivateClean,dalvikMax,dalvikAllocated,dalvikFree);
  }
 else {
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.nativeSwappablePss,memInfo.nativePrivateDirty,memInfo.nativePrivateClean,nativeMax,nativeAllocated,nativeFree);
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.dalvikPss,memInfo.dalvikSwappablePss,memInfo.dalvikPrivateDirty,memInfo.dalvikPrivateClean,dalvikMax,dalvikAllocated,dalvikFree);
  }
  int otherPss=memInfo.otherPss;
  int otherSwappablePss=memInfo.otherSwappablePss;
  int otherSharedDirty=memInfo.otherSharedDirty;
  int otherPrivateDirty=memInfo.otherPrivateDirty;
  int otherSharedClean=memInfo.otherSharedClean;
  int otherPrivateClean=memInfo.otherPrivateClean;
  for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
    final int myPss=memInfo.getOtherPss(i);
    final int mySwappablePss=memInfo.getOtherSwappablePss(i);
    final int mySharedDirty=memInfo.getOtherSharedDirty(i);
    final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
    final int mySharedClean=memInfo.getOtherSharedClean(i);
    final int myPrivateClean=memInfo.getOtherPrivateClean(i);
    if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
      if (dumpFullInfo) {
        printRow(pw,HEAP_FULL_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else {
        printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,myPrivateDirty,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
      otherPss-=myPss;
      otherSwappablePss-=mySwappablePss;
      otherSharedDirty-=mySharedDirty;
      otherPrivateDirty-=myPrivateDirty;
      otherSharedClean-=mySharedClean;
      otherPrivateClean-=myPrivateClean;
    }
  }
  if (dumpFullInfo) {
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",otherPss,otherSwappablePss,otherSharedDirty,otherPrivateDirty,otherSharedClean,otherPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",memInfo.getTotalPss(),memInfo.getTotalSwappablePss(),memInfo.getTotalSharedDirty(),memInfo.getTotalPrivateDirty(),memInfo.getTotalSharedClean(),memInfo.getTotalPrivateClean(),nativeMax + dalvikMax,nativeAllocated + dalvikAllocated,nativeFree + dalvikFree);
  }
 else {
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",otherPss,otherSwappablePss,otherPrivateDirty,otherPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.getTotalPss(),memInfo.getTotalSwappablePss(),memInfo.getTotalPrivateDirty(),memInfo.getTotalPrivateClean(),nativeMax + dalvikMax,nativeAllocated + dalvikAllocated,nativeFree + dalvikFree);
  }
  if (dumpDalvik) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (int i=Debug.MemoryInfo.NUM_OTHER_STATS; i < Debug.MemoryInfo.NUM_OTHER_STATS + Debug.MemoryInfo.NUM_DVK_STATS; i++) {
      final int myPss=memInfo.getOtherPss(i);
      final int mySwappablePss=memInfo.getOtherSwappablePss(i);
      final int mySharedDirty=memInfo.getOtherSharedDirty(i);
      final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
      final int mySharedClean=memInfo.getOtherSharedClean(i);
      final int myPrivateClean=memInfo.getOtherPrivateClean(i);
      if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
        if (dumpFullInfo) {
          printRow(pw,HEAP_FULL_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
 else {
          printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,myPrivateDirty,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
      }
    }
  }
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.memoryUsed / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.pageCacheOverflow / 1024,""String_Node_Str"",stats.largestMemAlloc / 1024);
  pw.println(""String_Node_Str"");
  int N=stats.dbStats.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    printRow(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < N; i++) {
      DbStats dbStats=stats.dbStats.get(i);
      printRow(pw,DB_INFO_FORMAT,(dbStats.pageSize > 0) ? String.valueOf(dbStats.pageSize) : ""String_Node_Str"",(dbStats.dbSize > 0) ? String.valueOf(dbStats.dbSize) : ""String_Node_Str"",(dbStats.lookaside > 0) ? String.valueOf(dbStats.lookaside) : ""String_Node_Str"",dbStats.cache,dbStats.dbName);
    }
  }
  String assetAlloc=AssetManager.getAssetAllocations();
  if (assetAlloc != null) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.print(assetAlloc);
  }
}"
1238,"public long getCachedSize(){
  return mCachedSize;
}","public long getCachedSize(){
  return mInfos[Debug.MEMINFO_CACHED] * 1024;
}"
1239,"public long getTotalSize(){
  return mTotalSize;
}","public long getTotalSize(){
  return mInfos[Debug.MEMINFO_TOTAL] * 1024;
}"
1240,"public long getFreeSize(){
  return mFreeSize;
}","public long getFreeSize(){
  return mInfos[Debug.MEMINFO_FREE] * 1024;
}"
1241,"public void readMemInfo(){
  StrictMode.ThreadPolicy savedPolicy=StrictMode.allowThreadDiskReads();
  try {
    long[] infos=new long[Debug.MEMINFO_COUNT];
    Debug.getMemInfo(infos);
    mTotalSize=infos[Debug.MEMINFO_TOTAL] * 1024;
    mFreeSize=infos[Debug.MEMINFO_FREE] * 1024;
    mCachedSize=infos[Debug.MEMINFO_CACHED] * 1024;
  }
  finally {
    StrictMode.setThreadPolicy(savedPolicy);
  }
}","public void readMemInfo(){
  StrictMode.ThreadPolicy savedPolicy=StrictMode.allowThreadDiskReads();
  try {
    Debug.getMemInfo(mInfos);
  }
  finally {
    StrictMode.setThreadPolicy(savedPolicy);
  }
}"
1242,"private void dumpMemInfo(PrintWriter pw,Debug.MemoryInfo memInfo,boolean checkin,boolean dumpInfo,boolean dumpDalvik){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootImplCount();
  long appContextInstanceCount=Debug.countInstancesOfClass(ContextImpl.class);
  long activityInstanceCount=Debug.countInstancesOfClass(Activity.class);
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  long openSslSocketCount=Debug.countInstancesOfClass(OpenSSLSocketImpl.class);
  SQLiteDebug.PagerStats stats=SQLiteDebug.getDatabaseInfo();
  if (checkin) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.getTotalPss());
    pw.print(',');
    pw.print(memInfo.nativeSwappablePss);
    pw.print(',');
    pw.print(memInfo.dalvikSwappablePss);
    pw.print(',');
    pw.print(memInfo.otherSwappablePss);
    pw.print(',');
    pw.print(memInfo.getTotalSwappablePss());
    pw.print(',');
    pw.print(memInfo.nativeSharedDirty);
    pw.print(',');
    pw.print(memInfo.dalvikSharedDirty);
    pw.print(',');
    pw.print(memInfo.otherSharedDirty);
    pw.print(',');
    pw.print(memInfo.getTotalSharedDirty());
    pw.print(',');
    pw.print(memInfo.nativeSharedClean);
    pw.print(',');
    pw.print(memInfo.dalvikSharedClean);
    pw.print(',');
    pw.print(memInfo.otherSharedClean);
    pw.print(',');
    pw.print(memInfo.getTotalSharedClean());
    pw.print(',');
    pw.print(memInfo.nativePrivateDirty);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateDirty);
    pw.print(',');
    pw.print(memInfo.otherPrivateDirty);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateDirty());
    pw.print(',');
    pw.print(memInfo.nativePrivateClean);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateClean);
    pw.print(',');
    pw.print(memInfo.otherPrivateClean);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateClean());
    pw.print(',');
    for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
      pw.print(Debug.MemoryInfo.getOtherLabel(i));
      pw.print(',');
      pw.print(memInfo.getOtherPss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSwappablePss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedClean(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateClean(i));
      pw.print(',');
    }
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.pageCacheOverflow / 1024);
    pw.print(',');
    pw.print(stats.largestMemAlloc / 1024);
    for (int i=0; i < stats.dbStats.size(); i++) {
      DbStats dbStats=stats.dbStats.get(i);
      pw.print(',');
      pw.print(dbStats.dbName);
      pw.print(',');
      pw.print(dbStats.pageSize);
      pw.print(',');
      pw.print(dbStats.dbSize);
      pw.print(',');
      pw.print(dbStats.lookaside);
      pw.print(',');
      pw.print(dbStats.cache);
      pw.print(',');
      pw.print(dbStats.cache);
    }
    pw.println();
    return;
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.nativeSwappablePss,memInfo.nativeSharedDirty,memInfo.nativePrivateDirty,memInfo.nativeSharedClean,memInfo.nativePrivateClean,nativeMax,nativeAllocated,nativeFree);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.dalvikPss,memInfo.dalvikSwappablePss,memInfo.dalvikSharedDirty,memInfo.dalvikPrivateDirty,memInfo.dalvikSharedClean,memInfo.dalvikPrivateClean,dalvikMax,dalvikAllocated,dalvikFree);
  int otherPss=memInfo.otherPss;
  int otherSwappablePss=memInfo.otherSwappablePss;
  int otherSharedDirty=memInfo.otherSharedDirty;
  int otherPrivateDirty=memInfo.otherPrivateDirty;
  int otherSharedClean=memInfo.otherSharedClean;
  int otherPrivateClean=memInfo.otherPrivateClean;
  for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
    final int myPss=memInfo.getOtherPss(i);
    final int mySwappablePss=memInfo.getOtherSwappablePss(i);
    final int mySharedDirty=memInfo.getOtherSharedDirty(i);
    final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
    final int mySharedClean=memInfo.getOtherSharedClean(i);
    final int myPrivateClean=memInfo.getOtherPrivateClean(i);
    if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
      printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      otherPss-=myPss;
      otherSwappablePss-=mySwappablePss;
      otherSharedDirty-=mySharedDirty;
      otherPrivateDirty-=myPrivateDirty;
      otherSharedClean-=mySharedClean;
      otherPrivateClean-=myPrivateClean;
    }
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",otherPss,otherSwappablePss,otherSharedDirty,otherPrivateDirty,otherSharedClean,otherPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.getTotalPss(),memInfo.getTotalSwappablePss(),memInfo.getTotalSharedDirty(),memInfo.getTotalPrivateDirty(),memInfo.getTotalSharedClean(),memInfo.getTotalPrivateClean(),nativeMax + dalvikMax,nativeAllocated + dalvikAllocated,nativeFree + dalvikFree);
  if (dumpDalvik) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (int i=Debug.MemoryInfo.NUM_OTHER_STATS; i < Debug.MemoryInfo.NUM_OTHER_STATS + Debug.MemoryInfo.NUM_DVK_STATS; i++) {
      final int myPss=memInfo.getOtherPss(i);
      final int mySwappablePss=memInfo.getOtherSwappablePss(i);
      final int mySharedDirty=memInfo.getOtherSharedDirty(i);
      final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
      final int mySharedClean=memInfo.getOtherSharedClean(i);
      final int myPrivateClean=memInfo.getOtherPrivateClean(i);
      if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
        printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.memoryUsed / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.pageCacheOverflow / 1024,""String_Node_Str"",stats.largestMemAlloc / 1024);
  pw.println(""String_Node_Str"");
  int N=stats.dbStats.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    printRow(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < N; i++) {
      DbStats dbStats=stats.dbStats.get(i);
      printRow(pw,DB_INFO_FORMAT,(dbStats.pageSize > 0) ? String.valueOf(dbStats.pageSize) : ""String_Node_Str"",(dbStats.dbSize > 0) ? String.valueOf(dbStats.dbSize) : ""String_Node_Str"",(dbStats.lookaside > 0) ? String.valueOf(dbStats.lookaside) : ""String_Node_Str"",dbStats.cache,dbStats.dbName);
    }
  }
  String assetAlloc=AssetManager.getAssetAllocations();
  if (assetAlloc != null) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.print(assetAlloc);
  }
}","private void dumpMemInfo(PrintWriter pw,Debug.MemoryInfo memInfo,boolean checkin,boolean dumpFullInfo,boolean dumpDalvik){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootImplCount();
  long appContextInstanceCount=Debug.countInstancesOfClass(ContextImpl.class);
  long activityInstanceCount=Debug.countInstancesOfClass(Activity.class);
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  long openSslSocketCount=Debug.countInstancesOfClass(OpenSSLSocketImpl.class);
  SQLiteDebug.PagerStats stats=SQLiteDebug.getDatabaseInfo();
  if (checkin) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.getTotalPss());
    pw.print(',');
    pw.print(memInfo.nativeSwappablePss);
    pw.print(',');
    pw.print(memInfo.dalvikSwappablePss);
    pw.print(',');
    pw.print(memInfo.otherSwappablePss);
    pw.print(',');
    pw.print(memInfo.getTotalSwappablePss());
    pw.print(',');
    pw.print(memInfo.nativeSharedDirty);
    pw.print(',');
    pw.print(memInfo.dalvikSharedDirty);
    pw.print(',');
    pw.print(memInfo.otherSharedDirty);
    pw.print(',');
    pw.print(memInfo.getTotalSharedDirty());
    pw.print(',');
    pw.print(memInfo.nativeSharedClean);
    pw.print(',');
    pw.print(memInfo.dalvikSharedClean);
    pw.print(',');
    pw.print(memInfo.otherSharedClean);
    pw.print(',');
    pw.print(memInfo.getTotalSharedClean());
    pw.print(',');
    pw.print(memInfo.nativePrivateDirty);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateDirty);
    pw.print(',');
    pw.print(memInfo.otherPrivateDirty);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateDirty());
    pw.print(',');
    pw.print(memInfo.nativePrivateClean);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateClean);
    pw.print(',');
    pw.print(memInfo.otherPrivateClean);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateClean());
    pw.print(',');
    for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
      pw.print(Debug.MemoryInfo.getOtherLabel(i));
      pw.print(',');
      pw.print(memInfo.getOtherPss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSwappablePss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedClean(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateClean(i));
      pw.print(',');
    }
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.pageCacheOverflow / 1024);
    pw.print(',');
    pw.print(stats.largestMemAlloc / 1024);
    for (int i=0; i < stats.dbStats.size(); i++) {
      DbStats dbStats=stats.dbStats.get(i);
      pw.print(',');
      pw.print(dbStats.dbName);
      pw.print(',');
      pw.print(dbStats.pageSize);
      pw.print(',');
      pw.print(dbStats.dbSize);
      pw.print(',');
      pw.print(dbStats.lookaside);
      pw.print(',');
      pw.print(dbStats.cache);
      pw.print(',');
      pw.print(dbStats.cache);
    }
    pw.println();
    return;
  }
  if (dumpFullInfo) {
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.nativeSwappablePss,memInfo.nativeSharedDirty,memInfo.nativePrivateDirty,memInfo.nativeSharedClean,memInfo.nativePrivateClean,nativeMax,nativeAllocated,nativeFree);
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",memInfo.dalvikPss,memInfo.dalvikSwappablePss,memInfo.dalvikSharedDirty,memInfo.dalvikPrivateDirty,memInfo.dalvikSharedClean,memInfo.dalvikPrivateClean,dalvikMax,dalvikAllocated,dalvikFree);
  }
 else {
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.nativeSwappablePss,memInfo.nativePrivateDirty,memInfo.nativePrivateClean,nativeMax,nativeAllocated,nativeFree);
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.dalvikPss,memInfo.dalvikSwappablePss,memInfo.dalvikPrivateDirty,memInfo.dalvikPrivateClean,dalvikMax,dalvikAllocated,dalvikFree);
  }
  int otherPss=memInfo.otherPss;
  int otherSwappablePss=memInfo.otherSwappablePss;
  int otherSharedDirty=memInfo.otherSharedDirty;
  int otherPrivateDirty=memInfo.otherPrivateDirty;
  int otherSharedClean=memInfo.otherSharedClean;
  int otherPrivateClean=memInfo.otherPrivateClean;
  for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
    final int myPss=memInfo.getOtherPss(i);
    final int mySwappablePss=memInfo.getOtherSwappablePss(i);
    final int mySharedDirty=memInfo.getOtherSharedDirty(i);
    final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
    final int mySharedClean=memInfo.getOtherSharedClean(i);
    final int myPrivateClean=memInfo.getOtherPrivateClean(i);
    if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
      if (dumpFullInfo) {
        printRow(pw,HEAP_FULL_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else {
        printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,myPrivateDirty,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
      otherPss-=myPss;
      otherSwappablePss-=mySwappablePss;
      otherSharedDirty-=mySharedDirty;
      otherPrivateDirty-=myPrivateDirty;
      otherSharedClean-=mySharedClean;
      otherPrivateClean-=myPrivateClean;
    }
  }
  if (dumpFullInfo) {
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",otherPss,otherSwappablePss,otherSharedDirty,otherPrivateDirty,otherSharedClean,otherPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",memInfo.getTotalPss(),memInfo.getTotalSwappablePss(),memInfo.getTotalSharedDirty(),memInfo.getTotalPrivateDirty(),memInfo.getTotalSharedClean(),memInfo.getTotalPrivateClean(),nativeMax + dalvikMax,nativeAllocated + dalvikAllocated,nativeFree + dalvikFree);
  }
 else {
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",otherPss,otherSwappablePss,otherPrivateDirty,otherPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.getTotalPss(),memInfo.getTotalSwappablePss(),memInfo.getTotalPrivateDirty(),memInfo.getTotalPrivateClean(),nativeMax + dalvikMax,nativeAllocated + dalvikAllocated,nativeFree + dalvikFree);
  }
  if (dumpDalvik) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (int i=Debug.MemoryInfo.NUM_OTHER_STATS; i < Debug.MemoryInfo.NUM_OTHER_STATS + Debug.MemoryInfo.NUM_DVK_STATS; i++) {
      final int myPss=memInfo.getOtherPss(i);
      final int mySwappablePss=memInfo.getOtherSwappablePss(i);
      final int mySharedDirty=memInfo.getOtherSharedDirty(i);
      final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
      final int mySharedClean=memInfo.getOtherSharedClean(i);
      final int myPrivateClean=memInfo.getOtherPrivateClean(i);
      if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
        if (dumpFullInfo) {
          printRow(pw,HEAP_FULL_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
 else {
          printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,myPrivateDirty,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
      }
    }
  }
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.memoryUsed / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.pageCacheOverflow / 1024,""String_Node_Str"",stats.largestMemAlloc / 1024);
  pw.println(""String_Node_Str"");
  int N=stats.dbStats.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    printRow(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < N; i++) {
      DbStats dbStats=stats.dbStats.get(i);
      printRow(pw,DB_INFO_FORMAT,(dbStats.pageSize > 0) ? String.valueOf(dbStats.pageSize) : ""String_Node_Str"",(dbStats.dbSize > 0) ? String.valueOf(dbStats.dbSize) : ""String_Node_Str"",(dbStats.lookaside > 0) ? String.valueOf(dbStats.lookaside) : ""String_Node_Str"",dbStats.cache,dbStats.dbName);
    }
  }
  String assetAlloc=AssetManager.getAssetAllocations();
  if (assetAlloc != null) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.print(assetAlloc);
  }
}"
1243,"public long getCachedSize(){
  return mCachedSize;
}","public long getCachedSize(){
  return mInfos[Debug.MEMINFO_CACHED] * 1024;
}"
1244,"public long getTotalSize(){
  return mTotalSize;
}","public long getTotalSize(){
  return mInfos[Debug.MEMINFO_TOTAL] * 1024;
}"
1245,"public long getFreeSize(){
  return mFreeSize;
}","public long getFreeSize(){
  return mInfos[Debug.MEMINFO_FREE] * 1024;
}"
1246,"public void readMemInfo(){
  StrictMode.ThreadPolicy savedPolicy=StrictMode.allowThreadDiskReads();
  try {
    long[] infos=new long[Debug.MEMINFO_COUNT];
    Debug.getMemInfo(infos);
    mTotalSize=infos[Debug.MEMINFO_TOTAL] * 1024;
    mFreeSize=infos[Debug.MEMINFO_FREE] * 1024;
    mCachedSize=infos[Debug.MEMINFO_CACHED] * 1024;
  }
  finally {
    StrictMode.setThreadPolicy(savedPolicy);
  }
}","public void readMemInfo(){
  StrictMode.ThreadPolicy savedPolicy=StrictMode.allowThreadDiskReads();
  try {
    Debug.getMemInfo(mInfos);
  }
  finally {
    StrictMode.setThreadPolicy(savedPolicy);
  }
}"
1247,"private void dumpMemInfo(PrintWriter pw,Debug.MemoryInfo memInfo,boolean checkin,boolean dumpInfo,boolean dumpDalvik){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootImplCount();
  long appContextInstanceCount=Debug.countInstancesOfClass(ContextImpl.class);
  long activityInstanceCount=Debug.countInstancesOfClass(Activity.class);
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  long openSslSocketCount=Debug.countInstancesOfClass(OpenSSLSocketImpl.class);
  SQLiteDebug.PagerStats stats=SQLiteDebug.getDatabaseInfo();
  if (checkin) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.getTotalPss());
    pw.print(',');
    pw.print(memInfo.nativeSwappablePss);
    pw.print(',');
    pw.print(memInfo.dalvikSwappablePss);
    pw.print(',');
    pw.print(memInfo.otherSwappablePss);
    pw.print(',');
    pw.print(memInfo.getTotalSwappablePss());
    pw.print(',');
    pw.print(memInfo.nativeSharedDirty);
    pw.print(',');
    pw.print(memInfo.dalvikSharedDirty);
    pw.print(',');
    pw.print(memInfo.otherSharedDirty);
    pw.print(',');
    pw.print(memInfo.getTotalSharedDirty());
    pw.print(',');
    pw.print(memInfo.nativeSharedClean);
    pw.print(',');
    pw.print(memInfo.dalvikSharedClean);
    pw.print(',');
    pw.print(memInfo.otherSharedClean);
    pw.print(',');
    pw.print(memInfo.getTotalSharedClean());
    pw.print(',');
    pw.print(memInfo.nativePrivateDirty);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateDirty);
    pw.print(',');
    pw.print(memInfo.otherPrivateDirty);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateDirty());
    pw.print(',');
    pw.print(memInfo.nativePrivateClean);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateClean);
    pw.print(',');
    pw.print(memInfo.otherPrivateClean);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateClean());
    pw.print(',');
    for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
      pw.print(Debug.MemoryInfo.getOtherLabel(i));
      pw.print(',');
      pw.print(memInfo.getOtherPss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSwappablePss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedClean(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateClean(i));
      pw.print(',');
    }
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.pageCacheOverflow / 1024);
    pw.print(',');
    pw.print(stats.largestMemAlloc / 1024);
    for (int i=0; i < stats.dbStats.size(); i++) {
      DbStats dbStats=stats.dbStats.get(i);
      pw.print(',');
      pw.print(dbStats.dbName);
      pw.print(',');
      pw.print(dbStats.pageSize);
      pw.print(',');
      pw.print(dbStats.dbSize);
      pw.print(',');
      pw.print(dbStats.lookaside);
      pw.print(',');
      pw.print(dbStats.cache);
      pw.print(',');
      pw.print(dbStats.cache);
    }
    pw.println();
    return;
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.nativeSwappablePss,memInfo.nativeSharedDirty,memInfo.nativePrivateDirty,memInfo.nativeSharedClean,memInfo.nativePrivateClean,nativeMax,nativeAllocated,nativeFree);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.dalvikPss,memInfo.dalvikSwappablePss,memInfo.dalvikSharedDirty,memInfo.dalvikPrivateDirty,memInfo.dalvikSharedClean,memInfo.dalvikPrivateClean,dalvikMax,dalvikAllocated,dalvikFree);
  int otherPss=memInfo.otherPss;
  int otherSwappablePss=memInfo.otherSwappablePss;
  int otherSharedDirty=memInfo.otherSharedDirty;
  int otherPrivateDirty=memInfo.otherPrivateDirty;
  int otherSharedClean=memInfo.otherSharedClean;
  int otherPrivateClean=memInfo.otherPrivateClean;
  for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
    final int myPss=memInfo.getOtherPss(i);
    final int mySwappablePss=memInfo.getOtherSwappablePss(i);
    final int mySharedDirty=memInfo.getOtherSharedDirty(i);
    final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
    final int mySharedClean=memInfo.getOtherSharedClean(i);
    final int myPrivateClean=memInfo.getOtherPrivateClean(i);
    if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
      printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      otherPss-=myPss;
      otherSwappablePss-=mySwappablePss;
      otherSharedDirty-=mySharedDirty;
      otherPrivateDirty-=myPrivateDirty;
      otherSharedClean-=mySharedClean;
      otherPrivateClean-=myPrivateClean;
    }
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",otherPss,otherSwappablePss,otherSharedDirty,otherPrivateDirty,otherSharedClean,otherPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.getTotalPss(),memInfo.getTotalSwappablePss(),memInfo.getTotalSharedDirty(),memInfo.getTotalPrivateDirty(),memInfo.getTotalSharedClean(),memInfo.getTotalPrivateClean(),nativeMax + dalvikMax,nativeAllocated + dalvikAllocated,nativeFree + dalvikFree);
  if (dumpDalvik) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (int i=Debug.MemoryInfo.NUM_OTHER_STATS; i < Debug.MemoryInfo.NUM_OTHER_STATS + Debug.MemoryInfo.NUM_DVK_STATS; i++) {
      final int myPss=memInfo.getOtherPss(i);
      final int mySwappablePss=memInfo.getOtherSwappablePss(i);
      final int mySharedDirty=memInfo.getOtherSharedDirty(i);
      final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
      final int mySharedClean=memInfo.getOtherSharedClean(i);
      final int myPrivateClean=memInfo.getOtherPrivateClean(i);
      if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
        printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.memoryUsed / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.pageCacheOverflow / 1024,""String_Node_Str"",stats.largestMemAlloc / 1024);
  pw.println(""String_Node_Str"");
  int N=stats.dbStats.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    printRow(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < N; i++) {
      DbStats dbStats=stats.dbStats.get(i);
      printRow(pw,DB_INFO_FORMAT,(dbStats.pageSize > 0) ? String.valueOf(dbStats.pageSize) : ""String_Node_Str"",(dbStats.dbSize > 0) ? String.valueOf(dbStats.dbSize) : ""String_Node_Str"",(dbStats.lookaside > 0) ? String.valueOf(dbStats.lookaside) : ""String_Node_Str"",dbStats.cache,dbStats.dbName);
    }
  }
  String assetAlloc=AssetManager.getAssetAllocations();
  if (assetAlloc != null) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.print(assetAlloc);
  }
}","private void dumpMemInfo(PrintWriter pw,Debug.MemoryInfo memInfo,boolean checkin,boolean dumpFullInfo,boolean dumpDalvik){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootImplCount();
  long appContextInstanceCount=Debug.countInstancesOfClass(ContextImpl.class);
  long activityInstanceCount=Debug.countInstancesOfClass(Activity.class);
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  long openSslSocketCount=Debug.countInstancesOfClass(OpenSSLSocketImpl.class);
  SQLiteDebug.PagerStats stats=SQLiteDebug.getDatabaseInfo();
  if (checkin) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.getTotalPss());
    pw.print(',');
    pw.print(memInfo.nativeSwappablePss);
    pw.print(',');
    pw.print(memInfo.dalvikSwappablePss);
    pw.print(',');
    pw.print(memInfo.otherSwappablePss);
    pw.print(',');
    pw.print(memInfo.getTotalSwappablePss());
    pw.print(',');
    pw.print(memInfo.nativeSharedDirty);
    pw.print(',');
    pw.print(memInfo.dalvikSharedDirty);
    pw.print(',');
    pw.print(memInfo.otherSharedDirty);
    pw.print(',');
    pw.print(memInfo.getTotalSharedDirty());
    pw.print(',');
    pw.print(memInfo.nativeSharedClean);
    pw.print(',');
    pw.print(memInfo.dalvikSharedClean);
    pw.print(',');
    pw.print(memInfo.otherSharedClean);
    pw.print(',');
    pw.print(memInfo.getTotalSharedClean());
    pw.print(',');
    pw.print(memInfo.nativePrivateDirty);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateDirty);
    pw.print(',');
    pw.print(memInfo.otherPrivateDirty);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateDirty());
    pw.print(',');
    pw.print(memInfo.nativePrivateClean);
    pw.print(',');
    pw.print(memInfo.dalvikPrivateClean);
    pw.print(',');
    pw.print(memInfo.otherPrivateClean);
    pw.print(',');
    pw.print(memInfo.getTotalPrivateClean());
    pw.print(',');
    for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
      pw.print(Debug.MemoryInfo.getOtherLabel(i));
      pw.print(',');
      pw.print(memInfo.getOtherPss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSwappablePss(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherSharedClean(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateDirty(i));
      pw.print(',');
      pw.print(memInfo.getOtherPrivateClean(i));
      pw.print(',');
    }
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.memoryUsed / 1024);
    pw.print(',');
    pw.print(stats.pageCacheOverflow / 1024);
    pw.print(',');
    pw.print(stats.largestMemAlloc / 1024);
    for (int i=0; i < stats.dbStats.size(); i++) {
      DbStats dbStats=stats.dbStats.get(i);
      pw.print(',');
      pw.print(dbStats.dbName);
      pw.print(',');
      pw.print(dbStats.pageSize);
      pw.print(',');
      pw.print(dbStats.dbSize);
      pw.print(',');
      pw.print(dbStats.lookaside);
      pw.print(',');
      pw.print(dbStats.cache);
      pw.print(',');
      pw.print(dbStats.cache);
    }
    pw.println();
    return;
  }
  if (dumpFullInfo) {
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.nativeSwappablePss,memInfo.nativeSharedDirty,memInfo.nativePrivateDirty,memInfo.nativeSharedClean,memInfo.nativePrivateClean,nativeMax,nativeAllocated,nativeFree);
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",memInfo.dalvikPss,memInfo.dalvikSwappablePss,memInfo.dalvikSharedDirty,memInfo.dalvikPrivateDirty,memInfo.dalvikSharedClean,memInfo.dalvikPrivateClean,dalvikMax,dalvikAllocated,dalvikFree);
  }
 else {
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.nativeSwappablePss,memInfo.nativePrivateDirty,memInfo.nativePrivateClean,nativeMax,nativeAllocated,nativeFree);
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.dalvikPss,memInfo.dalvikSwappablePss,memInfo.dalvikPrivateDirty,memInfo.dalvikPrivateClean,dalvikMax,dalvikAllocated,dalvikFree);
  }
  int otherPss=memInfo.otherPss;
  int otherSwappablePss=memInfo.otherSwappablePss;
  int otherSharedDirty=memInfo.otherSharedDirty;
  int otherPrivateDirty=memInfo.otherPrivateDirty;
  int otherSharedClean=memInfo.otherSharedClean;
  int otherPrivateClean=memInfo.otherPrivateClean;
  for (int i=0; i < Debug.MemoryInfo.NUM_OTHER_STATS; i++) {
    final int myPss=memInfo.getOtherPss(i);
    final int mySwappablePss=memInfo.getOtherSwappablePss(i);
    final int mySharedDirty=memInfo.getOtherSharedDirty(i);
    final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
    final int mySharedClean=memInfo.getOtherSharedClean(i);
    final int myPrivateClean=memInfo.getOtherPrivateClean(i);
    if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
      if (dumpFullInfo) {
        printRow(pw,HEAP_FULL_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else {
        printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,myPrivateDirty,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
      otherPss-=myPss;
      otherSwappablePss-=mySwappablePss;
      otherSharedDirty-=mySharedDirty;
      otherPrivateDirty-=myPrivateDirty;
      otherSharedClean-=mySharedClean;
      otherPrivateClean-=myPrivateClean;
    }
  }
  if (dumpFullInfo) {
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",otherPss,otherSwappablePss,otherSharedDirty,otherPrivateDirty,otherSharedClean,otherPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_FULL_COLUMN,""String_Node_Str"",memInfo.getTotalPss(),memInfo.getTotalSwappablePss(),memInfo.getTotalSharedDirty(),memInfo.getTotalPrivateDirty(),memInfo.getTotalSharedClean(),memInfo.getTotalPrivateClean(),nativeMax + dalvikMax,nativeAllocated + dalvikAllocated,nativeFree + dalvikFree);
  }
 else {
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",otherPss,otherSwappablePss,otherPrivateDirty,otherPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.getTotalPss(),memInfo.getTotalSwappablePss(),memInfo.getTotalPrivateDirty(),memInfo.getTotalPrivateClean(),nativeMax + dalvikMax,nativeAllocated + dalvikAllocated,nativeFree + dalvikFree);
  }
  if (dumpDalvik) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (int i=Debug.MemoryInfo.NUM_OTHER_STATS; i < Debug.MemoryInfo.NUM_OTHER_STATS + Debug.MemoryInfo.NUM_DVK_STATS; i++) {
      final int myPss=memInfo.getOtherPss(i);
      final int mySwappablePss=memInfo.getOtherSwappablePss(i);
      final int mySharedDirty=memInfo.getOtherSharedDirty(i);
      final int myPrivateDirty=memInfo.getOtherPrivateDirty(i);
      final int mySharedClean=memInfo.getOtherSharedClean(i);
      final int myPrivateClean=memInfo.getOtherPrivateClean(i);
      if (myPss != 0 || mySharedDirty != 0 || myPrivateDirty != 0 || mySharedClean != 0 || myPrivateClean != 0) {
        if (dumpFullInfo) {
          printRow(pw,HEAP_FULL_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,mySharedDirty,myPrivateDirty,mySharedClean,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
 else {
          printRow(pw,HEAP_COLUMN,Debug.MemoryInfo.getOtherLabel(i),myPss,mySwappablePss,myPrivateDirty,myPrivateClean,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
      }
    }
  }
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.memoryUsed / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.pageCacheOverflow / 1024,""String_Node_Str"",stats.largestMemAlloc / 1024);
  pw.println(""String_Node_Str"");
  int N=stats.dbStats.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    printRow(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < N; i++) {
      DbStats dbStats=stats.dbStats.get(i);
      printRow(pw,DB_INFO_FORMAT,(dbStats.pageSize > 0) ? String.valueOf(dbStats.pageSize) : ""String_Node_Str"",(dbStats.dbSize > 0) ? String.valueOf(dbStats.dbSize) : ""String_Node_Str"",(dbStats.lookaside > 0) ? String.valueOf(dbStats.lookaside) : ""String_Node_Str"",dbStats.cache,dbStats.dbName);
    }
  }
  String assetAlloc=AssetManager.getAssetAllocations();
  if (assetAlloc != null) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.print(assetAlloc);
  }
}"
1248,"public long getCachedSize(){
  return mCachedSize;
}","public long getCachedSize(){
  return mInfos[Debug.MEMINFO_CACHED] * 1024;
}"
1249,"public long getTotalSize(){
  return mTotalSize;
}","public long getTotalSize(){
  return mInfos[Debug.MEMINFO_TOTAL] * 1024;
}"
1250,"public long getFreeSize(){
  return mFreeSize;
}","public long getFreeSize(){
  return mInfos[Debug.MEMINFO_FREE] * 1024;
}"
1251,"public void readMemInfo(){
  StrictMode.ThreadPolicy savedPolicy=StrictMode.allowThreadDiskReads();
  try {
    long[] infos=new long[Debug.MEMINFO_COUNT];
    Debug.getMemInfo(infos);
    mTotalSize=infos[Debug.MEMINFO_TOTAL] * 1024;
    mFreeSize=infos[Debug.MEMINFO_FREE] * 1024;
    mCachedSize=infos[Debug.MEMINFO_CACHED] * 1024;
  }
  finally {
    StrictMode.setThreadPolicy(savedPolicy);
  }
}","public void readMemInfo(){
  StrictMode.ThreadPolicy savedPolicy=StrictMode.allowThreadDiskReads();
  try {
    Debug.getMemInfo(mInfos);
  }
  finally {
    StrictMode.setThreadPolicy(savedPolicy);
  }
}"
1252,"@Override protected void onAttachedToWindow(){
  super.onAttachedToWindow();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.addOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null && !mGlobalLayoutListenerAddedFilter) {
    treeObserver.addOnGlobalLayoutListener(this);
  }
  if (mAdapter != null && mDataSetObserver == null) {
    mDataSetObserver=new AdapterDataSetObserver();
    mAdapter.registerDataSetObserver(mDataSetObserver);
    mDataChanged=true;
    mOldItemCount=mItemCount;
    mItemCount=mAdapter.getCount();
  }
  mIsAttached=true;
}","@Override protected void onAttachedToWindow(){
  super.onAttachedToWindow();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.addOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null && !mGlobalLayoutListenerAddedFilter) {
    treeObserver.addOnGlobalLayoutListener(this);
  }
  if (mAdapter != null && mDataSetObserver == null) {
    mDataSetObserver=new AdapterDataSetObserver();
    mAdapter.registerDataSetObserver(mDataSetObserver);
    mDataChanged=true;
    mOldItemCount=mItemCount;
    mItemCount=mAdapter.getCount();
  }
}"
1253,"@Override protected void onFocusChanged(boolean gainFocus,int direction,Rect previouslyFocusedRect){
  super.onFocusChanged(gainFocus,direction,previouslyFocusedRect);
  if (gainFocus && mSelectedPosition < 0 && !isInTouchMode()) {
    if (!mIsAttached && mAdapter != null) {
      mDataChanged=true;
      mOldItemCount=mItemCount;
      mItemCount=mAdapter.getCount();
    }
    resurrectSelection();
  }
}","@Override protected void onFocusChanged(boolean gainFocus,int direction,Rect previouslyFocusedRect){
  super.onFocusChanged(gainFocus,direction,previouslyFocusedRect);
  if (gainFocus && mSelectedPosition < 0 && !isInTouchMode()) {
    if (!isAttachedToWindow() && mAdapter != null) {
      mDataChanged=true;
      mOldItemCount=mItemCount;
      mItemCount=mAdapter.getCount();
    }
    resurrectSelection();
  }
}"
1254,"private void onTouchUp(MotionEvent ev){
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
    final int motionPosition=mMotionPosition;
  final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null) {
  if (mTouchMode != TOUCH_MODE_DOWN) {
    child.setPressed(false);
  }
  final float x=ev.getX();
  final boolean inList=x > mListPadding.left && x < getWidth() - mListPadding.right;
  if (inList && !child.hasFocusable()) {
    if (mPerformClick == null) {
      mPerformClick=new PerformClick();
    }
    final AbsListView.PerformClick performClick=mPerformClick;
    performClick.mClickMotionPosition=motionPosition;
    performClick.rememberWindowAttachCount();
    mResurrectToPosition=motionPosition;
    if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
      removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
      mLayoutMode=LAYOUT_NORMAL;
      if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
        mTouchMode=TOUCH_MODE_TAP;
        setSelectedPositionInt(mMotionPosition);
        layoutChildren();
        child.setPressed(true);
        positionSelector(mMotionPosition,child);
        setPressed(true);
        if (mSelector != null) {
          Drawable d=mSelector.getCurrent();
          if (d != null && d instanceof TransitionDrawable) {
            ((TransitionDrawable)d).resetTransition();
          }
        }
        if (mTouchModeReset != null) {
          removeCallbacks(mTouchModeReset);
        }
        mTouchModeReset=new Runnable(){
          @Override public void run(){
            mTouchModeReset=null;
            mTouchMode=TOUCH_MODE_REST;
            child.setPressed(false);
            setPressed(false);
            if (!mDataChanged) {
              performClick.run();
            }
          }
        }
;
        postDelayed(mTouchModeReset,ViewConfiguration.getPressedStateDuration());
      }
 else {
        mTouchMode=TOUCH_MODE_REST;
        updateSelectorState();
      }
      return;
    }
 else     if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
      performClick.run();
    }
  }
}
mTouchMode=TOUCH_MODE_REST;
updateSelectorState();
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)(velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
if (mFlingRunnable != null) {
mFlingRunnable.endFling();
}
if (mPositionScroller != null) {
mPositionScroller.stop();
}
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
removeCallbacks(mPendingCheckForLongPress);
recycleVelocityTracker();
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
if (mScrollStrictSpan != null) {
mScrollStrictSpan.finish();
mScrollStrictSpan=null;
}
}","private void onTouchUp(MotionEvent ev){
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
    final int motionPosition=mMotionPosition;
  final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null) {
  if (mTouchMode != TOUCH_MODE_DOWN) {
    child.setPressed(false);
  }
  final float x=ev.getX();
  final boolean inList=x > mListPadding.left && x < getWidth() - mListPadding.right;
  if (inList && !child.hasFocusable()) {
    if (mPerformClick == null) {
      mPerformClick=new PerformClick();
    }
    final AbsListView.PerformClick performClick=mPerformClick;
    performClick.mClickMotionPosition=motionPosition;
    performClick.rememberWindowAttachCount();
    mResurrectToPosition=motionPosition;
    if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
      removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
      mLayoutMode=LAYOUT_NORMAL;
      if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
        mTouchMode=TOUCH_MODE_TAP;
        setSelectedPositionInt(mMotionPosition);
        layoutChildren();
        child.setPressed(true);
        positionSelector(mMotionPosition,child);
        setPressed(true);
        if (mSelector != null) {
          Drawable d=mSelector.getCurrent();
          if (d != null && d instanceof TransitionDrawable) {
            ((TransitionDrawable)d).resetTransition();
          }
        }
        if (mTouchModeReset != null) {
          removeCallbacks(mTouchModeReset);
        }
        mTouchModeReset=new Runnable(){
          @Override public void run(){
            mTouchModeReset=null;
            mTouchMode=TOUCH_MODE_REST;
            child.setPressed(false);
            setPressed(false);
            if (!mDataChanged && isAttachedToWindow()) {
              performClick.run();
            }
          }
        }
;
        postDelayed(mTouchModeReset,ViewConfiguration.getPressedStateDuration());
      }
 else {
        mTouchMode=TOUCH_MODE_REST;
        updateSelectorState();
      }
      return;
    }
 else     if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
      performClick.run();
    }
  }
}
mTouchMode=TOUCH_MODE_REST;
updateSelectorState();
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)(velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
if (mFlingRunnable != null) {
mFlingRunnable.endFling();
}
if (mPositionScroller != null) {
mPositionScroller.stop();
}
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
removeCallbacks(mPendingCheckForLongPress);
recycleVelocityTracker();
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
if (mScrollStrictSpan != null) {
mScrollStrictSpan.finish();
mScrollStrictSpan=null;
}
}"
1255,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!mIsAttached) {
    return false;
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  initVelocityTrackerIfNotExists();
  mVelocityTracker.addMovement(ev);
  final int actionMasked=ev.getActionMasked();
switch (actionMasked) {
case MotionEvent.ACTION_DOWN:
{
      onTouchDown(ev);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    onTouchMove(ev);
    break;
  }
case MotionEvent.ACTION_UP:
{
  onTouchUp(ev);
  break;
}
case MotionEvent.ACTION_CANCEL:
{
onTouchCancel();
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
final int id=ev.getPointerId(index);
final int x=(int)ev.getX(index);
final int y=(int)ev.getY(index);
mMotionCorrection=0;
mActivePointerId=id;
mMotionX=x;
mMotionY=y;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!isAttachedToWindow()) {
    return false;
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  initVelocityTrackerIfNotExists();
  mVelocityTracker.addMovement(ev);
  final int actionMasked=ev.getActionMasked();
switch (actionMasked) {
case MotionEvent.ACTION_DOWN:
{
      onTouchDown(ev);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    onTouchMove(ev);
    break;
  }
case MotionEvent.ACTION_UP:
{
  onTouchUp(ev);
  break;
}
case MotionEvent.ACTION_CANCEL:
{
onTouchCancel();
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
final int id=ev.getPointerId(index);
final int x=(int)ev.getX(index);
final int y=(int)ev.getY(index);
mMotionCorrection=0;
mActivePointerId=id;
mMotionX=x;
mMotionY=y;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}"
1256,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  int action=ev.getAction();
  View v;
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!mIsAttached) {
    return false;
  }
  if (mFastScroller != null && mFastScroller.onInterceptTouchEvent(ev)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      int touchMode=mTouchMode;
      if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
        mMotionCorrection=0;
        return true;
      }
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      int motionPosition=findMotionRow(y);
      if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mTouchMode=TOUCH_MODE_DOWN;
        clearScrollingCache();
      }
      mLastY=Integer.MIN_VALUE;
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      if (touchMode == TOUCH_MODE_FLING) {
        return true;
      }
      break;
    }
case MotionEvent.ACTION_MOVE:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
      int pointerIndex=ev.findPointerIndex(mActivePointerId);
    if (pointerIndex == -1) {
      pointerIndex=0;
      mActivePointerId=ev.getPointerId(pointerIndex);
    }
  final int y=(int)ev.getY(pointerIndex);
initVelocityTrackerIfNotExists();
mVelocityTracker.addMovement(ev);
if (startScrollIfNeeded(y)) {
return true;
}
break;
}
break;
}
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
{
mTouchMode=TOUCH_MODE_REST;
mActivePointerId=INVALID_POINTER;
recycleVelocityTracker();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
break;
}
}
return false;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  int action=ev.getAction();
  View v;
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!isAttachedToWindow()) {
    return false;
  }
  if (mFastScroller != null && mFastScroller.onInterceptTouchEvent(ev)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      int touchMode=mTouchMode;
      if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
        mMotionCorrection=0;
        return true;
      }
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      int motionPosition=findMotionRow(y);
      if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mTouchMode=TOUCH_MODE_DOWN;
        clearScrollingCache();
      }
      mLastY=Integer.MIN_VALUE;
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      if (touchMode == TOUCH_MODE_FLING) {
        return true;
      }
      break;
    }
case MotionEvent.ACTION_MOVE:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
      int pointerIndex=ev.findPointerIndex(mActivePointerId);
    if (pointerIndex == -1) {
      pointerIndex=0;
      mActivePointerId=ev.getPointerId(pointerIndex);
    }
  final int y=(int)ev.getY(pointerIndex);
initVelocityTrackerIfNotExists();
mVelocityTracker.addMovement(ev);
if (startScrollIfNeeded(y)) {
return true;
}
break;
}
break;
}
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
{
mTouchMode=TOUCH_MODE_REST;
mActivePointerId=INVALID_POINTER;
recycleVelocityTracker();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
break;
}
}
return false;
}"
1257,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null && mDataSetObserver != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
  mIsAttached=false;
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null && mDataSetObserver != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
}"
1258,"private boolean commonKey(int keyCode,int count,KeyEvent event){
  if (mAdapter == null || !mIsAttached) {
    return false;
  }
  if (mDataChanged) {
    layoutChildren();
  }
  boolean handled=false;
  int action=event.getAction();
  if (action != KeyEvent.ACTION_UP) {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (event.hasNoModifiers()) {
        handled=resurrectSelectionIfNeeded();
        if (!handled) {
          while (count-- > 0) {
            if (arrowScroll(FOCUS_UP)) {
              handled=true;
            }
 else {
              break;
            }
          }
        }
      }
 else       if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
        handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (event.hasNoModifiers()) {
    handled=resurrectSelectionIfNeeded();
    if (!handled) {
      while (count-- > 0) {
        if (arrowScroll(FOCUS_DOWN)) {
          handled=true;
        }
 else {
          break;
        }
      }
    }
  }
 else   if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
    handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_DPAD_LEFT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_LEFT);
}
break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_RIGHT);
}
break;
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded();
if (!handled && event.getRepeatCount() == 0 && getChildCount() > 0) {
keyPressed();
handled=true;
}
}
break;
case KeyEvent.KEYCODE_SPACE:
if (mPopup == null || !mPopup.isShowing()) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
handled=true;
}
break;
case KeyEvent.KEYCODE_PAGE_UP:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_PAGE_DOWN:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_MOVE_HOME:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_MOVE_END:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_TAB:
if (false) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_UP);
}
}
break;
}
}
if (handled) {
return true;
}
if (sendToTextFilter(keyCode,count,event)) {
return true;
}
switch (action) {
case KeyEvent.ACTION_DOWN:
return super.onKeyDown(keyCode,event);
case KeyEvent.ACTION_UP:
return super.onKeyUp(keyCode,event);
case KeyEvent.ACTION_MULTIPLE:
return super.onKeyMultiple(keyCode,count,event);
default :
return false;
}
}","private boolean commonKey(int keyCode,int count,KeyEvent event){
  if (mAdapter == null || !isAttachedToWindow()) {
    return false;
  }
  if (mDataChanged) {
    layoutChildren();
  }
  boolean handled=false;
  int action=event.getAction();
  if (action != KeyEvent.ACTION_UP) {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (event.hasNoModifiers()) {
        handled=resurrectSelectionIfNeeded();
        if (!handled) {
          while (count-- > 0) {
            if (arrowScroll(FOCUS_UP)) {
              handled=true;
            }
 else {
              break;
            }
          }
        }
      }
 else       if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
        handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (event.hasNoModifiers()) {
    handled=resurrectSelectionIfNeeded();
    if (!handled) {
      while (count-- > 0) {
        if (arrowScroll(FOCUS_DOWN)) {
          handled=true;
        }
 else {
          break;
        }
      }
    }
  }
 else   if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
    handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_DPAD_LEFT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_LEFT);
}
break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_RIGHT);
}
break;
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded();
if (!handled && event.getRepeatCount() == 0 && getChildCount() > 0) {
keyPressed();
handled=true;
}
}
break;
case KeyEvent.KEYCODE_SPACE:
if (mPopup == null || !mPopup.isShowing()) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
handled=true;
}
break;
case KeyEvent.KEYCODE_PAGE_UP:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_PAGE_DOWN:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_MOVE_HOME:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_MOVE_END:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_TAB:
if (false) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_UP);
}
}
break;
}
}
if (handled) {
return true;
}
if (sendToTextFilter(keyCode,count,event)) {
return true;
}
switch (action) {
case KeyEvent.ACTION_DOWN:
return super.onKeyDown(keyCode,event);
case KeyEvent.ACTION_UP:
return super.onKeyUp(keyCode,event);
case KeyEvent.ACTION_MULTIPLE:
return super.onKeyMultiple(keyCode,count,event);
default :
return false;
}
}"
1259,"@Override protected void onAttachedToWindow(){
  super.onAttachedToWindow();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.addOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null && !mGlobalLayoutListenerAddedFilter) {
    treeObserver.addOnGlobalLayoutListener(this);
  }
  if (mAdapter != null && mDataSetObserver == null) {
    mDataSetObserver=new AdapterDataSetObserver();
    mAdapter.registerDataSetObserver(mDataSetObserver);
    mDataChanged=true;
    mOldItemCount=mItemCount;
    mItemCount=mAdapter.getCount();
  }
  mIsAttached=true;
}","@Override protected void onAttachedToWindow(){
  super.onAttachedToWindow();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.addOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null && !mGlobalLayoutListenerAddedFilter) {
    treeObserver.addOnGlobalLayoutListener(this);
  }
  if (mAdapter != null && mDataSetObserver == null) {
    mDataSetObserver=new AdapterDataSetObserver();
    mAdapter.registerDataSetObserver(mDataSetObserver);
    mDataChanged=true;
    mOldItemCount=mItemCount;
    mItemCount=mAdapter.getCount();
  }
}"
1260,"@Override protected void onFocusChanged(boolean gainFocus,int direction,Rect previouslyFocusedRect){
  super.onFocusChanged(gainFocus,direction,previouslyFocusedRect);
  if (gainFocus && mSelectedPosition < 0 && !isInTouchMode()) {
    if (!mIsAttached && mAdapter != null) {
      mDataChanged=true;
      mOldItemCount=mItemCount;
      mItemCount=mAdapter.getCount();
    }
    resurrectSelection();
  }
}","@Override protected void onFocusChanged(boolean gainFocus,int direction,Rect previouslyFocusedRect){
  super.onFocusChanged(gainFocus,direction,previouslyFocusedRect);
  if (gainFocus && mSelectedPosition < 0 && !isInTouchMode()) {
    if (!isAttachedToWindow() && mAdapter != null) {
      mDataChanged=true;
      mOldItemCount=mItemCount;
      mItemCount=mAdapter.getCount();
    }
    resurrectSelection();
  }
}"
1261,"private void onTouchUp(MotionEvent ev){
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
    final int motionPosition=mMotionPosition;
  final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null) {
  if (mTouchMode != TOUCH_MODE_DOWN) {
    child.setPressed(false);
  }
  final float x=ev.getX();
  final boolean inList=x > mListPadding.left && x < getWidth() - mListPadding.right;
  if (inList && !child.hasFocusable()) {
    if (mPerformClick == null) {
      mPerformClick=new PerformClick();
    }
    final AbsListView.PerformClick performClick=mPerformClick;
    performClick.mClickMotionPosition=motionPosition;
    performClick.rememberWindowAttachCount();
    mResurrectToPosition=motionPosition;
    if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
      removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
      mLayoutMode=LAYOUT_NORMAL;
      if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
        mTouchMode=TOUCH_MODE_TAP;
        setSelectedPositionInt(mMotionPosition);
        layoutChildren();
        child.setPressed(true);
        positionSelector(mMotionPosition,child);
        setPressed(true);
        if (mSelector != null) {
          Drawable d=mSelector.getCurrent();
          if (d != null && d instanceof TransitionDrawable) {
            ((TransitionDrawable)d).resetTransition();
          }
        }
        if (mTouchModeReset != null) {
          removeCallbacks(mTouchModeReset);
        }
        mTouchModeReset=new Runnable(){
          @Override public void run(){
            mTouchModeReset=null;
            mTouchMode=TOUCH_MODE_REST;
            child.setPressed(false);
            setPressed(false);
            if (!mDataChanged) {
              performClick.run();
            }
          }
        }
;
        postDelayed(mTouchModeReset,ViewConfiguration.getPressedStateDuration());
      }
 else {
        mTouchMode=TOUCH_MODE_REST;
        updateSelectorState();
      }
      return;
    }
 else     if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
      performClick.run();
    }
  }
}
mTouchMode=TOUCH_MODE_REST;
updateSelectorState();
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)(velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
if (mFlingRunnable != null) {
mFlingRunnable.endFling();
}
if (mPositionScroller != null) {
mPositionScroller.stop();
}
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
removeCallbacks(mPendingCheckForLongPress);
recycleVelocityTracker();
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
if (mScrollStrictSpan != null) {
mScrollStrictSpan.finish();
mScrollStrictSpan=null;
}
}","private void onTouchUp(MotionEvent ev){
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
    final int motionPosition=mMotionPosition;
  final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null) {
  if (mTouchMode != TOUCH_MODE_DOWN) {
    child.setPressed(false);
  }
  final float x=ev.getX();
  final boolean inList=x > mListPadding.left && x < getWidth() - mListPadding.right;
  if (inList && !child.hasFocusable()) {
    if (mPerformClick == null) {
      mPerformClick=new PerformClick();
    }
    final AbsListView.PerformClick performClick=mPerformClick;
    performClick.mClickMotionPosition=motionPosition;
    performClick.rememberWindowAttachCount();
    mResurrectToPosition=motionPosition;
    if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
      removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
      mLayoutMode=LAYOUT_NORMAL;
      if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
        mTouchMode=TOUCH_MODE_TAP;
        setSelectedPositionInt(mMotionPosition);
        layoutChildren();
        child.setPressed(true);
        positionSelector(mMotionPosition,child);
        setPressed(true);
        if (mSelector != null) {
          Drawable d=mSelector.getCurrent();
          if (d != null && d instanceof TransitionDrawable) {
            ((TransitionDrawable)d).resetTransition();
          }
        }
        if (mTouchModeReset != null) {
          removeCallbacks(mTouchModeReset);
        }
        mTouchModeReset=new Runnable(){
          @Override public void run(){
            mTouchModeReset=null;
            mTouchMode=TOUCH_MODE_REST;
            child.setPressed(false);
            setPressed(false);
            if (!mDataChanged && isAttachedToWindow()) {
              performClick.run();
            }
          }
        }
;
        postDelayed(mTouchModeReset,ViewConfiguration.getPressedStateDuration());
      }
 else {
        mTouchMode=TOUCH_MODE_REST;
        updateSelectorState();
      }
      return;
    }
 else     if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
      performClick.run();
    }
  }
}
mTouchMode=TOUCH_MODE_REST;
updateSelectorState();
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)(velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
if (mFlingRunnable != null) {
mFlingRunnable.endFling();
}
if (mPositionScroller != null) {
mPositionScroller.stop();
}
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
removeCallbacks(mPendingCheckForLongPress);
recycleVelocityTracker();
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
if (mScrollStrictSpan != null) {
mScrollStrictSpan.finish();
mScrollStrictSpan=null;
}
}"
1262,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!mIsAttached) {
    return false;
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  initVelocityTrackerIfNotExists();
  mVelocityTracker.addMovement(ev);
  final int actionMasked=ev.getActionMasked();
switch (actionMasked) {
case MotionEvent.ACTION_DOWN:
{
      onTouchDown(ev);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    onTouchMove(ev);
    break;
  }
case MotionEvent.ACTION_UP:
{
  onTouchUp(ev);
  break;
}
case MotionEvent.ACTION_CANCEL:
{
onTouchCancel();
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
final int id=ev.getPointerId(index);
final int x=(int)ev.getX(index);
final int y=(int)ev.getY(index);
mMotionCorrection=0;
mActivePointerId=id;
mMotionX=x;
mMotionY=y;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!isAttachedToWindow()) {
    return false;
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  initVelocityTrackerIfNotExists();
  mVelocityTracker.addMovement(ev);
  final int actionMasked=ev.getActionMasked();
switch (actionMasked) {
case MotionEvent.ACTION_DOWN:
{
      onTouchDown(ev);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    onTouchMove(ev);
    break;
  }
case MotionEvent.ACTION_UP:
{
  onTouchUp(ev);
  break;
}
case MotionEvent.ACTION_CANCEL:
{
onTouchCancel();
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
final int id=ev.getPointerId(index);
final int x=(int)ev.getX(index);
final int y=(int)ev.getY(index);
mMotionCorrection=0;
mActivePointerId=id;
mMotionX=x;
mMotionY=y;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}"
1263,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  int action=ev.getAction();
  View v;
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!mIsAttached) {
    return false;
  }
  if (mFastScroller != null && mFastScroller.onInterceptTouchEvent(ev)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      int touchMode=mTouchMode;
      if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
        mMotionCorrection=0;
        return true;
      }
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      int motionPosition=findMotionRow(y);
      if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mTouchMode=TOUCH_MODE_DOWN;
        clearScrollingCache();
      }
      mLastY=Integer.MIN_VALUE;
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      if (touchMode == TOUCH_MODE_FLING) {
        return true;
      }
      break;
    }
case MotionEvent.ACTION_MOVE:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
      int pointerIndex=ev.findPointerIndex(mActivePointerId);
    if (pointerIndex == -1) {
      pointerIndex=0;
      mActivePointerId=ev.getPointerId(pointerIndex);
    }
  final int y=(int)ev.getY(pointerIndex);
initVelocityTrackerIfNotExists();
mVelocityTracker.addMovement(ev);
if (startScrollIfNeeded(y)) {
return true;
}
break;
}
break;
}
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
{
mTouchMode=TOUCH_MODE_REST;
mActivePointerId=INVALID_POINTER;
recycleVelocityTracker();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
break;
}
}
return false;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  int action=ev.getAction();
  View v;
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!isAttachedToWindow()) {
    return false;
  }
  if (mFastScroller != null && mFastScroller.onInterceptTouchEvent(ev)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      int touchMode=mTouchMode;
      if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
        mMotionCorrection=0;
        return true;
      }
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      int motionPosition=findMotionRow(y);
      if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mTouchMode=TOUCH_MODE_DOWN;
        clearScrollingCache();
      }
      mLastY=Integer.MIN_VALUE;
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      if (touchMode == TOUCH_MODE_FLING) {
        return true;
      }
      break;
    }
case MotionEvent.ACTION_MOVE:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
      int pointerIndex=ev.findPointerIndex(mActivePointerId);
    if (pointerIndex == -1) {
      pointerIndex=0;
      mActivePointerId=ev.getPointerId(pointerIndex);
    }
  final int y=(int)ev.getY(pointerIndex);
initVelocityTrackerIfNotExists();
mVelocityTracker.addMovement(ev);
if (startScrollIfNeeded(y)) {
return true;
}
break;
}
break;
}
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
{
mTouchMode=TOUCH_MODE_REST;
mActivePointerId=INVALID_POINTER;
recycleVelocityTracker();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
break;
}
}
return false;
}"
1264,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null && mDataSetObserver != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
  mIsAttached=false;
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null && mDataSetObserver != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
}"
1265,"private boolean commonKey(int keyCode,int count,KeyEvent event){
  if (mAdapter == null || !mIsAttached) {
    return false;
  }
  if (mDataChanged) {
    layoutChildren();
  }
  boolean handled=false;
  int action=event.getAction();
  if (action != KeyEvent.ACTION_UP) {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (event.hasNoModifiers()) {
        handled=resurrectSelectionIfNeeded();
        if (!handled) {
          while (count-- > 0) {
            if (arrowScroll(FOCUS_UP)) {
              handled=true;
            }
 else {
              break;
            }
          }
        }
      }
 else       if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
        handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (event.hasNoModifiers()) {
    handled=resurrectSelectionIfNeeded();
    if (!handled) {
      while (count-- > 0) {
        if (arrowScroll(FOCUS_DOWN)) {
          handled=true;
        }
 else {
          break;
        }
      }
    }
  }
 else   if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
    handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_DPAD_LEFT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_LEFT);
}
break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_RIGHT);
}
break;
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded();
if (!handled && event.getRepeatCount() == 0 && getChildCount() > 0) {
keyPressed();
handled=true;
}
}
break;
case KeyEvent.KEYCODE_SPACE:
if (mPopup == null || !mPopup.isShowing()) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
handled=true;
}
break;
case KeyEvent.KEYCODE_PAGE_UP:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_PAGE_DOWN:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_MOVE_HOME:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_MOVE_END:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_TAB:
if (false) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_UP);
}
}
break;
}
}
if (handled) {
return true;
}
if (sendToTextFilter(keyCode,count,event)) {
return true;
}
switch (action) {
case KeyEvent.ACTION_DOWN:
return super.onKeyDown(keyCode,event);
case KeyEvent.ACTION_UP:
return super.onKeyUp(keyCode,event);
case KeyEvent.ACTION_MULTIPLE:
return super.onKeyMultiple(keyCode,count,event);
default :
return false;
}
}","private boolean commonKey(int keyCode,int count,KeyEvent event){
  if (mAdapter == null || !isAttachedToWindow()) {
    return false;
  }
  if (mDataChanged) {
    layoutChildren();
  }
  boolean handled=false;
  int action=event.getAction();
  if (action != KeyEvent.ACTION_UP) {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (event.hasNoModifiers()) {
        handled=resurrectSelectionIfNeeded();
        if (!handled) {
          while (count-- > 0) {
            if (arrowScroll(FOCUS_UP)) {
              handled=true;
            }
 else {
              break;
            }
          }
        }
      }
 else       if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
        handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (event.hasNoModifiers()) {
    handled=resurrectSelectionIfNeeded();
    if (!handled) {
      while (count-- > 0) {
        if (arrowScroll(FOCUS_DOWN)) {
          handled=true;
        }
 else {
          break;
        }
      }
    }
  }
 else   if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
    handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_DPAD_LEFT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_LEFT);
}
break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_RIGHT);
}
break;
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded();
if (!handled && event.getRepeatCount() == 0 && getChildCount() > 0) {
keyPressed();
handled=true;
}
}
break;
case KeyEvent.KEYCODE_SPACE:
if (mPopup == null || !mPopup.isShowing()) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
handled=true;
}
break;
case KeyEvent.KEYCODE_PAGE_UP:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_PAGE_DOWN:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_MOVE_HOME:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_MOVE_END:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_TAB:
if (false) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_UP);
}
}
break;
}
}
if (handled) {
return true;
}
if (sendToTextFilter(keyCode,count,event)) {
return true;
}
switch (action) {
case KeyEvent.ACTION_DOWN:
return super.onKeyDown(keyCode,event);
case KeyEvent.ACTION_UP:
return super.onKeyUp(keyCode,event);
case KeyEvent.ACTION_MULTIPLE:
return super.onKeyMultiple(keyCode,count,event);
default :
return false;
}
}"
1266,"/** 
 * The same as   {@link #flattenToString()}, but abbreviates the class name if it is a suffix of the package.  The result can still be used with   {@link #unflattenFromString(String)}.
 * @return Returns a new String holding the package and class names.  Thisis represented as the package name, concatenated with a '/' and then the class name.
 * @see #unflattenFromString(String)
 */
public String flattenToShortString(){
  return mPackage + ""String_Node_Str"" + getShortClassName();
}","/** 
 * The same as   {@link #flattenToString()}, but abbreviates the class name if it is a suffix of the package.  The result can still be used with   {@link #unflattenFromString(String)}.
 * @return Returns a new String holding the package and class names.  Thisis represented as the package name, concatenated with a '/' and then the class name.
 * @see #unflattenFromString(String)
 */
public String flattenToShortString(){
  StringBuilder sb=new StringBuilder(mPackage.length() + mClass.length());
  appendShortString(sb,mPackage,mClass);
  return sb.toString();
}"
1267,"public String toString(){
  return ""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ service.info.name+ ""String_Node_Str"";
}","public String toString(){
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(' ');
  service.appendComponentShortName(sb);
  sb.append('}');
  return sb.toString();
}"
1268,"public String toString(){
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  return ""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ ci.name+ ""String_Node_Str""+ priority+ ""String_Node_Str""+ preferredOrder+ ""String_Node_Str""+ Integer.toHexString(match)+ ""String_Node_Str"";
}","public String toString(){
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(' ');
  ComponentName.appendShortString(sb,ci.packageName,ci.name);
  if (priority != 0) {
    sb.append(""String_Node_Str"");
    sb.append(priority);
  }
  if (preferredOrder != 0) {
    sb.append(""String_Node_Str"");
    sb.append(preferredOrder);
  }
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(match));
  sb.append('}');
  return sb.toString();
}"
1269,"public ResolveListAdapter(Context context,Intent intent,Intent[] initialIntents,List<ResolveInfo> rList,int launchedFromUid){
  mIntent=new Intent(intent);
  mIntent.setComponent(null);
  mInitialIntents=initialIntents;
  mBaseResolveList=rList;
  mLaunchedFromUid=launchedFromUid;
  mInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mList=new ArrayList<DisplayResolveInfo>();
  rebuildList();
}","public ResolveListAdapter(Context context,Intent intent,Intent[] initialIntents,List<ResolveInfo> rList,int launchedFromUid){
  mIntent=new Intent(intent);
  mInitialIntents=initialIntents;
  mBaseResolveList=rList;
  mLaunchedFromUid=launchedFromUid;
  mInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mList=new ArrayList<DisplayResolveInfo>();
  rebuildList();
}"
1270,"private void rebuildList(){
  List<ResolveInfo> currentResolveList;
  try {
    mLastChosen=AppGlobals.getPackageManager().getLastChosenActivity(mIntent,mIntent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY);
  }
 catch (  RemoteException re) {
    Log.d(TAG,""String_Node_Str"" + re);
  }
  mList.clear();
  if (mBaseResolveList != null) {
    currentResolveList=mBaseResolveList;
  }
 else {
    currentResolveList=mPm.queryIntentActivities(mIntent,PackageManager.MATCH_DEFAULT_ONLY | (mAlwaysUseOption ? PackageManager.GET_RESOLVED_FILTER : 0));
    if (currentResolveList != null) {
      for (int i=currentResolveList.size() - 1; i >= 0; i--) {
        ActivityInfo ai=currentResolveList.get(i).activityInfo;
        int granted=ActivityManager.checkComponentPermission(ai.permission,mLaunchedFromUid,ai.applicationInfo.uid,ai.exported);
        if (granted != PackageManager.PERMISSION_GRANTED) {
          currentResolveList.remove(i);
        }
      }
    }
  }
  int N;
  if ((currentResolveList != null) && ((N=currentResolveList.size()) > 0)) {
    ResolveInfo r0=currentResolveList.get(0);
    for (int i=1; i < N; i++) {
      ResolveInfo ri=currentResolveList.get(i);
      if (DEBUG)       Log.v(""String_Node_Str"",r0.activityInfo.name + ""String_Node_Str"" + r0.priority+ ""String_Node_Str""+ r0.isDefault+ ""String_Node_Str""+ ri.activityInfo.name+ ""String_Node_Str""+ ri.priority+ ""String_Node_Str""+ ri.isDefault);
      if (r0.priority != ri.priority || r0.isDefault != ri.isDefault) {
        while (i < N) {
          currentResolveList.remove(i);
          N--;
        }
      }
    }
    if (N > 1) {
      ResolveInfo.DisplayNameComparator rComparator=new ResolveInfo.DisplayNameComparator(mPm);
      Collections.sort(currentResolveList,rComparator);
    }
    if (mInitialIntents != null) {
      for (int i=0; i < mInitialIntents.length; i++) {
        Intent ii=mInitialIntents[i];
        if (ii == null) {
          continue;
        }
        ActivityInfo ai=ii.resolveActivityInfo(getPackageManager(),0);
        if (ai == null) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + ii);
          continue;
        }
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        if (ii instanceof LabeledIntent) {
          LabeledIntent li=(LabeledIntent)ii;
          ri.resolvePackageName=li.getSourcePackage();
          ri.labelRes=li.getLabelResource();
          ri.nonLocalizedLabel=li.getNonLocalizedLabel();
          ri.icon=li.getIconResource();
        }
        mList.add(new DisplayResolveInfo(ri,ri.loadLabel(getPackageManager()),null,ii));
      }
    }
    r0=currentResolveList.get(0);
    int start=0;
    CharSequence r0Label=r0.loadLabel(mPm);
    mShowExtended=false;
    for (int i=1; i < N; i++) {
      if (r0Label == null) {
        r0Label=r0.activityInfo.packageName;
      }
      ResolveInfo ri=currentResolveList.get(i);
      CharSequence riLabel=ri.loadLabel(mPm);
      if (riLabel == null) {
        riLabel=ri.activityInfo.packageName;
      }
      if (riLabel.equals(r0Label)) {
        continue;
      }
      processGroup(currentResolveList,start,(i - 1),r0,r0Label);
      r0=ri;
      r0Label=riLabel;
      start=i;
    }
    processGroup(currentResolveList,start,(N - 1),r0,r0Label);
  }
}","private void rebuildList(){
  List<ResolveInfo> currentResolveList;
  try {
    mLastChosen=AppGlobals.getPackageManager().getLastChosenActivity(mIntent,mIntent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY);
  }
 catch (  RemoteException re) {
    Log.d(TAG,""String_Node_Str"" + re);
  }
  mList.clear();
  if (mBaseResolveList != null) {
    currentResolveList=mBaseResolveList;
    mOrigResolveList=null;
  }
 else {
    currentResolveList=mOrigResolveList=mPm.queryIntentActivities(mIntent,PackageManager.MATCH_DEFAULT_ONLY | (mAlwaysUseOption ? PackageManager.GET_RESOLVED_FILTER : 0));
    if (currentResolveList != null) {
      for (int i=currentResolveList.size() - 1; i >= 0; i--) {
        ActivityInfo ai=currentResolveList.get(i).activityInfo;
        int granted=ActivityManager.checkComponentPermission(ai.permission,mLaunchedFromUid,ai.applicationInfo.uid,ai.exported);
        if (granted != PackageManager.PERMISSION_GRANTED) {
          if (mOrigResolveList == currentResolveList) {
            mOrigResolveList=new ArrayList<ResolveInfo>(mOrigResolveList);
          }
          currentResolveList.remove(i);
        }
      }
    }
  }
  int N;
  if ((currentResolveList != null) && ((N=currentResolveList.size()) > 0)) {
    ResolveInfo r0=currentResolveList.get(0);
    for (int i=1; i < N; i++) {
      ResolveInfo ri=currentResolveList.get(i);
      if (DEBUG)       Log.v(""String_Node_Str"",r0.activityInfo.name + ""String_Node_Str"" + r0.priority+ ""String_Node_Str""+ r0.isDefault+ ""String_Node_Str""+ ri.activityInfo.name+ ""String_Node_Str""+ ri.priority+ ""String_Node_Str""+ ri.isDefault);
      if (r0.priority != ri.priority || r0.isDefault != ri.isDefault) {
        while (i < N) {
          if (mOrigResolveList == currentResolveList) {
            mOrigResolveList=new ArrayList<ResolveInfo>(mOrigResolveList);
          }
          currentResolveList.remove(i);
          N--;
        }
      }
    }
    if (N > 1) {
      ResolveInfo.DisplayNameComparator rComparator=new ResolveInfo.DisplayNameComparator(mPm);
      Collections.sort(currentResolveList,rComparator);
    }
    if (mInitialIntents != null) {
      for (int i=0; i < mInitialIntents.length; i++) {
        Intent ii=mInitialIntents[i];
        if (ii == null) {
          continue;
        }
        ActivityInfo ai=ii.resolveActivityInfo(getPackageManager(),0);
        if (ai == null) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + ii);
          continue;
        }
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        if (ii instanceof LabeledIntent) {
          LabeledIntent li=(LabeledIntent)ii;
          ri.resolvePackageName=li.getSourcePackage();
          ri.labelRes=li.getLabelResource();
          ri.nonLocalizedLabel=li.getNonLocalizedLabel();
          ri.icon=li.getIconResource();
        }
        mList.add(new DisplayResolveInfo(ri,ri.loadLabel(getPackageManager()),null,ii));
      }
    }
    r0=currentResolveList.get(0);
    int start=0;
    CharSequence r0Label=r0.loadLabel(mPm);
    mShowExtended=false;
    for (int i=1; i < N; i++) {
      if (r0Label == null) {
        r0Label=r0.activityInfo.packageName;
      }
      ResolveInfo ri=currentResolveList.get(i);
      CharSequence riLabel=ri.loadLabel(mPm);
      if (riLabel == null) {
        riLabel=ri.activityInfo.packageName;
      }
      if (riLabel.equals(r0Label)) {
        continue;
      }
      processGroup(currentResolveList,start,(i - 1),r0,r0Label);
      r0=ri;
      r0Label=riLabel;
      start=i;
    }
    processGroup(currentResolveList,start,(N - 1),r0,r0Label);
  }
}"
1271,"protected void onCreate(Bundle savedInstanceState,Intent intent,CharSequence title,Intent[] initialIntents,List<ResolveInfo> rList,boolean alwaysUseOption){
  setTheme(R.style.Theme_DeviceDefault_Light_Dialog_Alert);
  super.onCreate(savedInstanceState);
  try {
    mLaunchedFromUid=ActivityManagerNative.getDefault().getLaunchedFromUid(getActivityToken());
  }
 catch (  RemoteException e) {
    mLaunchedFromUid=-1;
  }
  mPm=getPackageManager();
  mAlwaysUseOption=alwaysUseOption;
  mMaxColumns=getResources().getInteger(R.integer.config_maxResolverActivityColumns);
  intent.setComponent(null);
  AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=title;
  mPackageMonitor.register(this,getMainLooper(),false);
  mRegistered=true;
  final ActivityManager am=(ActivityManager)getSystemService(ACTIVITY_SERVICE);
  mIconDpi=am.getLauncherLargeIconDensity();
  mIconSize=am.getLauncherLargeIconSize();
  mAdapter=new ResolveListAdapter(this,intent,initialIntents,rList,mLaunchedFromUid);
  int count=mAdapter.getCount();
  if (mLaunchedFromUid < 0 || UserHandle.isIsolated(mLaunchedFromUid)) {
    finish();
    return;
  }
 else   if (count > 1) {
    ap.mView=getLayoutInflater().inflate(R.layout.resolver_list,null);
    mListView=(ListView)ap.mView.findViewById(R.id.resolver_list);
    mListView.setAdapter(mAdapter);
    mListView.setOnItemClickListener(this);
    mListView.setOnItemLongClickListener(new ItemLongClickListener());
    if (alwaysUseOption) {
      mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    }
  }
 else   if (count == 1) {
    startActivity(mAdapter.intentForPosition(0));
    mPackageMonitor.unregister();
    mRegistered=false;
    finish();
    return;
  }
 else {
    ap.mMessage=getResources().getText(R.string.noApplications);
  }
  setupAlert();
  if (alwaysUseOption) {
    final ViewGroup buttonLayout=(ViewGroup)findViewById(R.id.button_bar);
    if (buttonLayout != null) {
      buttonLayout.setVisibility(View.VISIBLE);
      mAlwaysButton=(Button)buttonLayout.findViewById(R.id.button_always);
      mOnceButton=(Button)buttonLayout.findViewById(R.id.button_once);
    }
 else {
      mAlwaysUseOption=false;
    }
  }
  final int initialHighlight=mAdapter.getInitialHighlight();
  if (initialHighlight >= 0) {
    mListView.setItemChecked(initialHighlight,true);
    onItemClick(null,null,initialHighlight,0);
  }
}","protected void onCreate(Bundle savedInstanceState,Intent intent,CharSequence title,Intent[] initialIntents,List<ResolveInfo> rList,boolean alwaysUseOption){
  setTheme(R.style.Theme_DeviceDefault_Light_Dialog_Alert);
  super.onCreate(savedInstanceState);
  try {
    mLaunchedFromUid=ActivityManagerNative.getDefault().getLaunchedFromUid(getActivityToken());
  }
 catch (  RemoteException e) {
    mLaunchedFromUid=-1;
  }
  mPm=getPackageManager();
  mAlwaysUseOption=alwaysUseOption;
  mMaxColumns=getResources().getInteger(R.integer.config_maxResolverActivityColumns);
  AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=title;
  mPackageMonitor.register(this,getMainLooper(),false);
  mRegistered=true;
  final ActivityManager am=(ActivityManager)getSystemService(ACTIVITY_SERVICE);
  mIconDpi=am.getLauncherLargeIconDensity();
  mIconSize=am.getLauncherLargeIconSize();
  mAdapter=new ResolveListAdapter(this,intent,initialIntents,rList,mLaunchedFromUid);
  int count=mAdapter.getCount();
  if (mLaunchedFromUid < 0 || UserHandle.isIsolated(mLaunchedFromUid)) {
    finish();
    return;
  }
 else   if (count > 1) {
    ap.mView=getLayoutInflater().inflate(R.layout.resolver_list,null);
    mListView=(ListView)ap.mView.findViewById(R.id.resolver_list);
    mListView.setAdapter(mAdapter);
    mListView.setOnItemClickListener(this);
    mListView.setOnItemLongClickListener(new ItemLongClickListener());
    if (alwaysUseOption) {
      mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    }
  }
 else   if (count == 1) {
    startActivity(mAdapter.intentForPosition(0));
    mPackageMonitor.unregister();
    mRegistered=false;
    finish();
    return;
  }
 else {
    ap.mMessage=getResources().getText(R.string.noApplications);
  }
  setupAlert();
  if (alwaysUseOption) {
    final ViewGroup buttonLayout=(ViewGroup)findViewById(R.id.button_bar);
    if (buttonLayout != null) {
      buttonLayout.setVisibility(View.VISIBLE);
      mAlwaysButton=(Button)buttonLayout.findViewById(R.id.button_always);
      mOnceButton=(Button)buttonLayout.findViewById(R.id.button_once);
    }
 else {
      mAlwaysUseOption=false;
    }
  }
  final int initialHighlight=mAdapter.getInitialHighlight();
  if (initialHighlight >= 0) {
    mListView.setItemChecked(initialHighlight,true);
    onItemClick(null,null,initialHighlight,0);
  }
}"
1272,"private Intent makeMyIntent(){
  Intent intent=new Intent(getIntent());
  intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
  return intent;
}","private Intent makeMyIntent(){
  Intent intent=new Intent(getIntent());
  intent.setComponent(null);
  intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
  return intent;
}"
1273,"protected void onIntentSelected(ResolveInfo ri,Intent intent,boolean alwaysCheck){
  if (mAlwaysUseOption) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<PatternMatcher> pIt=ri.filter.schemeSpecificPartsIterator();
        if (pIt != null) {
          String ssp=data.getSchemeSpecificPart();
          while (ssp != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(ssp)) {
              filter.addDataSchemeSpecificPart(p.getPath(),p.getType());
              break;
            }
          }
        }
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      if (alwaysCheck) {
        getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
      }
 else {
        try {
          AppGlobals.getPackageManager().setLastChosenActivity(intent,intent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY,filter,bestMatch,intent.getComponent());
        }
 catch (        RemoteException re) {
          Log.d(TAG,""String_Node_Str"" + re);
        }
      }
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
}","protected void onIntentSelected(ResolveInfo ri,Intent intent,boolean alwaysCheck){
  if (mAlwaysUseOption && mAdapter.mOrigResolveList != null) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<PatternMatcher> pIt=ri.filter.schemeSpecificPartsIterator();
        if (pIt != null) {
          String ssp=data.getSchemeSpecificPart();
          while (ssp != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(ssp)) {
              filter.addDataSchemeSpecificPart(p.getPath(),p.getType());
              break;
            }
          }
        }
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mOrigResolveList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mOrigResolveList.get(i);
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      if (alwaysCheck) {
        getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
      }
 else {
        try {
          AppGlobals.getPackageManager().setLastChosenActivity(intent,intent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY,filter,bestMatch,intent.getComponent());
        }
 catch (        RemoteException re) {
          Log.d(TAG,""String_Node_Str"" + re);
        }
      }
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
}"
1274,"@Override protected void onAttachedToWindow(){
  super.onAttachedToWindow();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.addOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null && !mGlobalLayoutListenerAddedFilter) {
    treeObserver.addOnGlobalLayoutListener(this);
  }
  if (mAdapter != null && mDataSetObserver == null) {
    mDataSetObserver=new AdapterDataSetObserver();
    mAdapter.registerDataSetObserver(mDataSetObserver);
    mDataChanged=true;
    mOldItemCount=mItemCount;
    mItemCount=mAdapter.getCount();
  }
  mIsAttached=true;
}","@Override protected void onAttachedToWindow(){
  super.onAttachedToWindow();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.addOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null && !mGlobalLayoutListenerAddedFilter) {
    treeObserver.addOnGlobalLayoutListener(this);
  }
  if (mAdapter != null && mDataSetObserver == null) {
    mDataSetObserver=new AdapterDataSetObserver();
    mAdapter.registerDataSetObserver(mDataSetObserver);
    mDataChanged=true;
    mOldItemCount=mItemCount;
    mItemCount=mAdapter.getCount();
  }
}"
1275,"@Override protected void onFocusChanged(boolean gainFocus,int direction,Rect previouslyFocusedRect){
  super.onFocusChanged(gainFocus,direction,previouslyFocusedRect);
  if (gainFocus && mSelectedPosition < 0 && !isInTouchMode()) {
    if (!mIsAttached && mAdapter != null) {
      mDataChanged=true;
      mOldItemCount=mItemCount;
      mItemCount=mAdapter.getCount();
    }
    resurrectSelection();
  }
}","@Override protected void onFocusChanged(boolean gainFocus,int direction,Rect previouslyFocusedRect){
  super.onFocusChanged(gainFocus,direction,previouslyFocusedRect);
  if (gainFocus && mSelectedPosition < 0 && !isInTouchMode()) {
    if (!isAttachedToWindow() && mAdapter != null) {
      mDataChanged=true;
      mOldItemCount=mItemCount;
      mItemCount=mAdapter.getCount();
    }
    resurrectSelection();
  }
}"
1276,"private void onTouchUp(MotionEvent ev){
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
    final int motionPosition=mMotionPosition;
  final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null) {
  if (mTouchMode != TOUCH_MODE_DOWN) {
    child.setPressed(false);
  }
  final float x=ev.getX();
  final boolean inList=x > mListPadding.left && x < getWidth() - mListPadding.right;
  if (inList && !child.hasFocusable()) {
    if (mPerformClick == null) {
      mPerformClick=new PerformClick();
    }
    final AbsListView.PerformClick performClick=mPerformClick;
    performClick.mClickMotionPosition=motionPosition;
    performClick.rememberWindowAttachCount();
    mResurrectToPosition=motionPosition;
    if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
      removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
      mLayoutMode=LAYOUT_NORMAL;
      if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
        mTouchMode=TOUCH_MODE_TAP;
        setSelectedPositionInt(mMotionPosition);
        layoutChildren();
        child.setPressed(true);
        positionSelector(mMotionPosition,child);
        setPressed(true);
        if (mSelector != null) {
          Drawable d=mSelector.getCurrent();
          if (d != null && d instanceof TransitionDrawable) {
            ((TransitionDrawable)d).resetTransition();
          }
        }
        if (mTouchModeReset != null) {
          removeCallbacks(mTouchModeReset);
        }
        mTouchModeReset=new Runnable(){
          @Override public void run(){
            mTouchModeReset=null;
            mTouchMode=TOUCH_MODE_REST;
            child.setPressed(false);
            setPressed(false);
            if (!mDataChanged) {
              performClick.run();
            }
          }
        }
;
        postDelayed(mTouchModeReset,ViewConfiguration.getPressedStateDuration());
      }
 else {
        mTouchMode=TOUCH_MODE_REST;
        updateSelectorState();
      }
      return;
    }
 else     if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
      performClick.run();
    }
  }
}
mTouchMode=TOUCH_MODE_REST;
updateSelectorState();
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)(velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
if (mFlingRunnable != null) {
mFlingRunnable.endFling();
}
if (mPositionScroller != null) {
mPositionScroller.stop();
}
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
removeCallbacks(mPendingCheckForLongPress);
recycleVelocityTracker();
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
if (mScrollStrictSpan != null) {
mScrollStrictSpan.finish();
mScrollStrictSpan=null;
}
}","private void onTouchUp(MotionEvent ev){
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
    final int motionPosition=mMotionPosition;
  final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null) {
  if (mTouchMode != TOUCH_MODE_DOWN) {
    child.setPressed(false);
  }
  final float x=ev.getX();
  final boolean inList=x > mListPadding.left && x < getWidth() - mListPadding.right;
  if (inList && !child.hasFocusable()) {
    if (mPerformClick == null) {
      mPerformClick=new PerformClick();
    }
    final AbsListView.PerformClick performClick=mPerformClick;
    performClick.mClickMotionPosition=motionPosition;
    performClick.rememberWindowAttachCount();
    mResurrectToPosition=motionPosition;
    if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
      removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
      mLayoutMode=LAYOUT_NORMAL;
      if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
        mTouchMode=TOUCH_MODE_TAP;
        setSelectedPositionInt(mMotionPosition);
        layoutChildren();
        child.setPressed(true);
        positionSelector(mMotionPosition,child);
        setPressed(true);
        if (mSelector != null) {
          Drawable d=mSelector.getCurrent();
          if (d != null && d instanceof TransitionDrawable) {
            ((TransitionDrawable)d).resetTransition();
          }
        }
        if (mTouchModeReset != null) {
          removeCallbacks(mTouchModeReset);
        }
        mTouchModeReset=new Runnable(){
          @Override public void run(){
            mTouchModeReset=null;
            mTouchMode=TOUCH_MODE_REST;
            child.setPressed(false);
            setPressed(false);
            if (!mDataChanged && isAttachedToWindow()) {
              performClick.run();
            }
          }
        }
;
        postDelayed(mTouchModeReset,ViewConfiguration.getPressedStateDuration());
      }
 else {
        mTouchMode=TOUCH_MODE_REST;
        updateSelectorState();
      }
      return;
    }
 else     if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
      performClick.run();
    }
  }
}
mTouchMode=TOUCH_MODE_REST;
updateSelectorState();
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)(velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
if (mFlingRunnable != null) {
mFlingRunnable.endFling();
}
if (mPositionScroller != null) {
mPositionScroller.stop();
}
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
removeCallbacks(mPendingCheckForLongPress);
recycleVelocityTracker();
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
if (mScrollStrictSpan != null) {
mScrollStrictSpan.finish();
mScrollStrictSpan=null;
}
}"
1277,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!mIsAttached) {
    return false;
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  initVelocityTrackerIfNotExists();
  mVelocityTracker.addMovement(ev);
  final int actionMasked=ev.getActionMasked();
switch (actionMasked) {
case MotionEvent.ACTION_DOWN:
{
      onTouchDown(ev);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    onTouchMove(ev);
    break;
  }
case MotionEvent.ACTION_UP:
{
  onTouchUp(ev);
  break;
}
case MotionEvent.ACTION_CANCEL:
{
onTouchCancel();
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
final int id=ev.getPointerId(index);
final int x=(int)ev.getX(index);
final int y=(int)ev.getY(index);
mMotionCorrection=0;
mActivePointerId=id;
mMotionX=x;
mMotionY=y;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!isAttachedToWindow()) {
    return false;
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  initVelocityTrackerIfNotExists();
  mVelocityTracker.addMovement(ev);
  final int actionMasked=ev.getActionMasked();
switch (actionMasked) {
case MotionEvent.ACTION_DOWN:
{
      onTouchDown(ev);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    onTouchMove(ev);
    break;
  }
case MotionEvent.ACTION_UP:
{
  onTouchUp(ev);
  break;
}
case MotionEvent.ACTION_CANCEL:
{
onTouchCancel();
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
final int id=ev.getPointerId(index);
final int x=(int)ev.getX(index);
final int y=(int)ev.getY(index);
mMotionCorrection=0;
mActivePointerId=id;
mMotionX=x;
mMotionY=y;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}"
1278,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  int action=ev.getAction();
  View v;
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!mIsAttached) {
    return false;
  }
  if (mFastScroller != null && mFastScroller.onInterceptTouchEvent(ev)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      int touchMode=mTouchMode;
      if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
        mMotionCorrection=0;
        return true;
      }
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      int motionPosition=findMotionRow(y);
      if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mTouchMode=TOUCH_MODE_DOWN;
        clearScrollingCache();
      }
      mLastY=Integer.MIN_VALUE;
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      if (touchMode == TOUCH_MODE_FLING) {
        return true;
      }
      break;
    }
case MotionEvent.ACTION_MOVE:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
      int pointerIndex=ev.findPointerIndex(mActivePointerId);
    if (pointerIndex == -1) {
      pointerIndex=0;
      mActivePointerId=ev.getPointerId(pointerIndex);
    }
  final int y=(int)ev.getY(pointerIndex);
initVelocityTrackerIfNotExists();
mVelocityTracker.addMovement(ev);
if (startScrollIfNeeded(y)) {
return true;
}
break;
}
break;
}
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
{
mTouchMode=TOUCH_MODE_REST;
mActivePointerId=INVALID_POINTER;
recycleVelocityTracker();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
break;
}
}
return false;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  int action=ev.getAction();
  View v;
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!isAttachedToWindow()) {
    return false;
  }
  if (mFastScroller != null && mFastScroller.onInterceptTouchEvent(ev)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      int touchMode=mTouchMode;
      if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
        mMotionCorrection=0;
        return true;
      }
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      int motionPosition=findMotionRow(y);
      if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mTouchMode=TOUCH_MODE_DOWN;
        clearScrollingCache();
      }
      mLastY=Integer.MIN_VALUE;
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      if (touchMode == TOUCH_MODE_FLING) {
        return true;
      }
      break;
    }
case MotionEvent.ACTION_MOVE:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
      int pointerIndex=ev.findPointerIndex(mActivePointerId);
    if (pointerIndex == -1) {
      pointerIndex=0;
      mActivePointerId=ev.getPointerId(pointerIndex);
    }
  final int y=(int)ev.getY(pointerIndex);
initVelocityTrackerIfNotExists();
mVelocityTracker.addMovement(ev);
if (startScrollIfNeeded(y)) {
return true;
}
break;
}
break;
}
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
{
mTouchMode=TOUCH_MODE_REST;
mActivePointerId=INVALID_POINTER;
recycleVelocityTracker();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
break;
}
}
return false;
}"
1279,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null && mDataSetObserver != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
  mIsAttached=false;
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null && mDataSetObserver != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
}"
1280,"private boolean commonKey(int keyCode,int count,KeyEvent event){
  if (mAdapter == null || !mIsAttached) {
    return false;
  }
  if (mDataChanged) {
    layoutChildren();
  }
  boolean handled=false;
  int action=event.getAction();
  if (action != KeyEvent.ACTION_UP) {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (event.hasNoModifiers()) {
        handled=resurrectSelectionIfNeeded();
        if (!handled) {
          while (count-- > 0) {
            if (arrowScroll(FOCUS_UP)) {
              handled=true;
            }
 else {
              break;
            }
          }
        }
      }
 else       if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
        handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (event.hasNoModifiers()) {
    handled=resurrectSelectionIfNeeded();
    if (!handled) {
      while (count-- > 0) {
        if (arrowScroll(FOCUS_DOWN)) {
          handled=true;
        }
 else {
          break;
        }
      }
    }
  }
 else   if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
    handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_DPAD_LEFT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_LEFT);
}
break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_RIGHT);
}
break;
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded();
if (!handled && event.getRepeatCount() == 0 && getChildCount() > 0) {
keyPressed();
handled=true;
}
}
break;
case KeyEvent.KEYCODE_SPACE:
if (mPopup == null || !mPopup.isShowing()) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
handled=true;
}
break;
case KeyEvent.KEYCODE_PAGE_UP:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_PAGE_DOWN:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_MOVE_HOME:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_MOVE_END:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_TAB:
if (false) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_UP);
}
}
break;
}
}
if (handled) {
return true;
}
if (sendToTextFilter(keyCode,count,event)) {
return true;
}
switch (action) {
case KeyEvent.ACTION_DOWN:
return super.onKeyDown(keyCode,event);
case KeyEvent.ACTION_UP:
return super.onKeyUp(keyCode,event);
case KeyEvent.ACTION_MULTIPLE:
return super.onKeyMultiple(keyCode,count,event);
default :
return false;
}
}","private boolean commonKey(int keyCode,int count,KeyEvent event){
  if (mAdapter == null || !isAttachedToWindow()) {
    return false;
  }
  if (mDataChanged) {
    layoutChildren();
  }
  boolean handled=false;
  int action=event.getAction();
  if (action != KeyEvent.ACTION_UP) {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (event.hasNoModifiers()) {
        handled=resurrectSelectionIfNeeded();
        if (!handled) {
          while (count-- > 0) {
            if (arrowScroll(FOCUS_UP)) {
              handled=true;
            }
 else {
              break;
            }
          }
        }
      }
 else       if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
        handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (event.hasNoModifiers()) {
    handled=resurrectSelectionIfNeeded();
    if (!handled) {
      while (count-- > 0) {
        if (arrowScroll(FOCUS_DOWN)) {
          handled=true;
        }
 else {
          break;
        }
      }
    }
  }
 else   if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
    handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_DPAD_LEFT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_LEFT);
}
break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_RIGHT);
}
break;
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded();
if (!handled && event.getRepeatCount() == 0 && getChildCount() > 0) {
keyPressed();
handled=true;
}
}
break;
case KeyEvent.KEYCODE_SPACE:
if (mPopup == null || !mPopup.isShowing()) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
handled=true;
}
break;
case KeyEvent.KEYCODE_PAGE_UP:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_PAGE_DOWN:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_MOVE_HOME:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_MOVE_END:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_TAB:
if (false) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_UP);
}
}
break;
}
}
if (handled) {
return true;
}
if (sendToTextFilter(keyCode,count,event)) {
return true;
}
switch (action) {
case KeyEvent.ACTION_DOWN:
return super.onKeyDown(keyCode,event);
case KeyEvent.ACTION_UP:
return super.onKeyUp(keyCode,event);
case KeyEvent.ACTION_MULTIPLE:
return super.onKeyMultiple(keyCode,count,event);
default :
return false;
}
}"
1281,"/** 
 * The same as   {@link #flattenToString()}, but abbreviates the class name if it is a suffix of the package.  The result can still be used with   {@link #unflattenFromString(String)}.
 * @return Returns a new String holding the package and class names.  Thisis represented as the package name, concatenated with a '/' and then the class name.
 * @see #unflattenFromString(String)
 */
public String flattenToShortString(){
  return mPackage + ""String_Node_Str"" + getShortClassName();
}","/** 
 * The same as   {@link #flattenToString()}, but abbreviates the class name if it is a suffix of the package.  The result can still be used with   {@link #unflattenFromString(String)}.
 * @return Returns a new String holding the package and class names.  Thisis represented as the package name, concatenated with a '/' and then the class name.
 * @see #unflattenFromString(String)
 */
public String flattenToShortString(){
  StringBuilder sb=new StringBuilder(mPackage.length() + mClass.length());
  appendShortString(sb,mPackage,mClass);
  return sb.toString();
}"
1282,"public String toString(){
  return ""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ service.info.name+ ""String_Node_Str"";
}","public String toString(){
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(' ');
  service.appendComponentShortName(sb);
  sb.append('}');
  return sb.toString();
}"
1283,"public String toString(){
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  return ""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ ci.name+ ""String_Node_Str""+ priority+ ""String_Node_Str""+ preferredOrder+ ""String_Node_Str""+ Integer.toHexString(match)+ ""String_Node_Str"";
}","public String toString(){
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(' ');
  ComponentName.appendShortString(sb,ci.packageName,ci.name);
  if (priority != 0) {
    sb.append(""String_Node_Str"");
    sb.append(priority);
  }
  if (preferredOrder != 0) {
    sb.append(""String_Node_Str"");
    sb.append(preferredOrder);
  }
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(match));
  sb.append('}');
  return sb.toString();
}"
1284,"public ResolveListAdapter(Context context,Intent intent,Intent[] initialIntents,List<ResolveInfo> rList,int launchedFromUid){
  mIntent=new Intent(intent);
  mIntent.setComponent(null);
  mInitialIntents=initialIntents;
  mBaseResolveList=rList;
  mLaunchedFromUid=launchedFromUid;
  mInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mList=new ArrayList<DisplayResolveInfo>();
  rebuildList();
}","public ResolveListAdapter(Context context,Intent intent,Intent[] initialIntents,List<ResolveInfo> rList,int launchedFromUid){
  mIntent=new Intent(intent);
  mInitialIntents=initialIntents;
  mBaseResolveList=rList;
  mLaunchedFromUid=launchedFromUid;
  mInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mList=new ArrayList<DisplayResolveInfo>();
  rebuildList();
}"
1285,"private void rebuildList(){
  List<ResolveInfo> currentResolveList;
  try {
    mLastChosen=AppGlobals.getPackageManager().getLastChosenActivity(mIntent,mIntent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY);
  }
 catch (  RemoteException re) {
    Log.d(TAG,""String_Node_Str"" + re);
  }
  mList.clear();
  if (mBaseResolveList != null) {
    currentResolveList=mBaseResolveList;
  }
 else {
    currentResolveList=mPm.queryIntentActivities(mIntent,PackageManager.MATCH_DEFAULT_ONLY | (mAlwaysUseOption ? PackageManager.GET_RESOLVED_FILTER : 0));
    if (currentResolveList != null) {
      for (int i=currentResolveList.size() - 1; i >= 0; i--) {
        ActivityInfo ai=currentResolveList.get(i).activityInfo;
        int granted=ActivityManager.checkComponentPermission(ai.permission,mLaunchedFromUid,ai.applicationInfo.uid,ai.exported);
        if (granted != PackageManager.PERMISSION_GRANTED) {
          currentResolveList.remove(i);
        }
      }
    }
  }
  int N;
  if ((currentResolveList != null) && ((N=currentResolveList.size()) > 0)) {
    ResolveInfo r0=currentResolveList.get(0);
    for (int i=1; i < N; i++) {
      ResolveInfo ri=currentResolveList.get(i);
      if (DEBUG)       Log.v(""String_Node_Str"",r0.activityInfo.name + ""String_Node_Str"" + r0.priority+ ""String_Node_Str""+ r0.isDefault+ ""String_Node_Str""+ ri.activityInfo.name+ ""String_Node_Str""+ ri.priority+ ""String_Node_Str""+ ri.isDefault);
      if (r0.priority != ri.priority || r0.isDefault != ri.isDefault) {
        while (i < N) {
          currentResolveList.remove(i);
          N--;
        }
      }
    }
    if (N > 1) {
      ResolveInfo.DisplayNameComparator rComparator=new ResolveInfo.DisplayNameComparator(mPm);
      Collections.sort(currentResolveList,rComparator);
    }
    if (mInitialIntents != null) {
      for (int i=0; i < mInitialIntents.length; i++) {
        Intent ii=mInitialIntents[i];
        if (ii == null) {
          continue;
        }
        ActivityInfo ai=ii.resolveActivityInfo(getPackageManager(),0);
        if (ai == null) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + ii);
          continue;
        }
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        if (ii instanceof LabeledIntent) {
          LabeledIntent li=(LabeledIntent)ii;
          ri.resolvePackageName=li.getSourcePackage();
          ri.labelRes=li.getLabelResource();
          ri.nonLocalizedLabel=li.getNonLocalizedLabel();
          ri.icon=li.getIconResource();
        }
        mList.add(new DisplayResolveInfo(ri,ri.loadLabel(getPackageManager()),null,ii));
      }
    }
    r0=currentResolveList.get(0);
    int start=0;
    CharSequence r0Label=r0.loadLabel(mPm);
    mShowExtended=false;
    for (int i=1; i < N; i++) {
      if (r0Label == null) {
        r0Label=r0.activityInfo.packageName;
      }
      ResolveInfo ri=currentResolveList.get(i);
      CharSequence riLabel=ri.loadLabel(mPm);
      if (riLabel == null) {
        riLabel=ri.activityInfo.packageName;
      }
      if (riLabel.equals(r0Label)) {
        continue;
      }
      processGroup(currentResolveList,start,(i - 1),r0,r0Label);
      r0=ri;
      r0Label=riLabel;
      start=i;
    }
    processGroup(currentResolveList,start,(N - 1),r0,r0Label);
  }
}","private void rebuildList(){
  List<ResolveInfo> currentResolveList;
  try {
    mLastChosen=AppGlobals.getPackageManager().getLastChosenActivity(mIntent,mIntent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY);
  }
 catch (  RemoteException re) {
    Log.d(TAG,""String_Node_Str"" + re);
  }
  mList.clear();
  if (mBaseResolveList != null) {
    currentResolveList=mBaseResolveList;
    mOrigResolveList=null;
  }
 else {
    currentResolveList=mOrigResolveList=mPm.queryIntentActivities(mIntent,PackageManager.MATCH_DEFAULT_ONLY | (mAlwaysUseOption ? PackageManager.GET_RESOLVED_FILTER : 0));
    if (currentResolveList != null) {
      for (int i=currentResolveList.size() - 1; i >= 0; i--) {
        ActivityInfo ai=currentResolveList.get(i).activityInfo;
        int granted=ActivityManager.checkComponentPermission(ai.permission,mLaunchedFromUid,ai.applicationInfo.uid,ai.exported);
        if (granted != PackageManager.PERMISSION_GRANTED) {
          if (mOrigResolveList == currentResolveList) {
            mOrigResolveList=new ArrayList<ResolveInfo>(mOrigResolveList);
          }
          currentResolveList.remove(i);
        }
      }
    }
  }
  int N;
  if ((currentResolveList != null) && ((N=currentResolveList.size()) > 0)) {
    ResolveInfo r0=currentResolveList.get(0);
    for (int i=1; i < N; i++) {
      ResolveInfo ri=currentResolveList.get(i);
      if (DEBUG)       Log.v(""String_Node_Str"",r0.activityInfo.name + ""String_Node_Str"" + r0.priority+ ""String_Node_Str""+ r0.isDefault+ ""String_Node_Str""+ ri.activityInfo.name+ ""String_Node_Str""+ ri.priority+ ""String_Node_Str""+ ri.isDefault);
      if (r0.priority != ri.priority || r0.isDefault != ri.isDefault) {
        while (i < N) {
          if (mOrigResolveList == currentResolveList) {
            mOrigResolveList=new ArrayList<ResolveInfo>(mOrigResolveList);
          }
          currentResolveList.remove(i);
          N--;
        }
      }
    }
    if (N > 1) {
      ResolveInfo.DisplayNameComparator rComparator=new ResolveInfo.DisplayNameComparator(mPm);
      Collections.sort(currentResolveList,rComparator);
    }
    if (mInitialIntents != null) {
      for (int i=0; i < mInitialIntents.length; i++) {
        Intent ii=mInitialIntents[i];
        if (ii == null) {
          continue;
        }
        ActivityInfo ai=ii.resolveActivityInfo(getPackageManager(),0);
        if (ai == null) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + ii);
          continue;
        }
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        if (ii instanceof LabeledIntent) {
          LabeledIntent li=(LabeledIntent)ii;
          ri.resolvePackageName=li.getSourcePackage();
          ri.labelRes=li.getLabelResource();
          ri.nonLocalizedLabel=li.getNonLocalizedLabel();
          ri.icon=li.getIconResource();
        }
        mList.add(new DisplayResolveInfo(ri,ri.loadLabel(getPackageManager()),null,ii));
      }
    }
    r0=currentResolveList.get(0);
    int start=0;
    CharSequence r0Label=r0.loadLabel(mPm);
    mShowExtended=false;
    for (int i=1; i < N; i++) {
      if (r0Label == null) {
        r0Label=r0.activityInfo.packageName;
      }
      ResolveInfo ri=currentResolveList.get(i);
      CharSequence riLabel=ri.loadLabel(mPm);
      if (riLabel == null) {
        riLabel=ri.activityInfo.packageName;
      }
      if (riLabel.equals(r0Label)) {
        continue;
      }
      processGroup(currentResolveList,start,(i - 1),r0,r0Label);
      r0=ri;
      r0Label=riLabel;
      start=i;
    }
    processGroup(currentResolveList,start,(N - 1),r0,r0Label);
  }
}"
1286,"protected void onCreate(Bundle savedInstanceState,Intent intent,CharSequence title,Intent[] initialIntents,List<ResolveInfo> rList,boolean alwaysUseOption){
  setTheme(R.style.Theme_DeviceDefault_Light_Dialog_Alert);
  super.onCreate(savedInstanceState);
  try {
    mLaunchedFromUid=ActivityManagerNative.getDefault().getLaunchedFromUid(getActivityToken());
  }
 catch (  RemoteException e) {
    mLaunchedFromUid=-1;
  }
  mPm=getPackageManager();
  mAlwaysUseOption=alwaysUseOption;
  mMaxColumns=getResources().getInteger(R.integer.config_maxResolverActivityColumns);
  intent.setComponent(null);
  AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=title;
  mPackageMonitor.register(this,getMainLooper(),false);
  mRegistered=true;
  final ActivityManager am=(ActivityManager)getSystemService(ACTIVITY_SERVICE);
  mIconDpi=am.getLauncherLargeIconDensity();
  mIconSize=am.getLauncherLargeIconSize();
  mAdapter=new ResolveListAdapter(this,intent,initialIntents,rList,mLaunchedFromUid);
  int count=mAdapter.getCount();
  if (mLaunchedFromUid < 0 || UserHandle.isIsolated(mLaunchedFromUid)) {
    finish();
    return;
  }
 else   if (count > 1) {
    ap.mView=getLayoutInflater().inflate(R.layout.resolver_list,null);
    mListView=(ListView)ap.mView.findViewById(R.id.resolver_list);
    mListView.setAdapter(mAdapter);
    mListView.setOnItemClickListener(this);
    mListView.setOnItemLongClickListener(new ItemLongClickListener());
    if (alwaysUseOption) {
      mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    }
  }
 else   if (count == 1) {
    startActivity(mAdapter.intentForPosition(0));
    mPackageMonitor.unregister();
    mRegistered=false;
    finish();
    return;
  }
 else {
    ap.mMessage=getResources().getText(R.string.noApplications);
  }
  setupAlert();
  if (alwaysUseOption) {
    final ViewGroup buttonLayout=(ViewGroup)findViewById(R.id.button_bar);
    if (buttonLayout != null) {
      buttonLayout.setVisibility(View.VISIBLE);
      mAlwaysButton=(Button)buttonLayout.findViewById(R.id.button_always);
      mOnceButton=(Button)buttonLayout.findViewById(R.id.button_once);
    }
 else {
      mAlwaysUseOption=false;
    }
  }
  final int initialHighlight=mAdapter.getInitialHighlight();
  if (initialHighlight >= 0) {
    mListView.setItemChecked(initialHighlight,true);
    onItemClick(null,null,initialHighlight,0);
  }
}","protected void onCreate(Bundle savedInstanceState,Intent intent,CharSequence title,Intent[] initialIntents,List<ResolveInfo> rList,boolean alwaysUseOption){
  setTheme(R.style.Theme_DeviceDefault_Light_Dialog_Alert);
  super.onCreate(savedInstanceState);
  try {
    mLaunchedFromUid=ActivityManagerNative.getDefault().getLaunchedFromUid(getActivityToken());
  }
 catch (  RemoteException e) {
    mLaunchedFromUid=-1;
  }
  mPm=getPackageManager();
  mAlwaysUseOption=alwaysUseOption;
  mMaxColumns=getResources().getInteger(R.integer.config_maxResolverActivityColumns);
  AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=title;
  mPackageMonitor.register(this,getMainLooper(),false);
  mRegistered=true;
  final ActivityManager am=(ActivityManager)getSystemService(ACTIVITY_SERVICE);
  mIconDpi=am.getLauncherLargeIconDensity();
  mIconSize=am.getLauncherLargeIconSize();
  mAdapter=new ResolveListAdapter(this,intent,initialIntents,rList,mLaunchedFromUid);
  int count=mAdapter.getCount();
  if (mLaunchedFromUid < 0 || UserHandle.isIsolated(mLaunchedFromUid)) {
    finish();
    return;
  }
 else   if (count > 1) {
    ap.mView=getLayoutInflater().inflate(R.layout.resolver_list,null);
    mListView=(ListView)ap.mView.findViewById(R.id.resolver_list);
    mListView.setAdapter(mAdapter);
    mListView.setOnItemClickListener(this);
    mListView.setOnItemLongClickListener(new ItemLongClickListener());
    if (alwaysUseOption) {
      mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    }
  }
 else   if (count == 1) {
    startActivity(mAdapter.intentForPosition(0));
    mPackageMonitor.unregister();
    mRegistered=false;
    finish();
    return;
  }
 else {
    ap.mMessage=getResources().getText(R.string.noApplications);
  }
  setupAlert();
  if (alwaysUseOption) {
    final ViewGroup buttonLayout=(ViewGroup)findViewById(R.id.button_bar);
    if (buttonLayout != null) {
      buttonLayout.setVisibility(View.VISIBLE);
      mAlwaysButton=(Button)buttonLayout.findViewById(R.id.button_always);
      mOnceButton=(Button)buttonLayout.findViewById(R.id.button_once);
    }
 else {
      mAlwaysUseOption=false;
    }
  }
  final int initialHighlight=mAdapter.getInitialHighlight();
  if (initialHighlight >= 0) {
    mListView.setItemChecked(initialHighlight,true);
    onItemClick(null,null,initialHighlight,0);
  }
}"
1287,"private Intent makeMyIntent(){
  Intent intent=new Intent(getIntent());
  intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
  return intent;
}","private Intent makeMyIntent(){
  Intent intent=new Intent(getIntent());
  intent.setComponent(null);
  intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
  return intent;
}"
1288,"protected void onIntentSelected(ResolveInfo ri,Intent intent,boolean alwaysCheck){
  if (mAlwaysUseOption) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<PatternMatcher> pIt=ri.filter.schemeSpecificPartsIterator();
        if (pIt != null) {
          String ssp=data.getSchemeSpecificPart();
          while (ssp != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(ssp)) {
              filter.addDataSchemeSpecificPart(p.getPath(),p.getType());
              break;
            }
          }
        }
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      if (alwaysCheck) {
        getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
      }
 else {
        try {
          AppGlobals.getPackageManager().setLastChosenActivity(intent,intent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY,filter,bestMatch,intent.getComponent());
        }
 catch (        RemoteException re) {
          Log.d(TAG,""String_Node_Str"" + re);
        }
      }
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
}","protected void onIntentSelected(ResolveInfo ri,Intent intent,boolean alwaysCheck){
  if (mAlwaysUseOption && mAdapter.mOrigResolveList != null) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<PatternMatcher> pIt=ri.filter.schemeSpecificPartsIterator();
        if (pIt != null) {
          String ssp=data.getSchemeSpecificPart();
          while (ssp != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(ssp)) {
              filter.addDataSchemeSpecificPart(p.getPath(),p.getType());
              break;
            }
          }
        }
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mOrigResolveList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mOrigResolveList.get(i);
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      if (alwaysCheck) {
        getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
      }
 else {
        try {
          AppGlobals.getPackageManager().setLastChosenActivity(intent,intent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY,filter,bestMatch,intent.getComponent());
        }
 catch (        RemoteException re) {
          Log.d(TAG,""String_Node_Str"" + re);
        }
      }
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
}"
1289,"@Override protected void onAttachedToWindow(){
  super.onAttachedToWindow();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.addOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null && !mGlobalLayoutListenerAddedFilter) {
    treeObserver.addOnGlobalLayoutListener(this);
  }
  if (mAdapter != null && mDataSetObserver == null) {
    mDataSetObserver=new AdapterDataSetObserver();
    mAdapter.registerDataSetObserver(mDataSetObserver);
    mDataChanged=true;
    mOldItemCount=mItemCount;
    mItemCount=mAdapter.getCount();
  }
  mIsAttached=true;
}","@Override protected void onAttachedToWindow(){
  super.onAttachedToWindow();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.addOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null && !mGlobalLayoutListenerAddedFilter) {
    treeObserver.addOnGlobalLayoutListener(this);
  }
  if (mAdapter != null && mDataSetObserver == null) {
    mDataSetObserver=new AdapterDataSetObserver();
    mAdapter.registerDataSetObserver(mDataSetObserver);
    mDataChanged=true;
    mOldItemCount=mItemCount;
    mItemCount=mAdapter.getCount();
  }
}"
1290,"@Override protected void onFocusChanged(boolean gainFocus,int direction,Rect previouslyFocusedRect){
  super.onFocusChanged(gainFocus,direction,previouslyFocusedRect);
  if (gainFocus && mSelectedPosition < 0 && !isInTouchMode()) {
    if (!mIsAttached && mAdapter != null) {
      mDataChanged=true;
      mOldItemCount=mItemCount;
      mItemCount=mAdapter.getCount();
    }
    resurrectSelection();
  }
}","@Override protected void onFocusChanged(boolean gainFocus,int direction,Rect previouslyFocusedRect){
  super.onFocusChanged(gainFocus,direction,previouslyFocusedRect);
  if (gainFocus && mSelectedPosition < 0 && !isInTouchMode()) {
    if (!isAttachedToWindow() && mAdapter != null) {
      mDataChanged=true;
      mOldItemCount=mItemCount;
      mItemCount=mAdapter.getCount();
    }
    resurrectSelection();
  }
}"
1291,"private void onTouchUp(MotionEvent ev){
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
    final int motionPosition=mMotionPosition;
  final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null) {
  if (mTouchMode != TOUCH_MODE_DOWN) {
    child.setPressed(false);
  }
  final float x=ev.getX();
  final boolean inList=x > mListPadding.left && x < getWidth() - mListPadding.right;
  if (inList && !child.hasFocusable()) {
    if (mPerformClick == null) {
      mPerformClick=new PerformClick();
    }
    final AbsListView.PerformClick performClick=mPerformClick;
    performClick.mClickMotionPosition=motionPosition;
    performClick.rememberWindowAttachCount();
    mResurrectToPosition=motionPosition;
    if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
      removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
      mLayoutMode=LAYOUT_NORMAL;
      if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
        mTouchMode=TOUCH_MODE_TAP;
        setSelectedPositionInt(mMotionPosition);
        layoutChildren();
        child.setPressed(true);
        positionSelector(mMotionPosition,child);
        setPressed(true);
        if (mSelector != null) {
          Drawable d=mSelector.getCurrent();
          if (d != null && d instanceof TransitionDrawable) {
            ((TransitionDrawable)d).resetTransition();
          }
        }
        if (mTouchModeReset != null) {
          removeCallbacks(mTouchModeReset);
        }
        mTouchModeReset=new Runnable(){
          @Override public void run(){
            mTouchModeReset=null;
            mTouchMode=TOUCH_MODE_REST;
            child.setPressed(false);
            setPressed(false);
            if (!mDataChanged) {
              performClick.run();
            }
          }
        }
;
        postDelayed(mTouchModeReset,ViewConfiguration.getPressedStateDuration());
      }
 else {
        mTouchMode=TOUCH_MODE_REST;
        updateSelectorState();
      }
      return;
    }
 else     if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
      performClick.run();
    }
  }
}
mTouchMode=TOUCH_MODE_REST;
updateSelectorState();
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)(velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
if (mFlingRunnable != null) {
mFlingRunnable.endFling();
}
if (mPositionScroller != null) {
mPositionScroller.stop();
}
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
removeCallbacks(mPendingCheckForLongPress);
recycleVelocityTracker();
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
if (mScrollStrictSpan != null) {
mScrollStrictSpan.finish();
mScrollStrictSpan=null;
}
}","private void onTouchUp(MotionEvent ev){
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
    final int motionPosition=mMotionPosition;
  final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null) {
  if (mTouchMode != TOUCH_MODE_DOWN) {
    child.setPressed(false);
  }
  final float x=ev.getX();
  final boolean inList=x > mListPadding.left && x < getWidth() - mListPadding.right;
  if (inList && !child.hasFocusable()) {
    if (mPerformClick == null) {
      mPerformClick=new PerformClick();
    }
    final AbsListView.PerformClick performClick=mPerformClick;
    performClick.mClickMotionPosition=motionPosition;
    performClick.rememberWindowAttachCount();
    mResurrectToPosition=motionPosition;
    if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
      removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
      mLayoutMode=LAYOUT_NORMAL;
      if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
        mTouchMode=TOUCH_MODE_TAP;
        setSelectedPositionInt(mMotionPosition);
        layoutChildren();
        child.setPressed(true);
        positionSelector(mMotionPosition,child);
        setPressed(true);
        if (mSelector != null) {
          Drawable d=mSelector.getCurrent();
          if (d != null && d instanceof TransitionDrawable) {
            ((TransitionDrawable)d).resetTransition();
          }
        }
        if (mTouchModeReset != null) {
          removeCallbacks(mTouchModeReset);
        }
        mTouchModeReset=new Runnable(){
          @Override public void run(){
            mTouchModeReset=null;
            mTouchMode=TOUCH_MODE_REST;
            child.setPressed(false);
            setPressed(false);
            if (!mDataChanged && isAttachedToWindow()) {
              performClick.run();
            }
          }
        }
;
        postDelayed(mTouchModeReset,ViewConfiguration.getPressedStateDuration());
      }
 else {
        mTouchMode=TOUCH_MODE_REST;
        updateSelectorState();
      }
      return;
    }
 else     if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
      performClick.run();
    }
  }
}
mTouchMode=TOUCH_MODE_REST;
updateSelectorState();
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)(velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
if (mFlingRunnable != null) {
mFlingRunnable.endFling();
}
if (mPositionScroller != null) {
mPositionScroller.stop();
}
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
removeCallbacks(mPendingCheckForLongPress);
recycleVelocityTracker();
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
if (mScrollStrictSpan != null) {
mScrollStrictSpan.finish();
mScrollStrictSpan=null;
}
}"
1292,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!mIsAttached) {
    return false;
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  initVelocityTrackerIfNotExists();
  mVelocityTracker.addMovement(ev);
  final int actionMasked=ev.getActionMasked();
switch (actionMasked) {
case MotionEvent.ACTION_DOWN:
{
      onTouchDown(ev);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    onTouchMove(ev);
    break;
  }
case MotionEvent.ACTION_UP:
{
  onTouchUp(ev);
  break;
}
case MotionEvent.ACTION_CANCEL:
{
onTouchCancel();
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
final int id=ev.getPointerId(index);
final int x=(int)ev.getX(index);
final int y=(int)ev.getY(index);
mMotionCorrection=0;
mActivePointerId=id;
mMotionX=x;
mMotionY=y;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!isAttachedToWindow()) {
    return false;
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  initVelocityTrackerIfNotExists();
  mVelocityTracker.addMovement(ev);
  final int actionMasked=ev.getActionMasked();
switch (actionMasked) {
case MotionEvent.ACTION_DOWN:
{
      onTouchDown(ev);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    onTouchMove(ev);
    break;
  }
case MotionEvent.ACTION_UP:
{
  onTouchUp(ev);
  break;
}
case MotionEvent.ACTION_CANCEL:
{
onTouchCancel();
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
final int id=ev.getPointerId(index);
final int x=(int)ev.getX(index);
final int y=(int)ev.getY(index);
mMotionCorrection=0;
mActivePointerId=id;
mMotionX=x;
mMotionY=y;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
final View child=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=child.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}"
1293,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  int action=ev.getAction();
  View v;
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!mIsAttached) {
    return false;
  }
  if (mFastScroller != null && mFastScroller.onInterceptTouchEvent(ev)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      int touchMode=mTouchMode;
      if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
        mMotionCorrection=0;
        return true;
      }
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      int motionPosition=findMotionRow(y);
      if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mTouchMode=TOUCH_MODE_DOWN;
        clearScrollingCache();
      }
      mLastY=Integer.MIN_VALUE;
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      if (touchMode == TOUCH_MODE_FLING) {
        return true;
      }
      break;
    }
case MotionEvent.ACTION_MOVE:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
      int pointerIndex=ev.findPointerIndex(mActivePointerId);
    if (pointerIndex == -1) {
      pointerIndex=0;
      mActivePointerId=ev.getPointerId(pointerIndex);
    }
  final int y=(int)ev.getY(pointerIndex);
initVelocityTrackerIfNotExists();
mVelocityTracker.addMovement(ev);
if (startScrollIfNeeded(y)) {
return true;
}
break;
}
break;
}
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
{
mTouchMode=TOUCH_MODE_REST;
mActivePointerId=INVALID_POINTER;
recycleVelocityTracker();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
break;
}
}
return false;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  int action=ev.getAction();
  View v;
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (!isAttachedToWindow()) {
    return false;
  }
  if (mFastScroller != null && mFastScroller.onInterceptTouchEvent(ev)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      int touchMode=mTouchMode;
      if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
        mMotionCorrection=0;
        return true;
      }
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      int motionPosition=findMotionRow(y);
      if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mTouchMode=TOUCH_MODE_DOWN;
        clearScrollingCache();
      }
      mLastY=Integer.MIN_VALUE;
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      if (touchMode == TOUCH_MODE_FLING) {
        return true;
      }
      break;
    }
case MotionEvent.ACTION_MOVE:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
      int pointerIndex=ev.findPointerIndex(mActivePointerId);
    if (pointerIndex == -1) {
      pointerIndex=0;
      mActivePointerId=ev.getPointerId(pointerIndex);
    }
  final int y=(int)ev.getY(pointerIndex);
initVelocityTrackerIfNotExists();
mVelocityTracker.addMovement(ev);
if (startScrollIfNeeded(y)) {
return true;
}
break;
}
break;
}
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
{
mTouchMode=TOUCH_MODE_REST;
mActivePointerId=INVALID_POINTER;
recycleVelocityTracker();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
break;
}
}
return false;
}"
1294,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null && mDataSetObserver != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
  mIsAttached=false;
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null && mDataSetObserver != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
}"
1295,"private boolean commonKey(int keyCode,int count,KeyEvent event){
  if (mAdapter == null || !mIsAttached) {
    return false;
  }
  if (mDataChanged) {
    layoutChildren();
  }
  boolean handled=false;
  int action=event.getAction();
  if (action != KeyEvent.ACTION_UP) {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (event.hasNoModifiers()) {
        handled=resurrectSelectionIfNeeded();
        if (!handled) {
          while (count-- > 0) {
            if (arrowScroll(FOCUS_UP)) {
              handled=true;
            }
 else {
              break;
            }
          }
        }
      }
 else       if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
        handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (event.hasNoModifiers()) {
    handled=resurrectSelectionIfNeeded();
    if (!handled) {
      while (count-- > 0) {
        if (arrowScroll(FOCUS_DOWN)) {
          handled=true;
        }
 else {
          break;
        }
      }
    }
  }
 else   if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
    handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_DPAD_LEFT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_LEFT);
}
break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_RIGHT);
}
break;
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded();
if (!handled && event.getRepeatCount() == 0 && getChildCount() > 0) {
keyPressed();
handled=true;
}
}
break;
case KeyEvent.KEYCODE_SPACE:
if (mPopup == null || !mPopup.isShowing()) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
handled=true;
}
break;
case KeyEvent.KEYCODE_PAGE_UP:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_PAGE_DOWN:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_MOVE_HOME:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_MOVE_END:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_TAB:
if (false) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_UP);
}
}
break;
}
}
if (handled) {
return true;
}
if (sendToTextFilter(keyCode,count,event)) {
return true;
}
switch (action) {
case KeyEvent.ACTION_DOWN:
return super.onKeyDown(keyCode,event);
case KeyEvent.ACTION_UP:
return super.onKeyUp(keyCode,event);
case KeyEvent.ACTION_MULTIPLE:
return super.onKeyMultiple(keyCode,count,event);
default :
return false;
}
}","private boolean commonKey(int keyCode,int count,KeyEvent event){
  if (mAdapter == null || !isAttachedToWindow()) {
    return false;
  }
  if (mDataChanged) {
    layoutChildren();
  }
  boolean handled=false;
  int action=event.getAction();
  if (action != KeyEvent.ACTION_UP) {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (event.hasNoModifiers()) {
        handled=resurrectSelectionIfNeeded();
        if (!handled) {
          while (count-- > 0) {
            if (arrowScroll(FOCUS_UP)) {
              handled=true;
            }
 else {
              break;
            }
          }
        }
      }
 else       if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
        handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (event.hasNoModifiers()) {
    handled=resurrectSelectionIfNeeded();
    if (!handled) {
      while (count-- > 0) {
        if (arrowScroll(FOCUS_DOWN)) {
          handled=true;
        }
 else {
          break;
        }
      }
    }
  }
 else   if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
    handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_DPAD_LEFT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_LEFT);
}
break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
if (event.hasNoModifiers()) {
handled=handleHorizontalFocusWithinListItem(View.FOCUS_RIGHT);
}
break;
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded();
if (!handled && event.getRepeatCount() == 0 && getChildCount() > 0) {
keyPressed();
handled=true;
}
}
break;
case KeyEvent.KEYCODE_SPACE:
if (mPopup == null || !mPopup.isShowing()) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
handled=true;
}
break;
case KeyEvent.KEYCODE_PAGE_UP:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_UP);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_PAGE_DOWN:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || pageScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_MOVE_HOME:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_UP);
}
break;
case KeyEvent.KEYCODE_MOVE_END:
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || fullScroll(FOCUS_DOWN);
}
break;
case KeyEvent.KEYCODE_TAB:
if (false) {
if (event.hasNoModifiers()) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_DOWN);
}
 else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
handled=resurrectSelectionIfNeeded() || arrowScroll(FOCUS_UP);
}
}
break;
}
}
if (handled) {
return true;
}
if (sendToTextFilter(keyCode,count,event)) {
return true;
}
switch (action) {
case KeyEvent.ACTION_DOWN:
return super.onKeyDown(keyCode,event);
case KeyEvent.ACTION_UP:
return super.onKeyUp(keyCode,event);
case KeyEvent.ACTION_MULTIPLE:
return super.onKeyMultiple(keyCode,count,event);
default :
return false;
}
}"
1296,"/** 
 * The same as   {@link #flattenToString()}, but abbreviates the class name if it is a suffix of the package.  The result can still be used with   {@link #unflattenFromString(String)}.
 * @return Returns a new String holding the package and class names.  Thisis represented as the package name, concatenated with a '/' and then the class name.
 * @see #unflattenFromString(String)
 */
public String flattenToShortString(){
  return mPackage + ""String_Node_Str"" + getShortClassName();
}","/** 
 * The same as   {@link #flattenToString()}, but abbreviates the class name if it is a suffix of the package.  The result can still be used with   {@link #unflattenFromString(String)}.
 * @return Returns a new String holding the package and class names.  Thisis represented as the package name, concatenated with a '/' and then the class name.
 * @see #unflattenFromString(String)
 */
public String flattenToShortString(){
  StringBuilder sb=new StringBuilder(mPackage.length() + mClass.length());
  appendShortString(sb,mPackage,mClass);
  return sb.toString();
}"
1297,"public String toString(){
  return ""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ service.info.name+ ""String_Node_Str"";
}","public String toString(){
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(' ');
  service.appendComponentShortName(sb);
  sb.append('}');
  return sb.toString();
}"
1298,"public String toString(){
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  return ""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ ci.name+ ""String_Node_Str""+ priority+ ""String_Node_Str""+ preferredOrder+ ""String_Node_Str""+ Integer.toHexString(match)+ ""String_Node_Str"";
}","public String toString(){
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(' ');
  ComponentName.appendShortString(sb,ci.packageName,ci.name);
  if (priority != 0) {
    sb.append(""String_Node_Str"");
    sb.append(priority);
  }
  if (preferredOrder != 0) {
    sb.append(""String_Node_Str"");
    sb.append(preferredOrder);
  }
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(match));
  sb.append('}');
  return sb.toString();
}"
1299,"public ResolveListAdapter(Context context,Intent intent,Intent[] initialIntents,List<ResolveInfo> rList,int launchedFromUid){
  mIntent=new Intent(intent);
  mIntent.setComponent(null);
  mInitialIntents=initialIntents;
  mBaseResolveList=rList;
  mLaunchedFromUid=launchedFromUid;
  mInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mList=new ArrayList<DisplayResolveInfo>();
  rebuildList();
}","public ResolveListAdapter(Context context,Intent intent,Intent[] initialIntents,List<ResolveInfo> rList,int launchedFromUid){
  mIntent=new Intent(intent);
  mInitialIntents=initialIntents;
  mBaseResolveList=rList;
  mLaunchedFromUid=launchedFromUid;
  mInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mList=new ArrayList<DisplayResolveInfo>();
  rebuildList();
}"
1300,"private void rebuildList(){
  List<ResolveInfo> currentResolveList;
  try {
    mLastChosen=AppGlobals.getPackageManager().getLastChosenActivity(mIntent,mIntent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY);
  }
 catch (  RemoteException re) {
    Log.d(TAG,""String_Node_Str"" + re);
  }
  mList.clear();
  if (mBaseResolveList != null) {
    currentResolveList=mBaseResolveList;
  }
 else {
    currentResolveList=mPm.queryIntentActivities(mIntent,PackageManager.MATCH_DEFAULT_ONLY | (mAlwaysUseOption ? PackageManager.GET_RESOLVED_FILTER : 0));
    if (currentResolveList != null) {
      for (int i=currentResolveList.size() - 1; i >= 0; i--) {
        ActivityInfo ai=currentResolveList.get(i).activityInfo;
        int granted=ActivityManager.checkComponentPermission(ai.permission,mLaunchedFromUid,ai.applicationInfo.uid,ai.exported);
        if (granted != PackageManager.PERMISSION_GRANTED) {
          currentResolveList.remove(i);
        }
      }
    }
  }
  int N;
  if ((currentResolveList != null) && ((N=currentResolveList.size()) > 0)) {
    ResolveInfo r0=currentResolveList.get(0);
    for (int i=1; i < N; i++) {
      ResolveInfo ri=currentResolveList.get(i);
      if (DEBUG)       Log.v(""String_Node_Str"",r0.activityInfo.name + ""String_Node_Str"" + r0.priority+ ""String_Node_Str""+ r0.isDefault+ ""String_Node_Str""+ ri.activityInfo.name+ ""String_Node_Str""+ ri.priority+ ""String_Node_Str""+ ri.isDefault);
      if (r0.priority != ri.priority || r0.isDefault != ri.isDefault) {
        while (i < N) {
          currentResolveList.remove(i);
          N--;
        }
      }
    }
    if (N > 1) {
      ResolveInfo.DisplayNameComparator rComparator=new ResolveInfo.DisplayNameComparator(mPm);
      Collections.sort(currentResolveList,rComparator);
    }
    if (mInitialIntents != null) {
      for (int i=0; i < mInitialIntents.length; i++) {
        Intent ii=mInitialIntents[i];
        if (ii == null) {
          continue;
        }
        ActivityInfo ai=ii.resolveActivityInfo(getPackageManager(),0);
        if (ai == null) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + ii);
          continue;
        }
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        if (ii instanceof LabeledIntent) {
          LabeledIntent li=(LabeledIntent)ii;
          ri.resolvePackageName=li.getSourcePackage();
          ri.labelRes=li.getLabelResource();
          ri.nonLocalizedLabel=li.getNonLocalizedLabel();
          ri.icon=li.getIconResource();
        }
        mList.add(new DisplayResolveInfo(ri,ri.loadLabel(getPackageManager()),null,ii));
      }
    }
    r0=currentResolveList.get(0);
    int start=0;
    CharSequence r0Label=r0.loadLabel(mPm);
    mShowExtended=false;
    for (int i=1; i < N; i++) {
      if (r0Label == null) {
        r0Label=r0.activityInfo.packageName;
      }
      ResolveInfo ri=currentResolveList.get(i);
      CharSequence riLabel=ri.loadLabel(mPm);
      if (riLabel == null) {
        riLabel=ri.activityInfo.packageName;
      }
      if (riLabel.equals(r0Label)) {
        continue;
      }
      processGroup(currentResolveList,start,(i - 1),r0,r0Label);
      r0=ri;
      r0Label=riLabel;
      start=i;
    }
    processGroup(currentResolveList,start,(N - 1),r0,r0Label);
  }
}","private void rebuildList(){
  List<ResolveInfo> currentResolveList;
  try {
    mLastChosen=AppGlobals.getPackageManager().getLastChosenActivity(mIntent,mIntent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY);
  }
 catch (  RemoteException re) {
    Log.d(TAG,""String_Node_Str"" + re);
  }
  mList.clear();
  if (mBaseResolveList != null) {
    currentResolveList=mBaseResolveList;
    mOrigResolveList=null;
  }
 else {
    currentResolveList=mOrigResolveList=mPm.queryIntentActivities(mIntent,PackageManager.MATCH_DEFAULT_ONLY | (mAlwaysUseOption ? PackageManager.GET_RESOLVED_FILTER : 0));
    if (currentResolveList != null) {
      for (int i=currentResolveList.size() - 1; i >= 0; i--) {
        ActivityInfo ai=currentResolveList.get(i).activityInfo;
        int granted=ActivityManager.checkComponentPermission(ai.permission,mLaunchedFromUid,ai.applicationInfo.uid,ai.exported);
        if (granted != PackageManager.PERMISSION_GRANTED) {
          if (mOrigResolveList == currentResolveList) {
            mOrigResolveList=new ArrayList<ResolveInfo>(mOrigResolveList);
          }
          currentResolveList.remove(i);
        }
      }
    }
  }
  int N;
  if ((currentResolveList != null) && ((N=currentResolveList.size()) > 0)) {
    ResolveInfo r0=currentResolveList.get(0);
    for (int i=1; i < N; i++) {
      ResolveInfo ri=currentResolveList.get(i);
      if (DEBUG)       Log.v(""String_Node_Str"",r0.activityInfo.name + ""String_Node_Str"" + r0.priority+ ""String_Node_Str""+ r0.isDefault+ ""String_Node_Str""+ ri.activityInfo.name+ ""String_Node_Str""+ ri.priority+ ""String_Node_Str""+ ri.isDefault);
      if (r0.priority != ri.priority || r0.isDefault != ri.isDefault) {
        while (i < N) {
          if (mOrigResolveList == currentResolveList) {
            mOrigResolveList=new ArrayList<ResolveInfo>(mOrigResolveList);
          }
          currentResolveList.remove(i);
          N--;
        }
      }
    }
    if (N > 1) {
      ResolveInfo.DisplayNameComparator rComparator=new ResolveInfo.DisplayNameComparator(mPm);
      Collections.sort(currentResolveList,rComparator);
    }
    if (mInitialIntents != null) {
      for (int i=0; i < mInitialIntents.length; i++) {
        Intent ii=mInitialIntents[i];
        if (ii == null) {
          continue;
        }
        ActivityInfo ai=ii.resolveActivityInfo(getPackageManager(),0);
        if (ai == null) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + ii);
          continue;
        }
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        if (ii instanceof LabeledIntent) {
          LabeledIntent li=(LabeledIntent)ii;
          ri.resolvePackageName=li.getSourcePackage();
          ri.labelRes=li.getLabelResource();
          ri.nonLocalizedLabel=li.getNonLocalizedLabel();
          ri.icon=li.getIconResource();
        }
        mList.add(new DisplayResolveInfo(ri,ri.loadLabel(getPackageManager()),null,ii));
      }
    }
    r0=currentResolveList.get(0);
    int start=0;
    CharSequence r0Label=r0.loadLabel(mPm);
    mShowExtended=false;
    for (int i=1; i < N; i++) {
      if (r0Label == null) {
        r0Label=r0.activityInfo.packageName;
      }
      ResolveInfo ri=currentResolveList.get(i);
      CharSequence riLabel=ri.loadLabel(mPm);
      if (riLabel == null) {
        riLabel=ri.activityInfo.packageName;
      }
      if (riLabel.equals(r0Label)) {
        continue;
      }
      processGroup(currentResolveList,start,(i - 1),r0,r0Label);
      r0=ri;
      r0Label=riLabel;
      start=i;
    }
    processGroup(currentResolveList,start,(N - 1),r0,r0Label);
  }
}"
1301,"protected void onCreate(Bundle savedInstanceState,Intent intent,CharSequence title,Intent[] initialIntents,List<ResolveInfo> rList,boolean alwaysUseOption){
  setTheme(R.style.Theme_DeviceDefault_Light_Dialog_Alert);
  super.onCreate(savedInstanceState);
  try {
    mLaunchedFromUid=ActivityManagerNative.getDefault().getLaunchedFromUid(getActivityToken());
  }
 catch (  RemoteException e) {
    mLaunchedFromUid=-1;
  }
  mPm=getPackageManager();
  mAlwaysUseOption=alwaysUseOption;
  mMaxColumns=getResources().getInteger(R.integer.config_maxResolverActivityColumns);
  intent.setComponent(null);
  AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=title;
  mPackageMonitor.register(this,getMainLooper(),false);
  mRegistered=true;
  final ActivityManager am=(ActivityManager)getSystemService(ACTIVITY_SERVICE);
  mIconDpi=am.getLauncherLargeIconDensity();
  mIconSize=am.getLauncherLargeIconSize();
  mAdapter=new ResolveListAdapter(this,intent,initialIntents,rList,mLaunchedFromUid);
  int count=mAdapter.getCount();
  if (mLaunchedFromUid < 0 || UserHandle.isIsolated(mLaunchedFromUid)) {
    finish();
    return;
  }
 else   if (count > 1) {
    ap.mView=getLayoutInflater().inflate(R.layout.resolver_list,null);
    mListView=(ListView)ap.mView.findViewById(R.id.resolver_list);
    mListView.setAdapter(mAdapter);
    mListView.setOnItemClickListener(this);
    mListView.setOnItemLongClickListener(new ItemLongClickListener());
    if (alwaysUseOption) {
      mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    }
  }
 else   if (count == 1) {
    startActivity(mAdapter.intentForPosition(0));
    mPackageMonitor.unregister();
    mRegistered=false;
    finish();
    return;
  }
 else {
    ap.mMessage=getResources().getText(R.string.noApplications);
  }
  setupAlert();
  if (alwaysUseOption) {
    final ViewGroup buttonLayout=(ViewGroup)findViewById(R.id.button_bar);
    if (buttonLayout != null) {
      buttonLayout.setVisibility(View.VISIBLE);
      mAlwaysButton=(Button)buttonLayout.findViewById(R.id.button_always);
      mOnceButton=(Button)buttonLayout.findViewById(R.id.button_once);
    }
 else {
      mAlwaysUseOption=false;
    }
  }
  final int initialHighlight=mAdapter.getInitialHighlight();
  if (initialHighlight >= 0) {
    mListView.setItemChecked(initialHighlight,true);
    onItemClick(null,null,initialHighlight,0);
  }
}","protected void onCreate(Bundle savedInstanceState,Intent intent,CharSequence title,Intent[] initialIntents,List<ResolveInfo> rList,boolean alwaysUseOption){
  setTheme(R.style.Theme_DeviceDefault_Light_Dialog_Alert);
  super.onCreate(savedInstanceState);
  try {
    mLaunchedFromUid=ActivityManagerNative.getDefault().getLaunchedFromUid(getActivityToken());
  }
 catch (  RemoteException e) {
    mLaunchedFromUid=-1;
  }
  mPm=getPackageManager();
  mAlwaysUseOption=alwaysUseOption;
  mMaxColumns=getResources().getInteger(R.integer.config_maxResolverActivityColumns);
  AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=title;
  mPackageMonitor.register(this,getMainLooper(),false);
  mRegistered=true;
  final ActivityManager am=(ActivityManager)getSystemService(ACTIVITY_SERVICE);
  mIconDpi=am.getLauncherLargeIconDensity();
  mIconSize=am.getLauncherLargeIconSize();
  mAdapter=new ResolveListAdapter(this,intent,initialIntents,rList,mLaunchedFromUid);
  int count=mAdapter.getCount();
  if (mLaunchedFromUid < 0 || UserHandle.isIsolated(mLaunchedFromUid)) {
    finish();
    return;
  }
 else   if (count > 1) {
    ap.mView=getLayoutInflater().inflate(R.layout.resolver_list,null);
    mListView=(ListView)ap.mView.findViewById(R.id.resolver_list);
    mListView.setAdapter(mAdapter);
    mListView.setOnItemClickListener(this);
    mListView.setOnItemLongClickListener(new ItemLongClickListener());
    if (alwaysUseOption) {
      mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    }
  }
 else   if (count == 1) {
    startActivity(mAdapter.intentForPosition(0));
    mPackageMonitor.unregister();
    mRegistered=false;
    finish();
    return;
  }
 else {
    ap.mMessage=getResources().getText(R.string.noApplications);
  }
  setupAlert();
  if (alwaysUseOption) {
    final ViewGroup buttonLayout=(ViewGroup)findViewById(R.id.button_bar);
    if (buttonLayout != null) {
      buttonLayout.setVisibility(View.VISIBLE);
      mAlwaysButton=(Button)buttonLayout.findViewById(R.id.button_always);
      mOnceButton=(Button)buttonLayout.findViewById(R.id.button_once);
    }
 else {
      mAlwaysUseOption=false;
    }
  }
  final int initialHighlight=mAdapter.getInitialHighlight();
  if (initialHighlight >= 0) {
    mListView.setItemChecked(initialHighlight,true);
    onItemClick(null,null,initialHighlight,0);
  }
}"
1302,"private Intent makeMyIntent(){
  Intent intent=new Intent(getIntent());
  intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
  return intent;
}","private Intent makeMyIntent(){
  Intent intent=new Intent(getIntent());
  intent.setComponent(null);
  intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
  return intent;
}"
1303,"protected void onIntentSelected(ResolveInfo ri,Intent intent,boolean alwaysCheck){
  if (mAlwaysUseOption) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<PatternMatcher> pIt=ri.filter.schemeSpecificPartsIterator();
        if (pIt != null) {
          String ssp=data.getSchemeSpecificPart();
          while (ssp != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(ssp)) {
              filter.addDataSchemeSpecificPart(p.getPath(),p.getType());
              break;
            }
          }
        }
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      if (alwaysCheck) {
        getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
      }
 else {
        try {
          AppGlobals.getPackageManager().setLastChosenActivity(intent,intent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY,filter,bestMatch,intent.getComponent());
        }
 catch (        RemoteException re) {
          Log.d(TAG,""String_Node_Str"" + re);
        }
      }
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
}","protected void onIntentSelected(ResolveInfo ri,Intent intent,boolean alwaysCheck){
  if (mAlwaysUseOption && mAdapter.mOrigResolveList != null) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<PatternMatcher> pIt=ri.filter.schemeSpecificPartsIterator();
        if (pIt != null) {
          String ssp=data.getSchemeSpecificPart();
          while (ssp != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(ssp)) {
              filter.addDataSchemeSpecificPart(p.getPath(),p.getType());
              break;
            }
          }
        }
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mOrigResolveList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mOrigResolveList.get(i);
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      if (alwaysCheck) {
        getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
      }
 else {
        try {
          AppGlobals.getPackageManager().setLastChosenActivity(intent,intent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY,filter,bestMatch,intent.getComponent());
        }
 catch (        RemoteException re) {
          Log.d(TAG,""String_Node_Str"" + re);
        }
      }
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
}"
1304,"/** 
 * The same as   {@link #flattenToString()}, but abbreviates the class name if it is a suffix of the package.  The result can still be used with   {@link #unflattenFromString(String)}.
 * @return Returns a new String holding the package and class names.  Thisis represented as the package name, concatenated with a '/' and then the class name.
 * @see #unflattenFromString(String)
 */
public String flattenToShortString(){
  return mPackage + ""String_Node_Str"" + getShortClassName();
}","/** 
 * The same as   {@link #flattenToString()}, but abbreviates the class name if it is a suffix of the package.  The result can still be used with   {@link #unflattenFromString(String)}.
 * @return Returns a new String holding the package and class names.  Thisis represented as the package name, concatenated with a '/' and then the class name.
 * @see #unflattenFromString(String)
 */
public String flattenToShortString(){
  StringBuilder sb=new StringBuilder(mPackage.length() + mClass.length());
  appendShortString(sb,mPackage,mClass);
  return sb.toString();
}"
1305,"public String toString(){
  return ""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ service.info.name+ ""String_Node_Str"";
}","public String toString(){
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(' ');
  service.appendComponentShortName(sb);
  sb.append('}');
  return sb.toString();
}"
1306,"public String toString(){
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  return ""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ ci.name+ ""String_Node_Str""+ priority+ ""String_Node_Str""+ preferredOrder+ ""String_Node_Str""+ Integer.toHexString(match)+ ""String_Node_Str"";
}","public String toString(){
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(' ');
  ComponentName.appendShortString(sb,ci.packageName,ci.name);
  if (priority != 0) {
    sb.append(""String_Node_Str"");
    sb.append(priority);
  }
  if (preferredOrder != 0) {
    sb.append(""String_Node_Str"");
    sb.append(preferredOrder);
  }
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(match));
  sb.append('}');
  return sb.toString();
}"
1307,"public ResolveListAdapter(Context context,Intent intent,Intent[] initialIntents,List<ResolveInfo> rList,int launchedFromUid){
  mIntent=new Intent(intent);
  mIntent.setComponent(null);
  mInitialIntents=initialIntents;
  mBaseResolveList=rList;
  mLaunchedFromUid=launchedFromUid;
  mInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mList=new ArrayList<DisplayResolveInfo>();
  rebuildList();
}","public ResolveListAdapter(Context context,Intent intent,Intent[] initialIntents,List<ResolveInfo> rList,int launchedFromUid){
  mIntent=new Intent(intent);
  mInitialIntents=initialIntents;
  mBaseResolveList=rList;
  mLaunchedFromUid=launchedFromUid;
  mInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mList=new ArrayList<DisplayResolveInfo>();
  rebuildList();
}"
1308,"private void rebuildList(){
  List<ResolveInfo> currentResolveList;
  try {
    mLastChosen=AppGlobals.getPackageManager().getLastChosenActivity(mIntent,mIntent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY);
  }
 catch (  RemoteException re) {
    Log.d(TAG,""String_Node_Str"" + re);
  }
  mList.clear();
  if (mBaseResolveList != null) {
    currentResolveList=mBaseResolveList;
  }
 else {
    currentResolveList=mPm.queryIntentActivities(mIntent,PackageManager.MATCH_DEFAULT_ONLY | (mAlwaysUseOption ? PackageManager.GET_RESOLVED_FILTER : 0));
    if (currentResolveList != null) {
      for (int i=currentResolveList.size() - 1; i >= 0; i--) {
        ActivityInfo ai=currentResolveList.get(i).activityInfo;
        int granted=ActivityManager.checkComponentPermission(ai.permission,mLaunchedFromUid,ai.applicationInfo.uid,ai.exported);
        if (granted != PackageManager.PERMISSION_GRANTED) {
          currentResolveList.remove(i);
        }
      }
    }
  }
  int N;
  if ((currentResolveList != null) && ((N=currentResolveList.size()) > 0)) {
    ResolveInfo r0=currentResolveList.get(0);
    for (int i=1; i < N; i++) {
      ResolveInfo ri=currentResolveList.get(i);
      if (DEBUG)       Log.v(""String_Node_Str"",r0.activityInfo.name + ""String_Node_Str"" + r0.priority+ ""String_Node_Str""+ r0.isDefault+ ""String_Node_Str""+ ri.activityInfo.name+ ""String_Node_Str""+ ri.priority+ ""String_Node_Str""+ ri.isDefault);
      if (r0.priority != ri.priority || r0.isDefault != ri.isDefault) {
        while (i < N) {
          currentResolveList.remove(i);
          N--;
        }
      }
    }
    if (N > 1) {
      ResolveInfo.DisplayNameComparator rComparator=new ResolveInfo.DisplayNameComparator(mPm);
      Collections.sort(currentResolveList,rComparator);
    }
    if (mInitialIntents != null) {
      for (int i=0; i < mInitialIntents.length; i++) {
        Intent ii=mInitialIntents[i];
        if (ii == null) {
          continue;
        }
        ActivityInfo ai=ii.resolveActivityInfo(getPackageManager(),0);
        if (ai == null) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + ii);
          continue;
        }
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        if (ii instanceof LabeledIntent) {
          LabeledIntent li=(LabeledIntent)ii;
          ri.resolvePackageName=li.getSourcePackage();
          ri.labelRes=li.getLabelResource();
          ri.nonLocalizedLabel=li.getNonLocalizedLabel();
          ri.icon=li.getIconResource();
        }
        mList.add(new DisplayResolveInfo(ri,ri.loadLabel(getPackageManager()),null,ii));
      }
    }
    r0=currentResolveList.get(0);
    int start=0;
    CharSequence r0Label=r0.loadLabel(mPm);
    mShowExtended=false;
    for (int i=1; i < N; i++) {
      if (r0Label == null) {
        r0Label=r0.activityInfo.packageName;
      }
      ResolveInfo ri=currentResolveList.get(i);
      CharSequence riLabel=ri.loadLabel(mPm);
      if (riLabel == null) {
        riLabel=ri.activityInfo.packageName;
      }
      if (riLabel.equals(r0Label)) {
        continue;
      }
      processGroup(currentResolveList,start,(i - 1),r0,r0Label);
      r0=ri;
      r0Label=riLabel;
      start=i;
    }
    processGroup(currentResolveList,start,(N - 1),r0,r0Label);
  }
}","private void rebuildList(){
  List<ResolveInfo> currentResolveList;
  try {
    mLastChosen=AppGlobals.getPackageManager().getLastChosenActivity(mIntent,mIntent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY);
  }
 catch (  RemoteException re) {
    Log.d(TAG,""String_Node_Str"" + re);
  }
  mList.clear();
  if (mBaseResolveList != null) {
    currentResolveList=mBaseResolveList;
    mOrigResolveList=null;
  }
 else {
    currentResolveList=mOrigResolveList=mPm.queryIntentActivities(mIntent,PackageManager.MATCH_DEFAULT_ONLY | (mAlwaysUseOption ? PackageManager.GET_RESOLVED_FILTER : 0));
    if (currentResolveList != null) {
      for (int i=currentResolveList.size() - 1; i >= 0; i--) {
        ActivityInfo ai=currentResolveList.get(i).activityInfo;
        int granted=ActivityManager.checkComponentPermission(ai.permission,mLaunchedFromUid,ai.applicationInfo.uid,ai.exported);
        if (granted != PackageManager.PERMISSION_GRANTED) {
          if (mOrigResolveList == currentResolveList) {
            mOrigResolveList=new ArrayList<ResolveInfo>(mOrigResolveList);
          }
          currentResolveList.remove(i);
        }
      }
    }
  }
  int N;
  if ((currentResolveList != null) && ((N=currentResolveList.size()) > 0)) {
    ResolveInfo r0=currentResolveList.get(0);
    for (int i=1; i < N; i++) {
      ResolveInfo ri=currentResolveList.get(i);
      if (DEBUG)       Log.v(""String_Node_Str"",r0.activityInfo.name + ""String_Node_Str"" + r0.priority+ ""String_Node_Str""+ r0.isDefault+ ""String_Node_Str""+ ri.activityInfo.name+ ""String_Node_Str""+ ri.priority+ ""String_Node_Str""+ ri.isDefault);
      if (r0.priority != ri.priority || r0.isDefault != ri.isDefault) {
        while (i < N) {
          if (mOrigResolveList == currentResolveList) {
            mOrigResolveList=new ArrayList<ResolveInfo>(mOrigResolveList);
          }
          currentResolveList.remove(i);
          N--;
        }
      }
    }
    if (N > 1) {
      ResolveInfo.DisplayNameComparator rComparator=new ResolveInfo.DisplayNameComparator(mPm);
      Collections.sort(currentResolveList,rComparator);
    }
    if (mInitialIntents != null) {
      for (int i=0; i < mInitialIntents.length; i++) {
        Intent ii=mInitialIntents[i];
        if (ii == null) {
          continue;
        }
        ActivityInfo ai=ii.resolveActivityInfo(getPackageManager(),0);
        if (ai == null) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + ii);
          continue;
        }
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        if (ii instanceof LabeledIntent) {
          LabeledIntent li=(LabeledIntent)ii;
          ri.resolvePackageName=li.getSourcePackage();
          ri.labelRes=li.getLabelResource();
          ri.nonLocalizedLabel=li.getNonLocalizedLabel();
          ri.icon=li.getIconResource();
        }
        mList.add(new DisplayResolveInfo(ri,ri.loadLabel(getPackageManager()),null,ii));
      }
    }
    r0=currentResolveList.get(0);
    int start=0;
    CharSequence r0Label=r0.loadLabel(mPm);
    mShowExtended=false;
    for (int i=1; i < N; i++) {
      if (r0Label == null) {
        r0Label=r0.activityInfo.packageName;
      }
      ResolveInfo ri=currentResolveList.get(i);
      CharSequence riLabel=ri.loadLabel(mPm);
      if (riLabel == null) {
        riLabel=ri.activityInfo.packageName;
      }
      if (riLabel.equals(r0Label)) {
        continue;
      }
      processGroup(currentResolveList,start,(i - 1),r0,r0Label);
      r0=ri;
      r0Label=riLabel;
      start=i;
    }
    processGroup(currentResolveList,start,(N - 1),r0,r0Label);
  }
}"
1309,"protected void onCreate(Bundle savedInstanceState,Intent intent,CharSequence title,Intent[] initialIntents,List<ResolveInfo> rList,boolean alwaysUseOption){
  setTheme(R.style.Theme_DeviceDefault_Light_Dialog_Alert);
  super.onCreate(savedInstanceState);
  try {
    mLaunchedFromUid=ActivityManagerNative.getDefault().getLaunchedFromUid(getActivityToken());
  }
 catch (  RemoteException e) {
    mLaunchedFromUid=-1;
  }
  mPm=getPackageManager();
  mAlwaysUseOption=alwaysUseOption;
  mMaxColumns=getResources().getInteger(R.integer.config_maxResolverActivityColumns);
  intent.setComponent(null);
  AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=title;
  mPackageMonitor.register(this,getMainLooper(),false);
  mRegistered=true;
  final ActivityManager am=(ActivityManager)getSystemService(ACTIVITY_SERVICE);
  mIconDpi=am.getLauncherLargeIconDensity();
  mIconSize=am.getLauncherLargeIconSize();
  mAdapter=new ResolveListAdapter(this,intent,initialIntents,rList,mLaunchedFromUid);
  int count=mAdapter.getCount();
  if (mLaunchedFromUid < 0 || UserHandle.isIsolated(mLaunchedFromUid)) {
    finish();
    return;
  }
 else   if (count > 1) {
    ap.mView=getLayoutInflater().inflate(R.layout.resolver_list,null);
    mListView=(ListView)ap.mView.findViewById(R.id.resolver_list);
    mListView.setAdapter(mAdapter);
    mListView.setOnItemClickListener(this);
    mListView.setOnItemLongClickListener(new ItemLongClickListener());
    if (alwaysUseOption) {
      mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    }
  }
 else   if (count == 1) {
    startActivity(mAdapter.intentForPosition(0));
    mPackageMonitor.unregister();
    mRegistered=false;
    finish();
    return;
  }
 else {
    ap.mMessage=getResources().getText(R.string.noApplications);
  }
  setupAlert();
  if (alwaysUseOption) {
    final ViewGroup buttonLayout=(ViewGroup)findViewById(R.id.button_bar);
    if (buttonLayout != null) {
      buttonLayout.setVisibility(View.VISIBLE);
      mAlwaysButton=(Button)buttonLayout.findViewById(R.id.button_always);
      mOnceButton=(Button)buttonLayout.findViewById(R.id.button_once);
    }
 else {
      mAlwaysUseOption=false;
    }
  }
  final int initialHighlight=mAdapter.getInitialHighlight();
  if (initialHighlight >= 0) {
    mListView.setItemChecked(initialHighlight,true);
    onItemClick(null,null,initialHighlight,0);
  }
}","protected void onCreate(Bundle savedInstanceState,Intent intent,CharSequence title,Intent[] initialIntents,List<ResolveInfo> rList,boolean alwaysUseOption){
  setTheme(R.style.Theme_DeviceDefault_Light_Dialog_Alert);
  super.onCreate(savedInstanceState);
  try {
    mLaunchedFromUid=ActivityManagerNative.getDefault().getLaunchedFromUid(getActivityToken());
  }
 catch (  RemoteException e) {
    mLaunchedFromUid=-1;
  }
  mPm=getPackageManager();
  mAlwaysUseOption=alwaysUseOption;
  mMaxColumns=getResources().getInteger(R.integer.config_maxResolverActivityColumns);
  AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=title;
  mPackageMonitor.register(this,getMainLooper(),false);
  mRegistered=true;
  final ActivityManager am=(ActivityManager)getSystemService(ACTIVITY_SERVICE);
  mIconDpi=am.getLauncherLargeIconDensity();
  mIconSize=am.getLauncherLargeIconSize();
  mAdapter=new ResolveListAdapter(this,intent,initialIntents,rList,mLaunchedFromUid);
  int count=mAdapter.getCount();
  if (mLaunchedFromUid < 0 || UserHandle.isIsolated(mLaunchedFromUid)) {
    finish();
    return;
  }
 else   if (count > 1) {
    ap.mView=getLayoutInflater().inflate(R.layout.resolver_list,null);
    mListView=(ListView)ap.mView.findViewById(R.id.resolver_list);
    mListView.setAdapter(mAdapter);
    mListView.setOnItemClickListener(this);
    mListView.setOnItemLongClickListener(new ItemLongClickListener());
    if (alwaysUseOption) {
      mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    }
  }
 else   if (count == 1) {
    startActivity(mAdapter.intentForPosition(0));
    mPackageMonitor.unregister();
    mRegistered=false;
    finish();
    return;
  }
 else {
    ap.mMessage=getResources().getText(R.string.noApplications);
  }
  setupAlert();
  if (alwaysUseOption) {
    final ViewGroup buttonLayout=(ViewGroup)findViewById(R.id.button_bar);
    if (buttonLayout != null) {
      buttonLayout.setVisibility(View.VISIBLE);
      mAlwaysButton=(Button)buttonLayout.findViewById(R.id.button_always);
      mOnceButton=(Button)buttonLayout.findViewById(R.id.button_once);
    }
 else {
      mAlwaysUseOption=false;
    }
  }
  final int initialHighlight=mAdapter.getInitialHighlight();
  if (initialHighlight >= 0) {
    mListView.setItemChecked(initialHighlight,true);
    onItemClick(null,null,initialHighlight,0);
  }
}"
1310,"private Intent makeMyIntent(){
  Intent intent=new Intent(getIntent());
  intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
  return intent;
}","private Intent makeMyIntent(){
  Intent intent=new Intent(getIntent());
  intent.setComponent(null);
  intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
  return intent;
}"
1311,"protected void onIntentSelected(ResolveInfo ri,Intent intent,boolean alwaysCheck){
  if (mAlwaysUseOption) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<PatternMatcher> pIt=ri.filter.schemeSpecificPartsIterator();
        if (pIt != null) {
          String ssp=data.getSchemeSpecificPart();
          while (ssp != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(ssp)) {
              filter.addDataSchemeSpecificPart(p.getPath(),p.getType());
              break;
            }
          }
        }
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      if (alwaysCheck) {
        getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
      }
 else {
        try {
          AppGlobals.getPackageManager().setLastChosenActivity(intent,intent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY,filter,bestMatch,intent.getComponent());
        }
 catch (        RemoteException re) {
          Log.d(TAG,""String_Node_Str"" + re);
        }
      }
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
}","protected void onIntentSelected(ResolveInfo ri,Intent intent,boolean alwaysCheck){
  if (mAlwaysUseOption && mAdapter.mOrigResolveList != null) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<PatternMatcher> pIt=ri.filter.schemeSpecificPartsIterator();
        if (pIt != null) {
          String ssp=data.getSchemeSpecificPart();
          while (ssp != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(ssp)) {
              filter.addDataSchemeSpecificPart(p.getPath(),p.getType());
              break;
            }
          }
        }
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mOrigResolveList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mOrigResolveList.get(i);
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      if (alwaysCheck) {
        getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
      }
 else {
        try {
          AppGlobals.getPackageManager().setLastChosenActivity(intent,intent.resolveTypeIfNeeded(getContentResolver()),PackageManager.MATCH_DEFAULT_ONLY,filter,bestMatch,intent.getComponent());
        }
 catch (        RemoteException re) {
          Log.d(TAG,""String_Node_Str"" + re);
        }
      }
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
}"
1312,"private final int updateLruProcessInternalLocked(ProcessRecord app,long now,int index,String what,Object obj,ProcessRecord srcApp){
  app.lastActivityTime=now;
  if (app.activities.size() > 0) {
    return index;
  }
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui < 0) {
    throw new IllegalStateException(""String_Node_Str"" + app + ""String_Node_Str""+ what+ obj+ ""String_Node_Str""+ srcApp);
  }
  if (lrui >= mLruProcessActivityStart) {
    return index;
  }
  mLruProcesses.remove(lrui);
  if (index > 0) {
    index--;
  }
  mLruProcesses.add(index,app);
  return index;
}","private final int updateLruProcessInternalLocked(ProcessRecord app,long now,int index,String what,Object obj,ProcessRecord srcApp){
  app.lastActivityTime=now;
  if (app.activities.size() > 0) {
    return index;
  }
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui < 0) {
    Log.wtf(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ what+ ""String_Node_Str""+ obj+ ""String_Node_Str""+ srcApp);
    return index;
  }
  if (lrui >= mLruProcessActivityStart) {
    return index;
  }
  mLruProcesses.remove(lrui);
  if (index > 0) {
    index--;
  }
  mLruProcesses.add(index,app);
  return index;
}"
1313,"final void updateLruProcessLocked(ProcessRecord app,boolean oomAdj,boolean activityChange){
  final boolean hasActivity=app.activities.size() > 0;
  if (!activityChange && hasActivity) {
    return;
  }
  mLruSeq++;
  final long now=SystemClock.uptimeMillis();
  app.lastActivityTime=now;
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui >= 0) {
    if (lrui < mLruProcessActivityStart) {
      mLruProcessActivityStart--;
    }
    mLruProcesses.remove(lrui);
  }
  int nextIndex;
  if (!hasActivity) {
    mLruProcesses.add(mLruProcessActivityStart,app);
    nextIndex=mLruProcessActivityStart - 1;
    mLruProcessActivityStart++;
  }
 else {
    mLruProcesses.add(app);
    nextIndex=mLruProcessActivityStart;
  }
  for (int j=app.connections.size() - 1; j >= 0; j--) {
    ConnectionRecord cr=app.connections.valueAt(j);
    if (cr.binding != null && cr.binding.service != null && cr.binding.service.app != null && cr.binding.service.app.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cr.binding.service.app,now,nextIndex,""String_Node_Str"",cr,app);
    }
  }
  for (int j=app.conProviders.size() - 1; j >= 0; j--) {
    ContentProviderRecord cpr=app.conProviders.get(j).provider;
    if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cpr.proc,now,nextIndex,""String_Node_Str"",cpr,app);
    }
  }
  if (oomAdj) {
    updateOomAdjLocked();
  }
}","final void updateLruProcessLocked(ProcessRecord app,boolean oomAdj,boolean activityChange){
  final boolean hasActivity=app.activities.size() > 0;
  if (!activityChange && hasActivity) {
    return;
  }
  mLruSeq++;
  final long now=SystemClock.uptimeMillis();
  app.lastActivityTime=now;
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui >= 0) {
    if (lrui < mLruProcessActivityStart) {
      mLruProcessActivityStart--;
    }
    mLruProcesses.remove(lrui);
  }
  int nextIndex;
  if (!hasActivity) {
    mLruProcesses.add(mLruProcessActivityStart,app);
    nextIndex=mLruProcessActivityStart - 1;
    mLruProcessActivityStart++;
  }
 else {
    mLruProcesses.add(app);
    nextIndex=mLruProcessActivityStart;
  }
  for (int j=app.connections.size() - 1; j >= 0; j--) {
    ConnectionRecord cr=app.connections.valueAt(j);
    if (cr.binding != null && !cr.serviceDead && cr.binding.service != null && cr.binding.service.app != null && cr.binding.service.app.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cr.binding.service.app,now,nextIndex,""String_Node_Str"",cr,app);
    }
  }
  for (int j=app.conProviders.size() - 1; j >= 0; j--) {
    ContentProviderRecord cpr=app.conProviders.get(j).provider;
    if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cpr.proc,now,nextIndex,""String_Node_Str"",cpr,app);
    }
  }
  if (oomAdj) {
    updateOomAdjLocked();
  }
}"
1314,"private final int updateLruProcessInternalLocked(ProcessRecord app,long now,int index,String what,Object obj,ProcessRecord srcApp){
  app.lastActivityTime=now;
  if (app.activities.size() > 0) {
    return index;
  }
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui < 0) {
    throw new IllegalStateException(""String_Node_Str"" + app + ""String_Node_Str""+ what+ obj+ ""String_Node_Str""+ srcApp);
  }
  if (lrui >= mLruProcessActivityStart) {
    return index;
  }
  mLruProcesses.remove(lrui);
  if (index > 0) {
    index--;
  }
  mLruProcesses.add(index,app);
  return index;
}","private final int updateLruProcessInternalLocked(ProcessRecord app,long now,int index,String what,Object obj,ProcessRecord srcApp){
  app.lastActivityTime=now;
  if (app.activities.size() > 0) {
    return index;
  }
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui < 0) {
    Log.wtf(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ what+ ""String_Node_Str""+ obj+ ""String_Node_Str""+ srcApp);
    return index;
  }
  if (lrui >= mLruProcessActivityStart) {
    return index;
  }
  mLruProcesses.remove(lrui);
  if (index > 0) {
    index--;
  }
  mLruProcesses.add(index,app);
  return index;
}"
1315,"final void updateLruProcessLocked(ProcessRecord app,boolean oomAdj,boolean activityChange){
  final boolean hasActivity=app.activities.size() > 0;
  if (!activityChange && hasActivity) {
    return;
  }
  mLruSeq++;
  final long now=SystemClock.uptimeMillis();
  app.lastActivityTime=now;
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui >= 0) {
    if (lrui < mLruProcessActivityStart) {
      mLruProcessActivityStart--;
    }
    mLruProcesses.remove(lrui);
  }
  int nextIndex;
  if (!hasActivity) {
    mLruProcesses.add(mLruProcessActivityStart,app);
    nextIndex=mLruProcessActivityStart - 1;
    mLruProcessActivityStart++;
  }
 else {
    mLruProcesses.add(app);
    nextIndex=mLruProcessActivityStart;
  }
  for (int j=app.connections.size() - 1; j >= 0; j--) {
    ConnectionRecord cr=app.connections.valueAt(j);
    if (cr.binding != null && cr.binding.service != null && cr.binding.service.app != null && cr.binding.service.app.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cr.binding.service.app,now,nextIndex,""String_Node_Str"",cr,app);
    }
  }
  for (int j=app.conProviders.size() - 1; j >= 0; j--) {
    ContentProviderRecord cpr=app.conProviders.get(j).provider;
    if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cpr.proc,now,nextIndex,""String_Node_Str"",cpr,app);
    }
  }
  if (oomAdj) {
    updateOomAdjLocked();
  }
}","final void updateLruProcessLocked(ProcessRecord app,boolean oomAdj,boolean activityChange){
  final boolean hasActivity=app.activities.size() > 0;
  if (!activityChange && hasActivity) {
    return;
  }
  mLruSeq++;
  final long now=SystemClock.uptimeMillis();
  app.lastActivityTime=now;
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui >= 0) {
    if (lrui < mLruProcessActivityStart) {
      mLruProcessActivityStart--;
    }
    mLruProcesses.remove(lrui);
  }
  int nextIndex;
  if (!hasActivity) {
    mLruProcesses.add(mLruProcessActivityStart,app);
    nextIndex=mLruProcessActivityStart - 1;
    mLruProcessActivityStart++;
  }
 else {
    mLruProcesses.add(app);
    nextIndex=mLruProcessActivityStart;
  }
  for (int j=app.connections.size() - 1; j >= 0; j--) {
    ConnectionRecord cr=app.connections.valueAt(j);
    if (cr.binding != null && !cr.serviceDead && cr.binding.service != null && cr.binding.service.app != null && cr.binding.service.app.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cr.binding.service.app,now,nextIndex,""String_Node_Str"",cr,app);
    }
  }
  for (int j=app.conProviders.size() - 1; j >= 0; j--) {
    ContentProviderRecord cpr=app.conProviders.get(j).provider;
    if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cpr.proc,now,nextIndex,""String_Node_Str"",cpr,app);
    }
  }
  if (oomAdj) {
    updateOomAdjLocked();
  }
}"
1316,"private final int updateLruProcessInternalLocked(ProcessRecord app,long now,int index,String what,Object obj,ProcessRecord srcApp){
  app.lastActivityTime=now;
  if (app.activities.size() > 0) {
    return index;
  }
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui < 0) {
    throw new IllegalStateException(""String_Node_Str"" + app + ""String_Node_Str""+ what+ obj+ ""String_Node_Str""+ srcApp);
  }
  if (lrui >= mLruProcessActivityStart) {
    return index;
  }
  mLruProcesses.remove(lrui);
  if (index > 0) {
    index--;
  }
  mLruProcesses.add(index,app);
  return index;
}","private final int updateLruProcessInternalLocked(ProcessRecord app,long now,int index,String what,Object obj,ProcessRecord srcApp){
  app.lastActivityTime=now;
  if (app.activities.size() > 0) {
    return index;
  }
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui < 0) {
    Log.wtf(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ what+ ""String_Node_Str""+ obj+ ""String_Node_Str""+ srcApp);
    return index;
  }
  if (lrui >= mLruProcessActivityStart) {
    return index;
  }
  mLruProcesses.remove(lrui);
  if (index > 0) {
    index--;
  }
  mLruProcesses.add(index,app);
  return index;
}"
1317,"final void updateLruProcessLocked(ProcessRecord app,boolean oomAdj,boolean activityChange){
  final boolean hasActivity=app.activities.size() > 0;
  if (!activityChange && hasActivity) {
    return;
  }
  mLruSeq++;
  final long now=SystemClock.uptimeMillis();
  app.lastActivityTime=now;
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui >= 0) {
    if (lrui < mLruProcessActivityStart) {
      mLruProcessActivityStart--;
    }
    mLruProcesses.remove(lrui);
  }
  int nextIndex;
  if (!hasActivity) {
    mLruProcesses.add(mLruProcessActivityStart,app);
    nextIndex=mLruProcessActivityStart - 1;
    mLruProcessActivityStart++;
  }
 else {
    mLruProcesses.add(app);
    nextIndex=mLruProcessActivityStart;
  }
  for (int j=app.connections.size() - 1; j >= 0; j--) {
    ConnectionRecord cr=app.connections.valueAt(j);
    if (cr.binding != null && cr.binding.service != null && cr.binding.service.app != null && cr.binding.service.app.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cr.binding.service.app,now,nextIndex,""String_Node_Str"",cr,app);
    }
  }
  for (int j=app.conProviders.size() - 1; j >= 0; j--) {
    ContentProviderRecord cpr=app.conProviders.get(j).provider;
    if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cpr.proc,now,nextIndex,""String_Node_Str"",cpr,app);
    }
  }
  if (oomAdj) {
    updateOomAdjLocked();
  }
}","final void updateLruProcessLocked(ProcessRecord app,boolean oomAdj,boolean activityChange){
  final boolean hasActivity=app.activities.size() > 0;
  if (!activityChange && hasActivity) {
    return;
  }
  mLruSeq++;
  final long now=SystemClock.uptimeMillis();
  app.lastActivityTime=now;
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui >= 0) {
    if (lrui < mLruProcessActivityStart) {
      mLruProcessActivityStart--;
    }
    mLruProcesses.remove(lrui);
  }
  int nextIndex;
  if (!hasActivity) {
    mLruProcesses.add(mLruProcessActivityStart,app);
    nextIndex=mLruProcessActivityStart - 1;
    mLruProcessActivityStart++;
  }
 else {
    mLruProcesses.add(app);
    nextIndex=mLruProcessActivityStart;
  }
  for (int j=app.connections.size() - 1; j >= 0; j--) {
    ConnectionRecord cr=app.connections.valueAt(j);
    if (cr.binding != null && !cr.serviceDead && cr.binding.service != null && cr.binding.service.app != null && cr.binding.service.app.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cr.binding.service.app,now,nextIndex,""String_Node_Str"",cr,app);
    }
  }
  for (int j=app.conProviders.size() - 1; j >= 0; j--) {
    ContentProviderRecord cpr=app.conProviders.get(j).provider;
    if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cpr.proc,now,nextIndex,""String_Node_Str"",cpr,app);
    }
  }
  if (oomAdj) {
    updateOomAdjLocked();
  }
}"
1318,"private final int updateLruProcessInternalLocked(ProcessRecord app,long now,int index,String what,Object obj,ProcessRecord srcApp){
  app.lastActivityTime=now;
  if (app.activities.size() > 0) {
    return index;
  }
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui < 0) {
    throw new IllegalStateException(""String_Node_Str"" + app + ""String_Node_Str""+ what+ obj+ ""String_Node_Str""+ srcApp);
  }
  if (lrui >= mLruProcessActivityStart) {
    return index;
  }
  mLruProcesses.remove(lrui);
  if (index > 0) {
    index--;
  }
  mLruProcesses.add(index,app);
  return index;
}","private final int updateLruProcessInternalLocked(ProcessRecord app,long now,int index,String what,Object obj,ProcessRecord srcApp){
  app.lastActivityTime=now;
  if (app.activities.size() > 0) {
    return index;
  }
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui < 0) {
    Log.wtf(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ what+ ""String_Node_Str""+ obj+ ""String_Node_Str""+ srcApp);
    return index;
  }
  if (lrui >= mLruProcessActivityStart) {
    return index;
  }
  mLruProcesses.remove(lrui);
  if (index > 0) {
    index--;
  }
  mLruProcesses.add(index,app);
  return index;
}"
1319,"final void updateLruProcessLocked(ProcessRecord app,boolean oomAdj,boolean activityChange){
  final boolean hasActivity=app.activities.size() > 0;
  if (!activityChange && hasActivity) {
    return;
  }
  mLruSeq++;
  final long now=SystemClock.uptimeMillis();
  app.lastActivityTime=now;
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui >= 0) {
    if (lrui < mLruProcessActivityStart) {
      mLruProcessActivityStart--;
    }
    mLruProcesses.remove(lrui);
  }
  int nextIndex;
  if (!hasActivity) {
    mLruProcesses.add(mLruProcessActivityStart,app);
    nextIndex=mLruProcessActivityStart - 1;
    mLruProcessActivityStart++;
  }
 else {
    mLruProcesses.add(app);
    nextIndex=mLruProcessActivityStart;
  }
  for (int j=app.connections.size() - 1; j >= 0; j--) {
    ConnectionRecord cr=app.connections.valueAt(j);
    if (cr.binding != null && cr.binding.service != null && cr.binding.service.app != null && cr.binding.service.app.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cr.binding.service.app,now,nextIndex,""String_Node_Str"",cr,app);
    }
  }
  for (int j=app.conProviders.size() - 1; j >= 0; j--) {
    ContentProviderRecord cpr=app.conProviders.get(j).provider;
    if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cpr.proc,now,nextIndex,""String_Node_Str"",cpr,app);
    }
  }
  if (oomAdj) {
    updateOomAdjLocked();
  }
}","final void updateLruProcessLocked(ProcessRecord app,boolean oomAdj,boolean activityChange){
  final boolean hasActivity=app.activities.size() > 0;
  if (!activityChange && hasActivity) {
    return;
  }
  mLruSeq++;
  final long now=SystemClock.uptimeMillis();
  app.lastActivityTime=now;
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui >= 0) {
    if (lrui < mLruProcessActivityStart) {
      mLruProcessActivityStart--;
    }
    mLruProcesses.remove(lrui);
  }
  int nextIndex;
  if (!hasActivity) {
    mLruProcesses.add(mLruProcessActivityStart,app);
    nextIndex=mLruProcessActivityStart - 1;
    mLruProcessActivityStart++;
  }
 else {
    mLruProcesses.add(app);
    nextIndex=mLruProcessActivityStart;
  }
  for (int j=app.connections.size() - 1; j >= 0; j--) {
    ConnectionRecord cr=app.connections.valueAt(j);
    if (cr.binding != null && !cr.serviceDead && cr.binding.service != null && cr.binding.service.app != null && cr.binding.service.app.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cr.binding.service.app,now,nextIndex,""String_Node_Str"",cr,app);
    }
  }
  for (int j=app.conProviders.size() - 1; j >= 0; j--) {
    ContentProviderRecord cpr=app.conProviders.get(j).provider;
    if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cpr.proc,now,nextIndex,""String_Node_Str"",cpr,app);
    }
  }
  if (oomAdj) {
    updateOomAdjLocked();
  }
}"
1320,"private final int updateLruProcessInternalLocked(ProcessRecord app,long now,int index,String what,Object obj,ProcessRecord srcApp){
  app.lastActivityTime=now;
  if (app.activities.size() > 0) {
    return index;
  }
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui < 0) {
    throw new IllegalStateException(""String_Node_Str"" + app + ""String_Node_Str""+ what+ obj+ ""String_Node_Str""+ srcApp);
  }
  if (lrui >= mLruProcessActivityStart) {
    return index;
  }
  mLruProcesses.remove(lrui);
  if (index > 0) {
    index--;
  }
  mLruProcesses.add(index,app);
  return index;
}","private final int updateLruProcessInternalLocked(ProcessRecord app,long now,int index,String what,Object obj,ProcessRecord srcApp){
  app.lastActivityTime=now;
  if (app.activities.size() > 0) {
    return index;
  }
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui < 0) {
    Log.wtf(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ what+ ""String_Node_Str""+ obj+ ""String_Node_Str""+ srcApp);
    return index;
  }
  if (lrui >= mLruProcessActivityStart) {
    return index;
  }
  mLruProcesses.remove(lrui);
  if (index > 0) {
    index--;
  }
  mLruProcesses.add(index,app);
  return index;
}"
1321,"final void updateLruProcessLocked(ProcessRecord app,boolean oomAdj,boolean activityChange){
  final boolean hasActivity=app.activities.size() > 0;
  if (!activityChange && hasActivity) {
    return;
  }
  mLruSeq++;
  final long now=SystemClock.uptimeMillis();
  app.lastActivityTime=now;
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui >= 0) {
    if (lrui < mLruProcessActivityStart) {
      mLruProcessActivityStart--;
    }
    mLruProcesses.remove(lrui);
  }
  int nextIndex;
  if (!hasActivity) {
    mLruProcesses.add(mLruProcessActivityStart,app);
    nextIndex=mLruProcessActivityStart - 1;
    mLruProcessActivityStart++;
  }
 else {
    mLruProcesses.add(app);
    nextIndex=mLruProcessActivityStart;
  }
  for (int j=app.connections.size() - 1; j >= 0; j--) {
    ConnectionRecord cr=app.connections.valueAt(j);
    if (cr.binding != null && cr.binding.service != null && cr.binding.service.app != null && cr.binding.service.app.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cr.binding.service.app,now,nextIndex,""String_Node_Str"",cr,app);
    }
  }
  for (int j=app.conProviders.size() - 1; j >= 0; j--) {
    ContentProviderRecord cpr=app.conProviders.get(j).provider;
    if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cpr.proc,now,nextIndex,""String_Node_Str"",cpr,app);
    }
  }
  if (oomAdj) {
    updateOomAdjLocked();
  }
}","final void updateLruProcessLocked(ProcessRecord app,boolean oomAdj,boolean activityChange){
  final boolean hasActivity=app.activities.size() > 0;
  if (!activityChange && hasActivity) {
    return;
  }
  mLruSeq++;
  final long now=SystemClock.uptimeMillis();
  app.lastActivityTime=now;
  int lrui=mLruProcesses.lastIndexOf(app);
  if (lrui >= 0) {
    if (lrui < mLruProcessActivityStart) {
      mLruProcessActivityStart--;
    }
    mLruProcesses.remove(lrui);
  }
  int nextIndex;
  if (!hasActivity) {
    mLruProcesses.add(mLruProcessActivityStart,app);
    nextIndex=mLruProcessActivityStart - 1;
    mLruProcessActivityStart++;
  }
 else {
    mLruProcesses.add(app);
    nextIndex=mLruProcessActivityStart;
  }
  for (int j=app.connections.size() - 1; j >= 0; j--) {
    ConnectionRecord cr=app.connections.valueAt(j);
    if (cr.binding != null && !cr.serviceDead && cr.binding.service != null && cr.binding.service.app != null && cr.binding.service.app.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cr.binding.service.app,now,nextIndex,""String_Node_Str"",cr,app);
    }
  }
  for (int j=app.conProviders.size() - 1; j >= 0; j--) {
    ContentProviderRecord cpr=app.conProviders.get(j).provider;
    if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq) {
      nextIndex=updateLruProcessInternalLocked(cpr.proc,now,nextIndex,""String_Node_Str"",cpr,app);
    }
  }
  if (oomAdj) {
    updateOomAdjLocked();
  }
}"
1322,"final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedByAm && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
killUnneededProcessLocked(app,""String_Node_Str"" + numCached);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
killUnneededProcessLocked(app,""String_Node_Str"" + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000) + ""String_Node_Str"");
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
killUnneededProcessLocked(app,""String_Node_Str"" + numEmpty);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
killUnneededProcessLocked(app,""String_Node_Str"");
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
final int numCachedAndEmpty=numCached + numEmpty;
int memFactor;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
memFactor=ProcessStats.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
memFactor=ProcessStats.ADJ_MEM_FACTOR_LOW;
}
 else {
memFactor=ProcessStats.ADJ_MEM_FACTOR_MODERATE;
}
}
 else {
memFactor=ProcessStats.ADJ_MEM_FACTOR_NORMAL;
}
if (DEBUG_OOM_ADJ) Slog.d(TAG,""String_Node_Str"" + memFactor + ""String_Node_Str""+ mLastMemoryLevel+ ""String_Node_Str""+ mAllowLowerMemLevel+ ""String_Node_Str""+ mLruProcesses.size()+ ""String_Node_Str""+ mLastNumProcesses);
if (memFactor > mLastMemoryLevel) {
if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {
memFactor=mLastMemoryLevel;
if (DEBUG_OOM_ADJ) Slog.d(TAG,""String_Node_Str"");
}
}
mLastMemoryLevel=memFactor;
mLastNumProcesses=mLruProcesses.size();
boolean allChanged=mProcessStats.setMemFactorLocked(ProcessStats.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
final int trackerMemFactor=mProcessStats.getMemFactorLocked();
if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {
if (mLowRamStartTime == 0) {
mLowRamStartTime=now;
}
int step=0;
int fgTrimLevel;
switch (memFactor) {
case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
break;
case ProcessStats.ADJ_MEM_FACTOR_LOW:
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
break;
default :
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
break;
}
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
setProcessTrackerState(app,trackerMemFactor,now);
app.procStateChanged=false;
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
if (mLowRamStartTime != 0) {
mLowRamTimeSinceLastIdle+=now - mLowRamStartTime;
mLowRamStartTime=0;
}
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
setProcessTrackerState(app,trackerMemFactor,now);
app.procStateChanged=false;
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false,mProcessStats.isMemFactorLowered());
}
if (mProcessStats.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessStats.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}","final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedByAm && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
killUnneededProcessLocked(app,""String_Node_Str"" + numCached);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
killUnneededProcessLocked(app,""String_Node_Str"" + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000) + ""String_Node_Str"");
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
killUnneededProcessLocked(app,""String_Node_Str"" + numEmpty);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
killUnneededProcessLocked(app,""String_Node_Str"");
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
final int numCachedAndEmpty=numCached + numEmpty;
int memFactor;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
memFactor=ProcessStats.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
memFactor=ProcessStats.ADJ_MEM_FACTOR_LOW;
}
 else {
memFactor=ProcessStats.ADJ_MEM_FACTOR_MODERATE;
}
}
 else {
memFactor=ProcessStats.ADJ_MEM_FACTOR_NORMAL;
}
if (DEBUG_OOM_ADJ) Slog.d(TAG,""String_Node_Str"" + memFactor + ""String_Node_Str""+ mLastMemoryLevel+ ""String_Node_Str""+ mAllowLowerMemLevel+ ""String_Node_Str""+ mLruProcesses.size()+ ""String_Node_Str""+ mLastNumProcesses);
if (memFactor > mLastMemoryLevel) {
if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {
memFactor=mLastMemoryLevel;
if (DEBUG_OOM_ADJ) Slog.d(TAG,""String_Node_Str"");
}
}
mLastMemoryLevel=memFactor;
mLastNumProcesses=mLruProcesses.size();
boolean allChanged=mProcessStats.setMemFactorLocked(memFactor,!mSleeping,now);
final int trackerMemFactor=mProcessStats.getMemFactorLocked();
if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {
if (mLowRamStartTime == 0) {
mLowRamStartTime=now;
}
int step=0;
int fgTrimLevel;
switch (memFactor) {
case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
break;
case ProcessStats.ADJ_MEM_FACTOR_LOW:
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
break;
default :
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
break;
}
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
setProcessTrackerState(app,trackerMemFactor,now);
app.procStateChanged=false;
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
if (mLowRamStartTime != 0) {
mLowRamTimeSinceLastIdle+=now - mLowRamStartTime;
mLowRamStartTime=0;
}
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
setProcessTrackerState(app,trackerMemFactor,now);
app.procStateChanged=false;
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false,mProcessStats.isMemFactorLowered());
}
if (mProcessStats.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessStats.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}"
1323,"/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(0x4C444E42);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      parcel.writeInt(-1);
      parcel.writeInt(0x4C444E42);
      int oldPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int newPos=parcel.dataPosition();
      parcel.setDataPosition(oldPos - 8);
      int length=newPos - oldPos;
      parcel.writeInt(length);
      parcel.setDataPosition(newPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}","/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      parcel.writeInt(-1);
      parcel.writeInt(BUNDLE_MAGIC);
      int oldPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int newPos=parcel.dataPosition();
      parcel.setDataPosition(oldPos - 8);
      int length=newPos - oldPos;
      parcel.writeInt(length);
      parcel.setDataPosition(newPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}"
1324,"void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != 0x4C444E42) {
    String st=Log.getStackTraceString(new RuntimeException());
    Log.e(""String_Node_Str"",""String_Node_Str"");
    Log.e(""String_Node_Str"",""String_Node_Str"" + st);
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  p.setDataPosition(0);
  mParcelledData=p;
  mHasFds=p.hasFileDescriptors();
  mFdsKnown=true;
}","void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != BUNDLE_MAGIC) {
    throw new IllegalStateException(""String_Node_Str"" + Integer.toHexString(magic));
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  p.setDataPosition(0);
  if (mMap != null) {
    if (mFdsKnown) {
      mHasFds|=p.hasFileDescriptors();
    }
    int N=p.readInt();
    p.readArrayMapSafelyInternal(mMap,N,mClassLoader);
    p.recycle();
  }
 else {
    mParcelledData=p;
    mHasFds=p.hasFileDescriptors();
    mFdsKnown=true;
  }
}"
1325,"void readArrayMapInternal(ArrayMap outVal,int N,ClassLoader loader){
  while (N > 0) {
    Object key=readValue(loader);
    Object value=readValue(loader);
    outVal.append(key,value);
    N--;
  }
}","void readArrayMapInternal(ArrayMap outVal,int N,ClassLoader loader){
  if (DEBUG_ARRAY_MAP) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Log.d(TAG,""String_Node_Str"" + N + ""String_Node_Str"",here);
  }
  while (N > 0) {
    Object key=readValue(loader);
    if (DEBUG_ARRAY_MAP)     Log.d(TAG,""String_Node_Str"" + (N - 1) + ""String_Node_Str""+ (key != null ? key.hashCode() : 0)+ ""String_Node_Str""+ key);
    Object value=readValue(loader);
    outVal.append(key,value);
    N--;
  }
}"
1326,"/** 
 * Flatten an ArrayMap into the parcel at the current dataPosition(), growing dataCapacity() if needed.  The Map keys must be String objects.
 */
void writeArrayMapInternal(ArrayMap<String,Object> val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  final int N=val.size();
  writeInt(N);
  for (int i=0; i < N; i++) {
    writeValue(val.keyAt(i));
    writeValue(val.valueAt(i));
  }
}","/** 
 * Flatten an ArrayMap into the parcel at the current dataPosition(), growing dataCapacity() if needed.  The Map keys must be String objects.
 */
void writeArrayMapInternal(ArrayMap<String,Object> val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  final int N=val.size();
  writeInt(N);
  if (DEBUG_ARRAY_MAP) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Log.d(TAG,""String_Node_Str"" + N + ""String_Node_Str"",here);
  }
  for (int i=0; i < N; i++) {
    if (DEBUG_ARRAY_MAP)     Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ (val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0)+ ""String_Node_Str""+ val.keyAt(i));
    writeValue(val.keyAt(i));
    writeValue(val.valueAt(i));
  }
}"
1327,"final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedByAm && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
killUnneededProcessLocked(app,""String_Node_Str"" + numCached);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
killUnneededProcessLocked(app,""String_Node_Str"" + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000) + ""String_Node_Str"");
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
killUnneededProcessLocked(app,""String_Node_Str"" + numEmpty);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
killUnneededProcessLocked(app,""String_Node_Str"");
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
final int numCachedAndEmpty=numCached + numEmpty;
int memFactor;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
memFactor=ProcessStats.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
memFactor=ProcessStats.ADJ_MEM_FACTOR_LOW;
}
 else {
memFactor=ProcessStats.ADJ_MEM_FACTOR_MODERATE;
}
}
 else {
memFactor=ProcessStats.ADJ_MEM_FACTOR_NORMAL;
}
if (DEBUG_OOM_ADJ) Slog.d(TAG,""String_Node_Str"" + memFactor + ""String_Node_Str""+ mLastMemoryLevel+ ""String_Node_Str""+ mAllowLowerMemLevel+ ""String_Node_Str""+ mLruProcesses.size()+ ""String_Node_Str""+ mLastNumProcesses);
if (memFactor > mLastMemoryLevel) {
if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {
memFactor=mLastMemoryLevel;
if (DEBUG_OOM_ADJ) Slog.d(TAG,""String_Node_Str"");
}
}
mLastMemoryLevel=memFactor;
mLastNumProcesses=mLruProcesses.size();
boolean allChanged=mProcessStats.setMemFactorLocked(ProcessStats.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
final int trackerMemFactor=mProcessStats.getMemFactorLocked();
if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {
if (mLowRamStartTime == 0) {
mLowRamStartTime=now;
}
int step=0;
int fgTrimLevel;
switch (memFactor) {
case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
break;
case ProcessStats.ADJ_MEM_FACTOR_LOW:
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
break;
default :
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
break;
}
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
setProcessTrackerState(app,trackerMemFactor,now);
app.procStateChanged=false;
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
if (mLowRamStartTime != 0) {
mLowRamTimeSinceLastIdle+=now - mLowRamStartTime;
mLowRamStartTime=0;
}
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
setProcessTrackerState(app,trackerMemFactor,now);
app.procStateChanged=false;
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false,mProcessStats.isMemFactorLowered());
}
if (mProcessStats.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessStats.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}","final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedByAm && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
killUnneededProcessLocked(app,""String_Node_Str"" + numCached);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
killUnneededProcessLocked(app,""String_Node_Str"" + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000) + ""String_Node_Str"");
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
killUnneededProcessLocked(app,""String_Node_Str"" + numEmpty);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
killUnneededProcessLocked(app,""String_Node_Str"");
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
final int numCachedAndEmpty=numCached + numEmpty;
int memFactor;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
memFactor=ProcessStats.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
memFactor=ProcessStats.ADJ_MEM_FACTOR_LOW;
}
 else {
memFactor=ProcessStats.ADJ_MEM_FACTOR_MODERATE;
}
}
 else {
memFactor=ProcessStats.ADJ_MEM_FACTOR_NORMAL;
}
if (DEBUG_OOM_ADJ) Slog.d(TAG,""String_Node_Str"" + memFactor + ""String_Node_Str""+ mLastMemoryLevel+ ""String_Node_Str""+ mAllowLowerMemLevel+ ""String_Node_Str""+ mLruProcesses.size()+ ""String_Node_Str""+ mLastNumProcesses);
if (memFactor > mLastMemoryLevel) {
if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {
memFactor=mLastMemoryLevel;
if (DEBUG_OOM_ADJ) Slog.d(TAG,""String_Node_Str"");
}
}
mLastMemoryLevel=memFactor;
mLastNumProcesses=mLruProcesses.size();
boolean allChanged=mProcessStats.setMemFactorLocked(memFactor,!mSleeping,now);
final int trackerMemFactor=mProcessStats.getMemFactorLocked();
if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {
if (mLowRamStartTime == 0) {
mLowRamStartTime=now;
}
int step=0;
int fgTrimLevel;
switch (memFactor) {
case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
break;
case ProcessStats.ADJ_MEM_FACTOR_LOW:
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
break;
default :
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
break;
}
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
setProcessTrackerState(app,trackerMemFactor,now);
app.procStateChanged=false;
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
if (mLowRamStartTime != 0) {
mLowRamTimeSinceLastIdle+=now - mLowRamStartTime;
mLowRamStartTime=0;
}
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
setProcessTrackerState(app,trackerMemFactor,now);
app.procStateChanged=false;
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false,mProcessStats.isMemFactorLowered());
}
if (mProcessStats.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessStats.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}"
1328,"/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(0x4C444E42);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      parcel.writeInt(-1);
      parcel.writeInt(0x4C444E42);
      int oldPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int newPos=parcel.dataPosition();
      parcel.setDataPosition(oldPos - 8);
      int length=newPos - oldPos;
      parcel.writeInt(length);
      parcel.setDataPosition(newPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}","/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      parcel.writeInt(-1);
      parcel.writeInt(BUNDLE_MAGIC);
      int oldPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int newPos=parcel.dataPosition();
      parcel.setDataPosition(oldPos - 8);
      int length=newPos - oldPos;
      parcel.writeInt(length);
      parcel.setDataPosition(newPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}"
1329,"void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != 0x4C444E42) {
    String st=Log.getStackTraceString(new RuntimeException());
    Log.e(""String_Node_Str"",""String_Node_Str"");
    Log.e(""String_Node_Str"",""String_Node_Str"" + st);
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  p.setDataPosition(0);
  mParcelledData=p;
  mHasFds=p.hasFileDescriptors();
  mFdsKnown=true;
}","void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != BUNDLE_MAGIC) {
    throw new IllegalStateException(""String_Node_Str"" + Integer.toHexString(magic));
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  p.setDataPosition(0);
  if (mMap != null) {
    if (mFdsKnown) {
      mHasFds|=p.hasFileDescriptors();
    }
    int N=p.readInt();
    p.readArrayMapSafelyInternal(mMap,N,mClassLoader);
    p.recycle();
  }
 else {
    mParcelledData=p;
    mHasFds=p.hasFileDescriptors();
    mFdsKnown=true;
  }
}"
1330,"void readArrayMapInternal(ArrayMap outVal,int N,ClassLoader loader){
  while (N > 0) {
    Object key=readValue(loader);
    Object value=readValue(loader);
    outVal.append(key,value);
    N--;
  }
}","void readArrayMapInternal(ArrayMap outVal,int N,ClassLoader loader){
  if (DEBUG_ARRAY_MAP) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Log.d(TAG,""String_Node_Str"" + N + ""String_Node_Str"",here);
  }
  while (N > 0) {
    Object key=readValue(loader);
    if (DEBUG_ARRAY_MAP)     Log.d(TAG,""String_Node_Str"" + (N - 1) + ""String_Node_Str""+ (key != null ? key.hashCode() : 0)+ ""String_Node_Str""+ key);
    Object value=readValue(loader);
    outVal.append(key,value);
    N--;
  }
}"
1331,"/** 
 * Flatten an ArrayMap into the parcel at the current dataPosition(), growing dataCapacity() if needed.  The Map keys must be String objects.
 */
void writeArrayMapInternal(ArrayMap<String,Object> val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  final int N=val.size();
  writeInt(N);
  for (int i=0; i < N; i++) {
    writeValue(val.keyAt(i));
    writeValue(val.valueAt(i));
  }
}","/** 
 * Flatten an ArrayMap into the parcel at the current dataPosition(), growing dataCapacity() if needed.  The Map keys must be String objects.
 */
void writeArrayMapInternal(ArrayMap<String,Object> val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  final int N=val.size();
  writeInt(N);
  if (DEBUG_ARRAY_MAP) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Log.d(TAG,""String_Node_Str"" + N + ""String_Node_Str"",here);
  }
  for (int i=0; i < N; i++) {
    if (DEBUG_ARRAY_MAP)     Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ (val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0)+ ""String_Node_Str""+ val.keyAt(i));
    writeValue(val.keyAt(i));
    writeValue(val.valueAt(i));
  }
}"
1332,"final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedByAm && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
killUnneededProcessLocked(app,""String_Node_Str"" + numCached);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
killUnneededProcessLocked(app,""String_Node_Str"" + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000) + ""String_Node_Str"");
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
killUnneededProcessLocked(app,""String_Node_Str"" + numEmpty);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
killUnneededProcessLocked(app,""String_Node_Str"");
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
final int numCachedAndEmpty=numCached + numEmpty;
int memFactor;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
memFactor=ProcessStats.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
memFactor=ProcessStats.ADJ_MEM_FACTOR_LOW;
}
 else {
memFactor=ProcessStats.ADJ_MEM_FACTOR_MODERATE;
}
}
 else {
memFactor=ProcessStats.ADJ_MEM_FACTOR_NORMAL;
}
if (DEBUG_OOM_ADJ) Slog.d(TAG,""String_Node_Str"" + memFactor + ""String_Node_Str""+ mLastMemoryLevel+ ""String_Node_Str""+ mAllowLowerMemLevel+ ""String_Node_Str""+ mLruProcesses.size()+ ""String_Node_Str""+ mLastNumProcesses);
if (memFactor > mLastMemoryLevel) {
if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {
memFactor=mLastMemoryLevel;
if (DEBUG_OOM_ADJ) Slog.d(TAG,""String_Node_Str"");
}
}
mLastMemoryLevel=memFactor;
mLastNumProcesses=mLruProcesses.size();
boolean allChanged=mProcessStats.setMemFactorLocked(ProcessStats.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
final int trackerMemFactor=mProcessStats.getMemFactorLocked();
if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {
if (mLowRamStartTime == 0) {
mLowRamStartTime=now;
}
int step=0;
int fgTrimLevel;
switch (memFactor) {
case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
break;
case ProcessStats.ADJ_MEM_FACTOR_LOW:
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
break;
default :
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
break;
}
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
setProcessTrackerState(app,trackerMemFactor,now);
app.procStateChanged=false;
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
if (mLowRamStartTime != 0) {
mLowRamTimeSinceLastIdle+=now - mLowRamStartTime;
mLowRamStartTime=0;
}
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
setProcessTrackerState(app,trackerMemFactor,now);
app.procStateChanged=false;
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false,mProcessStats.isMemFactorLowered());
}
if (mProcessStats.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessStats.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}","final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedByAm && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
killUnneededProcessLocked(app,""String_Node_Str"" + numCached);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
killUnneededProcessLocked(app,""String_Node_Str"" + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000) + ""String_Node_Str"");
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
killUnneededProcessLocked(app,""String_Node_Str"" + numEmpty);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
killUnneededProcessLocked(app,""String_Node_Str"");
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
final int numCachedAndEmpty=numCached + numEmpty;
int memFactor;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
memFactor=ProcessStats.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
memFactor=ProcessStats.ADJ_MEM_FACTOR_LOW;
}
 else {
memFactor=ProcessStats.ADJ_MEM_FACTOR_MODERATE;
}
}
 else {
memFactor=ProcessStats.ADJ_MEM_FACTOR_NORMAL;
}
if (DEBUG_OOM_ADJ) Slog.d(TAG,""String_Node_Str"" + memFactor + ""String_Node_Str""+ mLastMemoryLevel+ ""String_Node_Str""+ mAllowLowerMemLevel+ ""String_Node_Str""+ mLruProcesses.size()+ ""String_Node_Str""+ mLastNumProcesses);
if (memFactor > mLastMemoryLevel) {
if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {
memFactor=mLastMemoryLevel;
if (DEBUG_OOM_ADJ) Slog.d(TAG,""String_Node_Str"");
}
}
mLastMemoryLevel=memFactor;
mLastNumProcesses=mLruProcesses.size();
boolean allChanged=mProcessStats.setMemFactorLocked(memFactor,!mSleeping,now);
final int trackerMemFactor=mProcessStats.getMemFactorLocked();
if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {
if (mLowRamStartTime == 0) {
mLowRamStartTime=now;
}
int step=0;
int fgTrimLevel;
switch (memFactor) {
case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
break;
case ProcessStats.ADJ_MEM_FACTOR_LOW:
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
break;
default :
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
break;
}
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
setProcessTrackerState(app,trackerMemFactor,now);
app.procStateChanged=false;
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
if (mLowRamStartTime != 0) {
mLowRamTimeSinceLastIdle+=now - mLowRamStartTime;
mLowRamStartTime=0;
}
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
setProcessTrackerState(app,trackerMemFactor,now);
app.procStateChanged=false;
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false,mProcessStats.isMemFactorLowered());
}
if (mProcessStats.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessStats.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}"
1333,"/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(0x4C444E42);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      parcel.writeInt(-1);
      parcel.writeInt(0x4C444E42);
      int oldPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int newPos=parcel.dataPosition();
      parcel.setDataPosition(oldPos - 8);
      int length=newPos - oldPos;
      parcel.writeInt(length);
      parcel.setDataPosition(newPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}","/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      parcel.writeInt(-1);
      parcel.writeInt(BUNDLE_MAGIC);
      int oldPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int newPos=parcel.dataPosition();
      parcel.setDataPosition(oldPos - 8);
      int length=newPos - oldPos;
      parcel.writeInt(length);
      parcel.setDataPosition(newPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}"
1334,"void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != 0x4C444E42) {
    String st=Log.getStackTraceString(new RuntimeException());
    Log.e(""String_Node_Str"",""String_Node_Str"");
    Log.e(""String_Node_Str"",""String_Node_Str"" + st);
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  p.setDataPosition(0);
  mParcelledData=p;
  mHasFds=p.hasFileDescriptors();
  mFdsKnown=true;
}","void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != BUNDLE_MAGIC) {
    throw new IllegalStateException(""String_Node_Str"" + Integer.toHexString(magic));
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  p.setDataPosition(0);
  if (mMap != null) {
    if (mFdsKnown) {
      mHasFds|=p.hasFileDescriptors();
    }
    int N=p.readInt();
    p.readArrayMapSafelyInternal(mMap,N,mClassLoader);
    p.recycle();
  }
 else {
    mParcelledData=p;
    mHasFds=p.hasFileDescriptors();
    mFdsKnown=true;
  }
}"
1335,"void readArrayMapInternal(ArrayMap outVal,int N,ClassLoader loader){
  while (N > 0) {
    Object key=readValue(loader);
    Object value=readValue(loader);
    outVal.append(key,value);
    N--;
  }
}","void readArrayMapInternal(ArrayMap outVal,int N,ClassLoader loader){
  if (DEBUG_ARRAY_MAP) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Log.d(TAG,""String_Node_Str"" + N + ""String_Node_Str"",here);
  }
  while (N > 0) {
    Object key=readValue(loader);
    if (DEBUG_ARRAY_MAP)     Log.d(TAG,""String_Node_Str"" + (N - 1) + ""String_Node_Str""+ (key != null ? key.hashCode() : 0)+ ""String_Node_Str""+ key);
    Object value=readValue(loader);
    outVal.append(key,value);
    N--;
  }
}"
1336,"/** 
 * Flatten an ArrayMap into the parcel at the current dataPosition(), growing dataCapacity() if needed.  The Map keys must be String objects.
 */
void writeArrayMapInternal(ArrayMap<String,Object> val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  final int N=val.size();
  writeInt(N);
  for (int i=0; i < N; i++) {
    writeValue(val.keyAt(i));
    writeValue(val.valueAt(i));
  }
}","/** 
 * Flatten an ArrayMap into the parcel at the current dataPosition(), growing dataCapacity() if needed.  The Map keys must be String objects.
 */
void writeArrayMapInternal(ArrayMap<String,Object> val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  final int N=val.size();
  writeInt(N);
  if (DEBUG_ARRAY_MAP) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Log.d(TAG,""String_Node_Str"" + N + ""String_Node_Str"",here);
  }
  for (int i=0; i < N; i++) {
    if (DEBUG_ARRAY_MAP)     Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ (val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0)+ ""String_Node_Str""+ val.keyAt(i));
    writeValue(val.keyAt(i));
    writeValue(val.valueAt(i));
  }
}"
1337,"/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(0x4C444E42);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      parcel.writeInt(-1);
      parcel.writeInt(0x4C444E42);
      int oldPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int newPos=parcel.dataPosition();
      parcel.setDataPosition(oldPos - 8);
      int length=newPos - oldPos;
      parcel.writeInt(length);
      parcel.setDataPosition(newPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}","/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  final boolean oldAllowFds=parcel.pushAllowFds(mAllowFds);
  try {
    if (mParcelledData != null) {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
 else {
      parcel.writeInt(-1);
      parcel.writeInt(BUNDLE_MAGIC);
      int oldPos=parcel.dataPosition();
      parcel.writeArrayMapInternal(mMap);
      int newPos=parcel.dataPosition();
      parcel.setDataPosition(oldPos - 8);
      int length=newPos - oldPos;
      parcel.writeInt(length);
      parcel.setDataPosition(newPos);
    }
  }
  finally {
    parcel.restoreAllowFds(oldAllowFds);
  }
}"
1338,"void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != 0x4C444E42) {
    String st=Log.getStackTraceString(new RuntimeException());
    Log.e(""String_Node_Str"",""String_Node_Str"");
    Log.e(""String_Node_Str"",""String_Node_Str"" + st);
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  p.setDataPosition(0);
  mParcelledData=p;
  mHasFds=p.hasFileDescriptors();
  mFdsKnown=true;
}","void readFromParcelInner(Parcel parcel,int length){
  int magic=parcel.readInt();
  if (magic != BUNDLE_MAGIC) {
    throw new IllegalStateException(""String_Node_Str"" + Integer.toHexString(magic));
  }
  int offset=parcel.dataPosition();
  parcel.setDataPosition(offset + length);
  Parcel p=Parcel.obtain();
  p.setDataPosition(0);
  p.appendFrom(parcel,offset,length);
  p.setDataPosition(0);
  if (mMap != null) {
    if (mFdsKnown) {
      mHasFds|=p.hasFileDescriptors();
    }
    int N=p.readInt();
    p.readArrayMapSafelyInternal(mMap,N,mClassLoader);
    p.recycle();
  }
 else {
    mParcelledData=p;
    mHasFds=p.hasFileDescriptors();
    mFdsKnown=true;
  }
}"
1339,"void readArrayMapInternal(ArrayMap outVal,int N,ClassLoader loader){
  while (N > 0) {
    Object key=readValue(loader);
    Object value=readValue(loader);
    outVal.append(key,value);
    N--;
  }
}","void readArrayMapInternal(ArrayMap outVal,int N,ClassLoader loader){
  if (DEBUG_ARRAY_MAP) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Log.d(TAG,""String_Node_Str"" + N + ""String_Node_Str"",here);
  }
  while (N > 0) {
    Object key=readValue(loader);
    if (DEBUG_ARRAY_MAP)     Log.d(TAG,""String_Node_Str"" + (N - 1) + ""String_Node_Str""+ (key != null ? key.hashCode() : 0)+ ""String_Node_Str""+ key);
    Object value=readValue(loader);
    outVal.append(key,value);
    N--;
  }
}"
1340,"/** 
 * Flatten an ArrayMap into the parcel at the current dataPosition(), growing dataCapacity() if needed.  The Map keys must be String objects.
 */
void writeArrayMapInternal(ArrayMap<String,Object> val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  final int N=val.size();
  writeInt(N);
  for (int i=0; i < N; i++) {
    writeValue(val.keyAt(i));
    writeValue(val.valueAt(i));
  }
}","/** 
 * Flatten an ArrayMap into the parcel at the current dataPosition(), growing dataCapacity() if needed.  The Map keys must be String objects.
 */
void writeArrayMapInternal(ArrayMap<String,Object> val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  final int N=val.size();
  writeInt(N);
  if (DEBUG_ARRAY_MAP) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Log.d(TAG,""String_Node_Str"" + N + ""String_Node_Str"",here);
  }
  for (int i=0; i < N; i++) {
    if (DEBUG_ARRAY_MAP)     Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ (val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0)+ ""String_Node_Str""+ val.keyAt(i));
    writeValue(val.keyAt(i));
    writeValue(val.valueAt(i));
  }
}"
1341,"final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        targetStack.mLastPausedActivity=null;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && (curTop.task != intentActivity.task) || curTop.task != lastStack.topTask()) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || (sourceStack.topActivity() != null && sourceStack.topActivity().task == sourceRecord.task)) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            intentActivity.mLaunchHomeTaskNext=false;
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            topStack.mLastPausedActivity=null;
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.mLastPausedActivity=null;
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  mService.setFocusedActivityLocked(r);
  return ActivityManager.START_SUCCESS;
}","final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        targetStack.mLastPausedActivity=null;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && (curTop.task != intentActivity.task || curTop.task != lastStack.topTask())) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || (sourceStack.topActivity() != null && sourceStack.topActivity().task == sourceRecord.task)) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            intentActivity.mLaunchHomeTaskNext=false;
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            topStack.mLastPausedActivity=null;
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.mLastPausedActivity=null;
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  mService.setFocusedActivityLocked(r);
  return ActivityManager.START_SUCCESS;
}"
1342,"private final void setProcessTrackerState(ProcessRecord proc,int memFactor,long now){
  if (proc.thread != null) {
    proc.baseProcessTracker.setState(proc.repProcState,memFactor,now,proc.pkgList);
  }
}","private final void setProcessTrackerState(ProcessRecord proc,int memFactor,long now){
  if (proc.thread != null && proc.baseProcessTracker != null) {
    proc.baseProcessTracker.setState(proc.repProcState,memFactor,now,proc.pkgList);
  }
}"
1343,"public boolean addPackage(String pkg,ProcessStatsService tracker){
  if (!pkgList.containsKey(pkg)) {
    pkgList.put(pkg,tracker.getProcessStateLocked(pkg,info.uid,processName));
    return true;
  }
  return false;
}","public boolean addPackage(String pkg,ProcessStatsService tracker){
  if (!pkgList.containsKey(pkg)) {
    pkgList.put(pkg,baseProcessTracker != null ? tracker.getProcessStateLocked(pkg,info.uid,processName) : null);
    return true;
  }
  return false;
}"
1344,"public void resetPackageList(ProcessStatsService tracker){
  long now=SystemClock.uptimeMillis();
  baseProcessTracker.setState(ProcessStats.STATE_NOTHING,tracker.getMemFactorLocked(),now,pkgList);
  final int N=pkgList.size();
  if (N != 1) {
    for (int i=0; i < N; i++) {
      ProcessStats.ProcessState ps=pkgList.valueAt(i);
      if (ps != null && ps != baseProcessTracker) {
        ps.makeInactive();
      }
    }
    pkgList.clear();
    ProcessStats.ProcessState ps=tracker.getProcessStateLocked(info.packageName,info.uid,processName);
    pkgList.put(info.packageName,ps);
    if (thread != null && ps != baseProcessTracker) {
      ps.makeActive();
    }
  }
}","public void resetPackageList(ProcessStatsService tracker){
  final int N=pkgList.size();
  if (baseProcessTracker != null) {
    long now=SystemClock.uptimeMillis();
    baseProcessTracker.setState(ProcessStats.STATE_NOTHING,tracker.getMemFactorLocked(),now,pkgList);
    if (N != 1) {
      for (int i=0; i < N; i++) {
        ProcessStats.ProcessState ps=pkgList.valueAt(i);
        if (ps != null && ps != baseProcessTracker) {
          ps.makeInactive();
        }
      }
      pkgList.clear();
      ProcessStats.ProcessState ps=tracker.getProcessStateLocked(info.packageName,info.uid,processName);
      pkgList.put(info.packageName,ps);
      if (thread != null && ps != baseProcessTracker) {
        ps.makeActive();
      }
    }
  }
 else   if (N != 1) {
    pkgList.clear();
    pkgList.put(info.packageName,null);
  }
}"
1345,"private final void setProcessTrackerState(ProcessRecord proc,int memFactor,long now){
  if (proc.thread != null) {
    proc.baseProcessTracker.setState(proc.repProcState,memFactor,now,proc.pkgList);
  }
}","private final void setProcessTrackerState(ProcessRecord proc,int memFactor,long now){
  if (proc.thread != null && proc.baseProcessTracker != null) {
    proc.baseProcessTracker.setState(proc.repProcState,memFactor,now,proc.pkgList);
  }
}"
1346,"public boolean addPackage(String pkg,ProcessStatsService tracker){
  if (!pkgList.containsKey(pkg)) {
    pkgList.put(pkg,tracker.getProcessStateLocked(pkg,info.uid,processName));
    return true;
  }
  return false;
}","public boolean addPackage(String pkg,ProcessStatsService tracker){
  if (!pkgList.containsKey(pkg)) {
    pkgList.put(pkg,baseProcessTracker != null ? tracker.getProcessStateLocked(pkg,info.uid,processName) : null);
    return true;
  }
  return false;
}"
1347,"public void resetPackageList(ProcessStatsService tracker){
  long now=SystemClock.uptimeMillis();
  baseProcessTracker.setState(ProcessStats.STATE_NOTHING,tracker.getMemFactorLocked(),now,pkgList);
  final int N=pkgList.size();
  if (N != 1) {
    for (int i=0; i < N; i++) {
      ProcessStats.ProcessState ps=pkgList.valueAt(i);
      if (ps != null && ps != baseProcessTracker) {
        ps.makeInactive();
      }
    }
    pkgList.clear();
    ProcessStats.ProcessState ps=tracker.getProcessStateLocked(info.packageName,info.uid,processName);
    pkgList.put(info.packageName,ps);
    if (thread != null && ps != baseProcessTracker) {
      ps.makeActive();
    }
  }
}","public void resetPackageList(ProcessStatsService tracker){
  final int N=pkgList.size();
  if (baseProcessTracker != null) {
    long now=SystemClock.uptimeMillis();
    baseProcessTracker.setState(ProcessStats.STATE_NOTHING,tracker.getMemFactorLocked(),now,pkgList);
    if (N != 1) {
      for (int i=0; i < N; i++) {
        ProcessStats.ProcessState ps=pkgList.valueAt(i);
        if (ps != null && ps != baseProcessTracker) {
          ps.makeInactive();
        }
      }
      pkgList.clear();
      ProcessStats.ProcessState ps=tracker.getProcessStateLocked(info.packageName,info.uid,processName);
      pkgList.put(info.packageName,ps);
      if (thread != null && ps != baseProcessTracker) {
        ps.makeActive();
      }
    }
  }
 else   if (N != 1) {
    pkgList.clear();
    pkgList.put(info.packageName,null);
  }
}"
1348,"final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        targetStack.mLastPausedActivity=null;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && (curTop.task != intentActivity.task) || curTop.task != lastStack.topTask()) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || (sourceStack.topActivity() != null && sourceStack.topActivity().task == sourceRecord.task)) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            intentActivity.mLaunchHomeTaskNext=false;
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            topStack.mLastPausedActivity=null;
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.mLastPausedActivity=null;
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  mService.setFocusedActivityLocked(r);
  return ActivityManager.START_SUCCESS;
}","final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        targetStack.mLastPausedActivity=null;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && (curTop.task != intentActivity.task || curTop.task != lastStack.topTask())) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || (sourceStack.topActivity() != null && sourceStack.topActivity().task == sourceRecord.task)) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            intentActivity.mLaunchHomeTaskNext=false;
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            topStack.mLastPausedActivity=null;
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.mLastPausedActivity=null;
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  mService.setFocusedActivityLocked(r);
  return ActivityManager.START_SUCCESS;
}"
1349,"final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        targetStack.mLastPausedActivity=null;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && (curTop.task != intentActivity.task) || curTop.task != lastStack.topTask()) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || (sourceStack.topActivity() != null && sourceStack.topActivity().task == sourceRecord.task)) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            intentActivity.mLaunchHomeTaskNext=false;
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            topStack.mLastPausedActivity=null;
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.mLastPausedActivity=null;
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  mService.setFocusedActivityLocked(r);
  return ActivityManager.START_SUCCESS;
}","final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        targetStack.mLastPausedActivity=null;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && (curTop.task != intentActivity.task || curTop.task != lastStack.topTask())) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || (sourceStack.topActivity() != null && sourceStack.topActivity().task == sourceRecord.task)) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            intentActivity.mLaunchHomeTaskNext=false;
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            topStack.mLastPausedActivity=null;
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.mLastPausedActivity=null;
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  mService.setFocusedActivityLocked(r);
  return ActivityManager.START_SUCCESS;
}"
1350,"private final void setProcessTrackerState(ProcessRecord proc,int memFactor,long now){
  if (proc.thread != null) {
    proc.baseProcessTracker.setState(proc.repProcState,memFactor,now,proc.pkgList);
  }
}","private final void setProcessTrackerState(ProcessRecord proc,int memFactor,long now){
  if (proc.thread != null && proc.baseProcessTracker != null) {
    proc.baseProcessTracker.setState(proc.repProcState,memFactor,now,proc.pkgList);
  }
}"
1351,"public boolean addPackage(String pkg,ProcessStatsService tracker){
  if (!pkgList.containsKey(pkg)) {
    pkgList.put(pkg,tracker.getProcessStateLocked(pkg,info.uid,processName));
    return true;
  }
  return false;
}","public boolean addPackage(String pkg,ProcessStatsService tracker){
  if (!pkgList.containsKey(pkg)) {
    pkgList.put(pkg,baseProcessTracker != null ? tracker.getProcessStateLocked(pkg,info.uid,processName) : null);
    return true;
  }
  return false;
}"
1352,"public void resetPackageList(ProcessStatsService tracker){
  long now=SystemClock.uptimeMillis();
  baseProcessTracker.setState(ProcessStats.STATE_NOTHING,tracker.getMemFactorLocked(),now,pkgList);
  final int N=pkgList.size();
  if (N != 1) {
    for (int i=0; i < N; i++) {
      ProcessStats.ProcessState ps=pkgList.valueAt(i);
      if (ps != null && ps != baseProcessTracker) {
        ps.makeInactive();
      }
    }
    pkgList.clear();
    ProcessStats.ProcessState ps=tracker.getProcessStateLocked(info.packageName,info.uid,processName);
    pkgList.put(info.packageName,ps);
    if (thread != null && ps != baseProcessTracker) {
      ps.makeActive();
    }
  }
}","public void resetPackageList(ProcessStatsService tracker){
  final int N=pkgList.size();
  if (baseProcessTracker != null) {
    long now=SystemClock.uptimeMillis();
    baseProcessTracker.setState(ProcessStats.STATE_NOTHING,tracker.getMemFactorLocked(),now,pkgList);
    if (N != 1) {
      for (int i=0; i < N; i++) {
        ProcessStats.ProcessState ps=pkgList.valueAt(i);
        if (ps != null && ps != baseProcessTracker) {
          ps.makeInactive();
        }
      }
      pkgList.clear();
      ProcessStats.ProcessState ps=tracker.getProcessStateLocked(info.packageName,info.uid,processName);
      pkgList.put(info.packageName,ps);
      if (thread != null && ps != baseProcessTracker) {
        ps.makeActive();
      }
    }
  }
 else   if (N != 1) {
    pkgList.clear();
    pkgList.put(info.packageName,null);
  }
}"
1353,"final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        targetStack.mLastPausedActivity=null;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && (curTop.task != intentActivity.task) || curTop.task != lastStack.topTask()) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || (sourceStack.topActivity() != null && sourceStack.topActivity().task == sourceRecord.task)) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            intentActivity.mLaunchHomeTaskNext=false;
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            topStack.mLastPausedActivity=null;
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.mLastPausedActivity=null;
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  mService.setFocusedActivityLocked(r);
  return ActivityManager.START_SUCCESS;
}","final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        targetStack.mLastPausedActivity=null;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && (curTop.task != intentActivity.task || curTop.task != lastStack.topTask())) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || (sourceStack.topActivity() != null && sourceStack.topActivity().task == sourceRecord.task)) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            intentActivity.mLaunchHomeTaskNext=false;
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            topStack.mLastPausedActivity=null;
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.mLastPausedActivity=null;
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  mService.setFocusedActivityLocked(r);
  return ActivityManager.START_SUCCESS;
}"
1354,"final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        targetStack.mLastPausedActivity=null;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && (curTop.task != intentActivity.task) || curTop.task != lastStack.topTask()) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || (sourceStack.topActivity() != null && sourceStack.topActivity().task == sourceRecord.task)) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            intentActivity.mLaunchHomeTaskNext=false;
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            topStack.mLastPausedActivity=null;
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.mLastPausedActivity=null;
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  mService.setFocusedActivityLocked(r);
  return ActivityManager.START_SUCCESS;
}","final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        targetStack.mLastPausedActivity=null;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && (curTop.task != intentActivity.task || curTop.task != lastStack.topTask())) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || (sourceStack.topActivity() != null && sourceStack.topActivity().task == sourceRecord.task)) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            intentActivity.mLaunchHomeTaskNext=false;
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            topStack.mLastPausedActivity=null;
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        targetStack.mLastPausedActivity=null;
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=adjustStackFocus(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.mLastPausedActivity=null;
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  mService.setFocusedActivityLocked(r);
  return ActivityManager.START_SUCCESS;
}"
1355,"private final void setProcessTrackerState(ProcessRecord proc,int memFactor,long now){
  if (proc.thread != null) {
    proc.baseProcessTracker.setState(proc.repProcState,memFactor,now,proc.pkgList);
  }
}","private final void setProcessTrackerState(ProcessRecord proc,int memFactor,long now){
  if (proc.thread != null && proc.baseProcessTracker != null) {
    proc.baseProcessTracker.setState(proc.repProcState,memFactor,now,proc.pkgList);
  }
}"
1356,"public boolean addPackage(String pkg,ProcessStatsService tracker){
  if (!pkgList.containsKey(pkg)) {
    pkgList.put(pkg,tracker.getProcessStateLocked(pkg,info.uid,processName));
    return true;
  }
  return false;
}","public boolean addPackage(String pkg,ProcessStatsService tracker){
  if (!pkgList.containsKey(pkg)) {
    pkgList.put(pkg,baseProcessTracker != null ? tracker.getProcessStateLocked(pkg,info.uid,processName) : null);
    return true;
  }
  return false;
}"
1357,"public void resetPackageList(ProcessStatsService tracker){
  long now=SystemClock.uptimeMillis();
  baseProcessTracker.setState(ProcessStats.STATE_NOTHING,tracker.getMemFactorLocked(),now,pkgList);
  final int N=pkgList.size();
  if (N != 1) {
    for (int i=0; i < N; i++) {
      ProcessStats.ProcessState ps=pkgList.valueAt(i);
      if (ps != null && ps != baseProcessTracker) {
        ps.makeInactive();
      }
    }
    pkgList.clear();
    ProcessStats.ProcessState ps=tracker.getProcessStateLocked(info.packageName,info.uid,processName);
    pkgList.put(info.packageName,ps);
    if (thread != null && ps != baseProcessTracker) {
      ps.makeActive();
    }
  }
}","public void resetPackageList(ProcessStatsService tracker){
  final int N=pkgList.size();
  if (baseProcessTracker != null) {
    long now=SystemClock.uptimeMillis();
    baseProcessTracker.setState(ProcessStats.STATE_NOTHING,tracker.getMemFactorLocked(),now,pkgList);
    if (N != 1) {
      for (int i=0; i < N; i++) {
        ProcessStats.ProcessState ps=pkgList.valueAt(i);
        if (ps != null && ps != baseProcessTracker) {
          ps.makeInactive();
        }
      }
      pkgList.clear();
      ProcessStats.ProcessState ps=tracker.getProcessStateLocked(info.packageName,info.uid,processName);
      pkgList.put(info.packageName,ps);
      if (thread != null && ps != baseProcessTracker) {
        ps.makeActive();
      }
    }
  }
 else   if (N != 1) {
    pkgList.clear();
    pkgList.put(info.packageName,null);
  }
}"
1358,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STATS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid);
    if (proc == null || proc.curProcState >= ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STATS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STATS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STATS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STATS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STATS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STATS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STATS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}"
1359,"static private void dumpHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}","static private void dumpHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}"
1360,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
          writeStateLocked(true,true);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          writeStateSyncLocked();
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          readLocked(mProcessStats,mFile);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              processStats.dumpSummaryLocked(pw,reqPackage,now);
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
          writeStateLocked(true,true);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          mProcessStats.resetSafely();
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          writeStateSyncLocked();
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          readLocked(mProcessStats,mFile);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              processStats.dumpSummaryLocked(pw,reqPackage,now);
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}"
1361,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STATS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid);
    if (proc == null || proc.curProcState >= ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STATS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STATS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STATS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STATS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STATS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STATS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STATS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}"
1362,"static private void dumpHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}","static private void dumpHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}"
1363,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
          writeStateLocked(true,true);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          writeStateSyncLocked();
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          readLocked(mProcessStats,mFile);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              processStats.dumpSummaryLocked(pw,reqPackage,now);
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
          writeStateLocked(true,true);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          mProcessStats.resetSafely();
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          writeStateSyncLocked();
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          readLocked(mProcessStats,mFile);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              processStats.dumpSummaryLocked(pw,reqPackage,now);
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}"
1364,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STATS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid);
    if (proc == null || proc.curProcState >= ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STATS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STATS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STATS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STATS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STATS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STATS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STATS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}"
1365,"static private void dumpHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}","static private void dumpHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}"
1366,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
          writeStateLocked(true,true);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          writeStateSyncLocked();
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          readLocked(mProcessStats,mFile);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              processStats.dumpSummaryLocked(pw,reqPackage,now);
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
          writeStateLocked(true,true);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          mProcessStats.resetSafely();
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          writeStateSyncLocked();
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          readLocked(mProcessStats,mFile);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              processStats.dumpSummaryLocked(pw,reqPackage,now);
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}"
1367,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STATS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid);
    if (proc == null || proc.curProcState >= ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STATS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STATS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STATS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STATS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STATS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STATS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STATS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}"
1368,"static private void dumpHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}","static private void dumpHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}"
1369,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
          writeStateLocked(true,true);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          writeStateSyncLocked();
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          readLocked(mProcessStats,mFile);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              processStats.dumpSummaryLocked(pw,reqPackage,now);
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
          writeStateLocked(true,true);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          mProcessStats.resetSafely();
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          writeStateSyncLocked();
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mAm) {
          readLocked(mProcessStats,mFile);
          pw.println(""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              processStats.dumpSummaryLocked(pw,reqPackage,now);
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}"
1370,"private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (proc.mMultiPackage) {
    proc=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid).mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}","private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (proc.mMultiPackage) {
    PackageState pkg=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid);
    if (pkg == null) {
      throw new IllegalStateException(""String_Node_Str"" + pkgList.keyAt(index) + ""String_Node_Str""+ proc.mName);
    }
    proc=pkg.mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}"
1371,"private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (proc.mMultiPackage) {
    proc=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid).mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}","private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (proc.mMultiPackage) {
    PackageState pkg=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid);
    if (pkg == null) {
      throw new IllegalStateException(""String_Node_Str"" + pkgList.keyAt(index) + ""String_Node_Str""+ proc.mName);
    }
    proc=pkg.mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}"
1372,"private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (proc.mMultiPackage) {
    proc=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid).mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}","private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (proc.mMultiPackage) {
    PackageState pkg=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid);
    if (pkg == null) {
      throw new IllegalStateException(""String_Node_Str"" + pkgList.keyAt(index) + ""String_Node_Str""+ proc.mName);
    }
    proc=pkg.mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}"
1373,"private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (proc.mMultiPackage) {
    proc=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid).mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}","private ProcessState pullFixedProc(ArrayMap<String,ProcessState> pkgList,int index){
  ProcessState proc=pkgList.valueAt(index);
  if (proc.mMultiPackage) {
    PackageState pkg=mStats.mPackages.get(pkgList.keyAt(index),proc.mUid);
    if (pkg == null) {
      throw new IllegalStateException(""String_Node_Str"" + pkgList.keyAt(index) + ""String_Node_Str""+ proc.mName);
    }
    proc=pkg.mProcesses.get(proc.mName);
    if (proc == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pkgList.setValueAt(index,proc);
  }
  return proc;
}"
1374,"void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mPendingServices.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}","void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mDelayedStartList.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}"
1375,"void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mPendingServices.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}","void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mDelayedStartList.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}"
1376,"void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mPendingServices.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}","void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mDelayedStartList.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}"
1377,"void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mPendingServices.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}","void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mDelayedStartList.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}"
1378,"/** 
 * @hide 
 */
public int startOp(int op){
  return startOp(op,Process.myUid(),mContext.getBasePackageName());
}","/** 
 * @hide 
 */
public int startOp(int op){
  return startOp(op,Process.myUid(),mContext.getOpPackageName());
}"
1379,"public void finishOp(int op){
  finishOp(op,Process.myUid(),mContext.getBasePackageName());
}","public void finishOp(int op){
  finishOp(op,Process.myUid(),mContext.getOpPackageName());
}"
1380,"/** 
 * @hide 
 */
public int noteOp(int op){
  return noteOp(op,Process.myUid(),mContext.getBasePackageName());
}","/** 
 * @hide 
 */
public int noteOp(int op){
  return noteOp(op,Process.myUid(),mContext.getOpPackageName());
}"
1381,"/** 
 * Do a quick check for whether an application might be able to perform an operation. This is <em>not</em> a security check; you must use   {@link #noteOp(int,int,String)}or   {@link #startOp(int,int,String)} for your actual security checks, which alsoensure that the given uid and package name are consistent.  This function can just be used for a quick check to see if an operation has been disabled for the application, as an early reject of some work.  This does not modify the time stamp or other data about the operation.
 * @param op The operation to check.  One of the OP_* constants.
 * @param uid The user id of the application attempting to perform the operation.
 * @param packageName The name of the application attempting to perform the operation.
 * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or{@link #MODE_IGNORED} if it is not allowed and should be silently ignored (withoutcausing the app to crash).
 * @throws SecurityException If the app has been configured to crash on this op.
 */
public int checkOp(int op,int uid,String packageName){
  try {
    int mode=mService.checkOperation(op,uid,packageName);
    if (mode == MODE_ERRORED) {
      throw new SecurityException(""String_Node_Str"");
    }
    return mode;
  }
 catch (  RemoteException e) {
  }
  return MODE_IGNORED;
}","/** 
 * Do a quick check for whether an application might be able to perform an operation. This is <em>not</em> a security check; you must use   {@link #noteOp(int,int,String)}or   {@link #startOp(int,int,String)} for your actual security checks, which alsoensure that the given uid and package name are consistent.  This function can just be used for a quick check to see if an operation has been disabled for the application, as an early reject of some work.  This does not modify the time stamp or other data about the operation.
 * @param op The operation to check.  One of the OP_* constants.
 * @param uid The user id of the application attempting to perform the operation.
 * @param packageName The name of the application attempting to perform the operation.
 * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or{@link #MODE_IGNORED} if it is not allowed and should be silently ignored (withoutcausing the app to crash).
 * @throws SecurityException If the app has been configured to crash on this op.
 */
public int checkOp(int op,int uid,String packageName){
  try {
    int mode=mService.checkOperation(op,uid,packageName);
    if (mode == MODE_ERRORED) {
      throw new SecurityException(buildSecurityExceptionMsg(op,uid,packageName));
    }
    return mode;
  }
 catch (  RemoteException e) {
  }
  return MODE_IGNORED;
}"
1382,"@Override public void setApplicationEnabledSetting(String packageName,int newState,int flags){
  try {
    mPM.setApplicationEnabledSetting(packageName,newState,flags,mContext.getUserId(),mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
  }
}","@Override public void setApplicationEnabledSetting(String packageName,int newState,int flags){
  try {
    mPM.setApplicationEnabledSetting(packageName,newState,flags,mContext.getUserId(),mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
  }
}"
1383,"/** 
 * Create a new ApplicationContext from an existing one.  The new one works and operates the same as the one it is copying.
 * @param context Existing application context.
 */
public ContextImpl(ContextImpl context){
  mPackageInfo=context.mPackageInfo;
  mBasePackageName=context.mBasePackageName;
  mResources=context.mResources;
  mMainThread=context.mMainThread;
  mContentResolver=context.mContentResolver;
  mUser=context.mUser;
  mDisplay=context.mDisplay;
  mOuterContext=this;
  mDisplayAdjustments.setCompatibilityInfo(mPackageInfo.getCompatibilityInfo());
}","/** 
 * Create a new ApplicationContext from an existing one.  The new one works and operates the same as the one it is copying.
 * @param context Existing application context.
 */
public ContextImpl(ContextImpl context){
  mPackageInfo=context.mPackageInfo;
  mBasePackageName=context.mBasePackageName;
  mOpPackageName=context.mOpPackageName;
  mResources=context.mResources;
  mMainThread=context.mMainThread;
  mContentResolver=context.mContentResolver;
  mUser=context.mUser;
  mDisplay=context.mDisplay;
  mOuterContext=this;
  mDisplayAdjustments.setCompatibilityInfo(mPackageInfo.getCompatibilityInfo());
}"
1384,"final void init(Resources resources,ActivityThread mainThread,UserHandle user){
  mPackageInfo=null;
  mBasePackageName=null;
  mResources=resources;
  mMainThread=mainThread;
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
  mUser=user;
}","final void init(Resources resources,ActivityThread mainThread,UserHandle user){
  mPackageInfo=null;
  mBasePackageName=null;
  mOpPackageName=null;
  mResources=resources;
  mMainThread=mainThread;
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
  mUser=user;
}"
1385,"/** 
 * Post a notification to be shown in the status bar. If a notification with the same tag and id has already been posted by your application and has not yet been canceled, it will be replaced by the updated information.
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be uniquewithin your application.
 * @param notification A {@link Notification} object describing what toshow the user. Must not be null.
 */
public void notify(String tag,int id,Notification notification){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getBasePackageName(),tag,id,notification,idOut,UserHandle.myUserId());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}","/** 
 * Post a notification to be shown in the status bar. If a notification with the same tag and id has already been posted by your application and has not yet been canceled, it will be replaced by the updated information.
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be uniquewithin your application.
 * @param notification A {@link Notification} object describing what toshow the user. Must not be null.
 */
public void notify(String tag,int id,Notification notification){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getOpPackageName(),tag,id,notification,idOut,UserHandle.myUserId());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}"
1386,"/** 
 * @hide
 */
public void notifyAsUser(String tag,int id,Notification notification,UserHandle user){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getBasePackageName(),tag,id,notification,idOut,user.getIdentifier());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}","/** 
 * @hide
 */
public void notifyAsUser(String tag,int id,Notification notification,UserHandle user){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getOpPackageName(),tag,id,notification,idOut,user.getIdentifier());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}"
1387,"/** 
 * Returns true if there is currently a primary clip on the clipboard.
 */
public boolean hasPrimaryClip(){
  try {
    return getService().hasPrimaryClip(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}","/** 
 * Returns true if there is currently a primary clip on the clipboard.
 */
public boolean hasPrimaryClip(){
  try {
    return getService().hasPrimaryClip(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}"
1388,"/** 
 * Returns the current primary clip on the clipboard.
 */
public ClipData getPrimaryClip(){
  try {
    return getService().getPrimaryClip(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Returns the current primary clip on the clipboard.
 */
public ClipData getPrimaryClip(){
  try {
    return getService().getPrimaryClip(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}"
1389,"/** 
 * Returns a description of the current primary clip on the clipboard but not a copy of its data.
 */
public ClipDescription getPrimaryClipDescription(){
  try {
    return getService().getPrimaryClipDescription(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Returns a description of the current primary clip on the clipboard but not a copy of its data.
 */
public ClipDescription getPrimaryClipDescription(){
  try {
    return getService().getPrimaryClipDescription(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}"
1390,"public void addPrimaryClipChangedListener(OnPrimaryClipChangedListener what){
synchronized (mPrimaryClipChangedListeners) {
    if (mPrimaryClipChangedListeners.size() == 0) {
      try {
        getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener,mContext.getBasePackageName());
      }
 catch (      RemoteException e) {
      }
    }
    mPrimaryClipChangedListeners.add(what);
  }
}","public void addPrimaryClipChangedListener(OnPrimaryClipChangedListener what){
synchronized (mPrimaryClipChangedListeners) {
    if (mPrimaryClipChangedListeners.size() == 0) {
      try {
        getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener,mContext.getOpPackageName());
      }
 catch (      RemoteException e) {
      }
    }
    mPrimaryClipChangedListeners.add(what);
  }
}"
1391,"/** 
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
public boolean hasText(){
  try {
    return getService().hasClipboardText(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}","/** 
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
public boolean hasText(){
  try {
    return getService().hasClipboardText(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}"
1392,"/** 
 * Sets the current primary clip on the clipboard.  This is the clip that is involved in normal cut and paste operations.
 * @param clip The clipped data item to set.
 */
public void setPrimaryClip(ClipData clip){
  try {
    if (clip != null) {
      clip.prepareToLeaveProcess();
    }
    getService().setPrimaryClip(clip,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
  }
}","/** 
 * Sets the current primary clip on the clipboard.  This is the clip that is involved in normal cut and paste operations.
 * @param clip The clipped data item to set.
 */
public void setPrimaryClip(ClipData clip){
  try {
    if (clip != null) {
      clip.prepareToLeaveProcess();
    }
    getService().setPrimaryClip(clip,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
  }
}"
1393,"public ContentResolver(Context context){
  mContext=context != null ? context : ActivityThread.currentApplication();
  mPackageName=mContext.getBasePackageName();
}","public ContentResolver(Context context){
  mContext=context != null ? context : ActivityThread.currentApplication();
  mPackageName=mContext.getOpPackageName();
}"
1394,"/** 
 * Creates a new wake lock with the specified level and flags. <p> The   {@code levelAndFlags} parameter specifies a wake lock level and optional flagscombined using the logical OR operator. </p><p> The wake lock levels are:  {@link #PARTIAL_WAKE_LOCK},  {@link #FULL_WAKE_LOCK},   {@link #SCREEN_DIM_WAKE_LOCK}and   {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be specified as part of the   {@code levelAndFlags} parameter.</p><p> The wake lock flags are:  {@link #ACQUIRE_CAUSES_WAKEUP}and   {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the  {@code levelAndFlags} parameters.</p><p> Call  {@link WakeLock#acquire() acquire()} on the object to acquire thewake lock, and  {@link WakeLock#release release()} when you are done.</p><p> {@samplecode PowerManager pm = (PowerManager)mContext.getSystemService( Context.POWER_SERVICE); PowerManager.WakeLock wl = pm.newWakeLock( PowerManager.SCREEN_DIM_WAKE_LOCK | PowerManager.ON_AFTER_RELEASE, TAG); wl.acquire(); // ... do work... wl.release();}</p><p> Although a wake lock can be created without special permissions, the   {@link android.Manifest.permission#WAKE_LOCK} permission isrequired to actually acquire or release the wake lock that is returned. </p><p class=""note""> If using this to keep the screen on, you should strongly consider using {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. </p>
 * @param levelAndFlags Combination of wake lock level and flag values definingthe requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
public WakeLock newWakeLock(int levelAndFlags,String tag){
  validateWakeLockParameters(levelAndFlags,tag);
  return new WakeLock(levelAndFlags,tag,mContext.getBasePackageName());
}","/** 
 * Creates a new wake lock with the specified level and flags. <p> The   {@code levelAndFlags} parameter specifies a wake lock level and optional flagscombined using the logical OR operator. </p><p> The wake lock levels are:  {@link #PARTIAL_WAKE_LOCK},  {@link #FULL_WAKE_LOCK},   {@link #SCREEN_DIM_WAKE_LOCK}and   {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be specified as part of the   {@code levelAndFlags} parameter.</p><p> The wake lock flags are:  {@link #ACQUIRE_CAUSES_WAKEUP}and   {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the  {@code levelAndFlags} parameters.</p><p> Call  {@link WakeLock#acquire() acquire()} on the object to acquire thewake lock, and  {@link WakeLock#release release()} when you are done.</p><p> {@samplecode PowerManager pm = (PowerManager)mContext.getSystemService( Context.POWER_SERVICE); PowerManager.WakeLock wl = pm.newWakeLock( PowerManager.SCREEN_DIM_WAKE_LOCK | PowerManager.ON_AFTER_RELEASE, TAG); wl.acquire(); // ... do work... wl.release();}</p><p> Although a wake lock can be created without special permissions, the   {@link android.Manifest.permission#WAKE_LOCK} permission isrequired to actually acquire or release the wake lock that is returned. </p><p class=""note""> If using this to keep the screen on, you should strongly consider using {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. </p>
 * @param levelAndFlags Combination of wake lock level and flag values definingthe requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
public WakeLock newWakeLock(int levelAndFlags,String tag){
  validateWakeLockParameters(levelAndFlags,tag);
  return new WakeLock(levelAndFlags,tag,mContext.getOpPackageName());
}"
1395,"public SystemVibrator(Context context){
  mPackageName=context.getBasePackageName();
  mService=IVibratorService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
}","public SystemVibrator(Context context){
  mPackageName=context.getOpPackageName();
  mService=IVibratorService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
}"
1396,"/** 
 * Adjusts the master volume for the device's audio amplifier. <p>
 * @param steps The number of volume steps to adjust. A positivevalue will raise the volume.
 * @param flags One or more flags.
 * @hide
 */
public void adjustMasterVolume(int steps,int flags){
  IAudioService service=getService();
  try {
    service.adjustMasterVolume(steps,flags,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the master volume for the device's audio amplifier. <p>
 * @param steps The number of volume steps to adjust. A positivevalue will raise the volume.
 * @param flags One or more flags.
 * @hide
 */
public void adjustMasterVolume(int steps,int flags){
  IAudioService service=getService();
  try {
    service.adjustMasterVolume(steps,flags,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1397,"/** 
 * @hide Used internally by telephony package to request audio focus. Will cause the focus request to be associated with the ""voice communication"" identifier only used in AudioService to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL forthe establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended somedia applications resume after a call
 */
public void requestAudioFocusForCall(int streamType,int durationHint){
  IAudioService service=getService();
  try {
    service.requestAudioFocus(streamType,durationHint,mICallBack,null,MediaFocusControl.IN_VOICE_COMM_FOCUS_ID,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}","/** 
 * @hide Used internally by telephony package to request audio focus. Will cause the focus request to be associated with the ""voice communication"" identifier only used in AudioService to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL forthe establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended somedia applications resume after a call
 */
public void requestAudioFocusForCall(int streamType,int durationHint){
  IAudioService service=getService();
  try {
    service.requestAudioFocus(streamType,durationHint,mICallBack,null,MediaFocusControl.IN_VOICE_COMM_FOCUS_ID,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}"
1398,"/** 
 * Request audio focus. Send a request to obtain the audio focus
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Alternatively use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary requestthat benefits from the system not playing disruptive sounds like notifications, for usecases such as voice memo recording, or speech recognition. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l),mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * Request audio focus. Send a request to obtain the audio focus
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Alternatively use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary requestthat benefits from the system not playing disruptive sounds like notifications, for usecases such as voice memo recording, or speech recognition. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l),mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}"
1399,"/** 
 * Adjusts the volume of a particular stream by one step in a direction. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getBasePackageName());
    }
 else {
      service.adjustStreamVolume(streamType,direction,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of a particular stream by one step in a direction. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getOpPackageName());
    }
 else {
      service.adjustStreamVolume(streamType,direction,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1400,"/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getBasePackageName());
    }
 else {
      service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getOpPackageName());
    }
 else {
      service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1401,"/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getBasePackageName());
    }
 else {
      service.adjustVolume(direction,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getOpPackageName());
    }
 else {
      service.adjustVolume(direction,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1402,"/** 
 * Sets the volume index for master volume.
 * @param index The volume index to set. See{@link #getMasterMaxVolume()} for the largest valid value.
 * @param flags One or more flags.
 * @see #getMasterMaxVolume()
 * @see #getMasterVolume()
 * @hide
 */
public void setMasterVolume(int index,int flags){
  IAudioService service=getService();
  try {
    service.setMasterVolume(index,flags,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the volume index for master volume.
 * @param index The volume index to set. See{@link #getMasterMaxVolume()} for the largest valid value.
 * @param flags One or more flags.
 * @see #getMasterMaxVolume()
 * @see #getMasterVolume()
 * @hide
 */
public void setMasterVolume(int index,int flags){
  IAudioService service=getService();
  try {
    service.setMasterVolume(index,flags,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1403,"/** 
 * Sets the volume index for a particular stream.
 * @param streamType The stream whose volume index should be set.
 * @param index The volume index to set. See{@link #getStreamMaxVolume(int)} for the largest valid value.
 * @param flags One or more flags.
 * @see #getStreamMaxVolume(int)
 * @see #getStreamVolume(int)
 */
public void setStreamVolume(int streamType,int index,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.setMasterVolume(index,flags,mContext.getBasePackageName());
    }
 else {
      service.setStreamVolume(streamType,index,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the volume index for a particular stream.
 * @param streamType The stream whose volume index should be set.
 * @param index The volume index to set. See{@link #getStreamMaxVolume(int)} for the largest valid value.
 * @param flags One or more flags.
 * @see #getStreamMaxVolume(int)
 * @see #getStreamVolume(int)
 */
public void setStreamVolume(int streamType,int index,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.setMasterVolume(index,flags,mContext.getOpPackageName());
    }
 else {
      service.setStreamVolume(streamType,index,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1404,"/** 
 * @hide If the stream is active locally or remotely, adjust its volume according to the enforced priority rules. Note: only AudioManager.STREAM_MUSIC is supported at the moment
 */
public void adjustLocalOrRemoteStreamVolume(int streamType,int direction){
  if (streamType != STREAM_MUSIC) {
    Log.w(TAG,""String_Node_Str"" + streamType);
  }
  IAudioService service=getService();
  try {
    service.adjustLocalOrRemoteStreamVolume(streamType,direction,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * @hide If the stream is active locally or remotely, adjust its volume according to the enforced priority rules. Note: only AudioManager.STREAM_MUSIC is supported at the moment
 */
public void adjustLocalOrRemoteStreamVolume(int streamType,int direction){
  if (streamType != STREAM_MUSIC) {
    Log.w(TAG,""String_Node_Str"" + streamType);
  }
  IAudioService service=getService();
  try {
    service.adjustLocalOrRemoteStreamVolume(streamType,direction,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1405,"/** 
 * Tell the audio service to adjust the volume appropriate to the event.
 * @param keycode
 */
void handleVolumeKey(int stream,int keycode){
  IAudioService audioService=getAudioService();
  if (audioService == null) {
    return;
  }
  try {
    mBroadcastWakeLock.acquire();
    audioService.adjustStreamVolume(stream,keycode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER,0,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + e);
  }
 finally {
    mBroadcastWakeLock.release();
  }
}","/** 
 * Tell the audio service to adjust the volume appropriate to the event.
 * @param keycode
 */
void handleVolumeKey(int stream,int keycode){
  IAudioService audioService=getAudioService();
  if (audioService == null) {
    return;
  }
  try {
    mBroadcastWakeLock.acquire();
    audioService.adjustStreamVolume(stream,keycode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER,0,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + e);
  }
 finally {
    mBroadcastWakeLock.release();
  }
}"
1406,"@Override public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  if (!mVibrator.hasVibrator()) {
    return false;
  }
  final boolean hapticsDisabled=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0,UserHandle.USER_CURRENT) == 0;
  if (!always && (hapticsDisabled || mKeyguardDelegate.isShowingAndNotHidden())) {
    return false;
  }
  long[] pattern=null;
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    pattern=mLongPressVibePattern;
  break;
case HapticFeedbackConstants.VIRTUAL_KEY:
pattern=mVirtualKeyVibePattern;
break;
case HapticFeedbackConstants.KEYBOARD_TAP:
pattern=mKeyboardTapVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
pattern=mSafeModeDisabledVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
pattern=mSafeModeEnabledVibePattern;
break;
default :
return false;
}
int owningUid;
String owningPackage;
if (win != null) {
owningUid=win.getOwningUid();
owningPackage=win.getOwningPackage();
}
 else {
owningUid=android.os.Process.myUid();
owningPackage=mContext.getBasePackageName();
}
if (pattern.length == 1) {
mVibrator.vibrate(owningUid,owningPackage,pattern[0]);
}
 else {
mVibrator.vibrate(owningUid,owningPackage,pattern,-1);
}
return true;
}","@Override public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  if (!mVibrator.hasVibrator()) {
    return false;
  }
  final boolean hapticsDisabled=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0,UserHandle.USER_CURRENT) == 0;
  if (!always && (hapticsDisabled || mKeyguardDelegate.isShowingAndNotHidden())) {
    return false;
  }
  long[] pattern=null;
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    pattern=mLongPressVibePattern;
  break;
case HapticFeedbackConstants.VIRTUAL_KEY:
pattern=mVirtualKeyVibePattern;
break;
case HapticFeedbackConstants.KEYBOARD_TAP:
pattern=mKeyboardTapVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
pattern=mSafeModeDisabledVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
pattern=mSafeModeEnabledVibePattern;
break;
default :
return false;
}
int owningUid;
String owningPackage;
if (win != null) {
owningUid=win.getOwningUid();
owningPackage=win.getOwningPackage();
}
 else {
owningUid=android.os.Process.myUid();
owningPackage=mContext.getOpPackageName();
}
if (pattern.length == 1) {
mVibrator.vibrate(owningUid,owningPackage,pattern[0]);
}
 else {
mVibrator.vibrate(owningUid,owningPackage,pattern,-1);
}
return true;
}"
1407,"/** 
 * Returns the neighboring cell information of the device. The getAllCellInfo is preferred and use this only if getAllCellInfo return nulls or an empty list. <p> In the future this call will be deprecated. <p>
 * @return List of NeighboringCellInfo or null if info unavailable.<p>Requires Permission: (@link android.Manifest.permission#ACCESS_COARSE_UPDATES}
 */
public List<NeighboringCellInfo> getNeighboringCellInfo(){
  try {
    return getITelephony().getNeighboringCellInfo(mContext.getBasePackageName());
  }
 catch (  RemoteException ex) {
    return null;
  }
catch (  NullPointerException ex) {
    return null;
  }
}","/** 
 * Returns the neighboring cell information of the device. The getAllCellInfo is preferred and use this only if getAllCellInfo return nulls or an empty list. <p> In the future this call will be deprecated. <p>
 * @return List of NeighboringCellInfo or null if info unavailable.<p>Requires Permission: (@link android.Manifest.permission#ACCESS_COARSE_UPDATES}
 */
public List<NeighboringCellInfo> getNeighboringCellInfo(){
  try {
    return getITelephony().getNeighboringCellInfo(mContext.getOpPackageName());
  }
 catch (  RemoteException ex) {
    return null;
  }
catch (  NullPointerException ex) {
    return null;
  }
}"
1408,"/** 
 * @hide 
 */
public int startOp(int op){
  return startOp(op,Process.myUid(),mContext.getBasePackageName());
}","/** 
 * @hide 
 */
public int startOp(int op){
  return startOp(op,Process.myUid(),mContext.getOpPackageName());
}"
1409,"public void finishOp(int op){
  finishOp(op,Process.myUid(),mContext.getBasePackageName());
}","public void finishOp(int op){
  finishOp(op,Process.myUid(),mContext.getOpPackageName());
}"
1410,"/** 
 * @hide 
 */
public int noteOp(int op){
  return noteOp(op,Process.myUid(),mContext.getBasePackageName());
}","/** 
 * @hide 
 */
public int noteOp(int op){
  return noteOp(op,Process.myUid(),mContext.getOpPackageName());
}"
1411,"/** 
 * Do a quick check for whether an application might be able to perform an operation. This is <em>not</em> a security check; you must use   {@link #noteOp(int,int,String)}or   {@link #startOp(int,int,String)} for your actual security checks, which alsoensure that the given uid and package name are consistent.  This function can just be used for a quick check to see if an operation has been disabled for the application, as an early reject of some work.  This does not modify the time stamp or other data about the operation.
 * @param op The operation to check.  One of the OP_* constants.
 * @param uid The user id of the application attempting to perform the operation.
 * @param packageName The name of the application attempting to perform the operation.
 * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or{@link #MODE_IGNORED} if it is not allowed and should be silently ignored (withoutcausing the app to crash).
 * @throws SecurityException If the app has been configured to crash on this op.
 */
public int checkOp(int op,int uid,String packageName){
  try {
    int mode=mService.checkOperation(op,uid,packageName);
    if (mode == MODE_ERRORED) {
      throw new SecurityException(""String_Node_Str"");
    }
    return mode;
  }
 catch (  RemoteException e) {
  }
  return MODE_IGNORED;
}","/** 
 * Do a quick check for whether an application might be able to perform an operation. This is <em>not</em> a security check; you must use   {@link #noteOp(int,int,String)}or   {@link #startOp(int,int,String)} for your actual security checks, which alsoensure that the given uid and package name are consistent.  This function can just be used for a quick check to see if an operation has been disabled for the application, as an early reject of some work.  This does not modify the time stamp or other data about the operation.
 * @param op The operation to check.  One of the OP_* constants.
 * @param uid The user id of the application attempting to perform the operation.
 * @param packageName The name of the application attempting to perform the operation.
 * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or{@link #MODE_IGNORED} if it is not allowed and should be silently ignored (withoutcausing the app to crash).
 * @throws SecurityException If the app has been configured to crash on this op.
 */
public int checkOp(int op,int uid,String packageName){
  try {
    int mode=mService.checkOperation(op,uid,packageName);
    if (mode == MODE_ERRORED) {
      throw new SecurityException(buildSecurityExceptionMsg(op,uid,packageName));
    }
    return mode;
  }
 catch (  RemoteException e) {
  }
  return MODE_IGNORED;
}"
1412,"@Override public void setApplicationEnabledSetting(String packageName,int newState,int flags){
  try {
    mPM.setApplicationEnabledSetting(packageName,newState,flags,mContext.getUserId(),mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
  }
}","@Override public void setApplicationEnabledSetting(String packageName,int newState,int flags){
  try {
    mPM.setApplicationEnabledSetting(packageName,newState,flags,mContext.getUserId(),mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
  }
}"
1413,"/** 
 * Create a new ApplicationContext from an existing one.  The new one works and operates the same as the one it is copying.
 * @param context Existing application context.
 */
public ContextImpl(ContextImpl context){
  mPackageInfo=context.mPackageInfo;
  mBasePackageName=context.mBasePackageName;
  mResources=context.mResources;
  mMainThread=context.mMainThread;
  mContentResolver=context.mContentResolver;
  mUser=context.mUser;
  mDisplay=context.mDisplay;
  mOuterContext=this;
  mDisplayAdjustments.setCompatibilityInfo(mPackageInfo.getCompatibilityInfo());
}","/** 
 * Create a new ApplicationContext from an existing one.  The new one works and operates the same as the one it is copying.
 * @param context Existing application context.
 */
public ContextImpl(ContextImpl context){
  mPackageInfo=context.mPackageInfo;
  mBasePackageName=context.mBasePackageName;
  mOpPackageName=context.mOpPackageName;
  mResources=context.mResources;
  mMainThread=context.mMainThread;
  mContentResolver=context.mContentResolver;
  mUser=context.mUser;
  mDisplay=context.mDisplay;
  mOuterContext=this;
  mDisplayAdjustments.setCompatibilityInfo(mPackageInfo.getCompatibilityInfo());
}"
1414,"final void init(Resources resources,ActivityThread mainThread,UserHandle user){
  mPackageInfo=null;
  mBasePackageName=null;
  mResources=resources;
  mMainThread=mainThread;
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
  mUser=user;
}","final void init(Resources resources,ActivityThread mainThread,UserHandle user){
  mPackageInfo=null;
  mBasePackageName=null;
  mOpPackageName=null;
  mResources=resources;
  mMainThread=mainThread;
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
  mUser=user;
}"
1415,"/** 
 * Post a notification to be shown in the status bar. If a notification with the same tag and id has already been posted by your application and has not yet been canceled, it will be replaced by the updated information.
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be uniquewithin your application.
 * @param notification A {@link Notification} object describing what toshow the user. Must not be null.
 */
public void notify(String tag,int id,Notification notification){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getBasePackageName(),tag,id,notification,idOut,UserHandle.myUserId());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}","/** 
 * Post a notification to be shown in the status bar. If a notification with the same tag and id has already been posted by your application and has not yet been canceled, it will be replaced by the updated information.
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be uniquewithin your application.
 * @param notification A {@link Notification} object describing what toshow the user. Must not be null.
 */
public void notify(String tag,int id,Notification notification){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getOpPackageName(),tag,id,notification,idOut,UserHandle.myUserId());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}"
1416,"/** 
 * @hide
 */
public void notifyAsUser(String tag,int id,Notification notification,UserHandle user){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getBasePackageName(),tag,id,notification,idOut,user.getIdentifier());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}","/** 
 * @hide
 */
public void notifyAsUser(String tag,int id,Notification notification,UserHandle user){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getOpPackageName(),tag,id,notification,idOut,user.getIdentifier());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}"
1417,"/** 
 * Returns true if there is currently a primary clip on the clipboard.
 */
public boolean hasPrimaryClip(){
  try {
    return getService().hasPrimaryClip(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}","/** 
 * Returns true if there is currently a primary clip on the clipboard.
 */
public boolean hasPrimaryClip(){
  try {
    return getService().hasPrimaryClip(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}"
1418,"/** 
 * Returns the current primary clip on the clipboard.
 */
public ClipData getPrimaryClip(){
  try {
    return getService().getPrimaryClip(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Returns the current primary clip on the clipboard.
 */
public ClipData getPrimaryClip(){
  try {
    return getService().getPrimaryClip(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}"
1419,"/** 
 * Returns a description of the current primary clip on the clipboard but not a copy of its data.
 */
public ClipDescription getPrimaryClipDescription(){
  try {
    return getService().getPrimaryClipDescription(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Returns a description of the current primary clip on the clipboard but not a copy of its data.
 */
public ClipDescription getPrimaryClipDescription(){
  try {
    return getService().getPrimaryClipDescription(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}"
1420,"public void addPrimaryClipChangedListener(OnPrimaryClipChangedListener what){
synchronized (mPrimaryClipChangedListeners) {
    if (mPrimaryClipChangedListeners.size() == 0) {
      try {
        getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener,mContext.getBasePackageName());
      }
 catch (      RemoteException e) {
      }
    }
    mPrimaryClipChangedListeners.add(what);
  }
}","public void addPrimaryClipChangedListener(OnPrimaryClipChangedListener what){
synchronized (mPrimaryClipChangedListeners) {
    if (mPrimaryClipChangedListeners.size() == 0) {
      try {
        getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener,mContext.getOpPackageName());
      }
 catch (      RemoteException e) {
      }
    }
    mPrimaryClipChangedListeners.add(what);
  }
}"
1421,"/** 
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
public boolean hasText(){
  try {
    return getService().hasClipboardText(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}","/** 
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
public boolean hasText(){
  try {
    return getService().hasClipboardText(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}"
1422,"/** 
 * Sets the current primary clip on the clipboard.  This is the clip that is involved in normal cut and paste operations.
 * @param clip The clipped data item to set.
 */
public void setPrimaryClip(ClipData clip){
  try {
    if (clip != null) {
      clip.prepareToLeaveProcess();
    }
    getService().setPrimaryClip(clip,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
  }
}","/** 
 * Sets the current primary clip on the clipboard.  This is the clip that is involved in normal cut and paste operations.
 * @param clip The clipped data item to set.
 */
public void setPrimaryClip(ClipData clip){
  try {
    if (clip != null) {
      clip.prepareToLeaveProcess();
    }
    getService().setPrimaryClip(clip,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
  }
}"
1423,"public ContentResolver(Context context){
  mContext=context != null ? context : ActivityThread.currentApplication();
  mPackageName=mContext.getBasePackageName();
}","public ContentResolver(Context context){
  mContext=context != null ? context : ActivityThread.currentApplication();
  mPackageName=mContext.getOpPackageName();
}"
1424,"/** 
 * Creates a new wake lock with the specified level and flags. <p> The   {@code levelAndFlags} parameter specifies a wake lock level and optional flagscombined using the logical OR operator. </p><p> The wake lock levels are:  {@link #PARTIAL_WAKE_LOCK},  {@link #FULL_WAKE_LOCK},   {@link #SCREEN_DIM_WAKE_LOCK}and   {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be specified as part of the   {@code levelAndFlags} parameter.</p><p> The wake lock flags are:  {@link #ACQUIRE_CAUSES_WAKEUP}and   {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the  {@code levelAndFlags} parameters.</p><p> Call  {@link WakeLock#acquire() acquire()} on the object to acquire thewake lock, and  {@link WakeLock#release release()} when you are done.</p><p> {@samplecode PowerManager pm = (PowerManager)mContext.getSystemService( Context.POWER_SERVICE); PowerManager.WakeLock wl = pm.newWakeLock( PowerManager.SCREEN_DIM_WAKE_LOCK | PowerManager.ON_AFTER_RELEASE, TAG); wl.acquire(); // ... do work... wl.release();}</p><p> Although a wake lock can be created without special permissions, the   {@link android.Manifest.permission#WAKE_LOCK} permission isrequired to actually acquire or release the wake lock that is returned. </p><p class=""note""> If using this to keep the screen on, you should strongly consider using {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. </p>
 * @param levelAndFlags Combination of wake lock level and flag values definingthe requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
public WakeLock newWakeLock(int levelAndFlags,String tag){
  validateWakeLockParameters(levelAndFlags,tag);
  return new WakeLock(levelAndFlags,tag,mContext.getBasePackageName());
}","/** 
 * Creates a new wake lock with the specified level and flags. <p> The   {@code levelAndFlags} parameter specifies a wake lock level and optional flagscombined using the logical OR operator. </p><p> The wake lock levels are:  {@link #PARTIAL_WAKE_LOCK},  {@link #FULL_WAKE_LOCK},   {@link #SCREEN_DIM_WAKE_LOCK}and   {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be specified as part of the   {@code levelAndFlags} parameter.</p><p> The wake lock flags are:  {@link #ACQUIRE_CAUSES_WAKEUP}and   {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the  {@code levelAndFlags} parameters.</p><p> Call  {@link WakeLock#acquire() acquire()} on the object to acquire thewake lock, and  {@link WakeLock#release release()} when you are done.</p><p> {@samplecode PowerManager pm = (PowerManager)mContext.getSystemService( Context.POWER_SERVICE); PowerManager.WakeLock wl = pm.newWakeLock( PowerManager.SCREEN_DIM_WAKE_LOCK | PowerManager.ON_AFTER_RELEASE, TAG); wl.acquire(); // ... do work... wl.release();}</p><p> Although a wake lock can be created without special permissions, the   {@link android.Manifest.permission#WAKE_LOCK} permission isrequired to actually acquire or release the wake lock that is returned. </p><p class=""note""> If using this to keep the screen on, you should strongly consider using {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. </p>
 * @param levelAndFlags Combination of wake lock level and flag values definingthe requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
public WakeLock newWakeLock(int levelAndFlags,String tag){
  validateWakeLockParameters(levelAndFlags,tag);
  return new WakeLock(levelAndFlags,tag,mContext.getOpPackageName());
}"
1425,"public SystemVibrator(Context context){
  mPackageName=context.getBasePackageName();
  mService=IVibratorService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
}","public SystemVibrator(Context context){
  mPackageName=context.getOpPackageName();
  mService=IVibratorService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
}"
1426,"/** 
 * Adjusts the master volume for the device's audio amplifier. <p>
 * @param steps The number of volume steps to adjust. A positivevalue will raise the volume.
 * @param flags One or more flags.
 * @hide
 */
public void adjustMasterVolume(int steps,int flags){
  IAudioService service=getService();
  try {
    service.adjustMasterVolume(steps,flags,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the master volume for the device's audio amplifier. <p>
 * @param steps The number of volume steps to adjust. A positivevalue will raise the volume.
 * @param flags One or more flags.
 * @hide
 */
public void adjustMasterVolume(int steps,int flags){
  IAudioService service=getService();
  try {
    service.adjustMasterVolume(steps,flags,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1427,"/** 
 * @hide Used internally by telephony package to request audio focus. Will cause the focus request to be associated with the ""voice communication"" identifier only used in AudioService to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL forthe establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended somedia applications resume after a call
 */
public void requestAudioFocusForCall(int streamType,int durationHint){
  IAudioService service=getService();
  try {
    service.requestAudioFocus(streamType,durationHint,mICallBack,null,MediaFocusControl.IN_VOICE_COMM_FOCUS_ID,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}","/** 
 * @hide Used internally by telephony package to request audio focus. Will cause the focus request to be associated with the ""voice communication"" identifier only used in AudioService to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL forthe establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended somedia applications resume after a call
 */
public void requestAudioFocusForCall(int streamType,int durationHint){
  IAudioService service=getService();
  try {
    service.requestAudioFocus(streamType,durationHint,mICallBack,null,MediaFocusControl.IN_VOICE_COMM_FOCUS_ID,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}"
1428,"/** 
 * Request audio focus. Send a request to obtain the audio focus
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Alternatively use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary requestthat benefits from the system not playing disruptive sounds like notifications, for usecases such as voice memo recording, or speech recognition. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l),mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * Request audio focus. Send a request to obtain the audio focus
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Alternatively use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary requestthat benefits from the system not playing disruptive sounds like notifications, for usecases such as voice memo recording, or speech recognition. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l),mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}"
1429,"/** 
 * Adjusts the volume of a particular stream by one step in a direction. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getBasePackageName());
    }
 else {
      service.adjustStreamVolume(streamType,direction,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of a particular stream by one step in a direction. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getOpPackageName());
    }
 else {
      service.adjustStreamVolume(streamType,direction,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1430,"/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getBasePackageName());
    }
 else {
      service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getOpPackageName());
    }
 else {
      service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1431,"/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getBasePackageName());
    }
 else {
      service.adjustVolume(direction,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getOpPackageName());
    }
 else {
      service.adjustVolume(direction,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1432,"/** 
 * Sets the volume index for master volume.
 * @param index The volume index to set. See{@link #getMasterMaxVolume()} for the largest valid value.
 * @param flags One or more flags.
 * @see #getMasterMaxVolume()
 * @see #getMasterVolume()
 * @hide
 */
public void setMasterVolume(int index,int flags){
  IAudioService service=getService();
  try {
    service.setMasterVolume(index,flags,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the volume index for master volume.
 * @param index The volume index to set. See{@link #getMasterMaxVolume()} for the largest valid value.
 * @param flags One or more flags.
 * @see #getMasterMaxVolume()
 * @see #getMasterVolume()
 * @hide
 */
public void setMasterVolume(int index,int flags){
  IAudioService service=getService();
  try {
    service.setMasterVolume(index,flags,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1433,"/** 
 * Sets the volume index for a particular stream.
 * @param streamType The stream whose volume index should be set.
 * @param index The volume index to set. See{@link #getStreamMaxVolume(int)} for the largest valid value.
 * @param flags One or more flags.
 * @see #getStreamMaxVolume(int)
 * @see #getStreamVolume(int)
 */
public void setStreamVolume(int streamType,int index,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.setMasterVolume(index,flags,mContext.getBasePackageName());
    }
 else {
      service.setStreamVolume(streamType,index,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the volume index for a particular stream.
 * @param streamType The stream whose volume index should be set.
 * @param index The volume index to set. See{@link #getStreamMaxVolume(int)} for the largest valid value.
 * @param flags One or more flags.
 * @see #getStreamMaxVolume(int)
 * @see #getStreamVolume(int)
 */
public void setStreamVolume(int streamType,int index,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.setMasterVolume(index,flags,mContext.getOpPackageName());
    }
 else {
      service.setStreamVolume(streamType,index,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1434,"/** 
 * @hide If the stream is active locally or remotely, adjust its volume according to the enforced priority rules. Note: only AudioManager.STREAM_MUSIC is supported at the moment
 */
public void adjustLocalOrRemoteStreamVolume(int streamType,int direction){
  if (streamType != STREAM_MUSIC) {
    Log.w(TAG,""String_Node_Str"" + streamType);
  }
  IAudioService service=getService();
  try {
    service.adjustLocalOrRemoteStreamVolume(streamType,direction,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * @hide If the stream is active locally or remotely, adjust its volume according to the enforced priority rules. Note: only AudioManager.STREAM_MUSIC is supported at the moment
 */
public void adjustLocalOrRemoteStreamVolume(int streamType,int direction){
  if (streamType != STREAM_MUSIC) {
    Log.w(TAG,""String_Node_Str"" + streamType);
  }
  IAudioService service=getService();
  try {
    service.adjustLocalOrRemoteStreamVolume(streamType,direction,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1435,"/** 
 * Tell the audio service to adjust the volume appropriate to the event.
 * @param keycode
 */
void handleVolumeKey(int stream,int keycode){
  IAudioService audioService=getAudioService();
  if (audioService == null) {
    return;
  }
  try {
    mBroadcastWakeLock.acquire();
    audioService.adjustStreamVolume(stream,keycode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER,0,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + e);
  }
 finally {
    mBroadcastWakeLock.release();
  }
}","/** 
 * Tell the audio service to adjust the volume appropriate to the event.
 * @param keycode
 */
void handleVolumeKey(int stream,int keycode){
  IAudioService audioService=getAudioService();
  if (audioService == null) {
    return;
  }
  try {
    mBroadcastWakeLock.acquire();
    audioService.adjustStreamVolume(stream,keycode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER,0,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + e);
  }
 finally {
    mBroadcastWakeLock.release();
  }
}"
1436,"@Override public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  if (!mVibrator.hasVibrator()) {
    return false;
  }
  final boolean hapticsDisabled=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0,UserHandle.USER_CURRENT) == 0;
  if (!always && (hapticsDisabled || mKeyguardDelegate.isShowingAndNotHidden())) {
    return false;
  }
  long[] pattern=null;
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    pattern=mLongPressVibePattern;
  break;
case HapticFeedbackConstants.VIRTUAL_KEY:
pattern=mVirtualKeyVibePattern;
break;
case HapticFeedbackConstants.KEYBOARD_TAP:
pattern=mKeyboardTapVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
pattern=mSafeModeDisabledVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
pattern=mSafeModeEnabledVibePattern;
break;
default :
return false;
}
int owningUid;
String owningPackage;
if (win != null) {
owningUid=win.getOwningUid();
owningPackage=win.getOwningPackage();
}
 else {
owningUid=android.os.Process.myUid();
owningPackage=mContext.getBasePackageName();
}
if (pattern.length == 1) {
mVibrator.vibrate(owningUid,owningPackage,pattern[0]);
}
 else {
mVibrator.vibrate(owningUid,owningPackage,pattern,-1);
}
return true;
}","@Override public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  if (!mVibrator.hasVibrator()) {
    return false;
  }
  final boolean hapticsDisabled=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0,UserHandle.USER_CURRENT) == 0;
  if (!always && (hapticsDisabled || mKeyguardDelegate.isShowingAndNotHidden())) {
    return false;
  }
  long[] pattern=null;
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    pattern=mLongPressVibePattern;
  break;
case HapticFeedbackConstants.VIRTUAL_KEY:
pattern=mVirtualKeyVibePattern;
break;
case HapticFeedbackConstants.KEYBOARD_TAP:
pattern=mKeyboardTapVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
pattern=mSafeModeDisabledVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
pattern=mSafeModeEnabledVibePattern;
break;
default :
return false;
}
int owningUid;
String owningPackage;
if (win != null) {
owningUid=win.getOwningUid();
owningPackage=win.getOwningPackage();
}
 else {
owningUid=android.os.Process.myUid();
owningPackage=mContext.getOpPackageName();
}
if (pattern.length == 1) {
mVibrator.vibrate(owningUid,owningPackage,pattern[0]);
}
 else {
mVibrator.vibrate(owningUid,owningPackage,pattern,-1);
}
return true;
}"
1437,"/** 
 * Returns the neighboring cell information of the device. The getAllCellInfo is preferred and use this only if getAllCellInfo return nulls or an empty list. <p> In the future this call will be deprecated. <p>
 * @return List of NeighboringCellInfo or null if info unavailable.<p>Requires Permission: (@link android.Manifest.permission#ACCESS_COARSE_UPDATES}
 */
public List<NeighboringCellInfo> getNeighboringCellInfo(){
  try {
    return getITelephony().getNeighboringCellInfo(mContext.getBasePackageName());
  }
 catch (  RemoteException ex) {
    return null;
  }
catch (  NullPointerException ex) {
    return null;
  }
}","/** 
 * Returns the neighboring cell information of the device. The getAllCellInfo is preferred and use this only if getAllCellInfo return nulls or an empty list. <p> In the future this call will be deprecated. <p>
 * @return List of NeighboringCellInfo or null if info unavailable.<p>Requires Permission: (@link android.Manifest.permission#ACCESS_COARSE_UPDATES}
 */
public List<NeighboringCellInfo> getNeighboringCellInfo(){
  try {
    return getITelephony().getNeighboringCellInfo(mContext.getOpPackageName());
  }
 catch (  RemoteException ex) {
    return null;
  }
catch (  NullPointerException ex) {
    return null;
  }
}"
1438,"/** 
 * @hide 
 */
public int startOp(int op){
  return startOp(op,Process.myUid(),mContext.getBasePackageName());
}","/** 
 * @hide 
 */
public int startOp(int op){
  return startOp(op,Process.myUid(),mContext.getOpPackageName());
}"
1439,"public void finishOp(int op){
  finishOp(op,Process.myUid(),mContext.getBasePackageName());
}","public void finishOp(int op){
  finishOp(op,Process.myUid(),mContext.getOpPackageName());
}"
1440,"/** 
 * @hide 
 */
public int noteOp(int op){
  return noteOp(op,Process.myUid(),mContext.getBasePackageName());
}","/** 
 * @hide 
 */
public int noteOp(int op){
  return noteOp(op,Process.myUid(),mContext.getOpPackageName());
}"
1441,"/** 
 * Do a quick check for whether an application might be able to perform an operation. This is <em>not</em> a security check; you must use   {@link #noteOp(int,int,String)}or   {@link #startOp(int,int,String)} for your actual security checks, which alsoensure that the given uid and package name are consistent.  This function can just be used for a quick check to see if an operation has been disabled for the application, as an early reject of some work.  This does not modify the time stamp or other data about the operation.
 * @param op The operation to check.  One of the OP_* constants.
 * @param uid The user id of the application attempting to perform the operation.
 * @param packageName The name of the application attempting to perform the operation.
 * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or{@link #MODE_IGNORED} if it is not allowed and should be silently ignored (withoutcausing the app to crash).
 * @throws SecurityException If the app has been configured to crash on this op.
 */
public int checkOp(int op,int uid,String packageName){
  try {
    int mode=mService.checkOperation(op,uid,packageName);
    if (mode == MODE_ERRORED) {
      throw new SecurityException(""String_Node_Str"");
    }
    return mode;
  }
 catch (  RemoteException e) {
  }
  return MODE_IGNORED;
}","/** 
 * Do a quick check for whether an application might be able to perform an operation. This is <em>not</em> a security check; you must use   {@link #noteOp(int,int,String)}or   {@link #startOp(int,int,String)} for your actual security checks, which alsoensure that the given uid and package name are consistent.  This function can just be used for a quick check to see if an operation has been disabled for the application, as an early reject of some work.  This does not modify the time stamp or other data about the operation.
 * @param op The operation to check.  One of the OP_* constants.
 * @param uid The user id of the application attempting to perform the operation.
 * @param packageName The name of the application attempting to perform the operation.
 * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or{@link #MODE_IGNORED} if it is not allowed and should be silently ignored (withoutcausing the app to crash).
 * @throws SecurityException If the app has been configured to crash on this op.
 */
public int checkOp(int op,int uid,String packageName){
  try {
    int mode=mService.checkOperation(op,uid,packageName);
    if (mode == MODE_ERRORED) {
      throw new SecurityException(buildSecurityExceptionMsg(op,uid,packageName));
    }
    return mode;
  }
 catch (  RemoteException e) {
  }
  return MODE_IGNORED;
}"
1442,"@Override public void setApplicationEnabledSetting(String packageName,int newState,int flags){
  try {
    mPM.setApplicationEnabledSetting(packageName,newState,flags,mContext.getUserId(),mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
  }
}","@Override public void setApplicationEnabledSetting(String packageName,int newState,int flags){
  try {
    mPM.setApplicationEnabledSetting(packageName,newState,flags,mContext.getUserId(),mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
  }
}"
1443,"/** 
 * Create a new ApplicationContext from an existing one.  The new one works and operates the same as the one it is copying.
 * @param context Existing application context.
 */
public ContextImpl(ContextImpl context){
  mPackageInfo=context.mPackageInfo;
  mBasePackageName=context.mBasePackageName;
  mResources=context.mResources;
  mMainThread=context.mMainThread;
  mContentResolver=context.mContentResolver;
  mUser=context.mUser;
  mDisplay=context.mDisplay;
  mOuterContext=this;
  mDisplayAdjustments.setCompatibilityInfo(mPackageInfo.getCompatibilityInfo());
}","/** 
 * Create a new ApplicationContext from an existing one.  The new one works and operates the same as the one it is copying.
 * @param context Existing application context.
 */
public ContextImpl(ContextImpl context){
  mPackageInfo=context.mPackageInfo;
  mBasePackageName=context.mBasePackageName;
  mOpPackageName=context.mOpPackageName;
  mResources=context.mResources;
  mMainThread=context.mMainThread;
  mContentResolver=context.mContentResolver;
  mUser=context.mUser;
  mDisplay=context.mDisplay;
  mOuterContext=this;
  mDisplayAdjustments.setCompatibilityInfo(mPackageInfo.getCompatibilityInfo());
}"
1444,"final void init(Resources resources,ActivityThread mainThread,UserHandle user){
  mPackageInfo=null;
  mBasePackageName=null;
  mResources=resources;
  mMainThread=mainThread;
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
  mUser=user;
}","final void init(Resources resources,ActivityThread mainThread,UserHandle user){
  mPackageInfo=null;
  mBasePackageName=null;
  mOpPackageName=null;
  mResources=resources;
  mMainThread=mainThread;
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
  mUser=user;
}"
1445,"/** 
 * Post a notification to be shown in the status bar. If a notification with the same tag and id has already been posted by your application and has not yet been canceled, it will be replaced by the updated information.
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be uniquewithin your application.
 * @param notification A {@link Notification} object describing what toshow the user. Must not be null.
 */
public void notify(String tag,int id,Notification notification){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getBasePackageName(),tag,id,notification,idOut,UserHandle.myUserId());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}","/** 
 * Post a notification to be shown in the status bar. If a notification with the same tag and id has already been posted by your application and has not yet been canceled, it will be replaced by the updated information.
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be uniquewithin your application.
 * @param notification A {@link Notification} object describing what toshow the user. Must not be null.
 */
public void notify(String tag,int id,Notification notification){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getOpPackageName(),tag,id,notification,idOut,UserHandle.myUserId());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}"
1446,"/** 
 * @hide
 */
public void notifyAsUser(String tag,int id,Notification notification,UserHandle user){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getBasePackageName(),tag,id,notification,idOut,user.getIdentifier());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}","/** 
 * @hide
 */
public void notifyAsUser(String tag,int id,Notification notification,UserHandle user){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getOpPackageName(),tag,id,notification,idOut,user.getIdentifier());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}"
1447,"/** 
 * Returns true if there is currently a primary clip on the clipboard.
 */
public boolean hasPrimaryClip(){
  try {
    return getService().hasPrimaryClip(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}","/** 
 * Returns true if there is currently a primary clip on the clipboard.
 */
public boolean hasPrimaryClip(){
  try {
    return getService().hasPrimaryClip(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}"
1448,"/** 
 * Returns the current primary clip on the clipboard.
 */
public ClipData getPrimaryClip(){
  try {
    return getService().getPrimaryClip(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Returns the current primary clip on the clipboard.
 */
public ClipData getPrimaryClip(){
  try {
    return getService().getPrimaryClip(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}"
1449,"/** 
 * Returns a description of the current primary clip on the clipboard but not a copy of its data.
 */
public ClipDescription getPrimaryClipDescription(){
  try {
    return getService().getPrimaryClipDescription(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Returns a description of the current primary clip on the clipboard but not a copy of its data.
 */
public ClipDescription getPrimaryClipDescription(){
  try {
    return getService().getPrimaryClipDescription(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}"
1450,"public void addPrimaryClipChangedListener(OnPrimaryClipChangedListener what){
synchronized (mPrimaryClipChangedListeners) {
    if (mPrimaryClipChangedListeners.size() == 0) {
      try {
        getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener,mContext.getBasePackageName());
      }
 catch (      RemoteException e) {
      }
    }
    mPrimaryClipChangedListeners.add(what);
  }
}","public void addPrimaryClipChangedListener(OnPrimaryClipChangedListener what){
synchronized (mPrimaryClipChangedListeners) {
    if (mPrimaryClipChangedListeners.size() == 0) {
      try {
        getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener,mContext.getOpPackageName());
      }
 catch (      RemoteException e) {
      }
    }
    mPrimaryClipChangedListeners.add(what);
  }
}"
1451,"/** 
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
public boolean hasText(){
  try {
    return getService().hasClipboardText(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}","/** 
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
public boolean hasText(){
  try {
    return getService().hasClipboardText(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}"
1452,"/** 
 * Sets the current primary clip on the clipboard.  This is the clip that is involved in normal cut and paste operations.
 * @param clip The clipped data item to set.
 */
public void setPrimaryClip(ClipData clip){
  try {
    if (clip != null) {
      clip.prepareToLeaveProcess();
    }
    getService().setPrimaryClip(clip,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
  }
}","/** 
 * Sets the current primary clip on the clipboard.  This is the clip that is involved in normal cut and paste operations.
 * @param clip The clipped data item to set.
 */
public void setPrimaryClip(ClipData clip){
  try {
    if (clip != null) {
      clip.prepareToLeaveProcess();
    }
    getService().setPrimaryClip(clip,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
  }
}"
1453,"public ContentResolver(Context context){
  mContext=context != null ? context : ActivityThread.currentApplication();
  mPackageName=mContext.getBasePackageName();
}","public ContentResolver(Context context){
  mContext=context != null ? context : ActivityThread.currentApplication();
  mPackageName=mContext.getOpPackageName();
}"
1454,"/** 
 * Creates a new wake lock with the specified level and flags. <p> The   {@code levelAndFlags} parameter specifies a wake lock level and optional flagscombined using the logical OR operator. </p><p> The wake lock levels are:  {@link #PARTIAL_WAKE_LOCK},  {@link #FULL_WAKE_LOCK},   {@link #SCREEN_DIM_WAKE_LOCK}and   {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be specified as part of the   {@code levelAndFlags} parameter.</p><p> The wake lock flags are:  {@link #ACQUIRE_CAUSES_WAKEUP}and   {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the  {@code levelAndFlags} parameters.</p><p> Call  {@link WakeLock#acquire() acquire()} on the object to acquire thewake lock, and  {@link WakeLock#release release()} when you are done.</p><p> {@samplecode PowerManager pm = (PowerManager)mContext.getSystemService( Context.POWER_SERVICE); PowerManager.WakeLock wl = pm.newWakeLock( PowerManager.SCREEN_DIM_WAKE_LOCK | PowerManager.ON_AFTER_RELEASE, TAG); wl.acquire(); // ... do work... wl.release();}</p><p> Although a wake lock can be created without special permissions, the   {@link android.Manifest.permission#WAKE_LOCK} permission isrequired to actually acquire or release the wake lock that is returned. </p><p class=""note""> If using this to keep the screen on, you should strongly consider using {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. </p>
 * @param levelAndFlags Combination of wake lock level and flag values definingthe requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
public WakeLock newWakeLock(int levelAndFlags,String tag){
  validateWakeLockParameters(levelAndFlags,tag);
  return new WakeLock(levelAndFlags,tag,mContext.getBasePackageName());
}","/** 
 * Creates a new wake lock with the specified level and flags. <p> The   {@code levelAndFlags} parameter specifies a wake lock level and optional flagscombined using the logical OR operator. </p><p> The wake lock levels are:  {@link #PARTIAL_WAKE_LOCK},  {@link #FULL_WAKE_LOCK},   {@link #SCREEN_DIM_WAKE_LOCK}and   {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be specified as part of the   {@code levelAndFlags} parameter.</p><p> The wake lock flags are:  {@link #ACQUIRE_CAUSES_WAKEUP}and   {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the  {@code levelAndFlags} parameters.</p><p> Call  {@link WakeLock#acquire() acquire()} on the object to acquire thewake lock, and  {@link WakeLock#release release()} when you are done.</p><p> {@samplecode PowerManager pm = (PowerManager)mContext.getSystemService( Context.POWER_SERVICE); PowerManager.WakeLock wl = pm.newWakeLock( PowerManager.SCREEN_DIM_WAKE_LOCK | PowerManager.ON_AFTER_RELEASE, TAG); wl.acquire(); // ... do work... wl.release();}</p><p> Although a wake lock can be created without special permissions, the   {@link android.Manifest.permission#WAKE_LOCK} permission isrequired to actually acquire or release the wake lock that is returned. </p><p class=""note""> If using this to keep the screen on, you should strongly consider using {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. </p>
 * @param levelAndFlags Combination of wake lock level and flag values definingthe requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
public WakeLock newWakeLock(int levelAndFlags,String tag){
  validateWakeLockParameters(levelAndFlags,tag);
  return new WakeLock(levelAndFlags,tag,mContext.getOpPackageName());
}"
1455,"public SystemVibrator(Context context){
  mPackageName=context.getBasePackageName();
  mService=IVibratorService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
}","public SystemVibrator(Context context){
  mPackageName=context.getOpPackageName();
  mService=IVibratorService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
}"
1456,"/** 
 * Adjusts the master volume for the device's audio amplifier. <p>
 * @param steps The number of volume steps to adjust. A positivevalue will raise the volume.
 * @param flags One or more flags.
 * @hide
 */
public void adjustMasterVolume(int steps,int flags){
  IAudioService service=getService();
  try {
    service.adjustMasterVolume(steps,flags,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the master volume for the device's audio amplifier. <p>
 * @param steps The number of volume steps to adjust. A positivevalue will raise the volume.
 * @param flags One or more flags.
 * @hide
 */
public void adjustMasterVolume(int steps,int flags){
  IAudioService service=getService();
  try {
    service.adjustMasterVolume(steps,flags,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1457,"/** 
 * @hide Used internally by telephony package to request audio focus. Will cause the focus request to be associated with the ""voice communication"" identifier only used in AudioService to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL forthe establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended somedia applications resume after a call
 */
public void requestAudioFocusForCall(int streamType,int durationHint){
  IAudioService service=getService();
  try {
    service.requestAudioFocus(streamType,durationHint,mICallBack,null,MediaFocusControl.IN_VOICE_COMM_FOCUS_ID,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}","/** 
 * @hide Used internally by telephony package to request audio focus. Will cause the focus request to be associated with the ""voice communication"" identifier only used in AudioService to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL forthe establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended somedia applications resume after a call
 */
public void requestAudioFocusForCall(int streamType,int durationHint){
  IAudioService service=getService();
  try {
    service.requestAudioFocus(streamType,durationHint,mICallBack,null,MediaFocusControl.IN_VOICE_COMM_FOCUS_ID,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}"
1458,"/** 
 * Request audio focus. Send a request to obtain the audio focus
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Alternatively use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary requestthat benefits from the system not playing disruptive sounds like notifications, for usecases such as voice memo recording, or speech recognition. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l),mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * Request audio focus. Send a request to obtain the audio focus
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Alternatively use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary requestthat benefits from the system not playing disruptive sounds like notifications, for usecases such as voice memo recording, or speech recognition. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l),mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}"
1459,"/** 
 * Adjusts the volume of a particular stream by one step in a direction. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getBasePackageName());
    }
 else {
      service.adjustStreamVolume(streamType,direction,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of a particular stream by one step in a direction. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getOpPackageName());
    }
 else {
      service.adjustStreamVolume(streamType,direction,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1460,"/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getBasePackageName());
    }
 else {
      service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getOpPackageName());
    }
 else {
      service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1461,"/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getBasePackageName());
    }
 else {
      service.adjustVolume(direction,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getOpPackageName());
    }
 else {
      service.adjustVolume(direction,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1462,"/** 
 * Sets the volume index for master volume.
 * @param index The volume index to set. See{@link #getMasterMaxVolume()} for the largest valid value.
 * @param flags One or more flags.
 * @see #getMasterMaxVolume()
 * @see #getMasterVolume()
 * @hide
 */
public void setMasterVolume(int index,int flags){
  IAudioService service=getService();
  try {
    service.setMasterVolume(index,flags,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the volume index for master volume.
 * @param index The volume index to set. See{@link #getMasterMaxVolume()} for the largest valid value.
 * @param flags One or more flags.
 * @see #getMasterMaxVolume()
 * @see #getMasterVolume()
 * @hide
 */
public void setMasterVolume(int index,int flags){
  IAudioService service=getService();
  try {
    service.setMasterVolume(index,flags,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1463,"/** 
 * Sets the volume index for a particular stream.
 * @param streamType The stream whose volume index should be set.
 * @param index The volume index to set. See{@link #getStreamMaxVolume(int)} for the largest valid value.
 * @param flags One or more flags.
 * @see #getStreamMaxVolume(int)
 * @see #getStreamVolume(int)
 */
public void setStreamVolume(int streamType,int index,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.setMasterVolume(index,flags,mContext.getBasePackageName());
    }
 else {
      service.setStreamVolume(streamType,index,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the volume index for a particular stream.
 * @param streamType The stream whose volume index should be set.
 * @param index The volume index to set. See{@link #getStreamMaxVolume(int)} for the largest valid value.
 * @param flags One or more flags.
 * @see #getStreamMaxVolume(int)
 * @see #getStreamVolume(int)
 */
public void setStreamVolume(int streamType,int index,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.setMasterVolume(index,flags,mContext.getOpPackageName());
    }
 else {
      service.setStreamVolume(streamType,index,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1464,"/** 
 * @hide If the stream is active locally or remotely, adjust its volume according to the enforced priority rules. Note: only AudioManager.STREAM_MUSIC is supported at the moment
 */
public void adjustLocalOrRemoteStreamVolume(int streamType,int direction){
  if (streamType != STREAM_MUSIC) {
    Log.w(TAG,""String_Node_Str"" + streamType);
  }
  IAudioService service=getService();
  try {
    service.adjustLocalOrRemoteStreamVolume(streamType,direction,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * @hide If the stream is active locally or remotely, adjust its volume according to the enforced priority rules. Note: only AudioManager.STREAM_MUSIC is supported at the moment
 */
public void adjustLocalOrRemoteStreamVolume(int streamType,int direction){
  if (streamType != STREAM_MUSIC) {
    Log.w(TAG,""String_Node_Str"" + streamType);
  }
  IAudioService service=getService();
  try {
    service.adjustLocalOrRemoteStreamVolume(streamType,direction,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1465,"/** 
 * Tell the audio service to adjust the volume appropriate to the event.
 * @param keycode
 */
void handleVolumeKey(int stream,int keycode){
  IAudioService audioService=getAudioService();
  if (audioService == null) {
    return;
  }
  try {
    mBroadcastWakeLock.acquire();
    audioService.adjustStreamVolume(stream,keycode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER,0,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + e);
  }
 finally {
    mBroadcastWakeLock.release();
  }
}","/** 
 * Tell the audio service to adjust the volume appropriate to the event.
 * @param keycode
 */
void handleVolumeKey(int stream,int keycode){
  IAudioService audioService=getAudioService();
  if (audioService == null) {
    return;
  }
  try {
    mBroadcastWakeLock.acquire();
    audioService.adjustStreamVolume(stream,keycode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER,0,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + e);
  }
 finally {
    mBroadcastWakeLock.release();
  }
}"
1466,"@Override public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  if (!mVibrator.hasVibrator()) {
    return false;
  }
  final boolean hapticsDisabled=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0,UserHandle.USER_CURRENT) == 0;
  if (!always && (hapticsDisabled || mKeyguardDelegate.isShowingAndNotHidden())) {
    return false;
  }
  long[] pattern=null;
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    pattern=mLongPressVibePattern;
  break;
case HapticFeedbackConstants.VIRTUAL_KEY:
pattern=mVirtualKeyVibePattern;
break;
case HapticFeedbackConstants.KEYBOARD_TAP:
pattern=mKeyboardTapVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
pattern=mSafeModeDisabledVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
pattern=mSafeModeEnabledVibePattern;
break;
default :
return false;
}
int owningUid;
String owningPackage;
if (win != null) {
owningUid=win.getOwningUid();
owningPackage=win.getOwningPackage();
}
 else {
owningUid=android.os.Process.myUid();
owningPackage=mContext.getBasePackageName();
}
if (pattern.length == 1) {
mVibrator.vibrate(owningUid,owningPackage,pattern[0]);
}
 else {
mVibrator.vibrate(owningUid,owningPackage,pattern,-1);
}
return true;
}","@Override public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  if (!mVibrator.hasVibrator()) {
    return false;
  }
  final boolean hapticsDisabled=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0,UserHandle.USER_CURRENT) == 0;
  if (!always && (hapticsDisabled || mKeyguardDelegate.isShowingAndNotHidden())) {
    return false;
  }
  long[] pattern=null;
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    pattern=mLongPressVibePattern;
  break;
case HapticFeedbackConstants.VIRTUAL_KEY:
pattern=mVirtualKeyVibePattern;
break;
case HapticFeedbackConstants.KEYBOARD_TAP:
pattern=mKeyboardTapVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
pattern=mSafeModeDisabledVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
pattern=mSafeModeEnabledVibePattern;
break;
default :
return false;
}
int owningUid;
String owningPackage;
if (win != null) {
owningUid=win.getOwningUid();
owningPackage=win.getOwningPackage();
}
 else {
owningUid=android.os.Process.myUid();
owningPackage=mContext.getOpPackageName();
}
if (pattern.length == 1) {
mVibrator.vibrate(owningUid,owningPackage,pattern[0]);
}
 else {
mVibrator.vibrate(owningUid,owningPackage,pattern,-1);
}
return true;
}"
1467,"/** 
 * Returns the neighboring cell information of the device. The getAllCellInfo is preferred and use this only if getAllCellInfo return nulls or an empty list. <p> In the future this call will be deprecated. <p>
 * @return List of NeighboringCellInfo or null if info unavailable.<p>Requires Permission: (@link android.Manifest.permission#ACCESS_COARSE_UPDATES}
 */
public List<NeighboringCellInfo> getNeighboringCellInfo(){
  try {
    return getITelephony().getNeighboringCellInfo(mContext.getBasePackageName());
  }
 catch (  RemoteException ex) {
    return null;
  }
catch (  NullPointerException ex) {
    return null;
  }
}","/** 
 * Returns the neighboring cell information of the device. The getAllCellInfo is preferred and use this only if getAllCellInfo return nulls or an empty list. <p> In the future this call will be deprecated. <p>
 * @return List of NeighboringCellInfo or null if info unavailable.<p>Requires Permission: (@link android.Manifest.permission#ACCESS_COARSE_UPDATES}
 */
public List<NeighboringCellInfo> getNeighboringCellInfo(){
  try {
    return getITelephony().getNeighboringCellInfo(mContext.getOpPackageName());
  }
 catch (  RemoteException ex) {
    return null;
  }
catch (  NullPointerException ex) {
    return null;
  }
}"
1468,"/** 
 * @hide 
 */
public int startOp(int op){
  return startOp(op,Process.myUid(),mContext.getBasePackageName());
}","/** 
 * @hide 
 */
public int startOp(int op){
  return startOp(op,Process.myUid(),mContext.getOpPackageName());
}"
1469,"public void finishOp(int op){
  finishOp(op,Process.myUid(),mContext.getBasePackageName());
}","public void finishOp(int op){
  finishOp(op,Process.myUid(),mContext.getOpPackageName());
}"
1470,"/** 
 * @hide 
 */
public int noteOp(int op){
  return noteOp(op,Process.myUid(),mContext.getBasePackageName());
}","/** 
 * @hide 
 */
public int noteOp(int op){
  return noteOp(op,Process.myUid(),mContext.getOpPackageName());
}"
1471,"/** 
 * Do a quick check for whether an application might be able to perform an operation. This is <em>not</em> a security check; you must use   {@link #noteOp(int,int,String)}or   {@link #startOp(int,int,String)} for your actual security checks, which alsoensure that the given uid and package name are consistent.  This function can just be used for a quick check to see if an operation has been disabled for the application, as an early reject of some work.  This does not modify the time stamp or other data about the operation.
 * @param op The operation to check.  One of the OP_* constants.
 * @param uid The user id of the application attempting to perform the operation.
 * @param packageName The name of the application attempting to perform the operation.
 * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or{@link #MODE_IGNORED} if it is not allowed and should be silently ignored (withoutcausing the app to crash).
 * @throws SecurityException If the app has been configured to crash on this op.
 */
public int checkOp(int op,int uid,String packageName){
  try {
    int mode=mService.checkOperation(op,uid,packageName);
    if (mode == MODE_ERRORED) {
      throw new SecurityException(""String_Node_Str"");
    }
    return mode;
  }
 catch (  RemoteException e) {
  }
  return MODE_IGNORED;
}","/** 
 * Do a quick check for whether an application might be able to perform an operation. This is <em>not</em> a security check; you must use   {@link #noteOp(int,int,String)}or   {@link #startOp(int,int,String)} for your actual security checks, which alsoensure that the given uid and package name are consistent.  This function can just be used for a quick check to see if an operation has been disabled for the application, as an early reject of some work.  This does not modify the time stamp or other data about the operation.
 * @param op The operation to check.  One of the OP_* constants.
 * @param uid The user id of the application attempting to perform the operation.
 * @param packageName The name of the application attempting to perform the operation.
 * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or{@link #MODE_IGNORED} if it is not allowed and should be silently ignored (withoutcausing the app to crash).
 * @throws SecurityException If the app has been configured to crash on this op.
 */
public int checkOp(int op,int uid,String packageName){
  try {
    int mode=mService.checkOperation(op,uid,packageName);
    if (mode == MODE_ERRORED) {
      throw new SecurityException(buildSecurityExceptionMsg(op,uid,packageName));
    }
    return mode;
  }
 catch (  RemoteException e) {
  }
  return MODE_IGNORED;
}"
1472,"@Override public void setApplicationEnabledSetting(String packageName,int newState,int flags){
  try {
    mPM.setApplicationEnabledSetting(packageName,newState,flags,mContext.getUserId(),mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
  }
}","@Override public void setApplicationEnabledSetting(String packageName,int newState,int flags){
  try {
    mPM.setApplicationEnabledSetting(packageName,newState,flags,mContext.getUserId(),mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
  }
}"
1473,"/** 
 * Create a new ApplicationContext from an existing one.  The new one works and operates the same as the one it is copying.
 * @param context Existing application context.
 */
public ContextImpl(ContextImpl context){
  mPackageInfo=context.mPackageInfo;
  mBasePackageName=context.mBasePackageName;
  mResources=context.mResources;
  mMainThread=context.mMainThread;
  mContentResolver=context.mContentResolver;
  mUser=context.mUser;
  mDisplay=context.mDisplay;
  mOuterContext=this;
  mDisplayAdjustments.setCompatibilityInfo(mPackageInfo.getCompatibilityInfo());
}","/** 
 * Create a new ApplicationContext from an existing one.  The new one works and operates the same as the one it is copying.
 * @param context Existing application context.
 */
public ContextImpl(ContextImpl context){
  mPackageInfo=context.mPackageInfo;
  mBasePackageName=context.mBasePackageName;
  mOpPackageName=context.mOpPackageName;
  mResources=context.mResources;
  mMainThread=context.mMainThread;
  mContentResolver=context.mContentResolver;
  mUser=context.mUser;
  mDisplay=context.mDisplay;
  mOuterContext=this;
  mDisplayAdjustments.setCompatibilityInfo(mPackageInfo.getCompatibilityInfo());
}"
1474,"final void init(Resources resources,ActivityThread mainThread,UserHandle user){
  mPackageInfo=null;
  mBasePackageName=null;
  mResources=resources;
  mMainThread=mainThread;
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
  mUser=user;
}","final void init(Resources resources,ActivityThread mainThread,UserHandle user){
  mPackageInfo=null;
  mBasePackageName=null;
  mOpPackageName=null;
  mResources=resources;
  mMainThread=mainThread;
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
  mUser=user;
}"
1475,"/** 
 * Post a notification to be shown in the status bar. If a notification with the same tag and id has already been posted by your application and has not yet been canceled, it will be replaced by the updated information.
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be uniquewithin your application.
 * @param notification A {@link Notification} object describing what toshow the user. Must not be null.
 */
public void notify(String tag,int id,Notification notification){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getBasePackageName(),tag,id,notification,idOut,UserHandle.myUserId());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}","/** 
 * Post a notification to be shown in the status bar. If a notification with the same tag and id has already been posted by your application and has not yet been canceled, it will be replaced by the updated information.
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be uniquewithin your application.
 * @param notification A {@link Notification} object describing what toshow the user. Must not be null.
 */
public void notify(String tag,int id,Notification notification){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getOpPackageName(),tag,id,notification,idOut,UserHandle.myUserId());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}"
1476,"/** 
 * @hide
 */
public void notifyAsUser(String tag,int id,Notification notification,UserHandle user){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getBasePackageName(),tag,id,notification,idOut,user.getIdentifier());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}","/** 
 * @hide
 */
public void notifyAsUser(String tag,int id,Notification notification,UserHandle user){
  int[] idOut=new int[1];
  INotificationManager service=getService();
  String pkg=mContext.getPackageName();
  if (notification.sound != null) {
    notification.sound=notification.sound.getCanonicalUri();
    if (StrictMode.vmFileUriExposureEnabled()) {
      notification.sound.checkFileUriExposed(""String_Node_Str"");
    }
  }
  if (localLOGV)   Log.v(TAG,pkg + ""String_Node_Str"" + id+ ""String_Node_Str""+ notification+ ""String_Node_Str"");
  try {
    service.enqueueNotificationWithTag(pkg,mContext.getOpPackageName(),tag,id,notification,idOut,user.getIdentifier());
    if (id != idOut[0]) {
      Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ idOut[0]);
    }
  }
 catch (  RemoteException e) {
  }
}"
1477,"/** 
 * Returns true if there is currently a primary clip on the clipboard.
 */
public boolean hasPrimaryClip(){
  try {
    return getService().hasPrimaryClip(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}","/** 
 * Returns true if there is currently a primary clip on the clipboard.
 */
public boolean hasPrimaryClip(){
  try {
    return getService().hasPrimaryClip(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}"
1478,"/** 
 * Returns the current primary clip on the clipboard.
 */
public ClipData getPrimaryClip(){
  try {
    return getService().getPrimaryClip(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Returns the current primary clip on the clipboard.
 */
public ClipData getPrimaryClip(){
  try {
    return getService().getPrimaryClip(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}"
1479,"/** 
 * Returns a description of the current primary clip on the clipboard but not a copy of its data.
 */
public ClipDescription getPrimaryClipDescription(){
  try {
    return getService().getPrimaryClipDescription(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Returns a description of the current primary clip on the clipboard but not a copy of its data.
 */
public ClipDescription getPrimaryClipDescription(){
  try {
    return getService().getPrimaryClipDescription(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return null;
  }
}"
1480,"public void addPrimaryClipChangedListener(OnPrimaryClipChangedListener what){
synchronized (mPrimaryClipChangedListeners) {
    if (mPrimaryClipChangedListeners.size() == 0) {
      try {
        getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener,mContext.getBasePackageName());
      }
 catch (      RemoteException e) {
      }
    }
    mPrimaryClipChangedListeners.add(what);
  }
}","public void addPrimaryClipChangedListener(OnPrimaryClipChangedListener what){
synchronized (mPrimaryClipChangedListeners) {
    if (mPrimaryClipChangedListeners.size() == 0) {
      try {
        getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener,mContext.getOpPackageName());
      }
 catch (      RemoteException e) {
      }
    }
    mPrimaryClipChangedListeners.add(what);
  }
}"
1481,"/** 
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
public boolean hasText(){
  try {
    return getService().hasClipboardText(mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}","/** 
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
public boolean hasText(){
  try {
    return getService().hasClipboardText(mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    return false;
  }
}"
1482,"/** 
 * Sets the current primary clip on the clipboard.  This is the clip that is involved in normal cut and paste operations.
 * @param clip The clipped data item to set.
 */
public void setPrimaryClip(ClipData clip){
  try {
    if (clip != null) {
      clip.prepareToLeaveProcess();
    }
    getService().setPrimaryClip(clip,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
  }
}","/** 
 * Sets the current primary clip on the clipboard.  This is the clip that is involved in normal cut and paste operations.
 * @param clip The clipped data item to set.
 */
public void setPrimaryClip(ClipData clip){
  try {
    if (clip != null) {
      clip.prepareToLeaveProcess();
    }
    getService().setPrimaryClip(clip,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
  }
}"
1483,"public ContentResolver(Context context){
  mContext=context != null ? context : ActivityThread.currentApplication();
  mPackageName=mContext.getBasePackageName();
}","public ContentResolver(Context context){
  mContext=context != null ? context : ActivityThread.currentApplication();
  mPackageName=mContext.getOpPackageName();
}"
1484,"/** 
 * Creates a new wake lock with the specified level and flags. <p> The   {@code levelAndFlags} parameter specifies a wake lock level and optional flagscombined using the logical OR operator. </p><p> The wake lock levels are:  {@link #PARTIAL_WAKE_LOCK},  {@link #FULL_WAKE_LOCK},   {@link #SCREEN_DIM_WAKE_LOCK}and   {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be specified as part of the   {@code levelAndFlags} parameter.</p><p> The wake lock flags are:  {@link #ACQUIRE_CAUSES_WAKEUP}and   {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the  {@code levelAndFlags} parameters.</p><p> Call  {@link WakeLock#acquire() acquire()} on the object to acquire thewake lock, and  {@link WakeLock#release release()} when you are done.</p><p> {@samplecode PowerManager pm = (PowerManager)mContext.getSystemService( Context.POWER_SERVICE); PowerManager.WakeLock wl = pm.newWakeLock( PowerManager.SCREEN_DIM_WAKE_LOCK | PowerManager.ON_AFTER_RELEASE, TAG); wl.acquire(); // ... do work... wl.release();}</p><p> Although a wake lock can be created without special permissions, the   {@link android.Manifest.permission#WAKE_LOCK} permission isrequired to actually acquire or release the wake lock that is returned. </p><p class=""note""> If using this to keep the screen on, you should strongly consider using {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. </p>
 * @param levelAndFlags Combination of wake lock level and flag values definingthe requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
public WakeLock newWakeLock(int levelAndFlags,String tag){
  validateWakeLockParameters(levelAndFlags,tag);
  return new WakeLock(levelAndFlags,tag,mContext.getBasePackageName());
}","/** 
 * Creates a new wake lock with the specified level and flags. <p> The   {@code levelAndFlags} parameter specifies a wake lock level and optional flagscombined using the logical OR operator. </p><p> The wake lock levels are:  {@link #PARTIAL_WAKE_LOCK},  {@link #FULL_WAKE_LOCK},   {@link #SCREEN_DIM_WAKE_LOCK}and   {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be specified as part of the   {@code levelAndFlags} parameter.</p><p> The wake lock flags are:  {@link #ACQUIRE_CAUSES_WAKEUP}and   {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the  {@code levelAndFlags} parameters.</p><p> Call  {@link WakeLock#acquire() acquire()} on the object to acquire thewake lock, and  {@link WakeLock#release release()} when you are done.</p><p> {@samplecode PowerManager pm = (PowerManager)mContext.getSystemService( Context.POWER_SERVICE); PowerManager.WakeLock wl = pm.newWakeLock( PowerManager.SCREEN_DIM_WAKE_LOCK | PowerManager.ON_AFTER_RELEASE, TAG); wl.acquire(); // ... do work... wl.release();}</p><p> Although a wake lock can be created without special permissions, the   {@link android.Manifest.permission#WAKE_LOCK} permission isrequired to actually acquire or release the wake lock that is returned. </p><p class=""note""> If using this to keep the screen on, you should strongly consider using {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. </p>
 * @param levelAndFlags Combination of wake lock level and flag values definingthe requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
public WakeLock newWakeLock(int levelAndFlags,String tag){
  validateWakeLockParameters(levelAndFlags,tag);
  return new WakeLock(levelAndFlags,tag,mContext.getOpPackageName());
}"
1485,"public SystemVibrator(Context context){
  mPackageName=context.getBasePackageName();
  mService=IVibratorService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
}","public SystemVibrator(Context context){
  mPackageName=context.getOpPackageName();
  mService=IVibratorService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
}"
1486,"/** 
 * Adjusts the master volume for the device's audio amplifier. <p>
 * @param steps The number of volume steps to adjust. A positivevalue will raise the volume.
 * @param flags One or more flags.
 * @hide
 */
public void adjustMasterVolume(int steps,int flags){
  IAudioService service=getService();
  try {
    service.adjustMasterVolume(steps,flags,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the master volume for the device's audio amplifier. <p>
 * @param steps The number of volume steps to adjust. A positivevalue will raise the volume.
 * @param flags One or more flags.
 * @hide
 */
public void adjustMasterVolume(int steps,int flags){
  IAudioService service=getService();
  try {
    service.adjustMasterVolume(steps,flags,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1487,"/** 
 * @hide Used internally by telephony package to request audio focus. Will cause the focus request to be associated with the ""voice communication"" identifier only used in AudioService to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL forthe establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended somedia applications resume after a call
 */
public void requestAudioFocusForCall(int streamType,int durationHint){
  IAudioService service=getService();
  try {
    service.requestAudioFocus(streamType,durationHint,mICallBack,null,MediaFocusControl.IN_VOICE_COMM_FOCUS_ID,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}","/** 
 * @hide Used internally by telephony package to request audio focus. Will cause the focus request to be associated with the ""voice communication"" identifier only used in AudioService to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL forthe establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended somedia applications resume after a call
 */
public void requestAudioFocusForCall(int streamType,int durationHint){
  IAudioService service=getService();
  try {
    service.requestAudioFocus(streamType,durationHint,mICallBack,null,MediaFocusControl.IN_VOICE_COMM_FOCUS_ID,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}"
1488,"/** 
 * Request audio focus. Send a request to obtain the audio focus
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Alternatively use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary requestthat benefits from the system not playing disruptive sounds like notifications, for usecases such as voice memo recording, or speech recognition. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l),mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * Request audio focus. Send a request to obtain the audio focus
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Alternatively use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary requestthat benefits from the system not playing disruptive sounds like notifications, for usecases such as voice memo recording, or speech recognition. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l),mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}"
1489,"/** 
 * Adjusts the volume of a particular stream by one step in a direction. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getBasePackageName());
    }
 else {
      service.adjustStreamVolume(streamType,direction,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of a particular stream by one step in a direction. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getOpPackageName());
    }
 else {
      service.adjustStreamVolume(streamType,direction,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1490,"/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getBasePackageName());
    }
 else {
      service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getOpPackageName());
    }
 else {
      service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1491,"/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getBasePackageName());
    }
 else {
      service.adjustVolume(direction,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.adjustMasterVolume(direction,flags,mContext.getOpPackageName());
    }
 else {
      service.adjustVolume(direction,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1492,"/** 
 * Sets the volume index for master volume.
 * @param index The volume index to set. See{@link #getMasterMaxVolume()} for the largest valid value.
 * @param flags One or more flags.
 * @see #getMasterMaxVolume()
 * @see #getMasterVolume()
 * @hide
 */
public void setMasterVolume(int index,int flags){
  IAudioService service=getService();
  try {
    service.setMasterVolume(index,flags,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the volume index for master volume.
 * @param index The volume index to set. See{@link #getMasterMaxVolume()} for the largest valid value.
 * @param flags One or more flags.
 * @see #getMasterMaxVolume()
 * @see #getMasterVolume()
 * @hide
 */
public void setMasterVolume(int index,int flags){
  IAudioService service=getService();
  try {
    service.setMasterVolume(index,flags,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1493,"/** 
 * Sets the volume index for a particular stream.
 * @param streamType The stream whose volume index should be set.
 * @param index The volume index to set. See{@link #getStreamMaxVolume(int)} for the largest valid value.
 * @param flags One or more flags.
 * @see #getStreamMaxVolume(int)
 * @see #getStreamVolume(int)
 */
public void setStreamVolume(int streamType,int index,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.setMasterVolume(index,flags,mContext.getBasePackageName());
    }
 else {
      service.setStreamVolume(streamType,index,flags,mContext.getBasePackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the volume index for a particular stream.
 * @param streamType The stream whose volume index should be set.
 * @param index The volume index to set. See{@link #getStreamMaxVolume(int)} for the largest valid value.
 * @param flags One or more flags.
 * @see #getStreamMaxVolume(int)
 * @see #getStreamVolume(int)
 */
public void setStreamVolume(int streamType,int index,int flags){
  IAudioService service=getService();
  try {
    if (mUseMasterVolume) {
      service.setMasterVolume(index,flags,mContext.getOpPackageName());
    }
 else {
      service.setStreamVolume(streamType,index,flags,mContext.getOpPackageName());
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1494,"/** 
 * @hide If the stream is active locally or remotely, adjust its volume according to the enforced priority rules. Note: only AudioManager.STREAM_MUSIC is supported at the moment
 */
public void adjustLocalOrRemoteStreamVolume(int streamType,int direction){
  if (streamType != STREAM_MUSIC) {
    Log.w(TAG,""String_Node_Str"" + streamType);
  }
  IAudioService service=getService();
  try {
    service.adjustLocalOrRemoteStreamVolume(streamType,direction,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * @hide If the stream is active locally or remotely, adjust its volume according to the enforced priority rules. Note: only AudioManager.STREAM_MUSIC is supported at the moment
 */
public void adjustLocalOrRemoteStreamVolume(int streamType,int direction){
  if (streamType != STREAM_MUSIC) {
    Log.w(TAG,""String_Node_Str"" + streamType);
  }
  IAudioService service=getService();
  try {
    service.adjustLocalOrRemoteStreamVolume(streamType,direction,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
1495,"/** 
 * Tell the audio service to adjust the volume appropriate to the event.
 * @param keycode
 */
void handleVolumeKey(int stream,int keycode){
  IAudioService audioService=getAudioService();
  if (audioService == null) {
    return;
  }
  try {
    mBroadcastWakeLock.acquire();
    audioService.adjustStreamVolume(stream,keycode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER,0,mContext.getBasePackageName());
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + e);
  }
 finally {
    mBroadcastWakeLock.release();
  }
}","/** 
 * Tell the audio service to adjust the volume appropriate to the event.
 * @param keycode
 */
void handleVolumeKey(int stream,int keycode){
  IAudioService audioService=getAudioService();
  if (audioService == null) {
    return;
  }
  try {
    mBroadcastWakeLock.acquire();
    audioService.adjustStreamVolume(stream,keycode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER,0,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + e);
  }
 finally {
    mBroadcastWakeLock.release();
  }
}"
1496,"@Override public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  if (!mVibrator.hasVibrator()) {
    return false;
  }
  final boolean hapticsDisabled=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0,UserHandle.USER_CURRENT) == 0;
  if (!always && (hapticsDisabled || mKeyguardDelegate.isShowingAndNotHidden())) {
    return false;
  }
  long[] pattern=null;
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    pattern=mLongPressVibePattern;
  break;
case HapticFeedbackConstants.VIRTUAL_KEY:
pattern=mVirtualKeyVibePattern;
break;
case HapticFeedbackConstants.KEYBOARD_TAP:
pattern=mKeyboardTapVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
pattern=mSafeModeDisabledVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
pattern=mSafeModeEnabledVibePattern;
break;
default :
return false;
}
int owningUid;
String owningPackage;
if (win != null) {
owningUid=win.getOwningUid();
owningPackage=win.getOwningPackage();
}
 else {
owningUid=android.os.Process.myUid();
owningPackage=mContext.getBasePackageName();
}
if (pattern.length == 1) {
mVibrator.vibrate(owningUid,owningPackage,pattern[0]);
}
 else {
mVibrator.vibrate(owningUid,owningPackage,pattern,-1);
}
return true;
}","@Override public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  if (!mVibrator.hasVibrator()) {
    return false;
  }
  final boolean hapticsDisabled=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0,UserHandle.USER_CURRENT) == 0;
  if (!always && (hapticsDisabled || mKeyguardDelegate.isShowingAndNotHidden())) {
    return false;
  }
  long[] pattern=null;
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    pattern=mLongPressVibePattern;
  break;
case HapticFeedbackConstants.VIRTUAL_KEY:
pattern=mVirtualKeyVibePattern;
break;
case HapticFeedbackConstants.KEYBOARD_TAP:
pattern=mKeyboardTapVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
pattern=mSafeModeDisabledVibePattern;
break;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
pattern=mSafeModeEnabledVibePattern;
break;
default :
return false;
}
int owningUid;
String owningPackage;
if (win != null) {
owningUid=win.getOwningUid();
owningPackage=win.getOwningPackage();
}
 else {
owningUid=android.os.Process.myUid();
owningPackage=mContext.getOpPackageName();
}
if (pattern.length == 1) {
mVibrator.vibrate(owningUid,owningPackage,pattern[0]);
}
 else {
mVibrator.vibrate(owningUid,owningPackage,pattern,-1);
}
return true;
}"
1497,"/** 
 * Returns the neighboring cell information of the device. The getAllCellInfo is preferred and use this only if getAllCellInfo return nulls or an empty list. <p> In the future this call will be deprecated. <p>
 * @return List of NeighboringCellInfo or null if info unavailable.<p>Requires Permission: (@link android.Manifest.permission#ACCESS_COARSE_UPDATES}
 */
public List<NeighboringCellInfo> getNeighboringCellInfo(){
  try {
    return getITelephony().getNeighboringCellInfo(mContext.getBasePackageName());
  }
 catch (  RemoteException ex) {
    return null;
  }
catch (  NullPointerException ex) {
    return null;
  }
}","/** 
 * Returns the neighboring cell information of the device. The getAllCellInfo is preferred and use this only if getAllCellInfo return nulls or an empty list. <p> In the future this call will be deprecated. <p>
 * @return List of NeighboringCellInfo or null if info unavailable.<p>Requires Permission: (@link android.Manifest.permission#ACCESS_COARSE_UPDATES}
 */
public List<NeighboringCellInfo> getNeighboringCellInfo(){
  try {
    return getITelephony().getNeighboringCellInfo(mContext.getOpPackageName());
  }
 catch (  RemoteException ex) {
    return null;
  }
catch (  NullPointerException ex) {
    return null;
  }
}"
1498,"/** 
 * {@hide} 
 */
public static void closeQuietly(ContentProviderClient client){
  if (client != null) {
    client.release();
  }
}","/** 
 * {@hide} 
 */
public static void closeQuietly(ContentProviderClient client){
  if (client != null) {
    try {
      client.release();
    }
 catch (    Exception ignored) {
    }
  }
}"
1499,"/** 
 * {@hide} 
 */
public static void closeQuietly(ContentProviderClient client){
  if (client != null) {
    client.release();
  }
}","/** 
 * {@hide} 
 */
public static void closeQuietly(ContentProviderClient client){
  if (client != null) {
    try {
      client.release();
    }
 catch (    Exception ignored) {
    }
  }
}"
1500,"/** 
 * {@hide} 
 */
public static void closeQuietly(ContentProviderClient client){
  if (client != null) {
    client.release();
  }
}","/** 
 * {@hide} 
 */
public static void closeQuietly(ContentProviderClient client){
  if (client != null) {
    try {
      client.release();
    }
 catch (    Exception ignored) {
    }
  }
}"
1501,"/** 
 * {@hide} 
 */
public static void closeQuietly(ContentProviderClient client){
  if (client != null) {
    client.release();
  }
}","/** 
 * {@hide} 
 */
public static void closeQuietly(ContentProviderClient client){
  if (client != null) {
    try {
      client.release();
    }
 catch (    Exception ignored) {
    }
  }
}"
1502,"/** 
 * @hide 
 */
public static int checkComponentPermission(String permission,int uid,int owningUid,boolean exported){
  if (uid == 0 || uid == Process.SYSTEM_UID) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (UserHandle.isIsolated(uid)) {
    return PackageManager.PERMISSION_DENIED;
  }
  if (owningUid >= 0 && UserHandle.isSameApp(uid,owningUid)) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (!exported) {
    Slog.w(TAG,""String_Node_Str"" + owningUid);
    return PackageManager.PERMISSION_DENIED;
  }
  if (permission == null) {
    return PackageManager.PERMISSION_GRANTED;
  }
  try {
    return AppGlobals.getPackageManager().checkUidPermission(permission,uid);
  }
 catch (  RemoteException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  return PackageManager.PERMISSION_DENIED;
}","/** 
 * @hide 
 */
public static int checkComponentPermission(String permission,int uid,int owningUid,boolean exported){
  if (uid == 0 || uid == Process.SYSTEM_UID) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (UserHandle.isIsolated(uid)) {
    return PackageManager.PERMISSION_DENIED;
  }
  if (owningUid >= 0 && UserHandle.isSameApp(uid,owningUid)) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (!exported) {
    return PackageManager.PERMISSION_DENIED;
  }
  if (permission == null) {
    return PackageManager.PERMISSION_GRANTED;
  }
  try {
    return AppGlobals.getPackageManager().checkUidPermission(permission,uid);
  }
 catch (  RemoteException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  return PackageManager.PERMISSION_DENIED;
}"
1503,"/** 
 * @hide 
 */
public static int checkComponentPermission(String permission,int uid,int owningUid,boolean exported){
  if (uid == 0 || uid == Process.SYSTEM_UID) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (UserHandle.isIsolated(uid)) {
    return PackageManager.PERMISSION_DENIED;
  }
  if (owningUid >= 0 && UserHandle.isSameApp(uid,owningUid)) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (!exported) {
    Slog.w(TAG,""String_Node_Str"" + owningUid);
    return PackageManager.PERMISSION_DENIED;
  }
  if (permission == null) {
    return PackageManager.PERMISSION_GRANTED;
  }
  try {
    return AppGlobals.getPackageManager().checkUidPermission(permission,uid);
  }
 catch (  RemoteException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  return PackageManager.PERMISSION_DENIED;
}","/** 
 * @hide 
 */
public static int checkComponentPermission(String permission,int uid,int owningUid,boolean exported){
  if (uid == 0 || uid == Process.SYSTEM_UID) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (UserHandle.isIsolated(uid)) {
    return PackageManager.PERMISSION_DENIED;
  }
  if (owningUid >= 0 && UserHandle.isSameApp(uid,owningUid)) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (!exported) {
    return PackageManager.PERMISSION_DENIED;
  }
  if (permission == null) {
    return PackageManager.PERMISSION_GRANTED;
  }
  try {
    return AppGlobals.getPackageManager().checkUidPermission(permission,uid);
  }
 catch (  RemoteException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  return PackageManager.PERMISSION_DENIED;
}"
1504,"/** 
 * @hide 
 */
public static int checkComponentPermission(String permission,int uid,int owningUid,boolean exported){
  if (uid == 0 || uid == Process.SYSTEM_UID) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (UserHandle.isIsolated(uid)) {
    return PackageManager.PERMISSION_DENIED;
  }
  if (owningUid >= 0 && UserHandle.isSameApp(uid,owningUid)) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (!exported) {
    Slog.w(TAG,""String_Node_Str"" + owningUid);
    return PackageManager.PERMISSION_DENIED;
  }
  if (permission == null) {
    return PackageManager.PERMISSION_GRANTED;
  }
  try {
    return AppGlobals.getPackageManager().checkUidPermission(permission,uid);
  }
 catch (  RemoteException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  return PackageManager.PERMISSION_DENIED;
}","/** 
 * @hide 
 */
public static int checkComponentPermission(String permission,int uid,int owningUid,boolean exported){
  if (uid == 0 || uid == Process.SYSTEM_UID) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (UserHandle.isIsolated(uid)) {
    return PackageManager.PERMISSION_DENIED;
  }
  if (owningUid >= 0 && UserHandle.isSameApp(uid,owningUid)) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (!exported) {
    return PackageManager.PERMISSION_DENIED;
  }
  if (permission == null) {
    return PackageManager.PERMISSION_GRANTED;
  }
  try {
    return AppGlobals.getPackageManager().checkUidPermission(permission,uid);
  }
 catch (  RemoteException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  return PackageManager.PERMISSION_DENIED;
}"
1505,"/** 
 * @hide 
 */
public static int checkComponentPermission(String permission,int uid,int owningUid,boolean exported){
  if (uid == 0 || uid == Process.SYSTEM_UID) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (UserHandle.isIsolated(uid)) {
    return PackageManager.PERMISSION_DENIED;
  }
  if (owningUid >= 0 && UserHandle.isSameApp(uid,owningUid)) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (!exported) {
    Slog.w(TAG,""String_Node_Str"" + owningUid);
    return PackageManager.PERMISSION_DENIED;
  }
  if (permission == null) {
    return PackageManager.PERMISSION_GRANTED;
  }
  try {
    return AppGlobals.getPackageManager().checkUidPermission(permission,uid);
  }
 catch (  RemoteException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  return PackageManager.PERMISSION_DENIED;
}","/** 
 * @hide 
 */
public static int checkComponentPermission(String permission,int uid,int owningUid,boolean exported){
  if (uid == 0 || uid == Process.SYSTEM_UID) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (UserHandle.isIsolated(uid)) {
    return PackageManager.PERMISSION_DENIED;
  }
  if (owningUid >= 0 && UserHandle.isSameApp(uid,owningUid)) {
    return PackageManager.PERMISSION_GRANTED;
  }
  if (!exported) {
    return PackageManager.PERMISSION_DENIED;
  }
  if (permission == null) {
    return PackageManager.PERMISSION_GRANTED;
  }
  try {
    return AppGlobals.getPackageManager().checkUidPermission(permission,uid);
  }
 catch (  RemoteException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  return PackageManager.PERMISSION_DENIED;
}"
1506,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (DEBUG_BACKUP) {
        Slog.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.logo=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_logo,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_requiredForAllUsers,false)) {
    owner.mRequiredForAllUsers=true;
  }
  String restrictedAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_restrictedAccountType);
  if (restrictedAccountType != null && restrictedAccountType.length() > 0) {
    owner.mRestrictedAccountType=restrictedAccountType;
  }
  String requiredAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_requiredAccountType);
  if (requiredAccountType != null && requiredAccountType.length() > 0) {
    owner.mRequiredAccountType=requiredAccountType;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  boolean hardwareAccelerated=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hardwareAccelerated,owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.ICE_CREAM_SANDWICH);
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_largeHeap,false)) {
    ai.flags|=ApplicationInfo.FLAG_LARGE_HEAP;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_supportsRtl,false)) {
    ai.flags|=ApplicationInfo.FLAG_SUPPORTS_RTL;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
    if (false) {
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_cantSaveState,false)) {
        ai.flags|=ApplicationInfo.FLAG_CANT_SAVE_STATE;
        if (ai.processName != null && ai.processName != ai.packageName) {
          outError[0]=""String_Node_Str"";
        }
      }
    }
  }
  ai.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestApplication_uiOptions,0);
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false,hardwareAccelerated);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestLibrary_name);
      sa.recycle();
      if (lname != null) {
        if (owner.libraryNames == null) {
          owner.libraryNames=new ArrayList<String>();
        }
        if (!owner.libraryNames.contains(lname)) {
          owner.libraryNames.add(lname.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,Configuration.NATIVE_CONFIG_VERSION);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,Configuration.NATIVE_CONFIG_VERSION);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (DEBUG_BACKUP) {
        Slog.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.logo=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_logo,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_requiredForAllUsers,false)) {
    owner.mRequiredForAllUsers=true;
  }
  String restrictedAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_restrictedAccountType);
  if (restrictedAccountType != null && restrictedAccountType.length() > 0) {
    owner.mRestrictedAccountType=restrictedAccountType;
  }
  String requiredAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_requiredAccountType);
  if (requiredAccountType != null && requiredAccountType.length() > 0) {
    owner.mRequiredAccountType=requiredAccountType;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  boolean hardwareAccelerated=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hardwareAccelerated,owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.ICE_CREAM_SANDWICH);
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_largeHeap,false)) {
    ai.flags|=ApplicationInfo.FLAG_LARGE_HEAP;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_supportsRtl,false)) {
    ai.flags|=ApplicationInfo.FLAG_SUPPORTS_RTL;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,Configuration.NATIVE_CONFIG_VERSION);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,Configuration.NATIVE_CONFIG_VERSION);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
    if (false) {
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_cantSaveState,false)) {
        ai.flags|=ApplicationInfo.FLAG_CANT_SAVE_STATE;
        if (ai.processName != null && ai.processName != ai.packageName) {
          outError[0]=""String_Node_Str"";
        }
      }
    }
  }
  ai.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestApplication_uiOptions,0);
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false,hardwareAccelerated);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestLibrary_name);
      sa.recycle();
      if (lname != null) {
        if (owner.libraryNames == null) {
          owner.libraryNames=new ArrayList<String>();
        }
        if (!owner.libraryNames.contains(lname)) {
          owner.libraryNames.add(lname.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}"
1507,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity,0);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,com.android.internal.R.styleable.AndroidManifestActivityAlias_logo,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_description,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.logo=target.info.logo;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  if (info.descriptionRes == 0) {
    info.descriptionRes=target.info.descriptionRes;
  }
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  info.softInputMode=target.info.softInputMode;
  info.uiOptions=target.info.uiOptions;
  info.parentActivityName=target.info.parentActivityName;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission,0);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_parentActivityName,0);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity,Configuration.NATIVE_CONFIG_VERSION);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,com.android.internal.R.styleable.AndroidManifestActivityAlias_logo,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_description,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.logo=target.info.logo;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  if (info.descriptionRes == 0) {
    info.descriptionRes=target.info.descriptionRes;
  }
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  info.softInputMode=target.info.softInputMode;
  info.uiOptions=target.info.uiOptions;
  info.parentActivityName=target.info.parentActivityName;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission,0);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_parentActivityName,Configuration.NATIVE_CONFIG_VERSION);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
1508,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver,boolean hardwareAccelerated) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,com.android.internal.R.styleable.AndroidManifestActivity_logo,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_description,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  a.info.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_uiOptions,a.info.applicationInfo.uiOptions);
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_parentActivityName,0);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_permission,0);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity,0);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_showOnLockScreen,false)) {
    a.info.flags|=ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_immersive,false)) {
    a.info.flags|=ActivityInfo.FLAG_IMMERSIVE;
  }
  if (!receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_hardwareAccelerated,hardwareAccelerated)) {
      a.info.flags|=ActivityInfo.FLAG_HARDWARE_ACCELERATED;
    }
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  if (receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_singleUser,false)) {
      a.info.flags|=ActivityInfo.FLAG_SINGLE_USER;
      if (a.info.exported) {
        Slog.w(TAG,""String_Node_Str"" + a.className + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        a.info.exported=false;
      }
      setExported=true;
    }
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_primaryUserOnly,false)) {
      a.info.flags|=ActivityInfo.FLAG_PRIMARY_USER_ONLY;
    }
  }
  sa.recycle();
  if (receiver && (owner.applicationInfo.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
    if (a.info.processName == owner.packageName) {
      outError[0]=""String_Node_Str"";
    }
  }
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (!receiver && parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,false,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        if (owner.preferredActivityFilters == null) {
          owner.preferredActivityFilters=new ArrayList<ActivityIntentInfo>();
        }
        owner.preferredActivityFilters.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        if (receiver) {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
 else {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver,boolean hardwareAccelerated) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,com.android.internal.R.styleable.AndroidManifestActivity_logo,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_description,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  a.info.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_uiOptions,a.info.applicationInfo.uiOptions);
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_parentActivityName,Configuration.NATIVE_CONFIG_VERSION);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_permission,0);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity,Configuration.NATIVE_CONFIG_VERSION);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_showOnLockScreen,false)) {
    a.info.flags|=ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_immersive,false)) {
    a.info.flags|=ActivityInfo.FLAG_IMMERSIVE;
  }
  if (!receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_hardwareAccelerated,hardwareAccelerated)) {
      a.info.flags|=ActivityInfo.FLAG_HARDWARE_ACCELERATED;
    }
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  if (receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_singleUser,false)) {
      a.info.flags|=ActivityInfo.FLAG_SINGLE_USER;
      if (a.info.exported) {
        Slog.w(TAG,""String_Node_Str"" + a.className + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        a.info.exported=false;
      }
      setExported=true;
    }
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_primaryUserOnly,false)) {
      a.info.flags|=ActivityInfo.FLAG_PRIMARY_USER_ONLY;
    }
  }
  sa.recycle();
  if (receiver && (owner.applicationInfo.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
    if (a.info.processName == owner.packageName) {
      outError[0]=""String_Node_Str"";
    }
  }
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (!receiver && parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,false,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        if (owner.preferredActivityFilters == null) {
          owner.preferredActivityFilters=new ArrayList<ActivityIntentInfo>();
        }
        owner.preferredActivityFilters.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        if (receiver) {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
 else {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
1509,"/** 
 * @hide Retrieve the string value for the attribute at <var>index</var> that is not allowed to change with the given configurations.
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations fromActivityInfo that are allowed to change.
 * @return String holding string data.  Any styling information isremoved.  Returns null if the attribute is not defined.
 */
public String getNonConfigurationString(int index,int allowedChangingConfigs){
  index*=AssetManager.STYLE_NUM_ENTRIES;
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
    return null;
  }
  if (type == TypedValue.TYPE_NULL) {
    return null;
  }
 else   if (type == TypedValue.TYPE_STRING) {
    return loadStringValueAt(index).toString();
  }
  TypedValue v=mValue;
  if (getValueAt(index,v)) {
    Log.w(Resources.TAG,""String_Node_Str"" + v);
    CharSequence cs=v.coerceToString();
    return cs != null ? cs.toString() : null;
  }
  Log.w(Resources.TAG,""String_Node_Str"" + Integer.toHexString(type));
  return null;
}","/** 
 * @hide Retrieve the string value for the attribute at <var>index</var> that is not allowed to change with the given configurations.
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations from{@link Configuration}.NATIVE_CONFIG_* that are allowed to change.
 * @return String holding string data.  Any styling information isremoved.  Returns null if the attribute is not defined.
 */
public String getNonConfigurationString(int index,int allowedChangingConfigs){
  index*=AssetManager.STYLE_NUM_ENTRIES;
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
    return null;
  }
  if (type == TypedValue.TYPE_NULL) {
    return null;
  }
 else   if (type == TypedValue.TYPE_STRING) {
    return loadStringValueAt(index).toString();
  }
  TypedValue v=mValue;
  if (getValueAt(index,v)) {
    Log.w(Resources.TAG,""String_Node_Str"" + v);
    CharSequence cs=v.coerceToString();
    return cs != null ? cs.toString() : null;
  }
  Log.w(Resources.TAG,""String_Node_Str"" + Integer.toHexString(type));
  return null;
}"
1510,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (DEBUG_BACKUP) {
        Slog.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.logo=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_logo,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_requiredForAllUsers,false)) {
    owner.mRequiredForAllUsers=true;
  }
  String restrictedAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_restrictedAccountType);
  if (restrictedAccountType != null && restrictedAccountType.length() > 0) {
    owner.mRestrictedAccountType=restrictedAccountType;
  }
  String requiredAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_requiredAccountType);
  if (requiredAccountType != null && requiredAccountType.length() > 0) {
    owner.mRequiredAccountType=requiredAccountType;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  boolean hardwareAccelerated=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hardwareAccelerated,owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.ICE_CREAM_SANDWICH);
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_largeHeap,false)) {
    ai.flags|=ApplicationInfo.FLAG_LARGE_HEAP;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_supportsRtl,false)) {
    ai.flags|=ApplicationInfo.FLAG_SUPPORTS_RTL;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
    if (false) {
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_cantSaveState,false)) {
        ai.flags|=ApplicationInfo.FLAG_CANT_SAVE_STATE;
        if (ai.processName != null && ai.processName != ai.packageName) {
          outError[0]=""String_Node_Str"";
        }
      }
    }
  }
  ai.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestApplication_uiOptions,0);
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false,hardwareAccelerated);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestLibrary_name);
      sa.recycle();
      if (lname != null) {
        if (owner.libraryNames == null) {
          owner.libraryNames=new ArrayList<String>();
        }
        if (!owner.libraryNames.contains(lname)) {
          owner.libraryNames.add(lname.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,Configuration.NATIVE_CONFIG_VERSION);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,Configuration.NATIVE_CONFIG_VERSION);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (DEBUG_BACKUP) {
        Slog.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.logo=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_logo,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_requiredForAllUsers,false)) {
    owner.mRequiredForAllUsers=true;
  }
  String restrictedAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_restrictedAccountType);
  if (restrictedAccountType != null && restrictedAccountType.length() > 0) {
    owner.mRestrictedAccountType=restrictedAccountType;
  }
  String requiredAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_requiredAccountType);
  if (requiredAccountType != null && requiredAccountType.length() > 0) {
    owner.mRequiredAccountType=requiredAccountType;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  boolean hardwareAccelerated=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hardwareAccelerated,owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.ICE_CREAM_SANDWICH);
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_largeHeap,false)) {
    ai.flags|=ApplicationInfo.FLAG_LARGE_HEAP;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_supportsRtl,false)) {
    ai.flags|=ApplicationInfo.FLAG_SUPPORTS_RTL;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,Configuration.NATIVE_CONFIG_VERSION);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,Configuration.NATIVE_CONFIG_VERSION);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
    if (false) {
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_cantSaveState,false)) {
        ai.flags|=ApplicationInfo.FLAG_CANT_SAVE_STATE;
        if (ai.processName != null && ai.processName != ai.packageName) {
          outError[0]=""String_Node_Str"";
        }
      }
    }
  }
  ai.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestApplication_uiOptions,0);
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false,hardwareAccelerated);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestLibrary_name);
      sa.recycle();
      if (lname != null) {
        if (owner.libraryNames == null) {
          owner.libraryNames=new ArrayList<String>();
        }
        if (!owner.libraryNames.contains(lname)) {
          owner.libraryNames.add(lname.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}"
1511,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity,0);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,com.android.internal.R.styleable.AndroidManifestActivityAlias_logo,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_description,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.logo=target.info.logo;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  if (info.descriptionRes == 0) {
    info.descriptionRes=target.info.descriptionRes;
  }
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  info.softInputMode=target.info.softInputMode;
  info.uiOptions=target.info.uiOptions;
  info.parentActivityName=target.info.parentActivityName;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission,0);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_parentActivityName,0);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity,Configuration.NATIVE_CONFIG_VERSION);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,com.android.internal.R.styleable.AndroidManifestActivityAlias_logo,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_description,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.logo=target.info.logo;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  if (info.descriptionRes == 0) {
    info.descriptionRes=target.info.descriptionRes;
  }
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  info.softInputMode=target.info.softInputMode;
  info.uiOptions=target.info.uiOptions;
  info.parentActivityName=target.info.parentActivityName;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission,0);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_parentActivityName,Configuration.NATIVE_CONFIG_VERSION);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
1512,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver,boolean hardwareAccelerated) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,com.android.internal.R.styleable.AndroidManifestActivity_logo,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_description,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  a.info.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_uiOptions,a.info.applicationInfo.uiOptions);
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_parentActivityName,0);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_permission,0);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity,0);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_showOnLockScreen,false)) {
    a.info.flags|=ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_immersive,false)) {
    a.info.flags|=ActivityInfo.FLAG_IMMERSIVE;
  }
  if (!receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_hardwareAccelerated,hardwareAccelerated)) {
      a.info.flags|=ActivityInfo.FLAG_HARDWARE_ACCELERATED;
    }
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  if (receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_singleUser,false)) {
      a.info.flags|=ActivityInfo.FLAG_SINGLE_USER;
      if (a.info.exported) {
        Slog.w(TAG,""String_Node_Str"" + a.className + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        a.info.exported=false;
      }
      setExported=true;
    }
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_primaryUserOnly,false)) {
      a.info.flags|=ActivityInfo.FLAG_PRIMARY_USER_ONLY;
    }
  }
  sa.recycle();
  if (receiver && (owner.applicationInfo.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
    if (a.info.processName == owner.packageName) {
      outError[0]=""String_Node_Str"";
    }
  }
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (!receiver && parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,false,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        if (owner.preferredActivityFilters == null) {
          owner.preferredActivityFilters=new ArrayList<ActivityIntentInfo>();
        }
        owner.preferredActivityFilters.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        if (receiver) {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
 else {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver,boolean hardwareAccelerated) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,com.android.internal.R.styleable.AndroidManifestActivity_logo,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_description,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  a.info.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_uiOptions,a.info.applicationInfo.uiOptions);
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_parentActivityName,Configuration.NATIVE_CONFIG_VERSION);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_permission,0);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity,Configuration.NATIVE_CONFIG_VERSION);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_showOnLockScreen,false)) {
    a.info.flags|=ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_immersive,false)) {
    a.info.flags|=ActivityInfo.FLAG_IMMERSIVE;
  }
  if (!receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_hardwareAccelerated,hardwareAccelerated)) {
      a.info.flags|=ActivityInfo.FLAG_HARDWARE_ACCELERATED;
    }
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  if (receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_singleUser,false)) {
      a.info.flags|=ActivityInfo.FLAG_SINGLE_USER;
      if (a.info.exported) {
        Slog.w(TAG,""String_Node_Str"" + a.className + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        a.info.exported=false;
      }
      setExported=true;
    }
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_primaryUserOnly,false)) {
      a.info.flags|=ActivityInfo.FLAG_PRIMARY_USER_ONLY;
    }
  }
  sa.recycle();
  if (receiver && (owner.applicationInfo.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
    if (a.info.processName == owner.packageName) {
      outError[0]=""String_Node_Str"";
    }
  }
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (!receiver && parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,false,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        if (owner.preferredActivityFilters == null) {
          owner.preferredActivityFilters=new ArrayList<ActivityIntentInfo>();
        }
        owner.preferredActivityFilters.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        if (receiver) {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
 else {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
1513,"/** 
 * @hide Retrieve the string value for the attribute at <var>index</var> that is not allowed to change with the given configurations.
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations fromActivityInfo that are allowed to change.
 * @return String holding string data.  Any styling information isremoved.  Returns null if the attribute is not defined.
 */
public String getNonConfigurationString(int index,int allowedChangingConfigs){
  index*=AssetManager.STYLE_NUM_ENTRIES;
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
    return null;
  }
  if (type == TypedValue.TYPE_NULL) {
    return null;
  }
 else   if (type == TypedValue.TYPE_STRING) {
    return loadStringValueAt(index).toString();
  }
  TypedValue v=mValue;
  if (getValueAt(index,v)) {
    Log.w(Resources.TAG,""String_Node_Str"" + v);
    CharSequence cs=v.coerceToString();
    return cs != null ? cs.toString() : null;
  }
  Log.w(Resources.TAG,""String_Node_Str"" + Integer.toHexString(type));
  return null;
}","/** 
 * @hide Retrieve the string value for the attribute at <var>index</var> that is not allowed to change with the given configurations.
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations from{@link Configuration}.NATIVE_CONFIG_* that are allowed to change.
 * @return String holding string data.  Any styling information isremoved.  Returns null if the attribute is not defined.
 */
public String getNonConfigurationString(int index,int allowedChangingConfigs){
  index*=AssetManager.STYLE_NUM_ENTRIES;
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
    return null;
  }
  if (type == TypedValue.TYPE_NULL) {
    return null;
  }
 else   if (type == TypedValue.TYPE_STRING) {
    return loadStringValueAt(index).toString();
  }
  TypedValue v=mValue;
  if (getValueAt(index,v)) {
    Log.w(Resources.TAG,""String_Node_Str"" + v);
    CharSequence cs=v.coerceToString();
    return cs != null ? cs.toString() : null;
  }
  Log.w(Resources.TAG,""String_Node_Str"" + Integer.toHexString(type));
  return null;
}"
1514,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (DEBUG_BACKUP) {
        Slog.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.logo=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_logo,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_requiredForAllUsers,false)) {
    owner.mRequiredForAllUsers=true;
  }
  String restrictedAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_restrictedAccountType);
  if (restrictedAccountType != null && restrictedAccountType.length() > 0) {
    owner.mRestrictedAccountType=restrictedAccountType;
  }
  String requiredAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_requiredAccountType);
  if (requiredAccountType != null && requiredAccountType.length() > 0) {
    owner.mRequiredAccountType=requiredAccountType;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  boolean hardwareAccelerated=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hardwareAccelerated,owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.ICE_CREAM_SANDWICH);
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_largeHeap,false)) {
    ai.flags|=ApplicationInfo.FLAG_LARGE_HEAP;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_supportsRtl,false)) {
    ai.flags|=ApplicationInfo.FLAG_SUPPORTS_RTL;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
    if (false) {
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_cantSaveState,false)) {
        ai.flags|=ApplicationInfo.FLAG_CANT_SAVE_STATE;
        if (ai.processName != null && ai.processName != ai.packageName) {
          outError[0]=""String_Node_Str"";
        }
      }
    }
  }
  ai.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestApplication_uiOptions,0);
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false,hardwareAccelerated);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestLibrary_name);
      sa.recycle();
      if (lname != null) {
        if (owner.libraryNames == null) {
          owner.libraryNames=new ArrayList<String>();
        }
        if (!owner.libraryNames.contains(lname)) {
          owner.libraryNames.add(lname.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,Configuration.NATIVE_CONFIG_VERSION);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,Configuration.NATIVE_CONFIG_VERSION);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (DEBUG_BACKUP) {
        Slog.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.logo=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_logo,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_requiredForAllUsers,false)) {
    owner.mRequiredForAllUsers=true;
  }
  String restrictedAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_restrictedAccountType);
  if (restrictedAccountType != null && restrictedAccountType.length() > 0) {
    owner.mRestrictedAccountType=restrictedAccountType;
  }
  String requiredAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_requiredAccountType);
  if (requiredAccountType != null && requiredAccountType.length() > 0) {
    owner.mRequiredAccountType=requiredAccountType;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  boolean hardwareAccelerated=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hardwareAccelerated,owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.ICE_CREAM_SANDWICH);
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_largeHeap,false)) {
    ai.flags|=ApplicationInfo.FLAG_LARGE_HEAP;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_supportsRtl,false)) {
    ai.flags|=ApplicationInfo.FLAG_SUPPORTS_RTL;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,Configuration.NATIVE_CONFIG_VERSION);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,Configuration.NATIVE_CONFIG_VERSION);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
    if (false) {
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_cantSaveState,false)) {
        ai.flags|=ApplicationInfo.FLAG_CANT_SAVE_STATE;
        if (ai.processName != null && ai.processName != ai.packageName) {
          outError[0]=""String_Node_Str"";
        }
      }
    }
  }
  ai.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestApplication_uiOptions,0);
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false,hardwareAccelerated);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestLibrary_name);
      sa.recycle();
      if (lname != null) {
        if (owner.libraryNames == null) {
          owner.libraryNames=new ArrayList<String>();
        }
        if (!owner.libraryNames.contains(lname)) {
          owner.libraryNames.add(lname.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}"
1515,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity,0);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,com.android.internal.R.styleable.AndroidManifestActivityAlias_logo,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_description,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.logo=target.info.logo;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  if (info.descriptionRes == 0) {
    info.descriptionRes=target.info.descriptionRes;
  }
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  info.softInputMode=target.info.softInputMode;
  info.uiOptions=target.info.uiOptions;
  info.parentActivityName=target.info.parentActivityName;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission,0);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_parentActivityName,0);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity,Configuration.NATIVE_CONFIG_VERSION);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,com.android.internal.R.styleable.AndroidManifestActivityAlias_logo,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_description,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.logo=target.info.logo;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  if (info.descriptionRes == 0) {
    info.descriptionRes=target.info.descriptionRes;
  }
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  info.softInputMode=target.info.softInputMode;
  info.uiOptions=target.info.uiOptions;
  info.parentActivityName=target.info.parentActivityName;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission,0);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_parentActivityName,Configuration.NATIVE_CONFIG_VERSION);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
1516,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver,boolean hardwareAccelerated) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,com.android.internal.R.styleable.AndroidManifestActivity_logo,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_description,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  a.info.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_uiOptions,a.info.applicationInfo.uiOptions);
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_parentActivityName,0);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_permission,0);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity,0);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_showOnLockScreen,false)) {
    a.info.flags|=ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_immersive,false)) {
    a.info.flags|=ActivityInfo.FLAG_IMMERSIVE;
  }
  if (!receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_hardwareAccelerated,hardwareAccelerated)) {
      a.info.flags|=ActivityInfo.FLAG_HARDWARE_ACCELERATED;
    }
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  if (receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_singleUser,false)) {
      a.info.flags|=ActivityInfo.FLAG_SINGLE_USER;
      if (a.info.exported) {
        Slog.w(TAG,""String_Node_Str"" + a.className + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        a.info.exported=false;
      }
      setExported=true;
    }
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_primaryUserOnly,false)) {
      a.info.flags|=ActivityInfo.FLAG_PRIMARY_USER_ONLY;
    }
  }
  sa.recycle();
  if (receiver && (owner.applicationInfo.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
    if (a.info.processName == owner.packageName) {
      outError[0]=""String_Node_Str"";
    }
  }
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (!receiver && parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,false,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        if (owner.preferredActivityFilters == null) {
          owner.preferredActivityFilters=new ArrayList<ActivityIntentInfo>();
        }
        owner.preferredActivityFilters.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        if (receiver) {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
 else {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver,boolean hardwareAccelerated) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,com.android.internal.R.styleable.AndroidManifestActivity_logo,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_description,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  a.info.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_uiOptions,a.info.applicationInfo.uiOptions);
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_parentActivityName,Configuration.NATIVE_CONFIG_VERSION);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_permission,0);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity,Configuration.NATIVE_CONFIG_VERSION);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_showOnLockScreen,false)) {
    a.info.flags|=ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_immersive,false)) {
    a.info.flags|=ActivityInfo.FLAG_IMMERSIVE;
  }
  if (!receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_hardwareAccelerated,hardwareAccelerated)) {
      a.info.flags|=ActivityInfo.FLAG_HARDWARE_ACCELERATED;
    }
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  if (receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_singleUser,false)) {
      a.info.flags|=ActivityInfo.FLAG_SINGLE_USER;
      if (a.info.exported) {
        Slog.w(TAG,""String_Node_Str"" + a.className + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        a.info.exported=false;
      }
      setExported=true;
    }
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_primaryUserOnly,false)) {
      a.info.flags|=ActivityInfo.FLAG_PRIMARY_USER_ONLY;
    }
  }
  sa.recycle();
  if (receiver && (owner.applicationInfo.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
    if (a.info.processName == owner.packageName) {
      outError[0]=""String_Node_Str"";
    }
  }
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (!receiver && parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,false,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        if (owner.preferredActivityFilters == null) {
          owner.preferredActivityFilters=new ArrayList<ActivityIntentInfo>();
        }
        owner.preferredActivityFilters.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        if (receiver) {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
 else {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
1517,"/** 
 * @hide Retrieve the string value for the attribute at <var>index</var> that is not allowed to change with the given configurations.
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations fromActivityInfo that are allowed to change.
 * @return String holding string data.  Any styling information isremoved.  Returns null if the attribute is not defined.
 */
public String getNonConfigurationString(int index,int allowedChangingConfigs){
  index*=AssetManager.STYLE_NUM_ENTRIES;
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
    return null;
  }
  if (type == TypedValue.TYPE_NULL) {
    return null;
  }
 else   if (type == TypedValue.TYPE_STRING) {
    return loadStringValueAt(index).toString();
  }
  TypedValue v=mValue;
  if (getValueAt(index,v)) {
    Log.w(Resources.TAG,""String_Node_Str"" + v);
    CharSequence cs=v.coerceToString();
    return cs != null ? cs.toString() : null;
  }
  Log.w(Resources.TAG,""String_Node_Str"" + Integer.toHexString(type));
  return null;
}","/** 
 * @hide Retrieve the string value for the attribute at <var>index</var> that is not allowed to change with the given configurations.
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations from{@link Configuration}.NATIVE_CONFIG_* that are allowed to change.
 * @return String holding string data.  Any styling information isremoved.  Returns null if the attribute is not defined.
 */
public String getNonConfigurationString(int index,int allowedChangingConfigs){
  index*=AssetManager.STYLE_NUM_ENTRIES;
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
    return null;
  }
  if (type == TypedValue.TYPE_NULL) {
    return null;
  }
 else   if (type == TypedValue.TYPE_STRING) {
    return loadStringValueAt(index).toString();
  }
  TypedValue v=mValue;
  if (getValueAt(index,v)) {
    Log.w(Resources.TAG,""String_Node_Str"" + v);
    CharSequence cs=v.coerceToString();
    return cs != null ? cs.toString() : null;
  }
  Log.w(Resources.TAG,""String_Node_Str"" + Integer.toHexString(type));
  return null;
}"
1518,"/** 
 * Releases resources associated with this MediaPlayer object. It is considered good practice to call this method when you're done using the MediaPlayer. In particular, whenever an Activity of an application is paused (its onPause() method is called), or stopped (its onStop() method is called), this method should be invoked to release the MediaPlayer object, unless the application has a special need to keep the object around. In addition to unnecessary resources (such as memory and instances of codecs) being held, failure to call this method immediately if a MediaPlayer object is no longer needed may also lead to continuous battery consumption for mobile devices, and playback failure for other applications if no multiple instances of the same codec are supported on a device. Even if multiple instances of the same codec are supported, some performance degradation may be expected when unnecessary multiple instances are used at the same time.
 */
public void release(){
  stayAwake(false);
  updateSurfaceScreenOn();
  mOnPreparedListener=null;
  mOnBufferingUpdateListener=null;
  mOnCompletionListener=null;
  mOnSeekCompleteListener=null;
  mOnErrorListener=null;
  mOnInfoListener=null;
  mOnVideoSizeChangedListener=null;
  mOnTimedTextListener=null;
  mTimeProvider.close();
  mTimeProvider=null;
  mOnSubtitleDataListener=null;
  _release();
}","/** 
 * Releases resources associated with this MediaPlayer object. It is considered good practice to call this method when you're done using the MediaPlayer. In particular, whenever an Activity of an application is paused (its onPause() method is called), or stopped (its onStop() method is called), this method should be invoked to release the MediaPlayer object, unless the application has a special need to keep the object around. In addition to unnecessary resources (such as memory and instances of codecs) being held, failure to call this method immediately if a MediaPlayer object is no longer needed may also lead to continuous battery consumption for mobile devices, and playback failure for other applications if no multiple instances of the same codec are supported on a device. Even if multiple instances of the same codec are supported, some performance degradation may be expected when unnecessary multiple instances are used at the same time.
 */
public void release(){
  stayAwake(false);
  updateSurfaceScreenOn();
  mOnPreparedListener=null;
  mOnBufferingUpdateListener=null;
  mOnCompletionListener=null;
  mOnSeekCompleteListener=null;
  mOnErrorListener=null;
  mOnInfoListener=null;
  mOnVideoSizeChangedListener=null;
  mOnTimedTextListener=null;
  if (mTimeProvider != null) {
    mTimeProvider.close();
    mTimeProvider=null;
  }
  mOnSubtitleDataListener=null;
  _release();
}"
1519,"/** 
 * Resets the MediaPlayer to its uninitialized state. After calling this method, you will have to initialize it again by setting the data source and calling prepare().
 */
public void reset(){
  mSelectedSubtitleTrackIndex=-1;
synchronized (mOpenSubtitleSources) {
    for (    final InputStream is : mOpenSubtitleSources) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
    mOpenSubtitleSources.clear();
  }
  mOutOfBandSubtitleTracks.clear();
  mInbandSubtitleTracks=new SubtitleTrack[0];
  if (mSubtitleController != null) {
    mSubtitleController.reset();
  }
  stayAwake(false);
  _reset();
  mEventHandler.removeCallbacksAndMessages(null);
  disableProxyListener();
}","/** 
 * Resets the MediaPlayer to its uninitialized state. After calling this method, you will have to initialize it again by setting the data source and calling prepare().
 */
public void reset(){
  mSelectedSubtitleTrackIndex=-1;
synchronized (mOpenSubtitleSources) {
    for (    final InputStream is : mOpenSubtitleSources) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
    mOpenSubtitleSources.clear();
  }
  mOutOfBandSubtitleTracks.clear();
  mInbandSubtitleTracks=new SubtitleTrack[0];
  if (mSubtitleController != null) {
    mSubtitleController.reset();
  }
  if (mTimeProvider != null) {
    mTimeProvider.close();
    mTimeProvider=null;
  }
  stayAwake(false);
  _reset();
  if (mEventHandler != null) {
    mEventHandler.removeCallbacksAndMessages(null);
  }
  disableProxyListener();
}"
1520,"public EventHandler(MediaPlayer mp,Looper looper){
  super(looper);
  mMediaPlayer=mp;
}","public EventHandler(Looper looper){
  super(looper);
}"
1521,"/** 
 * @hide 
 */
public void close(){
  mEventHandler.removeMessages(NOTIFY);
}","/** 
 * @hide 
 */
public void close(){
  mEventHandler.removeMessages(NOTIFY);
  if (mHandlerThread != null) {
    mHandlerThread.quitSafely();
    mHandlerThread=null;
  }
}"
1522,"@Override protected void finalize(){
  native_finalize();
}","/** 
 * @hide 
 */
protected void finalize(){
  if (mHandlerThread != null) {
    mHandlerThread.quitSafely();
  }
}"
1523,"public TimeProvider(MediaPlayer mp){
  mPlayer=mp;
  try {
    getCurrentTimeUs(true,false);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
  }
  mEventHandler=new EventHandler();
  mListeners=new MediaTimeProvider.OnMediaTimeListener[0];
  mTimes=new long[0];
  mLastTimeUs=0;
  mTimeAdjustment=0;
}","public TimeProvider(MediaPlayer mp){
  mPlayer=mp;
  try {
    getCurrentTimeUs(true,false);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
  }
  Looper looper;
  if ((looper=Looper.myLooper()) == null && (looper=Looper.getMainLooper()) == null) {
    mHandlerThread=new HandlerThread(""String_Node_Str"",Process.THREAD_PRIORITY_FOREGROUND);
    mHandlerThread.start();
    looper=mHandlerThread.getLooper();
  }
  mEventHandler=new EventHandler(looper);
  mListeners=new MediaTimeProvider.OnMediaTimeListener[0];
  mTimes=new long[0];
  mLastTimeUs=0;
  mTimeAdjustment=0;
}"
1524,"/** 
 * @hide 
 */
public MediaTimeProvider getMediaTimeProvider(){
  return mTimeProvider;
}","/** 
 * @hide 
 */
public MediaTimeProvider getMediaTimeProvider(){
  if (mTimeProvider == null) {
    mTimeProvider=new TimeProvider(this);
  }
  return mTimeProvider;
}"
1525,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (DEBUG_BACKUP) {
        Slog.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.logo=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_logo,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_requiredForAllUsers,false)) {
    owner.mRequiredForAllUsers=true;
  }
  String restrictedAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_restrictedAccountType);
  if (restrictedAccountType != null && restrictedAccountType.length() > 0) {
    owner.mRestrictedAccountType=restrictedAccountType;
  }
  String requiredAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_requiredAccountType);
  if (requiredAccountType != null && requiredAccountType.length() > 0) {
    owner.mRequiredAccountType=requiredAccountType;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  boolean hardwareAccelerated=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hardwareAccelerated,owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.ICE_CREAM_SANDWICH);
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_largeHeap,false)) {
    ai.flags|=ApplicationInfo.FLAG_LARGE_HEAP;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_supportsRtl,false)) {
    ai.flags|=ApplicationInfo.FLAG_SUPPORTS_RTL;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
    if (false) {
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_cantSaveState,false)) {
        ai.flags|=ApplicationInfo.FLAG_CANT_SAVE_STATE;
        if (ai.processName != null && ai.processName != ai.packageName) {
          outError[0]=""String_Node_Str"";
        }
      }
    }
  }
  ai.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestApplication_uiOptions,0);
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false,hardwareAccelerated);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestLibrary_name);
      sa.recycle();
      if (lname != null) {
        if (owner.libraryNames == null) {
          owner.libraryNames=new ArrayList<String>();
        }
        if (!owner.libraryNames.contains(lname)) {
          owner.libraryNames.add(lname.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,Configuration.NATIVE_CONFIG_VERSION);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,Configuration.NATIVE_CONFIG_VERSION);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (DEBUG_BACKUP) {
        Slog.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.logo=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_logo,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_requiredForAllUsers,false)) {
    owner.mRequiredForAllUsers=true;
  }
  String restrictedAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_restrictedAccountType);
  if (restrictedAccountType != null && restrictedAccountType.length() > 0) {
    owner.mRestrictedAccountType=restrictedAccountType;
  }
  String requiredAccountType=sa.getString(com.android.internal.R.styleable.AndroidManifestApplication_requiredAccountType);
  if (requiredAccountType != null && requiredAccountType.length() > 0) {
    owner.mRequiredAccountType=requiredAccountType;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  boolean hardwareAccelerated=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hardwareAccelerated,owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.ICE_CREAM_SANDWICH);
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_largeHeap,false)) {
    ai.flags|=ApplicationInfo.FLAG_LARGE_HEAP;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_supportsRtl,false)) {
    ai.flags|=ApplicationInfo.FLAG_SUPPORTS_RTL;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,Configuration.NATIVE_CONFIG_VERSION);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,Configuration.NATIVE_CONFIG_VERSION);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
    if (false) {
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_cantSaveState,false)) {
        ai.flags|=ApplicationInfo.FLAG_CANT_SAVE_STATE;
        if (ai.processName != null && ai.processName != ai.packageName) {
          outError[0]=""String_Node_Str"";
        }
      }
    }
  }
  ai.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestApplication_uiOptions,0);
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false,hardwareAccelerated);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestLibrary_name);
      sa.recycle();
      if (lname != null) {
        if (owner.libraryNames == null) {
          owner.libraryNames=new ArrayList<String>();
        }
        if (!owner.libraryNames.contains(lname)) {
          owner.libraryNames.add(lname.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}"
1526,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity,0);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,com.android.internal.R.styleable.AndroidManifestActivityAlias_logo,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_description,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.logo=target.info.logo;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  if (info.descriptionRes == 0) {
    info.descriptionRes=target.info.descriptionRes;
  }
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  info.softInputMode=target.info.softInputMode;
  info.uiOptions=target.info.uiOptions;
  info.parentActivityName=target.info.parentActivityName;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission,0);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_parentActivityName,0);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity,Configuration.NATIVE_CONFIG_VERSION);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,com.android.internal.R.styleable.AndroidManifestActivityAlias_logo,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_description,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.logo=target.info.logo;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  if (info.descriptionRes == 0) {
    info.descriptionRes=target.info.descriptionRes;
  }
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  info.softInputMode=target.info.softInputMode;
  info.uiOptions=target.info.uiOptions;
  info.parentActivityName=target.info.parentActivityName;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission,0);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_parentActivityName,Configuration.NATIVE_CONFIG_VERSION);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
1527,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver,boolean hardwareAccelerated) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,com.android.internal.R.styleable.AndroidManifestActivity_logo,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_description,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  a.info.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_uiOptions,a.info.applicationInfo.uiOptions);
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_parentActivityName,0);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_permission,0);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity,0);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_showOnLockScreen,false)) {
    a.info.flags|=ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_immersive,false)) {
    a.info.flags|=ActivityInfo.FLAG_IMMERSIVE;
  }
  if (!receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_hardwareAccelerated,hardwareAccelerated)) {
      a.info.flags|=ActivityInfo.FLAG_HARDWARE_ACCELERATED;
    }
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  if (receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_singleUser,false)) {
      a.info.flags|=ActivityInfo.FLAG_SINGLE_USER;
      if (a.info.exported) {
        Slog.w(TAG,""String_Node_Str"" + a.className + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        a.info.exported=false;
      }
      setExported=true;
    }
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_primaryUserOnly,false)) {
      a.info.flags|=ActivityInfo.FLAG_PRIMARY_USER_ONLY;
    }
  }
  sa.recycle();
  if (receiver && (owner.applicationInfo.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
    if (a.info.processName == owner.packageName) {
      outError[0]=""String_Node_Str"";
    }
  }
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (!receiver && parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,false,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        if (owner.preferredActivityFilters == null) {
          owner.preferredActivityFilters=new ArrayList<ActivityIntentInfo>();
        }
        owner.preferredActivityFilters.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        if (receiver) {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
 else {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver,boolean hardwareAccelerated) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,com.android.internal.R.styleable.AndroidManifestActivity_logo,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_description,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  a.info.uiOptions=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_uiOptions,a.info.applicationInfo.uiOptions);
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_parentActivityName,Configuration.NATIVE_CONFIG_VERSION);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_permission,0);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity,Configuration.NATIVE_CONFIG_VERSION);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_showOnLockScreen,false)) {
    a.info.flags|=ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_immersive,false)) {
    a.info.flags|=ActivityInfo.FLAG_IMMERSIVE;
  }
  if (!receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_hardwareAccelerated,hardwareAccelerated)) {
      a.info.flags|=ActivityInfo.FLAG_HARDWARE_ACCELERATED;
    }
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  if (receiver) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_singleUser,false)) {
      a.info.flags|=ActivityInfo.FLAG_SINGLE_USER;
      if (a.info.exported) {
        Slog.w(TAG,""String_Node_Str"" + a.className + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        a.info.exported=false;
      }
      setExported=true;
    }
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_primaryUserOnly,false)) {
      a.info.flags|=ActivityInfo.FLAG_PRIMARY_USER_ONLY;
    }
  }
  sa.recycle();
  if (receiver && (owner.applicationInfo.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
    if (a.info.processName == owner.packageName) {
      outError[0]=""String_Node_Str"";
    }
  }
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (!receiver && parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,false,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        if (owner.preferredActivityFilters == null) {
          owner.preferredActivityFilters=new ArrayList<ActivityIntentInfo>();
        }
        owner.preferredActivityFilters.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        if (receiver) {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
 else {
          outError[0]=""String_Node_Str"" + parser.getName();
        }
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
1528,"/** 
 * @hide Retrieve the string value for the attribute at <var>index</var> that is not allowed to change with the given configurations.
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations fromActivityInfo that are allowed to change.
 * @return String holding string data.  Any styling information isremoved.  Returns null if the attribute is not defined.
 */
public String getNonConfigurationString(int index,int allowedChangingConfigs){
  index*=AssetManager.STYLE_NUM_ENTRIES;
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
    return null;
  }
  if (type == TypedValue.TYPE_NULL) {
    return null;
  }
 else   if (type == TypedValue.TYPE_STRING) {
    return loadStringValueAt(index).toString();
  }
  TypedValue v=mValue;
  if (getValueAt(index,v)) {
    Log.w(Resources.TAG,""String_Node_Str"" + v);
    CharSequence cs=v.coerceToString();
    return cs != null ? cs.toString() : null;
  }
  Log.w(Resources.TAG,""String_Node_Str"" + Integer.toHexString(type));
  return null;
}","/** 
 * @hide Retrieve the string value for the attribute at <var>index</var> that is not allowed to change with the given configurations.
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations from{@link Configuration}.NATIVE_CONFIG_* that are allowed to change.
 * @return String holding string data.  Any styling information isremoved.  Returns null if the attribute is not defined.
 */
public String getNonConfigurationString(int index,int allowedChangingConfigs){
  index*=AssetManager.STYLE_NUM_ENTRIES;
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
    return null;
  }
  if (type == TypedValue.TYPE_NULL) {
    return null;
  }
 else   if (type == TypedValue.TYPE_STRING) {
    return loadStringValueAt(index).toString();
  }
  TypedValue v=mValue;
  if (getValueAt(index,v)) {
    Log.w(Resources.TAG,""String_Node_Str"" + v);
    CharSequence cs=v.coerceToString();
    return cs != null ? cs.toString() : null;
  }
  Log.w(Resources.TAG,""String_Node_Str"" + Integer.toHexString(type));
  return null;
}"
1529,"/** 
 * Releases resources associated with this MediaPlayer object. It is considered good practice to call this method when you're done using the MediaPlayer. In particular, whenever an Activity of an application is paused (its onPause() method is called), or stopped (its onStop() method is called), this method should be invoked to release the MediaPlayer object, unless the application has a special need to keep the object around. In addition to unnecessary resources (such as memory and instances of codecs) being held, failure to call this method immediately if a MediaPlayer object is no longer needed may also lead to continuous battery consumption for mobile devices, and playback failure for other applications if no multiple instances of the same codec are supported on a device. Even if multiple instances of the same codec are supported, some performance degradation may be expected when unnecessary multiple instances are used at the same time.
 */
public void release(){
  stayAwake(false);
  updateSurfaceScreenOn();
  mOnPreparedListener=null;
  mOnBufferingUpdateListener=null;
  mOnCompletionListener=null;
  mOnSeekCompleteListener=null;
  mOnErrorListener=null;
  mOnInfoListener=null;
  mOnVideoSizeChangedListener=null;
  mOnTimedTextListener=null;
  mTimeProvider.close();
  mTimeProvider=null;
  mOnSubtitleDataListener=null;
  _release();
}","/** 
 * Releases resources associated with this MediaPlayer object. It is considered good practice to call this method when you're done using the MediaPlayer. In particular, whenever an Activity of an application is paused (its onPause() method is called), or stopped (its onStop() method is called), this method should be invoked to release the MediaPlayer object, unless the application has a special need to keep the object around. In addition to unnecessary resources (such as memory and instances of codecs) being held, failure to call this method immediately if a MediaPlayer object is no longer needed may also lead to continuous battery consumption for mobile devices, and playback failure for other applications if no multiple instances of the same codec are supported on a device. Even if multiple instances of the same codec are supported, some performance degradation may be expected when unnecessary multiple instances are used at the same time.
 */
public void release(){
  stayAwake(false);
  updateSurfaceScreenOn();
  mOnPreparedListener=null;
  mOnBufferingUpdateListener=null;
  mOnCompletionListener=null;
  mOnSeekCompleteListener=null;
  mOnErrorListener=null;
  mOnInfoListener=null;
  mOnVideoSizeChangedListener=null;
  mOnTimedTextListener=null;
  if (mTimeProvider != null) {
    mTimeProvider.close();
    mTimeProvider=null;
  }
  mOnSubtitleDataListener=null;
  _release();
}"
1530,"/** 
 * Resets the MediaPlayer to its uninitialized state. After calling this method, you will have to initialize it again by setting the data source and calling prepare().
 */
public void reset(){
  mSelectedSubtitleTrackIndex=-1;
synchronized (mOpenSubtitleSources) {
    for (    final InputStream is : mOpenSubtitleSources) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
    mOpenSubtitleSources.clear();
  }
  mOutOfBandSubtitleTracks.clear();
  mInbandSubtitleTracks=new SubtitleTrack[0];
  if (mSubtitleController != null) {
    mSubtitleController.reset();
  }
  stayAwake(false);
  _reset();
  mEventHandler.removeCallbacksAndMessages(null);
  disableProxyListener();
}","/** 
 * Resets the MediaPlayer to its uninitialized state. After calling this method, you will have to initialize it again by setting the data source and calling prepare().
 */
public void reset(){
  mSelectedSubtitleTrackIndex=-1;
synchronized (mOpenSubtitleSources) {
    for (    final InputStream is : mOpenSubtitleSources) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
    mOpenSubtitleSources.clear();
  }
  mOutOfBandSubtitleTracks.clear();
  mInbandSubtitleTracks=new SubtitleTrack[0];
  if (mSubtitleController != null) {
    mSubtitleController.reset();
  }
  if (mTimeProvider != null) {
    mTimeProvider.close();
    mTimeProvider=null;
  }
  stayAwake(false);
  _reset();
  if (mEventHandler != null) {
    mEventHandler.removeCallbacksAndMessages(null);
  }
  disableProxyListener();
}"
1531,"public EventHandler(MediaPlayer mp,Looper looper){
  super(looper);
  mMediaPlayer=mp;
}","public EventHandler(Looper looper){
  super(looper);
}"
1532,"/** 
 * @hide 
 */
public void close(){
  mEventHandler.removeMessages(NOTIFY);
}","/** 
 * @hide 
 */
public void close(){
  mEventHandler.removeMessages(NOTIFY);
  if (mHandlerThread != null) {
    mHandlerThread.quitSafely();
    mHandlerThread=null;
  }
}"
1533,"@Override protected void finalize(){
  native_finalize();
}","/** 
 * @hide 
 */
protected void finalize(){
  if (mHandlerThread != null) {
    mHandlerThread.quitSafely();
  }
}"
1534,"public TimeProvider(MediaPlayer mp){
  mPlayer=mp;
  try {
    getCurrentTimeUs(true,false);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
  }
  mEventHandler=new EventHandler();
  mListeners=new MediaTimeProvider.OnMediaTimeListener[0];
  mTimes=new long[0];
  mLastTimeUs=0;
  mTimeAdjustment=0;
}","public TimeProvider(MediaPlayer mp){
  mPlayer=mp;
  try {
    getCurrentTimeUs(true,false);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
  }
  Looper looper;
  if ((looper=Looper.myLooper()) == null && (looper=Looper.getMainLooper()) == null) {
    mHandlerThread=new HandlerThread(""String_Node_Str"",Process.THREAD_PRIORITY_FOREGROUND);
    mHandlerThread.start();
    looper=mHandlerThread.getLooper();
  }
  mEventHandler=new EventHandler(looper);
  mListeners=new MediaTimeProvider.OnMediaTimeListener[0];
  mTimes=new long[0];
  mLastTimeUs=0;
  mTimeAdjustment=0;
}"
1535,"/** 
 * @hide 
 */
public MediaTimeProvider getMediaTimeProvider(){
  return mTimeProvider;
}","/** 
 * @hide 
 */
public MediaTimeProvider getMediaTimeProvider(){
  if (mTimeProvider == null) {
    mTimeProvider=new TimeProvider(this);
  }
  return mTimeProvider;
}"
1536,"/** 
 * Releases resources associated with this MediaPlayer object. It is considered good practice to call this method when you're done using the MediaPlayer. In particular, whenever an Activity of an application is paused (its onPause() method is called), or stopped (its onStop() method is called), this method should be invoked to release the MediaPlayer object, unless the application has a special need to keep the object around. In addition to unnecessary resources (such as memory and instances of codecs) being held, failure to call this method immediately if a MediaPlayer object is no longer needed may also lead to continuous battery consumption for mobile devices, and playback failure for other applications if no multiple instances of the same codec are supported on a device. Even if multiple instances of the same codec are supported, some performance degradation may be expected when unnecessary multiple instances are used at the same time.
 */
public void release(){
  stayAwake(false);
  updateSurfaceScreenOn();
  mOnPreparedListener=null;
  mOnBufferingUpdateListener=null;
  mOnCompletionListener=null;
  mOnSeekCompleteListener=null;
  mOnErrorListener=null;
  mOnInfoListener=null;
  mOnVideoSizeChangedListener=null;
  mOnTimedTextListener=null;
  mTimeProvider.close();
  mTimeProvider=null;
  mOnSubtitleDataListener=null;
  _release();
}","/** 
 * Releases resources associated with this MediaPlayer object. It is considered good practice to call this method when you're done using the MediaPlayer. In particular, whenever an Activity of an application is paused (its onPause() method is called), or stopped (its onStop() method is called), this method should be invoked to release the MediaPlayer object, unless the application has a special need to keep the object around. In addition to unnecessary resources (such as memory and instances of codecs) being held, failure to call this method immediately if a MediaPlayer object is no longer needed may also lead to continuous battery consumption for mobile devices, and playback failure for other applications if no multiple instances of the same codec are supported on a device. Even if multiple instances of the same codec are supported, some performance degradation may be expected when unnecessary multiple instances are used at the same time.
 */
public void release(){
  stayAwake(false);
  updateSurfaceScreenOn();
  mOnPreparedListener=null;
  mOnBufferingUpdateListener=null;
  mOnCompletionListener=null;
  mOnSeekCompleteListener=null;
  mOnErrorListener=null;
  mOnInfoListener=null;
  mOnVideoSizeChangedListener=null;
  mOnTimedTextListener=null;
  if (mTimeProvider != null) {
    mTimeProvider.close();
    mTimeProvider=null;
  }
  mOnSubtitleDataListener=null;
  _release();
}"
1537,"/** 
 * Resets the MediaPlayer to its uninitialized state. After calling this method, you will have to initialize it again by setting the data source and calling prepare().
 */
public void reset(){
  mSelectedSubtitleTrackIndex=-1;
synchronized (mOpenSubtitleSources) {
    for (    final InputStream is : mOpenSubtitleSources) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
    mOpenSubtitleSources.clear();
  }
  mOutOfBandSubtitleTracks.clear();
  mInbandSubtitleTracks=new SubtitleTrack[0];
  if (mSubtitleController != null) {
    mSubtitleController.reset();
  }
  stayAwake(false);
  _reset();
  mEventHandler.removeCallbacksAndMessages(null);
  disableProxyListener();
}","/** 
 * Resets the MediaPlayer to its uninitialized state. After calling this method, you will have to initialize it again by setting the data source and calling prepare().
 */
public void reset(){
  mSelectedSubtitleTrackIndex=-1;
synchronized (mOpenSubtitleSources) {
    for (    final InputStream is : mOpenSubtitleSources) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
    mOpenSubtitleSources.clear();
  }
  mOutOfBandSubtitleTracks.clear();
  mInbandSubtitleTracks=new SubtitleTrack[0];
  if (mSubtitleController != null) {
    mSubtitleController.reset();
  }
  if (mTimeProvider != null) {
    mTimeProvider.close();
    mTimeProvider=null;
  }
  stayAwake(false);
  _reset();
  if (mEventHandler != null) {
    mEventHandler.removeCallbacksAndMessages(null);
  }
  disableProxyListener();
}"
1538,"public EventHandler(MediaPlayer mp,Looper looper){
  super(looper);
  mMediaPlayer=mp;
}","public EventHandler(Looper looper){
  super(looper);
}"
1539,"/** 
 * @hide 
 */
public void close(){
  mEventHandler.removeMessages(NOTIFY);
}","/** 
 * @hide 
 */
public void close(){
  mEventHandler.removeMessages(NOTIFY);
  if (mHandlerThread != null) {
    mHandlerThread.quitSafely();
    mHandlerThread=null;
  }
}"
1540,"@Override protected void finalize(){
  native_finalize();
}","/** 
 * @hide 
 */
protected void finalize(){
  if (mHandlerThread != null) {
    mHandlerThread.quitSafely();
  }
}"
1541,"public TimeProvider(MediaPlayer mp){
  mPlayer=mp;
  try {
    getCurrentTimeUs(true,false);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
  }
  mEventHandler=new EventHandler();
  mListeners=new MediaTimeProvider.OnMediaTimeListener[0];
  mTimes=new long[0];
  mLastTimeUs=0;
  mTimeAdjustment=0;
}","public TimeProvider(MediaPlayer mp){
  mPlayer=mp;
  try {
    getCurrentTimeUs(true,false);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
  }
  Looper looper;
  if ((looper=Looper.myLooper()) == null && (looper=Looper.getMainLooper()) == null) {
    mHandlerThread=new HandlerThread(""String_Node_Str"",Process.THREAD_PRIORITY_FOREGROUND);
    mHandlerThread.start();
    looper=mHandlerThread.getLooper();
  }
  mEventHandler=new EventHandler(looper);
  mListeners=new MediaTimeProvider.OnMediaTimeListener[0];
  mTimes=new long[0];
  mLastTimeUs=0;
  mTimeAdjustment=0;
}"
1542,"/** 
 * @hide 
 */
public MediaTimeProvider getMediaTimeProvider(){
  return mTimeProvider;
}","/** 
 * @hide 
 */
public MediaTimeProvider getMediaTimeProvider(){
  if (mTimeProvider == null) {
    mTimeProvider=new TimeProvider(this);
  }
  return mTimeProvider;
}"
1543,"/** 
 * Releases resources associated with this MediaPlayer object. It is considered good practice to call this method when you're done using the MediaPlayer. In particular, whenever an Activity of an application is paused (its onPause() method is called), or stopped (its onStop() method is called), this method should be invoked to release the MediaPlayer object, unless the application has a special need to keep the object around. In addition to unnecessary resources (such as memory and instances of codecs) being held, failure to call this method immediately if a MediaPlayer object is no longer needed may also lead to continuous battery consumption for mobile devices, and playback failure for other applications if no multiple instances of the same codec are supported on a device. Even if multiple instances of the same codec are supported, some performance degradation may be expected when unnecessary multiple instances are used at the same time.
 */
public void release(){
  stayAwake(false);
  updateSurfaceScreenOn();
  mOnPreparedListener=null;
  mOnBufferingUpdateListener=null;
  mOnCompletionListener=null;
  mOnSeekCompleteListener=null;
  mOnErrorListener=null;
  mOnInfoListener=null;
  mOnVideoSizeChangedListener=null;
  mOnTimedTextListener=null;
  mTimeProvider.close();
  mTimeProvider=null;
  mOnSubtitleDataListener=null;
  _release();
}","/** 
 * Releases resources associated with this MediaPlayer object. It is considered good practice to call this method when you're done using the MediaPlayer. In particular, whenever an Activity of an application is paused (its onPause() method is called), or stopped (its onStop() method is called), this method should be invoked to release the MediaPlayer object, unless the application has a special need to keep the object around. In addition to unnecessary resources (such as memory and instances of codecs) being held, failure to call this method immediately if a MediaPlayer object is no longer needed may also lead to continuous battery consumption for mobile devices, and playback failure for other applications if no multiple instances of the same codec are supported on a device. Even if multiple instances of the same codec are supported, some performance degradation may be expected when unnecessary multiple instances are used at the same time.
 */
public void release(){
  stayAwake(false);
  updateSurfaceScreenOn();
  mOnPreparedListener=null;
  mOnBufferingUpdateListener=null;
  mOnCompletionListener=null;
  mOnSeekCompleteListener=null;
  mOnErrorListener=null;
  mOnInfoListener=null;
  mOnVideoSizeChangedListener=null;
  mOnTimedTextListener=null;
  if (mTimeProvider != null) {
    mTimeProvider.close();
    mTimeProvider=null;
  }
  mOnSubtitleDataListener=null;
  _release();
}"
1544,"/** 
 * Resets the MediaPlayer to its uninitialized state. After calling this method, you will have to initialize it again by setting the data source and calling prepare().
 */
public void reset(){
  mSelectedSubtitleTrackIndex=-1;
synchronized (mOpenSubtitleSources) {
    for (    final InputStream is : mOpenSubtitleSources) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
    mOpenSubtitleSources.clear();
  }
  mOutOfBandSubtitleTracks.clear();
  mInbandSubtitleTracks=new SubtitleTrack[0];
  if (mSubtitleController != null) {
    mSubtitleController.reset();
  }
  stayAwake(false);
  _reset();
  mEventHandler.removeCallbacksAndMessages(null);
  disableProxyListener();
}","/** 
 * Resets the MediaPlayer to its uninitialized state. After calling this method, you will have to initialize it again by setting the data source and calling prepare().
 */
public void reset(){
  mSelectedSubtitleTrackIndex=-1;
synchronized (mOpenSubtitleSources) {
    for (    final InputStream is : mOpenSubtitleSources) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
    mOpenSubtitleSources.clear();
  }
  mOutOfBandSubtitleTracks.clear();
  mInbandSubtitleTracks=new SubtitleTrack[0];
  if (mSubtitleController != null) {
    mSubtitleController.reset();
  }
  if (mTimeProvider != null) {
    mTimeProvider.close();
    mTimeProvider=null;
  }
  stayAwake(false);
  _reset();
  if (mEventHandler != null) {
    mEventHandler.removeCallbacksAndMessages(null);
  }
  disableProxyListener();
}"
1545,"public EventHandler(MediaPlayer mp,Looper looper){
  super(looper);
  mMediaPlayer=mp;
}","public EventHandler(Looper looper){
  super(looper);
}"
1546,"/** 
 * @hide 
 */
public void close(){
  mEventHandler.removeMessages(NOTIFY);
}","/** 
 * @hide 
 */
public void close(){
  mEventHandler.removeMessages(NOTIFY);
  if (mHandlerThread != null) {
    mHandlerThread.quitSafely();
    mHandlerThread=null;
  }
}"
1547,"@Override protected void finalize(){
  native_finalize();
}","/** 
 * @hide 
 */
protected void finalize(){
  if (mHandlerThread != null) {
    mHandlerThread.quitSafely();
  }
}"
1548,"public TimeProvider(MediaPlayer mp){
  mPlayer=mp;
  try {
    getCurrentTimeUs(true,false);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
  }
  mEventHandler=new EventHandler();
  mListeners=new MediaTimeProvider.OnMediaTimeListener[0];
  mTimes=new long[0];
  mLastTimeUs=0;
  mTimeAdjustment=0;
}","public TimeProvider(MediaPlayer mp){
  mPlayer=mp;
  try {
    getCurrentTimeUs(true,false);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
  }
  Looper looper;
  if ((looper=Looper.myLooper()) == null && (looper=Looper.getMainLooper()) == null) {
    mHandlerThread=new HandlerThread(""String_Node_Str"",Process.THREAD_PRIORITY_FOREGROUND);
    mHandlerThread.start();
    looper=mHandlerThread.getLooper();
  }
  mEventHandler=new EventHandler(looper);
  mListeners=new MediaTimeProvider.OnMediaTimeListener[0];
  mTimes=new long[0];
  mLastTimeUs=0;
  mTimeAdjustment=0;
}"
1549,"/** 
 * @hide 
 */
public MediaTimeProvider getMediaTimeProvider(){
  return mTimeProvider;
}","/** 
 * @hide 
 */
public MediaTimeProvider getMediaTimeProvider(){
  if (mTimeProvider == null) {
    mTimeProvider=new TimeProvider(this);
  }
  return mTimeProvider;
}"
1550,"/** 
 * Releases resources associated with this MediaPlayer object. It is considered good practice to call this method when you're done using the MediaPlayer. In particular, whenever an Activity of an application is paused (its onPause() method is called), or stopped (its onStop() method is called), this method should be invoked to release the MediaPlayer object, unless the application has a special need to keep the object around. In addition to unnecessary resources (such as memory and instances of codecs) being held, failure to call this method immediately if a MediaPlayer object is no longer needed may also lead to continuous battery consumption for mobile devices, and playback failure for other applications if no multiple instances of the same codec are supported on a device. Even if multiple instances of the same codec are supported, some performance degradation may be expected when unnecessary multiple instances are used at the same time.
 */
public void release(){
  stayAwake(false);
  updateSurfaceScreenOn();
  mOnPreparedListener=null;
  mOnBufferingUpdateListener=null;
  mOnCompletionListener=null;
  mOnSeekCompleteListener=null;
  mOnErrorListener=null;
  mOnInfoListener=null;
  mOnVideoSizeChangedListener=null;
  mOnTimedTextListener=null;
  mTimeProvider.close();
  mTimeProvider=null;
  mOnSubtitleDataListener=null;
  _release();
}","/** 
 * Releases resources associated with this MediaPlayer object. It is considered good practice to call this method when you're done using the MediaPlayer. In particular, whenever an Activity of an application is paused (its onPause() method is called), or stopped (its onStop() method is called), this method should be invoked to release the MediaPlayer object, unless the application has a special need to keep the object around. In addition to unnecessary resources (such as memory and instances of codecs) being held, failure to call this method immediately if a MediaPlayer object is no longer needed may also lead to continuous battery consumption for mobile devices, and playback failure for other applications if no multiple instances of the same codec are supported on a device. Even if multiple instances of the same codec are supported, some performance degradation may be expected when unnecessary multiple instances are used at the same time.
 */
public void release(){
  stayAwake(false);
  updateSurfaceScreenOn();
  mOnPreparedListener=null;
  mOnBufferingUpdateListener=null;
  mOnCompletionListener=null;
  mOnSeekCompleteListener=null;
  mOnErrorListener=null;
  mOnInfoListener=null;
  mOnVideoSizeChangedListener=null;
  mOnTimedTextListener=null;
  if (mTimeProvider != null) {
    mTimeProvider.close();
    mTimeProvider=null;
  }
  mOnSubtitleDataListener=null;
  _release();
}"
1551,"/** 
 * Resets the MediaPlayer to its uninitialized state. After calling this method, you will have to initialize it again by setting the data source and calling prepare().
 */
public void reset(){
  mSelectedSubtitleTrackIndex=-1;
synchronized (mOpenSubtitleSources) {
    for (    final InputStream is : mOpenSubtitleSources) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
    mOpenSubtitleSources.clear();
  }
  mOutOfBandSubtitleTracks.clear();
  mInbandSubtitleTracks=new SubtitleTrack[0];
  if (mSubtitleController != null) {
    mSubtitleController.reset();
  }
  stayAwake(false);
  _reset();
  mEventHandler.removeCallbacksAndMessages(null);
  disableProxyListener();
}","/** 
 * Resets the MediaPlayer to its uninitialized state. After calling this method, you will have to initialize it again by setting the data source and calling prepare().
 */
public void reset(){
  mSelectedSubtitleTrackIndex=-1;
synchronized (mOpenSubtitleSources) {
    for (    final InputStream is : mOpenSubtitleSources) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
    mOpenSubtitleSources.clear();
  }
  mOutOfBandSubtitleTracks.clear();
  mInbandSubtitleTracks=new SubtitleTrack[0];
  if (mSubtitleController != null) {
    mSubtitleController.reset();
  }
  if (mTimeProvider != null) {
    mTimeProvider.close();
    mTimeProvider=null;
  }
  stayAwake(false);
  _reset();
  if (mEventHandler != null) {
    mEventHandler.removeCallbacksAndMessages(null);
  }
  disableProxyListener();
}"
1552,"public EventHandler(MediaPlayer mp,Looper looper){
  super(looper);
  mMediaPlayer=mp;
}","public EventHandler(Looper looper){
  super(looper);
}"
1553,"/** 
 * @hide 
 */
public void close(){
  mEventHandler.removeMessages(NOTIFY);
}","/** 
 * @hide 
 */
public void close(){
  mEventHandler.removeMessages(NOTIFY);
  if (mHandlerThread != null) {
    mHandlerThread.quitSafely();
    mHandlerThread=null;
  }
}"
1554,"@Override protected void finalize(){
  native_finalize();
}","/** 
 * @hide 
 */
protected void finalize(){
  if (mHandlerThread != null) {
    mHandlerThread.quitSafely();
  }
}"
1555,"public TimeProvider(MediaPlayer mp){
  mPlayer=mp;
  try {
    getCurrentTimeUs(true,false);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
  }
  mEventHandler=new EventHandler();
  mListeners=new MediaTimeProvider.OnMediaTimeListener[0];
  mTimes=new long[0];
  mLastTimeUs=0;
  mTimeAdjustment=0;
}","public TimeProvider(MediaPlayer mp){
  mPlayer=mp;
  try {
    getCurrentTimeUs(true,false);
  }
 catch (  IllegalStateException e) {
    mRefresh=true;
  }
  Looper looper;
  if ((looper=Looper.myLooper()) == null && (looper=Looper.getMainLooper()) == null) {
    mHandlerThread=new HandlerThread(""String_Node_Str"",Process.THREAD_PRIORITY_FOREGROUND);
    mHandlerThread.start();
    looper=mHandlerThread.getLooper();
  }
  mEventHandler=new EventHandler(looper);
  mListeners=new MediaTimeProvider.OnMediaTimeListener[0];
  mTimes=new long[0];
  mLastTimeUs=0;
  mTimeAdjustment=0;
}"
1556,"/** 
 * @hide 
 */
public MediaTimeProvider getMediaTimeProvider(){
  return mTimeProvider;
}","/** 
 * @hide 
 */
public MediaTimeProvider getMediaTimeProvider(){
  if (mTimeProvider == null) {
    mTimeProvider=new TimeProvider(this);
  }
  return mTimeProvider;
}"
1557,"/** 
 * Returns a new media size in a portrait orientation which is the height is the greater dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asPortrait(){
  return new MediaSize(mId,mPackageName,mLabel,Math.min(mWidthMils,mHeightMils),Math.max(mWidthMils,mHeightMils),mLabelResId);
}","/** 
 * Returns a new media size in a portrait orientation which is the height is the greater dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asPortrait(){
  return new MediaSize(mId,mLabel,mPackageName,Math.min(mWidthMils,mHeightMils),Math.max(mWidthMils,mHeightMils),mLabelResId);
}"
1558,"/** 
 * Returns a new media size in a landscape orientation which is the height is the lesser dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asLandscape(){
  return new MediaSize(mId,mLabel,Math.max(mWidthMils,mHeightMils),Math.min(mWidthMils,mHeightMils),mLabelResId);
}","/** 
 * Returns a new media size in a landscape orientation which is the height is the lesser dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asLandscape(){
  return new MediaSize(mId,mLabel,mPackageName,Math.max(mWidthMils,mHeightMils),Math.min(mWidthMils,mHeightMils),mLabelResId);
}"
1559,"@SuppressWarnings(""String_Node_Str"") public void addPrinterAndWritePrinterHistory(PrinterInfo printer){
  if (mHistoricalPrinters.size() >= MAX_HISTORY_LENGTH) {
    mHistoricalPrinters.remove(0);
  }
  mHistoricalPrinters.add(printer);
  mWriteTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,new ArrayList<PrinterInfo>(mHistoricalPrinters));
}","@SuppressWarnings(""String_Node_Str"") public void addPrinterAndWritePrinterHistory(PrinterInfo printer){
  if (mHistoricalPrinters.size() >= MAX_HISTORY_LENGTH) {
    mHistoricalPrinters.remove(0);
  }
  mHistoricalPrinters.add(printer);
  new WriteTask().executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,new ArrayList<PrinterInfo>(mHistoricalPrinters));
}"
1560,"public boolean stopReadPrinterHistory(){
  return mReadTask.cancel(true);
}","public boolean stopReadPrinterHistory(){
  final boolean cancelled=mReadTask.cancel(true);
  mReadTask=null;
  return cancelled;
}"
1561,"public void readPrinterHistory(){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
  mReadHistoryInProgress=true;
  mReadTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,(Void[])null);
}","public void readPrinterHistory(){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
  mReadHistoryInProgress=true;
  mReadTask=new ReadTask();
  mReadTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,(Void[])null);
}"
1562,"@Override protected void onPostExecute(List<PrinterInfo> printers){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + FusedPrintersProvider.this.hashCode());
  }
  mHistoricalPrinters=printers;
  mFavoritePrinters.addAll(computeFavoritePrinters(printers));
  mReadHistoryInProgress=false;
  mReadHistoryCompleted=true;
  computeAndDeliverResult();
  loadInternal();
}","@Override protected void onPostExecute(List<PrinterInfo> printers){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + FusedPrintersProvider.this.hashCode());
  }
  mHistoricalPrinters=printers;
  mFavoritePrinters.addAll(computeFavoritePrinters(printers));
  mReadHistoryInProgress=false;
  mReadHistoryCompleted=true;
  computeAndDeliverResult();
  loadInternal();
  mReadTask=null;
}"
1563,"private void updateUiForNewPrinterCapabilities(){
  if (!mMediaSizeSpinnerAdapter.isEmpty()) {
    mIgnoreNextMediaSizeChange=true;
    mMediaSizeSpinnerAdapter.clear();
  }
  if (!mColorModeSpinnerAdapter.isEmpty()) {
    mIgnoreNextColorModeChange=true;
    mColorModeSpinnerAdapter.clear();
  }
  if (!mOrientationSpinnerAdapter.isEmpty()) {
    mIgnoreNextOrientationChange=true;
    mOrientationSpinner.setSelection(0);
  }
  if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextRangeOptionChange=true;
    mRangeOptionsSpinner.setSelection(0);
  }
  if (!TextUtils.isEmpty(mCopiesEditText.getText())) {
    mIgnoreNextCopiesChange=true;
    mCopiesEditText.setText(MIN_COPIES_STRING);
  }
  updateUi();
}","private void updateUiForNewPrinterCapabilities(){
  if (!mMediaSizeSpinnerAdapter.isEmpty()) {
    mIgnoreNextMediaSizeChange=true;
    mMediaSizeSpinnerAdapter.clear();
  }
  if (!mColorModeSpinnerAdapter.isEmpty()) {
    mIgnoreNextColorModeChange=true;
    mColorModeSpinnerAdapter.clear();
  }
  if (mOrientationSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextOrientationChange=true;
    mOrientationSpinner.setSelection(0);
  }
  if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextRangeOptionChange=true;
    mRangeOptionsSpinner.setSelection(0);
  }
  if (!TextUtils.isEmpty(mCopiesEditText.getText())) {
    mIgnoreNextCopiesChange=true;
    mCopiesEditText.setText(MIN_COPIES_STRING);
  }
  updateUi();
}"
1564,"public boolean onTouchEvent(MotionEvent event){
  if (!mEditor.isPrintConfirmed() && !mEditor.isPreviewConfirmed() && mEditor.shouldCloseOnTouch(event)) {
    if (!mController.isWorking()) {
      PrintJobConfigActivity.this.finish();
    }
    mEditor.cancel();
    return true;
  }
  return super.onTouchEvent(event);
}","public boolean onTouchEvent(MotionEvent event){
  if (!mEditor.isPrintConfirmed() && mEditor.shouldCloseOnTouch(event)) {
    if (!mController.isWorking()) {
      PrintJobConfigActivity.this.finish();
    }
    mEditor.cancel();
    return true;
  }
  return super.onTouchEvent(event);
}"
1565,"private void handleOnWriteFinished(PageRange[] pages,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_WRITE_COMPLETED;
  File file=PrintSpoolerService.peekInstance().generateFileForPrintJob(mPrintJobId);
  mDocument.info.setDataSize(file.length());
  mDocument.pages=PageRangeUtils.normalize(pages);
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + Arrays.toString(mRequestedPages) + ""String_Node_Str""+ Arrays.toString(mDocument.pages));
  }
  if (Arrays.equals(mDocument.pages,mRequestedPages)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,ALL_PAGES_ARRAY);
  }
 else   if (Arrays.equals(mDocument.pages,ALL_PAGES_ARRAY)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mRequestedPages);
  }
 else   if (PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    final int offset=mDocument.pages[0].getStart() - pages[0].getStart();
    PageRange[] offsetPages=Arrays.copyOf(mDocument.pages,mDocument.pages.length);
    PageRangeUtils.offsetStart(offsetPages,offset);
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,offsetPages);
  }
 else   if (Arrays.equals(mRequestedPages,ALL_PAGES_ARRAY) && mDocument.pages.length == 1 && mDocument.pages[0].getStart() == 0 && mDocument.pages[0].getEnd() == mDocument.info.getPageCount() - 1) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mDocument.pages);
  }
 else {
    mControllerState=CONTROLLER_STATE_FAILED;
    Log.e(LOG_TAG,""String_Node_Str"");
    PrintJobConfigActivity.this.finish();
  }
  if (mEditor.isDone()) {
    if (mEditor.isPrintingToPdf()) {
      PrintJobInfo printJob=PrintSpoolerService.peekInstance().getPrintJobInfo(mPrintJobId,PrintManager.APP_ID_ANY);
      Intent intent=new Intent(Intent.ACTION_CREATE_DOCUMENT);
      intent.setType(""String_Node_Str"");
      intent.putExtra(Intent.EXTRA_TITLE,printJob.getLabel());
      startActivityForResult(intent,ACTIVITY_REQUEST_CREATE_FILE);
    }
 else {
      PrintJobConfigActivity.this.finish();
    }
  }
}","private void handleOnWriteFinished(PageRange[] pages,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_WRITE_COMPLETED;
  File file=PrintSpoolerService.peekInstance().generateFileForPrintJob(mPrintJobId);
  mDocument.info.setDataSize(file.length());
  mDocument.pages=PageRangeUtils.normalize(pages);
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + Arrays.toString(mRequestedPages) + ""String_Node_Str""+ Arrays.toString(mDocument.pages));
  }
  if (Arrays.equals(mDocument.pages,mRequestedPages)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,ALL_PAGES_ARRAY);
  }
 else   if (Arrays.equals(mDocument.pages,ALL_PAGES_ARRAY)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mRequestedPages);
  }
 else   if (PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    final int offset=mDocument.pages[0].getStart() - pages[0].getStart();
    PageRange[] offsetPages=Arrays.copyOf(mDocument.pages,mDocument.pages.length);
    PageRangeUtils.offsetStart(offsetPages,offset);
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,offsetPages);
  }
 else   if (Arrays.equals(mRequestedPages,ALL_PAGES_ARRAY) && mDocument.pages.length == 1 && mDocument.pages[0].getStart() == 0 && mDocument.pages[0].getEnd() == mDocument.info.getPageCount() - 1) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mDocument.pages);
  }
 else {
    mControllerState=CONTROLLER_STATE_FAILED;
    Log.e(LOG_TAG,""String_Node_Str"");
    PrintJobConfigActivity.this.finish();
  }
  if (mEditor.isDone()) {
    requestCreatePdfFileOrFinish();
  }
}"
1566,"public void addCurrentPrinterToHistory(){
  PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
  if (printer != null) {
    FusedPrintersProvider printersLoader=(FusedPrintersProvider)(Loader<?>)getLoaderManager().getLoader(LOADER_ID_PRINTERS_LOADER);
    if (printersLoader != null) {
      printersLoader.addHistoricalPrinter(printer);
    }
  }
}","public void addCurrentPrinterToHistory(){
  PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
  PrinterId fakePdfPritnerId=mDestinationSpinnerAdapter.mFakePdfPrinter.getId();
  if (printer != null && !printer.getId().equals(fakePdfPritnerId)) {
    FusedPrintersProvider printersLoader=(FusedPrintersProvider)(Loader<?>)getLoaderManager().getLoader(LOADER_ID_PRINTERS_LOADER);
    if (printersLoader != null) {
      printersLoader.addHistoricalPrinter(printer);
    }
  }
}"
1567,"private void handleOnLayoutFinished(PrintDocumentInfo info,boolean layoutChanged,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_LAYOUT_COMPLETED;
  final boolean infoChanged=!info.equals(mDocument.info);
  if (infoChanged) {
    mDocument.info=info;
    PrintSpoolerService.peekInstance().setPrintJobPrintDocumentInfoNoPersistence(mPrintJobId,info);
  }
  if (infoChanged || layoutChanged) {
    mDocument.pages=null;
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,null);
  }
  mRequestedPages=mEditor.getRequestedPages();
  if (mRequestedPages == null) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!infoChanged && !layoutChanged && PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!LIVE_PREVIEW_SUPPORTED && !mEditor.isPreviewConfirmed() && mMetadata.getBoolean(PrintDocumentAdapter.METADATA_KEY_PRINT_PREVIEW)) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mEditor.updateUi();
  mControllerState=CONTROLLER_STATE_WRITE_STARTED;
  mRemotePrintAdapter.write(mRequestedPages,mWriteResultCallback,mRequestCounter.incrementAndGet());
}","private void handleOnLayoutFinished(PrintDocumentInfo info,boolean layoutChanged,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_LAYOUT_COMPLETED;
  final boolean infoChanged=!info.equals(mDocument.info);
  if (infoChanged) {
    mDocument.info=info;
    PrintSpoolerService.peekInstance().setPrintJobPrintDocumentInfoNoPersistence(mPrintJobId,info);
  }
  if (infoChanged || layoutChanged) {
    mDocument.pages=null;
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,null);
  }
  mRequestedPages=mEditor.getRequestedPages();
  if (mRequestedPages == null) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!infoChanged && !layoutChanged && PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    if (mEditor.isDone()) {
      requestCreatePdfFileOrFinish();
    }
    return;
  }
  mEditor.updateUi();
  mControllerState=CONTROLLER_STATE_WRITE_STARTED;
  mRemotePrintAdapter.write(mRequestedPages,mWriteResultCallback,mRequestCounter.incrementAndGet());
}"
1568,"public boolean updateUi(){
  if (mCurrentUi != UI_EDITING_PRINT_JOB) {
    return false;
  }
  if (isPrintConfirmed() || isPreviewConfirmed() || isCancelled()) {
    mDestinationSpinner.setEnabled(false);
    mCopiesEditText.setEnabled(false);
    mMediaSizeSpinner.setEnabled(false);
    mColorModeSpinner.setEnabled(false);
    mOrientationSpinner.setEnabled(false);
    mRangeOptionsSpinner.setEnabled(false);
    mPageRangeEditText.setEnabled(false);
    mPrintButton.setEnabled(false);
    return false;
  }
  boolean allOptionsEnabled=false;
  final int selectedIndex=mDestinationSpinner.getSelectedItemPosition();
  if (selectedIndex >= 0) {
    Object item=mDestinationSpinnerAdapter.getItem(selectedIndex);
    if (item instanceof PrinterInfo) {
      PrinterInfo printer=(PrinterInfo)item;
      if (printer.getCapabilities() != null) {
        allOptionsEnabled=true;
      }
    }
  }
  if (!allOptionsEnabled) {
    String minCopiesString=String.valueOf(MIN_COPIES);
    if (!TextUtils.equals(mCopiesEditText.getText(),minCopiesString)) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(minCopiesString);
    }
    mCopiesEditText.setEnabled(false);
    if (mMediaSizeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextMediaSizeChange=true;
      mMediaSizeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mMediaSizeSpinner.setEnabled(false);
    if (mColorModeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextColorModeChange=true;
      mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mColorModeSpinner.setEnabled(false);
    if (mOrientationSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextOrientationChange=true;
      mOrientationSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mOrientationSpinner.setEnabled(false);
    if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextRangeOptionChange=true;
      mRangeOptionsSpinner.setSelection(0);
    }
    mRangeOptionsSpinner.setEnabled(false);
    mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
    if (!TextUtils.equals(mPageRangeEditText.getText(),""String_Node_Str"")) {
      mIgnoreNextRangeChange=true;
      mPageRangeEditText.setText(""String_Node_Str"");
    }
    mPageRangeEditText.setEnabled(false);
    mPageRangeEditText.setVisibility(View.INVISIBLE);
    mPageRangeTitle.setVisibility(View.INVISIBLE);
    mPrintButton.setEnabled(false);
    return false;
  }
 else {
    boolean someAttributeSelectionChanged=false;
    PrintAttributes defaultAttributes=mTempPrintAttributes;
    PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
    PrinterCapabilitiesInfo capabilities=printer.getCapabilities();
    printer.getCapabilities().getDefaults(defaultAttributes);
    List<MediaSize> mediaSizes=capabilities.getMediaSizes();
    boolean mediaSizesChanged=false;
    final int mediaSizeCount=mediaSizes.size();
    if (mediaSizeCount != mMediaSizeSpinnerAdapter.getCount()) {
      mediaSizesChanged=true;
    }
 else {
      for (int i=0; i < mediaSizeCount; i++) {
        if (!mediaSizes.get(i).equals(mMediaSizeSpinnerAdapter.getItem(i).value)) {
          mediaSizesChanged=true;
          break;
        }
      }
    }
    if (mediaSizesChanged) {
      int oldMediaSizeNewIndex=AdapterView.INVALID_POSITION;
      MediaSize oldMediaSize=mCurrPrintAttributes.getMediaSize();
      mMediaSizeSpinnerAdapter.clear();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize mediaSize=mediaSizes.get(i);
        if (mediaSize.equals(oldMediaSize)) {
          oldMediaSizeNewIndex=i;
        }
        mMediaSizeSpinnerAdapter.add(new SpinnerItem<MediaSize>(mediaSize,mediaSize.getLabel(getPackageManager())));
      }
      if (mediaSizeCount <= 0) {
        mMediaSizeSpinner.setEnabled(false);
        someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(AdapterView.INVALID_POSITION);
      }
 else {
        mMediaSizeSpinner.setEnabled(true);
        if (oldMediaSizeNewIndex != AdapterView.INVALID_POSITION) {
          setMediaSizeSpinnerSelectionNoCallback(oldMediaSizeNewIndex);
        }
 else {
          final int mediaSizeIndex=Math.max(mediaSizes.indexOf(defaultAttributes.getMediaSize()),0);
          someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(mediaSizeIndex);
        }
      }
    }
    mMediaSizeSpinner.setEnabled(true);
    final int colorModes=capabilities.getColorModes();
    boolean colorModesChanged=false;
    if (Integer.bitCount(colorModes) != mColorModeSpinnerAdapter.getCount()) {
      colorModesChanged=true;
    }
 else {
      int remainingColorModes=colorModes;
      int adapterIndex=0;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        remainingColorModes&=~colorMode;
        if (colorMode != mColorModeSpinnerAdapter.getItem(adapterIndex).value) {
          colorModesChanged=true;
          break;
        }
        adapterIndex++;
      }
    }
    if (colorModesChanged) {
      int oldColorModeNewIndex=AdapterView.INVALID_POSITION;
      final int oldColorMode=mCurrPrintAttributes.getColorMode();
      mColorModeSpinnerAdapter.clear();
      String[] colorModeLabels=getResources().getStringArray(R.array.color_mode_labels);
      int remainingColorModes=colorModes;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        if (colorMode == oldColorMode) {
          oldColorModeNewIndex=colorBitOffset;
        }
        remainingColorModes&=~colorMode;
        mColorModeSpinnerAdapter.add(new SpinnerItem<Integer>(colorMode,colorModeLabels[colorBitOffset]));
      }
      final int colorModeCount=Integer.bitCount(colorModes);
      if (colorModeCount <= 0) {
        mColorModeSpinner.setEnabled(false);
        mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
      }
 else {
        mColorModeSpinner.setEnabled(true);
        if (oldColorModeNewIndex != AdapterView.INVALID_POSITION) {
          setColorModeSpinnerSelectionNoCallback(oldColorModeNewIndex);
        }
 else {
          final int selectedColorModeIndex=Integer.numberOfTrailingZeros((colorModes & defaultAttributes.getColorMode()));
          someAttributeSelectionChanged=setColorModeSpinnerSelectionNoCallback(selectedColorModeIndex);
        }
      }
    }
    mColorModeSpinner.setEnabled(true);
    mOrientationSpinner.setEnabled(true);
    PrintDocumentInfo info=mDocument.info;
    if (info != null && (info.getPageCount() > 0 || info.getPageCount() == PrintDocumentInfo.PAGE_COUNT_UNKNOWN)) {
      if (info.getPageCount() == 1) {
        mRangeOptionsSpinner.setEnabled(false);
      }
 else {
        mRangeOptionsSpinner.setEnabled(true);
        if (mRangeOptionsSpinner.getSelectedItemPosition() > 0) {
          if (!mPageRangeEditText.isEnabled()) {
            mPageRangeEditText.setEnabled(true);
            mPageRangeEditText.setVisibility(View.VISIBLE);
            mPageRangeTitle.setVisibility(View.VISIBLE);
            mPageRangeEditText.requestFocus();
            InputMethodManager imm=(InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
            imm.showSoftInput(mPageRangeEditText,0);
          }
        }
 else {
          mPageRangeEditText.setEnabled(false);
          mPageRangeEditText.setVisibility(View.INVISIBLE);
          mPageRangeTitle.setVisibility(View.INVISIBLE);
        }
      }
      final int pageCount=mDocument.info.getPageCount();
      mRangeOptionsTitle.setText(getString(R.string.label_pages,(pageCount == PrintDocumentInfo.PAGE_COUNT_UNKNOWN) ? getString(R.string.page_count_unknown) : String.valueOf(pageCount)));
    }
 else {
      if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
        mIgnoreNextRangeOptionChange=true;
        mRangeOptionsSpinner.setSelection(0);
      }
      mRangeOptionsSpinner.setEnabled(false);
      mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
      mPageRangeEditText.setEnabled(false);
      mPageRangeEditText.setVisibility(View.INVISIBLE);
      mPageRangeTitle.setVisibility(View.INVISIBLE);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      String newText=getString(R.string.print_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.print_button);
      }
    }
 else {
      String newText=getString(R.string.save_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.save_button);
      }
    }
    if ((mRangeOptionsSpinner.getSelectedItemPosition() == 1 && (TextUtils.isEmpty(mPageRangeEditText.getText()) || hasErrors())) || (mRangeOptionsSpinner.getSelectedItemPosition() == 0 && (!mController.hasPerformedLayout() || hasErrors()))) {
      mPrintButton.setEnabled(false);
    }
 else {
      mPrintButton.setEnabled(true);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      mCopiesEditText.setEnabled(true);
    }
 else {
      mCopiesEditText.setEnabled(false);
    }
    if (mCopiesEditText.getError() == null && TextUtils.isEmpty(mCopiesEditText.getText())) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(String.valueOf(MIN_COPIES));
      mCopiesEditText.selectAll();
      mCopiesEditText.requestFocus();
    }
    return someAttributeSelectionChanged;
  }
}","public boolean updateUi(){
  if (mCurrentUi != UI_EDITING_PRINT_JOB) {
    return false;
  }
  if (isPrintConfirmed() || isCancelled()) {
    mDestinationSpinner.setEnabled(false);
    mCopiesEditText.setEnabled(false);
    mMediaSizeSpinner.setEnabled(false);
    mColorModeSpinner.setEnabled(false);
    mOrientationSpinner.setEnabled(false);
    mRangeOptionsSpinner.setEnabled(false);
    mPageRangeEditText.setEnabled(false);
    mPrintButton.setEnabled(false);
    return false;
  }
  boolean allOptionsEnabled=false;
  final int selectedIndex=mDestinationSpinner.getSelectedItemPosition();
  if (selectedIndex >= 0) {
    Object item=mDestinationSpinnerAdapter.getItem(selectedIndex);
    if (item instanceof PrinterInfo) {
      PrinterInfo printer=(PrinterInfo)item;
      if (printer.getCapabilities() != null) {
        allOptionsEnabled=true;
      }
    }
  }
  if (!allOptionsEnabled) {
    String minCopiesString=String.valueOf(MIN_COPIES);
    if (!TextUtils.equals(mCopiesEditText.getText(),minCopiesString)) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(minCopiesString);
    }
    mCopiesEditText.setEnabled(false);
    if (mMediaSizeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextMediaSizeChange=true;
      mMediaSizeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mMediaSizeSpinner.setEnabled(false);
    if (mColorModeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextColorModeChange=true;
      mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mColorModeSpinner.setEnabled(false);
    if (mOrientationSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextOrientationChange=true;
      mOrientationSpinner.setSelection(0);
    }
    mOrientationSpinner.setEnabled(false);
    if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextRangeOptionChange=true;
      mRangeOptionsSpinner.setSelection(0);
    }
    mRangeOptionsSpinner.setEnabled(false);
    mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
    if (!TextUtils.equals(mPageRangeEditText.getText(),""String_Node_Str"")) {
      mIgnoreNextRangeChange=true;
      mPageRangeEditText.setText(""String_Node_Str"");
    }
    mPageRangeEditText.setEnabled(false);
    mPageRangeEditText.setVisibility(View.INVISIBLE);
    mPageRangeTitle.setVisibility(View.INVISIBLE);
    mPrintButton.setEnabled(false);
    return false;
  }
 else {
    boolean someAttributeSelectionChanged=false;
    PrintAttributes defaultAttributes=mTempPrintAttributes;
    PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
    PrinterCapabilitiesInfo capabilities=printer.getCapabilities();
    printer.getCapabilities().getDefaults(defaultAttributes);
    List<MediaSize> mediaSizes=capabilities.getMediaSizes();
    boolean mediaSizesChanged=false;
    final int mediaSizeCount=mediaSizes.size();
    if (mediaSizeCount != mMediaSizeSpinnerAdapter.getCount()) {
      mediaSizesChanged=true;
    }
 else {
      for (int i=0; i < mediaSizeCount; i++) {
        if (!mediaSizes.get(i).equals(mMediaSizeSpinnerAdapter.getItem(i).value)) {
          mediaSizesChanged=true;
          break;
        }
      }
    }
    if (mediaSizesChanged) {
      int oldMediaSizeNewIndex=AdapterView.INVALID_POSITION;
      MediaSize oldMediaSize=mCurrPrintAttributes.getMediaSize();
      mMediaSizeSpinnerAdapter.clear();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize mediaSize=mediaSizes.get(i);
        if (mediaSize.equals(oldMediaSize)) {
          oldMediaSizeNewIndex=i;
        }
        mMediaSizeSpinnerAdapter.add(new SpinnerItem<MediaSize>(mediaSize,mediaSize.getLabel(getPackageManager())));
      }
      if (mediaSizeCount <= 0) {
        mMediaSizeSpinner.setEnabled(false);
        someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(AdapterView.INVALID_POSITION);
      }
 else {
        mMediaSizeSpinner.setEnabled(true);
        if (oldMediaSizeNewIndex != AdapterView.INVALID_POSITION) {
          setMediaSizeSpinnerSelectionNoCallback(oldMediaSizeNewIndex);
        }
 else {
          final int mediaSizeIndex=Math.max(mediaSizes.indexOf(defaultAttributes.getMediaSize()),0);
          someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(mediaSizeIndex);
        }
      }
    }
    mMediaSizeSpinner.setEnabled(true);
    final int colorModes=capabilities.getColorModes();
    boolean colorModesChanged=false;
    if (Integer.bitCount(colorModes) != mColorModeSpinnerAdapter.getCount()) {
      colorModesChanged=true;
    }
 else {
      int remainingColorModes=colorModes;
      int adapterIndex=0;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        remainingColorModes&=~colorMode;
        if (colorMode != mColorModeSpinnerAdapter.getItem(adapterIndex).value) {
          colorModesChanged=true;
          break;
        }
        adapterIndex++;
      }
    }
    if (colorModesChanged) {
      int oldColorModeNewIndex=AdapterView.INVALID_POSITION;
      final int oldColorMode=mCurrPrintAttributes.getColorMode();
      mColorModeSpinnerAdapter.clear();
      String[] colorModeLabels=getResources().getStringArray(R.array.color_mode_labels);
      int remainingColorModes=colorModes;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        if (colorMode == oldColorMode) {
          oldColorModeNewIndex=colorBitOffset;
        }
        remainingColorModes&=~colorMode;
        mColorModeSpinnerAdapter.add(new SpinnerItem<Integer>(colorMode,colorModeLabels[colorBitOffset]));
      }
      final int colorModeCount=Integer.bitCount(colorModes);
      if (colorModeCount <= 0) {
        mColorModeSpinner.setEnabled(false);
        mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
      }
 else {
        mColorModeSpinner.setEnabled(true);
        if (oldColorModeNewIndex != AdapterView.INVALID_POSITION) {
          setColorModeSpinnerSelectionNoCallback(oldColorModeNewIndex);
        }
 else {
          final int selectedColorModeIndex=Integer.numberOfTrailingZeros((colorModes & defaultAttributes.getColorMode()));
          someAttributeSelectionChanged=setColorModeSpinnerSelectionNoCallback(selectedColorModeIndex);
        }
      }
    }
    mColorModeSpinner.setEnabled(true);
    mOrientationSpinner.setEnabled(true);
    PrintDocumentInfo info=mDocument.info;
    if (info != null && (info.getPageCount() > 0 || info.getPageCount() == PrintDocumentInfo.PAGE_COUNT_UNKNOWN)) {
      if (info.getPageCount() == 1) {
        mRangeOptionsSpinner.setEnabled(false);
      }
 else {
        mRangeOptionsSpinner.setEnabled(true);
        if (mRangeOptionsSpinner.getSelectedItemPosition() > 0) {
          if (!mPageRangeEditText.isEnabled()) {
            mPageRangeEditText.setEnabled(true);
            mPageRangeEditText.setVisibility(View.VISIBLE);
            mPageRangeTitle.setVisibility(View.VISIBLE);
            mPageRangeEditText.requestFocus();
            InputMethodManager imm=(InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
            imm.showSoftInput(mPageRangeEditText,0);
          }
        }
 else {
          mPageRangeEditText.setEnabled(false);
          mPageRangeEditText.setVisibility(View.INVISIBLE);
          mPageRangeTitle.setVisibility(View.INVISIBLE);
        }
      }
      final int pageCount=mDocument.info.getPageCount();
      mRangeOptionsTitle.setText(getString(R.string.label_pages,(pageCount == PrintDocumentInfo.PAGE_COUNT_UNKNOWN) ? getString(R.string.page_count_unknown) : String.valueOf(pageCount)));
    }
 else {
      if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
        mIgnoreNextRangeOptionChange=true;
        mRangeOptionsSpinner.setSelection(0);
      }
      mRangeOptionsSpinner.setEnabled(false);
      mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
      mPageRangeEditText.setEnabled(false);
      mPageRangeEditText.setVisibility(View.INVISIBLE);
      mPageRangeTitle.setVisibility(View.INVISIBLE);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      String newText=getString(R.string.print_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.print_button);
      }
    }
 else {
      String newText=getString(R.string.save_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.save_button);
      }
    }
    if ((mRangeOptionsSpinner.getSelectedItemPosition() == 1 && (TextUtils.isEmpty(mPageRangeEditText.getText()) || hasErrors())) || (mRangeOptionsSpinner.getSelectedItemPosition() == 0 && (!mController.hasPerformedLayout() || hasErrors()))) {
      mPrintButton.setEnabled(false);
    }
 else {
      mPrintButton.setEnabled(true);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      mCopiesEditText.setEnabled(true);
    }
 else {
      mCopiesEditText.setEnabled(false);
    }
    if (mCopiesEditText.getError() == null && TextUtils.isEmpty(mCopiesEditText.getText())) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(String.valueOf(MIN_COPIES));
      mCopiesEditText.selectAll();
      mCopiesEditText.requestFocus();
    }
    return someAttributeSelectionChanged;
  }
}"
1569,"public boolean isDone(){
  return isPrintConfirmed() || isPreviewConfirmed() || isCancelled();
}","public boolean isDone(){
  return isPrintConfirmed() || isCancelled();
}"
1570,"@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (mSync) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}","@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (ContextImpl.class) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}"
1571,"/** 
 * Returns a new media size in a portrait orientation which is the height is the greater dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asPortrait(){
  return new MediaSize(mId,mPackageName,mLabel,Math.min(mWidthMils,mHeightMils),Math.max(mWidthMils,mHeightMils),mLabelResId);
}","/** 
 * Returns a new media size in a portrait orientation which is the height is the greater dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asPortrait(){
  return new MediaSize(mId,mLabel,mPackageName,Math.min(mWidthMils,mHeightMils),Math.max(mWidthMils,mHeightMils),mLabelResId);
}"
1572,"/** 
 * Returns a new media size in a landscape orientation which is the height is the lesser dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asLandscape(){
  return new MediaSize(mId,mLabel,Math.max(mWidthMils,mHeightMils),Math.min(mWidthMils,mHeightMils),mLabelResId);
}","/** 
 * Returns a new media size in a landscape orientation which is the height is the lesser dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asLandscape(){
  return new MediaSize(mId,mLabel,mPackageName,Math.max(mWidthMils,mHeightMils),Math.min(mWidthMils,mHeightMils),mLabelResId);
}"
1573,"@SuppressWarnings(""String_Node_Str"") public void addPrinterAndWritePrinterHistory(PrinterInfo printer){
  if (mHistoricalPrinters.size() >= MAX_HISTORY_LENGTH) {
    mHistoricalPrinters.remove(0);
  }
  mHistoricalPrinters.add(printer);
  mWriteTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,new ArrayList<PrinterInfo>(mHistoricalPrinters));
}","@SuppressWarnings(""String_Node_Str"") public void addPrinterAndWritePrinterHistory(PrinterInfo printer){
  if (mHistoricalPrinters.size() >= MAX_HISTORY_LENGTH) {
    mHistoricalPrinters.remove(0);
  }
  mHistoricalPrinters.add(printer);
  new WriteTask().executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,new ArrayList<PrinterInfo>(mHistoricalPrinters));
}"
1574,"public boolean stopReadPrinterHistory(){
  return mReadTask.cancel(true);
}","public boolean stopReadPrinterHistory(){
  final boolean cancelled=mReadTask.cancel(true);
  mReadTask=null;
  return cancelled;
}"
1575,"public void readPrinterHistory(){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
  mReadHistoryInProgress=true;
  mReadTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,(Void[])null);
}","public void readPrinterHistory(){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
  mReadHistoryInProgress=true;
  mReadTask=new ReadTask();
  mReadTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,(Void[])null);
}"
1576,"@Override protected void onPostExecute(List<PrinterInfo> printers){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + FusedPrintersProvider.this.hashCode());
  }
  mHistoricalPrinters=printers;
  mFavoritePrinters.addAll(computeFavoritePrinters(printers));
  mReadHistoryInProgress=false;
  mReadHistoryCompleted=true;
  computeAndDeliverResult();
  loadInternal();
}","@Override protected void onPostExecute(List<PrinterInfo> printers){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + FusedPrintersProvider.this.hashCode());
  }
  mHistoricalPrinters=printers;
  mFavoritePrinters.addAll(computeFavoritePrinters(printers));
  mReadHistoryInProgress=false;
  mReadHistoryCompleted=true;
  computeAndDeliverResult();
  loadInternal();
  mReadTask=null;
}"
1577,"private void updateUiForNewPrinterCapabilities(){
  if (!mMediaSizeSpinnerAdapter.isEmpty()) {
    mIgnoreNextMediaSizeChange=true;
    mMediaSizeSpinnerAdapter.clear();
  }
  if (!mColorModeSpinnerAdapter.isEmpty()) {
    mIgnoreNextColorModeChange=true;
    mColorModeSpinnerAdapter.clear();
  }
  if (!mOrientationSpinnerAdapter.isEmpty()) {
    mIgnoreNextOrientationChange=true;
    mOrientationSpinner.setSelection(0);
  }
  if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextRangeOptionChange=true;
    mRangeOptionsSpinner.setSelection(0);
  }
  if (!TextUtils.isEmpty(mCopiesEditText.getText())) {
    mIgnoreNextCopiesChange=true;
    mCopiesEditText.setText(MIN_COPIES_STRING);
  }
  updateUi();
}","private void updateUiForNewPrinterCapabilities(){
  if (!mMediaSizeSpinnerAdapter.isEmpty()) {
    mIgnoreNextMediaSizeChange=true;
    mMediaSizeSpinnerAdapter.clear();
  }
  if (!mColorModeSpinnerAdapter.isEmpty()) {
    mIgnoreNextColorModeChange=true;
    mColorModeSpinnerAdapter.clear();
  }
  if (mOrientationSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextOrientationChange=true;
    mOrientationSpinner.setSelection(0);
  }
  if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextRangeOptionChange=true;
    mRangeOptionsSpinner.setSelection(0);
  }
  if (!TextUtils.isEmpty(mCopiesEditText.getText())) {
    mIgnoreNextCopiesChange=true;
    mCopiesEditText.setText(MIN_COPIES_STRING);
  }
  updateUi();
}"
1578,"public boolean onTouchEvent(MotionEvent event){
  if (!mEditor.isPrintConfirmed() && !mEditor.isPreviewConfirmed() && mEditor.shouldCloseOnTouch(event)) {
    if (!mController.isWorking()) {
      PrintJobConfigActivity.this.finish();
    }
    mEditor.cancel();
    return true;
  }
  return super.onTouchEvent(event);
}","public boolean onTouchEvent(MotionEvent event){
  if (!mEditor.isPrintConfirmed() && mEditor.shouldCloseOnTouch(event)) {
    if (!mController.isWorking()) {
      PrintJobConfigActivity.this.finish();
    }
    mEditor.cancel();
    return true;
  }
  return super.onTouchEvent(event);
}"
1579,"private void handleOnWriteFinished(PageRange[] pages,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_WRITE_COMPLETED;
  File file=PrintSpoolerService.peekInstance().generateFileForPrintJob(mPrintJobId);
  mDocument.info.setDataSize(file.length());
  mDocument.pages=PageRangeUtils.normalize(pages);
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + Arrays.toString(mRequestedPages) + ""String_Node_Str""+ Arrays.toString(mDocument.pages));
  }
  if (Arrays.equals(mDocument.pages,mRequestedPages)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,ALL_PAGES_ARRAY);
  }
 else   if (Arrays.equals(mDocument.pages,ALL_PAGES_ARRAY)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mRequestedPages);
  }
 else   if (PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    final int offset=mDocument.pages[0].getStart() - pages[0].getStart();
    PageRange[] offsetPages=Arrays.copyOf(mDocument.pages,mDocument.pages.length);
    PageRangeUtils.offsetStart(offsetPages,offset);
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,offsetPages);
  }
 else   if (Arrays.equals(mRequestedPages,ALL_PAGES_ARRAY) && mDocument.pages.length == 1 && mDocument.pages[0].getStart() == 0 && mDocument.pages[0].getEnd() == mDocument.info.getPageCount() - 1) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mDocument.pages);
  }
 else {
    mControllerState=CONTROLLER_STATE_FAILED;
    Log.e(LOG_TAG,""String_Node_Str"");
    PrintJobConfigActivity.this.finish();
  }
  if (mEditor.isDone()) {
    if (mEditor.isPrintingToPdf()) {
      PrintJobInfo printJob=PrintSpoolerService.peekInstance().getPrintJobInfo(mPrintJobId,PrintManager.APP_ID_ANY);
      Intent intent=new Intent(Intent.ACTION_CREATE_DOCUMENT);
      intent.setType(""String_Node_Str"");
      intent.putExtra(Intent.EXTRA_TITLE,printJob.getLabel());
      startActivityForResult(intent,ACTIVITY_REQUEST_CREATE_FILE);
    }
 else {
      PrintJobConfigActivity.this.finish();
    }
  }
}","private void handleOnWriteFinished(PageRange[] pages,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_WRITE_COMPLETED;
  File file=PrintSpoolerService.peekInstance().generateFileForPrintJob(mPrintJobId);
  mDocument.info.setDataSize(file.length());
  mDocument.pages=PageRangeUtils.normalize(pages);
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + Arrays.toString(mRequestedPages) + ""String_Node_Str""+ Arrays.toString(mDocument.pages));
  }
  if (Arrays.equals(mDocument.pages,mRequestedPages)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,ALL_PAGES_ARRAY);
  }
 else   if (Arrays.equals(mDocument.pages,ALL_PAGES_ARRAY)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mRequestedPages);
  }
 else   if (PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    final int offset=mDocument.pages[0].getStart() - pages[0].getStart();
    PageRange[] offsetPages=Arrays.copyOf(mDocument.pages,mDocument.pages.length);
    PageRangeUtils.offsetStart(offsetPages,offset);
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,offsetPages);
  }
 else   if (Arrays.equals(mRequestedPages,ALL_PAGES_ARRAY) && mDocument.pages.length == 1 && mDocument.pages[0].getStart() == 0 && mDocument.pages[0].getEnd() == mDocument.info.getPageCount() - 1) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mDocument.pages);
  }
 else {
    mControllerState=CONTROLLER_STATE_FAILED;
    Log.e(LOG_TAG,""String_Node_Str"");
    PrintJobConfigActivity.this.finish();
  }
  if (mEditor.isDone()) {
    requestCreatePdfFileOrFinish();
  }
}"
1580,"public void addCurrentPrinterToHistory(){
  PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
  if (printer != null) {
    FusedPrintersProvider printersLoader=(FusedPrintersProvider)(Loader<?>)getLoaderManager().getLoader(LOADER_ID_PRINTERS_LOADER);
    if (printersLoader != null) {
      printersLoader.addHistoricalPrinter(printer);
    }
  }
}","public void addCurrentPrinterToHistory(){
  PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
  PrinterId fakePdfPritnerId=mDestinationSpinnerAdapter.mFakePdfPrinter.getId();
  if (printer != null && !printer.getId().equals(fakePdfPritnerId)) {
    FusedPrintersProvider printersLoader=(FusedPrintersProvider)(Loader<?>)getLoaderManager().getLoader(LOADER_ID_PRINTERS_LOADER);
    if (printersLoader != null) {
      printersLoader.addHistoricalPrinter(printer);
    }
  }
}"
1581,"private void handleOnLayoutFinished(PrintDocumentInfo info,boolean layoutChanged,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_LAYOUT_COMPLETED;
  final boolean infoChanged=!info.equals(mDocument.info);
  if (infoChanged) {
    mDocument.info=info;
    PrintSpoolerService.peekInstance().setPrintJobPrintDocumentInfoNoPersistence(mPrintJobId,info);
  }
  if (infoChanged || layoutChanged) {
    mDocument.pages=null;
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,null);
  }
  mRequestedPages=mEditor.getRequestedPages();
  if (mRequestedPages == null) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!infoChanged && !layoutChanged && PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!LIVE_PREVIEW_SUPPORTED && !mEditor.isPreviewConfirmed() && mMetadata.getBoolean(PrintDocumentAdapter.METADATA_KEY_PRINT_PREVIEW)) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mEditor.updateUi();
  mControllerState=CONTROLLER_STATE_WRITE_STARTED;
  mRemotePrintAdapter.write(mRequestedPages,mWriteResultCallback,mRequestCounter.incrementAndGet());
}","private void handleOnLayoutFinished(PrintDocumentInfo info,boolean layoutChanged,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_LAYOUT_COMPLETED;
  final boolean infoChanged=!info.equals(mDocument.info);
  if (infoChanged) {
    mDocument.info=info;
    PrintSpoolerService.peekInstance().setPrintJobPrintDocumentInfoNoPersistence(mPrintJobId,info);
  }
  if (infoChanged || layoutChanged) {
    mDocument.pages=null;
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,null);
  }
  mRequestedPages=mEditor.getRequestedPages();
  if (mRequestedPages == null) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!infoChanged && !layoutChanged && PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    if (mEditor.isDone()) {
      requestCreatePdfFileOrFinish();
    }
    return;
  }
  mEditor.updateUi();
  mControllerState=CONTROLLER_STATE_WRITE_STARTED;
  mRemotePrintAdapter.write(mRequestedPages,mWriteResultCallback,mRequestCounter.incrementAndGet());
}"
1582,"public boolean updateUi(){
  if (mCurrentUi != UI_EDITING_PRINT_JOB) {
    return false;
  }
  if (isPrintConfirmed() || isPreviewConfirmed() || isCancelled()) {
    mDestinationSpinner.setEnabled(false);
    mCopiesEditText.setEnabled(false);
    mMediaSizeSpinner.setEnabled(false);
    mColorModeSpinner.setEnabled(false);
    mOrientationSpinner.setEnabled(false);
    mRangeOptionsSpinner.setEnabled(false);
    mPageRangeEditText.setEnabled(false);
    mPrintButton.setEnabled(false);
    return false;
  }
  boolean allOptionsEnabled=false;
  final int selectedIndex=mDestinationSpinner.getSelectedItemPosition();
  if (selectedIndex >= 0) {
    Object item=mDestinationSpinnerAdapter.getItem(selectedIndex);
    if (item instanceof PrinterInfo) {
      PrinterInfo printer=(PrinterInfo)item;
      if (printer.getCapabilities() != null) {
        allOptionsEnabled=true;
      }
    }
  }
  if (!allOptionsEnabled) {
    String minCopiesString=String.valueOf(MIN_COPIES);
    if (!TextUtils.equals(mCopiesEditText.getText(),minCopiesString)) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(minCopiesString);
    }
    mCopiesEditText.setEnabled(false);
    if (mMediaSizeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextMediaSizeChange=true;
      mMediaSizeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mMediaSizeSpinner.setEnabled(false);
    if (mColorModeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextColorModeChange=true;
      mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mColorModeSpinner.setEnabled(false);
    if (mOrientationSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextOrientationChange=true;
      mOrientationSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mOrientationSpinner.setEnabled(false);
    if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextRangeOptionChange=true;
      mRangeOptionsSpinner.setSelection(0);
    }
    mRangeOptionsSpinner.setEnabled(false);
    mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
    if (!TextUtils.equals(mPageRangeEditText.getText(),""String_Node_Str"")) {
      mIgnoreNextRangeChange=true;
      mPageRangeEditText.setText(""String_Node_Str"");
    }
    mPageRangeEditText.setEnabled(false);
    mPageRangeEditText.setVisibility(View.INVISIBLE);
    mPageRangeTitle.setVisibility(View.INVISIBLE);
    mPrintButton.setEnabled(false);
    return false;
  }
 else {
    boolean someAttributeSelectionChanged=false;
    PrintAttributes defaultAttributes=mTempPrintAttributes;
    PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
    PrinterCapabilitiesInfo capabilities=printer.getCapabilities();
    printer.getCapabilities().getDefaults(defaultAttributes);
    List<MediaSize> mediaSizes=capabilities.getMediaSizes();
    boolean mediaSizesChanged=false;
    final int mediaSizeCount=mediaSizes.size();
    if (mediaSizeCount != mMediaSizeSpinnerAdapter.getCount()) {
      mediaSizesChanged=true;
    }
 else {
      for (int i=0; i < mediaSizeCount; i++) {
        if (!mediaSizes.get(i).equals(mMediaSizeSpinnerAdapter.getItem(i).value)) {
          mediaSizesChanged=true;
          break;
        }
      }
    }
    if (mediaSizesChanged) {
      int oldMediaSizeNewIndex=AdapterView.INVALID_POSITION;
      MediaSize oldMediaSize=mCurrPrintAttributes.getMediaSize();
      mMediaSizeSpinnerAdapter.clear();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize mediaSize=mediaSizes.get(i);
        if (mediaSize.equals(oldMediaSize)) {
          oldMediaSizeNewIndex=i;
        }
        mMediaSizeSpinnerAdapter.add(new SpinnerItem<MediaSize>(mediaSize,mediaSize.getLabel(getPackageManager())));
      }
      if (mediaSizeCount <= 0) {
        mMediaSizeSpinner.setEnabled(false);
        someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(AdapterView.INVALID_POSITION);
      }
 else {
        mMediaSizeSpinner.setEnabled(true);
        if (oldMediaSizeNewIndex != AdapterView.INVALID_POSITION) {
          setMediaSizeSpinnerSelectionNoCallback(oldMediaSizeNewIndex);
        }
 else {
          final int mediaSizeIndex=Math.max(mediaSizes.indexOf(defaultAttributes.getMediaSize()),0);
          someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(mediaSizeIndex);
        }
      }
    }
    mMediaSizeSpinner.setEnabled(true);
    final int colorModes=capabilities.getColorModes();
    boolean colorModesChanged=false;
    if (Integer.bitCount(colorModes) != mColorModeSpinnerAdapter.getCount()) {
      colorModesChanged=true;
    }
 else {
      int remainingColorModes=colorModes;
      int adapterIndex=0;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        remainingColorModes&=~colorMode;
        if (colorMode != mColorModeSpinnerAdapter.getItem(adapterIndex).value) {
          colorModesChanged=true;
          break;
        }
        adapterIndex++;
      }
    }
    if (colorModesChanged) {
      int oldColorModeNewIndex=AdapterView.INVALID_POSITION;
      final int oldColorMode=mCurrPrintAttributes.getColorMode();
      mColorModeSpinnerAdapter.clear();
      String[] colorModeLabels=getResources().getStringArray(R.array.color_mode_labels);
      int remainingColorModes=colorModes;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        if (colorMode == oldColorMode) {
          oldColorModeNewIndex=colorBitOffset;
        }
        remainingColorModes&=~colorMode;
        mColorModeSpinnerAdapter.add(new SpinnerItem<Integer>(colorMode,colorModeLabels[colorBitOffset]));
      }
      final int colorModeCount=Integer.bitCount(colorModes);
      if (colorModeCount <= 0) {
        mColorModeSpinner.setEnabled(false);
        mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
      }
 else {
        mColorModeSpinner.setEnabled(true);
        if (oldColorModeNewIndex != AdapterView.INVALID_POSITION) {
          setColorModeSpinnerSelectionNoCallback(oldColorModeNewIndex);
        }
 else {
          final int selectedColorModeIndex=Integer.numberOfTrailingZeros((colorModes & defaultAttributes.getColorMode()));
          someAttributeSelectionChanged=setColorModeSpinnerSelectionNoCallback(selectedColorModeIndex);
        }
      }
    }
    mColorModeSpinner.setEnabled(true);
    mOrientationSpinner.setEnabled(true);
    PrintDocumentInfo info=mDocument.info;
    if (info != null && (info.getPageCount() > 0 || info.getPageCount() == PrintDocumentInfo.PAGE_COUNT_UNKNOWN)) {
      if (info.getPageCount() == 1) {
        mRangeOptionsSpinner.setEnabled(false);
      }
 else {
        mRangeOptionsSpinner.setEnabled(true);
        if (mRangeOptionsSpinner.getSelectedItemPosition() > 0) {
          if (!mPageRangeEditText.isEnabled()) {
            mPageRangeEditText.setEnabled(true);
            mPageRangeEditText.setVisibility(View.VISIBLE);
            mPageRangeTitle.setVisibility(View.VISIBLE);
            mPageRangeEditText.requestFocus();
            InputMethodManager imm=(InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
            imm.showSoftInput(mPageRangeEditText,0);
          }
        }
 else {
          mPageRangeEditText.setEnabled(false);
          mPageRangeEditText.setVisibility(View.INVISIBLE);
          mPageRangeTitle.setVisibility(View.INVISIBLE);
        }
      }
      final int pageCount=mDocument.info.getPageCount();
      mRangeOptionsTitle.setText(getString(R.string.label_pages,(pageCount == PrintDocumentInfo.PAGE_COUNT_UNKNOWN) ? getString(R.string.page_count_unknown) : String.valueOf(pageCount)));
    }
 else {
      if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
        mIgnoreNextRangeOptionChange=true;
        mRangeOptionsSpinner.setSelection(0);
      }
      mRangeOptionsSpinner.setEnabled(false);
      mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
      mPageRangeEditText.setEnabled(false);
      mPageRangeEditText.setVisibility(View.INVISIBLE);
      mPageRangeTitle.setVisibility(View.INVISIBLE);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      String newText=getString(R.string.print_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.print_button);
      }
    }
 else {
      String newText=getString(R.string.save_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.save_button);
      }
    }
    if ((mRangeOptionsSpinner.getSelectedItemPosition() == 1 && (TextUtils.isEmpty(mPageRangeEditText.getText()) || hasErrors())) || (mRangeOptionsSpinner.getSelectedItemPosition() == 0 && (!mController.hasPerformedLayout() || hasErrors()))) {
      mPrintButton.setEnabled(false);
    }
 else {
      mPrintButton.setEnabled(true);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      mCopiesEditText.setEnabled(true);
    }
 else {
      mCopiesEditText.setEnabled(false);
    }
    if (mCopiesEditText.getError() == null && TextUtils.isEmpty(mCopiesEditText.getText())) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(String.valueOf(MIN_COPIES));
      mCopiesEditText.selectAll();
      mCopiesEditText.requestFocus();
    }
    return someAttributeSelectionChanged;
  }
}","public boolean updateUi(){
  if (mCurrentUi != UI_EDITING_PRINT_JOB) {
    return false;
  }
  if (isPrintConfirmed() || isCancelled()) {
    mDestinationSpinner.setEnabled(false);
    mCopiesEditText.setEnabled(false);
    mMediaSizeSpinner.setEnabled(false);
    mColorModeSpinner.setEnabled(false);
    mOrientationSpinner.setEnabled(false);
    mRangeOptionsSpinner.setEnabled(false);
    mPageRangeEditText.setEnabled(false);
    mPrintButton.setEnabled(false);
    return false;
  }
  boolean allOptionsEnabled=false;
  final int selectedIndex=mDestinationSpinner.getSelectedItemPosition();
  if (selectedIndex >= 0) {
    Object item=mDestinationSpinnerAdapter.getItem(selectedIndex);
    if (item instanceof PrinterInfo) {
      PrinterInfo printer=(PrinterInfo)item;
      if (printer.getCapabilities() != null) {
        allOptionsEnabled=true;
      }
    }
  }
  if (!allOptionsEnabled) {
    String minCopiesString=String.valueOf(MIN_COPIES);
    if (!TextUtils.equals(mCopiesEditText.getText(),minCopiesString)) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(minCopiesString);
    }
    mCopiesEditText.setEnabled(false);
    if (mMediaSizeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextMediaSizeChange=true;
      mMediaSizeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mMediaSizeSpinner.setEnabled(false);
    if (mColorModeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextColorModeChange=true;
      mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mColorModeSpinner.setEnabled(false);
    if (mOrientationSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextOrientationChange=true;
      mOrientationSpinner.setSelection(0);
    }
    mOrientationSpinner.setEnabled(false);
    if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextRangeOptionChange=true;
      mRangeOptionsSpinner.setSelection(0);
    }
    mRangeOptionsSpinner.setEnabled(false);
    mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
    if (!TextUtils.equals(mPageRangeEditText.getText(),""String_Node_Str"")) {
      mIgnoreNextRangeChange=true;
      mPageRangeEditText.setText(""String_Node_Str"");
    }
    mPageRangeEditText.setEnabled(false);
    mPageRangeEditText.setVisibility(View.INVISIBLE);
    mPageRangeTitle.setVisibility(View.INVISIBLE);
    mPrintButton.setEnabled(false);
    return false;
  }
 else {
    boolean someAttributeSelectionChanged=false;
    PrintAttributes defaultAttributes=mTempPrintAttributes;
    PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
    PrinterCapabilitiesInfo capabilities=printer.getCapabilities();
    printer.getCapabilities().getDefaults(defaultAttributes);
    List<MediaSize> mediaSizes=capabilities.getMediaSizes();
    boolean mediaSizesChanged=false;
    final int mediaSizeCount=mediaSizes.size();
    if (mediaSizeCount != mMediaSizeSpinnerAdapter.getCount()) {
      mediaSizesChanged=true;
    }
 else {
      for (int i=0; i < mediaSizeCount; i++) {
        if (!mediaSizes.get(i).equals(mMediaSizeSpinnerAdapter.getItem(i).value)) {
          mediaSizesChanged=true;
          break;
        }
      }
    }
    if (mediaSizesChanged) {
      int oldMediaSizeNewIndex=AdapterView.INVALID_POSITION;
      MediaSize oldMediaSize=mCurrPrintAttributes.getMediaSize();
      mMediaSizeSpinnerAdapter.clear();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize mediaSize=mediaSizes.get(i);
        if (mediaSize.equals(oldMediaSize)) {
          oldMediaSizeNewIndex=i;
        }
        mMediaSizeSpinnerAdapter.add(new SpinnerItem<MediaSize>(mediaSize,mediaSize.getLabel(getPackageManager())));
      }
      if (mediaSizeCount <= 0) {
        mMediaSizeSpinner.setEnabled(false);
        someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(AdapterView.INVALID_POSITION);
      }
 else {
        mMediaSizeSpinner.setEnabled(true);
        if (oldMediaSizeNewIndex != AdapterView.INVALID_POSITION) {
          setMediaSizeSpinnerSelectionNoCallback(oldMediaSizeNewIndex);
        }
 else {
          final int mediaSizeIndex=Math.max(mediaSizes.indexOf(defaultAttributes.getMediaSize()),0);
          someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(mediaSizeIndex);
        }
      }
    }
    mMediaSizeSpinner.setEnabled(true);
    final int colorModes=capabilities.getColorModes();
    boolean colorModesChanged=false;
    if (Integer.bitCount(colorModes) != mColorModeSpinnerAdapter.getCount()) {
      colorModesChanged=true;
    }
 else {
      int remainingColorModes=colorModes;
      int adapterIndex=0;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        remainingColorModes&=~colorMode;
        if (colorMode != mColorModeSpinnerAdapter.getItem(adapterIndex).value) {
          colorModesChanged=true;
          break;
        }
        adapterIndex++;
      }
    }
    if (colorModesChanged) {
      int oldColorModeNewIndex=AdapterView.INVALID_POSITION;
      final int oldColorMode=mCurrPrintAttributes.getColorMode();
      mColorModeSpinnerAdapter.clear();
      String[] colorModeLabels=getResources().getStringArray(R.array.color_mode_labels);
      int remainingColorModes=colorModes;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        if (colorMode == oldColorMode) {
          oldColorModeNewIndex=colorBitOffset;
        }
        remainingColorModes&=~colorMode;
        mColorModeSpinnerAdapter.add(new SpinnerItem<Integer>(colorMode,colorModeLabels[colorBitOffset]));
      }
      final int colorModeCount=Integer.bitCount(colorModes);
      if (colorModeCount <= 0) {
        mColorModeSpinner.setEnabled(false);
        mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
      }
 else {
        mColorModeSpinner.setEnabled(true);
        if (oldColorModeNewIndex != AdapterView.INVALID_POSITION) {
          setColorModeSpinnerSelectionNoCallback(oldColorModeNewIndex);
        }
 else {
          final int selectedColorModeIndex=Integer.numberOfTrailingZeros((colorModes & defaultAttributes.getColorMode()));
          someAttributeSelectionChanged=setColorModeSpinnerSelectionNoCallback(selectedColorModeIndex);
        }
      }
    }
    mColorModeSpinner.setEnabled(true);
    mOrientationSpinner.setEnabled(true);
    PrintDocumentInfo info=mDocument.info;
    if (info != null && (info.getPageCount() > 0 || info.getPageCount() == PrintDocumentInfo.PAGE_COUNT_UNKNOWN)) {
      if (info.getPageCount() == 1) {
        mRangeOptionsSpinner.setEnabled(false);
      }
 else {
        mRangeOptionsSpinner.setEnabled(true);
        if (mRangeOptionsSpinner.getSelectedItemPosition() > 0) {
          if (!mPageRangeEditText.isEnabled()) {
            mPageRangeEditText.setEnabled(true);
            mPageRangeEditText.setVisibility(View.VISIBLE);
            mPageRangeTitle.setVisibility(View.VISIBLE);
            mPageRangeEditText.requestFocus();
            InputMethodManager imm=(InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
            imm.showSoftInput(mPageRangeEditText,0);
          }
        }
 else {
          mPageRangeEditText.setEnabled(false);
          mPageRangeEditText.setVisibility(View.INVISIBLE);
          mPageRangeTitle.setVisibility(View.INVISIBLE);
        }
      }
      final int pageCount=mDocument.info.getPageCount();
      mRangeOptionsTitle.setText(getString(R.string.label_pages,(pageCount == PrintDocumentInfo.PAGE_COUNT_UNKNOWN) ? getString(R.string.page_count_unknown) : String.valueOf(pageCount)));
    }
 else {
      if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
        mIgnoreNextRangeOptionChange=true;
        mRangeOptionsSpinner.setSelection(0);
      }
      mRangeOptionsSpinner.setEnabled(false);
      mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
      mPageRangeEditText.setEnabled(false);
      mPageRangeEditText.setVisibility(View.INVISIBLE);
      mPageRangeTitle.setVisibility(View.INVISIBLE);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      String newText=getString(R.string.print_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.print_button);
      }
    }
 else {
      String newText=getString(R.string.save_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.save_button);
      }
    }
    if ((mRangeOptionsSpinner.getSelectedItemPosition() == 1 && (TextUtils.isEmpty(mPageRangeEditText.getText()) || hasErrors())) || (mRangeOptionsSpinner.getSelectedItemPosition() == 0 && (!mController.hasPerformedLayout() || hasErrors()))) {
      mPrintButton.setEnabled(false);
    }
 else {
      mPrintButton.setEnabled(true);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      mCopiesEditText.setEnabled(true);
    }
 else {
      mCopiesEditText.setEnabled(false);
    }
    if (mCopiesEditText.getError() == null && TextUtils.isEmpty(mCopiesEditText.getText())) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(String.valueOf(MIN_COPIES));
      mCopiesEditText.selectAll();
      mCopiesEditText.requestFocus();
    }
    return someAttributeSelectionChanged;
  }
}"
1583,"public boolean isDone(){
  return isPrintConfirmed() || isPreviewConfirmed() || isCancelled();
}","public boolean isDone(){
  return isPrintConfirmed() || isCancelled();
}"
1584,"@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (mSync) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}","@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (ContextImpl.class) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}"
1585,"@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (mSync) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}","@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (ContextImpl.class) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}"
1586,"/** 
 * Returns a new media size in a portrait orientation which is the height is the greater dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asPortrait(){
  return new MediaSize(mId,mPackageName,mLabel,Math.min(mWidthMils,mHeightMils),Math.max(mWidthMils,mHeightMils),mLabelResId);
}","/** 
 * Returns a new media size in a portrait orientation which is the height is the greater dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asPortrait(){
  return new MediaSize(mId,mLabel,mPackageName,Math.min(mWidthMils,mHeightMils),Math.max(mWidthMils,mHeightMils),mLabelResId);
}"
1587,"/** 
 * Returns a new media size in a landscape orientation which is the height is the lesser dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asLandscape(){
  return new MediaSize(mId,mLabel,Math.max(mWidthMils,mHeightMils),Math.min(mWidthMils,mHeightMils),mLabelResId);
}","/** 
 * Returns a new media size in a landscape orientation which is the height is the lesser dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asLandscape(){
  return new MediaSize(mId,mLabel,mPackageName,Math.max(mWidthMils,mHeightMils),Math.min(mWidthMils,mHeightMils),mLabelResId);
}"
1588,"@SuppressWarnings(""String_Node_Str"") public void addPrinterAndWritePrinterHistory(PrinterInfo printer){
  if (mHistoricalPrinters.size() >= MAX_HISTORY_LENGTH) {
    mHistoricalPrinters.remove(0);
  }
  mHistoricalPrinters.add(printer);
  mWriteTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,new ArrayList<PrinterInfo>(mHistoricalPrinters));
}","@SuppressWarnings(""String_Node_Str"") public void addPrinterAndWritePrinterHistory(PrinterInfo printer){
  if (mHistoricalPrinters.size() >= MAX_HISTORY_LENGTH) {
    mHistoricalPrinters.remove(0);
  }
  mHistoricalPrinters.add(printer);
  new WriteTask().executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,new ArrayList<PrinterInfo>(mHistoricalPrinters));
}"
1589,"public boolean stopReadPrinterHistory(){
  return mReadTask.cancel(true);
}","public boolean stopReadPrinterHistory(){
  final boolean cancelled=mReadTask.cancel(true);
  mReadTask=null;
  return cancelled;
}"
1590,"public void readPrinterHistory(){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
  mReadHistoryInProgress=true;
  mReadTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,(Void[])null);
}","public void readPrinterHistory(){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
  mReadHistoryInProgress=true;
  mReadTask=new ReadTask();
  mReadTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,(Void[])null);
}"
1591,"@Override protected void onPostExecute(List<PrinterInfo> printers){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + FusedPrintersProvider.this.hashCode());
  }
  mHistoricalPrinters=printers;
  mFavoritePrinters.addAll(computeFavoritePrinters(printers));
  mReadHistoryInProgress=false;
  mReadHistoryCompleted=true;
  computeAndDeliverResult();
  loadInternal();
}","@Override protected void onPostExecute(List<PrinterInfo> printers){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + FusedPrintersProvider.this.hashCode());
  }
  mHistoricalPrinters=printers;
  mFavoritePrinters.addAll(computeFavoritePrinters(printers));
  mReadHistoryInProgress=false;
  mReadHistoryCompleted=true;
  computeAndDeliverResult();
  loadInternal();
  mReadTask=null;
}"
1592,"private void updateUiForNewPrinterCapabilities(){
  if (!mMediaSizeSpinnerAdapter.isEmpty()) {
    mIgnoreNextMediaSizeChange=true;
    mMediaSizeSpinnerAdapter.clear();
  }
  if (!mColorModeSpinnerAdapter.isEmpty()) {
    mIgnoreNextColorModeChange=true;
    mColorModeSpinnerAdapter.clear();
  }
  if (!mOrientationSpinnerAdapter.isEmpty()) {
    mIgnoreNextOrientationChange=true;
    mOrientationSpinner.setSelection(0);
  }
  if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextRangeOptionChange=true;
    mRangeOptionsSpinner.setSelection(0);
  }
  if (!TextUtils.isEmpty(mCopiesEditText.getText())) {
    mIgnoreNextCopiesChange=true;
    mCopiesEditText.setText(MIN_COPIES_STRING);
  }
  updateUi();
}","private void updateUiForNewPrinterCapabilities(){
  if (!mMediaSizeSpinnerAdapter.isEmpty()) {
    mIgnoreNextMediaSizeChange=true;
    mMediaSizeSpinnerAdapter.clear();
  }
  if (!mColorModeSpinnerAdapter.isEmpty()) {
    mIgnoreNextColorModeChange=true;
    mColorModeSpinnerAdapter.clear();
  }
  if (mOrientationSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextOrientationChange=true;
    mOrientationSpinner.setSelection(0);
  }
  if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextRangeOptionChange=true;
    mRangeOptionsSpinner.setSelection(0);
  }
  if (!TextUtils.isEmpty(mCopiesEditText.getText())) {
    mIgnoreNextCopiesChange=true;
    mCopiesEditText.setText(MIN_COPIES_STRING);
  }
  updateUi();
}"
1593,"public boolean onTouchEvent(MotionEvent event){
  if (!mEditor.isPrintConfirmed() && !mEditor.isPreviewConfirmed() && mEditor.shouldCloseOnTouch(event)) {
    if (!mController.isWorking()) {
      PrintJobConfigActivity.this.finish();
    }
    mEditor.cancel();
    return true;
  }
  return super.onTouchEvent(event);
}","public boolean onTouchEvent(MotionEvent event){
  if (!mEditor.isPrintConfirmed() && mEditor.shouldCloseOnTouch(event)) {
    if (!mController.isWorking()) {
      PrintJobConfigActivity.this.finish();
    }
    mEditor.cancel();
    return true;
  }
  return super.onTouchEvent(event);
}"
1594,"private void handleOnWriteFinished(PageRange[] pages,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_WRITE_COMPLETED;
  File file=PrintSpoolerService.peekInstance().generateFileForPrintJob(mPrintJobId);
  mDocument.info.setDataSize(file.length());
  mDocument.pages=PageRangeUtils.normalize(pages);
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + Arrays.toString(mRequestedPages) + ""String_Node_Str""+ Arrays.toString(mDocument.pages));
  }
  if (Arrays.equals(mDocument.pages,mRequestedPages)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,ALL_PAGES_ARRAY);
  }
 else   if (Arrays.equals(mDocument.pages,ALL_PAGES_ARRAY)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mRequestedPages);
  }
 else   if (PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    final int offset=mDocument.pages[0].getStart() - pages[0].getStart();
    PageRange[] offsetPages=Arrays.copyOf(mDocument.pages,mDocument.pages.length);
    PageRangeUtils.offsetStart(offsetPages,offset);
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,offsetPages);
  }
 else   if (Arrays.equals(mRequestedPages,ALL_PAGES_ARRAY) && mDocument.pages.length == 1 && mDocument.pages[0].getStart() == 0 && mDocument.pages[0].getEnd() == mDocument.info.getPageCount() - 1) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mDocument.pages);
  }
 else {
    mControllerState=CONTROLLER_STATE_FAILED;
    Log.e(LOG_TAG,""String_Node_Str"");
    PrintJobConfigActivity.this.finish();
  }
  if (mEditor.isDone()) {
    if (mEditor.isPrintingToPdf()) {
      PrintJobInfo printJob=PrintSpoolerService.peekInstance().getPrintJobInfo(mPrintJobId,PrintManager.APP_ID_ANY);
      Intent intent=new Intent(Intent.ACTION_CREATE_DOCUMENT);
      intent.setType(""String_Node_Str"");
      intent.putExtra(Intent.EXTRA_TITLE,printJob.getLabel());
      startActivityForResult(intent,ACTIVITY_REQUEST_CREATE_FILE);
    }
 else {
      PrintJobConfigActivity.this.finish();
    }
  }
}","private void handleOnWriteFinished(PageRange[] pages,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_WRITE_COMPLETED;
  File file=PrintSpoolerService.peekInstance().generateFileForPrintJob(mPrintJobId);
  mDocument.info.setDataSize(file.length());
  mDocument.pages=PageRangeUtils.normalize(pages);
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + Arrays.toString(mRequestedPages) + ""String_Node_Str""+ Arrays.toString(mDocument.pages));
  }
  if (Arrays.equals(mDocument.pages,mRequestedPages)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,ALL_PAGES_ARRAY);
  }
 else   if (Arrays.equals(mDocument.pages,ALL_PAGES_ARRAY)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mRequestedPages);
  }
 else   if (PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    final int offset=mDocument.pages[0].getStart() - pages[0].getStart();
    PageRange[] offsetPages=Arrays.copyOf(mDocument.pages,mDocument.pages.length);
    PageRangeUtils.offsetStart(offsetPages,offset);
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,offsetPages);
  }
 else   if (Arrays.equals(mRequestedPages,ALL_PAGES_ARRAY) && mDocument.pages.length == 1 && mDocument.pages[0].getStart() == 0 && mDocument.pages[0].getEnd() == mDocument.info.getPageCount() - 1) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mDocument.pages);
  }
 else {
    mControllerState=CONTROLLER_STATE_FAILED;
    Log.e(LOG_TAG,""String_Node_Str"");
    PrintJobConfigActivity.this.finish();
  }
  if (mEditor.isDone()) {
    requestCreatePdfFileOrFinish();
  }
}"
1595,"public void addCurrentPrinterToHistory(){
  PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
  if (printer != null) {
    FusedPrintersProvider printersLoader=(FusedPrintersProvider)(Loader<?>)getLoaderManager().getLoader(LOADER_ID_PRINTERS_LOADER);
    if (printersLoader != null) {
      printersLoader.addHistoricalPrinter(printer);
    }
  }
}","public void addCurrentPrinterToHistory(){
  PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
  PrinterId fakePdfPritnerId=mDestinationSpinnerAdapter.mFakePdfPrinter.getId();
  if (printer != null && !printer.getId().equals(fakePdfPritnerId)) {
    FusedPrintersProvider printersLoader=(FusedPrintersProvider)(Loader<?>)getLoaderManager().getLoader(LOADER_ID_PRINTERS_LOADER);
    if (printersLoader != null) {
      printersLoader.addHistoricalPrinter(printer);
    }
  }
}"
1596,"private void handleOnLayoutFinished(PrintDocumentInfo info,boolean layoutChanged,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_LAYOUT_COMPLETED;
  final boolean infoChanged=!info.equals(mDocument.info);
  if (infoChanged) {
    mDocument.info=info;
    PrintSpoolerService.peekInstance().setPrintJobPrintDocumentInfoNoPersistence(mPrintJobId,info);
  }
  if (infoChanged || layoutChanged) {
    mDocument.pages=null;
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,null);
  }
  mRequestedPages=mEditor.getRequestedPages();
  if (mRequestedPages == null) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!infoChanged && !layoutChanged && PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!LIVE_PREVIEW_SUPPORTED && !mEditor.isPreviewConfirmed() && mMetadata.getBoolean(PrintDocumentAdapter.METADATA_KEY_PRINT_PREVIEW)) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mEditor.updateUi();
  mControllerState=CONTROLLER_STATE_WRITE_STARTED;
  mRemotePrintAdapter.write(mRequestedPages,mWriteResultCallback,mRequestCounter.incrementAndGet());
}","private void handleOnLayoutFinished(PrintDocumentInfo info,boolean layoutChanged,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_LAYOUT_COMPLETED;
  final boolean infoChanged=!info.equals(mDocument.info);
  if (infoChanged) {
    mDocument.info=info;
    PrintSpoolerService.peekInstance().setPrintJobPrintDocumentInfoNoPersistence(mPrintJobId,info);
  }
  if (infoChanged || layoutChanged) {
    mDocument.pages=null;
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,null);
  }
  mRequestedPages=mEditor.getRequestedPages();
  if (mRequestedPages == null) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!infoChanged && !layoutChanged && PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    if (mEditor.isDone()) {
      requestCreatePdfFileOrFinish();
    }
    return;
  }
  mEditor.updateUi();
  mControllerState=CONTROLLER_STATE_WRITE_STARTED;
  mRemotePrintAdapter.write(mRequestedPages,mWriteResultCallback,mRequestCounter.incrementAndGet());
}"
1597,"public boolean updateUi(){
  if (mCurrentUi != UI_EDITING_PRINT_JOB) {
    return false;
  }
  if (isPrintConfirmed() || isPreviewConfirmed() || isCancelled()) {
    mDestinationSpinner.setEnabled(false);
    mCopiesEditText.setEnabled(false);
    mMediaSizeSpinner.setEnabled(false);
    mColorModeSpinner.setEnabled(false);
    mOrientationSpinner.setEnabled(false);
    mRangeOptionsSpinner.setEnabled(false);
    mPageRangeEditText.setEnabled(false);
    mPrintButton.setEnabled(false);
    return false;
  }
  boolean allOptionsEnabled=false;
  final int selectedIndex=mDestinationSpinner.getSelectedItemPosition();
  if (selectedIndex >= 0) {
    Object item=mDestinationSpinnerAdapter.getItem(selectedIndex);
    if (item instanceof PrinterInfo) {
      PrinterInfo printer=(PrinterInfo)item;
      if (printer.getCapabilities() != null) {
        allOptionsEnabled=true;
      }
    }
  }
  if (!allOptionsEnabled) {
    String minCopiesString=String.valueOf(MIN_COPIES);
    if (!TextUtils.equals(mCopiesEditText.getText(),minCopiesString)) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(minCopiesString);
    }
    mCopiesEditText.setEnabled(false);
    if (mMediaSizeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextMediaSizeChange=true;
      mMediaSizeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mMediaSizeSpinner.setEnabled(false);
    if (mColorModeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextColorModeChange=true;
      mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mColorModeSpinner.setEnabled(false);
    if (mOrientationSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextOrientationChange=true;
      mOrientationSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mOrientationSpinner.setEnabled(false);
    if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextRangeOptionChange=true;
      mRangeOptionsSpinner.setSelection(0);
    }
    mRangeOptionsSpinner.setEnabled(false);
    mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
    if (!TextUtils.equals(mPageRangeEditText.getText(),""String_Node_Str"")) {
      mIgnoreNextRangeChange=true;
      mPageRangeEditText.setText(""String_Node_Str"");
    }
    mPageRangeEditText.setEnabled(false);
    mPageRangeEditText.setVisibility(View.INVISIBLE);
    mPageRangeTitle.setVisibility(View.INVISIBLE);
    mPrintButton.setEnabled(false);
    return false;
  }
 else {
    boolean someAttributeSelectionChanged=false;
    PrintAttributes defaultAttributes=mTempPrintAttributes;
    PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
    PrinterCapabilitiesInfo capabilities=printer.getCapabilities();
    printer.getCapabilities().getDefaults(defaultAttributes);
    List<MediaSize> mediaSizes=capabilities.getMediaSizes();
    boolean mediaSizesChanged=false;
    final int mediaSizeCount=mediaSizes.size();
    if (mediaSizeCount != mMediaSizeSpinnerAdapter.getCount()) {
      mediaSizesChanged=true;
    }
 else {
      for (int i=0; i < mediaSizeCount; i++) {
        if (!mediaSizes.get(i).equals(mMediaSizeSpinnerAdapter.getItem(i).value)) {
          mediaSizesChanged=true;
          break;
        }
      }
    }
    if (mediaSizesChanged) {
      int oldMediaSizeNewIndex=AdapterView.INVALID_POSITION;
      MediaSize oldMediaSize=mCurrPrintAttributes.getMediaSize();
      mMediaSizeSpinnerAdapter.clear();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize mediaSize=mediaSizes.get(i);
        if (mediaSize.equals(oldMediaSize)) {
          oldMediaSizeNewIndex=i;
        }
        mMediaSizeSpinnerAdapter.add(new SpinnerItem<MediaSize>(mediaSize,mediaSize.getLabel(getPackageManager())));
      }
      if (mediaSizeCount <= 0) {
        mMediaSizeSpinner.setEnabled(false);
        someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(AdapterView.INVALID_POSITION);
      }
 else {
        mMediaSizeSpinner.setEnabled(true);
        if (oldMediaSizeNewIndex != AdapterView.INVALID_POSITION) {
          setMediaSizeSpinnerSelectionNoCallback(oldMediaSizeNewIndex);
        }
 else {
          final int mediaSizeIndex=Math.max(mediaSizes.indexOf(defaultAttributes.getMediaSize()),0);
          someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(mediaSizeIndex);
        }
      }
    }
    mMediaSizeSpinner.setEnabled(true);
    final int colorModes=capabilities.getColorModes();
    boolean colorModesChanged=false;
    if (Integer.bitCount(colorModes) != mColorModeSpinnerAdapter.getCount()) {
      colorModesChanged=true;
    }
 else {
      int remainingColorModes=colorModes;
      int adapterIndex=0;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        remainingColorModes&=~colorMode;
        if (colorMode != mColorModeSpinnerAdapter.getItem(adapterIndex).value) {
          colorModesChanged=true;
          break;
        }
        adapterIndex++;
      }
    }
    if (colorModesChanged) {
      int oldColorModeNewIndex=AdapterView.INVALID_POSITION;
      final int oldColorMode=mCurrPrintAttributes.getColorMode();
      mColorModeSpinnerAdapter.clear();
      String[] colorModeLabels=getResources().getStringArray(R.array.color_mode_labels);
      int remainingColorModes=colorModes;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        if (colorMode == oldColorMode) {
          oldColorModeNewIndex=colorBitOffset;
        }
        remainingColorModes&=~colorMode;
        mColorModeSpinnerAdapter.add(new SpinnerItem<Integer>(colorMode,colorModeLabels[colorBitOffset]));
      }
      final int colorModeCount=Integer.bitCount(colorModes);
      if (colorModeCount <= 0) {
        mColorModeSpinner.setEnabled(false);
        mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
      }
 else {
        mColorModeSpinner.setEnabled(true);
        if (oldColorModeNewIndex != AdapterView.INVALID_POSITION) {
          setColorModeSpinnerSelectionNoCallback(oldColorModeNewIndex);
        }
 else {
          final int selectedColorModeIndex=Integer.numberOfTrailingZeros((colorModes & defaultAttributes.getColorMode()));
          someAttributeSelectionChanged=setColorModeSpinnerSelectionNoCallback(selectedColorModeIndex);
        }
      }
    }
    mColorModeSpinner.setEnabled(true);
    mOrientationSpinner.setEnabled(true);
    PrintDocumentInfo info=mDocument.info;
    if (info != null && (info.getPageCount() > 0 || info.getPageCount() == PrintDocumentInfo.PAGE_COUNT_UNKNOWN)) {
      if (info.getPageCount() == 1) {
        mRangeOptionsSpinner.setEnabled(false);
      }
 else {
        mRangeOptionsSpinner.setEnabled(true);
        if (mRangeOptionsSpinner.getSelectedItemPosition() > 0) {
          if (!mPageRangeEditText.isEnabled()) {
            mPageRangeEditText.setEnabled(true);
            mPageRangeEditText.setVisibility(View.VISIBLE);
            mPageRangeTitle.setVisibility(View.VISIBLE);
            mPageRangeEditText.requestFocus();
            InputMethodManager imm=(InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
            imm.showSoftInput(mPageRangeEditText,0);
          }
        }
 else {
          mPageRangeEditText.setEnabled(false);
          mPageRangeEditText.setVisibility(View.INVISIBLE);
          mPageRangeTitle.setVisibility(View.INVISIBLE);
        }
      }
      final int pageCount=mDocument.info.getPageCount();
      mRangeOptionsTitle.setText(getString(R.string.label_pages,(pageCount == PrintDocumentInfo.PAGE_COUNT_UNKNOWN) ? getString(R.string.page_count_unknown) : String.valueOf(pageCount)));
    }
 else {
      if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
        mIgnoreNextRangeOptionChange=true;
        mRangeOptionsSpinner.setSelection(0);
      }
      mRangeOptionsSpinner.setEnabled(false);
      mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
      mPageRangeEditText.setEnabled(false);
      mPageRangeEditText.setVisibility(View.INVISIBLE);
      mPageRangeTitle.setVisibility(View.INVISIBLE);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      String newText=getString(R.string.print_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.print_button);
      }
    }
 else {
      String newText=getString(R.string.save_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.save_button);
      }
    }
    if ((mRangeOptionsSpinner.getSelectedItemPosition() == 1 && (TextUtils.isEmpty(mPageRangeEditText.getText()) || hasErrors())) || (mRangeOptionsSpinner.getSelectedItemPosition() == 0 && (!mController.hasPerformedLayout() || hasErrors()))) {
      mPrintButton.setEnabled(false);
    }
 else {
      mPrintButton.setEnabled(true);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      mCopiesEditText.setEnabled(true);
    }
 else {
      mCopiesEditText.setEnabled(false);
    }
    if (mCopiesEditText.getError() == null && TextUtils.isEmpty(mCopiesEditText.getText())) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(String.valueOf(MIN_COPIES));
      mCopiesEditText.selectAll();
      mCopiesEditText.requestFocus();
    }
    return someAttributeSelectionChanged;
  }
}","public boolean updateUi(){
  if (mCurrentUi != UI_EDITING_PRINT_JOB) {
    return false;
  }
  if (isPrintConfirmed() || isCancelled()) {
    mDestinationSpinner.setEnabled(false);
    mCopiesEditText.setEnabled(false);
    mMediaSizeSpinner.setEnabled(false);
    mColorModeSpinner.setEnabled(false);
    mOrientationSpinner.setEnabled(false);
    mRangeOptionsSpinner.setEnabled(false);
    mPageRangeEditText.setEnabled(false);
    mPrintButton.setEnabled(false);
    return false;
  }
  boolean allOptionsEnabled=false;
  final int selectedIndex=mDestinationSpinner.getSelectedItemPosition();
  if (selectedIndex >= 0) {
    Object item=mDestinationSpinnerAdapter.getItem(selectedIndex);
    if (item instanceof PrinterInfo) {
      PrinterInfo printer=(PrinterInfo)item;
      if (printer.getCapabilities() != null) {
        allOptionsEnabled=true;
      }
    }
  }
  if (!allOptionsEnabled) {
    String minCopiesString=String.valueOf(MIN_COPIES);
    if (!TextUtils.equals(mCopiesEditText.getText(),minCopiesString)) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(minCopiesString);
    }
    mCopiesEditText.setEnabled(false);
    if (mMediaSizeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextMediaSizeChange=true;
      mMediaSizeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mMediaSizeSpinner.setEnabled(false);
    if (mColorModeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextColorModeChange=true;
      mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mColorModeSpinner.setEnabled(false);
    if (mOrientationSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextOrientationChange=true;
      mOrientationSpinner.setSelection(0);
    }
    mOrientationSpinner.setEnabled(false);
    if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextRangeOptionChange=true;
      mRangeOptionsSpinner.setSelection(0);
    }
    mRangeOptionsSpinner.setEnabled(false);
    mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
    if (!TextUtils.equals(mPageRangeEditText.getText(),""String_Node_Str"")) {
      mIgnoreNextRangeChange=true;
      mPageRangeEditText.setText(""String_Node_Str"");
    }
    mPageRangeEditText.setEnabled(false);
    mPageRangeEditText.setVisibility(View.INVISIBLE);
    mPageRangeTitle.setVisibility(View.INVISIBLE);
    mPrintButton.setEnabled(false);
    return false;
  }
 else {
    boolean someAttributeSelectionChanged=false;
    PrintAttributes defaultAttributes=mTempPrintAttributes;
    PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
    PrinterCapabilitiesInfo capabilities=printer.getCapabilities();
    printer.getCapabilities().getDefaults(defaultAttributes);
    List<MediaSize> mediaSizes=capabilities.getMediaSizes();
    boolean mediaSizesChanged=false;
    final int mediaSizeCount=mediaSizes.size();
    if (mediaSizeCount != mMediaSizeSpinnerAdapter.getCount()) {
      mediaSizesChanged=true;
    }
 else {
      for (int i=0; i < mediaSizeCount; i++) {
        if (!mediaSizes.get(i).equals(mMediaSizeSpinnerAdapter.getItem(i).value)) {
          mediaSizesChanged=true;
          break;
        }
      }
    }
    if (mediaSizesChanged) {
      int oldMediaSizeNewIndex=AdapterView.INVALID_POSITION;
      MediaSize oldMediaSize=mCurrPrintAttributes.getMediaSize();
      mMediaSizeSpinnerAdapter.clear();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize mediaSize=mediaSizes.get(i);
        if (mediaSize.equals(oldMediaSize)) {
          oldMediaSizeNewIndex=i;
        }
        mMediaSizeSpinnerAdapter.add(new SpinnerItem<MediaSize>(mediaSize,mediaSize.getLabel(getPackageManager())));
      }
      if (mediaSizeCount <= 0) {
        mMediaSizeSpinner.setEnabled(false);
        someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(AdapterView.INVALID_POSITION);
      }
 else {
        mMediaSizeSpinner.setEnabled(true);
        if (oldMediaSizeNewIndex != AdapterView.INVALID_POSITION) {
          setMediaSizeSpinnerSelectionNoCallback(oldMediaSizeNewIndex);
        }
 else {
          final int mediaSizeIndex=Math.max(mediaSizes.indexOf(defaultAttributes.getMediaSize()),0);
          someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(mediaSizeIndex);
        }
      }
    }
    mMediaSizeSpinner.setEnabled(true);
    final int colorModes=capabilities.getColorModes();
    boolean colorModesChanged=false;
    if (Integer.bitCount(colorModes) != mColorModeSpinnerAdapter.getCount()) {
      colorModesChanged=true;
    }
 else {
      int remainingColorModes=colorModes;
      int adapterIndex=0;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        remainingColorModes&=~colorMode;
        if (colorMode != mColorModeSpinnerAdapter.getItem(adapterIndex).value) {
          colorModesChanged=true;
          break;
        }
        adapterIndex++;
      }
    }
    if (colorModesChanged) {
      int oldColorModeNewIndex=AdapterView.INVALID_POSITION;
      final int oldColorMode=mCurrPrintAttributes.getColorMode();
      mColorModeSpinnerAdapter.clear();
      String[] colorModeLabels=getResources().getStringArray(R.array.color_mode_labels);
      int remainingColorModes=colorModes;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        if (colorMode == oldColorMode) {
          oldColorModeNewIndex=colorBitOffset;
        }
        remainingColorModes&=~colorMode;
        mColorModeSpinnerAdapter.add(new SpinnerItem<Integer>(colorMode,colorModeLabels[colorBitOffset]));
      }
      final int colorModeCount=Integer.bitCount(colorModes);
      if (colorModeCount <= 0) {
        mColorModeSpinner.setEnabled(false);
        mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
      }
 else {
        mColorModeSpinner.setEnabled(true);
        if (oldColorModeNewIndex != AdapterView.INVALID_POSITION) {
          setColorModeSpinnerSelectionNoCallback(oldColorModeNewIndex);
        }
 else {
          final int selectedColorModeIndex=Integer.numberOfTrailingZeros((colorModes & defaultAttributes.getColorMode()));
          someAttributeSelectionChanged=setColorModeSpinnerSelectionNoCallback(selectedColorModeIndex);
        }
      }
    }
    mColorModeSpinner.setEnabled(true);
    mOrientationSpinner.setEnabled(true);
    PrintDocumentInfo info=mDocument.info;
    if (info != null && (info.getPageCount() > 0 || info.getPageCount() == PrintDocumentInfo.PAGE_COUNT_UNKNOWN)) {
      if (info.getPageCount() == 1) {
        mRangeOptionsSpinner.setEnabled(false);
      }
 else {
        mRangeOptionsSpinner.setEnabled(true);
        if (mRangeOptionsSpinner.getSelectedItemPosition() > 0) {
          if (!mPageRangeEditText.isEnabled()) {
            mPageRangeEditText.setEnabled(true);
            mPageRangeEditText.setVisibility(View.VISIBLE);
            mPageRangeTitle.setVisibility(View.VISIBLE);
            mPageRangeEditText.requestFocus();
            InputMethodManager imm=(InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
            imm.showSoftInput(mPageRangeEditText,0);
          }
        }
 else {
          mPageRangeEditText.setEnabled(false);
          mPageRangeEditText.setVisibility(View.INVISIBLE);
          mPageRangeTitle.setVisibility(View.INVISIBLE);
        }
      }
      final int pageCount=mDocument.info.getPageCount();
      mRangeOptionsTitle.setText(getString(R.string.label_pages,(pageCount == PrintDocumentInfo.PAGE_COUNT_UNKNOWN) ? getString(R.string.page_count_unknown) : String.valueOf(pageCount)));
    }
 else {
      if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
        mIgnoreNextRangeOptionChange=true;
        mRangeOptionsSpinner.setSelection(0);
      }
      mRangeOptionsSpinner.setEnabled(false);
      mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
      mPageRangeEditText.setEnabled(false);
      mPageRangeEditText.setVisibility(View.INVISIBLE);
      mPageRangeTitle.setVisibility(View.INVISIBLE);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      String newText=getString(R.string.print_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.print_button);
      }
    }
 else {
      String newText=getString(R.string.save_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.save_button);
      }
    }
    if ((mRangeOptionsSpinner.getSelectedItemPosition() == 1 && (TextUtils.isEmpty(mPageRangeEditText.getText()) || hasErrors())) || (mRangeOptionsSpinner.getSelectedItemPosition() == 0 && (!mController.hasPerformedLayout() || hasErrors()))) {
      mPrintButton.setEnabled(false);
    }
 else {
      mPrintButton.setEnabled(true);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      mCopiesEditText.setEnabled(true);
    }
 else {
      mCopiesEditText.setEnabled(false);
    }
    if (mCopiesEditText.getError() == null && TextUtils.isEmpty(mCopiesEditText.getText())) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(String.valueOf(MIN_COPIES));
      mCopiesEditText.selectAll();
      mCopiesEditText.requestFocus();
    }
    return someAttributeSelectionChanged;
  }
}"
1598,"public boolean isDone(){
  return isPrintConfirmed() || isPreviewConfirmed() || isCancelled();
}","public boolean isDone(){
  return isPrintConfirmed() || isCancelled();
}"
1599,"@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (mSync) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}","@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (ContextImpl.class) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}"
1600,"@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (mSync) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}","@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (ContextImpl.class) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}"
1601,"/** 
 * Returns a new media size in a portrait orientation which is the height is the greater dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asPortrait(){
  return new MediaSize(mId,mPackageName,mLabel,Math.min(mWidthMils,mHeightMils),Math.max(mWidthMils,mHeightMils),mLabelResId);
}","/** 
 * Returns a new media size in a portrait orientation which is the height is the greater dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asPortrait(){
  return new MediaSize(mId,mLabel,mPackageName,Math.min(mWidthMils,mHeightMils),Math.max(mWidthMils,mHeightMils),mLabelResId);
}"
1602,"/** 
 * Returns a new media size in a landscape orientation which is the height is the lesser dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asLandscape(){
  return new MediaSize(mId,mLabel,Math.max(mWidthMils,mHeightMils),Math.min(mWidthMils,mHeightMils),mLabelResId);
}","/** 
 * Returns a new media size in a landscape orientation which is the height is the lesser dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asLandscape(){
  return new MediaSize(mId,mLabel,mPackageName,Math.max(mWidthMils,mHeightMils),Math.min(mWidthMils,mHeightMils),mLabelResId);
}"
1603,"@SuppressWarnings(""String_Node_Str"") public void addPrinterAndWritePrinterHistory(PrinterInfo printer){
  if (mHistoricalPrinters.size() >= MAX_HISTORY_LENGTH) {
    mHistoricalPrinters.remove(0);
  }
  mHistoricalPrinters.add(printer);
  mWriteTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,new ArrayList<PrinterInfo>(mHistoricalPrinters));
}","@SuppressWarnings(""String_Node_Str"") public void addPrinterAndWritePrinterHistory(PrinterInfo printer){
  if (mHistoricalPrinters.size() >= MAX_HISTORY_LENGTH) {
    mHistoricalPrinters.remove(0);
  }
  mHistoricalPrinters.add(printer);
  new WriteTask().executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,new ArrayList<PrinterInfo>(mHistoricalPrinters));
}"
1604,"public boolean stopReadPrinterHistory(){
  return mReadTask.cancel(true);
}","public boolean stopReadPrinterHistory(){
  final boolean cancelled=mReadTask.cancel(true);
  mReadTask=null;
  return cancelled;
}"
1605,"public void readPrinterHistory(){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
  mReadHistoryInProgress=true;
  mReadTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,(Void[])null);
}","public void readPrinterHistory(){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
  mReadHistoryInProgress=true;
  mReadTask=new ReadTask();
  mReadTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,(Void[])null);
}"
1606,"@Override protected void onPostExecute(List<PrinterInfo> printers){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + FusedPrintersProvider.this.hashCode());
  }
  mHistoricalPrinters=printers;
  mFavoritePrinters.addAll(computeFavoritePrinters(printers));
  mReadHistoryInProgress=false;
  mReadHistoryCompleted=true;
  computeAndDeliverResult();
  loadInternal();
}","@Override protected void onPostExecute(List<PrinterInfo> printers){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + FusedPrintersProvider.this.hashCode());
  }
  mHistoricalPrinters=printers;
  mFavoritePrinters.addAll(computeFavoritePrinters(printers));
  mReadHistoryInProgress=false;
  mReadHistoryCompleted=true;
  computeAndDeliverResult();
  loadInternal();
  mReadTask=null;
}"
1607,"private void updateUiForNewPrinterCapabilities(){
  if (!mMediaSizeSpinnerAdapter.isEmpty()) {
    mIgnoreNextMediaSizeChange=true;
    mMediaSizeSpinnerAdapter.clear();
  }
  if (!mColorModeSpinnerAdapter.isEmpty()) {
    mIgnoreNextColorModeChange=true;
    mColorModeSpinnerAdapter.clear();
  }
  if (!mOrientationSpinnerAdapter.isEmpty()) {
    mIgnoreNextOrientationChange=true;
    mOrientationSpinner.setSelection(0);
  }
  if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextRangeOptionChange=true;
    mRangeOptionsSpinner.setSelection(0);
  }
  if (!TextUtils.isEmpty(mCopiesEditText.getText())) {
    mIgnoreNextCopiesChange=true;
    mCopiesEditText.setText(MIN_COPIES_STRING);
  }
  updateUi();
}","private void updateUiForNewPrinterCapabilities(){
  if (!mMediaSizeSpinnerAdapter.isEmpty()) {
    mIgnoreNextMediaSizeChange=true;
    mMediaSizeSpinnerAdapter.clear();
  }
  if (!mColorModeSpinnerAdapter.isEmpty()) {
    mIgnoreNextColorModeChange=true;
    mColorModeSpinnerAdapter.clear();
  }
  if (mOrientationSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextOrientationChange=true;
    mOrientationSpinner.setSelection(0);
  }
  if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextRangeOptionChange=true;
    mRangeOptionsSpinner.setSelection(0);
  }
  if (!TextUtils.isEmpty(mCopiesEditText.getText())) {
    mIgnoreNextCopiesChange=true;
    mCopiesEditText.setText(MIN_COPIES_STRING);
  }
  updateUi();
}"
1608,"public boolean onTouchEvent(MotionEvent event){
  if (!mEditor.isPrintConfirmed() && !mEditor.isPreviewConfirmed() && mEditor.shouldCloseOnTouch(event)) {
    if (!mController.isWorking()) {
      PrintJobConfigActivity.this.finish();
    }
    mEditor.cancel();
    return true;
  }
  return super.onTouchEvent(event);
}","public boolean onTouchEvent(MotionEvent event){
  if (!mEditor.isPrintConfirmed() && mEditor.shouldCloseOnTouch(event)) {
    if (!mController.isWorking()) {
      PrintJobConfigActivity.this.finish();
    }
    mEditor.cancel();
    return true;
  }
  return super.onTouchEvent(event);
}"
1609,"private void handleOnWriteFinished(PageRange[] pages,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_WRITE_COMPLETED;
  File file=PrintSpoolerService.peekInstance().generateFileForPrintJob(mPrintJobId);
  mDocument.info.setDataSize(file.length());
  mDocument.pages=PageRangeUtils.normalize(pages);
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + Arrays.toString(mRequestedPages) + ""String_Node_Str""+ Arrays.toString(mDocument.pages));
  }
  if (Arrays.equals(mDocument.pages,mRequestedPages)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,ALL_PAGES_ARRAY);
  }
 else   if (Arrays.equals(mDocument.pages,ALL_PAGES_ARRAY)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mRequestedPages);
  }
 else   if (PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    final int offset=mDocument.pages[0].getStart() - pages[0].getStart();
    PageRange[] offsetPages=Arrays.copyOf(mDocument.pages,mDocument.pages.length);
    PageRangeUtils.offsetStart(offsetPages,offset);
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,offsetPages);
  }
 else   if (Arrays.equals(mRequestedPages,ALL_PAGES_ARRAY) && mDocument.pages.length == 1 && mDocument.pages[0].getStart() == 0 && mDocument.pages[0].getEnd() == mDocument.info.getPageCount() - 1) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mDocument.pages);
  }
 else {
    mControllerState=CONTROLLER_STATE_FAILED;
    Log.e(LOG_TAG,""String_Node_Str"");
    PrintJobConfigActivity.this.finish();
  }
  if (mEditor.isDone()) {
    if (mEditor.isPrintingToPdf()) {
      PrintJobInfo printJob=PrintSpoolerService.peekInstance().getPrintJobInfo(mPrintJobId,PrintManager.APP_ID_ANY);
      Intent intent=new Intent(Intent.ACTION_CREATE_DOCUMENT);
      intent.setType(""String_Node_Str"");
      intent.putExtra(Intent.EXTRA_TITLE,printJob.getLabel());
      startActivityForResult(intent,ACTIVITY_REQUEST_CREATE_FILE);
    }
 else {
      PrintJobConfigActivity.this.finish();
    }
  }
}","private void handleOnWriteFinished(PageRange[] pages,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_WRITE_COMPLETED;
  File file=PrintSpoolerService.peekInstance().generateFileForPrintJob(mPrintJobId);
  mDocument.info.setDataSize(file.length());
  mDocument.pages=PageRangeUtils.normalize(pages);
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + Arrays.toString(mRequestedPages) + ""String_Node_Str""+ Arrays.toString(mDocument.pages));
  }
  if (Arrays.equals(mDocument.pages,mRequestedPages)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,ALL_PAGES_ARRAY);
  }
 else   if (Arrays.equals(mDocument.pages,ALL_PAGES_ARRAY)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mRequestedPages);
  }
 else   if (PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    final int offset=mDocument.pages[0].getStart() - pages[0].getStart();
    PageRange[] offsetPages=Arrays.copyOf(mDocument.pages,mDocument.pages.length);
    PageRangeUtils.offsetStart(offsetPages,offset);
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,offsetPages);
  }
 else   if (Arrays.equals(mRequestedPages,ALL_PAGES_ARRAY) && mDocument.pages.length == 1 && mDocument.pages[0].getStart() == 0 && mDocument.pages[0].getEnd() == mDocument.info.getPageCount() - 1) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mDocument.pages);
  }
 else {
    mControllerState=CONTROLLER_STATE_FAILED;
    Log.e(LOG_TAG,""String_Node_Str"");
    PrintJobConfigActivity.this.finish();
  }
  if (mEditor.isDone()) {
    requestCreatePdfFileOrFinish();
  }
}"
1610,"public void addCurrentPrinterToHistory(){
  PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
  if (printer != null) {
    FusedPrintersProvider printersLoader=(FusedPrintersProvider)(Loader<?>)getLoaderManager().getLoader(LOADER_ID_PRINTERS_LOADER);
    if (printersLoader != null) {
      printersLoader.addHistoricalPrinter(printer);
    }
  }
}","public void addCurrentPrinterToHistory(){
  PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
  PrinterId fakePdfPritnerId=mDestinationSpinnerAdapter.mFakePdfPrinter.getId();
  if (printer != null && !printer.getId().equals(fakePdfPritnerId)) {
    FusedPrintersProvider printersLoader=(FusedPrintersProvider)(Loader<?>)getLoaderManager().getLoader(LOADER_ID_PRINTERS_LOADER);
    if (printersLoader != null) {
      printersLoader.addHistoricalPrinter(printer);
    }
  }
}"
1611,"private void handleOnLayoutFinished(PrintDocumentInfo info,boolean layoutChanged,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_LAYOUT_COMPLETED;
  final boolean infoChanged=!info.equals(mDocument.info);
  if (infoChanged) {
    mDocument.info=info;
    PrintSpoolerService.peekInstance().setPrintJobPrintDocumentInfoNoPersistence(mPrintJobId,info);
  }
  if (infoChanged || layoutChanged) {
    mDocument.pages=null;
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,null);
  }
  mRequestedPages=mEditor.getRequestedPages();
  if (mRequestedPages == null) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!infoChanged && !layoutChanged && PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!LIVE_PREVIEW_SUPPORTED && !mEditor.isPreviewConfirmed() && mMetadata.getBoolean(PrintDocumentAdapter.METADATA_KEY_PRINT_PREVIEW)) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mEditor.updateUi();
  mControllerState=CONTROLLER_STATE_WRITE_STARTED;
  mRemotePrintAdapter.write(mRequestedPages,mWriteResultCallback,mRequestCounter.incrementAndGet());
}","private void handleOnLayoutFinished(PrintDocumentInfo info,boolean layoutChanged,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_LAYOUT_COMPLETED;
  final boolean infoChanged=!info.equals(mDocument.info);
  if (infoChanged) {
    mDocument.info=info;
    PrintSpoolerService.peekInstance().setPrintJobPrintDocumentInfoNoPersistence(mPrintJobId,info);
  }
  if (infoChanged || layoutChanged) {
    mDocument.pages=null;
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,null);
  }
  mRequestedPages=mEditor.getRequestedPages();
  if (mRequestedPages == null) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!infoChanged && !layoutChanged && PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    if (mEditor.isDone()) {
      requestCreatePdfFileOrFinish();
    }
    return;
  }
  mEditor.updateUi();
  mControllerState=CONTROLLER_STATE_WRITE_STARTED;
  mRemotePrintAdapter.write(mRequestedPages,mWriteResultCallback,mRequestCounter.incrementAndGet());
}"
1612,"public boolean updateUi(){
  if (mCurrentUi != UI_EDITING_PRINT_JOB) {
    return false;
  }
  if (isPrintConfirmed() || isPreviewConfirmed() || isCancelled()) {
    mDestinationSpinner.setEnabled(false);
    mCopiesEditText.setEnabled(false);
    mMediaSizeSpinner.setEnabled(false);
    mColorModeSpinner.setEnabled(false);
    mOrientationSpinner.setEnabled(false);
    mRangeOptionsSpinner.setEnabled(false);
    mPageRangeEditText.setEnabled(false);
    mPrintButton.setEnabled(false);
    return false;
  }
  boolean allOptionsEnabled=false;
  final int selectedIndex=mDestinationSpinner.getSelectedItemPosition();
  if (selectedIndex >= 0) {
    Object item=mDestinationSpinnerAdapter.getItem(selectedIndex);
    if (item instanceof PrinterInfo) {
      PrinterInfo printer=(PrinterInfo)item;
      if (printer.getCapabilities() != null) {
        allOptionsEnabled=true;
      }
    }
  }
  if (!allOptionsEnabled) {
    String minCopiesString=String.valueOf(MIN_COPIES);
    if (!TextUtils.equals(mCopiesEditText.getText(),minCopiesString)) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(minCopiesString);
    }
    mCopiesEditText.setEnabled(false);
    if (mMediaSizeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextMediaSizeChange=true;
      mMediaSizeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mMediaSizeSpinner.setEnabled(false);
    if (mColorModeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextColorModeChange=true;
      mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mColorModeSpinner.setEnabled(false);
    if (mOrientationSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextOrientationChange=true;
      mOrientationSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mOrientationSpinner.setEnabled(false);
    if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextRangeOptionChange=true;
      mRangeOptionsSpinner.setSelection(0);
    }
    mRangeOptionsSpinner.setEnabled(false);
    mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
    if (!TextUtils.equals(mPageRangeEditText.getText(),""String_Node_Str"")) {
      mIgnoreNextRangeChange=true;
      mPageRangeEditText.setText(""String_Node_Str"");
    }
    mPageRangeEditText.setEnabled(false);
    mPageRangeEditText.setVisibility(View.INVISIBLE);
    mPageRangeTitle.setVisibility(View.INVISIBLE);
    mPrintButton.setEnabled(false);
    return false;
  }
 else {
    boolean someAttributeSelectionChanged=false;
    PrintAttributes defaultAttributes=mTempPrintAttributes;
    PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
    PrinterCapabilitiesInfo capabilities=printer.getCapabilities();
    printer.getCapabilities().getDefaults(defaultAttributes);
    List<MediaSize> mediaSizes=capabilities.getMediaSizes();
    boolean mediaSizesChanged=false;
    final int mediaSizeCount=mediaSizes.size();
    if (mediaSizeCount != mMediaSizeSpinnerAdapter.getCount()) {
      mediaSizesChanged=true;
    }
 else {
      for (int i=0; i < mediaSizeCount; i++) {
        if (!mediaSizes.get(i).equals(mMediaSizeSpinnerAdapter.getItem(i).value)) {
          mediaSizesChanged=true;
          break;
        }
      }
    }
    if (mediaSizesChanged) {
      int oldMediaSizeNewIndex=AdapterView.INVALID_POSITION;
      MediaSize oldMediaSize=mCurrPrintAttributes.getMediaSize();
      mMediaSizeSpinnerAdapter.clear();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize mediaSize=mediaSizes.get(i);
        if (mediaSize.equals(oldMediaSize)) {
          oldMediaSizeNewIndex=i;
        }
        mMediaSizeSpinnerAdapter.add(new SpinnerItem<MediaSize>(mediaSize,mediaSize.getLabel(getPackageManager())));
      }
      if (mediaSizeCount <= 0) {
        mMediaSizeSpinner.setEnabled(false);
        someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(AdapterView.INVALID_POSITION);
      }
 else {
        mMediaSizeSpinner.setEnabled(true);
        if (oldMediaSizeNewIndex != AdapterView.INVALID_POSITION) {
          setMediaSizeSpinnerSelectionNoCallback(oldMediaSizeNewIndex);
        }
 else {
          final int mediaSizeIndex=Math.max(mediaSizes.indexOf(defaultAttributes.getMediaSize()),0);
          someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(mediaSizeIndex);
        }
      }
    }
    mMediaSizeSpinner.setEnabled(true);
    final int colorModes=capabilities.getColorModes();
    boolean colorModesChanged=false;
    if (Integer.bitCount(colorModes) != mColorModeSpinnerAdapter.getCount()) {
      colorModesChanged=true;
    }
 else {
      int remainingColorModes=colorModes;
      int adapterIndex=0;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        remainingColorModes&=~colorMode;
        if (colorMode != mColorModeSpinnerAdapter.getItem(adapterIndex).value) {
          colorModesChanged=true;
          break;
        }
        adapterIndex++;
      }
    }
    if (colorModesChanged) {
      int oldColorModeNewIndex=AdapterView.INVALID_POSITION;
      final int oldColorMode=mCurrPrintAttributes.getColorMode();
      mColorModeSpinnerAdapter.clear();
      String[] colorModeLabels=getResources().getStringArray(R.array.color_mode_labels);
      int remainingColorModes=colorModes;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        if (colorMode == oldColorMode) {
          oldColorModeNewIndex=colorBitOffset;
        }
        remainingColorModes&=~colorMode;
        mColorModeSpinnerAdapter.add(new SpinnerItem<Integer>(colorMode,colorModeLabels[colorBitOffset]));
      }
      final int colorModeCount=Integer.bitCount(colorModes);
      if (colorModeCount <= 0) {
        mColorModeSpinner.setEnabled(false);
        mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
      }
 else {
        mColorModeSpinner.setEnabled(true);
        if (oldColorModeNewIndex != AdapterView.INVALID_POSITION) {
          setColorModeSpinnerSelectionNoCallback(oldColorModeNewIndex);
        }
 else {
          final int selectedColorModeIndex=Integer.numberOfTrailingZeros((colorModes & defaultAttributes.getColorMode()));
          someAttributeSelectionChanged=setColorModeSpinnerSelectionNoCallback(selectedColorModeIndex);
        }
      }
    }
    mColorModeSpinner.setEnabled(true);
    mOrientationSpinner.setEnabled(true);
    PrintDocumentInfo info=mDocument.info;
    if (info != null && (info.getPageCount() > 0 || info.getPageCount() == PrintDocumentInfo.PAGE_COUNT_UNKNOWN)) {
      if (info.getPageCount() == 1) {
        mRangeOptionsSpinner.setEnabled(false);
      }
 else {
        mRangeOptionsSpinner.setEnabled(true);
        if (mRangeOptionsSpinner.getSelectedItemPosition() > 0) {
          if (!mPageRangeEditText.isEnabled()) {
            mPageRangeEditText.setEnabled(true);
            mPageRangeEditText.setVisibility(View.VISIBLE);
            mPageRangeTitle.setVisibility(View.VISIBLE);
            mPageRangeEditText.requestFocus();
            InputMethodManager imm=(InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
            imm.showSoftInput(mPageRangeEditText,0);
          }
        }
 else {
          mPageRangeEditText.setEnabled(false);
          mPageRangeEditText.setVisibility(View.INVISIBLE);
          mPageRangeTitle.setVisibility(View.INVISIBLE);
        }
      }
      final int pageCount=mDocument.info.getPageCount();
      mRangeOptionsTitle.setText(getString(R.string.label_pages,(pageCount == PrintDocumentInfo.PAGE_COUNT_UNKNOWN) ? getString(R.string.page_count_unknown) : String.valueOf(pageCount)));
    }
 else {
      if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
        mIgnoreNextRangeOptionChange=true;
        mRangeOptionsSpinner.setSelection(0);
      }
      mRangeOptionsSpinner.setEnabled(false);
      mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
      mPageRangeEditText.setEnabled(false);
      mPageRangeEditText.setVisibility(View.INVISIBLE);
      mPageRangeTitle.setVisibility(View.INVISIBLE);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      String newText=getString(R.string.print_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.print_button);
      }
    }
 else {
      String newText=getString(R.string.save_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.save_button);
      }
    }
    if ((mRangeOptionsSpinner.getSelectedItemPosition() == 1 && (TextUtils.isEmpty(mPageRangeEditText.getText()) || hasErrors())) || (mRangeOptionsSpinner.getSelectedItemPosition() == 0 && (!mController.hasPerformedLayout() || hasErrors()))) {
      mPrintButton.setEnabled(false);
    }
 else {
      mPrintButton.setEnabled(true);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      mCopiesEditText.setEnabled(true);
    }
 else {
      mCopiesEditText.setEnabled(false);
    }
    if (mCopiesEditText.getError() == null && TextUtils.isEmpty(mCopiesEditText.getText())) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(String.valueOf(MIN_COPIES));
      mCopiesEditText.selectAll();
      mCopiesEditText.requestFocus();
    }
    return someAttributeSelectionChanged;
  }
}","public boolean updateUi(){
  if (mCurrentUi != UI_EDITING_PRINT_JOB) {
    return false;
  }
  if (isPrintConfirmed() || isCancelled()) {
    mDestinationSpinner.setEnabled(false);
    mCopiesEditText.setEnabled(false);
    mMediaSizeSpinner.setEnabled(false);
    mColorModeSpinner.setEnabled(false);
    mOrientationSpinner.setEnabled(false);
    mRangeOptionsSpinner.setEnabled(false);
    mPageRangeEditText.setEnabled(false);
    mPrintButton.setEnabled(false);
    return false;
  }
  boolean allOptionsEnabled=false;
  final int selectedIndex=mDestinationSpinner.getSelectedItemPosition();
  if (selectedIndex >= 0) {
    Object item=mDestinationSpinnerAdapter.getItem(selectedIndex);
    if (item instanceof PrinterInfo) {
      PrinterInfo printer=(PrinterInfo)item;
      if (printer.getCapabilities() != null) {
        allOptionsEnabled=true;
      }
    }
  }
  if (!allOptionsEnabled) {
    String minCopiesString=String.valueOf(MIN_COPIES);
    if (!TextUtils.equals(mCopiesEditText.getText(),minCopiesString)) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(minCopiesString);
    }
    mCopiesEditText.setEnabled(false);
    if (mMediaSizeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextMediaSizeChange=true;
      mMediaSizeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mMediaSizeSpinner.setEnabled(false);
    if (mColorModeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextColorModeChange=true;
      mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mColorModeSpinner.setEnabled(false);
    if (mOrientationSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextOrientationChange=true;
      mOrientationSpinner.setSelection(0);
    }
    mOrientationSpinner.setEnabled(false);
    if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextRangeOptionChange=true;
      mRangeOptionsSpinner.setSelection(0);
    }
    mRangeOptionsSpinner.setEnabled(false);
    mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
    if (!TextUtils.equals(mPageRangeEditText.getText(),""String_Node_Str"")) {
      mIgnoreNextRangeChange=true;
      mPageRangeEditText.setText(""String_Node_Str"");
    }
    mPageRangeEditText.setEnabled(false);
    mPageRangeEditText.setVisibility(View.INVISIBLE);
    mPageRangeTitle.setVisibility(View.INVISIBLE);
    mPrintButton.setEnabled(false);
    return false;
  }
 else {
    boolean someAttributeSelectionChanged=false;
    PrintAttributes defaultAttributes=mTempPrintAttributes;
    PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
    PrinterCapabilitiesInfo capabilities=printer.getCapabilities();
    printer.getCapabilities().getDefaults(defaultAttributes);
    List<MediaSize> mediaSizes=capabilities.getMediaSizes();
    boolean mediaSizesChanged=false;
    final int mediaSizeCount=mediaSizes.size();
    if (mediaSizeCount != mMediaSizeSpinnerAdapter.getCount()) {
      mediaSizesChanged=true;
    }
 else {
      for (int i=0; i < mediaSizeCount; i++) {
        if (!mediaSizes.get(i).equals(mMediaSizeSpinnerAdapter.getItem(i).value)) {
          mediaSizesChanged=true;
          break;
        }
      }
    }
    if (mediaSizesChanged) {
      int oldMediaSizeNewIndex=AdapterView.INVALID_POSITION;
      MediaSize oldMediaSize=mCurrPrintAttributes.getMediaSize();
      mMediaSizeSpinnerAdapter.clear();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize mediaSize=mediaSizes.get(i);
        if (mediaSize.equals(oldMediaSize)) {
          oldMediaSizeNewIndex=i;
        }
        mMediaSizeSpinnerAdapter.add(new SpinnerItem<MediaSize>(mediaSize,mediaSize.getLabel(getPackageManager())));
      }
      if (mediaSizeCount <= 0) {
        mMediaSizeSpinner.setEnabled(false);
        someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(AdapterView.INVALID_POSITION);
      }
 else {
        mMediaSizeSpinner.setEnabled(true);
        if (oldMediaSizeNewIndex != AdapterView.INVALID_POSITION) {
          setMediaSizeSpinnerSelectionNoCallback(oldMediaSizeNewIndex);
        }
 else {
          final int mediaSizeIndex=Math.max(mediaSizes.indexOf(defaultAttributes.getMediaSize()),0);
          someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(mediaSizeIndex);
        }
      }
    }
    mMediaSizeSpinner.setEnabled(true);
    final int colorModes=capabilities.getColorModes();
    boolean colorModesChanged=false;
    if (Integer.bitCount(colorModes) != mColorModeSpinnerAdapter.getCount()) {
      colorModesChanged=true;
    }
 else {
      int remainingColorModes=colorModes;
      int adapterIndex=0;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        remainingColorModes&=~colorMode;
        if (colorMode != mColorModeSpinnerAdapter.getItem(adapterIndex).value) {
          colorModesChanged=true;
          break;
        }
        adapterIndex++;
      }
    }
    if (colorModesChanged) {
      int oldColorModeNewIndex=AdapterView.INVALID_POSITION;
      final int oldColorMode=mCurrPrintAttributes.getColorMode();
      mColorModeSpinnerAdapter.clear();
      String[] colorModeLabels=getResources().getStringArray(R.array.color_mode_labels);
      int remainingColorModes=colorModes;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        if (colorMode == oldColorMode) {
          oldColorModeNewIndex=colorBitOffset;
        }
        remainingColorModes&=~colorMode;
        mColorModeSpinnerAdapter.add(new SpinnerItem<Integer>(colorMode,colorModeLabels[colorBitOffset]));
      }
      final int colorModeCount=Integer.bitCount(colorModes);
      if (colorModeCount <= 0) {
        mColorModeSpinner.setEnabled(false);
        mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
      }
 else {
        mColorModeSpinner.setEnabled(true);
        if (oldColorModeNewIndex != AdapterView.INVALID_POSITION) {
          setColorModeSpinnerSelectionNoCallback(oldColorModeNewIndex);
        }
 else {
          final int selectedColorModeIndex=Integer.numberOfTrailingZeros((colorModes & defaultAttributes.getColorMode()));
          someAttributeSelectionChanged=setColorModeSpinnerSelectionNoCallback(selectedColorModeIndex);
        }
      }
    }
    mColorModeSpinner.setEnabled(true);
    mOrientationSpinner.setEnabled(true);
    PrintDocumentInfo info=mDocument.info;
    if (info != null && (info.getPageCount() > 0 || info.getPageCount() == PrintDocumentInfo.PAGE_COUNT_UNKNOWN)) {
      if (info.getPageCount() == 1) {
        mRangeOptionsSpinner.setEnabled(false);
      }
 else {
        mRangeOptionsSpinner.setEnabled(true);
        if (mRangeOptionsSpinner.getSelectedItemPosition() > 0) {
          if (!mPageRangeEditText.isEnabled()) {
            mPageRangeEditText.setEnabled(true);
            mPageRangeEditText.setVisibility(View.VISIBLE);
            mPageRangeTitle.setVisibility(View.VISIBLE);
            mPageRangeEditText.requestFocus();
            InputMethodManager imm=(InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
            imm.showSoftInput(mPageRangeEditText,0);
          }
        }
 else {
          mPageRangeEditText.setEnabled(false);
          mPageRangeEditText.setVisibility(View.INVISIBLE);
          mPageRangeTitle.setVisibility(View.INVISIBLE);
        }
      }
      final int pageCount=mDocument.info.getPageCount();
      mRangeOptionsTitle.setText(getString(R.string.label_pages,(pageCount == PrintDocumentInfo.PAGE_COUNT_UNKNOWN) ? getString(R.string.page_count_unknown) : String.valueOf(pageCount)));
    }
 else {
      if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
        mIgnoreNextRangeOptionChange=true;
        mRangeOptionsSpinner.setSelection(0);
      }
      mRangeOptionsSpinner.setEnabled(false);
      mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
      mPageRangeEditText.setEnabled(false);
      mPageRangeEditText.setVisibility(View.INVISIBLE);
      mPageRangeTitle.setVisibility(View.INVISIBLE);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      String newText=getString(R.string.print_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.print_button);
      }
    }
 else {
      String newText=getString(R.string.save_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.save_button);
      }
    }
    if ((mRangeOptionsSpinner.getSelectedItemPosition() == 1 && (TextUtils.isEmpty(mPageRangeEditText.getText()) || hasErrors())) || (mRangeOptionsSpinner.getSelectedItemPosition() == 0 && (!mController.hasPerformedLayout() || hasErrors()))) {
      mPrintButton.setEnabled(false);
    }
 else {
      mPrintButton.setEnabled(true);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      mCopiesEditText.setEnabled(true);
    }
 else {
      mCopiesEditText.setEnabled(false);
    }
    if (mCopiesEditText.getError() == null && TextUtils.isEmpty(mCopiesEditText.getText())) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(String.valueOf(MIN_COPIES));
      mCopiesEditText.selectAll();
      mCopiesEditText.requestFocus();
    }
    return someAttributeSelectionChanged;
  }
}"
1613,"public boolean isDone(){
  return isPrintConfirmed() || isPreviewConfirmed() || isCancelled();
}","public boolean isDone(){
  return isPrintConfirmed() || isCancelled();
}"
1614,"/** 
 * Returns a new media size in a portrait orientation which is the height is the greater dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asPortrait(){
  return new MediaSize(mId,mPackageName,mLabel,Math.min(mWidthMils,mHeightMils),Math.max(mWidthMils,mHeightMils),mLabelResId);
}","/** 
 * Returns a new media size in a portrait orientation which is the height is the greater dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asPortrait(){
  return new MediaSize(mId,mLabel,mPackageName,Math.min(mWidthMils,mHeightMils),Math.max(mWidthMils,mHeightMils),mLabelResId);
}"
1615,"/** 
 * Returns a new media size in a landscape orientation which is the height is the lesser dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asLandscape(){
  return new MediaSize(mId,mLabel,Math.max(mWidthMils,mHeightMils),Math.min(mWidthMils,mHeightMils),mLabelResId);
}","/** 
 * Returns a new media size in a landscape orientation which is the height is the lesser dimension.
 * @return New instance in landscape orientation.
 */
public MediaSize asLandscape(){
  return new MediaSize(mId,mLabel,mPackageName,Math.max(mWidthMils,mHeightMils),Math.min(mWidthMils,mHeightMils),mLabelResId);
}"
1616,"@SuppressWarnings(""String_Node_Str"") public void addPrinterAndWritePrinterHistory(PrinterInfo printer){
  if (mHistoricalPrinters.size() >= MAX_HISTORY_LENGTH) {
    mHistoricalPrinters.remove(0);
  }
  mHistoricalPrinters.add(printer);
  mWriteTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,new ArrayList<PrinterInfo>(mHistoricalPrinters));
}","@SuppressWarnings(""String_Node_Str"") public void addPrinterAndWritePrinterHistory(PrinterInfo printer){
  if (mHistoricalPrinters.size() >= MAX_HISTORY_LENGTH) {
    mHistoricalPrinters.remove(0);
  }
  mHistoricalPrinters.add(printer);
  new WriteTask().executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,new ArrayList<PrinterInfo>(mHistoricalPrinters));
}"
1617,"public boolean stopReadPrinterHistory(){
  return mReadTask.cancel(true);
}","public boolean stopReadPrinterHistory(){
  final boolean cancelled=mReadTask.cancel(true);
  mReadTask=null;
  return cancelled;
}"
1618,"public void readPrinterHistory(){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
  mReadHistoryInProgress=true;
  mReadTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,(Void[])null);
}","public void readPrinterHistory(){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
  mReadHistoryInProgress=true;
  mReadTask=new ReadTask();
  mReadTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,(Void[])null);
}"
1619,"@Override protected void onPostExecute(List<PrinterInfo> printers){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + FusedPrintersProvider.this.hashCode());
  }
  mHistoricalPrinters=printers;
  mFavoritePrinters.addAll(computeFavoritePrinters(printers));
  mReadHistoryInProgress=false;
  mReadHistoryCompleted=true;
  computeAndDeliverResult();
  loadInternal();
}","@Override protected void onPostExecute(List<PrinterInfo> printers){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + FusedPrintersProvider.this.hashCode());
  }
  mHistoricalPrinters=printers;
  mFavoritePrinters.addAll(computeFavoritePrinters(printers));
  mReadHistoryInProgress=false;
  mReadHistoryCompleted=true;
  computeAndDeliverResult();
  loadInternal();
  mReadTask=null;
}"
1620,"private void updateUiForNewPrinterCapabilities(){
  if (!mMediaSizeSpinnerAdapter.isEmpty()) {
    mIgnoreNextMediaSizeChange=true;
    mMediaSizeSpinnerAdapter.clear();
  }
  if (!mColorModeSpinnerAdapter.isEmpty()) {
    mIgnoreNextColorModeChange=true;
    mColorModeSpinnerAdapter.clear();
  }
  if (!mOrientationSpinnerAdapter.isEmpty()) {
    mIgnoreNextOrientationChange=true;
    mOrientationSpinner.setSelection(0);
  }
  if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextRangeOptionChange=true;
    mRangeOptionsSpinner.setSelection(0);
  }
  if (!TextUtils.isEmpty(mCopiesEditText.getText())) {
    mIgnoreNextCopiesChange=true;
    mCopiesEditText.setText(MIN_COPIES_STRING);
  }
  updateUi();
}","private void updateUiForNewPrinterCapabilities(){
  if (!mMediaSizeSpinnerAdapter.isEmpty()) {
    mIgnoreNextMediaSizeChange=true;
    mMediaSizeSpinnerAdapter.clear();
  }
  if (!mColorModeSpinnerAdapter.isEmpty()) {
    mIgnoreNextColorModeChange=true;
    mColorModeSpinnerAdapter.clear();
  }
  if (mOrientationSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextOrientationChange=true;
    mOrientationSpinner.setSelection(0);
  }
  if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
    mIgnoreNextRangeOptionChange=true;
    mRangeOptionsSpinner.setSelection(0);
  }
  if (!TextUtils.isEmpty(mCopiesEditText.getText())) {
    mIgnoreNextCopiesChange=true;
    mCopiesEditText.setText(MIN_COPIES_STRING);
  }
  updateUi();
}"
1621,"public boolean onTouchEvent(MotionEvent event){
  if (!mEditor.isPrintConfirmed() && !mEditor.isPreviewConfirmed() && mEditor.shouldCloseOnTouch(event)) {
    if (!mController.isWorking()) {
      PrintJobConfigActivity.this.finish();
    }
    mEditor.cancel();
    return true;
  }
  return super.onTouchEvent(event);
}","public boolean onTouchEvent(MotionEvent event){
  if (!mEditor.isPrintConfirmed() && mEditor.shouldCloseOnTouch(event)) {
    if (!mController.isWorking()) {
      PrintJobConfigActivity.this.finish();
    }
    mEditor.cancel();
    return true;
  }
  return super.onTouchEvent(event);
}"
1622,"private void handleOnWriteFinished(PageRange[] pages,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_WRITE_COMPLETED;
  File file=PrintSpoolerService.peekInstance().generateFileForPrintJob(mPrintJobId);
  mDocument.info.setDataSize(file.length());
  mDocument.pages=PageRangeUtils.normalize(pages);
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + Arrays.toString(mRequestedPages) + ""String_Node_Str""+ Arrays.toString(mDocument.pages));
  }
  if (Arrays.equals(mDocument.pages,mRequestedPages)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,ALL_PAGES_ARRAY);
  }
 else   if (Arrays.equals(mDocument.pages,ALL_PAGES_ARRAY)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mRequestedPages);
  }
 else   if (PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    final int offset=mDocument.pages[0].getStart() - pages[0].getStart();
    PageRange[] offsetPages=Arrays.copyOf(mDocument.pages,mDocument.pages.length);
    PageRangeUtils.offsetStart(offsetPages,offset);
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,offsetPages);
  }
 else   if (Arrays.equals(mRequestedPages,ALL_PAGES_ARRAY) && mDocument.pages.length == 1 && mDocument.pages[0].getStart() == 0 && mDocument.pages[0].getEnd() == mDocument.info.getPageCount() - 1) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mDocument.pages);
  }
 else {
    mControllerState=CONTROLLER_STATE_FAILED;
    Log.e(LOG_TAG,""String_Node_Str"");
    PrintJobConfigActivity.this.finish();
  }
  if (mEditor.isDone()) {
    if (mEditor.isPrintingToPdf()) {
      PrintJobInfo printJob=PrintSpoolerService.peekInstance().getPrintJobInfo(mPrintJobId,PrintManager.APP_ID_ANY);
      Intent intent=new Intent(Intent.ACTION_CREATE_DOCUMENT);
      intent.setType(""String_Node_Str"");
      intent.putExtra(Intent.EXTRA_TITLE,printJob.getLabel());
      startActivityForResult(intent,ACTIVITY_REQUEST_CREATE_FILE);
    }
 else {
      PrintJobConfigActivity.this.finish();
    }
  }
}","private void handleOnWriteFinished(PageRange[] pages,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_WRITE_COMPLETED;
  File file=PrintSpoolerService.peekInstance().generateFileForPrintJob(mPrintJobId);
  mDocument.info.setDataSize(file.length());
  mDocument.pages=PageRangeUtils.normalize(pages);
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + Arrays.toString(mRequestedPages) + ""String_Node_Str""+ Arrays.toString(mDocument.pages));
  }
  if (Arrays.equals(mDocument.pages,mRequestedPages)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,ALL_PAGES_ARRAY);
  }
 else   if (Arrays.equals(mDocument.pages,ALL_PAGES_ARRAY)) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mRequestedPages);
  }
 else   if (PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    final int offset=mDocument.pages[0].getStart() - pages[0].getStart();
    PageRange[] offsetPages=Arrays.copyOf(mDocument.pages,mDocument.pages.length);
    PageRangeUtils.offsetStart(offsetPages,offset);
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,offsetPages);
  }
 else   if (Arrays.equals(mRequestedPages,ALL_PAGES_ARRAY) && mDocument.pages.length == 1 && mDocument.pages[0].getStart() == 0 && mDocument.pages[0].getEnd() == mDocument.info.getPageCount() - 1) {
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,mDocument.pages);
  }
 else {
    mControllerState=CONTROLLER_STATE_FAILED;
    Log.e(LOG_TAG,""String_Node_Str"");
    PrintJobConfigActivity.this.finish();
  }
  if (mEditor.isDone()) {
    requestCreatePdfFileOrFinish();
  }
}"
1623,"public void addCurrentPrinterToHistory(){
  PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
  if (printer != null) {
    FusedPrintersProvider printersLoader=(FusedPrintersProvider)(Loader<?>)getLoaderManager().getLoader(LOADER_ID_PRINTERS_LOADER);
    if (printersLoader != null) {
      printersLoader.addHistoricalPrinter(printer);
    }
  }
}","public void addCurrentPrinterToHistory(){
  PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
  PrinterId fakePdfPritnerId=mDestinationSpinnerAdapter.mFakePdfPrinter.getId();
  if (printer != null && !printer.getId().equals(fakePdfPritnerId)) {
    FusedPrintersProvider printersLoader=(FusedPrintersProvider)(Loader<?>)getLoaderManager().getLoader(LOADER_ID_PRINTERS_LOADER);
    if (printersLoader != null) {
      printersLoader.addHistoricalPrinter(printer);
    }
  }
}"
1624,"private void handleOnLayoutFinished(PrintDocumentInfo info,boolean layoutChanged,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_LAYOUT_COMPLETED;
  final boolean infoChanged=!info.equals(mDocument.info);
  if (infoChanged) {
    mDocument.info=info;
    PrintSpoolerService.peekInstance().setPrintJobPrintDocumentInfoNoPersistence(mPrintJobId,info);
  }
  if (infoChanged || layoutChanged) {
    mDocument.pages=null;
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,null);
  }
  mRequestedPages=mEditor.getRequestedPages();
  if (mRequestedPages == null) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!infoChanged && !layoutChanged && PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!LIVE_PREVIEW_SUPPORTED && !mEditor.isPreviewConfirmed() && mMetadata.getBoolean(PrintDocumentAdapter.METADATA_KEY_PRINT_PREVIEW)) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mEditor.updateUi();
  mControllerState=CONTROLLER_STATE_WRITE_STARTED;
  mRemotePrintAdapter.write(mRequestedPages,mWriteResultCallback,mRequestCounter.incrementAndGet());
}","private void handleOnLayoutFinished(PrintDocumentInfo info,boolean layoutChanged,int sequence){
  if (mRequestCounter.get() != sequence) {
    return;
  }
  if (isCancelled()) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  mControllerState=CONTROLLER_STATE_LAYOUT_COMPLETED;
  final boolean infoChanged=!info.equals(mDocument.info);
  if (infoChanged) {
    mDocument.info=info;
    PrintSpoolerService.peekInstance().setPrintJobPrintDocumentInfoNoPersistence(mPrintJobId,info);
  }
  if (infoChanged || layoutChanged) {
    mDocument.pages=null;
    PrintSpoolerService.peekInstance().setPrintJobPagesNoPersistence(mPrintJobId,null);
  }
  mRequestedPages=mEditor.getRequestedPages();
  if (mRequestedPages == null) {
    mEditor.updateUi();
    if (mEditor.isDone()) {
      PrintJobConfigActivity.this.finish();
    }
    return;
  }
  if (!infoChanged && !layoutChanged && PageRangeUtils.contains(mDocument.pages,mRequestedPages)) {
    if (mEditor.isDone()) {
      requestCreatePdfFileOrFinish();
    }
    return;
  }
  mEditor.updateUi();
  mControllerState=CONTROLLER_STATE_WRITE_STARTED;
  mRemotePrintAdapter.write(mRequestedPages,mWriteResultCallback,mRequestCounter.incrementAndGet());
}"
1625,"public boolean updateUi(){
  if (mCurrentUi != UI_EDITING_PRINT_JOB) {
    return false;
  }
  if (isPrintConfirmed() || isPreviewConfirmed() || isCancelled()) {
    mDestinationSpinner.setEnabled(false);
    mCopiesEditText.setEnabled(false);
    mMediaSizeSpinner.setEnabled(false);
    mColorModeSpinner.setEnabled(false);
    mOrientationSpinner.setEnabled(false);
    mRangeOptionsSpinner.setEnabled(false);
    mPageRangeEditText.setEnabled(false);
    mPrintButton.setEnabled(false);
    return false;
  }
  boolean allOptionsEnabled=false;
  final int selectedIndex=mDestinationSpinner.getSelectedItemPosition();
  if (selectedIndex >= 0) {
    Object item=mDestinationSpinnerAdapter.getItem(selectedIndex);
    if (item instanceof PrinterInfo) {
      PrinterInfo printer=(PrinterInfo)item;
      if (printer.getCapabilities() != null) {
        allOptionsEnabled=true;
      }
    }
  }
  if (!allOptionsEnabled) {
    String minCopiesString=String.valueOf(MIN_COPIES);
    if (!TextUtils.equals(mCopiesEditText.getText(),minCopiesString)) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(minCopiesString);
    }
    mCopiesEditText.setEnabled(false);
    if (mMediaSizeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextMediaSizeChange=true;
      mMediaSizeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mMediaSizeSpinner.setEnabled(false);
    if (mColorModeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextColorModeChange=true;
      mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mColorModeSpinner.setEnabled(false);
    if (mOrientationSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextOrientationChange=true;
      mOrientationSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mOrientationSpinner.setEnabled(false);
    if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextRangeOptionChange=true;
      mRangeOptionsSpinner.setSelection(0);
    }
    mRangeOptionsSpinner.setEnabled(false);
    mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
    if (!TextUtils.equals(mPageRangeEditText.getText(),""String_Node_Str"")) {
      mIgnoreNextRangeChange=true;
      mPageRangeEditText.setText(""String_Node_Str"");
    }
    mPageRangeEditText.setEnabled(false);
    mPageRangeEditText.setVisibility(View.INVISIBLE);
    mPageRangeTitle.setVisibility(View.INVISIBLE);
    mPrintButton.setEnabled(false);
    return false;
  }
 else {
    boolean someAttributeSelectionChanged=false;
    PrintAttributes defaultAttributes=mTempPrintAttributes;
    PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
    PrinterCapabilitiesInfo capabilities=printer.getCapabilities();
    printer.getCapabilities().getDefaults(defaultAttributes);
    List<MediaSize> mediaSizes=capabilities.getMediaSizes();
    boolean mediaSizesChanged=false;
    final int mediaSizeCount=mediaSizes.size();
    if (mediaSizeCount != mMediaSizeSpinnerAdapter.getCount()) {
      mediaSizesChanged=true;
    }
 else {
      for (int i=0; i < mediaSizeCount; i++) {
        if (!mediaSizes.get(i).equals(mMediaSizeSpinnerAdapter.getItem(i).value)) {
          mediaSizesChanged=true;
          break;
        }
      }
    }
    if (mediaSizesChanged) {
      int oldMediaSizeNewIndex=AdapterView.INVALID_POSITION;
      MediaSize oldMediaSize=mCurrPrintAttributes.getMediaSize();
      mMediaSizeSpinnerAdapter.clear();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize mediaSize=mediaSizes.get(i);
        if (mediaSize.equals(oldMediaSize)) {
          oldMediaSizeNewIndex=i;
        }
        mMediaSizeSpinnerAdapter.add(new SpinnerItem<MediaSize>(mediaSize,mediaSize.getLabel(getPackageManager())));
      }
      if (mediaSizeCount <= 0) {
        mMediaSizeSpinner.setEnabled(false);
        someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(AdapterView.INVALID_POSITION);
      }
 else {
        mMediaSizeSpinner.setEnabled(true);
        if (oldMediaSizeNewIndex != AdapterView.INVALID_POSITION) {
          setMediaSizeSpinnerSelectionNoCallback(oldMediaSizeNewIndex);
        }
 else {
          final int mediaSizeIndex=Math.max(mediaSizes.indexOf(defaultAttributes.getMediaSize()),0);
          someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(mediaSizeIndex);
        }
      }
    }
    mMediaSizeSpinner.setEnabled(true);
    final int colorModes=capabilities.getColorModes();
    boolean colorModesChanged=false;
    if (Integer.bitCount(colorModes) != mColorModeSpinnerAdapter.getCount()) {
      colorModesChanged=true;
    }
 else {
      int remainingColorModes=colorModes;
      int adapterIndex=0;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        remainingColorModes&=~colorMode;
        if (colorMode != mColorModeSpinnerAdapter.getItem(adapterIndex).value) {
          colorModesChanged=true;
          break;
        }
        adapterIndex++;
      }
    }
    if (colorModesChanged) {
      int oldColorModeNewIndex=AdapterView.INVALID_POSITION;
      final int oldColorMode=mCurrPrintAttributes.getColorMode();
      mColorModeSpinnerAdapter.clear();
      String[] colorModeLabels=getResources().getStringArray(R.array.color_mode_labels);
      int remainingColorModes=colorModes;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        if (colorMode == oldColorMode) {
          oldColorModeNewIndex=colorBitOffset;
        }
        remainingColorModes&=~colorMode;
        mColorModeSpinnerAdapter.add(new SpinnerItem<Integer>(colorMode,colorModeLabels[colorBitOffset]));
      }
      final int colorModeCount=Integer.bitCount(colorModes);
      if (colorModeCount <= 0) {
        mColorModeSpinner.setEnabled(false);
        mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
      }
 else {
        mColorModeSpinner.setEnabled(true);
        if (oldColorModeNewIndex != AdapterView.INVALID_POSITION) {
          setColorModeSpinnerSelectionNoCallback(oldColorModeNewIndex);
        }
 else {
          final int selectedColorModeIndex=Integer.numberOfTrailingZeros((colorModes & defaultAttributes.getColorMode()));
          someAttributeSelectionChanged=setColorModeSpinnerSelectionNoCallback(selectedColorModeIndex);
        }
      }
    }
    mColorModeSpinner.setEnabled(true);
    mOrientationSpinner.setEnabled(true);
    PrintDocumentInfo info=mDocument.info;
    if (info != null && (info.getPageCount() > 0 || info.getPageCount() == PrintDocumentInfo.PAGE_COUNT_UNKNOWN)) {
      if (info.getPageCount() == 1) {
        mRangeOptionsSpinner.setEnabled(false);
      }
 else {
        mRangeOptionsSpinner.setEnabled(true);
        if (mRangeOptionsSpinner.getSelectedItemPosition() > 0) {
          if (!mPageRangeEditText.isEnabled()) {
            mPageRangeEditText.setEnabled(true);
            mPageRangeEditText.setVisibility(View.VISIBLE);
            mPageRangeTitle.setVisibility(View.VISIBLE);
            mPageRangeEditText.requestFocus();
            InputMethodManager imm=(InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
            imm.showSoftInput(mPageRangeEditText,0);
          }
        }
 else {
          mPageRangeEditText.setEnabled(false);
          mPageRangeEditText.setVisibility(View.INVISIBLE);
          mPageRangeTitle.setVisibility(View.INVISIBLE);
        }
      }
      final int pageCount=mDocument.info.getPageCount();
      mRangeOptionsTitle.setText(getString(R.string.label_pages,(pageCount == PrintDocumentInfo.PAGE_COUNT_UNKNOWN) ? getString(R.string.page_count_unknown) : String.valueOf(pageCount)));
    }
 else {
      if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
        mIgnoreNextRangeOptionChange=true;
        mRangeOptionsSpinner.setSelection(0);
      }
      mRangeOptionsSpinner.setEnabled(false);
      mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
      mPageRangeEditText.setEnabled(false);
      mPageRangeEditText.setVisibility(View.INVISIBLE);
      mPageRangeTitle.setVisibility(View.INVISIBLE);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      String newText=getString(R.string.print_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.print_button);
      }
    }
 else {
      String newText=getString(R.string.save_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.save_button);
      }
    }
    if ((mRangeOptionsSpinner.getSelectedItemPosition() == 1 && (TextUtils.isEmpty(mPageRangeEditText.getText()) || hasErrors())) || (mRangeOptionsSpinner.getSelectedItemPosition() == 0 && (!mController.hasPerformedLayout() || hasErrors()))) {
      mPrintButton.setEnabled(false);
    }
 else {
      mPrintButton.setEnabled(true);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      mCopiesEditText.setEnabled(true);
    }
 else {
      mCopiesEditText.setEnabled(false);
    }
    if (mCopiesEditText.getError() == null && TextUtils.isEmpty(mCopiesEditText.getText())) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(String.valueOf(MIN_COPIES));
      mCopiesEditText.selectAll();
      mCopiesEditText.requestFocus();
    }
    return someAttributeSelectionChanged;
  }
}","public boolean updateUi(){
  if (mCurrentUi != UI_EDITING_PRINT_JOB) {
    return false;
  }
  if (isPrintConfirmed() || isCancelled()) {
    mDestinationSpinner.setEnabled(false);
    mCopiesEditText.setEnabled(false);
    mMediaSizeSpinner.setEnabled(false);
    mColorModeSpinner.setEnabled(false);
    mOrientationSpinner.setEnabled(false);
    mRangeOptionsSpinner.setEnabled(false);
    mPageRangeEditText.setEnabled(false);
    mPrintButton.setEnabled(false);
    return false;
  }
  boolean allOptionsEnabled=false;
  final int selectedIndex=mDestinationSpinner.getSelectedItemPosition();
  if (selectedIndex >= 0) {
    Object item=mDestinationSpinnerAdapter.getItem(selectedIndex);
    if (item instanceof PrinterInfo) {
      PrinterInfo printer=(PrinterInfo)item;
      if (printer.getCapabilities() != null) {
        allOptionsEnabled=true;
      }
    }
  }
  if (!allOptionsEnabled) {
    String minCopiesString=String.valueOf(MIN_COPIES);
    if (!TextUtils.equals(mCopiesEditText.getText(),minCopiesString)) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(minCopiesString);
    }
    mCopiesEditText.setEnabled(false);
    if (mMediaSizeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextMediaSizeChange=true;
      mMediaSizeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mMediaSizeSpinner.setEnabled(false);
    if (mColorModeSpinner.getSelectedItemPosition() != AdapterView.INVALID_POSITION) {
      mIgnoreNextColorModeChange=true;
      mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
    }
    mColorModeSpinner.setEnabled(false);
    if (mOrientationSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextOrientationChange=true;
      mOrientationSpinner.setSelection(0);
    }
    mOrientationSpinner.setEnabled(false);
    if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
      mIgnoreNextRangeOptionChange=true;
      mRangeOptionsSpinner.setSelection(0);
    }
    mRangeOptionsSpinner.setEnabled(false);
    mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
    if (!TextUtils.equals(mPageRangeEditText.getText(),""String_Node_Str"")) {
      mIgnoreNextRangeChange=true;
      mPageRangeEditText.setText(""String_Node_Str"");
    }
    mPageRangeEditText.setEnabled(false);
    mPageRangeEditText.setVisibility(View.INVISIBLE);
    mPageRangeTitle.setVisibility(View.INVISIBLE);
    mPrintButton.setEnabled(false);
    return false;
  }
 else {
    boolean someAttributeSelectionChanged=false;
    PrintAttributes defaultAttributes=mTempPrintAttributes;
    PrinterInfo printer=(PrinterInfo)mDestinationSpinner.getSelectedItem();
    PrinterCapabilitiesInfo capabilities=printer.getCapabilities();
    printer.getCapabilities().getDefaults(defaultAttributes);
    List<MediaSize> mediaSizes=capabilities.getMediaSizes();
    boolean mediaSizesChanged=false;
    final int mediaSizeCount=mediaSizes.size();
    if (mediaSizeCount != mMediaSizeSpinnerAdapter.getCount()) {
      mediaSizesChanged=true;
    }
 else {
      for (int i=0; i < mediaSizeCount; i++) {
        if (!mediaSizes.get(i).equals(mMediaSizeSpinnerAdapter.getItem(i).value)) {
          mediaSizesChanged=true;
          break;
        }
      }
    }
    if (mediaSizesChanged) {
      int oldMediaSizeNewIndex=AdapterView.INVALID_POSITION;
      MediaSize oldMediaSize=mCurrPrintAttributes.getMediaSize();
      mMediaSizeSpinnerAdapter.clear();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize mediaSize=mediaSizes.get(i);
        if (mediaSize.equals(oldMediaSize)) {
          oldMediaSizeNewIndex=i;
        }
        mMediaSizeSpinnerAdapter.add(new SpinnerItem<MediaSize>(mediaSize,mediaSize.getLabel(getPackageManager())));
      }
      if (mediaSizeCount <= 0) {
        mMediaSizeSpinner.setEnabled(false);
        someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(AdapterView.INVALID_POSITION);
      }
 else {
        mMediaSizeSpinner.setEnabled(true);
        if (oldMediaSizeNewIndex != AdapterView.INVALID_POSITION) {
          setMediaSizeSpinnerSelectionNoCallback(oldMediaSizeNewIndex);
        }
 else {
          final int mediaSizeIndex=Math.max(mediaSizes.indexOf(defaultAttributes.getMediaSize()),0);
          someAttributeSelectionChanged=setMediaSizeSpinnerSelectionNoCallback(mediaSizeIndex);
        }
      }
    }
    mMediaSizeSpinner.setEnabled(true);
    final int colorModes=capabilities.getColorModes();
    boolean colorModesChanged=false;
    if (Integer.bitCount(colorModes) != mColorModeSpinnerAdapter.getCount()) {
      colorModesChanged=true;
    }
 else {
      int remainingColorModes=colorModes;
      int adapterIndex=0;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        remainingColorModes&=~colorMode;
        if (colorMode != mColorModeSpinnerAdapter.getItem(adapterIndex).value) {
          colorModesChanged=true;
          break;
        }
        adapterIndex++;
      }
    }
    if (colorModesChanged) {
      int oldColorModeNewIndex=AdapterView.INVALID_POSITION;
      final int oldColorMode=mCurrPrintAttributes.getColorMode();
      mColorModeSpinnerAdapter.clear();
      String[] colorModeLabels=getResources().getStringArray(R.array.color_mode_labels);
      int remainingColorModes=colorModes;
      while (remainingColorModes != 0) {
        final int colorBitOffset=Integer.numberOfTrailingZeros(remainingColorModes);
        final int colorMode=1 << colorBitOffset;
        if (colorMode == oldColorMode) {
          oldColorModeNewIndex=colorBitOffset;
        }
        remainingColorModes&=~colorMode;
        mColorModeSpinnerAdapter.add(new SpinnerItem<Integer>(colorMode,colorModeLabels[colorBitOffset]));
      }
      final int colorModeCount=Integer.bitCount(colorModes);
      if (colorModeCount <= 0) {
        mColorModeSpinner.setEnabled(false);
        mColorModeSpinner.setSelection(AdapterView.INVALID_POSITION);
      }
 else {
        mColorModeSpinner.setEnabled(true);
        if (oldColorModeNewIndex != AdapterView.INVALID_POSITION) {
          setColorModeSpinnerSelectionNoCallback(oldColorModeNewIndex);
        }
 else {
          final int selectedColorModeIndex=Integer.numberOfTrailingZeros((colorModes & defaultAttributes.getColorMode()));
          someAttributeSelectionChanged=setColorModeSpinnerSelectionNoCallback(selectedColorModeIndex);
        }
      }
    }
    mColorModeSpinner.setEnabled(true);
    mOrientationSpinner.setEnabled(true);
    PrintDocumentInfo info=mDocument.info;
    if (info != null && (info.getPageCount() > 0 || info.getPageCount() == PrintDocumentInfo.PAGE_COUNT_UNKNOWN)) {
      if (info.getPageCount() == 1) {
        mRangeOptionsSpinner.setEnabled(false);
      }
 else {
        mRangeOptionsSpinner.setEnabled(true);
        if (mRangeOptionsSpinner.getSelectedItemPosition() > 0) {
          if (!mPageRangeEditText.isEnabled()) {
            mPageRangeEditText.setEnabled(true);
            mPageRangeEditText.setVisibility(View.VISIBLE);
            mPageRangeTitle.setVisibility(View.VISIBLE);
            mPageRangeEditText.requestFocus();
            InputMethodManager imm=(InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
            imm.showSoftInput(mPageRangeEditText,0);
          }
        }
 else {
          mPageRangeEditText.setEnabled(false);
          mPageRangeEditText.setVisibility(View.INVISIBLE);
          mPageRangeTitle.setVisibility(View.INVISIBLE);
        }
      }
      final int pageCount=mDocument.info.getPageCount();
      mRangeOptionsTitle.setText(getString(R.string.label_pages,(pageCount == PrintDocumentInfo.PAGE_COUNT_UNKNOWN) ? getString(R.string.page_count_unknown) : String.valueOf(pageCount)));
    }
 else {
      if (mRangeOptionsSpinner.getSelectedItemPosition() != 0) {
        mIgnoreNextRangeOptionChange=true;
        mRangeOptionsSpinner.setSelection(0);
      }
      mRangeOptionsSpinner.setEnabled(false);
      mRangeOptionsTitle.setText(getString(R.string.label_pages,getString(R.string.page_count_unknown)));
      mPageRangeEditText.setEnabled(false);
      mPageRangeEditText.setVisibility(View.INVISIBLE);
      mPageRangeTitle.setVisibility(View.INVISIBLE);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      String newText=getString(R.string.print_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.print_button);
      }
    }
 else {
      String newText=getString(R.string.save_button);
      if (!TextUtils.equals(newText,mPrintButton.getText())) {
        mPrintButton.setText(R.string.save_button);
      }
    }
    if ((mRangeOptionsSpinner.getSelectedItemPosition() == 1 && (TextUtils.isEmpty(mPageRangeEditText.getText()) || hasErrors())) || (mRangeOptionsSpinner.getSelectedItemPosition() == 0 && (!mController.hasPerformedLayout() || hasErrors()))) {
      mPrintButton.setEnabled(false);
    }
 else {
      mPrintButton.setEnabled(true);
    }
    if (mDestinationSpinner.getSelectedItemId() != DEST_ADAPTER_ITEM_ID_SAVE_AS_PDF) {
      mCopiesEditText.setEnabled(true);
    }
 else {
      mCopiesEditText.setEnabled(false);
    }
    if (mCopiesEditText.getError() == null && TextUtils.isEmpty(mCopiesEditText.getText())) {
      mIgnoreNextCopiesChange=true;
      mCopiesEditText.setText(String.valueOf(MIN_COPIES));
      mCopiesEditText.selectAll();
      mCopiesEditText.requestFocus();
    }
    return someAttributeSelectionChanged;
  }
}"
1626,"public boolean isDone(){
  return isPrintConfirmed() || isPreviewConfirmed() || isCancelled();
}","public boolean isDone(){
  return isPrintConfirmed() || isCancelled();
}"
1627,"@Override public void onAfterInvocation(Method m,Object[] args,Object result){
  if (m.getReturnType() == Integer.TYPE) {
    int returnValue=(Integer)result;
switch (returnValue) {
case NO_ERROR:
      return;
case PERMISSION_DENIED:
    throw new SecurityException(""String_Node_Str"");
case ALREADY_EXISTS:
  return;
case BAD_VALUE:
throw new IllegalArgumentException(""String_Node_Str"");
case DEAD_OBJECT:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case EACCES:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISABLED));
case EBUSY:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_IN_USE));
case ENODEV:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case ENOTSUP:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DEPRECATED_HAL));
}
if (returnValue < 0) {
throw new UnsupportedOperationException(String.format(""String_Node_Str"",returnValue));
}
}
}","@Override public void onAfterInvocation(Method m,Object[] args,Object result){
  if (m.getReturnType() == Integer.TYPE) {
    int returnValue=(Integer)result;
switch (returnValue) {
case NO_ERROR:
      return;
case PERMISSION_DENIED:
    throw new SecurityException(""String_Node_Str"");
case ALREADY_EXISTS:
  return;
case BAD_VALUE:
throw new IllegalArgumentException(""String_Node_Str"");
case DEAD_OBJECT:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case EACCES:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISABLED));
case EBUSY:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_IN_USE));
case ENODEV:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case EOPNOTSUPP:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DEPRECATED_HAL));
}
if (returnValue < 0) {
throw new UnsupportedOperationException(String.format(""String_Node_Str"",returnValue));
}
}
}"
1628,"@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(PrintWriter pw,List<ApplicationInfo> apps,boolean isUnpluggedOnly){
  prepareForDumpLocked();
  long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
  final HistoryItem rec=new HistoryItem();
  if (startIteratingHistoryLocked()) {
    HistoryPrinter hprinter=new HistoryPrinter();
    while (getNextHistoryLocked(rec)) {
      pw.print(BATTERY_STATS_CHECKIN_VERSION);
      pw.print(',');
      pw.print(0);
      pw.print(',');
      pw.print(HISTORY_DATA);
      pw.print(',');
      hprinter.printNextItemCheckin(pw,rec,now);
      pw.println();
    }
    finishIteratingHistoryLocked();
  }
  if (apps != null) {
    SparseArray<ArrayList<String>> uids=new SparseArray<ArrayList<String>>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      ArrayList<String> pkgs=uids.get(ai.uid);
      if (pkgs == null) {
        pkgs=new ArrayList<String>();
        uids.put(ai.uid,pkgs);
      }
      pkgs.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=uidStats.keyAt(i);
      ArrayList<String> pkgs=uids.get(uid);
      if (pkgs != null) {
        for (int j=0; j < pkgs.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (isUnpluggedOnly) {
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
 else {
    dumpCheckinLocked(pw,STATS_SINCE_CHARGED,-1);
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
}","@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(PrintWriter pw,List<ApplicationInfo> apps,boolean isUnpluggedOnly,boolean includeHistory){
  prepareForDumpLocked();
  long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
  if (includeHistory) {
    final HistoryItem rec=new HistoryItem();
    if (startIteratingHistoryLocked()) {
      HistoryPrinter hprinter=new HistoryPrinter();
      while (getNextHistoryLocked(rec)) {
        pw.print(BATTERY_STATS_CHECKIN_VERSION);
        pw.print(',');
        pw.print(0);
        pw.print(',');
        pw.print(HISTORY_DATA);
        pw.print(',');
        hprinter.printNextItemCheckin(pw,rec,now);
        pw.println();
      }
      finishIteratingHistoryLocked();
    }
  }
  if (apps != null) {
    SparseArray<ArrayList<String>> uids=new SparseArray<ArrayList<String>>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      ArrayList<String> pkgs=uids.get(ai.uid);
      if (pkgs == null) {
        pkgs=new ArrayList<String>();
        uids.put(ai.uid,pkgs);
      }
      pkgs.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=uidStats.keyAt(i);
      ArrayList<String> pkgs=uids.get(uid);
      if (pkgs != null) {
        for (int j=0; j < pkgs.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (isUnpluggedOnly) {
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
 else {
    dumpCheckinLocked(pw,STATS_SINCE_CHARGED,-1);
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
}"
1629,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean isCheckin=false;
  boolean isUnpluggedOnly=false;
  boolean noOutput=false;
  int reqUid=-1;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isUnpluggedOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.resetAllStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.writeSyncLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          reqUid=mContext.getPackageManager().getPackageUid(arg,UserHandle.getCallingUserId());
        }
 catch (        PackageManager.NameNotFoundException e) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (noOutput) {
    return;
  }
  if (isCheckin) {
    List<ApplicationInfo> apps=mContext.getPackageManager().getInstalledApplications(0);
synchronized (mStats) {
      mStats.dumpCheckinLocked(pw,apps,isUnpluggedOnly);
    }
  }
 else {
synchronized (mStats) {
      mStats.dumpLocked(pw,isUnpluggedOnly,reqUid);
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean isCheckin=false;
  boolean includeHistory=false;
  boolean isUnpluggedOnly=false;
  boolean noOutput=false;
  int reqUid=-1;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
        includeHistory=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isUnpluggedOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.resetAllStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.writeSyncLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          reqUid=mContext.getPackageManager().getPackageUid(arg,UserHandle.getCallingUserId());
        }
 catch (        PackageManager.NameNotFoundException e) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (noOutput) {
    return;
  }
  if (isCheckin) {
    List<ApplicationInfo> apps=mContext.getPackageManager().getInstalledApplications(0);
synchronized (mStats) {
      mStats.dumpCheckinLocked(pw,apps,isUnpluggedOnly,includeHistory);
    }
  }
 else {
synchronized (mStats) {
      mStats.dumpLocked(pw,isUnpluggedOnly,reqUid);
    }
  }
}"
1630,"@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(PrintWriter pw,List<ApplicationInfo> apps,boolean isUnpluggedOnly){
  prepareForDumpLocked();
  long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
  final HistoryItem rec=new HistoryItem();
  if (startIteratingHistoryLocked()) {
    HistoryPrinter hprinter=new HistoryPrinter();
    while (getNextHistoryLocked(rec)) {
      pw.print(BATTERY_STATS_CHECKIN_VERSION);
      pw.print(',');
      pw.print(0);
      pw.print(',');
      pw.print(HISTORY_DATA);
      pw.print(',');
      hprinter.printNextItemCheckin(pw,rec,now);
      pw.println();
    }
    finishIteratingHistoryLocked();
  }
  if (apps != null) {
    SparseArray<ArrayList<String>> uids=new SparseArray<ArrayList<String>>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      ArrayList<String> pkgs=uids.get(ai.uid);
      if (pkgs == null) {
        pkgs=new ArrayList<String>();
        uids.put(ai.uid,pkgs);
      }
      pkgs.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=uidStats.keyAt(i);
      ArrayList<String> pkgs=uids.get(uid);
      if (pkgs != null) {
        for (int j=0; j < pkgs.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (isUnpluggedOnly) {
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
 else {
    dumpCheckinLocked(pw,STATS_SINCE_CHARGED,-1);
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
}","@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(PrintWriter pw,List<ApplicationInfo> apps,boolean isUnpluggedOnly,boolean includeHistory){
  prepareForDumpLocked();
  long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
  if (includeHistory) {
    final HistoryItem rec=new HistoryItem();
    if (startIteratingHistoryLocked()) {
      HistoryPrinter hprinter=new HistoryPrinter();
      while (getNextHistoryLocked(rec)) {
        pw.print(BATTERY_STATS_CHECKIN_VERSION);
        pw.print(',');
        pw.print(0);
        pw.print(',');
        pw.print(HISTORY_DATA);
        pw.print(',');
        hprinter.printNextItemCheckin(pw,rec,now);
        pw.println();
      }
      finishIteratingHistoryLocked();
    }
  }
  if (apps != null) {
    SparseArray<ArrayList<String>> uids=new SparseArray<ArrayList<String>>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      ArrayList<String> pkgs=uids.get(ai.uid);
      if (pkgs == null) {
        pkgs=new ArrayList<String>();
        uids.put(ai.uid,pkgs);
      }
      pkgs.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=uidStats.keyAt(i);
      ArrayList<String> pkgs=uids.get(uid);
      if (pkgs != null) {
        for (int j=0; j < pkgs.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (isUnpluggedOnly) {
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
 else {
    dumpCheckinLocked(pw,STATS_SINCE_CHARGED,-1);
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
}"
1631,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean isCheckin=false;
  boolean isUnpluggedOnly=false;
  boolean noOutput=false;
  int reqUid=-1;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isUnpluggedOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.resetAllStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.writeSyncLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          reqUid=mContext.getPackageManager().getPackageUid(arg,UserHandle.getCallingUserId());
        }
 catch (        PackageManager.NameNotFoundException e) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (noOutput) {
    return;
  }
  if (isCheckin) {
    List<ApplicationInfo> apps=mContext.getPackageManager().getInstalledApplications(0);
synchronized (mStats) {
      mStats.dumpCheckinLocked(pw,apps,isUnpluggedOnly);
    }
  }
 else {
synchronized (mStats) {
      mStats.dumpLocked(pw,isUnpluggedOnly,reqUid);
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean isCheckin=false;
  boolean includeHistory=false;
  boolean isUnpluggedOnly=false;
  boolean noOutput=false;
  int reqUid=-1;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
        includeHistory=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isUnpluggedOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.resetAllStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.writeSyncLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          reqUid=mContext.getPackageManager().getPackageUid(arg,UserHandle.getCallingUserId());
        }
 catch (        PackageManager.NameNotFoundException e) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (noOutput) {
    return;
  }
  if (isCheckin) {
    List<ApplicationInfo> apps=mContext.getPackageManager().getInstalledApplications(0);
synchronized (mStats) {
      mStats.dumpCheckinLocked(pw,apps,isUnpluggedOnly,includeHistory);
    }
  }
 else {
synchronized (mStats) {
      mStats.dumpLocked(pw,isUnpluggedOnly,reqUid);
    }
  }
}"
1632,"@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(PrintWriter pw,List<ApplicationInfo> apps,boolean isUnpluggedOnly){
  prepareForDumpLocked();
  long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
  final HistoryItem rec=new HistoryItem();
  if (startIteratingHistoryLocked()) {
    HistoryPrinter hprinter=new HistoryPrinter();
    while (getNextHistoryLocked(rec)) {
      pw.print(BATTERY_STATS_CHECKIN_VERSION);
      pw.print(',');
      pw.print(0);
      pw.print(',');
      pw.print(HISTORY_DATA);
      pw.print(',');
      hprinter.printNextItemCheckin(pw,rec,now);
      pw.println();
    }
    finishIteratingHistoryLocked();
  }
  if (apps != null) {
    SparseArray<ArrayList<String>> uids=new SparseArray<ArrayList<String>>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      ArrayList<String> pkgs=uids.get(ai.uid);
      if (pkgs == null) {
        pkgs=new ArrayList<String>();
        uids.put(ai.uid,pkgs);
      }
      pkgs.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=uidStats.keyAt(i);
      ArrayList<String> pkgs=uids.get(uid);
      if (pkgs != null) {
        for (int j=0; j < pkgs.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (isUnpluggedOnly) {
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
 else {
    dumpCheckinLocked(pw,STATS_SINCE_CHARGED,-1);
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
}","@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(PrintWriter pw,List<ApplicationInfo> apps,boolean isUnpluggedOnly,boolean includeHistory){
  prepareForDumpLocked();
  long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
  if (includeHistory) {
    final HistoryItem rec=new HistoryItem();
    if (startIteratingHistoryLocked()) {
      HistoryPrinter hprinter=new HistoryPrinter();
      while (getNextHistoryLocked(rec)) {
        pw.print(BATTERY_STATS_CHECKIN_VERSION);
        pw.print(',');
        pw.print(0);
        pw.print(',');
        pw.print(HISTORY_DATA);
        pw.print(',');
        hprinter.printNextItemCheckin(pw,rec,now);
        pw.println();
      }
      finishIteratingHistoryLocked();
    }
  }
  if (apps != null) {
    SparseArray<ArrayList<String>> uids=new SparseArray<ArrayList<String>>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      ArrayList<String> pkgs=uids.get(ai.uid);
      if (pkgs == null) {
        pkgs=new ArrayList<String>();
        uids.put(ai.uid,pkgs);
      }
      pkgs.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=uidStats.keyAt(i);
      ArrayList<String> pkgs=uids.get(uid);
      if (pkgs != null) {
        for (int j=0; j < pkgs.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (isUnpluggedOnly) {
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
 else {
    dumpCheckinLocked(pw,STATS_SINCE_CHARGED,-1);
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
}"
1633,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean isCheckin=false;
  boolean isUnpluggedOnly=false;
  boolean noOutput=false;
  int reqUid=-1;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isUnpluggedOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.resetAllStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.writeSyncLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          reqUid=mContext.getPackageManager().getPackageUid(arg,UserHandle.getCallingUserId());
        }
 catch (        PackageManager.NameNotFoundException e) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (noOutput) {
    return;
  }
  if (isCheckin) {
    List<ApplicationInfo> apps=mContext.getPackageManager().getInstalledApplications(0);
synchronized (mStats) {
      mStats.dumpCheckinLocked(pw,apps,isUnpluggedOnly);
    }
  }
 else {
synchronized (mStats) {
      mStats.dumpLocked(pw,isUnpluggedOnly,reqUid);
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean isCheckin=false;
  boolean includeHistory=false;
  boolean isUnpluggedOnly=false;
  boolean noOutput=false;
  int reqUid=-1;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
        includeHistory=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isUnpluggedOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.resetAllStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.writeSyncLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          reqUid=mContext.getPackageManager().getPackageUid(arg,UserHandle.getCallingUserId());
        }
 catch (        PackageManager.NameNotFoundException e) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (noOutput) {
    return;
  }
  if (isCheckin) {
    List<ApplicationInfo> apps=mContext.getPackageManager().getInstalledApplications(0);
synchronized (mStats) {
      mStats.dumpCheckinLocked(pw,apps,isUnpluggedOnly,includeHistory);
    }
  }
 else {
synchronized (mStats) {
      mStats.dumpLocked(pw,isUnpluggedOnly,reqUid);
    }
  }
}"
1634,"@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(PrintWriter pw,List<ApplicationInfo> apps,boolean isUnpluggedOnly){
  prepareForDumpLocked();
  long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
  final HistoryItem rec=new HistoryItem();
  if (startIteratingHistoryLocked()) {
    HistoryPrinter hprinter=new HistoryPrinter();
    while (getNextHistoryLocked(rec)) {
      pw.print(BATTERY_STATS_CHECKIN_VERSION);
      pw.print(',');
      pw.print(0);
      pw.print(',');
      pw.print(HISTORY_DATA);
      pw.print(',');
      hprinter.printNextItemCheckin(pw,rec,now);
      pw.println();
    }
    finishIteratingHistoryLocked();
  }
  if (apps != null) {
    SparseArray<ArrayList<String>> uids=new SparseArray<ArrayList<String>>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      ArrayList<String> pkgs=uids.get(ai.uid);
      if (pkgs == null) {
        pkgs=new ArrayList<String>();
        uids.put(ai.uid,pkgs);
      }
      pkgs.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=uidStats.keyAt(i);
      ArrayList<String> pkgs=uids.get(uid);
      if (pkgs != null) {
        for (int j=0; j < pkgs.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (isUnpluggedOnly) {
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
 else {
    dumpCheckinLocked(pw,STATS_SINCE_CHARGED,-1);
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
}","@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(PrintWriter pw,List<ApplicationInfo> apps,boolean isUnpluggedOnly,boolean includeHistory){
  prepareForDumpLocked();
  long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
  if (includeHistory) {
    final HistoryItem rec=new HistoryItem();
    if (startIteratingHistoryLocked()) {
      HistoryPrinter hprinter=new HistoryPrinter();
      while (getNextHistoryLocked(rec)) {
        pw.print(BATTERY_STATS_CHECKIN_VERSION);
        pw.print(',');
        pw.print(0);
        pw.print(',');
        pw.print(HISTORY_DATA);
        pw.print(',');
        hprinter.printNextItemCheckin(pw,rec,now);
        pw.println();
      }
      finishIteratingHistoryLocked();
    }
  }
  if (apps != null) {
    SparseArray<ArrayList<String>> uids=new SparseArray<ArrayList<String>>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      ArrayList<String> pkgs=uids.get(ai.uid);
      if (pkgs == null) {
        pkgs=new ArrayList<String>();
        uids.put(ai.uid,pkgs);
      }
      pkgs.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=uidStats.keyAt(i);
      ArrayList<String> pkgs=uids.get(uid);
      if (pkgs != null) {
        for (int j=0; j < pkgs.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (isUnpluggedOnly) {
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
 else {
    dumpCheckinLocked(pw,STATS_SINCE_CHARGED,-1);
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
}"
1635,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean isCheckin=false;
  boolean isUnpluggedOnly=false;
  boolean noOutput=false;
  int reqUid=-1;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isUnpluggedOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.resetAllStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.writeSyncLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          reqUid=mContext.getPackageManager().getPackageUid(arg,UserHandle.getCallingUserId());
        }
 catch (        PackageManager.NameNotFoundException e) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (noOutput) {
    return;
  }
  if (isCheckin) {
    List<ApplicationInfo> apps=mContext.getPackageManager().getInstalledApplications(0);
synchronized (mStats) {
      mStats.dumpCheckinLocked(pw,apps,isUnpluggedOnly);
    }
  }
 else {
synchronized (mStats) {
      mStats.dumpLocked(pw,isUnpluggedOnly,reqUid);
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean isCheckin=false;
  boolean includeHistory=false;
  boolean isUnpluggedOnly=false;
  boolean noOutput=false;
  int reqUid=-1;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
        includeHistory=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isUnpluggedOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.resetAllStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.writeSyncLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          reqUid=mContext.getPackageManager().getPackageUid(arg,UserHandle.getCallingUserId());
        }
 catch (        PackageManager.NameNotFoundException e) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (noOutput) {
    return;
  }
  if (isCheckin) {
    List<ApplicationInfo> apps=mContext.getPackageManager().getInstalledApplications(0);
synchronized (mStats) {
      mStats.dumpCheckinLocked(pw,apps,isUnpluggedOnly,includeHistory);
    }
  }
 else {
synchronized (mStats) {
      mStats.dumpLocked(pw,isUnpluggedOnly,reqUid);
    }
  }
}"
1636,"@Override public void onAfterInvocation(Method m,Object[] args,Object result){
  if (m.getReturnType() == Integer.TYPE) {
    int returnValue=(Integer)result;
switch (returnValue) {
case NO_ERROR:
      return;
case PERMISSION_DENIED:
    throw new SecurityException(""String_Node_Str"");
case ALREADY_EXISTS:
  return;
case BAD_VALUE:
throw new IllegalArgumentException(""String_Node_Str"");
case DEAD_OBJECT:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case EACCES:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISABLED));
case EBUSY:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_IN_USE));
case ENODEV:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case ENOTSUP:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DEPRECATED_HAL));
}
if (returnValue < 0) {
throw new UnsupportedOperationException(String.format(""String_Node_Str"",returnValue));
}
}
}","@Override public void onAfterInvocation(Method m,Object[] args,Object result){
  if (m.getReturnType() == Integer.TYPE) {
    int returnValue=(Integer)result;
switch (returnValue) {
case NO_ERROR:
      return;
case PERMISSION_DENIED:
    throw new SecurityException(""String_Node_Str"");
case ALREADY_EXISTS:
  return;
case BAD_VALUE:
throw new IllegalArgumentException(""String_Node_Str"");
case DEAD_OBJECT:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case EACCES:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISABLED));
case EBUSY:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_IN_USE));
case ENODEV:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case EOPNOTSUPP:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DEPRECATED_HAL));
}
if (returnValue < 0) {
throw new UnsupportedOperationException(String.format(""String_Node_Str"",returnValue));
}
}
}"
1637,"@Override public void onAfterInvocation(Method m,Object[] args,Object result){
  if (m.getReturnType() == Integer.TYPE) {
    int returnValue=(Integer)result;
switch (returnValue) {
case NO_ERROR:
      return;
case PERMISSION_DENIED:
    throw new SecurityException(""String_Node_Str"");
case ALREADY_EXISTS:
  return;
case BAD_VALUE:
throw new IllegalArgumentException(""String_Node_Str"");
case DEAD_OBJECT:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case EACCES:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISABLED));
case EBUSY:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_IN_USE));
case ENODEV:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case ENOTSUP:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DEPRECATED_HAL));
}
if (returnValue < 0) {
throw new UnsupportedOperationException(String.format(""String_Node_Str"",returnValue));
}
}
}","@Override public void onAfterInvocation(Method m,Object[] args,Object result){
  if (m.getReturnType() == Integer.TYPE) {
    int returnValue=(Integer)result;
switch (returnValue) {
case NO_ERROR:
      return;
case PERMISSION_DENIED:
    throw new SecurityException(""String_Node_Str"");
case ALREADY_EXISTS:
  return;
case BAD_VALUE:
throw new IllegalArgumentException(""String_Node_Str"");
case DEAD_OBJECT:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case EACCES:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISABLED));
case EBUSY:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_IN_USE));
case ENODEV:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case EOPNOTSUPP:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DEPRECATED_HAL));
}
if (returnValue < 0) {
throw new UnsupportedOperationException(String.format(""String_Node_Str"",returnValue));
}
}
}"
1638,"public void setExecuting(boolean executing,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addStateTime(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
  }
}","public void setExecuting(boolean executing,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addStateTime(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
  }
}"
1639,"public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(proc.mNumStartedServices);
          }
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,dumpAll);
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println(""String_Node_Str"");
    dumpSummaryLocked(pw,reqPackage,now);
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}","public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(proc.mNumStartedServices);
          }
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,dumpAll);
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println();
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println(""String_Node_Str"");
    dumpSummaryLocked(pw,reqPackage,now);
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}"
1640,"public void setStarted(boolean started,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addStateTime(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    if (mProc != null) {
      mProc=mProc.pullFixedProc(mPackage);
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
  }
}","public void setStarted(boolean started,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final boolean wasStarted=mStartedState != STATE_NOTHING;
  final int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addStateTime(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    mProc=mProc.pullFixedProc(mPackage);
    if (wasStarted != started) {
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
  }
}"
1641,"public void setBound(boolean bound,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addStateTime(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
  }
}","public void setBound(boolean bound,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addStateTime(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
  }
}"
1642,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
        writeStateLocked(true,true);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        writeStateSyncLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        readLocked(mProcessStats,mFile);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              if (dumpDetails) {
                processStats.dumpLocked(pw,reqPackage,now,dumpAll);
              }
 else {
                processStats.dumpSummaryLocked(pw,reqPackage,now);
              }
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
        writeStateLocked(true,true);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        writeStateSyncLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        readLocked(mProcessStats,mFile);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              processStats.dumpSummaryLocked(pw,reqPackage,now);
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}"
1643,"public void setExecuting(boolean executing,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addStateTime(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
  }
}","public void setExecuting(boolean executing,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addStateTime(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
  }
}"
1644,"public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(proc.mNumStartedServices);
          }
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,dumpAll);
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println(""String_Node_Str"");
    dumpSummaryLocked(pw,reqPackage,now);
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}","public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(proc.mNumStartedServices);
          }
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,dumpAll);
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println();
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println(""String_Node_Str"");
    dumpSummaryLocked(pw,reqPackage,now);
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}"
1645,"public void setStarted(boolean started,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addStateTime(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    if (mProc != null) {
      mProc=mProc.pullFixedProc(mPackage);
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
  }
}","public void setStarted(boolean started,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final boolean wasStarted=mStartedState != STATE_NOTHING;
  final int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addStateTime(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    mProc=mProc.pullFixedProc(mPackage);
    if (wasStarted != started) {
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
  }
}"
1646,"public void setBound(boolean bound,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addStateTime(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
  }
}","public void setBound(boolean bound,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addStateTime(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
  }
}"
1647,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
        writeStateLocked(true,true);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        writeStateSyncLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        readLocked(mProcessStats,mFile);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              if (dumpDetails) {
                processStats.dumpLocked(pw,reqPackage,now,dumpAll);
              }
 else {
                processStats.dumpSummaryLocked(pw,reqPackage,now);
              }
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
        writeStateLocked(true,true);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        writeStateSyncLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        readLocked(mProcessStats,mFile);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              processStats.dumpSummaryLocked(pw,reqPackage,now);
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}"
1648,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  final int layoutDirection=getLayoutDirection();
  if (isLayoutRtl() && myWidth == -1) {
    myWidth=DEFAULT_WIDTH;
  }
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        if (isLayoutRtl()) {
          width=Math.max(width,myWidth - params.mLeft);
        }
 else {
          width=Math.max(width,params.mRight);
        }
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  if (isLayoutRtl()) {
    final int offsetWidth=myWidth - width;
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        params.mLeft-=offsetWidth;
        params.mRight-=offsetWidth;
      }
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  final int layoutDirection=getLayoutDirection();
  if (isLayoutRtl() && myWidth == -1) {
    myWidth=DEFAULT_WIDTH;
  }
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  final int targetSdkVersion=getContext().getApplicationInfo().targetSdkVersion;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        if (isLayoutRtl()) {
          if (targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
            width=Math.max(width,myWidth - params.mLeft);
          }
 else {
            width=Math.max(width,myWidth - params.mLeft - params.leftMargin);
          }
        }
 else {
          if (targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
            width=Math.max(width,params.mRight);
          }
 else {
            width=Math.max(width,params.mRight + params.rightMargin);
          }
        }
      }
      if (isWrapContentHeight) {
        if (targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
          height=Math.max(height,params.mBottom);
        }
 else {
          height=Math.max(height,params.mBottom + params.bottomMargin);
        }
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  if (isLayoutRtl()) {
    final int offsetWidth=myWidth - width;
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        params.mLeft-=offsetWidth;
        params.mRight-=offsetWidth;
      }
    }
  }
  setMeasuredDimension(width,height);
}"
1649,"public void setExecuting(boolean executing,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addStateTime(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
  }
}","public void setExecuting(boolean executing,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addStateTime(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
  }
}"
1650,"public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(proc.mNumStartedServices);
          }
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,dumpAll);
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println(""String_Node_Str"");
    dumpSummaryLocked(pw,reqPackage,now);
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}","public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(proc.mNumStartedServices);
          }
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,dumpAll);
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println();
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println(""String_Node_Str"");
    dumpSummaryLocked(pw,reqPackage,now);
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}"
1651,"public void setStarted(boolean started,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addStateTime(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    if (mProc != null) {
      mProc=mProc.pullFixedProc(mPackage);
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
  }
}","public void setStarted(boolean started,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final boolean wasStarted=mStartedState != STATE_NOTHING;
  final int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addStateTime(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    mProc=mProc.pullFixedProc(mPackage);
    if (wasStarted != started) {
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
  }
}"
1652,"public void setBound(boolean bound,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addStateTime(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
  }
}","public void setBound(boolean bound,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addStateTime(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
  }
}"
1653,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
        writeStateLocked(true,true);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        writeStateSyncLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        readLocked(mProcessStats,mFile);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              if (dumpDetails) {
                processStats.dumpLocked(pw,reqPackage,now,dumpAll);
              }
 else {
                processStats.dumpSummaryLocked(pw,reqPackage,now);
              }
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
        writeStateLocked(true,true);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        writeStateSyncLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        readLocked(mProcessStats,mFile);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              processStats.dumpSummaryLocked(pw,reqPackage,now);
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}"
1654,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  final int layoutDirection=getLayoutDirection();
  if (isLayoutRtl() && myWidth == -1) {
    myWidth=DEFAULT_WIDTH;
  }
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        if (isLayoutRtl()) {
          width=Math.max(width,myWidth - params.mLeft);
        }
 else {
          width=Math.max(width,params.mRight);
        }
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  if (isLayoutRtl()) {
    final int offsetWidth=myWidth - width;
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        params.mLeft-=offsetWidth;
        params.mRight-=offsetWidth;
      }
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  final int layoutDirection=getLayoutDirection();
  if (isLayoutRtl() && myWidth == -1) {
    myWidth=DEFAULT_WIDTH;
  }
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  final int targetSdkVersion=getContext().getApplicationInfo().targetSdkVersion;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        if (isLayoutRtl()) {
          if (targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
            width=Math.max(width,myWidth - params.mLeft);
          }
 else {
            width=Math.max(width,myWidth - params.mLeft - params.leftMargin);
          }
        }
 else {
          if (targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
            width=Math.max(width,params.mRight);
          }
 else {
            width=Math.max(width,params.mRight + params.rightMargin);
          }
        }
      }
      if (isWrapContentHeight) {
        if (targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
          height=Math.max(height,params.mBottom);
        }
 else {
          height=Math.max(height,params.mBottom + params.bottomMargin);
        }
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  if (isLayoutRtl()) {
    final int offsetWidth=myWidth - width;
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        params.mLeft-=offsetWidth;
        params.mRight-=offsetWidth;
      }
    }
  }
  setMeasuredDimension(width,height);
}"
1655,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  final int layoutDirection=getLayoutDirection();
  if (isLayoutRtl() && myWidth == -1) {
    myWidth=DEFAULT_WIDTH;
  }
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        if (isLayoutRtl()) {
          width=Math.max(width,myWidth - params.mLeft);
        }
 else {
          width=Math.max(width,params.mRight);
        }
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  if (isLayoutRtl()) {
    final int offsetWidth=myWidth - width;
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        params.mLeft-=offsetWidth;
        params.mRight-=offsetWidth;
      }
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  final int layoutDirection=getLayoutDirection();
  if (isLayoutRtl() && myWidth == -1) {
    myWidth=DEFAULT_WIDTH;
  }
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  final int targetSdkVersion=getContext().getApplicationInfo().targetSdkVersion;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        if (isLayoutRtl()) {
          if (targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
            width=Math.max(width,myWidth - params.mLeft);
          }
 else {
            width=Math.max(width,myWidth - params.mLeft - params.leftMargin);
          }
        }
 else {
          if (targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
            width=Math.max(width,params.mRight);
          }
 else {
            width=Math.max(width,params.mRight + params.rightMargin);
          }
        }
      }
      if (isWrapContentHeight) {
        if (targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
          height=Math.max(height,params.mBottom);
        }
 else {
          height=Math.max(height,params.mBottom + params.bottomMargin);
        }
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  if (isLayoutRtl()) {
    final int offsetWidth=myWidth - width;
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        params.mLeft-=offsetWidth;
        params.mRight-=offsetWidth;
      }
    }
  }
  setMeasuredDimension(width,height);
}"
1656,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  final int layoutDirection=getLayoutDirection();
  if (isLayoutRtl() && myWidth == -1) {
    myWidth=DEFAULT_WIDTH;
  }
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        if (isLayoutRtl()) {
          width=Math.max(width,myWidth - params.mLeft);
        }
 else {
          width=Math.max(width,params.mRight);
        }
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  if (isLayoutRtl()) {
    final int offsetWidth=myWidth - width;
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        params.mLeft-=offsetWidth;
        params.mRight-=offsetWidth;
      }
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  final int layoutDirection=getLayoutDirection();
  if (isLayoutRtl() && myWidth == -1) {
    myWidth=DEFAULT_WIDTH;
  }
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  final int targetSdkVersion=getContext().getApplicationInfo().targetSdkVersion;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        if (isLayoutRtl()) {
          if (targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
            width=Math.max(width,myWidth - params.mLeft);
          }
 else {
            width=Math.max(width,myWidth - params.mLeft - params.leftMargin);
          }
        }
 else {
          if (targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
            width=Math.max(width,params.mRight);
          }
 else {
            width=Math.max(width,params.mRight + params.rightMargin);
          }
        }
      }
      if (isWrapContentHeight) {
        if (targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
          height=Math.max(height,params.mBottom);
        }
 else {
          height=Math.max(height,params.mBottom + params.bottomMargin);
        }
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  if (isLayoutRtl()) {
    final int offsetWidth=myWidth - width;
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        params.mLeft-=offsetWidth;
        params.mRight-=offsetWidth;
      }
    }
  }
  setMeasuredDimension(width,height);
}"
1657,"@Override public void onAfterInvocation(Method m,Object[] args,Object result){
  if (m.getReturnType() == Integer.TYPE) {
    int returnValue=(Integer)result;
switch (returnValue) {
case NO_ERROR:
      return;
case PERMISSION_DENIED:
    throw new SecurityException(""String_Node_Str"");
case ALREADY_EXISTS:
  return;
case BAD_VALUE:
throw new IllegalArgumentException(""String_Node_Str"");
case DEAD_OBJECT:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case EACCES:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISABLED));
case EBUSY:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_IN_USE));
case ENODEV:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case ENOTSUP:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DEPRECATED_HAL));
}
if (returnValue < 0) {
throw new UnsupportedOperationException(String.format(""String_Node_Str"",returnValue));
}
}
}","@Override public void onAfterInvocation(Method m,Object[] args,Object result){
  if (m.getReturnType() == Integer.TYPE) {
    int returnValue=(Integer)result;
switch (returnValue) {
case NO_ERROR:
      return;
case PERMISSION_DENIED:
    throw new SecurityException(""String_Node_Str"");
case ALREADY_EXISTS:
  return;
case BAD_VALUE:
throw new IllegalArgumentException(""String_Node_Str"");
case DEAD_OBJECT:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case EACCES:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISABLED));
case EBUSY:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_IN_USE));
case ENODEV:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
case EOPNOTSUPP:
UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DEPRECATED_HAL));
}
if (returnValue < 0) {
throw new UnsupportedOperationException(String.format(""String_Node_Str"",returnValue));
}
}
}"
1658,"public void setExecuting(boolean executing,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addStateTime(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
  }
}","public void setExecuting(boolean executing,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=executing ? memFactor : STATE_NOTHING;
  if (mExecState != state) {
    if (mExecState != STATE_NOTHING) {
      addStateTime(SERVICE_EXEC + (mExecState * SERVICE_COUNT),now - mExecStartTime);
    }
 else     if (executing) {
      mExecCount++;
    }
    mExecState=state;
    mExecStartTime=now;
  }
}"
1659,"public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(proc.mNumStartedServices);
          }
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,dumpAll);
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println(""String_Node_Str"");
    dumpSummaryLocked(pw,reqPackage,now);
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}","public void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(proc.mNumStartedServices);
          }
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,dumpAll);
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println();
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println(""String_Node_Str"");
    dumpSummaryLocked(pw,reqPackage,now);
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}"
1660,"public void setStarted(boolean started,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addStateTime(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    if (mProc != null) {
      mProc=mProc.pullFixedProc(mPackage);
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
  }
}","public void setStarted(boolean started,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final boolean wasStarted=mStartedState != STATE_NOTHING;
  final int state=started ? memFactor : STATE_NOTHING;
  if (mStartedState != state) {
    if (mStartedState != STATE_NOTHING) {
      addStateTime(SERVICE_STARTED + (mStartedState * SERVICE_COUNT),now - mStartedStartTime);
    }
 else     if (started) {
      mStartedCount++;
    }
    mStartedState=state;
    mStartedStartTime=now;
    mProc=mProc.pullFixedProc(mPackage);
    if (wasStarted != started) {
      if (started) {
        mProc.incStartedServices(memFactor,now);
      }
 else {
        mProc.decStartedServices(memFactor,now);
      }
    }
  }
}"
1661,"public void setBound(boolean bound,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addStateTime(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
  }
}","public void setBound(boolean bound,int memFactor,long now){
  if (mActive <= 0) {
    throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ mActive);
  }
  final int state=bound ? memFactor : STATE_NOTHING;
  if (mBoundState != state) {
    if (mBoundState != STATE_NOTHING) {
      addStateTime(SERVICE_BOUND + (mBoundState * SERVICE_COUNT),now - mBoundStartTime);
    }
 else     if (bound) {
      mBoundCount++;
    }
    mBoundState=state;
    mBoundStartTime=now;
  }
}"
1662,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
        writeStateLocked(true,true);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        writeStateSyncLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        readLocked(mProcessStats,mFile);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              if (dumpDetails) {
                processStats.dumpLocked(pw,reqPackage,now,dumpAll);
              }
 else {
                processStats.dumpSummaryLocked(pw,reqPackage,now);
              }
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
        writeStateLocked(true,true);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        writeStateSyncLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        readLocked(mProcessStats,mFile);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print(""String_Node_Str"");
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              processStats.dumpSummaryLocked(pw,reqPackage,now);
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,dumpAll);
          if (dumpAll) {
            pw.print(""String_Node_Str"");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}"
1663,"private void addWidgetsFromSettings(){
  if (mSafeModeEnabled || widgetsDisabled()) {
    return;
  }
  int insertionIndex=getInsertPageIndex();
  final int[] widgets=mLockPatternUtils.getAppWidgets();
  if (widgets == null) {
    Log.d(TAG,""String_Node_Str"");
  }
 else {
    for (int i=widgets.length - 1; i >= 0; i--) {
      if (widgets[i] == LockPatternUtils.ID_DEFAULT_STATUS_WIDGET) {
        addDefaultStatusWidget(insertionIndex);
      }
 else {
        addWidget(widgets[i],insertionIndex,true);
      }
    }
  }
}","private void addWidgetsFromSettings(){
  if (mSafeModeEnabled || widgetsDisabled()) {
    addDefaultStatusWidget(0);
    return;
  }
  int insertionIndex=getInsertPageIndex();
  final int[] widgets=mLockPatternUtils.getAppWidgets();
  if (widgets == null) {
    Log.d(TAG,""String_Node_Str"");
  }
 else {
    for (int i=widgets.length - 1; i >= 0; i--) {
      if (widgets[i] == LockPatternUtils.ID_DEFAULT_STATUS_WIDGET) {
        addDefaultStatusWidget(insertionIndex);
      }
 else {
        addWidget(widgets[i],insertionIndex,true);
      }
    }
  }
}"
1664,"private void addWidgetsFromSettings(){
  if (mSafeModeEnabled || widgetsDisabled()) {
    return;
  }
  int insertionIndex=getInsertPageIndex();
  final int[] widgets=mLockPatternUtils.getAppWidgets();
  if (widgets == null) {
    Log.d(TAG,""String_Node_Str"");
  }
 else {
    for (int i=widgets.length - 1; i >= 0; i--) {
      if (widgets[i] == LockPatternUtils.ID_DEFAULT_STATUS_WIDGET) {
        addDefaultStatusWidget(insertionIndex);
      }
 else {
        addWidget(widgets[i],insertionIndex,true);
      }
    }
  }
}","private void addWidgetsFromSettings(){
  if (mSafeModeEnabled || widgetsDisabled()) {
    addDefaultStatusWidget(0);
    return;
  }
  int insertionIndex=getInsertPageIndex();
  final int[] widgets=mLockPatternUtils.getAppWidgets();
  if (widgets == null) {
    Log.d(TAG,""String_Node_Str"");
  }
 else {
    for (int i=widgets.length - 1; i >= 0; i--) {
      if (widgets[i] == LockPatternUtils.ID_DEFAULT_STATUS_WIDGET) {
        addDefaultStatusWidget(insertionIndex);
      }
 else {
        addWidget(widgets[i],insertionIndex,true);
      }
    }
  }
}"
1665,"private void addWidgetsFromSettings(){
  if (mSafeModeEnabled || widgetsDisabled()) {
    return;
  }
  int insertionIndex=getInsertPageIndex();
  final int[] widgets=mLockPatternUtils.getAppWidgets();
  if (widgets == null) {
    Log.d(TAG,""String_Node_Str"");
  }
 else {
    for (int i=widgets.length - 1; i >= 0; i--) {
      if (widgets[i] == LockPatternUtils.ID_DEFAULT_STATUS_WIDGET) {
        addDefaultStatusWidget(insertionIndex);
      }
 else {
        addWidget(widgets[i],insertionIndex,true);
      }
    }
  }
}","private void addWidgetsFromSettings(){
  if (mSafeModeEnabled || widgetsDisabled()) {
    addDefaultStatusWidget(0);
    return;
  }
  int insertionIndex=getInsertPageIndex();
  final int[] widgets=mLockPatternUtils.getAppWidgets();
  if (widgets == null) {
    Log.d(TAG,""String_Node_Str"");
  }
 else {
    for (int i=widgets.length - 1; i >= 0; i--) {
      if (widgets[i] == LockPatternUtils.ID_DEFAULT_STATUS_WIDGET) {
        addDefaultStatusWidget(insertionIndex);
      }
 else {
        addWidget(widgets[i],insertionIndex,true);
      }
    }
  }
}"
1666,"private void addWidgetsFromSettings(){
  if (mSafeModeEnabled || widgetsDisabled()) {
    return;
  }
  int insertionIndex=getInsertPageIndex();
  final int[] widgets=mLockPatternUtils.getAppWidgets();
  if (widgets == null) {
    Log.d(TAG,""String_Node_Str"");
  }
 else {
    for (int i=widgets.length - 1; i >= 0; i--) {
      if (widgets[i] == LockPatternUtils.ID_DEFAULT_STATUS_WIDGET) {
        addDefaultStatusWidget(insertionIndex);
      }
 else {
        addWidget(widgets[i],insertionIndex,true);
      }
    }
  }
}","private void addWidgetsFromSettings(){
  if (mSafeModeEnabled || widgetsDisabled()) {
    addDefaultStatusWidget(0);
    return;
  }
  int insertionIndex=getInsertPageIndex();
  final int[] widgets=mLockPatternUtils.getAppWidgets();
  if (widgets == null) {
    Log.d(TAG,""String_Node_Str"");
  }
 else {
    for (int i=widgets.length - 1; i >= 0; i--) {
      if (widgets[i] == LockPatternUtils.ID_DEFAULT_STATUS_WIDGET) {
        addDefaultStatusWidget(insertionIndex);
      }
 else {
        addWidget(widgets[i],insertionIndex,true);
      }
    }
  }
}"
1667,"/** 
 * Sets up the strings to be used by the header.
 */
private void setUpHeader(){
  mDayLabels=new String[mDaysPerWeek];
  for (int i=mFirstDayOfWeek, count=mFirstDayOfWeek + mDaysPerWeek; i < count; i++) {
    int calendarDay=(i > Calendar.SATURDAY) ? i - Calendar.SATURDAY : i;
    mDayLabels[i - mFirstDayOfWeek]=DateUtils.getDayOfWeekString(calendarDay,DateUtils.LENGTH_SHORTEST);
  }
  TextView label=(TextView)mDayNamesHeader.getChildAt(0);
  if (mShowWeekNumber) {
    label.setVisibility(View.VISIBLE);
  }
 else {
    label.setVisibility(View.GONE);
  }
  for (int i=1, count=mDayNamesHeader.getChildCount(); i < count; i++) {
    label=(TextView)mDayNamesHeader.getChildAt(i);
    if (mWeekDayTextAppearanceResId > -1) {
      label.setTextAppearance(mContext,mWeekDayTextAppearanceResId);
    }
    if (i < mDaysPerWeek + 1) {
      label.setText(mDayLabels[i - 1]);
      label.setVisibility(View.VISIBLE);
    }
 else {
      label.setVisibility(View.GONE);
    }
  }
  mDayNamesHeader.invalidate();
}","/** 
 * Sets up the strings to be used by the header.
 */
private void setUpHeader(){
  final String[] tinyWeekdayNames=LocaleData.get(Locale.getDefault()).tinyWeekdayNames;
  mDayLabels=new String[mDaysPerWeek];
  for (int i=0; i < mDaysPerWeek; i++) {
    final int j=i + mFirstDayOfWeek;
    final int calendarDay=(j > Calendar.SATURDAY) ? j - Calendar.SATURDAY : j;
    mDayLabels[i]=tinyWeekdayNames[calendarDay];
  }
  TextView label=(TextView)mDayNamesHeader.getChildAt(0);
  if (mShowWeekNumber) {
    label.setVisibility(View.VISIBLE);
  }
 else {
    label.setVisibility(View.GONE);
  }
  final int count=mDayNamesHeader.getChildCount();
  for (int i=0; i < count - 1; i++) {
    label=(TextView)mDayNamesHeader.getChildAt(i + 1);
    if (mWeekDayTextAppearanceResId > -1) {
      label.setTextAppearance(mContext,mWeekDayTextAppearanceResId);
    }
    if (i < mDaysPerWeek) {
      label.setText(mDayLabels[i]);
      label.setVisibility(View.VISIBLE);
    }
 else {
      label.setVisibility(View.GONE);
    }
  }
  mDayNamesHeader.invalidate();
}"
1668,"/** 
 * Sets up the strings to be used by the header.
 */
private void setUpHeader(){
  mDayLabels=new String[mDaysPerWeek];
  for (int i=mFirstDayOfWeek, count=mFirstDayOfWeek + mDaysPerWeek; i < count; i++) {
    int calendarDay=(i > Calendar.SATURDAY) ? i - Calendar.SATURDAY : i;
    mDayLabels[i - mFirstDayOfWeek]=DateUtils.getDayOfWeekString(calendarDay,DateUtils.LENGTH_SHORTEST);
  }
  TextView label=(TextView)mDayNamesHeader.getChildAt(0);
  if (mShowWeekNumber) {
    label.setVisibility(View.VISIBLE);
  }
 else {
    label.setVisibility(View.GONE);
  }
  for (int i=1, count=mDayNamesHeader.getChildCount(); i < count; i++) {
    label=(TextView)mDayNamesHeader.getChildAt(i);
    if (mWeekDayTextAppearanceResId > -1) {
      label.setTextAppearance(mContext,mWeekDayTextAppearanceResId);
    }
    if (i < mDaysPerWeek + 1) {
      label.setText(mDayLabels[i - 1]);
      label.setVisibility(View.VISIBLE);
    }
 else {
      label.setVisibility(View.GONE);
    }
  }
  mDayNamesHeader.invalidate();
}","/** 
 * Sets up the strings to be used by the header.
 */
private void setUpHeader(){
  final String[] tinyWeekdayNames=LocaleData.get(Locale.getDefault()).tinyWeekdayNames;
  mDayLabels=new String[mDaysPerWeek];
  for (int i=0; i < mDaysPerWeek; i++) {
    final int j=i + mFirstDayOfWeek;
    final int calendarDay=(j > Calendar.SATURDAY) ? j - Calendar.SATURDAY : j;
    mDayLabels[i]=tinyWeekdayNames[calendarDay];
  }
  TextView label=(TextView)mDayNamesHeader.getChildAt(0);
  if (mShowWeekNumber) {
    label.setVisibility(View.VISIBLE);
  }
 else {
    label.setVisibility(View.GONE);
  }
  final int count=mDayNamesHeader.getChildCount();
  for (int i=0; i < count - 1; i++) {
    label=(TextView)mDayNamesHeader.getChildAt(i + 1);
    if (mWeekDayTextAppearanceResId > -1) {
      label.setTextAppearance(mContext,mWeekDayTextAppearanceResId);
    }
    if (i < mDaysPerWeek) {
      label.setText(mDayLabels[i]);
      label.setVisibility(View.VISIBLE);
    }
 else {
      label.setVisibility(View.GONE);
    }
  }
  mDayNamesHeader.invalidate();
}"
1669,"/** 
 * Sets up the strings to be used by the header.
 */
private void setUpHeader(){
  mDayLabels=new String[mDaysPerWeek];
  for (int i=mFirstDayOfWeek, count=mFirstDayOfWeek + mDaysPerWeek; i < count; i++) {
    int calendarDay=(i > Calendar.SATURDAY) ? i - Calendar.SATURDAY : i;
    mDayLabels[i - mFirstDayOfWeek]=DateUtils.getDayOfWeekString(calendarDay,DateUtils.LENGTH_SHORTEST);
  }
  TextView label=(TextView)mDayNamesHeader.getChildAt(0);
  if (mShowWeekNumber) {
    label.setVisibility(View.VISIBLE);
  }
 else {
    label.setVisibility(View.GONE);
  }
  for (int i=1, count=mDayNamesHeader.getChildCount(); i < count; i++) {
    label=(TextView)mDayNamesHeader.getChildAt(i);
    if (mWeekDayTextAppearanceResId > -1) {
      label.setTextAppearance(mContext,mWeekDayTextAppearanceResId);
    }
    if (i < mDaysPerWeek + 1) {
      label.setText(mDayLabels[i - 1]);
      label.setVisibility(View.VISIBLE);
    }
 else {
      label.setVisibility(View.GONE);
    }
  }
  mDayNamesHeader.invalidate();
}","/** 
 * Sets up the strings to be used by the header.
 */
private void setUpHeader(){
  final String[] tinyWeekdayNames=LocaleData.get(Locale.getDefault()).tinyWeekdayNames;
  mDayLabels=new String[mDaysPerWeek];
  for (int i=0; i < mDaysPerWeek; i++) {
    final int j=i + mFirstDayOfWeek;
    final int calendarDay=(j > Calendar.SATURDAY) ? j - Calendar.SATURDAY : j;
    mDayLabels[i]=tinyWeekdayNames[calendarDay];
  }
  TextView label=(TextView)mDayNamesHeader.getChildAt(0);
  if (mShowWeekNumber) {
    label.setVisibility(View.VISIBLE);
  }
 else {
    label.setVisibility(View.GONE);
  }
  final int count=mDayNamesHeader.getChildCount();
  for (int i=0; i < count - 1; i++) {
    label=(TextView)mDayNamesHeader.getChildAt(i + 1);
    if (mWeekDayTextAppearanceResId > -1) {
      label.setTextAppearance(mContext,mWeekDayTextAppearanceResId);
    }
    if (i < mDaysPerWeek) {
      label.setText(mDayLabels[i]);
      label.setVisibility(View.VISIBLE);
    }
 else {
      label.setVisibility(View.GONE);
    }
  }
  mDayNamesHeader.invalidate();
}"
1670,"/** 
 * Sets up the strings to be used by the header.
 */
private void setUpHeader(){
  mDayLabels=new String[mDaysPerWeek];
  for (int i=mFirstDayOfWeek, count=mFirstDayOfWeek + mDaysPerWeek; i < count; i++) {
    int calendarDay=(i > Calendar.SATURDAY) ? i - Calendar.SATURDAY : i;
    mDayLabels[i - mFirstDayOfWeek]=DateUtils.getDayOfWeekString(calendarDay,DateUtils.LENGTH_SHORTEST);
  }
  TextView label=(TextView)mDayNamesHeader.getChildAt(0);
  if (mShowWeekNumber) {
    label.setVisibility(View.VISIBLE);
  }
 else {
    label.setVisibility(View.GONE);
  }
  for (int i=1, count=mDayNamesHeader.getChildCount(); i < count; i++) {
    label=(TextView)mDayNamesHeader.getChildAt(i);
    if (mWeekDayTextAppearanceResId > -1) {
      label.setTextAppearance(mContext,mWeekDayTextAppearanceResId);
    }
    if (i < mDaysPerWeek + 1) {
      label.setText(mDayLabels[i - 1]);
      label.setVisibility(View.VISIBLE);
    }
 else {
      label.setVisibility(View.GONE);
    }
  }
  mDayNamesHeader.invalidate();
}","/** 
 * Sets up the strings to be used by the header.
 */
private void setUpHeader(){
  final String[] tinyWeekdayNames=LocaleData.get(Locale.getDefault()).tinyWeekdayNames;
  mDayLabels=new String[mDaysPerWeek];
  for (int i=0; i < mDaysPerWeek; i++) {
    final int j=i + mFirstDayOfWeek;
    final int calendarDay=(j > Calendar.SATURDAY) ? j - Calendar.SATURDAY : j;
    mDayLabels[i]=tinyWeekdayNames[calendarDay];
  }
  TextView label=(TextView)mDayNamesHeader.getChildAt(0);
  if (mShowWeekNumber) {
    label.setVisibility(View.VISIBLE);
  }
 else {
    label.setVisibility(View.GONE);
  }
  final int count=mDayNamesHeader.getChildCount();
  for (int i=0; i < count - 1; i++) {
    label=(TextView)mDayNamesHeader.getChildAt(i + 1);
    if (mWeekDayTextAppearanceResId > -1) {
      label.setTextAppearance(mContext,mWeekDayTextAppearanceResId);
    }
    if (i < mDaysPerWeek) {
      label.setText(mDayLabels[i]);
      label.setVisibility(View.VISIBLE);
    }
 else {
      label.setVisibility(View.GONE);
    }
  }
  mDayNamesHeader.invalidate();
}"
1671,"/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  int currentHour=getCurrentHour();
  mIs24HourView=is24HourView;
  getHourFormatData();
  updateHourControl();
  setCurrentHour(currentHour);
  updateMinuteControl();
  updateAmPmControl();
}","/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  int currentHour=getCurrentHour();
  mIs24HourView=is24HourView;
  getHourFormatData();
  updateHourControl();
  setCurrentHour(currentHour,false);
  updateMinuteControl();
  updateAmPmControl();
}"
1672,"/** 
 * Set the current hour.
 */
public void setCurrentHour(Integer currentHour){
  if (currentHour == null || currentHour == getCurrentHour()) {
    return;
  }
  if (!is24HourView()) {
    if (currentHour >= HOURS_IN_HALF_DAY) {
      mIsAm=false;
      if (currentHour > HOURS_IN_HALF_DAY) {
        currentHour=currentHour - HOURS_IN_HALF_DAY;
      }
    }
 else {
      mIsAm=true;
      if (currentHour == 0) {
        currentHour=HOURS_IN_HALF_DAY;
      }
    }
    updateAmPmControl();
  }
  mHourSpinner.setValue(currentHour);
  onTimeChanged();
}","private void setCurrentHour(Integer currentHour,boolean notifyTimeChanged){
  if (currentHour == null || currentHour == getCurrentHour()) {
    return;
  }
  if (!is24HourView()) {
    if (currentHour >= HOURS_IN_HALF_DAY) {
      mIsAm=false;
      if (currentHour > HOURS_IN_HALF_DAY) {
        currentHour=currentHour - HOURS_IN_HALF_DAY;
      }
    }
 else {
      mIsAm=true;
      if (currentHour == 0) {
        currentHour=HOURS_IN_HALF_DAY;
      }
    }
    updateAmPmControl();
  }
  mHourSpinner.setValue(currentHour);
  if (notifyTimeChanged) {
    onTimeChanged();
  }
}"
1673,"/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  int currentHour=getCurrentHour();
  mIs24HourView=is24HourView;
  getHourFormatData();
  updateHourControl();
  setCurrentHour(currentHour);
  updateMinuteControl();
  updateAmPmControl();
}","/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  int currentHour=getCurrentHour();
  mIs24HourView=is24HourView;
  getHourFormatData();
  updateHourControl();
  setCurrentHour(currentHour,false);
  updateMinuteControl();
  updateAmPmControl();
}"
1674,"/** 
 * Set the current hour.
 */
public void setCurrentHour(Integer currentHour){
  if (currentHour == null || currentHour == getCurrentHour()) {
    return;
  }
  if (!is24HourView()) {
    if (currentHour >= HOURS_IN_HALF_DAY) {
      mIsAm=false;
      if (currentHour > HOURS_IN_HALF_DAY) {
        currentHour=currentHour - HOURS_IN_HALF_DAY;
      }
    }
 else {
      mIsAm=true;
      if (currentHour == 0) {
        currentHour=HOURS_IN_HALF_DAY;
      }
    }
    updateAmPmControl();
  }
  mHourSpinner.setValue(currentHour);
  onTimeChanged();
}","private void setCurrentHour(Integer currentHour,boolean notifyTimeChanged){
  if (currentHour == null || currentHour == getCurrentHour()) {
    return;
  }
  if (!is24HourView()) {
    if (currentHour >= HOURS_IN_HALF_DAY) {
      mIsAm=false;
      if (currentHour > HOURS_IN_HALF_DAY) {
        currentHour=currentHour - HOURS_IN_HALF_DAY;
      }
    }
 else {
      mIsAm=true;
      if (currentHour == 0) {
        currentHour=HOURS_IN_HALF_DAY;
      }
    }
    updateAmPmControl();
  }
  mHourSpinner.setValue(currentHour);
  if (notifyTimeChanged) {
    onTimeChanged();
  }
}"
1675,"/** 
 * Get the format for this image. This format determines the number of ByteBuffers needed to represent the image, and the general layout of the pixel data in each in ByteBuffer. The format is one of the values from  {@link android.graphics.ImageFormat}. The mapping between the formats and the planes is as follows: <table> <th> <td>Format</td> <td>Plane count</td> <td>Layout details</td> </th> <tr> <td>  {@link android.graphics.ImageFormat#JPEG}</td> <td>1</td> <td>Compressed data, so row and pixel strides are 0. To uncompress, use  {@link android.graphics.BitmapFactory#decodeByteArray}.</td> </tr> <tr> <td>  {@link android.graphics.ImageFormat#YUV_420_888}</td> <td>3</td> <td>A luminance plane followed by the Cb and Cr chroma planes. The chroma planes have half the width and height of the luminance plane (4:2:0 subsampling). Each pixel sample in each plane has 8 bits. Each plane has its own row stride and pixel stride.</td> </tr> <tr> <td>  {@link android.graphics.ImageFormat#RAW_SENSOR}</td> <td>1</td> <td>A single plane of raw sensor image data, with 16 bits per color sample. The details of the layout need to be queried from the source of the raw sensor data, such as  {@link android.hardware.camera2.CameraDevice}. </td> </tr> </table>
 * @see android.graphics.ImageFormat
 */
public int getFormat();","/** 
 * Get the format for this image. This format determines the number of ByteBuffers needed to represent the image, and the general layout of the pixel data in each in ByteBuffer. The format is one of the values from  {@link android.graphics.ImageFormat}. The mapping between the formats and the planes is as follows: <table> <tr> <th>Format</th> <th>Plane count</th> <th>Layout details</th> </tr> <tr> <td>  {@link android.graphics.ImageFormat#JPEG}</td> <td>1</td> <td>Compressed data, so row and pixel strides are 0. To uncompress, use  {@link android.graphics.BitmapFactory#decodeByteArray}.</td> </tr> <tr> <td>  {@link android.graphics.ImageFormat#YUV_420_888}</td> <td>3</td> <td>A luminance plane followed by the Cb and Cr chroma planes. The chroma planes have half the width and height of the luminance plane (4:2:0 subsampling). Each pixel sample in each plane has 8 bits. Each plane has its own row stride and pixel stride.</td> </tr> <tr> <td>  {@link android.graphics.ImageFormat#RAW_SENSOR}</td> <td>1</td> <td>A single plane of raw sensor image data, with 16 bits per color sample. The details of the layout need to be queried from the source of the raw sensor data, such as  {@link android.hardware.camera2.CameraDevice}. </td> </tr> </table>
 * @see android.graphics.ImageFormat
 */
public int getFormat();"
1676,"/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  int currentHour=getCurrentHour();
  mIs24HourView=is24HourView;
  getHourFormatData();
  updateHourControl();
  setCurrentHour(currentHour);
  updateMinuteControl();
  updateAmPmControl();
}","/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  int currentHour=getCurrentHour();
  mIs24HourView=is24HourView;
  getHourFormatData();
  updateHourControl();
  setCurrentHour(currentHour,false);
  updateMinuteControl();
  updateAmPmControl();
}"
1677,"/** 
 * Set the current hour.
 */
public void setCurrentHour(Integer currentHour){
  if (currentHour == null || currentHour == getCurrentHour()) {
    return;
  }
  if (!is24HourView()) {
    if (currentHour >= HOURS_IN_HALF_DAY) {
      mIsAm=false;
      if (currentHour > HOURS_IN_HALF_DAY) {
        currentHour=currentHour - HOURS_IN_HALF_DAY;
      }
    }
 else {
      mIsAm=true;
      if (currentHour == 0) {
        currentHour=HOURS_IN_HALF_DAY;
      }
    }
    updateAmPmControl();
  }
  mHourSpinner.setValue(currentHour);
  onTimeChanged();
}","private void setCurrentHour(Integer currentHour,boolean notifyTimeChanged){
  if (currentHour == null || currentHour == getCurrentHour()) {
    return;
  }
  if (!is24HourView()) {
    if (currentHour >= HOURS_IN_HALF_DAY) {
      mIsAm=false;
      if (currentHour > HOURS_IN_HALF_DAY) {
        currentHour=currentHour - HOURS_IN_HALF_DAY;
      }
    }
 else {
      mIsAm=true;
      if (currentHour == 0) {
        currentHour=HOURS_IN_HALF_DAY;
      }
    }
    updateAmPmControl();
  }
  mHourSpinner.setValue(currentHour);
  if (notifyTimeChanged) {
    onTimeChanged();
  }
}"
1678,"/** 
 * Get the format for this image. This format determines the number of ByteBuffers needed to represent the image, and the general layout of the pixel data in each in ByteBuffer. The format is one of the values from  {@link android.graphics.ImageFormat}. The mapping between the formats and the planes is as follows: <table> <th> <td>Format</td> <td>Plane count</td> <td>Layout details</td> </th> <tr> <td>  {@link android.graphics.ImageFormat#JPEG}</td> <td>1</td> <td>Compressed data, so row and pixel strides are 0. To uncompress, use  {@link android.graphics.BitmapFactory#decodeByteArray}.</td> </tr> <tr> <td>  {@link android.graphics.ImageFormat#YUV_420_888}</td> <td>3</td> <td>A luminance plane followed by the Cb and Cr chroma planes. The chroma planes have half the width and height of the luminance plane (4:2:0 subsampling). Each pixel sample in each plane has 8 bits. Each plane has its own row stride and pixel stride.</td> </tr> <tr> <td>  {@link android.graphics.ImageFormat#RAW_SENSOR}</td> <td>1</td> <td>A single plane of raw sensor image data, with 16 bits per color sample. The details of the layout need to be queried from the source of the raw sensor data, such as  {@link android.hardware.camera2.CameraDevice}. </td> </tr> </table>
 * @see android.graphics.ImageFormat
 */
public int getFormat();","/** 
 * Get the format for this image. This format determines the number of ByteBuffers needed to represent the image, and the general layout of the pixel data in each in ByteBuffer. The format is one of the values from  {@link android.graphics.ImageFormat}. The mapping between the formats and the planes is as follows: <table> <tr> <th>Format</th> <th>Plane count</th> <th>Layout details</th> </tr> <tr> <td>  {@link android.graphics.ImageFormat#JPEG}</td> <td>1</td> <td>Compressed data, so row and pixel strides are 0. To uncompress, use  {@link android.graphics.BitmapFactory#decodeByteArray}.</td> </tr> <tr> <td>  {@link android.graphics.ImageFormat#YUV_420_888}</td> <td>3</td> <td>A luminance plane followed by the Cb and Cr chroma planes. The chroma planes have half the width and height of the luminance plane (4:2:0 subsampling). Each pixel sample in each plane has 8 bits. Each plane has its own row stride and pixel stride.</td> </tr> <tr> <td>  {@link android.graphics.ImageFormat#RAW_SENSOR}</td> <td>1</td> <td>A single plane of raw sensor image data, with 16 bits per color sample. The details of the layout need to be queried from the source of the raw sensor data, such as  {@link android.hardware.camera2.CameraDevice}. </td> </tr> </table>
 * @see android.graphics.ImageFormat
 */
public int getFormat();"
1679,"/** 
 * Get the format for this image. This format determines the number of ByteBuffers needed to represent the image, and the general layout of the pixel data in each in ByteBuffer. The format is one of the values from  {@link android.graphics.ImageFormat}. The mapping between the formats and the planes is as follows: <table> <th> <td>Format</td> <td>Plane count</td> <td>Layout details</td> </th> <tr> <td>  {@link android.graphics.ImageFormat#JPEG}</td> <td>1</td> <td>Compressed data, so row and pixel strides are 0. To uncompress, use  {@link android.graphics.BitmapFactory#decodeByteArray}.</td> </tr> <tr> <td>  {@link android.graphics.ImageFormat#YUV_420_888}</td> <td>3</td> <td>A luminance plane followed by the Cb and Cr chroma planes. The chroma planes have half the width and height of the luminance plane (4:2:0 subsampling). Each pixel sample in each plane has 8 bits. Each plane has its own row stride and pixel stride.</td> </tr> <tr> <td>  {@link android.graphics.ImageFormat#RAW_SENSOR}</td> <td>1</td> <td>A single plane of raw sensor image data, with 16 bits per color sample. The details of the layout need to be queried from the source of the raw sensor data, such as  {@link android.hardware.camera2.CameraDevice}. </td> </tr> </table>
 * @see android.graphics.ImageFormat
 */
public int getFormat();","/** 
 * Get the format for this image. This format determines the number of ByteBuffers needed to represent the image, and the general layout of the pixel data in each in ByteBuffer. The format is one of the values from  {@link android.graphics.ImageFormat}. The mapping between the formats and the planes is as follows: <table> <tr> <th>Format</th> <th>Plane count</th> <th>Layout details</th> </tr> <tr> <td>  {@link android.graphics.ImageFormat#JPEG}</td> <td>1</td> <td>Compressed data, so row and pixel strides are 0. To uncompress, use  {@link android.graphics.BitmapFactory#decodeByteArray}.</td> </tr> <tr> <td>  {@link android.graphics.ImageFormat#YUV_420_888}</td> <td>3</td> <td>A luminance plane followed by the Cb and Cr chroma planes. The chroma planes have half the width and height of the luminance plane (4:2:0 subsampling). Each pixel sample in each plane has 8 bits. Each plane has its own row stride and pixel stride.</td> </tr> <tr> <td>  {@link android.graphics.ImageFormat#RAW_SENSOR}</td> <td>1</td> <td>A single plane of raw sensor image data, with 16 bits per color sample. The details of the layout need to be queried from the source of the raw sensor data, such as  {@link android.hardware.camera2.CameraDevice}. </td> </tr> </table>
 * @see android.graphics.ImageFormat
 */
public int getFormat();"
1680,"final void freeTextLayoutCachesIfNeeded(int configDiff){
  if (configDiff != 0) {
    boolean hasLocaleConfigChange=((configDiff & ActivityInfo.CONFIG_LOCALE) != 0);
    if (hasLocaleConfigChange) {
      Canvas.freeTextLayoutCaches();
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
    }
  }
}","static void freeTextLayoutCachesIfNeeded(int configDiff){
  if (configDiff != 0) {
    boolean hasLocaleConfigChange=((configDiff & ActivityInfo.CONFIG_LOCALE) != 0);
    if (hasLocaleConfigChange) {
      Canvas.freeTextLayoutCaches();
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
    }
  }
}"
1681,"@Override protected void onDetachedFromWindow(){
  cancelClearAnimation();
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  cancelClearAnimation();
}"
1682,"/** 
 * Reset native resources. This is called when cleaning up the state of display lists during destruction of hardware resources, to ensure that we do not hold onto obsolete resources after related resources are gone.
 * @hide
 */
public abstract void reset();","/** 
 * Reset native resources. This is called when cleaning up the state of display lists during destruction of hardware resources, to ensure that we do not hold onto obsolete resources after related resources are gone.
 * @see #clear()
 * @hide
 */
public abstract void reset();"
1683,"/** 
 * Clears resources held onto by this display list. After calling this method  {@link #isValid()} will return false.
 * @see #isValid()
 */
public abstract void clear();","/** 
 * Clears resources held onto by this display list. After calling this method  {@link #isValid()} will return false.
 * @see #isValid()
 * @see #reset()
 */
public abstract void clear();"
1684,"@Override public void reset(){
  if (hasNativeDisplayList()) {
    nReset(mFinalizer.mNativeDisplayList);
  }
}","@Override public void reset(){
  if (hasNativeDisplayList()) {
    nReset(mFinalizer.mNativeDisplayList);
  }
  clear();
}"
1685,"/** 
 * Destroys all hardware rendering resources. This method is invoked when the system needs to reclaim resources. Upon execution of this method, you should free any OpenGL resources created by the view. Note: you <strong>must</strong> call <code>super.destroyHardwareResources()</code> when overriding this method.
 * @hide
 */
protected void destroyHardwareResources(){
  clearDisplayList();
  destroyLayer(true);
}","/** 
 * Destroys all hardware rendering resources. This method is invoked when the system needs to reclaim resources. Upon execution of this method, you should free any OpenGL resources created by the view. Note: you <strong>must</strong> call <code>super.destroyHardwareResources()</code> when overriding this method.
 * @hide
 */
protected void destroyHardwareResources(){
  resetDisplayList();
  destroyLayer(true);
}"
1686,"private void cleanupDraw(){
  if (mAttachInfo != null) {
    if (mDisplayList != null) {
      mDisplayList.markDirty();
      mAttachInfo.mViewRootImpl.enqueueDisplayList(mDisplayList);
    }
    mAttachInfo.mViewRootImpl.cancelInvalidate(this);
  }
 else {
    clearDisplayList();
  }
}","private void cleanupDraw(){
  if (mAttachInfo != null) {
    if (mDisplayList != null) {
      mDisplayList.markDirty();
      mAttachInfo.mViewRootImpl.enqueueDisplayList(mDisplayList);
    }
    mAttachInfo.mViewRootImpl.cancelInvalidate(this);
  }
 else {
    resetDisplayList();
  }
}"
1687,"/** 
 * Destroys this View's hardware layer if possible.
 * @return True if the layer was destroyed, false otherwise.
 * @see #setLayerType(int,android.graphics.Paint)
 * @see #LAYER_TYPE_HARDWARE
 */
boolean destroyLayer(boolean valid){
  if (mHardwareLayer != null) {
    AttachInfo info=mAttachInfo;
    if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled() && (valid || info.mHardwareRenderer.validate())) {
      info.mHardwareRenderer.cancelLayerUpdate(mHardwareLayer);
      mHardwareLayer.destroy();
      mHardwareLayer=null;
      if (mDisplayList != null) {
        mDisplayList.reset();
      }
      invalidate(true);
      invalidateParentCaches();
    }
    return true;
  }
  return false;
}","/** 
 * Destroys this View's hardware layer if possible.
 * @return True if the layer was destroyed, false otherwise.
 * @see #setLayerType(int,android.graphics.Paint)
 * @see #LAYER_TYPE_HARDWARE
 */
boolean destroyLayer(boolean valid){
  if (mHardwareLayer != null) {
    AttachInfo info=mAttachInfo;
    if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled() && (valid || info.mHardwareRenderer.validate())) {
      info.mHardwareRenderer.cancelLayerUpdate(mHardwareLayer);
      mHardwareLayer.destroy();
      mHardwareLayer=null;
      invalidate(true);
      invalidateParentCaches();
    }
    return true;
  }
  return false;
}"
1688,"void destroyHardwareLayers(){
  if (mThread != Thread.currentThread()) {
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      HardwareRenderer.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
    }
  }
 else {
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      mAttachInfo.mHardwareRenderer.destroyLayers(mView);
    }
  }
}","void destroyHardwareLayers(){
  if (mThread != Thread.currentThread()) {
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      HardwareRenderer.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
    }
  }
 else {
    invalidateDisplayLists();
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      mAttachInfo.mHardwareRenderer.destroyLayers(mView);
    }
  }
}"
1689,"void invalidateDisplayLists(){
  final ArrayList<DisplayList> displayLists=mDisplayLists;
  final int count=displayLists.size();
  for (int i=0; i < count; i++) {
    final DisplayList displayList=displayLists.get(i);
    if (displayList.isDirty()) {
      displayList.clear();
    }
  }
  displayLists.clear();
}","void invalidateDisplayLists(){
  final ArrayList<DisplayList> displayLists=mDisplayLists;
  final int count=displayLists.size();
  for (int i=0; i < count; i++) {
    final DisplayList displayList=displayLists.get(i);
    if (displayList.isDirty()) {
      displayList.reset();
    }
  }
  displayLists.clear();
}"
1690,"void destroyHardwareResources(){
  if (mAttachInfo.mHardwareRenderer != null) {
    if (mAttachInfo.mHardwareRenderer.isEnabled()) {
      mAttachInfo.mHardwareRenderer.destroyLayers(mView);
    }
    mAttachInfo.mHardwareRenderer.destroy(false);
  }
}","void destroyHardwareResources(){
  invalidateDisplayLists();
  if (mAttachInfo.mHardwareRenderer != null) {
    mAttachInfo.mHardwareRenderer.destroyHardwareResources(mView);
    mAttachInfo.mHardwareRenderer.destroy(false);
  }
}"
1691,"public void startTrimMemory(int level){
  if (HardwareRenderer.isAvailable()) {
    if (level >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE || (level >= ComponentCallbacks2.TRIM_MEMORY_MODERATE && !ActivityManager.isHighEndGfx())) {
synchronized (mLock) {
        for (int i=mRoots.size() - 1; i >= 0; --i) {
          mRoots.get(i).terminateHardwareResources();
        }
      }
      mNeedsEglTerminate=true;
      HardwareRenderer.startTrimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
      return;
    }
    HardwareRenderer.startTrimMemory(level);
  }
}","public void startTrimMemory(int level){
  if (HardwareRenderer.isAvailable()) {
    if (level >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE || (level >= ComponentCallbacks2.TRIM_MEMORY_MODERATE && !ActivityManager.isHighEndGfx())) {
synchronized (mLock) {
        for (int i=mRoots.size() - 1; i >= 0; --i) {
          mRoots.get(i).destroyHardwareResources();
        }
      }
      mNeedsEglTerminate=true;
      HardwareRenderer.startTrimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
      return;
    }
    HardwareRenderer.startTrimMemory(level);
  }
}"
1692,"@Override protected void onDetachedFromWindow(){
  removeAllCallbacks();
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  removeAllCallbacks();
}"
1693,"final void freeTextLayoutCachesIfNeeded(int configDiff){
  if (configDiff != 0) {
    boolean hasLocaleConfigChange=((configDiff & ActivityInfo.CONFIG_LOCALE) != 0);
    if (hasLocaleConfigChange) {
      Canvas.freeTextLayoutCaches();
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
    }
  }
}","static void freeTextLayoutCachesIfNeeded(int configDiff){
  if (configDiff != 0) {
    boolean hasLocaleConfigChange=((configDiff & ActivityInfo.CONFIG_LOCALE) != 0);
    if (hasLocaleConfigChange) {
      Canvas.freeTextLayoutCaches();
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
    }
  }
}"
1694,"@Override protected void onDetachedFromWindow(){
  cancelClearAnimation();
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  cancelClearAnimation();
}"
1695,"/** 
 * Reset native resources. This is called when cleaning up the state of display lists during destruction of hardware resources, to ensure that we do not hold onto obsolete resources after related resources are gone.
 * @hide
 */
public abstract void reset();","/** 
 * Reset native resources. This is called when cleaning up the state of display lists during destruction of hardware resources, to ensure that we do not hold onto obsolete resources after related resources are gone.
 * @see #clear()
 * @hide
 */
public abstract void reset();"
1696,"/** 
 * Clears resources held onto by this display list. After calling this method  {@link #isValid()} will return false.
 * @see #isValid()
 */
public abstract void clear();","/** 
 * Clears resources held onto by this display list. After calling this method  {@link #isValid()} will return false.
 * @see #isValid()
 * @see #reset()
 */
public abstract void clear();"
1697,"@Override public void reset(){
  if (hasNativeDisplayList()) {
    nReset(mFinalizer.mNativeDisplayList);
  }
}","@Override public void reset(){
  if (hasNativeDisplayList()) {
    nReset(mFinalizer.mNativeDisplayList);
  }
  clear();
}"
1698,"/** 
 * Destroys all hardware rendering resources. This method is invoked when the system needs to reclaim resources. Upon execution of this method, you should free any OpenGL resources created by the view. Note: you <strong>must</strong> call <code>super.destroyHardwareResources()</code> when overriding this method.
 * @hide
 */
protected void destroyHardwareResources(){
  clearDisplayList();
  destroyLayer(true);
}","/** 
 * Destroys all hardware rendering resources. This method is invoked when the system needs to reclaim resources. Upon execution of this method, you should free any OpenGL resources created by the view. Note: you <strong>must</strong> call <code>super.destroyHardwareResources()</code> when overriding this method.
 * @hide
 */
protected void destroyHardwareResources(){
  resetDisplayList();
  destroyLayer(true);
}"
1699,"private void cleanupDraw(){
  if (mAttachInfo != null) {
    if (mDisplayList != null) {
      mDisplayList.markDirty();
      mAttachInfo.mViewRootImpl.enqueueDisplayList(mDisplayList);
    }
    mAttachInfo.mViewRootImpl.cancelInvalidate(this);
  }
 else {
    clearDisplayList();
  }
}","private void cleanupDraw(){
  if (mAttachInfo != null) {
    if (mDisplayList != null) {
      mDisplayList.markDirty();
      mAttachInfo.mViewRootImpl.enqueueDisplayList(mDisplayList);
    }
    mAttachInfo.mViewRootImpl.cancelInvalidate(this);
  }
 else {
    resetDisplayList();
  }
}"
1700,"/** 
 * Destroys this View's hardware layer if possible.
 * @return True if the layer was destroyed, false otherwise.
 * @see #setLayerType(int,android.graphics.Paint)
 * @see #LAYER_TYPE_HARDWARE
 */
boolean destroyLayer(boolean valid){
  if (mHardwareLayer != null) {
    AttachInfo info=mAttachInfo;
    if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled() && (valid || info.mHardwareRenderer.validate())) {
      info.mHardwareRenderer.cancelLayerUpdate(mHardwareLayer);
      mHardwareLayer.destroy();
      mHardwareLayer=null;
      if (mDisplayList != null) {
        mDisplayList.reset();
      }
      invalidate(true);
      invalidateParentCaches();
    }
    return true;
  }
  return false;
}","/** 
 * Destroys this View's hardware layer if possible.
 * @return True if the layer was destroyed, false otherwise.
 * @see #setLayerType(int,android.graphics.Paint)
 * @see #LAYER_TYPE_HARDWARE
 */
boolean destroyLayer(boolean valid){
  if (mHardwareLayer != null) {
    AttachInfo info=mAttachInfo;
    if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled() && (valid || info.mHardwareRenderer.validate())) {
      info.mHardwareRenderer.cancelLayerUpdate(mHardwareLayer);
      mHardwareLayer.destroy();
      mHardwareLayer=null;
      invalidate(true);
      invalidateParentCaches();
    }
    return true;
  }
  return false;
}"
1701,"void destroyHardwareLayers(){
  if (mThread != Thread.currentThread()) {
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      HardwareRenderer.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
    }
  }
 else {
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      mAttachInfo.mHardwareRenderer.destroyLayers(mView);
    }
  }
}","void destroyHardwareLayers(){
  if (mThread != Thread.currentThread()) {
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      HardwareRenderer.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
    }
  }
 else {
    invalidateDisplayLists();
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      mAttachInfo.mHardwareRenderer.destroyLayers(mView);
    }
  }
}"
1702,"void invalidateDisplayLists(){
  final ArrayList<DisplayList> displayLists=mDisplayLists;
  final int count=displayLists.size();
  for (int i=0; i < count; i++) {
    final DisplayList displayList=displayLists.get(i);
    if (displayList.isDirty()) {
      displayList.clear();
    }
  }
  displayLists.clear();
}","void invalidateDisplayLists(){
  final ArrayList<DisplayList> displayLists=mDisplayLists;
  final int count=displayLists.size();
  for (int i=0; i < count; i++) {
    final DisplayList displayList=displayLists.get(i);
    if (displayList.isDirty()) {
      displayList.reset();
    }
  }
  displayLists.clear();
}"
1703,"void destroyHardwareResources(){
  if (mAttachInfo.mHardwareRenderer != null) {
    if (mAttachInfo.mHardwareRenderer.isEnabled()) {
      mAttachInfo.mHardwareRenderer.destroyLayers(mView);
    }
    mAttachInfo.mHardwareRenderer.destroy(false);
  }
}","void destroyHardwareResources(){
  invalidateDisplayLists();
  if (mAttachInfo.mHardwareRenderer != null) {
    mAttachInfo.mHardwareRenderer.destroyHardwareResources(mView);
    mAttachInfo.mHardwareRenderer.destroy(false);
  }
}"
1704,"public void startTrimMemory(int level){
  if (HardwareRenderer.isAvailable()) {
    if (level >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE || (level >= ComponentCallbacks2.TRIM_MEMORY_MODERATE && !ActivityManager.isHighEndGfx())) {
synchronized (mLock) {
        for (int i=mRoots.size() - 1; i >= 0; --i) {
          mRoots.get(i).terminateHardwareResources();
        }
      }
      mNeedsEglTerminate=true;
      HardwareRenderer.startTrimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
      return;
    }
    HardwareRenderer.startTrimMemory(level);
  }
}","public void startTrimMemory(int level){
  if (HardwareRenderer.isAvailable()) {
    if (level >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE || (level >= ComponentCallbacks2.TRIM_MEMORY_MODERATE && !ActivityManager.isHighEndGfx())) {
synchronized (mLock) {
        for (int i=mRoots.size() - 1; i >= 0; --i) {
          mRoots.get(i).destroyHardwareResources();
        }
      }
      mNeedsEglTerminate=true;
      HardwareRenderer.startTrimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
      return;
    }
    HardwareRenderer.startTrimMemory(level);
  }
}"
1705,"@Override protected void onDetachedFromWindow(){
  removeAllCallbacks();
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  removeAllCallbacks();
}"
1706,"final void freeTextLayoutCachesIfNeeded(int configDiff){
  if (configDiff != 0) {
    boolean hasLocaleConfigChange=((configDiff & ActivityInfo.CONFIG_LOCALE) != 0);
    if (hasLocaleConfigChange) {
      Canvas.freeTextLayoutCaches();
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
    }
  }
}","static void freeTextLayoutCachesIfNeeded(int configDiff){
  if (configDiff != 0) {
    boolean hasLocaleConfigChange=((configDiff & ActivityInfo.CONFIG_LOCALE) != 0);
    if (hasLocaleConfigChange) {
      Canvas.freeTextLayoutCaches();
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
    }
  }
}"
1707,"@Override protected void onDetachedFromWindow(){
  cancelClearAnimation();
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  cancelClearAnimation();
}"
1708,"/** 
 * Reset native resources. This is called when cleaning up the state of display lists during destruction of hardware resources, to ensure that we do not hold onto obsolete resources after related resources are gone.
 * @hide
 */
public abstract void reset();","/** 
 * Reset native resources. This is called when cleaning up the state of display lists during destruction of hardware resources, to ensure that we do not hold onto obsolete resources after related resources are gone.
 * @see #clear()
 * @hide
 */
public abstract void reset();"
1709,"/** 
 * Clears resources held onto by this display list. After calling this method  {@link #isValid()} will return false.
 * @see #isValid()
 */
public abstract void clear();","/** 
 * Clears resources held onto by this display list. After calling this method  {@link #isValid()} will return false.
 * @see #isValid()
 * @see #reset()
 */
public abstract void clear();"
1710,"@Override public void reset(){
  if (hasNativeDisplayList()) {
    nReset(mFinalizer.mNativeDisplayList);
  }
}","@Override public void reset(){
  if (hasNativeDisplayList()) {
    nReset(mFinalizer.mNativeDisplayList);
  }
  clear();
}"
1711,"/** 
 * Destroys all hardware rendering resources. This method is invoked when the system needs to reclaim resources. Upon execution of this method, you should free any OpenGL resources created by the view. Note: you <strong>must</strong> call <code>super.destroyHardwareResources()</code> when overriding this method.
 * @hide
 */
protected void destroyHardwareResources(){
  clearDisplayList();
  destroyLayer(true);
}","/** 
 * Destroys all hardware rendering resources. This method is invoked when the system needs to reclaim resources. Upon execution of this method, you should free any OpenGL resources created by the view. Note: you <strong>must</strong> call <code>super.destroyHardwareResources()</code> when overriding this method.
 * @hide
 */
protected void destroyHardwareResources(){
  resetDisplayList();
  destroyLayer(true);
}"
1712,"private void cleanupDraw(){
  if (mAttachInfo != null) {
    if (mDisplayList != null) {
      mDisplayList.markDirty();
      mAttachInfo.mViewRootImpl.enqueueDisplayList(mDisplayList);
    }
    mAttachInfo.mViewRootImpl.cancelInvalidate(this);
  }
 else {
    clearDisplayList();
  }
}","private void cleanupDraw(){
  if (mAttachInfo != null) {
    if (mDisplayList != null) {
      mDisplayList.markDirty();
      mAttachInfo.mViewRootImpl.enqueueDisplayList(mDisplayList);
    }
    mAttachInfo.mViewRootImpl.cancelInvalidate(this);
  }
 else {
    resetDisplayList();
  }
}"
1713,"/** 
 * Destroys this View's hardware layer if possible.
 * @return True if the layer was destroyed, false otherwise.
 * @see #setLayerType(int,android.graphics.Paint)
 * @see #LAYER_TYPE_HARDWARE
 */
boolean destroyLayer(boolean valid){
  if (mHardwareLayer != null) {
    AttachInfo info=mAttachInfo;
    if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled() && (valid || info.mHardwareRenderer.validate())) {
      info.mHardwareRenderer.cancelLayerUpdate(mHardwareLayer);
      mHardwareLayer.destroy();
      mHardwareLayer=null;
      if (mDisplayList != null) {
        mDisplayList.reset();
      }
      invalidate(true);
      invalidateParentCaches();
    }
    return true;
  }
  return false;
}","/** 
 * Destroys this View's hardware layer if possible.
 * @return True if the layer was destroyed, false otherwise.
 * @see #setLayerType(int,android.graphics.Paint)
 * @see #LAYER_TYPE_HARDWARE
 */
boolean destroyLayer(boolean valid){
  if (mHardwareLayer != null) {
    AttachInfo info=mAttachInfo;
    if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled() && (valid || info.mHardwareRenderer.validate())) {
      info.mHardwareRenderer.cancelLayerUpdate(mHardwareLayer);
      mHardwareLayer.destroy();
      mHardwareLayer=null;
      invalidate(true);
      invalidateParentCaches();
    }
    return true;
  }
  return false;
}"
1714,"void destroyHardwareLayers(){
  if (mThread != Thread.currentThread()) {
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      HardwareRenderer.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
    }
  }
 else {
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      mAttachInfo.mHardwareRenderer.destroyLayers(mView);
    }
  }
}","void destroyHardwareLayers(){
  if (mThread != Thread.currentThread()) {
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      HardwareRenderer.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
    }
  }
 else {
    invalidateDisplayLists();
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      mAttachInfo.mHardwareRenderer.destroyLayers(mView);
    }
  }
}"
1715,"void invalidateDisplayLists(){
  final ArrayList<DisplayList> displayLists=mDisplayLists;
  final int count=displayLists.size();
  for (int i=0; i < count; i++) {
    final DisplayList displayList=displayLists.get(i);
    if (displayList.isDirty()) {
      displayList.clear();
    }
  }
  displayLists.clear();
}","void invalidateDisplayLists(){
  final ArrayList<DisplayList> displayLists=mDisplayLists;
  final int count=displayLists.size();
  for (int i=0; i < count; i++) {
    final DisplayList displayList=displayLists.get(i);
    if (displayList.isDirty()) {
      displayList.reset();
    }
  }
  displayLists.clear();
}"
1716,"void destroyHardwareResources(){
  if (mAttachInfo.mHardwareRenderer != null) {
    if (mAttachInfo.mHardwareRenderer.isEnabled()) {
      mAttachInfo.mHardwareRenderer.destroyLayers(mView);
    }
    mAttachInfo.mHardwareRenderer.destroy(false);
  }
}","void destroyHardwareResources(){
  invalidateDisplayLists();
  if (mAttachInfo.mHardwareRenderer != null) {
    mAttachInfo.mHardwareRenderer.destroyHardwareResources(mView);
    mAttachInfo.mHardwareRenderer.destroy(false);
  }
}"
1717,"public void startTrimMemory(int level){
  if (HardwareRenderer.isAvailable()) {
    if (level >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE || (level >= ComponentCallbacks2.TRIM_MEMORY_MODERATE && !ActivityManager.isHighEndGfx())) {
synchronized (mLock) {
        for (int i=mRoots.size() - 1; i >= 0; --i) {
          mRoots.get(i).terminateHardwareResources();
        }
      }
      mNeedsEglTerminate=true;
      HardwareRenderer.startTrimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
      return;
    }
    HardwareRenderer.startTrimMemory(level);
  }
}","public void startTrimMemory(int level){
  if (HardwareRenderer.isAvailable()) {
    if (level >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE || (level >= ComponentCallbacks2.TRIM_MEMORY_MODERATE && !ActivityManager.isHighEndGfx())) {
synchronized (mLock) {
        for (int i=mRoots.size() - 1; i >= 0; --i) {
          mRoots.get(i).destroyHardwareResources();
        }
      }
      mNeedsEglTerminate=true;
      HardwareRenderer.startTrimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
      return;
    }
    HardwareRenderer.startTrimMemory(level);
  }
}"
1718,"@Override protected void onDetachedFromWindow(){
  removeAllCallbacks();
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  removeAllCallbacks();
}"
1719,"public TimePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  setCurrentLocale(Locale.getDefault());
  TypedArray attributesArray=context.obtainStyledAttributes(attrs,R.styleable.TimePicker,defStyle,0);
  int layoutResourceId=attributesArray.getResourceId(R.styleable.TimePicker_internalLayout,R.layout.time_picker);
  attributesArray.recycle();
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(layoutResourceId,this,true);
  mHourSpinner=(NumberPicker)findViewById(R.id.hour);
  mHourSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      if (!is24HourView()) {
        if ((oldVal == HOURS_IN_HALF_DAY - 1 && newVal == HOURS_IN_HALF_DAY) || (oldVal == HOURS_IN_HALF_DAY && newVal == HOURS_IN_HALF_DAY - 1)) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
      }
      onTimeChanged();
    }
  }
);
  mHourSpinnerInput=(EditText)mHourSpinner.findViewById(R.id.numberpicker_input);
  mHourSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mDivider=(TextView)findViewById(R.id.divider);
  if (mDivider != null) {
    mDivider.setText(R.string.time_picker_separator);
  }
  mMinuteSpinner=(NumberPicker)findViewById(R.id.minute);
  mMinuteSpinner.setMinValue(0);
  mMinuteSpinner.setMaxValue(59);
  mMinuteSpinner.setOnLongPressUpdateInterval(100);
  mMinuteSpinner.setFormatter(NumberPicker.getTwoDigitFormatter());
  mMinuteSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      int minValue=mMinuteSpinner.getMinValue();
      int maxValue=mMinuteSpinner.getMaxValue();
      if (oldVal == maxValue && newVal == minValue) {
        int newHour=mHourSpinner.getValue() + 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
 else       if (oldVal == minValue && newVal == maxValue) {
        int newHour=mHourSpinner.getValue() - 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY - 1) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
      onTimeChanged();
    }
  }
);
  mMinuteSpinnerInput=(EditText)mMinuteSpinner.findViewById(R.id.numberpicker_input);
  mMinuteSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mAmPmStrings=new DateFormatSymbols().getAmPmStrings();
  View amPmView=findViewById(R.id.amPm);
  if (amPmView instanceof Button) {
    mAmPmSpinner=null;
    mAmPmSpinnerInput=null;
    mAmPmButton=(Button)amPmView;
    mAmPmButton.setOnClickListener(new OnClickListener(){
      public void onClick(      View button){
        button.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
  }
 else {
    mAmPmButton=null;
    mAmPmSpinner=(NumberPicker)amPmView;
    mAmPmSpinner.setMinValue(0);
    mAmPmSpinner.setMaxValue(1);
    mAmPmSpinner.setDisplayedValues(mAmPmStrings);
    mAmPmSpinner.setOnValueChangedListener(new OnValueChangeListener(){
      public void onValueChange(      NumberPicker picker,      int oldVal,      int newVal){
        updateInputState();
        picker.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
    mAmPmSpinnerInput=(EditText)mAmPmSpinner.findViewById(R.id.numberpicker_input);
    mAmPmSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_DONE);
  }
  updateHourControl();
  updateMinuteControl();
  updateAmPmControl();
  setOnTimeChangedListener(NO_OP_CHANGE_LISTENER);
  setCurrentHour(mTempCalendar.get(Calendar.HOUR_OF_DAY));
  setCurrentMinute(mTempCalendar.get(Calendar.MINUTE));
  if (!isEnabled()) {
    setEnabled(false);
  }
  setContentDescriptions();
  if (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
    setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
  }
}","public TimePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  setCurrentLocale(Locale.getDefault());
  TypedArray attributesArray=context.obtainStyledAttributes(attrs,R.styleable.TimePicker,defStyle,0);
  int layoutResourceId=attributesArray.getResourceId(R.styleable.TimePicker_internalLayout,R.layout.time_picker);
  attributesArray.recycle();
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(layoutResourceId,this,true);
  mHourSpinner=(NumberPicker)findViewById(R.id.hour);
  mHourSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      if (!is24HourView()) {
        if ((oldVal == HOURS_IN_HALF_DAY - 1 && newVal == HOURS_IN_HALF_DAY) || (oldVal == HOURS_IN_HALF_DAY && newVal == HOURS_IN_HALF_DAY - 1)) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
      }
      onTimeChanged();
    }
  }
);
  mHourSpinnerInput=(EditText)mHourSpinner.findViewById(R.id.numberpicker_input);
  mHourSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mDivider=(TextView)findViewById(R.id.divider);
  if (mDivider != null) {
    setDividerText();
  }
  mMinuteSpinner=(NumberPicker)findViewById(R.id.minute);
  mMinuteSpinner.setMinValue(0);
  mMinuteSpinner.setMaxValue(59);
  mMinuteSpinner.setOnLongPressUpdateInterval(100);
  mMinuteSpinner.setFormatter(NumberPicker.getTwoDigitFormatter());
  mMinuteSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      int minValue=mMinuteSpinner.getMinValue();
      int maxValue=mMinuteSpinner.getMaxValue();
      if (oldVal == maxValue && newVal == minValue) {
        int newHour=mHourSpinner.getValue() + 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
 else       if (oldVal == minValue && newVal == maxValue) {
        int newHour=mHourSpinner.getValue() - 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY - 1) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
      onTimeChanged();
    }
  }
);
  mMinuteSpinnerInput=(EditText)mMinuteSpinner.findViewById(R.id.numberpicker_input);
  mMinuteSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mAmPmStrings=new DateFormatSymbols().getAmPmStrings();
  View amPmView=findViewById(R.id.amPm);
  if (amPmView instanceof Button) {
    mAmPmSpinner=null;
    mAmPmSpinnerInput=null;
    mAmPmButton=(Button)amPmView;
    mAmPmButton.setOnClickListener(new OnClickListener(){
      public void onClick(      View button){
        button.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
  }
 else {
    mAmPmButton=null;
    mAmPmSpinner=(NumberPicker)amPmView;
    mAmPmSpinner.setMinValue(0);
    mAmPmSpinner.setMaxValue(1);
    mAmPmSpinner.setDisplayedValues(mAmPmStrings);
    mAmPmSpinner.setOnValueChangedListener(new OnValueChangeListener(){
      public void onValueChange(      NumberPicker picker,      int oldVal,      int newVal){
        updateInputState();
        picker.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
    mAmPmSpinnerInput=(EditText)mAmPmSpinner.findViewById(R.id.numberpicker_input);
    mAmPmSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_DONE);
  }
  if (isAmPmAtStart()) {
    ViewGroup amPmParent=(ViewGroup)findViewById(R.id.timePickerLayout);
    amPmParent.removeView(amPmView);
    amPmParent.addView(amPmView,0);
    ViewGroup.MarginLayoutParams lp=(ViewGroup.MarginLayoutParams)amPmView.getLayoutParams();
    final int startMargin=lp.getMarginStart();
    final int endMargin=lp.getMarginEnd();
    if (startMargin != endMargin) {
      lp.setMarginStart(endMargin);
      lp.setMarginEnd(startMargin);
    }
  }
  getHourFormatData();
  updateHourControl();
  updateMinuteControl();
  updateAmPmControl();
  setOnTimeChangedListener(NO_OP_CHANGE_LISTENER);
  setCurrentHour(mTempCalendar.get(Calendar.HOUR_OF_DAY));
  setCurrentMinute(mTempCalendar.get(Calendar.MINUTE));
  if (!isEnabled()) {
    setEnabled(false);
  }
  setContentDescriptions();
  if (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
    setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
  }
}"
1720,"private void updateHourControl(){
  if (is24HourView()) {
    mHourSpinner.setMinValue(0);
    mHourSpinner.setMaxValue(23);
    mHourSpinner.setFormatter(NumberPicker.getTwoDigitFormatter());
  }
 else {
    mHourSpinner.setMinValue(1);
    mHourSpinner.setMaxValue(12);
    mHourSpinner.setFormatter(null);
  }
}","private void updateHourControl(){
  if (is24HourView()) {
    if (mHourFormat == 'k') {
      mHourSpinner.setMinValue(1);
      mHourSpinner.setMaxValue(24);
    }
 else {
      mHourSpinner.setMinValue(0);
      mHourSpinner.setMaxValue(23);
    }
  }
 else {
    if (mHourFormat == 'K') {
      mHourSpinner.setMinValue(0);
      mHourSpinner.setMaxValue(11);
    }
 else {
      mHourSpinner.setMinValue(1);
      mHourSpinner.setMaxValue(12);
    }
  }
  mHourSpinner.setFormatter(mHourWithTwoDigit ? NumberPicker.getTwoDigitFormatter() : null);
}"
1721,"/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  mIs24HourView=is24HourView;
  int currentHour=getCurrentHour();
  updateHourControl();
  setCurrentHour(currentHour);
  updateMinuteControl();
  updateAmPmControl();
}","/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  int currentHour=getCurrentHour();
  mIs24HourView=is24HourView;
  getHourFormatData();
  updateHourControl();
  setCurrentHour(currentHour);
  updateMinuteControl();
  updateAmPmControl();
}"
1722,"public TimePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  setCurrentLocale(Locale.getDefault());
  TypedArray attributesArray=context.obtainStyledAttributes(attrs,R.styleable.TimePicker,defStyle,0);
  int layoutResourceId=attributesArray.getResourceId(R.styleable.TimePicker_internalLayout,R.layout.time_picker);
  attributesArray.recycle();
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(layoutResourceId,this,true);
  mHourSpinner=(NumberPicker)findViewById(R.id.hour);
  mHourSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      if (!is24HourView()) {
        if ((oldVal == HOURS_IN_HALF_DAY - 1 && newVal == HOURS_IN_HALF_DAY) || (oldVal == HOURS_IN_HALF_DAY && newVal == HOURS_IN_HALF_DAY - 1)) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
      }
      onTimeChanged();
    }
  }
);
  mHourSpinnerInput=(EditText)mHourSpinner.findViewById(R.id.numberpicker_input);
  mHourSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mDivider=(TextView)findViewById(R.id.divider);
  if (mDivider != null) {
    mDivider.setText(R.string.time_picker_separator);
  }
  mMinuteSpinner=(NumberPicker)findViewById(R.id.minute);
  mMinuteSpinner.setMinValue(0);
  mMinuteSpinner.setMaxValue(59);
  mMinuteSpinner.setOnLongPressUpdateInterval(100);
  mMinuteSpinner.setFormatter(NumberPicker.getTwoDigitFormatter());
  mMinuteSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      int minValue=mMinuteSpinner.getMinValue();
      int maxValue=mMinuteSpinner.getMaxValue();
      if (oldVal == maxValue && newVal == minValue) {
        int newHour=mHourSpinner.getValue() + 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
 else       if (oldVal == minValue && newVal == maxValue) {
        int newHour=mHourSpinner.getValue() - 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY - 1) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
      onTimeChanged();
    }
  }
);
  mMinuteSpinnerInput=(EditText)mMinuteSpinner.findViewById(R.id.numberpicker_input);
  mMinuteSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mAmPmStrings=new DateFormatSymbols().getAmPmStrings();
  View amPmView=findViewById(R.id.amPm);
  if (amPmView instanceof Button) {
    mAmPmSpinner=null;
    mAmPmSpinnerInput=null;
    mAmPmButton=(Button)amPmView;
    mAmPmButton.setOnClickListener(new OnClickListener(){
      public void onClick(      View button){
        button.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
  }
 else {
    mAmPmButton=null;
    mAmPmSpinner=(NumberPicker)amPmView;
    mAmPmSpinner.setMinValue(0);
    mAmPmSpinner.setMaxValue(1);
    mAmPmSpinner.setDisplayedValues(mAmPmStrings);
    mAmPmSpinner.setOnValueChangedListener(new OnValueChangeListener(){
      public void onValueChange(      NumberPicker picker,      int oldVal,      int newVal){
        updateInputState();
        picker.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
    mAmPmSpinnerInput=(EditText)mAmPmSpinner.findViewById(R.id.numberpicker_input);
    mAmPmSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_DONE);
  }
  updateHourControl();
  updateMinuteControl();
  updateAmPmControl();
  setOnTimeChangedListener(NO_OP_CHANGE_LISTENER);
  setCurrentHour(mTempCalendar.get(Calendar.HOUR_OF_DAY));
  setCurrentMinute(mTempCalendar.get(Calendar.MINUTE));
  if (!isEnabled()) {
    setEnabled(false);
  }
  setContentDescriptions();
  if (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
    setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
  }
}","public TimePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  setCurrentLocale(Locale.getDefault());
  TypedArray attributesArray=context.obtainStyledAttributes(attrs,R.styleable.TimePicker,defStyle,0);
  int layoutResourceId=attributesArray.getResourceId(R.styleable.TimePicker_internalLayout,R.layout.time_picker);
  attributesArray.recycle();
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(layoutResourceId,this,true);
  mHourSpinner=(NumberPicker)findViewById(R.id.hour);
  mHourSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      if (!is24HourView()) {
        if ((oldVal == HOURS_IN_HALF_DAY - 1 && newVal == HOURS_IN_HALF_DAY) || (oldVal == HOURS_IN_HALF_DAY && newVal == HOURS_IN_HALF_DAY - 1)) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
      }
      onTimeChanged();
    }
  }
);
  mHourSpinnerInput=(EditText)mHourSpinner.findViewById(R.id.numberpicker_input);
  mHourSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mDivider=(TextView)findViewById(R.id.divider);
  if (mDivider != null) {
    setDividerText();
  }
  mMinuteSpinner=(NumberPicker)findViewById(R.id.minute);
  mMinuteSpinner.setMinValue(0);
  mMinuteSpinner.setMaxValue(59);
  mMinuteSpinner.setOnLongPressUpdateInterval(100);
  mMinuteSpinner.setFormatter(NumberPicker.getTwoDigitFormatter());
  mMinuteSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      int minValue=mMinuteSpinner.getMinValue();
      int maxValue=mMinuteSpinner.getMaxValue();
      if (oldVal == maxValue && newVal == minValue) {
        int newHour=mHourSpinner.getValue() + 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
 else       if (oldVal == minValue && newVal == maxValue) {
        int newHour=mHourSpinner.getValue() - 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY - 1) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
      onTimeChanged();
    }
  }
);
  mMinuteSpinnerInput=(EditText)mMinuteSpinner.findViewById(R.id.numberpicker_input);
  mMinuteSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mAmPmStrings=new DateFormatSymbols().getAmPmStrings();
  View amPmView=findViewById(R.id.amPm);
  if (amPmView instanceof Button) {
    mAmPmSpinner=null;
    mAmPmSpinnerInput=null;
    mAmPmButton=(Button)amPmView;
    mAmPmButton.setOnClickListener(new OnClickListener(){
      public void onClick(      View button){
        button.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
  }
 else {
    mAmPmButton=null;
    mAmPmSpinner=(NumberPicker)amPmView;
    mAmPmSpinner.setMinValue(0);
    mAmPmSpinner.setMaxValue(1);
    mAmPmSpinner.setDisplayedValues(mAmPmStrings);
    mAmPmSpinner.setOnValueChangedListener(new OnValueChangeListener(){
      public void onValueChange(      NumberPicker picker,      int oldVal,      int newVal){
        updateInputState();
        picker.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
    mAmPmSpinnerInput=(EditText)mAmPmSpinner.findViewById(R.id.numberpicker_input);
    mAmPmSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_DONE);
  }
  if (isAmPmAtStart()) {
    ViewGroup amPmParent=(ViewGroup)findViewById(R.id.timePickerLayout);
    amPmParent.removeView(amPmView);
    amPmParent.addView(amPmView,0);
    ViewGroup.MarginLayoutParams lp=(ViewGroup.MarginLayoutParams)amPmView.getLayoutParams();
    final int startMargin=lp.getMarginStart();
    final int endMargin=lp.getMarginEnd();
    if (startMargin != endMargin) {
      lp.setMarginStart(endMargin);
      lp.setMarginEnd(startMargin);
    }
  }
  getHourFormatData();
  updateHourControl();
  updateMinuteControl();
  updateAmPmControl();
  setOnTimeChangedListener(NO_OP_CHANGE_LISTENER);
  setCurrentHour(mTempCalendar.get(Calendar.HOUR_OF_DAY));
  setCurrentMinute(mTempCalendar.get(Calendar.MINUTE));
  if (!isEnabled()) {
    setEnabled(false);
  }
  setContentDescriptions();
  if (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
    setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
  }
}"
1723,"private void updateHourControl(){
  if (is24HourView()) {
    mHourSpinner.setMinValue(0);
    mHourSpinner.setMaxValue(23);
    mHourSpinner.setFormatter(NumberPicker.getTwoDigitFormatter());
  }
 else {
    mHourSpinner.setMinValue(1);
    mHourSpinner.setMaxValue(12);
    mHourSpinner.setFormatter(null);
  }
}","private void updateHourControl(){
  if (is24HourView()) {
    if (mHourFormat == 'k') {
      mHourSpinner.setMinValue(1);
      mHourSpinner.setMaxValue(24);
    }
 else {
      mHourSpinner.setMinValue(0);
      mHourSpinner.setMaxValue(23);
    }
  }
 else {
    if (mHourFormat == 'K') {
      mHourSpinner.setMinValue(0);
      mHourSpinner.setMaxValue(11);
    }
 else {
      mHourSpinner.setMinValue(1);
      mHourSpinner.setMaxValue(12);
    }
  }
  mHourSpinner.setFormatter(mHourWithTwoDigit ? NumberPicker.getTwoDigitFormatter() : null);
}"
1724,"/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  mIs24HourView=is24HourView;
  int currentHour=getCurrentHour();
  updateHourControl();
  setCurrentHour(currentHour);
  updateMinuteControl();
  updateAmPmControl();
}","/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  int currentHour=getCurrentHour();
  mIs24HourView=is24HourView;
  getHourFormatData();
  updateHourControl();
  setCurrentHour(currentHour);
  updateMinuteControl();
  updateAmPmControl();
}"
1725,"public TimePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  setCurrentLocale(Locale.getDefault());
  TypedArray attributesArray=context.obtainStyledAttributes(attrs,R.styleable.TimePicker,defStyle,0);
  int layoutResourceId=attributesArray.getResourceId(R.styleable.TimePicker_internalLayout,R.layout.time_picker);
  attributesArray.recycle();
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(layoutResourceId,this,true);
  mHourSpinner=(NumberPicker)findViewById(R.id.hour);
  mHourSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      if (!is24HourView()) {
        if ((oldVal == HOURS_IN_HALF_DAY - 1 && newVal == HOURS_IN_HALF_DAY) || (oldVal == HOURS_IN_HALF_DAY && newVal == HOURS_IN_HALF_DAY - 1)) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
      }
      onTimeChanged();
    }
  }
);
  mHourSpinnerInput=(EditText)mHourSpinner.findViewById(R.id.numberpicker_input);
  mHourSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mDivider=(TextView)findViewById(R.id.divider);
  if (mDivider != null) {
    mDivider.setText(R.string.time_picker_separator);
  }
  mMinuteSpinner=(NumberPicker)findViewById(R.id.minute);
  mMinuteSpinner.setMinValue(0);
  mMinuteSpinner.setMaxValue(59);
  mMinuteSpinner.setOnLongPressUpdateInterval(100);
  mMinuteSpinner.setFormatter(NumberPicker.getTwoDigitFormatter());
  mMinuteSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      int minValue=mMinuteSpinner.getMinValue();
      int maxValue=mMinuteSpinner.getMaxValue();
      if (oldVal == maxValue && newVal == minValue) {
        int newHour=mHourSpinner.getValue() + 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
 else       if (oldVal == minValue && newVal == maxValue) {
        int newHour=mHourSpinner.getValue() - 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY - 1) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
      onTimeChanged();
    }
  }
);
  mMinuteSpinnerInput=(EditText)mMinuteSpinner.findViewById(R.id.numberpicker_input);
  mMinuteSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mAmPmStrings=new DateFormatSymbols().getAmPmStrings();
  View amPmView=findViewById(R.id.amPm);
  if (amPmView instanceof Button) {
    mAmPmSpinner=null;
    mAmPmSpinnerInput=null;
    mAmPmButton=(Button)amPmView;
    mAmPmButton.setOnClickListener(new OnClickListener(){
      public void onClick(      View button){
        button.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
  }
 else {
    mAmPmButton=null;
    mAmPmSpinner=(NumberPicker)amPmView;
    mAmPmSpinner.setMinValue(0);
    mAmPmSpinner.setMaxValue(1);
    mAmPmSpinner.setDisplayedValues(mAmPmStrings);
    mAmPmSpinner.setOnValueChangedListener(new OnValueChangeListener(){
      public void onValueChange(      NumberPicker picker,      int oldVal,      int newVal){
        updateInputState();
        picker.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
    mAmPmSpinnerInput=(EditText)mAmPmSpinner.findViewById(R.id.numberpicker_input);
    mAmPmSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_DONE);
  }
  updateHourControl();
  updateMinuteControl();
  updateAmPmControl();
  setOnTimeChangedListener(NO_OP_CHANGE_LISTENER);
  setCurrentHour(mTempCalendar.get(Calendar.HOUR_OF_DAY));
  setCurrentMinute(mTempCalendar.get(Calendar.MINUTE));
  if (!isEnabled()) {
    setEnabled(false);
  }
  setContentDescriptions();
  if (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
    setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
  }
}","public TimePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  setCurrentLocale(Locale.getDefault());
  TypedArray attributesArray=context.obtainStyledAttributes(attrs,R.styleable.TimePicker,defStyle,0);
  int layoutResourceId=attributesArray.getResourceId(R.styleable.TimePicker_internalLayout,R.layout.time_picker);
  attributesArray.recycle();
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(layoutResourceId,this,true);
  mHourSpinner=(NumberPicker)findViewById(R.id.hour);
  mHourSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      if (!is24HourView()) {
        if ((oldVal == HOURS_IN_HALF_DAY - 1 && newVal == HOURS_IN_HALF_DAY) || (oldVal == HOURS_IN_HALF_DAY && newVal == HOURS_IN_HALF_DAY - 1)) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
      }
      onTimeChanged();
    }
  }
);
  mHourSpinnerInput=(EditText)mHourSpinner.findViewById(R.id.numberpicker_input);
  mHourSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mDivider=(TextView)findViewById(R.id.divider);
  if (mDivider != null) {
    setDividerText();
  }
  mMinuteSpinner=(NumberPicker)findViewById(R.id.minute);
  mMinuteSpinner.setMinValue(0);
  mMinuteSpinner.setMaxValue(59);
  mMinuteSpinner.setOnLongPressUpdateInterval(100);
  mMinuteSpinner.setFormatter(NumberPicker.getTwoDigitFormatter());
  mMinuteSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      int minValue=mMinuteSpinner.getMinValue();
      int maxValue=mMinuteSpinner.getMaxValue();
      if (oldVal == maxValue && newVal == minValue) {
        int newHour=mHourSpinner.getValue() + 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
 else       if (oldVal == minValue && newVal == maxValue) {
        int newHour=mHourSpinner.getValue() - 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY - 1) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
      onTimeChanged();
    }
  }
);
  mMinuteSpinnerInput=(EditText)mMinuteSpinner.findViewById(R.id.numberpicker_input);
  mMinuteSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mAmPmStrings=new DateFormatSymbols().getAmPmStrings();
  View amPmView=findViewById(R.id.amPm);
  if (amPmView instanceof Button) {
    mAmPmSpinner=null;
    mAmPmSpinnerInput=null;
    mAmPmButton=(Button)amPmView;
    mAmPmButton.setOnClickListener(new OnClickListener(){
      public void onClick(      View button){
        button.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
  }
 else {
    mAmPmButton=null;
    mAmPmSpinner=(NumberPicker)amPmView;
    mAmPmSpinner.setMinValue(0);
    mAmPmSpinner.setMaxValue(1);
    mAmPmSpinner.setDisplayedValues(mAmPmStrings);
    mAmPmSpinner.setOnValueChangedListener(new OnValueChangeListener(){
      public void onValueChange(      NumberPicker picker,      int oldVal,      int newVal){
        updateInputState();
        picker.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
    mAmPmSpinnerInput=(EditText)mAmPmSpinner.findViewById(R.id.numberpicker_input);
    mAmPmSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_DONE);
  }
  if (isAmPmAtStart()) {
    ViewGroup amPmParent=(ViewGroup)findViewById(R.id.timePickerLayout);
    amPmParent.removeView(amPmView);
    amPmParent.addView(amPmView,0);
    ViewGroup.MarginLayoutParams lp=(ViewGroup.MarginLayoutParams)amPmView.getLayoutParams();
    final int startMargin=lp.getMarginStart();
    final int endMargin=lp.getMarginEnd();
    if (startMargin != endMargin) {
      lp.setMarginStart(endMargin);
      lp.setMarginEnd(startMargin);
    }
  }
  getHourFormatData();
  updateHourControl();
  updateMinuteControl();
  updateAmPmControl();
  setOnTimeChangedListener(NO_OP_CHANGE_LISTENER);
  setCurrentHour(mTempCalendar.get(Calendar.HOUR_OF_DAY));
  setCurrentMinute(mTempCalendar.get(Calendar.MINUTE));
  if (!isEnabled()) {
    setEnabled(false);
  }
  setContentDescriptions();
  if (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
    setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
  }
}"
1726,"private void updateHourControl(){
  if (is24HourView()) {
    mHourSpinner.setMinValue(0);
    mHourSpinner.setMaxValue(23);
    mHourSpinner.setFormatter(NumberPicker.getTwoDigitFormatter());
  }
 else {
    mHourSpinner.setMinValue(1);
    mHourSpinner.setMaxValue(12);
    mHourSpinner.setFormatter(null);
  }
}","private void updateHourControl(){
  if (is24HourView()) {
    if (mHourFormat == 'k') {
      mHourSpinner.setMinValue(1);
      mHourSpinner.setMaxValue(24);
    }
 else {
      mHourSpinner.setMinValue(0);
      mHourSpinner.setMaxValue(23);
    }
  }
 else {
    if (mHourFormat == 'K') {
      mHourSpinner.setMinValue(0);
      mHourSpinner.setMaxValue(11);
    }
 else {
      mHourSpinner.setMinValue(1);
      mHourSpinner.setMaxValue(12);
    }
  }
  mHourSpinner.setFormatter(mHourWithTwoDigit ? NumberPicker.getTwoDigitFormatter() : null);
}"
1727,"/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  mIs24HourView=is24HourView;
  int currentHour=getCurrentHour();
  updateHourControl();
  setCurrentHour(currentHour);
  updateMinuteControl();
  updateAmPmControl();
}","/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  int currentHour=getCurrentHour();
  mIs24HourView=is24HourView;
  getHourFormatData();
  updateHourControl();
  setCurrentHour(currentHour);
  updateMinuteControl();
  updateAmPmControl();
}"
1728,"public TimePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  setCurrentLocale(Locale.getDefault());
  TypedArray attributesArray=context.obtainStyledAttributes(attrs,R.styleable.TimePicker,defStyle,0);
  int layoutResourceId=attributesArray.getResourceId(R.styleable.TimePicker_internalLayout,R.layout.time_picker);
  attributesArray.recycle();
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(layoutResourceId,this,true);
  mHourSpinner=(NumberPicker)findViewById(R.id.hour);
  mHourSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      if (!is24HourView()) {
        if ((oldVal == HOURS_IN_HALF_DAY - 1 && newVal == HOURS_IN_HALF_DAY) || (oldVal == HOURS_IN_HALF_DAY && newVal == HOURS_IN_HALF_DAY - 1)) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
      }
      onTimeChanged();
    }
  }
);
  mHourSpinnerInput=(EditText)mHourSpinner.findViewById(R.id.numberpicker_input);
  mHourSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mDivider=(TextView)findViewById(R.id.divider);
  if (mDivider != null) {
    mDivider.setText(R.string.time_picker_separator);
  }
  mMinuteSpinner=(NumberPicker)findViewById(R.id.minute);
  mMinuteSpinner.setMinValue(0);
  mMinuteSpinner.setMaxValue(59);
  mMinuteSpinner.setOnLongPressUpdateInterval(100);
  mMinuteSpinner.setFormatter(NumberPicker.getTwoDigitFormatter());
  mMinuteSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      int minValue=mMinuteSpinner.getMinValue();
      int maxValue=mMinuteSpinner.getMaxValue();
      if (oldVal == maxValue && newVal == minValue) {
        int newHour=mHourSpinner.getValue() + 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
 else       if (oldVal == minValue && newVal == maxValue) {
        int newHour=mHourSpinner.getValue() - 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY - 1) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
      onTimeChanged();
    }
  }
);
  mMinuteSpinnerInput=(EditText)mMinuteSpinner.findViewById(R.id.numberpicker_input);
  mMinuteSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mAmPmStrings=new DateFormatSymbols().getAmPmStrings();
  View amPmView=findViewById(R.id.amPm);
  if (amPmView instanceof Button) {
    mAmPmSpinner=null;
    mAmPmSpinnerInput=null;
    mAmPmButton=(Button)amPmView;
    mAmPmButton.setOnClickListener(new OnClickListener(){
      public void onClick(      View button){
        button.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
  }
 else {
    mAmPmButton=null;
    mAmPmSpinner=(NumberPicker)amPmView;
    mAmPmSpinner.setMinValue(0);
    mAmPmSpinner.setMaxValue(1);
    mAmPmSpinner.setDisplayedValues(mAmPmStrings);
    mAmPmSpinner.setOnValueChangedListener(new OnValueChangeListener(){
      public void onValueChange(      NumberPicker picker,      int oldVal,      int newVal){
        updateInputState();
        picker.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
    mAmPmSpinnerInput=(EditText)mAmPmSpinner.findViewById(R.id.numberpicker_input);
    mAmPmSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_DONE);
  }
  updateHourControl();
  updateMinuteControl();
  updateAmPmControl();
  setOnTimeChangedListener(NO_OP_CHANGE_LISTENER);
  setCurrentHour(mTempCalendar.get(Calendar.HOUR_OF_DAY));
  setCurrentMinute(mTempCalendar.get(Calendar.MINUTE));
  if (!isEnabled()) {
    setEnabled(false);
  }
  setContentDescriptions();
  if (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
    setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
  }
}","public TimePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  setCurrentLocale(Locale.getDefault());
  TypedArray attributesArray=context.obtainStyledAttributes(attrs,R.styleable.TimePicker,defStyle,0);
  int layoutResourceId=attributesArray.getResourceId(R.styleable.TimePicker_internalLayout,R.layout.time_picker);
  attributesArray.recycle();
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(layoutResourceId,this,true);
  mHourSpinner=(NumberPicker)findViewById(R.id.hour);
  mHourSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      if (!is24HourView()) {
        if ((oldVal == HOURS_IN_HALF_DAY - 1 && newVal == HOURS_IN_HALF_DAY) || (oldVal == HOURS_IN_HALF_DAY && newVal == HOURS_IN_HALF_DAY - 1)) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
      }
      onTimeChanged();
    }
  }
);
  mHourSpinnerInput=(EditText)mHourSpinner.findViewById(R.id.numberpicker_input);
  mHourSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mDivider=(TextView)findViewById(R.id.divider);
  if (mDivider != null) {
    setDividerText();
  }
  mMinuteSpinner=(NumberPicker)findViewById(R.id.minute);
  mMinuteSpinner.setMinValue(0);
  mMinuteSpinner.setMaxValue(59);
  mMinuteSpinner.setOnLongPressUpdateInterval(100);
  mMinuteSpinner.setFormatter(NumberPicker.getTwoDigitFormatter());
  mMinuteSpinner.setOnValueChangedListener(new NumberPicker.OnValueChangeListener(){
    public void onValueChange(    NumberPicker spinner,    int oldVal,    int newVal){
      updateInputState();
      int minValue=mMinuteSpinner.getMinValue();
      int maxValue=mMinuteSpinner.getMaxValue();
      if (oldVal == maxValue && newVal == minValue) {
        int newHour=mHourSpinner.getValue() + 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
 else       if (oldVal == minValue && newVal == maxValue) {
        int newHour=mHourSpinner.getValue() - 1;
        if (!is24HourView() && newHour == HOURS_IN_HALF_DAY - 1) {
          mIsAm=!mIsAm;
          updateAmPmControl();
        }
        mHourSpinner.setValue(newHour);
      }
      onTimeChanged();
    }
  }
);
  mMinuteSpinnerInput=(EditText)mMinuteSpinner.findViewById(R.id.numberpicker_input);
  mMinuteSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  mAmPmStrings=new DateFormatSymbols().getAmPmStrings();
  View amPmView=findViewById(R.id.amPm);
  if (amPmView instanceof Button) {
    mAmPmSpinner=null;
    mAmPmSpinnerInput=null;
    mAmPmButton=(Button)amPmView;
    mAmPmButton.setOnClickListener(new OnClickListener(){
      public void onClick(      View button){
        button.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
  }
 else {
    mAmPmButton=null;
    mAmPmSpinner=(NumberPicker)amPmView;
    mAmPmSpinner.setMinValue(0);
    mAmPmSpinner.setMaxValue(1);
    mAmPmSpinner.setDisplayedValues(mAmPmStrings);
    mAmPmSpinner.setOnValueChangedListener(new OnValueChangeListener(){
      public void onValueChange(      NumberPicker picker,      int oldVal,      int newVal){
        updateInputState();
        picker.requestFocus();
        mIsAm=!mIsAm;
        updateAmPmControl();
        onTimeChanged();
      }
    }
);
    mAmPmSpinnerInput=(EditText)mAmPmSpinner.findViewById(R.id.numberpicker_input);
    mAmPmSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_DONE);
  }
  if (isAmPmAtStart()) {
    ViewGroup amPmParent=(ViewGroup)findViewById(R.id.timePickerLayout);
    amPmParent.removeView(amPmView);
    amPmParent.addView(amPmView,0);
    ViewGroup.MarginLayoutParams lp=(ViewGroup.MarginLayoutParams)amPmView.getLayoutParams();
    final int startMargin=lp.getMarginStart();
    final int endMargin=lp.getMarginEnd();
    if (startMargin != endMargin) {
      lp.setMarginStart(endMargin);
      lp.setMarginEnd(startMargin);
    }
  }
  getHourFormatData();
  updateHourControl();
  updateMinuteControl();
  updateAmPmControl();
  setOnTimeChangedListener(NO_OP_CHANGE_LISTENER);
  setCurrentHour(mTempCalendar.get(Calendar.HOUR_OF_DAY));
  setCurrentMinute(mTempCalendar.get(Calendar.MINUTE));
  if (!isEnabled()) {
    setEnabled(false);
  }
  setContentDescriptions();
  if (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
    setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
  }
}"
1729,"private void updateHourControl(){
  if (is24HourView()) {
    mHourSpinner.setMinValue(0);
    mHourSpinner.setMaxValue(23);
    mHourSpinner.setFormatter(NumberPicker.getTwoDigitFormatter());
  }
 else {
    mHourSpinner.setMinValue(1);
    mHourSpinner.setMaxValue(12);
    mHourSpinner.setFormatter(null);
  }
}","private void updateHourControl(){
  if (is24HourView()) {
    if (mHourFormat == 'k') {
      mHourSpinner.setMinValue(1);
      mHourSpinner.setMaxValue(24);
    }
 else {
      mHourSpinner.setMinValue(0);
      mHourSpinner.setMaxValue(23);
    }
  }
 else {
    if (mHourFormat == 'K') {
      mHourSpinner.setMinValue(0);
      mHourSpinner.setMaxValue(11);
    }
 else {
      mHourSpinner.setMinValue(1);
      mHourSpinner.setMaxValue(12);
    }
  }
  mHourSpinner.setFormatter(mHourWithTwoDigit ? NumberPicker.getTwoDigitFormatter() : null);
}"
1730,"/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  mIs24HourView=is24HourView;
  int currentHour=getCurrentHour();
  updateHourControl();
  setCurrentHour(currentHour);
  updateMinuteControl();
  updateAmPmControl();
}","/** 
 * Set whether in 24 hour or AM/PM mode.
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
public void setIs24HourView(Boolean is24HourView){
  if (mIs24HourView == is24HourView) {
    return;
  }
  int currentHour=getCurrentHour();
  mIs24HourView=is24HourView;
  getHourFormatData();
  updateHourControl();
  setCurrentHour(currentHour);
  updateMinuteControl();
  updateAmPmControl();
}"
1731,"public void run(){
  for (; ; ) {
    String eventStr=mWifiNative.waitForEvent();
    if (DBG && eventStr.indexOf(SCAN_RESULTS_STR) == -1) {
      Log.d(TAG,""String_Node_Str"" + eventStr + ""String_Node_Str"");
    }
    WifiMonitor m=null;
    mStateMachine=null;
    if (eventStr.startsWith(""String_Node_Str"")) {
      int space=eventStr.indexOf(' ');
      if (space != -1) {
        String iface=eventStr.substring(7,space);
        m=mWifiMonitorSingleton.getMonitor(iface);
        if (m != null) {
          if (m.mMonitoring) {
            mStateMachine=m.mWifiStateMachine;
            eventStr=eventStr.substring(space + 1);
          }
 else {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + iface + ""String_Node_Str"");
            continue;
          }
        }
 else {
          eventStr=eventStr.substring(space + 1);
        }
      }
    }
    if (mStateMachine != null) {
      if (dispatchEvent(eventStr)) {
        break;
      }
    }
 else {
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      boolean done=false;
      Iterator<Map.Entry<String,WifiMonitor>> it=mWifiMonitorSingleton.mIfaceMap.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,WifiMonitor> e=it.next();
        m=e.getValue();
        mStateMachine=m.mWifiStateMachine;
        if (dispatchEvent(eventStr)) {
          done=true;
        }
      }
      if (done) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        mWifiMonitorSingleton.mConnected=false;
        break;
      }
    }
  }
}","public void run(){
  for (; ; ) {
    String eventStr=mWifiNative.waitForEvent();
    if (DBG && eventStr.indexOf(SCAN_RESULTS_STR) == -1) {
      Log.d(TAG,""String_Node_Str"" + eventStr + ""String_Node_Str"");
    }
    WifiMonitor m=null;
    mStateMachine=null;
    if (eventStr.startsWith(""String_Node_Str"")) {
      int space=eventStr.indexOf(' ');
      if (space != -1) {
        String iface=eventStr.substring(7,space);
        m=mWifiMonitorSingleton.getMonitor(iface);
        if (m == null && iface.startsWith(""String_Node_Str"")) {
          m=mWifiMonitorSingleton.getMonitor(""String_Node_Str"");
        }
        if (m != null) {
          if (m.mMonitoring) {
            mStateMachine=m.mWifiStateMachine;
            eventStr=eventStr.substring(space + 1);
          }
 else {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + iface + ""String_Node_Str"");
            continue;
          }
        }
 else {
          eventStr=eventStr.substring(space + 1);
        }
      }
    }
    if (mStateMachine != null) {
      if (dispatchEvent(eventStr)) {
        break;
      }
    }
 else {
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      boolean done=false;
      Iterator<Map.Entry<String,WifiMonitor>> it=mWifiMonitorSingleton.mIfaceMap.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,WifiMonitor> e=it.next();
        m=e.getValue();
        mStateMachine=m.mWifiStateMachine;
        if (dispatchEvent(eventStr)) {
          done=true;
        }
      }
      if (done) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        mWifiMonitorSingleton.mConnected=false;
        break;
      }
    }
  }
}"
1732,"public void run(){
  for (; ; ) {
    String eventStr=mWifiNative.waitForEvent();
    if (DBG && eventStr.indexOf(SCAN_RESULTS_STR) == -1) {
      Log.d(TAG,""String_Node_Str"" + eventStr + ""String_Node_Str"");
    }
    WifiMonitor m=null;
    mStateMachine=null;
    if (eventStr.startsWith(""String_Node_Str"")) {
      int space=eventStr.indexOf(' ');
      if (space != -1) {
        String iface=eventStr.substring(7,space);
        m=mWifiMonitorSingleton.getMonitor(iface);
        if (m != null) {
          if (m.mMonitoring) {
            mStateMachine=m.mWifiStateMachine;
            eventStr=eventStr.substring(space + 1);
          }
 else {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + iface + ""String_Node_Str"");
            continue;
          }
        }
 else {
          eventStr=eventStr.substring(space + 1);
        }
      }
    }
    if (mStateMachine != null) {
      if (dispatchEvent(eventStr)) {
        break;
      }
    }
 else {
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      boolean done=false;
      Iterator<Map.Entry<String,WifiMonitor>> it=mWifiMonitorSingleton.mIfaceMap.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,WifiMonitor> e=it.next();
        m=e.getValue();
        mStateMachine=m.mWifiStateMachine;
        if (dispatchEvent(eventStr)) {
          done=true;
        }
      }
      if (done) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        mWifiMonitorSingleton.mConnected=false;
        break;
      }
    }
  }
}","public void run(){
  for (; ; ) {
    String eventStr=mWifiNative.waitForEvent();
    if (DBG && eventStr.indexOf(SCAN_RESULTS_STR) == -1) {
      Log.d(TAG,""String_Node_Str"" + eventStr + ""String_Node_Str"");
    }
    WifiMonitor m=null;
    mStateMachine=null;
    if (eventStr.startsWith(""String_Node_Str"")) {
      int space=eventStr.indexOf(' ');
      if (space != -1) {
        String iface=eventStr.substring(7,space);
        m=mWifiMonitorSingleton.getMonitor(iface);
        if (m == null && iface.startsWith(""String_Node_Str"")) {
          m=mWifiMonitorSingleton.getMonitor(""String_Node_Str"");
        }
        if (m != null) {
          if (m.mMonitoring) {
            mStateMachine=m.mWifiStateMachine;
            eventStr=eventStr.substring(space + 1);
          }
 else {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + iface + ""String_Node_Str"");
            continue;
          }
        }
 else {
          eventStr=eventStr.substring(space + 1);
        }
      }
    }
    if (mStateMachine != null) {
      if (dispatchEvent(eventStr)) {
        break;
      }
    }
 else {
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      boolean done=false;
      Iterator<Map.Entry<String,WifiMonitor>> it=mWifiMonitorSingleton.mIfaceMap.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,WifiMonitor> e=it.next();
        m=e.getValue();
        mStateMachine=m.mWifiStateMachine;
        if (dispatchEvent(eventStr)) {
          done=true;
        }
      }
      if (done) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        mWifiMonitorSingleton.mConnected=false;
        break;
      }
    }
  }
}"
1733,"public void run(){
  for (; ; ) {
    String eventStr=mWifiNative.waitForEvent();
    if (DBG && eventStr.indexOf(SCAN_RESULTS_STR) == -1) {
      Log.d(TAG,""String_Node_Str"" + eventStr + ""String_Node_Str"");
    }
    WifiMonitor m=null;
    mStateMachine=null;
    if (eventStr.startsWith(""String_Node_Str"")) {
      int space=eventStr.indexOf(' ');
      if (space != -1) {
        String iface=eventStr.substring(7,space);
        m=mWifiMonitorSingleton.getMonitor(iface);
        if (m != null) {
          if (m.mMonitoring) {
            mStateMachine=m.mWifiStateMachine;
            eventStr=eventStr.substring(space + 1);
          }
 else {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + iface + ""String_Node_Str"");
            continue;
          }
        }
 else {
          eventStr=eventStr.substring(space + 1);
        }
      }
    }
    if (mStateMachine != null) {
      if (dispatchEvent(eventStr)) {
        break;
      }
    }
 else {
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      boolean done=false;
      Iterator<Map.Entry<String,WifiMonitor>> it=mWifiMonitorSingleton.mIfaceMap.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,WifiMonitor> e=it.next();
        m=e.getValue();
        mStateMachine=m.mWifiStateMachine;
        if (dispatchEvent(eventStr)) {
          done=true;
        }
      }
      if (done) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        mWifiMonitorSingleton.mConnected=false;
        break;
      }
    }
  }
}","public void run(){
  for (; ; ) {
    String eventStr=mWifiNative.waitForEvent();
    if (DBG && eventStr.indexOf(SCAN_RESULTS_STR) == -1) {
      Log.d(TAG,""String_Node_Str"" + eventStr + ""String_Node_Str"");
    }
    WifiMonitor m=null;
    mStateMachine=null;
    if (eventStr.startsWith(""String_Node_Str"")) {
      int space=eventStr.indexOf(' ');
      if (space != -1) {
        String iface=eventStr.substring(7,space);
        m=mWifiMonitorSingleton.getMonitor(iface);
        if (m == null && iface.startsWith(""String_Node_Str"")) {
          m=mWifiMonitorSingleton.getMonitor(""String_Node_Str"");
        }
        if (m != null) {
          if (m.mMonitoring) {
            mStateMachine=m.mWifiStateMachine;
            eventStr=eventStr.substring(space + 1);
          }
 else {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + iface + ""String_Node_Str"");
            continue;
          }
        }
 else {
          eventStr=eventStr.substring(space + 1);
        }
      }
    }
    if (mStateMachine != null) {
      if (dispatchEvent(eventStr)) {
        break;
      }
    }
 else {
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      boolean done=false;
      Iterator<Map.Entry<String,WifiMonitor>> it=mWifiMonitorSingleton.mIfaceMap.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,WifiMonitor> e=it.next();
        m=e.getValue();
        mStateMachine=m.mWifiStateMachine;
        if (dispatchEvent(eventStr)) {
          done=true;
        }
      }
      if (done) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        mWifiMonitorSingleton.mConnected=false;
        break;
      }
    }
  }
}"
1734,"public void run(){
  for (; ; ) {
    String eventStr=mWifiNative.waitForEvent();
    if (DBG && eventStr.indexOf(SCAN_RESULTS_STR) == -1) {
      Log.d(TAG,""String_Node_Str"" + eventStr + ""String_Node_Str"");
    }
    WifiMonitor m=null;
    mStateMachine=null;
    if (eventStr.startsWith(""String_Node_Str"")) {
      int space=eventStr.indexOf(' ');
      if (space != -1) {
        String iface=eventStr.substring(7,space);
        m=mWifiMonitorSingleton.getMonitor(iface);
        if (m != null) {
          if (m.mMonitoring) {
            mStateMachine=m.mWifiStateMachine;
            eventStr=eventStr.substring(space + 1);
          }
 else {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + iface + ""String_Node_Str"");
            continue;
          }
        }
 else {
          eventStr=eventStr.substring(space + 1);
        }
      }
    }
    if (mStateMachine != null) {
      if (dispatchEvent(eventStr)) {
        break;
      }
    }
 else {
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      boolean done=false;
      Iterator<Map.Entry<String,WifiMonitor>> it=mWifiMonitorSingleton.mIfaceMap.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,WifiMonitor> e=it.next();
        m=e.getValue();
        mStateMachine=m.mWifiStateMachine;
        if (dispatchEvent(eventStr)) {
          done=true;
        }
      }
      if (done) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        mWifiMonitorSingleton.mConnected=false;
        break;
      }
    }
  }
}","public void run(){
  for (; ; ) {
    String eventStr=mWifiNative.waitForEvent();
    if (DBG && eventStr.indexOf(SCAN_RESULTS_STR) == -1) {
      Log.d(TAG,""String_Node_Str"" + eventStr + ""String_Node_Str"");
    }
    WifiMonitor m=null;
    mStateMachine=null;
    if (eventStr.startsWith(""String_Node_Str"")) {
      int space=eventStr.indexOf(' ');
      if (space != -1) {
        String iface=eventStr.substring(7,space);
        m=mWifiMonitorSingleton.getMonitor(iface);
        if (m == null && iface.startsWith(""String_Node_Str"")) {
          m=mWifiMonitorSingleton.getMonitor(""String_Node_Str"");
        }
        if (m != null) {
          if (m.mMonitoring) {
            mStateMachine=m.mWifiStateMachine;
            eventStr=eventStr.substring(space + 1);
          }
 else {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + iface + ""String_Node_Str"");
            continue;
          }
        }
 else {
          eventStr=eventStr.substring(space + 1);
        }
      }
    }
    if (mStateMachine != null) {
      if (dispatchEvent(eventStr)) {
        break;
      }
    }
 else {
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      boolean done=false;
      Iterator<Map.Entry<String,WifiMonitor>> it=mWifiMonitorSingleton.mIfaceMap.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,WifiMonitor> e=it.next();
        m=e.getValue();
        mStateMachine=m.mWifiStateMachine;
        if (dispatchEvent(eventStr)) {
          done=true;
        }
      }
      if (done) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        mWifiMonitorSingleton.mConnected=false;
        break;
      }
    }
  }
}"
1735,"/** 
 * Resolve the Drawables depending on the layout direction. This is implicitly supposing that the View directionality can and will be resolved before its Drawables. Will call   {@link View#onResolveDrawables} when resolution is done.
 * @hide
 */
protected void resolveDrawables(){
  if (canResolveLayoutDirection()) {
    if (mBackground != null) {
      mBackground.setLayoutDirection(getLayoutDirection());
    }
    mPrivateFlags2|=PFLAG2_DRAWABLE_RESOLVED;
    onResolveDrawables(getLayoutDirection());
  }
}","/** 
 * Resolve the Drawables depending on the layout direction. This is implicitly supposing that the View directionality can and will be resolved before its Drawables. Will call   {@link View#onResolveDrawables} when resolution is done.
 * @hide
 */
protected void resolveDrawables(){
  if (!isLayoutDirectionResolved() && getRawLayoutDirection() == View.LAYOUT_DIRECTION_INHERIT) {
    return;
  }
  final int layoutDirection=isLayoutDirectionResolved() ? getLayoutDirection() : getRawLayoutDirection();
  if (mBackground != null) {
    mBackground.setLayoutDirection(layoutDirection);
  }
  mPrivateFlags2|=PFLAG2_DRAWABLE_RESOLVED;
  onResolveDrawables(layoutDirection);
}"
1736,"private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
  }
}","private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
    resetResolvedDrawables();
    resolveDrawables();
  }
}"
1737,"/** 
 * Set all class variables using current values from the given  {@link Paint}.
 */
private void setClassVariablesFrom(Paint paint){
  mColorFilter=paint.mColorFilter;
  mMaskFilter=paint.mMaskFilter;
  mPathEffect=paint.mPathEffect;
  mRasterizer=paint.mRasterizer;
  if (paint.mShader != null) {
    mShader=paint.mShader.copy();
  }
  mTypeface=paint.mTypeface;
  mXfermode=paint.mXfermode;
  mHasCompatScaling=paint.mHasCompatScaling;
  mCompatScaling=paint.mCompatScaling;
  mInvCompatScaling=paint.mInvCompatScaling;
  hasShadow=paint.hasShadow;
  shadowDx=paint.shadowDx;
  shadowDy=paint.shadowDy;
  shadowRadius=paint.shadowRadius;
  shadowColor=paint.shadowColor;
  mBidiFlags=paint.mBidiFlags;
  mLocale=paint.mLocale;
}","/** 
 * Set all class variables using current values from the given  {@link Paint}.
 */
private void setClassVariablesFrom(Paint paint){
  mColorFilter=paint.mColorFilter;
  mMaskFilter=paint.mMaskFilter;
  mPathEffect=paint.mPathEffect;
  mRasterizer=paint.mRasterizer;
  if (paint.mShader != null) {
    mShader=paint.mShader.copy();
  }
 else {
    mShader=null;
  }
  mTypeface=paint.mTypeface;
  mXfermode=paint.mXfermode;
  mHasCompatScaling=paint.mHasCompatScaling;
  mCompatScaling=paint.mCompatScaling;
  mInvCompatScaling=paint.mInvCompatScaling;
  hasShadow=paint.hasShadow;
  shadowDx=paint.shadowDx;
  shadowDy=paint.shadowDy;
  shadowRadius=paint.shadowRadius;
  shadowColor=paint.shadowColor;
  mBidiFlags=paint.mBidiFlags;
  mLocale=paint.mLocale;
}"
1738,"/** 
 * Resolve the Drawables depending on the layout direction. This is implicitly supposing that the View directionality can and will be resolved before its Drawables. Will call   {@link View#onResolveDrawables} when resolution is done.
 * @hide
 */
protected void resolveDrawables(){
  if (canResolveLayoutDirection()) {
    if (mBackground != null) {
      mBackground.setLayoutDirection(getLayoutDirection());
    }
    mPrivateFlags2|=PFLAG2_DRAWABLE_RESOLVED;
    onResolveDrawables(getLayoutDirection());
  }
}","/** 
 * Resolve the Drawables depending on the layout direction. This is implicitly supposing that the View directionality can and will be resolved before its Drawables. Will call   {@link View#onResolveDrawables} when resolution is done.
 * @hide
 */
protected void resolveDrawables(){
  if (!isLayoutDirectionResolved() && getRawLayoutDirection() == View.LAYOUT_DIRECTION_INHERIT) {
    return;
  }
  final int layoutDirection=isLayoutDirectionResolved() ? getLayoutDirection() : getRawLayoutDirection();
  if (mBackground != null) {
    mBackground.setLayoutDirection(layoutDirection);
  }
  mPrivateFlags2|=PFLAG2_DRAWABLE_RESOLVED;
  onResolveDrawables(layoutDirection);
}"
1739,"private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
  }
}","private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
    resetResolvedDrawables();
    resolveDrawables();
  }
}"
1740,"/** 
 * Set all class variables using current values from the given  {@link Paint}.
 */
private void setClassVariablesFrom(Paint paint){
  mColorFilter=paint.mColorFilter;
  mMaskFilter=paint.mMaskFilter;
  mPathEffect=paint.mPathEffect;
  mRasterizer=paint.mRasterizer;
  if (paint.mShader != null) {
    mShader=paint.mShader.copy();
  }
  mTypeface=paint.mTypeface;
  mXfermode=paint.mXfermode;
  mHasCompatScaling=paint.mHasCompatScaling;
  mCompatScaling=paint.mCompatScaling;
  mInvCompatScaling=paint.mInvCompatScaling;
  hasShadow=paint.hasShadow;
  shadowDx=paint.shadowDx;
  shadowDy=paint.shadowDy;
  shadowRadius=paint.shadowRadius;
  shadowColor=paint.shadowColor;
  mBidiFlags=paint.mBidiFlags;
  mLocale=paint.mLocale;
}","/** 
 * Set all class variables using current values from the given  {@link Paint}.
 */
private void setClassVariablesFrom(Paint paint){
  mColorFilter=paint.mColorFilter;
  mMaskFilter=paint.mMaskFilter;
  mPathEffect=paint.mPathEffect;
  mRasterizer=paint.mRasterizer;
  if (paint.mShader != null) {
    mShader=paint.mShader.copy();
  }
 else {
    mShader=null;
  }
  mTypeface=paint.mTypeface;
  mXfermode=paint.mXfermode;
  mHasCompatScaling=paint.mHasCompatScaling;
  mCompatScaling=paint.mCompatScaling;
  mInvCompatScaling=paint.mInvCompatScaling;
  hasShadow=paint.hasShadow;
  shadowDx=paint.shadowDx;
  shadowDy=paint.shadowDy;
  shadowRadius=paint.shadowRadius;
  shadowColor=paint.shadowColor;
  mBidiFlags=paint.mBidiFlags;
  mLocale=paint.mLocale;
}"
1741,"/** 
 * Resolve the Drawables depending on the layout direction. This is implicitly supposing that the View directionality can and will be resolved before its Drawables. Will call   {@link View#onResolveDrawables} when resolution is done.
 * @hide
 */
protected void resolveDrawables(){
  if (canResolveLayoutDirection()) {
    if (mBackground != null) {
      mBackground.setLayoutDirection(getLayoutDirection());
    }
    mPrivateFlags2|=PFLAG2_DRAWABLE_RESOLVED;
    onResolveDrawables(getLayoutDirection());
  }
}","/** 
 * Resolve the Drawables depending on the layout direction. This is implicitly supposing that the View directionality can and will be resolved before its Drawables. Will call   {@link View#onResolveDrawables} when resolution is done.
 * @hide
 */
protected void resolveDrawables(){
  if (!isLayoutDirectionResolved() && getRawLayoutDirection() == View.LAYOUT_DIRECTION_INHERIT) {
    return;
  }
  final int layoutDirection=isLayoutDirectionResolved() ? getLayoutDirection() : getRawLayoutDirection();
  if (mBackground != null) {
    mBackground.setLayoutDirection(layoutDirection);
  }
  mPrivateFlags2|=PFLAG2_DRAWABLE_RESOLVED;
  onResolveDrawables(layoutDirection);
}"
1742,"private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
  }
}","private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
    resetResolvedDrawables();
    resolveDrawables();
  }
}"
1743,"/** 
 * Set all class variables using current values from the given  {@link Paint}.
 */
private void setClassVariablesFrom(Paint paint){
  mColorFilter=paint.mColorFilter;
  mMaskFilter=paint.mMaskFilter;
  mPathEffect=paint.mPathEffect;
  mRasterizer=paint.mRasterizer;
  if (paint.mShader != null) {
    mShader=paint.mShader.copy();
  }
  mTypeface=paint.mTypeface;
  mXfermode=paint.mXfermode;
  mHasCompatScaling=paint.mHasCompatScaling;
  mCompatScaling=paint.mCompatScaling;
  mInvCompatScaling=paint.mInvCompatScaling;
  hasShadow=paint.hasShadow;
  shadowDx=paint.shadowDx;
  shadowDy=paint.shadowDy;
  shadowRadius=paint.shadowRadius;
  shadowColor=paint.shadowColor;
  mBidiFlags=paint.mBidiFlags;
  mLocale=paint.mLocale;
}","/** 
 * Set all class variables using current values from the given  {@link Paint}.
 */
private void setClassVariablesFrom(Paint paint){
  mColorFilter=paint.mColorFilter;
  mMaskFilter=paint.mMaskFilter;
  mPathEffect=paint.mPathEffect;
  mRasterizer=paint.mRasterizer;
  if (paint.mShader != null) {
    mShader=paint.mShader.copy();
  }
 else {
    mShader=null;
  }
  mTypeface=paint.mTypeface;
  mXfermode=paint.mXfermode;
  mHasCompatScaling=paint.mHasCompatScaling;
  mCompatScaling=paint.mCompatScaling;
  mInvCompatScaling=paint.mInvCompatScaling;
  hasShadow=paint.hasShadow;
  shadowDx=paint.shadowDx;
  shadowDy=paint.shadowDy;
  shadowRadius=paint.shadowRadius;
  shadowColor=paint.shadowColor;
  mBidiFlags=paint.mBidiFlags;
  mLocale=paint.mLocale;
}"
1744,"/** 
 * Resolve the Drawables depending on the layout direction. This is implicitly supposing that the View directionality can and will be resolved before its Drawables. Will call   {@link View#onResolveDrawables} when resolution is done.
 * @hide
 */
protected void resolveDrawables(){
  if (canResolveLayoutDirection()) {
    if (mBackground != null) {
      mBackground.setLayoutDirection(getLayoutDirection());
    }
    mPrivateFlags2|=PFLAG2_DRAWABLE_RESOLVED;
    onResolveDrawables(getLayoutDirection());
  }
}","/** 
 * Resolve the Drawables depending on the layout direction. This is implicitly supposing that the View directionality can and will be resolved before its Drawables. Will call   {@link View#onResolveDrawables} when resolution is done.
 * @hide
 */
protected void resolveDrawables(){
  if (!isLayoutDirectionResolved() && getRawLayoutDirection() == View.LAYOUT_DIRECTION_INHERIT) {
    return;
  }
  final int layoutDirection=isLayoutDirectionResolved() ? getLayoutDirection() : getRawLayoutDirection();
  if (mBackground != null) {
    mBackground.setLayoutDirection(layoutDirection);
  }
  mPrivateFlags2|=PFLAG2_DRAWABLE_RESOLVED;
  onResolveDrawables(layoutDirection);
}"
1745,"private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
  }
}","private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
    resetResolvedDrawables();
    resolveDrawables();
  }
}"
1746,"/** 
 * Set all class variables using current values from the given  {@link Paint}.
 */
private void setClassVariablesFrom(Paint paint){
  mColorFilter=paint.mColorFilter;
  mMaskFilter=paint.mMaskFilter;
  mPathEffect=paint.mPathEffect;
  mRasterizer=paint.mRasterizer;
  if (paint.mShader != null) {
    mShader=paint.mShader.copy();
  }
  mTypeface=paint.mTypeface;
  mXfermode=paint.mXfermode;
  mHasCompatScaling=paint.mHasCompatScaling;
  mCompatScaling=paint.mCompatScaling;
  mInvCompatScaling=paint.mInvCompatScaling;
  hasShadow=paint.hasShadow;
  shadowDx=paint.shadowDx;
  shadowDy=paint.shadowDy;
  shadowRadius=paint.shadowRadius;
  shadowColor=paint.shadowColor;
  mBidiFlags=paint.mBidiFlags;
  mLocale=paint.mLocale;
}","/** 
 * Set all class variables using current values from the given  {@link Paint}.
 */
private void setClassVariablesFrom(Paint paint){
  mColorFilter=paint.mColorFilter;
  mMaskFilter=paint.mMaskFilter;
  mPathEffect=paint.mPathEffect;
  mRasterizer=paint.mRasterizer;
  if (paint.mShader != null) {
    mShader=paint.mShader.copy();
  }
 else {
    mShader=null;
  }
  mTypeface=paint.mTypeface;
  mXfermode=paint.mXfermode;
  mHasCompatScaling=paint.mHasCompatScaling;
  mCompatScaling=paint.mCompatScaling;
  mInvCompatScaling=paint.mInvCompatScaling;
  hasShadow=paint.hasShadow;
  shadowDx=paint.shadowDx;
  shadowDy=paint.shadowDy;
  shadowRadius=paint.shadowRadius;
  shadowColor=paint.shadowColor;
  mBidiFlags=paint.mBidiFlags;
  mLocale=paint.mLocale;
}"
1747,"@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=0; i < mUidOps.size(); i++) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      for (      Map.Entry<String,Ops> ent : packages.entrySet()) {
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=0; j < pkgOps.size(); j++) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            pruneOp(curOp,mUidOps.keyAt(i),packageName);
          }
        }
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}"
1748,"@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=0; i < mUidOps.size(); i++) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      for (      Map.Entry<String,Ops> ent : packages.entrySet()) {
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=0; j < pkgOps.size(); j++) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            pruneOp(curOp,mUidOps.keyAt(i),packageName);
          }
        }
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}"
1749,"/** 
 * Locked on mService.mWindowMap. 
 */
private void animateLocked(){
  if (!mInitialized) {
    return;
  }
  mCurrentTime=SystemClock.uptimeMillis();
  mBulkUpdateParams=SET_ORIENTATION_CHANGE_COMPLETE;
  boolean wasAnimating=mAnimating;
  mAnimating=false;
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,""String_Node_Str"" + mCurrentTime);
  }
  if (WindowManagerService.SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  SurfaceControl.setAnimationTransaction();
  try {
    final int numDisplays=mDisplayContentsAnimators.size();
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      updateAppWindowsLocked(displayId);
      DisplayContentsAnimator displayAnimator=mDisplayContentsAnimators.valueAt(i);
      final ScreenRotationAnimation screenRotationAnimation=displayAnimator.mScreenRotationAnimation;
      if (screenRotationAnimation != null && screenRotationAnimation.isAnimating()) {
        if (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) {
          mAnimating=true;
        }
 else {
          mBulkUpdateParams|=SET_UPDATE_ROTATION;
          screenRotationAnimation.kill();
          displayAnimator.mScreenRotationAnimation=null;
        }
      }
      performAnimationsLocked(displayId);
      final WindowList windows=mService.getWindowListLocked(displayId);
      final int N=windows.size();
      for (int j=0; j < N; j++) {
        windows.get(j).mWinAnimator.prepareSurfaceLocked(true);
      }
    }
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      testTokenMayBeDrawnLocked(displayId);
      final ScreenRotationAnimation screenRotationAnimation=mDisplayContentsAnimators.valueAt(i).mScreenRotationAnimation;
      if (screenRotationAnimation != null) {
        screenRotationAnimation.updateSurfacesInTransaction();
      }
      mAnimating|=mService.getDisplayContentLocked(displayId).animateDimLayers();
      if (mService.mDisplayMagnifier != null && displayId == Display.DEFAULT_DISPLAY) {
        mService.mDisplayMagnifier.drawMagnifiedRegionBorderIfNeededLocked();
      }
    }
    mService.setFocusedStackLayer();
    if (mService.mWatermark != null) {
      mService.mWatermark.drawIfNeeded();
    }
  }
 catch (  RuntimeException e) {
    Log.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (WindowManagerService.SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  boolean hasPendingLayoutChanges=false;
  final int numDisplays=mService.mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mService.mDisplayContents.valueAt(displayNdx);
    final int pendingChanges=getPendingLayoutChanges(displayContent.getDisplayId());
    if ((pendingChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      mBulkUpdateParams|=SET_WALLPAPER_ACTION_PENDING;
    }
    if (pendingChanges != 0) {
      hasPendingLayoutChanges=true;
    }
  }
  boolean doRequest=false;
  if (mBulkUpdateParams != 0) {
    doRequest=mService.copyAnimToLayoutParamsLocked();
  }
  if (hasPendingLayoutChanges || doRequest) {
    mService.requestTraversalLocked();
  }
  if (mAnimating) {
    mService.scheduleAnimationLocked();
  }
 else   if (wasAnimating) {
    mService.requestTraversalLocked();
  }
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,""String_Node_Str"" + mAnimating + ""String_Node_Str""+ Integer.toHexString(mBulkUpdateParams)+ ""String_Node_Str""+ Integer.toHexString(getPendingLayoutChanges(Display.DEFAULT_DISPLAY)));
  }
}","/** 
 * Locked on mService.mWindowMap. 
 */
private void animateLocked(){
  if (!mInitialized) {
    return;
  }
  mCurrentTime=SystemClock.uptimeMillis();
  mBulkUpdateParams=SET_ORIENTATION_CHANGE_COMPLETE;
  boolean wasAnimating=mAnimating;
  mAnimating=false;
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,""String_Node_Str"" + mCurrentTime);
  }
  if (WindowManagerService.SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  SurfaceControl.setAnimationTransaction();
  try {
    final int numDisplays=mDisplayContentsAnimators.size();
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      updateAppWindowsLocked(displayId);
      DisplayContentsAnimator displayAnimator=mDisplayContentsAnimators.valueAt(i);
      final ScreenRotationAnimation screenRotationAnimation=displayAnimator.mScreenRotationAnimation;
      if (screenRotationAnimation != null && screenRotationAnimation.isAnimating()) {
        if (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) {
          mAnimating=true;
        }
 else {
          mBulkUpdateParams|=SET_UPDATE_ROTATION;
          screenRotationAnimation.kill();
          displayAnimator.mScreenRotationAnimation=null;
        }
      }
      performAnimationsLocked(displayId);
      final WindowList windows=mService.getWindowListLocked(displayId);
      final int N=windows.size();
      for (int j=0; j < N; j++) {
        windows.get(j).mWinAnimator.prepareSurfaceLocked(true);
      }
    }
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      testTokenMayBeDrawnLocked(displayId);
      final ScreenRotationAnimation screenRotationAnimation=mDisplayContentsAnimators.valueAt(i).mScreenRotationAnimation;
      if (screenRotationAnimation != null) {
        screenRotationAnimation.updateSurfacesInTransaction();
      }
      mAnimating|=mService.getDisplayContentLocked(displayId).animateDimLayers();
      if (mService.mDisplayMagnifier != null && displayId == Display.DEFAULT_DISPLAY) {
        mService.mDisplayMagnifier.drawMagnifiedRegionBorderIfNeededLocked();
      }
    }
    if (mAnimating) {
      mService.scheduleAnimationLocked();
    }
    mService.setFocusedStackLayer();
    if (mService.mWatermark != null) {
      mService.mWatermark.drawIfNeeded();
    }
  }
 catch (  RuntimeException e) {
    Log.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (WindowManagerService.SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  boolean hasPendingLayoutChanges=false;
  final int numDisplays=mService.mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mService.mDisplayContents.valueAt(displayNdx);
    final int pendingChanges=getPendingLayoutChanges(displayContent.getDisplayId());
    if ((pendingChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      mBulkUpdateParams|=SET_WALLPAPER_ACTION_PENDING;
    }
    if (pendingChanges != 0) {
      hasPendingLayoutChanges=true;
    }
  }
  boolean doRequest=false;
  if (mBulkUpdateParams != 0) {
    doRequest=mService.copyAnimToLayoutParamsLocked();
  }
  if (hasPendingLayoutChanges || doRequest) {
    mService.requestTraversalLocked();
  }
  if (!mAnimating && wasAnimating) {
    mService.requestTraversalLocked();
  }
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,""String_Node_Str"" + mAnimating + ""String_Node_Str""+ Integer.toHexString(mBulkUpdateParams)+ ""String_Node_Str""+ Integer.toHexString(getPendingLayoutChanges(Display.DEFAULT_DISPLAY)));
  }
}"
1750,"@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=0; i < mUidOps.size(); i++) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      for (      Map.Entry<String,Ops> ent : packages.entrySet()) {
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=0; j < pkgOps.size(); j++) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            pruneOp(curOp,mUidOps.keyAt(i),packageName);
          }
        }
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}"
1751,"@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=0; i < mUidOps.size(); i++) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      for (      Map.Entry<String,Ops> ent : packages.entrySet()) {
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=0; j < pkgOps.size(); j++) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            pruneOp(curOp,mUidOps.keyAt(i),packageName);
          }
        }
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}"
1752,"@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=0; i < mUidOps.size(); i++) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      for (      Map.Entry<String,Ops> ent : packages.entrySet()) {
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=0; j < pkgOps.size(); j++) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            pruneOp(curOp,mUidOps.keyAt(i),packageName);
          }
        }
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}"
1753,"@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=0; i < mUidOps.size(); i++) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      for (      Map.Entry<String,Ops> ent : packages.entrySet()) {
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=0; j < pkgOps.size(); j++) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            pruneOp(curOp,mUidOps.keyAt(i),packageName);
          }
        }
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}"
1754,"@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=0; i < mUidOps.size(); i++) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      for (      Map.Entry<String,Ops> ent : packages.entrySet()) {
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=0; j < pkgOps.size(); j++) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            pruneOp(curOp,mUidOps.keyAt(i),packageName);
          }
        }
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}"
1755,"/** 
 * Locked on mService.mWindowMap. 
 */
private void animateLocked(){
  if (!mInitialized) {
    return;
  }
  mCurrentTime=SystemClock.uptimeMillis();
  mBulkUpdateParams=SET_ORIENTATION_CHANGE_COMPLETE;
  boolean wasAnimating=mAnimating;
  mAnimating=false;
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,""String_Node_Str"" + mCurrentTime);
  }
  if (WindowManagerService.SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  SurfaceControl.setAnimationTransaction();
  try {
    final int numDisplays=mDisplayContentsAnimators.size();
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      updateAppWindowsLocked(displayId);
      DisplayContentsAnimator displayAnimator=mDisplayContentsAnimators.valueAt(i);
      final ScreenRotationAnimation screenRotationAnimation=displayAnimator.mScreenRotationAnimation;
      if (screenRotationAnimation != null && screenRotationAnimation.isAnimating()) {
        if (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) {
          mAnimating=true;
        }
 else {
          mBulkUpdateParams|=SET_UPDATE_ROTATION;
          screenRotationAnimation.kill();
          displayAnimator.mScreenRotationAnimation=null;
        }
      }
      performAnimationsLocked(displayId);
      final WindowList windows=mService.getWindowListLocked(displayId);
      final int N=windows.size();
      for (int j=0; j < N; j++) {
        windows.get(j).mWinAnimator.prepareSurfaceLocked(true);
      }
    }
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      testTokenMayBeDrawnLocked(displayId);
      final ScreenRotationAnimation screenRotationAnimation=mDisplayContentsAnimators.valueAt(i).mScreenRotationAnimation;
      if (screenRotationAnimation != null) {
        screenRotationAnimation.updateSurfacesInTransaction();
      }
      mAnimating|=mService.getDisplayContentLocked(displayId).animateDimLayers();
      if (mService.mDisplayMagnifier != null && displayId == Display.DEFAULT_DISPLAY) {
        mService.mDisplayMagnifier.drawMagnifiedRegionBorderIfNeededLocked();
      }
    }
    mService.setFocusedStackLayer();
    if (mService.mWatermark != null) {
      mService.mWatermark.drawIfNeeded();
    }
  }
 catch (  RuntimeException e) {
    Log.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (WindowManagerService.SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  boolean hasPendingLayoutChanges=false;
  final int numDisplays=mService.mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mService.mDisplayContents.valueAt(displayNdx);
    final int pendingChanges=getPendingLayoutChanges(displayContent.getDisplayId());
    if ((pendingChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      mBulkUpdateParams|=SET_WALLPAPER_ACTION_PENDING;
    }
    if (pendingChanges != 0) {
      hasPendingLayoutChanges=true;
    }
  }
  boolean doRequest=false;
  if (mBulkUpdateParams != 0) {
    doRequest=mService.copyAnimToLayoutParamsLocked();
  }
  if (hasPendingLayoutChanges || doRequest) {
    mService.requestTraversalLocked();
  }
  if (mAnimating) {
    mService.scheduleAnimationLocked();
  }
 else   if (wasAnimating) {
    mService.requestTraversalLocked();
  }
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,""String_Node_Str"" + mAnimating + ""String_Node_Str""+ Integer.toHexString(mBulkUpdateParams)+ ""String_Node_Str""+ Integer.toHexString(getPendingLayoutChanges(Display.DEFAULT_DISPLAY)));
  }
}","/** 
 * Locked on mService.mWindowMap. 
 */
private void animateLocked(){
  if (!mInitialized) {
    return;
  }
  mCurrentTime=SystemClock.uptimeMillis();
  mBulkUpdateParams=SET_ORIENTATION_CHANGE_COMPLETE;
  boolean wasAnimating=mAnimating;
  mAnimating=false;
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,""String_Node_Str"" + mCurrentTime);
  }
  if (WindowManagerService.SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  SurfaceControl.setAnimationTransaction();
  try {
    final int numDisplays=mDisplayContentsAnimators.size();
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      updateAppWindowsLocked(displayId);
      DisplayContentsAnimator displayAnimator=mDisplayContentsAnimators.valueAt(i);
      final ScreenRotationAnimation screenRotationAnimation=displayAnimator.mScreenRotationAnimation;
      if (screenRotationAnimation != null && screenRotationAnimation.isAnimating()) {
        if (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) {
          mAnimating=true;
        }
 else {
          mBulkUpdateParams|=SET_UPDATE_ROTATION;
          screenRotationAnimation.kill();
          displayAnimator.mScreenRotationAnimation=null;
        }
      }
      performAnimationsLocked(displayId);
      final WindowList windows=mService.getWindowListLocked(displayId);
      final int N=windows.size();
      for (int j=0; j < N; j++) {
        windows.get(j).mWinAnimator.prepareSurfaceLocked(true);
      }
    }
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      testTokenMayBeDrawnLocked(displayId);
      final ScreenRotationAnimation screenRotationAnimation=mDisplayContentsAnimators.valueAt(i).mScreenRotationAnimation;
      if (screenRotationAnimation != null) {
        screenRotationAnimation.updateSurfacesInTransaction();
      }
      mAnimating|=mService.getDisplayContentLocked(displayId).animateDimLayers();
      if (mService.mDisplayMagnifier != null && displayId == Display.DEFAULT_DISPLAY) {
        mService.mDisplayMagnifier.drawMagnifiedRegionBorderIfNeededLocked();
      }
    }
    if (mAnimating) {
      mService.scheduleAnimationLocked();
    }
    mService.setFocusedStackLayer();
    if (mService.mWatermark != null) {
      mService.mWatermark.drawIfNeeded();
    }
  }
 catch (  RuntimeException e) {
    Log.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (WindowManagerService.SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  boolean hasPendingLayoutChanges=false;
  final int numDisplays=mService.mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mService.mDisplayContents.valueAt(displayNdx);
    final int pendingChanges=getPendingLayoutChanges(displayContent.getDisplayId());
    if ((pendingChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      mBulkUpdateParams|=SET_WALLPAPER_ACTION_PENDING;
    }
    if (pendingChanges != 0) {
      hasPendingLayoutChanges=true;
    }
  }
  boolean doRequest=false;
  if (mBulkUpdateParams != 0) {
    doRequest=mService.copyAnimToLayoutParamsLocked();
  }
  if (hasPendingLayoutChanges || doRequest) {
    mService.requestTraversalLocked();
  }
  if (!mAnimating && wasAnimating) {
    mService.requestTraversalLocked();
  }
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,""String_Node_Str"" + mAnimating + ""String_Node_Str""+ Integer.toHexString(mBulkUpdateParams)+ ""String_Node_Str""+ Integer.toHexString(getPendingLayoutChanges(Display.DEFAULT_DISPLAY)));
  }
}"
1756,"@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=0; i < mUidOps.size(); i++) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      for (      Map.Entry<String,Ops> ent : packages.entrySet()) {
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=0; j < pkgOps.size(); j++) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            pruneOp(curOp,mUidOps.keyAt(i),packageName);
          }
        }
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","@Override public void resetAllModes(){
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  HashMap<Callback,ArrayList<Pair<String,Integer>>> callbacks=null;
synchronized (this) {
    boolean changed=false;
    for (int i=mUidOps.size() - 1; i >= 0; i--) {
      HashMap<String,Ops> packages=mUidOps.valueAt(i);
      Iterator<Map.Entry<String,Ops>> it=packages.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,Ops> ent=it.next();
        String packageName=ent.getKey();
        Ops pkgOps=ent.getValue();
        for (int j=pkgOps.size() - 1; j >= 0; j--) {
          Op curOp=pkgOps.valueAt(j);
          if (curOp.mode != AppOpsManager.MODE_ALLOWED) {
            curOp.mode=AppOpsManager.MODE_ALLOWED;
            changed=true;
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mOpModeWatchers.get(curOp.op));
            callbacks=addCallbacks(callbacks,packageName,curOp.op,mPackageModeWatchers.get(packageName));
            if (curOp.time == 0 && curOp.rejectTime == 0) {
              pkgOps.removeAt(j);
            }
          }
        }
        if (pkgOps.size() == 0) {
          it.remove();
        }
      }
      if (packages.size() == 0) {
        mUidOps.removeAt(i);
      }
    }
    if (changed) {
      scheduleWriteNowLocked();
    }
  }
  if (callbacks != null) {
    for (    Map.Entry<Callback,ArrayList<Pair<String,Integer>>> ent : callbacks.entrySet()) {
      Callback cb=ent.getKey();
      ArrayList<Pair<String,Integer>> reports=ent.getValue();
      for (int i=0; i < reports.size(); i++) {
        Pair<String,Integer> rep=reports.get(i);
        try {
          cb.mCallback.opChanged(rep.second,rep.first);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}"
1757,"/** 
 * Locked on mService.mWindowMap. 
 */
private void animateLocked(){
  if (!mInitialized) {
    return;
  }
  mCurrentTime=SystemClock.uptimeMillis();
  mBulkUpdateParams=SET_ORIENTATION_CHANGE_COMPLETE;
  boolean wasAnimating=mAnimating;
  mAnimating=false;
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,""String_Node_Str"" + mCurrentTime);
  }
  if (WindowManagerService.SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  SurfaceControl.setAnimationTransaction();
  try {
    final int numDisplays=mDisplayContentsAnimators.size();
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      updateAppWindowsLocked(displayId);
      DisplayContentsAnimator displayAnimator=mDisplayContentsAnimators.valueAt(i);
      final ScreenRotationAnimation screenRotationAnimation=displayAnimator.mScreenRotationAnimation;
      if (screenRotationAnimation != null && screenRotationAnimation.isAnimating()) {
        if (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) {
          mAnimating=true;
        }
 else {
          mBulkUpdateParams|=SET_UPDATE_ROTATION;
          screenRotationAnimation.kill();
          displayAnimator.mScreenRotationAnimation=null;
        }
      }
      performAnimationsLocked(displayId);
      final WindowList windows=mService.getWindowListLocked(displayId);
      final int N=windows.size();
      for (int j=0; j < N; j++) {
        windows.get(j).mWinAnimator.prepareSurfaceLocked(true);
      }
    }
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      testTokenMayBeDrawnLocked(displayId);
      final ScreenRotationAnimation screenRotationAnimation=mDisplayContentsAnimators.valueAt(i).mScreenRotationAnimation;
      if (screenRotationAnimation != null) {
        screenRotationAnimation.updateSurfacesInTransaction();
      }
      mAnimating|=mService.getDisplayContentLocked(displayId).animateDimLayers();
      if (mService.mDisplayMagnifier != null && displayId == Display.DEFAULT_DISPLAY) {
        mService.mDisplayMagnifier.drawMagnifiedRegionBorderIfNeededLocked();
      }
    }
    mService.setFocusedStackLayer();
    if (mService.mWatermark != null) {
      mService.mWatermark.drawIfNeeded();
    }
  }
 catch (  RuntimeException e) {
    Log.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (WindowManagerService.SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  boolean hasPendingLayoutChanges=false;
  final int numDisplays=mService.mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mService.mDisplayContents.valueAt(displayNdx);
    final int pendingChanges=getPendingLayoutChanges(displayContent.getDisplayId());
    if ((pendingChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      mBulkUpdateParams|=SET_WALLPAPER_ACTION_PENDING;
    }
    if (pendingChanges != 0) {
      hasPendingLayoutChanges=true;
    }
  }
  boolean doRequest=false;
  if (mBulkUpdateParams != 0) {
    doRequest=mService.copyAnimToLayoutParamsLocked();
  }
  if (hasPendingLayoutChanges || doRequest) {
    mService.requestTraversalLocked();
  }
  if (mAnimating) {
    mService.scheduleAnimationLocked();
  }
 else   if (wasAnimating) {
    mService.requestTraversalLocked();
  }
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,""String_Node_Str"" + mAnimating + ""String_Node_Str""+ Integer.toHexString(mBulkUpdateParams)+ ""String_Node_Str""+ Integer.toHexString(getPendingLayoutChanges(Display.DEFAULT_DISPLAY)));
  }
}","/** 
 * Locked on mService.mWindowMap. 
 */
private void animateLocked(){
  if (!mInitialized) {
    return;
  }
  mCurrentTime=SystemClock.uptimeMillis();
  mBulkUpdateParams=SET_ORIENTATION_CHANGE_COMPLETE;
  boolean wasAnimating=mAnimating;
  mAnimating=false;
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,""String_Node_Str"" + mCurrentTime);
  }
  if (WindowManagerService.SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  SurfaceControl.setAnimationTransaction();
  try {
    final int numDisplays=mDisplayContentsAnimators.size();
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      updateAppWindowsLocked(displayId);
      DisplayContentsAnimator displayAnimator=mDisplayContentsAnimators.valueAt(i);
      final ScreenRotationAnimation screenRotationAnimation=displayAnimator.mScreenRotationAnimation;
      if (screenRotationAnimation != null && screenRotationAnimation.isAnimating()) {
        if (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) {
          mAnimating=true;
        }
 else {
          mBulkUpdateParams|=SET_UPDATE_ROTATION;
          screenRotationAnimation.kill();
          displayAnimator.mScreenRotationAnimation=null;
        }
      }
      performAnimationsLocked(displayId);
      final WindowList windows=mService.getWindowListLocked(displayId);
      final int N=windows.size();
      for (int j=0; j < N; j++) {
        windows.get(j).mWinAnimator.prepareSurfaceLocked(true);
      }
    }
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      testTokenMayBeDrawnLocked(displayId);
      final ScreenRotationAnimation screenRotationAnimation=mDisplayContentsAnimators.valueAt(i).mScreenRotationAnimation;
      if (screenRotationAnimation != null) {
        screenRotationAnimation.updateSurfacesInTransaction();
      }
      mAnimating|=mService.getDisplayContentLocked(displayId).animateDimLayers();
      if (mService.mDisplayMagnifier != null && displayId == Display.DEFAULT_DISPLAY) {
        mService.mDisplayMagnifier.drawMagnifiedRegionBorderIfNeededLocked();
      }
    }
    if (mAnimating) {
      mService.scheduleAnimationLocked();
    }
    mService.setFocusedStackLayer();
    if (mService.mWatermark != null) {
      mService.mWatermark.drawIfNeeded();
    }
  }
 catch (  RuntimeException e) {
    Log.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (WindowManagerService.SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  boolean hasPendingLayoutChanges=false;
  final int numDisplays=mService.mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mService.mDisplayContents.valueAt(displayNdx);
    final int pendingChanges=getPendingLayoutChanges(displayContent.getDisplayId());
    if ((pendingChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      mBulkUpdateParams|=SET_WALLPAPER_ACTION_PENDING;
    }
    if (pendingChanges != 0) {
      hasPendingLayoutChanges=true;
    }
  }
  boolean doRequest=false;
  if (mBulkUpdateParams != 0) {
    doRequest=mService.copyAnimToLayoutParamsLocked();
  }
  if (hasPendingLayoutChanges || doRequest) {
    mService.requestTraversalLocked();
  }
  if (!mAnimating && wasAnimating) {
    mService.requestTraversalLocked();
  }
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,""String_Node_Str"" + mAnimating + ""String_Node_Str""+ Integer.toHexString(mBulkUpdateParams)+ ""String_Node_Str""+ Integer.toHexString(getPendingLayoutChanges(Display.DEFAULT_DISPLAY)));
  }
}"
1758,"public void setPrimaryClip(ClipData clip,String callingPackage){
synchronized (this) {
    if (clip != null && clip.getItemCount() <= 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
      return;
    }
    checkDataOwnerLocked(clip,Binder.getCallingUid());
    clearActiveOwnersLocked();
    PerUserClipboard clipboard=getClipboard();
    clipboard.primaryClip=clip;
    final int n=clipboard.primaryClipListeners.beginBroadcast();
    for (int i=0; i < n; i++) {
      try {
        ListenerInfo li=(ListenerInfo)clipboard.primaryClipListeners.getBroadcastCookie(i);
        if (mAppOps.checkOpNoThrow(AppOpsManager.OP_READ_CLIPBOARD,li.mUid,li.mPackageName) == AppOpsManager.MODE_ALLOWED) {
          clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
        }
      }
 catch (      RemoteException e) {
      }
    }
    clipboard.primaryClipListeners.finishBroadcast();
  }
}","public void setPrimaryClip(ClipData clip,String callingPackage){
synchronized (this) {
    if (clip != null && clip.getItemCount() <= 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    final int callingUid=Binder.getCallingUid();
    if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
      return;
    }
    checkDataOwnerLocked(clip,callingUid);
    clearActiveOwnersLocked();
    PerUserClipboard clipboard=getClipboard();
    clipboard.primaryClip=clip;
    final long ident=Binder.clearCallingIdentity();
    final int n=clipboard.primaryClipListeners.beginBroadcast();
    try {
      for (int i=0; i < n; i++) {
        try {
          ListenerInfo li=(ListenerInfo)clipboard.primaryClipListeners.getBroadcastCookie(i);
          if (mAppOps.checkOpNoThrow(AppOpsManager.OP_READ_CLIPBOARD,li.mUid,li.mPackageName) == AppOpsManager.MODE_ALLOWED) {
            clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
  finally {
      clipboard.primaryClipListeners.finishBroadcast();
      Binder.restoreCallingIdentity(ident);
    }
  }
}"
1759,"@Override public final int hashCode(){
  if (!mEntryValid) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final Object key=colGetEntry(mIndex,0);
  final Object value=colGetEntry(mIndex,1);
  return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode());
}","@Override public int hashCode(){
  int result=0;
  for (int i=colGetSize() - 1; i >= 0; i--) {
    Object obj=colGetEntry(i,0);
    result+=obj == null ? 0 : obj.hashCode();
  }
  return result;
}"
1760,"@Override public final boolean equals(Object o){
  if (!mEntryValid) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!(o instanceof Map.Entry)) {
    return false;
  }
  Map.Entry<?,?> e=(Map.Entry<?,?>)o;
  return Objects.equal(e.getKey(),colGetEntry(mIndex,0)) && Objects.equal(e.getValue(),colGetEntry(mIndex,1));
}","@Override public boolean equals(Object object){
  return equalsSetHelper(this,object);
}"
1761,"private static boolean compareMaps(HashMap map,ArrayMap array){
  if (map.size() != array.size()) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + map.size() + ""String_Node_Str""+ array.size());
    return false;
  }
  Set<Map.Entry> mapSet=map.entrySet();
  for (  Map.Entry entry : mapSet) {
    Object expValue=entry.getValue();
    Object gotValue=array.get(entry.getKey());
    if (!compare(expValue,gotValue)) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + expValue + ""String_Node_Str""+ gotValue+ ""String_Node_Str""+ entry.getKey());
      return false;
    }
  }
  for (int i=0; i < array.size(); i++) {
    Object gotValue=array.valueAt(i);
    Object key=array.keyAt(i);
    Object expValue=map.get(key);
    if (!compare(expValue,gotValue)) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + expValue + ""String_Node_Str""+ gotValue+ ""String_Node_Str""+ key);
      return false;
    }
  }
  return true;
}","private static boolean compareMaps(HashMap map,ArrayMap array){
  if (map.size() != array.size()) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + map.size() + ""String_Node_Str""+ array.size());
    return false;
  }
  Set<Map.Entry> mapSet=map.entrySet();
  for (  Map.Entry entry : mapSet) {
    Object expValue=entry.getValue();
    Object gotValue=array.get(entry.getKey());
    if (!compare(expValue,gotValue)) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + expValue + ""String_Node_Str""+ gotValue+ ""String_Node_Str""+ entry.getKey());
      return false;
    }
  }
  for (int i=0; i < array.size(); i++) {
    Object gotValue=array.valueAt(i);
    Object key=array.keyAt(i);
    Object expValue=map.get(key);
    if (!compare(expValue,gotValue)) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + expValue + ""String_Node_Str""+ gotValue+ ""String_Node_Str""+ key);
      return false;
    }
  }
  if (map.entrySet().hashCode() != array.entrySet().hashCode()) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + Integer.toHexString(map.entrySet().hashCode()) + ""String_Node_Str""+ Integer.toHexString(array.entrySet().hashCode()));
    return false;
  }
  if (!map.entrySet().equals(array.entrySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!array.entrySet().equals(map.entrySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (map.keySet().hashCode() != array.keySet().hashCode()) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + Integer.toHexString(map.keySet().hashCode()) + ""String_Node_Str""+ Integer.toHexString(array.keySet().hashCode()));
    return false;
  }
  if (!map.keySet().equals(array.keySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!array.keySet().equals(map.keySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!map.keySet().containsAll(array.keySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!array.keySet().containsAll(map.keySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!array.containsAll(map.keySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!map.entrySet().containsAll(array.entrySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!array.entrySet().containsAll(map.entrySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  return true;
}"
1762,"@Override public final int hashCode(){
  if (!mEntryValid) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final Object key=colGetEntry(mIndex,0);
  final Object value=colGetEntry(mIndex,1);
  return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode());
}","@Override public int hashCode(){
  int result=0;
  for (int i=colGetSize() - 1; i >= 0; i--) {
    Object obj=colGetEntry(i,0);
    result+=obj == null ? 0 : obj.hashCode();
  }
  return result;
}"
1763,"@Override public final boolean equals(Object o){
  if (!mEntryValid) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!(o instanceof Map.Entry)) {
    return false;
  }
  Map.Entry<?,?> e=(Map.Entry<?,?>)o;
  return Objects.equal(e.getKey(),colGetEntry(mIndex,0)) && Objects.equal(e.getValue(),colGetEntry(mIndex,1));
}","@Override public boolean equals(Object object){
  return equalsSetHelper(this,object);
}"
1764,"private static boolean compareMaps(HashMap map,ArrayMap array){
  if (map.size() != array.size()) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + map.size() + ""String_Node_Str""+ array.size());
    return false;
  }
  Set<Map.Entry> mapSet=map.entrySet();
  for (  Map.Entry entry : mapSet) {
    Object expValue=entry.getValue();
    Object gotValue=array.get(entry.getKey());
    if (!compare(expValue,gotValue)) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + expValue + ""String_Node_Str""+ gotValue+ ""String_Node_Str""+ entry.getKey());
      return false;
    }
  }
  for (int i=0; i < array.size(); i++) {
    Object gotValue=array.valueAt(i);
    Object key=array.keyAt(i);
    Object expValue=map.get(key);
    if (!compare(expValue,gotValue)) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + expValue + ""String_Node_Str""+ gotValue+ ""String_Node_Str""+ key);
      return false;
    }
  }
  return true;
}","private static boolean compareMaps(HashMap map,ArrayMap array){
  if (map.size() != array.size()) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + map.size() + ""String_Node_Str""+ array.size());
    return false;
  }
  Set<Map.Entry> mapSet=map.entrySet();
  for (  Map.Entry entry : mapSet) {
    Object expValue=entry.getValue();
    Object gotValue=array.get(entry.getKey());
    if (!compare(expValue,gotValue)) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + expValue + ""String_Node_Str""+ gotValue+ ""String_Node_Str""+ entry.getKey());
      return false;
    }
  }
  for (int i=0; i < array.size(); i++) {
    Object gotValue=array.valueAt(i);
    Object key=array.keyAt(i);
    Object expValue=map.get(key);
    if (!compare(expValue,gotValue)) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + expValue + ""String_Node_Str""+ gotValue+ ""String_Node_Str""+ key);
      return false;
    }
  }
  if (map.entrySet().hashCode() != array.entrySet().hashCode()) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + Integer.toHexString(map.entrySet().hashCode()) + ""String_Node_Str""+ Integer.toHexString(array.entrySet().hashCode()));
    return false;
  }
  if (!map.entrySet().equals(array.entrySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!array.entrySet().equals(map.entrySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (map.keySet().hashCode() != array.keySet().hashCode()) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + Integer.toHexString(map.keySet().hashCode()) + ""String_Node_Str""+ Integer.toHexString(array.keySet().hashCode()));
    return false;
  }
  if (!map.keySet().equals(array.keySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!array.keySet().equals(map.keySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!map.keySet().containsAll(array.keySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!array.keySet().containsAll(map.keySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!array.containsAll(map.keySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!map.entrySet().containsAll(array.entrySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!array.entrySet().containsAll(map.entrySet())) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  return true;
}"
1765,"public void setPrimaryClip(ClipData clip,String callingPackage){
synchronized (this) {
    if (clip != null && clip.getItemCount() <= 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
      return;
    }
    checkDataOwnerLocked(clip,Binder.getCallingUid());
    clearActiveOwnersLocked();
    PerUserClipboard clipboard=getClipboard();
    clipboard.primaryClip=clip;
    final int n=clipboard.primaryClipListeners.beginBroadcast();
    for (int i=0; i < n; i++) {
      try {
        ListenerInfo li=(ListenerInfo)clipboard.primaryClipListeners.getBroadcastCookie(i);
        if (mAppOps.checkOpNoThrow(AppOpsManager.OP_READ_CLIPBOARD,li.mUid,li.mPackageName) == AppOpsManager.MODE_ALLOWED) {
          clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
        }
      }
 catch (      RemoteException e) {
      }
    }
    clipboard.primaryClipListeners.finishBroadcast();
  }
}","public void setPrimaryClip(ClipData clip,String callingPackage){
synchronized (this) {
    if (clip != null && clip.getItemCount() <= 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    final int callingUid=Binder.getCallingUid();
    if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
      return;
    }
    checkDataOwnerLocked(clip,callingUid);
    clearActiveOwnersLocked();
    PerUserClipboard clipboard=getClipboard();
    clipboard.primaryClip=clip;
    final long ident=Binder.clearCallingIdentity();
    final int n=clipboard.primaryClipListeners.beginBroadcast();
    try {
      for (int i=0; i < n; i++) {
        try {
          ListenerInfo li=(ListenerInfo)clipboard.primaryClipListeners.getBroadcastCookie(i);
          if (mAppOps.checkOpNoThrow(AppOpsManager.OP_READ_CLIPBOARD,li.mUid,li.mPackageName) == AppOpsManager.MODE_ALLOWED) {
            clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
  finally {
      clipboard.primaryClipListeners.finishBroadcast();
      Binder.restoreCallingIdentity(ident);
    }
  }
}"
1766,"public void setPrimaryClip(ClipData clip,String callingPackage){
synchronized (this) {
    if (clip != null && clip.getItemCount() <= 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
      return;
    }
    checkDataOwnerLocked(clip,Binder.getCallingUid());
    clearActiveOwnersLocked();
    PerUserClipboard clipboard=getClipboard();
    clipboard.primaryClip=clip;
    final int n=clipboard.primaryClipListeners.beginBroadcast();
    for (int i=0; i < n; i++) {
      try {
        ListenerInfo li=(ListenerInfo)clipboard.primaryClipListeners.getBroadcastCookie(i);
        if (mAppOps.checkOpNoThrow(AppOpsManager.OP_READ_CLIPBOARD,li.mUid,li.mPackageName) == AppOpsManager.MODE_ALLOWED) {
          clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
        }
      }
 catch (      RemoteException e) {
      }
    }
    clipboard.primaryClipListeners.finishBroadcast();
  }
}","public void setPrimaryClip(ClipData clip,String callingPackage){
synchronized (this) {
    if (clip != null && clip.getItemCount() <= 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    final int callingUid=Binder.getCallingUid();
    if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
      return;
    }
    checkDataOwnerLocked(clip,callingUid);
    clearActiveOwnersLocked();
    PerUserClipboard clipboard=getClipboard();
    clipboard.primaryClip=clip;
    final long ident=Binder.clearCallingIdentity();
    final int n=clipboard.primaryClipListeners.beginBroadcast();
    try {
      for (int i=0; i < n; i++) {
        try {
          ListenerInfo li=(ListenerInfo)clipboard.primaryClipListeners.getBroadcastCookie(i);
          if (mAppOps.checkOpNoThrow(AppOpsManager.OP_READ_CLIPBOARD,li.mUid,li.mPackageName) == AppOpsManager.MODE_ALLOWED) {
            clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
  finally {
      clipboard.primaryClipListeners.finishBroadcast();
      Binder.restoreCallingIdentity(ident);
    }
  }
}"
1767,"public void setPrimaryClip(ClipData clip,String callingPackage){
synchronized (this) {
    if (clip != null && clip.getItemCount() <= 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
      return;
    }
    checkDataOwnerLocked(clip,Binder.getCallingUid());
    clearActiveOwnersLocked();
    PerUserClipboard clipboard=getClipboard();
    clipboard.primaryClip=clip;
    final int n=clipboard.primaryClipListeners.beginBroadcast();
    for (int i=0; i < n; i++) {
      try {
        ListenerInfo li=(ListenerInfo)clipboard.primaryClipListeners.getBroadcastCookie(i);
        if (mAppOps.checkOpNoThrow(AppOpsManager.OP_READ_CLIPBOARD,li.mUid,li.mPackageName) == AppOpsManager.MODE_ALLOWED) {
          clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
        }
      }
 catch (      RemoteException e) {
      }
    }
    clipboard.primaryClipListeners.finishBroadcast();
  }
}","public void setPrimaryClip(ClipData clip,String callingPackage){
synchronized (this) {
    if (clip != null && clip.getItemCount() <= 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    final int callingUid=Binder.getCallingUid();
    if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
      return;
    }
    checkDataOwnerLocked(clip,callingUid);
    clearActiveOwnersLocked();
    PerUserClipboard clipboard=getClipboard();
    clipboard.primaryClip=clip;
    final long ident=Binder.clearCallingIdentity();
    final int n=clipboard.primaryClipListeners.beginBroadcast();
    try {
      for (int i=0; i < n; i++) {
        try {
          ListenerInfo li=(ListenerInfo)clipboard.primaryClipListeners.getBroadcastCookie(i);
          if (mAppOps.checkOpNoThrow(AppOpsManager.OP_READ_CLIPBOARD,li.mUid,li.mPackageName) == AppOpsManager.MODE_ALLOWED) {
            clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
  finally {
      clipboard.primaryClipListeners.finishBroadcast();
      Binder.restoreCallingIdentity(ident);
    }
  }
}"
1768,"public void setPrimaryClip(ClipData clip,String callingPackage){
synchronized (this) {
    if (clip != null && clip.getItemCount() <= 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
      return;
    }
    checkDataOwnerLocked(clip,Binder.getCallingUid());
    clearActiveOwnersLocked();
    PerUserClipboard clipboard=getClipboard();
    clipboard.primaryClip=clip;
    final int n=clipboard.primaryClipListeners.beginBroadcast();
    for (int i=0; i < n; i++) {
      try {
        ListenerInfo li=(ListenerInfo)clipboard.primaryClipListeners.getBroadcastCookie(i);
        if (mAppOps.checkOpNoThrow(AppOpsManager.OP_READ_CLIPBOARD,li.mUid,li.mPackageName) == AppOpsManager.MODE_ALLOWED) {
          clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
        }
      }
 catch (      RemoteException e) {
      }
    }
    clipboard.primaryClipListeners.finishBroadcast();
  }
}","public void setPrimaryClip(ClipData clip,String callingPackage){
synchronized (this) {
    if (clip != null && clip.getItemCount() <= 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    final int callingUid=Binder.getCallingUid();
    if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
      return;
    }
    checkDataOwnerLocked(clip,callingUid);
    clearActiveOwnersLocked();
    PerUserClipboard clipboard=getClipboard();
    clipboard.primaryClip=clip;
    final long ident=Binder.clearCallingIdentity();
    final int n=clipboard.primaryClipListeners.beginBroadcast();
    try {
      for (int i=0; i < n; i++) {
        try {
          ListenerInfo li=(ListenerInfo)clipboard.primaryClipListeners.getBroadcastCookie(i);
          if (mAppOps.checkOpNoThrow(AppOpsManager.OP_READ_CLIPBOARD,li.mUid,li.mPackageName) == AppOpsManager.MODE_ALLOWED) {
            clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
  finally {
      clipboard.primaryClipListeners.finishBroadcast();
      Binder.restoreCallingIdentity(ident);
    }
  }
}"
1769,"public void setPrimaryClip(ClipData clip,String callingPackage){
synchronized (this) {
    if (clip != null && clip.getItemCount() <= 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
      return;
    }
    checkDataOwnerLocked(clip,Binder.getCallingUid());
    clearActiveOwnersLocked();
    PerUserClipboard clipboard=getClipboard();
    clipboard.primaryClip=clip;
    final int n=clipboard.primaryClipListeners.beginBroadcast();
    for (int i=0; i < n; i++) {
      try {
        ListenerInfo li=(ListenerInfo)clipboard.primaryClipListeners.getBroadcastCookie(i);
        if (mAppOps.checkOpNoThrow(AppOpsManager.OP_READ_CLIPBOARD,li.mUid,li.mPackageName) == AppOpsManager.MODE_ALLOWED) {
          clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
        }
      }
 catch (      RemoteException e) {
      }
    }
    clipboard.primaryClipListeners.finishBroadcast();
  }
}","public void setPrimaryClip(ClipData clip,String callingPackage){
synchronized (this) {
    if (clip != null && clip.getItemCount() <= 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    final int callingUid=Binder.getCallingUid();
    if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
      return;
    }
    checkDataOwnerLocked(clip,callingUid);
    clearActiveOwnersLocked();
    PerUserClipboard clipboard=getClipboard();
    clipboard.primaryClip=clip;
    final long ident=Binder.clearCallingIdentity();
    final int n=clipboard.primaryClipListeners.beginBroadcast();
    try {
      for (int i=0; i < n; i++) {
        try {
          ListenerInfo li=(ListenerInfo)clipboard.primaryClipListeners.getBroadcastCookie(i);
          if (mAppOps.checkOpNoThrow(AppOpsManager.OP_READ_CLIPBOARD,li.mUid,li.mPackageName) == AppOpsManager.MODE_ALLOWED) {
            clipboard.primaryClipListeners.getBroadcastItem(i).dispatchPrimaryClipChanged();
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
  finally {
      clipboard.primaryClipListeners.finishBroadcast();
      Binder.restoreCallingIdentity(ident);
    }
  }
}"
1770,"final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedBackground && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numCached);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numEmpty);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
boolean allChanged;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
final int numCachedAndEmpty=numCached + numEmpty;
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int step=0;
int fgTrimLevel;
int memFactor;
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_LOW;
}
 else {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_MODERATE;
}
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
allChanged=mProcessTracker.setMemFactorLocked(memFactor,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(memFactor,now);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
allChanged=mProcessTracker.setMemFactorLocked(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,now);
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false);
}
if (mProcessTracker.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessTracker.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}","final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedBackground && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numCached);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numEmpty);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
boolean allChanged;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
final int numCachedAndEmpty=numCached + numEmpty;
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int step=0;
int fgTrimLevel;
int memFactor;
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_LOW;
}
 else {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_MODERATE;
}
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
allChanged=mProcessTracker.setMemFactorLocked(memFactor,!mSleeping,now);
final int trackerMemFactor=mProcessTracker.getMemFactorLocked();
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(trackerMemFactor,now);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
allChanged=mProcessTracker.setMemFactorLocked(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
final int trackerMemFactor=mProcessTracker.getMemFactorLocked();
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(trackerMemFactor,now);
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false);
}
if (mProcessTracker.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessTracker.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}"
1771,"void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpAll){
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      for (int iproc=0; iproc < NPROCS; iproc++) {
        ProcessState proc=pkgState.mProcesses.valueAt(iproc);
        pw.print(""String_Node_Str"");
        pw.print(pkgState.mProcesses.keyAt(iproc));
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        pw.print(""String_Node_Str"");
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        if (svc.mStartedCount != 0) {
          pw.print(""String_Node_Str"");
          pw.print(svc.mStartedCount);
          pw.println(""String_Node_Str"");
          dumpSingleTime(pw,""String_Node_Str"",svc.mStartedDurations,svc.mStartedState,svc.mStartedStartTime,now);
        }
        if (svc.mBoundCount != 0) {
          pw.print(""String_Node_Str"");
          pw.print(svc.mBoundCount);
          pw.println(""String_Node_Str"");
          dumpSingleTime(pw,""String_Node_Str"",svc.mBoundDurations,svc.mBoundState,svc.mBoundStartTime,now);
        }
        if (svc.mExecCount != 0) {
          pw.print(""String_Node_Str"");
          pw.print(svc.mExecCount);
          pw.println(""String_Node_Str"");
          dumpSingleTime(pw,""String_Node_Str"",svc.mExecDurations,svc.mExecState,svc.mExecStartTime,now);
        }
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println(""String_Node_Str"");
    dumpSummaryLocked(pw,reqPackage,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mFile.getBaseFile());
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}","void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc.mStartedCount,svc.mStartedDurations,svc.mStartedState,svc.mStartedStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc.mBoundCount,svc.mBoundDurations,svc.mBoundState,svc.mBoundStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc.mExecCount,svc.mExecDurations,svc.mExecState,svc.mExecStartTime,now,totalTime,dumpAll);
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println(""String_Node_Str"");
    dumpSummaryLocked(pw,reqPackage,now);
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mFile.getBaseFile());
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}"
1772,"private static void printSizeValue(PrintWriter pw,long number){
  float result=number;
  String suffix=""String_Node_Str"";
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  String value;
  if (result < 1) {
    value=String.format(""String_Node_Str"",result);
  }
 else   if (result < 10) {
    value=String.format(""String_Node_Str"",result);
  }
 else   if (result < 100) {
    value=String.format(""String_Node_Str"",result);
  }
 else {
    value=String.format(""String_Node_Str"",result);
  }
  pw.print(value);
  pw.print(suffix);
}","static void printSizeValue(PrintWriter pw,long number){
  float result=number;
  String suffix=""String_Node_Str"";
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  String value;
  if (result < 1) {
    value=String.format(""String_Node_Str"",result);
  }
 else   if (result < 10) {
    value=String.format(""String_Node_Str"",result);
  }
 else   if (result < 100) {
    value=String.format(""String_Node_Str"",result);
  }
 else {
    value=String.format(""String_Node_Str"",result);
  }
  pw.print(value);
  pw.print(suffix);
}"
1773,"static void dumpProcessSummaryLocked(PrintWriter pw,String prefix,ArrayList<ProcessState> procs,int[] screenStates,int[] memStates,int[] procStates,long now,long totalTime){
  for (int i=procs.size() - 1; i >= 0; i--) {
    ProcessState proc=procs.get(i);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(proc.mName);
    pw.print(""String_Node_Str"");
    UserHandle.formatUid(pw,proc.mUid);
    pw.println(""String_Node_Str"");
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,procStates,now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_PERSISTENT},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_TOP},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_IMPORTANT_FOREGROUND},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_IMPORTANT_BACKGROUND},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_BACKUP},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_HEAVY_WEIGHT},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_SERVICE},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_RECEIVER},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_HOME},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_LAST_ACTIVITY},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_CACHED_ACTIVITY_CLIENT,STATE_CACHED_ACTIVITY_CLIENT,STATE_CACHED_EMPTY},now,totalTime,true);
  }
}","static void dumpProcessSummaryLocked(PrintWriter pw,String prefix,ArrayList<ProcessState> procs,int[] screenStates,int[] memStates,int[] procStates,long now,long totalTime){
  for (int i=procs.size() - 1; i >= 0; i--) {
    ProcessState proc=procs.get(i);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(proc.mName);
    pw.print(""String_Node_Str"");
    UserHandle.formatUid(pw,proc.mUid);
    pw.println(""String_Node_Str"");
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,procStates,now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_PERSISTENT},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_TOP},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_IMPORTANT_FOREGROUND},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_IMPORTANT_BACKGROUND},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_BACKUP},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_HEAVY_WEIGHT},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_SERVICE},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_RECEIVER},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_HOME},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_LAST_ACTIVITY},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_CACHED_ACTIVITY,STATE_CACHED_ACTIVITY_CLIENT,STATE_CACHED_EMPTY},now,totalTime,true);
  }
}"
1774,"public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ADJ_SCREEN_OFF,ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=new int[]{STATE_PERSISTENT,STATE_TOP,STATE_IMPORTANT_FOREGROUND,STATE_IMPORTANT_BACKGROUND,STATE_BACKUP,STATE_HEAVY_WEIGHT,STATE_SERVICE,STATE_RECEIVER,STATE_HOME,STATE_LAST_ACTIVITY,STATE_CACHED_ACTIVITY,STATE_CACHED_ACTIVITY_CLIENT,STATE_CACHED_EMPTY};
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ADJ_SCREEN_NAMES_CSV,ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        mState.mFlags|=State.FLAG_COMPLETE;
        mState.writeStateLocked(true,true);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        writeStateSyncLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        readLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mLock) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            State state=new State(files.get(i));
            if (state.mReadError != null) {
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(state.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=state.mFile.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              state.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(state.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              if (dumpDetails) {
                state.dumpLocked(pw,reqPackage,now,dumpAll);
              }
 else {
                state.dumpSummaryLocked(pw,reqPackage,now);
              }
            }
            if (isCheckin) {
              state.mFile.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mLock) {
      if (isCompact) {
        mState.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mState.dumpLocked(pw,reqPackage,now,dumpAll);
        }
 else {
          mState.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}","public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ADJ_SCREEN_OFF,ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ADJ_SCREEN_NAMES_CSV,ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        mState.mFlags|=State.FLAG_COMPLETE;
        mState.writeStateLocked(true,true);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        writeStateSyncLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        readLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mLock) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            State state=new State(files.get(i));
            if (state.mReadError != null) {
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(state.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=state.mFile.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              state.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(state.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              if (dumpDetails) {
                state.dumpLocked(pw,reqPackage,now,dumpAll);
              }
 else {
                state.dumpSummaryLocked(pw,reqPackage,now);
              }
            }
            if (isCheckin) {
              state.mFile.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mLock) {
      if (isCompact) {
        mState.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mState.dumpLocked(pw,reqPackage,now,dumpAll);
        }
 else {
          mState.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}"
1775,"void print(PrintWriter pw,long overallTime,boolean full){
  double percent=((double)totalTime / (double)overallTime) * 100;
  if (percent < 1) {
    pw.print(String.format(""String_Node_Str"",percent));
  }
 else   if (percent < 10) {
    pw.print(String.format(""String_Node_Str"",percent));
  }
 else {
    pw.print(String.format(""String_Node_Str"",percent));
  }
  pw.print(""String_Node_Str"");
  if (numPss > 0) {
    pw.print(""String_Node_Str"");
    printSizeValue(pw,minPss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,avgPss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,maxPss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,minUss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,avgUss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,maxUss * 1024);
    if (full) {
      pw.print(""String_Node_Str"");
      pw.print(numPss);
    }
    pw.print(""String_Node_Str"");
  }
}","void print(PrintWriter pw,long overallTime,boolean full){
  printPercent(pw,(double)totalTime / (double)overallTime);
  if (numPss > 0) {
    pw.print(""String_Node_Str"");
    printSizeValue(pw,minPss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,avgPss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,maxPss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,minUss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,avgUss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,maxUss * 1024);
    if (full) {
      pw.print(""String_Node_Str"");
      pw.print(numPss);
    }
    pw.print(""String_Node_Str"");
  }
}"
1776,"void dumpSummaryLocked(PrintWriter pw,String reqPackage,long now){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  dumpFilteredSummaryLocked(pw,null,""String_Node_Str"",ALL_SCREEN_ADJ,ALL_MEM_ADJ,new int[]{STATE_PERSISTENT,STATE_TOP,STATE_IMPORTANT_FOREGROUND,STATE_IMPORTANT_BACKGROUND,STATE_BACKUP,STATE_HEAVY_WEIGHT,STATE_SERVICE,STATE_RECEIVER,STATE_HOME},now,totalTime,reqPackage);
  pw.println();
  pw.println(""String_Node_Str"");
  dumpSingleTime(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(DateFormat.format(""String_Node_Str"",mTimePeriodStartClock));
  pw.println();
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration((mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime) - mTimePeriodStartRealtime,pw);
  if ((mFlags & FLAG_COMPLETE) != 0)   pw.print(""String_Node_Str"");
 else   if ((mFlags & FLAG_SHUTDOWN) != 0)   pw.print(""String_Node_Str"");
 else   pw.print(""String_Node_Str"");
  pw.println();
}","void dumpSummaryLocked(PrintWriter pw,String reqPackage,long now){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  dumpFilteredSummaryLocked(pw,null,""String_Node_Str"",ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime,reqPackage);
  pw.println();
  dumpTotalsLocked(pw,now);
}"
1777,"final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedBackground && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numCached);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numEmpty);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
boolean allChanged;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
final int numCachedAndEmpty=numCached + numEmpty;
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int step=0;
int fgTrimLevel;
int memFactor;
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_LOW;
}
 else {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_MODERATE;
}
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
allChanged=mProcessTracker.setMemFactorLocked(memFactor,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(memFactor,now);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
allChanged=mProcessTracker.setMemFactorLocked(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,now);
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false);
}
if (mProcessTracker.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessTracker.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}","final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedBackground && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numCached);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numEmpty);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
boolean allChanged;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
final int numCachedAndEmpty=numCached + numEmpty;
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int step=0;
int fgTrimLevel;
int memFactor;
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_LOW;
}
 else {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_MODERATE;
}
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
allChanged=mProcessTracker.setMemFactorLocked(memFactor,!mSleeping,now);
final int trackerMemFactor=mProcessTracker.getMemFactorLocked();
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(trackerMemFactor,now);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
allChanged=mProcessTracker.setMemFactorLocked(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
final int trackerMemFactor=mProcessTracker.getMemFactorLocked();
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(trackerMemFactor,now);
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false);
}
if (mProcessTracker.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessTracker.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}"
1778,"void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpAll){
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      for (int iproc=0; iproc < NPROCS; iproc++) {
        ProcessState proc=pkgState.mProcesses.valueAt(iproc);
        pw.print(""String_Node_Str"");
        pw.print(pkgState.mProcesses.keyAt(iproc));
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        pw.print(""String_Node_Str"");
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        if (svc.mStartedCount != 0) {
          pw.print(""String_Node_Str"");
          pw.print(svc.mStartedCount);
          pw.println(""String_Node_Str"");
          dumpSingleTime(pw,""String_Node_Str"",svc.mStartedDurations,svc.mStartedState,svc.mStartedStartTime,now);
        }
        if (svc.mBoundCount != 0) {
          pw.print(""String_Node_Str"");
          pw.print(svc.mBoundCount);
          pw.println(""String_Node_Str"");
          dumpSingleTime(pw,""String_Node_Str"",svc.mBoundDurations,svc.mBoundState,svc.mBoundStartTime,now);
        }
        if (svc.mExecCount != 0) {
          pw.print(""String_Node_Str"");
          pw.print(svc.mExecCount);
          pw.println(""String_Node_Str"");
          dumpSingleTime(pw,""String_Node_Str"",svc.mExecDurations,svc.mExecState,svc.mExecStartTime,now);
        }
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println(""String_Node_Str"");
    dumpSummaryLocked(pw,reqPackage,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mFile.getBaseFile());
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}","void dumpLocked(PrintWriter pw,String reqPackage,long now,boolean dumpAll){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkgName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.println(""String_Node_Str"");
      }
      if (dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print(""String_Node_Str"");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          pw.print(""String_Node_Str"");
          pw.print(proc.mDurationsTableSize);
          pw.print(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          procs.add(pkgState.mProcesses.valueAt(iproc));
        }
        dumpProcessSummaryLocked(pw,""String_Node_Str"",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        if (dumpAll) {
          pw.print(""String_Node_Str"");
        }
 else {
          pw.print(""String_Node_Str"");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(""String_Node_Str"");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc.mStartedCount,svc.mStartedDurations,svc.mStartedState,svc.mStartedStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc.mBoundCount,svc.mBoundDurations,svc.mBoundState,svc.mBoundStartTime,now,totalTime,dumpAll);
        dumpServiceStats(pw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",svc.mExecCount,svc.mExecDurations,svc.mExecState,svc.mExecStartTime,now,totalTime,dumpAll);
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println(""String_Node_Str"");
          printedHeader=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(procName);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,uid);
        pw.print(""String_Node_Str"");
        pw.print(proc.mDurationsTableSize);
        pw.print(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        dumpProcessState(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,""String_Node_Str"",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println(""String_Node_Str"");
    dumpSummaryLocked(pw,reqPackage,now);
  }
 else {
    pw.println();
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.println(mFile.getBaseFile());
    pw.print(""String_Node_Str"");
    pw.println(mLongs.size());
    pw.print(""String_Node_Str"");
    pw.println(mNextLong);
    pw.print(""String_Node_Str"");
    pw.println(mRunning);
  }
}"
1779,"private static void printSizeValue(PrintWriter pw,long number){
  float result=number;
  String suffix=""String_Node_Str"";
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  String value;
  if (result < 1) {
    value=String.format(""String_Node_Str"",result);
  }
 else   if (result < 10) {
    value=String.format(""String_Node_Str"",result);
  }
 else   if (result < 100) {
    value=String.format(""String_Node_Str"",result);
  }
 else {
    value=String.format(""String_Node_Str"",result);
  }
  pw.print(value);
  pw.print(suffix);
}","static void printSizeValue(PrintWriter pw,long number){
  float result=number;
  String suffix=""String_Node_Str"";
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  if (result > 900) {
    suffix=""String_Node_Str"";
    result=result / 1024;
  }
  String value;
  if (result < 1) {
    value=String.format(""String_Node_Str"",result);
  }
 else   if (result < 10) {
    value=String.format(""String_Node_Str"",result);
  }
 else   if (result < 100) {
    value=String.format(""String_Node_Str"",result);
  }
 else {
    value=String.format(""String_Node_Str"",result);
  }
  pw.print(value);
  pw.print(suffix);
}"
1780,"static void dumpProcessSummaryLocked(PrintWriter pw,String prefix,ArrayList<ProcessState> procs,int[] screenStates,int[] memStates,int[] procStates,long now,long totalTime){
  for (int i=procs.size() - 1; i >= 0; i--) {
    ProcessState proc=procs.get(i);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(proc.mName);
    pw.print(""String_Node_Str"");
    UserHandle.formatUid(pw,proc.mUid);
    pw.println(""String_Node_Str"");
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,procStates,now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_PERSISTENT},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_TOP},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_IMPORTANT_FOREGROUND},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_IMPORTANT_BACKGROUND},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_BACKUP},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_HEAVY_WEIGHT},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_SERVICE},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_RECEIVER},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_HOME},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_LAST_ACTIVITY},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_CACHED_ACTIVITY_CLIENT,STATE_CACHED_ACTIVITY_CLIENT,STATE_CACHED_EMPTY},now,totalTime,true);
  }
}","static void dumpProcessSummaryLocked(PrintWriter pw,String prefix,ArrayList<ProcessState> procs,int[] screenStates,int[] memStates,int[] procStates,long now,long totalTime){
  for (int i=procs.size() - 1; i >= 0; i--) {
    ProcessState proc=procs.get(i);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(proc.mName);
    pw.print(""String_Node_Str"");
    UserHandle.formatUid(pw,proc.mUid);
    pw.println(""String_Node_Str"");
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,procStates,now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_PERSISTENT},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_TOP},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_IMPORTANT_FOREGROUND},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_IMPORTANT_BACKGROUND},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_BACKUP},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_HEAVY_WEIGHT},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_SERVICE},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_RECEIVER},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_HOME},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_LAST_ACTIVITY},now,totalTime,true);
    dumpProcessSummaryDetails(pw,proc,prefix,""String_Node_Str"",screenStates,memStates,new int[]{STATE_CACHED_ACTIVITY,STATE_CACHED_ACTIVITY_CLIENT,STATE_CACHED_EMPTY},now,totalTime,true);
  }
}"
1781,"public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ADJ_SCREEN_OFF,ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=new int[]{STATE_PERSISTENT,STATE_TOP,STATE_IMPORTANT_FOREGROUND,STATE_IMPORTANT_BACKGROUND,STATE_BACKUP,STATE_HEAVY_WEIGHT,STATE_SERVICE,STATE_RECEIVER,STATE_HOME,STATE_LAST_ACTIVITY,STATE_CACHED_ACTIVITY,STATE_CACHED_ACTIVITY_CLIENT,STATE_CACHED_EMPTY};
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ADJ_SCREEN_NAMES_CSV,ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        mState.mFlags|=State.FLAG_COMPLETE;
        mState.writeStateLocked(true,true);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        writeStateSyncLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        readLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mLock) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            State state=new State(files.get(i));
            if (state.mReadError != null) {
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(state.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=state.mFile.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              state.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(state.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              if (dumpDetails) {
                state.dumpLocked(pw,reqPackage,now,dumpAll);
              }
 else {
                state.dumpSummaryLocked(pw,reqPackage,now);
              }
            }
            if (isCheckin) {
              state.mFile.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mLock) {
      if (isCompact) {
        mState.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mState.dumpLocked(pw,reqPackage,now,dumpAll);
        }
 else {
          mState.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}","public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ADJ_SCREEN_OFF,ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        isCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCompact=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        isCsv=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ADJ_SCREEN_NAMES_CSV,ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println(""String_Node_Str"" + args[i] + ""String_Node_Str""+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        currentOnly=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        mState.mFlags|=State.FLAG_COMPLETE;
        mState.writeStateLocked(true,true);
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        writeStateSyncLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        readLocked();
        pw.println(""String_Node_Str"");
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print(""String_Node_Str"");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(""String_Node_Str"");
        printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(""String_Node_Str"");
        printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(""String_Node_Str"");
        pw.print(STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mLock) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + files.get(i));
          try {
            State state=new State(files.get(i));
            if (state.mReadError != null) {
              pw.print(""String_Node_Str"");
              pw.print(files.get(i));
              pw.print(""String_Node_Str"");
              pw.println(state.mReadError);
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"" + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=state.mFile.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              state.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print(""String_Node_Str"");
              pw.print(state.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(""String_Node_Str"");
              pw.println(""String_Node_Str"");
              if (dumpDetails) {
                state.dumpLocked(pw,reqPackage,now,dumpAll);
              }
 else {
                state.dumpSummaryLocked(pw,reqPackage,now);
              }
            }
            if (isCheckin) {
              state.mFile.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print(""String_Node_Str"");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mLock) {
      if (isCompact) {
        mState.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println(""String_Node_Str"");
        }
        if (dumpDetails) {
          mState.dumpLocked(pw,reqPackage,now,dumpAll);
        }
 else {
          mState.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}"
1782,"void print(PrintWriter pw,long overallTime,boolean full){
  double percent=((double)totalTime / (double)overallTime) * 100;
  if (percent < 1) {
    pw.print(String.format(""String_Node_Str"",percent));
  }
 else   if (percent < 10) {
    pw.print(String.format(""String_Node_Str"",percent));
  }
 else {
    pw.print(String.format(""String_Node_Str"",percent));
  }
  pw.print(""String_Node_Str"");
  if (numPss > 0) {
    pw.print(""String_Node_Str"");
    printSizeValue(pw,minPss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,avgPss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,maxPss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,minUss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,avgUss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,maxUss * 1024);
    if (full) {
      pw.print(""String_Node_Str"");
      pw.print(numPss);
    }
    pw.print(""String_Node_Str"");
  }
}","void print(PrintWriter pw,long overallTime,boolean full){
  printPercent(pw,(double)totalTime / (double)overallTime);
  if (numPss > 0) {
    pw.print(""String_Node_Str"");
    printSizeValue(pw,minPss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,avgPss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,maxPss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,minUss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,avgUss * 1024);
    pw.print(""String_Node_Str"");
    printSizeValue(pw,maxUss * 1024);
    if (full) {
      pw.print(""String_Node_Str"");
      pw.print(numPss);
    }
    pw.print(""String_Node_Str"");
  }
}"
1783,"void dumpSummaryLocked(PrintWriter pw,String reqPackage,long now){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  dumpFilteredSummaryLocked(pw,null,""String_Node_Str"",ALL_SCREEN_ADJ,ALL_MEM_ADJ,new int[]{STATE_PERSISTENT,STATE_TOP,STATE_IMPORTANT_FOREGROUND,STATE_IMPORTANT_BACKGROUND,STATE_BACKUP,STATE_HEAVY_WEIGHT,STATE_SERVICE,STATE_RECEIVER,STATE_HOME},now,totalTime,reqPackage);
  pw.println();
  pw.println(""String_Node_Str"");
  dumpSingleTime(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(DateFormat.format(""String_Node_Str"",mTimePeriodStartClock));
  pw.println();
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration((mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime) - mTimePeriodStartRealtime,pw);
  if ((mFlags & FLAG_COMPLETE) != 0)   pw.print(""String_Node_Str"");
 else   if ((mFlags & FLAG_SHUTDOWN) != 0)   pw.print(""String_Node_Str"");
 else   pw.print(""String_Node_Str"");
  pw.println();
}","void dumpSummaryLocked(PrintWriter pw,String reqPackage,long now){
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  dumpFilteredSummaryLocked(pw,null,""String_Node_Str"",ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime,reqPackage);
  pw.println();
  dumpTotalsLocked(pw,now);
}"
1784,"private void serviceDoneExecutingLocked(ServiceRecord r,boolean inStopping){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inStopping+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
      if (inStopping) {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r);
        mStoppingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessTracker.getMemFactorLocked(),SystemClock.uptimeMillis());
    }
  }
}","private void serviceDoneExecutingLocked(ServiceRecord r,boolean inStopping){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inStopping+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
      if (inStopping) {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r);
        mStoppingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessTracker.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (inStopping) {
        r.tracker.makeInactive();
        r.tracker=null;
      }
    }
  }
}"
1785,"int bindServiceLocked(IApplicationThread caller,IBinder token,Intent service,String resolvedType,IServiceConnection connection,int flags,int userId){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
  final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
  if (callerApp == null) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  ActivityRecord activity=null;
  if (token != null) {
    activity=ActivityRecord.isInStackLocked(token);
    if (activity == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return 0;
    }
  }
  int clientLabel=0;
  PendingIntent clientIntent=null;
  if (callerApp.info.uid == Process.SYSTEM_UID) {
    try {
      clientIntent=(PendingIntent)service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);
    }
 catch (    RuntimeException e) {
    }
    if (clientIntent != null) {
      clientLabel=service.getIntExtra(Intent.EXTRA_CLIENT_LABEL,0);
      if (clientLabel != 0) {
        service=service.cloneFilter();
      }
    }
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,Binder.getCallingPid(),Binder.getCallingUid(),userId,true);
  if (res == null) {
    return 0;
  }
  if (res.record == null) {
    return -1;
  }
  ServiceRecord s=res.record;
  final long origId=Binder.clearCallingIdentity();
  try {
    if (unscheduleServiceRestartLocked(s)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + s);
    }
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!s.hasAutoCreateConnections()) {
        if (s.tracker != null) {
          s.tracker.setBound(true,mAm.mProcessTracker.getMemFactorLocked(),s.lastActivity);
        }
      }
    }
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags,clientLabel,clientIntent);
    IBinder binder=connection.asBinder();
    ArrayList<ConnectionRecord> clist=s.connections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      s.connections.put(binder,clist);
    }
    clist.add(c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.hasAboveClient=true;
    }
    clist=mServiceConnections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      mServiceConnections.put(binder,clist);
    }
    clist.add(c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (bringUpServiceLocked(s,service.getFlags(),false) != null) {
        return 0;
      }
    }
    if (s.app != null) {
      mAm.updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}","int bindServiceLocked(IApplicationThread caller,IBinder token,Intent service,String resolvedType,IServiceConnection connection,int flags,int userId){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
  final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
  if (callerApp == null) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  ActivityRecord activity=null;
  if (token != null) {
    activity=ActivityRecord.isInStackLocked(token);
    if (activity == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return 0;
    }
  }
  int clientLabel=0;
  PendingIntent clientIntent=null;
  if (callerApp.info.uid == Process.SYSTEM_UID) {
    try {
      clientIntent=(PendingIntent)service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);
    }
 catch (    RuntimeException e) {
    }
    if (clientIntent != null) {
      clientLabel=service.getIntExtra(Intent.EXTRA_CLIENT_LABEL,0);
      if (clientLabel != 0) {
        service=service.cloneFilter();
      }
    }
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,Binder.getCallingPid(),Binder.getCallingUid(),userId,true);
  if (res == null) {
    return 0;
  }
  if (res.record == null) {
    return -1;
  }
  ServiceRecord s=res.record;
  final long origId=Binder.clearCallingIdentity();
  try {
    if (unscheduleServiceRestartLocked(s)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + s);
    }
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!s.hasAutoCreateConnections()) {
        ProcessTracker.ServiceState stracker=s.getTracker();
        if (stracker != null) {
          stracker.setBound(true,mAm.mProcessTracker.getMemFactorLocked(),s.lastActivity);
        }
      }
    }
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags,clientLabel,clientIntent);
    IBinder binder=connection.asBinder();
    ArrayList<ConnectionRecord> clist=s.connections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      s.connections.put(binder,clist);
    }
    clist.add(c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.hasAboveClient=true;
    }
    clist=mServiceConnections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      mServiceConnections.put(binder,clist);
    }
    clist.add(c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (bringUpServiceLocked(s,service.getFlags(),false) != null) {
        return 0;
      }
    }
    if (s.app != null) {
      mAm.updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}"
1786,"private final void bumpServiceExecutingLocked(ServiceRecord r,String why){
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + why + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Log.v(TAG,""String_Node_Str"" + why + ""String_Node_Str""+ r.shortName);
  long now=SystemClock.uptimeMillis();
  if (r.executeNesting == 0) {
    if (r.tracker != null) {
      r.tracker.setExecuting(true,mAm.mProcessTracker.getMemFactorLocked(),now);
    }
    if (r.app != null) {
      if (r.app.executingServices.size() == 0) {
        Message msg=mAm.mHandler.obtainMessage(ActivityManagerService.SERVICE_TIMEOUT_MSG);
        msg.obj=r.app;
        mAm.mHandler.sendMessageAtTime(msg,now + SERVICE_TIMEOUT);
      }
      r.app.executingServices.add(r);
    }
  }
  r.executeNesting++;
  r.executingStart=now;
}","private final void bumpServiceExecutingLocked(ServiceRecord r,String why){
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + why + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Log.v(TAG,""String_Node_Str"" + why + ""String_Node_Str""+ r.shortName);
  long now=SystemClock.uptimeMillis();
  if (r.executeNesting == 0) {
    ProcessTracker.ServiceState stracker=r.getTracker();
    if (stracker != null) {
      stracker.setExecuting(true,mAm.mProcessTracker.getMemFactorLocked(),now);
    }
    if (r.app != null) {
      if (r.app.executingServices.size() == 0) {
        Message msg=mAm.mHandler.obtainMessage(ActivityManagerService.SERVICE_TIMEOUT_MSG);
        msg.obj=r.app;
        mAm.mHandler.sendMessageAtTime(msg,now + SERVICE_TIMEOUT);
      }
      r.app.executingServices.add(r);
    }
  }
  r.executeNesting++;
  r.executingStart=now;
}"
1787,"private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  mServiceMap.removeServiceByName(r.name,r.userId);
  mServiceMap.removeServiceByIntent(r.intent,r.userId);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        bumpServiceExecutingLocked(r,""String_Node_Str"");
        mStoppingServices.add(r);
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessTracker.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
  }
}","private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  mServiceMap.removeServiceByName(r.name,r.userId);
  mServiceMap.removeServiceByIntent(r.intent,r.userId);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        bumpServiceExecutingLocked(r,""String_Node_Str"");
        mStoppingServices.add(r);
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessTracker.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.makeInactive();
      r.tracker=null;
    }
  }
}"
1788,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  if (r.tracker != null) {
    r.tracker.setStarted(true,mAm.mProcessTracker.getMemFactorLocked(),r.lastActivity);
  }
  r.callStart=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
synchronized (r.stats.getBatteryStats()) {
    r.stats.startRunningLocked();
  }
  String error=bringUpServiceLocked(r,service.getFlags(),false);
  if (error != null) {
    return new ComponentName(""String_Node_Str"",error);
  }
  return r.name;
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  ProcessTracker.ServiceState stracker=r.getTracker();
  if (stracker != null) {
    stracker.setStarted(true,mAm.mProcessTracker.getMemFactorLocked(),r.lastActivity);
  }
  r.callStart=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
synchronized (r.stats.getBatteryStats()) {
    r.stats.startRunningLocked();
  }
  String error=bringUpServiceLocked(r,service.getFlags(),false);
  if (error != null) {
    return new ComponentName(""String_Node_Str"",error);
  }
  return r.name;
}"
1789,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid,int userId,boolean createIfNeeded){
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ callingUid);
  userId=mAm.handleIncomingUser(callingPid,callingUid,userId,false,true,""String_Node_Str"",null);
  if (service.getComponent() != null) {
    r=mServiceMap.getServiceByName(service.getComponent(),userId);
  }
  if (r == null) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=mServiceMap.getServiceByIntent(filter,userId);
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ userId+ ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags)) {
          userId=0;
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=mServiceMap.getServiceByName(name,userId);
      if (r == null && createIfNeeded) {
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        ProcessTracker.ServiceState tracker=null;
        if ((sInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
          tracker=mAm.mProcessTracker.getServiceStateLocked(sInfo.packageName,sInfo.applicationInfo.uid,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,res,tracker);
        res.setService(r);
        mServiceMap.putServiceByName(name,UserHandle.getUserId(r.appInfo.uid),r);
        mServiceMap.putServiceByIntent(filter,UserHandle.getUserId(r.appInfo.uid),r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.appInfo.uid);
        return new ServiceLookupResult(null,""String_Node_Str"" + r.appInfo.uid);
      }
      Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid,int userId,boolean createIfNeeded){
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ callingUid);
  userId=mAm.handleIncomingUser(callingPid,callingUid,userId,false,true,""String_Node_Str"",null);
  if (service.getComponent() != null) {
    r=mServiceMap.getServiceByName(service.getComponent(),userId);
  }
  if (r == null) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=mServiceMap.getServiceByIntent(filter,userId);
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ userId+ ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags)) {
          userId=0;
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=mServiceMap.getServiceByName(name,userId);
      if (r == null && createIfNeeded) {
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,res);
        res.setService(r);
        mServiceMap.putServiceByName(name,UserHandle.getUserId(r.appInfo.uid),r);
        mServiceMap.putServiceByIntent(filter,UserHandle.getUserId(r.appInfo.uid),r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.appInfo.uid);
        return new ServiceLookupResult(null,""String_Node_Str"" + r.appInfo.uid);
      }
      Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}"
1790,"private void serviceDoneExecutingLocked(ServiceRecord r,boolean inStopping){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inStopping+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
      if (inStopping) {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r);
        mStoppingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessTracker.getMemFactorLocked(),SystemClock.uptimeMillis());
    }
  }
}","private void serviceDoneExecutingLocked(ServiceRecord r,boolean inStopping){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inStopping+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
      if (inStopping) {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r);
        mStoppingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessTracker.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (inStopping) {
        r.tracker.makeInactive();
        r.tracker=null;
      }
    }
  }
}"
1791,"int bindServiceLocked(IApplicationThread caller,IBinder token,Intent service,String resolvedType,IServiceConnection connection,int flags,int userId){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
  final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
  if (callerApp == null) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  ActivityRecord activity=null;
  if (token != null) {
    activity=ActivityRecord.isInStackLocked(token);
    if (activity == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return 0;
    }
  }
  int clientLabel=0;
  PendingIntent clientIntent=null;
  if (callerApp.info.uid == Process.SYSTEM_UID) {
    try {
      clientIntent=(PendingIntent)service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);
    }
 catch (    RuntimeException e) {
    }
    if (clientIntent != null) {
      clientLabel=service.getIntExtra(Intent.EXTRA_CLIENT_LABEL,0);
      if (clientLabel != 0) {
        service=service.cloneFilter();
      }
    }
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,Binder.getCallingPid(),Binder.getCallingUid(),userId,true);
  if (res == null) {
    return 0;
  }
  if (res.record == null) {
    return -1;
  }
  ServiceRecord s=res.record;
  final long origId=Binder.clearCallingIdentity();
  try {
    if (unscheduleServiceRestartLocked(s)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + s);
    }
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!s.hasAutoCreateConnections()) {
        if (s.tracker != null) {
          s.tracker.setBound(true,mAm.mProcessTracker.getMemFactorLocked(),s.lastActivity);
        }
      }
    }
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags,clientLabel,clientIntent);
    IBinder binder=connection.asBinder();
    ArrayList<ConnectionRecord> clist=s.connections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      s.connections.put(binder,clist);
    }
    clist.add(c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.hasAboveClient=true;
    }
    clist=mServiceConnections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      mServiceConnections.put(binder,clist);
    }
    clist.add(c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (bringUpServiceLocked(s,service.getFlags(),false) != null) {
        return 0;
      }
    }
    if (s.app != null) {
      mAm.updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}","int bindServiceLocked(IApplicationThread caller,IBinder token,Intent service,String resolvedType,IServiceConnection connection,int flags,int userId){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
  final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
  if (callerApp == null) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  ActivityRecord activity=null;
  if (token != null) {
    activity=ActivityRecord.isInStackLocked(token);
    if (activity == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return 0;
    }
  }
  int clientLabel=0;
  PendingIntent clientIntent=null;
  if (callerApp.info.uid == Process.SYSTEM_UID) {
    try {
      clientIntent=(PendingIntent)service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);
    }
 catch (    RuntimeException e) {
    }
    if (clientIntent != null) {
      clientLabel=service.getIntExtra(Intent.EXTRA_CLIENT_LABEL,0);
      if (clientLabel != 0) {
        service=service.cloneFilter();
      }
    }
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,Binder.getCallingPid(),Binder.getCallingUid(),userId,true);
  if (res == null) {
    return 0;
  }
  if (res.record == null) {
    return -1;
  }
  ServiceRecord s=res.record;
  final long origId=Binder.clearCallingIdentity();
  try {
    if (unscheduleServiceRestartLocked(s)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + s);
    }
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!s.hasAutoCreateConnections()) {
        ProcessTracker.ServiceState stracker=s.getTracker();
        if (stracker != null) {
          stracker.setBound(true,mAm.mProcessTracker.getMemFactorLocked(),s.lastActivity);
        }
      }
    }
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags,clientLabel,clientIntent);
    IBinder binder=connection.asBinder();
    ArrayList<ConnectionRecord> clist=s.connections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      s.connections.put(binder,clist);
    }
    clist.add(c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.hasAboveClient=true;
    }
    clist=mServiceConnections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      mServiceConnections.put(binder,clist);
    }
    clist.add(c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (bringUpServiceLocked(s,service.getFlags(),false) != null) {
        return 0;
      }
    }
    if (s.app != null) {
      mAm.updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}"
1792,"private final void bumpServiceExecutingLocked(ServiceRecord r,String why){
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + why + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Log.v(TAG,""String_Node_Str"" + why + ""String_Node_Str""+ r.shortName);
  long now=SystemClock.uptimeMillis();
  if (r.executeNesting == 0) {
    if (r.tracker != null) {
      r.tracker.setExecuting(true,mAm.mProcessTracker.getMemFactorLocked(),now);
    }
    if (r.app != null) {
      if (r.app.executingServices.size() == 0) {
        Message msg=mAm.mHandler.obtainMessage(ActivityManagerService.SERVICE_TIMEOUT_MSG);
        msg.obj=r.app;
        mAm.mHandler.sendMessageAtTime(msg,now + SERVICE_TIMEOUT);
      }
      r.app.executingServices.add(r);
    }
  }
  r.executeNesting++;
  r.executingStart=now;
}","private final void bumpServiceExecutingLocked(ServiceRecord r,String why){
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + why + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Log.v(TAG,""String_Node_Str"" + why + ""String_Node_Str""+ r.shortName);
  long now=SystemClock.uptimeMillis();
  if (r.executeNesting == 0) {
    ProcessTracker.ServiceState stracker=r.getTracker();
    if (stracker != null) {
      stracker.setExecuting(true,mAm.mProcessTracker.getMemFactorLocked(),now);
    }
    if (r.app != null) {
      if (r.app.executingServices.size() == 0) {
        Message msg=mAm.mHandler.obtainMessage(ActivityManagerService.SERVICE_TIMEOUT_MSG);
        msg.obj=r.app;
        mAm.mHandler.sendMessageAtTime(msg,now + SERVICE_TIMEOUT);
      }
      r.app.executingServices.add(r);
    }
  }
  r.executeNesting++;
  r.executingStart=now;
}"
1793,"private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  mServiceMap.removeServiceByName(r.name,r.userId);
  mServiceMap.removeServiceByIntent(r.intent,r.userId);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        bumpServiceExecutingLocked(r,""String_Node_Str"");
        mStoppingServices.add(r);
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessTracker.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
  }
}","private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  mServiceMap.removeServiceByName(r.name,r.userId);
  mServiceMap.removeServiceByIntent(r.intent,r.userId);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        bumpServiceExecutingLocked(r,""String_Node_Str"");
        mStoppingServices.add(r);
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessTracker.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.makeInactive();
      r.tracker=null;
    }
  }
}"
1794,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  if (r.tracker != null) {
    r.tracker.setStarted(true,mAm.mProcessTracker.getMemFactorLocked(),r.lastActivity);
  }
  r.callStart=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
synchronized (r.stats.getBatteryStats()) {
    r.stats.startRunningLocked();
  }
  String error=bringUpServiceLocked(r,service.getFlags(),false);
  if (error != null) {
    return new ComponentName(""String_Node_Str"",error);
  }
  return r.name;
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  ProcessTracker.ServiceState stracker=r.getTracker();
  if (stracker != null) {
    stracker.setStarted(true,mAm.mProcessTracker.getMemFactorLocked(),r.lastActivity);
  }
  r.callStart=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
synchronized (r.stats.getBatteryStats()) {
    r.stats.startRunningLocked();
  }
  String error=bringUpServiceLocked(r,service.getFlags(),false);
  if (error != null) {
    return new ComponentName(""String_Node_Str"",error);
  }
  return r.name;
}"
1795,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid,int userId,boolean createIfNeeded){
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ callingUid);
  userId=mAm.handleIncomingUser(callingPid,callingUid,userId,false,true,""String_Node_Str"",null);
  if (service.getComponent() != null) {
    r=mServiceMap.getServiceByName(service.getComponent(),userId);
  }
  if (r == null) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=mServiceMap.getServiceByIntent(filter,userId);
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ userId+ ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags)) {
          userId=0;
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=mServiceMap.getServiceByName(name,userId);
      if (r == null && createIfNeeded) {
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        ProcessTracker.ServiceState tracker=null;
        if ((sInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
          tracker=mAm.mProcessTracker.getServiceStateLocked(sInfo.packageName,sInfo.applicationInfo.uid,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,res,tracker);
        res.setService(r);
        mServiceMap.putServiceByName(name,UserHandle.getUserId(r.appInfo.uid),r);
        mServiceMap.putServiceByIntent(filter,UserHandle.getUserId(r.appInfo.uid),r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.appInfo.uid);
        return new ServiceLookupResult(null,""String_Node_Str"" + r.appInfo.uid);
      }
      Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid,int userId,boolean createIfNeeded){
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ callingUid);
  userId=mAm.handleIncomingUser(callingPid,callingUid,userId,false,true,""String_Node_Str"",null);
  if (service.getComponent() != null) {
    r=mServiceMap.getServiceByName(service.getComponent(),userId);
  }
  if (r == null) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=mServiceMap.getServiceByIntent(filter,userId);
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ userId+ ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags)) {
          userId=0;
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=mServiceMap.getServiceByName(name,userId);
      if (r == null && createIfNeeded) {
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,res);
        res.setService(r);
        mServiceMap.putServiceByName(name,UserHandle.getUserId(r.appInfo.uid),r);
        mServiceMap.putServiceByIntent(filter,UserHandle.getUserId(r.appInfo.uid),r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.appInfo.uid);
        return new ServiceLookupResult(null,""String_Node_Str"" + r.appInfo.uid);
      }
      Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}"
1796,"private Method getMethod(View view,String methodName,Class<?> paramType){
  Method method;
  Class<? extends View> klass=view.getClass();
synchronized (sMethodsLock) {
    ArrayMap<MutablePair<String,Class<?>>,Method> methods=sMethods.get(klass);
    if (methods == null) {
      methods=new ArrayMap<MutablePair<String,Class<?>>,Method>();
      sMethods.put(klass,methods);
    }
    mPair.first=methodName;
    mPair.second=paramType;
    method=methods.get(mPair);
    if (method == null) {
      try {
        method=klass.getMethod(methodName,paramType);
      }
 catch (      NoSuchMethodException ex) {
        throw new ActionException(""String_Node_Str"" + klass.getName() + ""String_Node_Str""+ methodName+ getParameters(paramType));
      }
      if (!method.isAnnotationPresent(RemotableViewMethod.class)) {
        throw new ActionException(""String_Node_Str"" + klass.getName() + ""String_Node_Str""+ methodName+ getParameters(paramType));
      }
      methods.put(new MutablePair<String,Class<?>>(methodName,paramType),method);
    }
  }
  return method;
}","private Method getMethod(View view,String methodName,Class<?> paramType){
  Method method;
  Class<? extends View> klass=view.getClass();
synchronized (sMethodsLock) {
    ArrayMap<MutablePair<String,Class<?>>,Method> methods=sMethods.get(klass);
    if (methods == null) {
      methods=new ArrayMap<MutablePair<String,Class<?>>,Method>();
      sMethods.put(klass,methods);
    }
    mPair.first=methodName;
    mPair.second=paramType;
    method=methods.get(mPair);
    if (method == null) {
      try {
        if (paramType == null) {
          method=klass.getMethod(methodName);
        }
 else {
          method=klass.getMethod(methodName,paramType);
        }
      }
 catch (      NoSuchMethodException ex) {
        throw new ActionException(""String_Node_Str"" + klass.getName() + ""String_Node_Str""+ methodName+ getParameters(paramType));
      }
      if (!method.isAnnotationPresent(RemotableViewMethod.class)) {
        throw new ActionException(""String_Node_Str"" + klass.getName() + ""String_Node_Str""+ methodName+ getParameters(paramType));
      }
      methods.put(new MutablePair<String,Class<?>>(methodName,paramType),method);
    }
  }
  return method;
}"
1797,"/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    return;
  }
  int N=mParcelledData.readInt();
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new ArrayMap<String,Object>(N);
  }
 else {
    mMap.ensureCapacity(N);
  }
  mParcelledData.readArrayMapInternal(mMap,N,mClassLoader);
  mParcelledData.recycle();
  mParcelledData=null;
}","/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    return;
  }
  int N=mParcelledData.readInt();
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new ArrayMap<String,Object>(N);
  }
 else {
    mMap.erase();
    mMap.ensureCapacity(N);
  }
  mParcelledData.readArrayMapInternal(mMap,N,mClassLoader);
  mParcelledData.recycle();
  mParcelledData=null;
}"
1798,"/** 
 * Special fast path for appending items to the end of the array without validation. The array must already be large enough to contain the item.
 * @hide
 */
public void append(K key,V value){
  int index=mSize;
  final int hash=key.hashCode();
  if (index >= mHashes.length) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (index > 0 && mHashes[index - 1] > hash) {
    throw new IllegalArgumentException(""String_Node_Str"" + hash + ""String_Node_Str""+ mHashes[index - 1]);
  }
  mSize=index + 1;
  mHashes[index]=hash;
  index<<=1;
  mArray[index]=key;
  mArray[index + 1]=value;
}","/** 
 * Special fast path for appending items to the end of the array without validation. The array must already be large enough to contain the item.
 * @hide
 */
public void append(K key,V value){
  int index=mSize;
  final int hash=key.hashCode();
  if (index >= mHashes.length) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (index > 0 && mHashes[index - 1] > hash) {
    RuntimeException e=new RuntimeException(""String_Node_Str"");
    e.fillInStackTrace();
    Log.w(TAG,""String_Node_Str"" + hash + ""String_Node_Str""+ mHashes[index - 1]+ ""String_Node_Str""+ index+ ""String_Node_Str""+ key,e);
    put(key,value);
    return;
  }
  mSize=index + 1;
  mHashes[index]=hash;
  index<<=1;
  mArray[index]=key;
  mArray[index + 1]=value;
}"
1799,"@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (mSync) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}","@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (mSync) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}"
1800,"@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (mSync) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}","@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (mSync) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}"
1801,"final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  int curClientCachedAdj=curEmptyAdj;
  for (int i=0; i < N; i++) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedBackground && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numCached);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numEmpty);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
boolean allChanged;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
final int numCachedAndEmpty=numCached + numEmpty;
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int step=0;
int fgTrimLevel;
int memFactor;
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_LOW;
}
 else {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_MODERATE;
}
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
allChanged=mProcessTracker.setMemFactorLocked(memFactor,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(memFactor,now);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
allChanged=mProcessTracker.setMemFactorLocked(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,now);
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false);
}
if (mProcessTracker.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessTracker.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}","final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedBackground && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numCached);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numEmpty);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
boolean allChanged;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
final int numCachedAndEmpty=numCached + numEmpty;
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int step=0;
int fgTrimLevel;
int memFactor;
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_LOW;
}
 else {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_MODERATE;
}
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
allChanged=mProcessTracker.setMemFactorLocked(memFactor,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(memFactor,now);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
allChanged=mProcessTracker.setMemFactorLocked(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,now);
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false);
}
if (mProcessTracker.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessTracker.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}"
1802,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  app.hasClientActivities=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.hasActivities=false;
    app.foregroundActivities=false;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
      app.hasActivities=true;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
        if (r.app == app) {
          app.hasActivities=true;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.keeping=false;
  app.systemNoUi=false;
  app.hasActivities=false;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  boolean interesting=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    interesting=true;
    app.hasActivities=true;
    procState=ActivityManager.PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str"");
        continue;
      }
      app.hasActivities=true;
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app.foregroundServices) {
    interesting=true;
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
      app.keeping=true;
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
 else           if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
            if ((cr.flags & Context.BIND_NOT_VISIBLE) == 0) {
              if (client.hasActivities) {
                if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT) {
                  procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
                  app.adjType=""String_Node_Str"";
                }
              }
              app.hasClientActivities|=client.hasActivities;
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              if (client.keeping) {
                app.keeping=true;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceOom=clientAdj;
            app.adjTarget=s.name;
          }
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceOom=adj;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.keeping|=client.keeping;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceOom=clientAdj;
        app.adjTarget=cpr.name;
      }
      if (procState > client.curProcState) {
        procState=client.curProcState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND ? client.curProcState : ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.keeping=true;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (adj == ProcessList.SERVICE_ADJ) {
    if (doingAll) {
      app.serviceb=mNewNumServiceProcs > (mNumServiceProcs / 3);
      mNewNumServiceProcs++;
    }
    if (app.serviceb) {
      adj=ProcessList.SERVICE_B_ADJ;
    }
  }
 else {
    app.serviceb=false;
  }
  app.curRawAdj=adj;
  if (adj > app.maxAdj) {
    adj=app.maxAdj;
    if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (adj < ProcessList.CACHED_APP_MIN_ADJ) {
    app.keeping=true;
  }
  adj=app.modifyRawOomAdj(adj);
  app.curProcState=procState;
  int importance=app.memImportance;
  if (importance == 0 || adj != app.curAdj || schedGroup != app.curSchedGroup) {
    app.curAdj=adj;
    app.curSchedGroup=schedGroup;
    if (!interesting) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.CACHED_APP_MIN_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.SERVICE_B_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    }
 else     if (adj >= ProcessList.HOME_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.SERVICE_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    }
 else     if (adj >= ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_CANT_SAVE_STATE;
    }
 else     if (adj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE;
    }
 else     if (adj >= ProcessList.VISIBLE_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE;
    }
 else     if (adj >= ProcessList.FOREGROUND_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
    }
 else {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERSISTENT;
    }
  }
  int changes=importance != app.memImportance ? ProcessChangeItem.CHANGE_IMPORTANCE : 0;
  if (foregroundActivities != app.foregroundActivities) {
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    app.memImportance=importance;
    app.foregroundActivities=foregroundActivities;
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"");
        mHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.importance=importance;
    item.foregroundActivities=foregroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.importance+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  app.hasClientActivities=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.hasActivities=false;
    app.foregroundActivities=false;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
      app.hasActivities=true;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
        if (r.app == app) {
          app.hasActivities=true;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.keeping=false;
  app.systemNoUi=false;
  app.hasActivities=false;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  boolean interesting=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    interesting=true;
    app.hasActivities=true;
    procState=ActivityManager.PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str"");
        continue;
      }
      app.hasActivities=true;
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app.foregroundServices) {
    interesting=true;
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
      app.keeping=true;
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
 else           if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
            if ((cr.flags & Context.BIND_NOT_VISIBLE) == 0) {
              if (client.hasActivities) {
                if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT) {
                  procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
                  app.adjType=""String_Node_Str"";
                }
                app.hasClientActivities=true;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              if (client.keeping) {
                app.keeping=true;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceOom=clientAdj;
            app.adjTarget=s.name;
          }
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceOom=adj;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.keeping|=client.keeping;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceOom=clientAdj;
        app.adjTarget=cpr.name;
      }
      if (procState > clientProcState) {
        procState=clientProcState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND ? clientProcState : ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.keeping=true;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (adj == ProcessList.SERVICE_ADJ) {
    if (doingAll) {
      app.serviceb=mNewNumServiceProcs > (mNumServiceProcs / 3);
      mNewNumServiceProcs++;
    }
    if (app.serviceb) {
      adj=ProcessList.SERVICE_B_ADJ;
    }
  }
 else {
    app.serviceb=false;
  }
  app.curRawAdj=adj;
  if (adj > app.maxAdj) {
    adj=app.maxAdj;
    if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (adj < ProcessList.CACHED_APP_MIN_ADJ) {
    app.keeping=true;
  }
  adj=app.modifyRawOomAdj(adj);
  app.curProcState=procState;
  int importance=app.memImportance;
  if (importance == 0 || adj != app.curAdj || schedGroup != app.curSchedGroup) {
    app.curAdj=adj;
    app.curSchedGroup=schedGroup;
    if (!interesting) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.CACHED_APP_MIN_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.SERVICE_B_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    }
 else     if (adj >= ProcessList.HOME_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.SERVICE_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    }
 else     if (adj >= ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_CANT_SAVE_STATE;
    }
 else     if (adj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE;
    }
 else     if (adj >= ProcessList.VISIBLE_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE;
    }
 else     if (adj >= ProcessList.FOREGROUND_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
    }
 else {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERSISTENT;
    }
  }
  int changes=importance != app.memImportance ? ProcessChangeItem.CHANGE_IMPORTANCE : 0;
  if (foregroundActivities != app.foregroundActivities) {
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    app.memImportance=importance;
    app.foregroundActivities=foregroundActivities;
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"");
        mHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.importance=importance;
    item.foregroundActivities=foregroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.importance+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return app.curRawAdj;
}"
1803,"public String toString(){
  if (stringName != null) {
    return stringName;
  }
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(""String_Node_Str"");
  sb.append(binding.client.userId);
  sb.append(' ');
  if ((flags & Context.BIND_AUTO_CREATE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_DEBUG_UNBIND) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_NOT_FOREGROUND) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ABOVE_CLIENT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_WAIVE_PRIORITY) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_IMPORTANT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_NOT_VISIBLE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_VISIBLE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if (serviceDead) {
    sb.append(""String_Node_Str"");
  }
  sb.append(binding.service.shortName);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(conn.asBinder())));
  sb.append('}');
  return stringName=sb.toString();
}","public String toString(){
  if (stringName != null) {
    return stringName;
  }
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(""String_Node_Str"");
  sb.append(binding.client.userId);
  sb.append(' ');
  if ((flags & Context.BIND_AUTO_CREATE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_DEBUG_UNBIND) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_NOT_FOREGROUND) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ABOVE_CLIENT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_WAIVE_PRIORITY) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_IMPORTANT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_VISIBLE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_SHOWING_UI) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_NOT_VISIBLE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if (serviceDead) {
    sb.append(""String_Node_Str"");
  }
  sb.append(binding.service.shortName);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(conn.asBinder())));
  sb.append('}');
  return stringName=sb.toString();
}"
1804,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.println();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.print(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(serviceb);
  pw.print(""String_Node_Str"");
  pw.print(keeping);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.println(setProcState);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  pw.println(lastPssTime);
  if (hasShownUi || pendingUiClean || hasAboveClient) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.println(hasAboveClient);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasActivities || hasClientActivities || foregroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasActivities);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.println(foregroundActivities);
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (!keeping) {
    long wtime;
synchronized (batteryStats.getBatteryStats()) {
      wtime=batteryStats.getBatteryStats().getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    long timeUsed=wtime - lastWakeTime;
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(timeUsed,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killedBackground || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killedBackground);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.println();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(serviceb);
  pw.print(""String_Node_Str"");
  pw.print(keeping);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.println(setProcState);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  pw.println(lastPssTime);
  if (hasShownUi || pendingUiClean || hasAboveClient) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.println(hasAboveClient);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasActivities || hasClientActivities || foregroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasActivities);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.println(foregroundActivities);
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (!keeping) {
    long wtime;
synchronized (batteryStats.getBatteryStats()) {
      wtime=batteryStats.getBatteryStats().getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    long timeUsed=wtime - lastWakeTime;
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(timeUsed,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killedBackground || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killedBackground);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}"
1805,"@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (mSync) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}","@Override public SharedPreferences getSharedPreferences(String name,int mode){
  SharedPreferencesImpl sp;
synchronized (mSync) {
    if (sSharedPrefs == null) {
      sSharedPrefs=new ArrayMap<String,ArrayMap<String,SharedPreferencesImpl>>();
    }
    final String packageName=getPackageName();
    ArrayMap<String,SharedPreferencesImpl> packagePrefs=sSharedPrefs.get(packageName);
    if (packagePrefs == null) {
      packagePrefs=new ArrayMap<String,SharedPreferencesImpl>();
      sSharedPrefs.put(packageName,packagePrefs);
    }
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KEY_LIME_PIE) {
      if (name == null) {
        name=""String_Node_Str"";
      }
    }
    sp=packagePrefs.get(name);
    if (sp == null) {
      File prefsFile=getSharedPrefsFile(name);
      sp=new SharedPreferencesImpl(prefsFile,mode);
      packagePrefs.put(name,sp);
      return sp;
    }
  }
  if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
    sp.startReloadIfChangedUnexpectedly();
  }
  return sp;
}"
1806,"final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  int curClientCachedAdj=curEmptyAdj;
  for (int i=0; i < N; i++) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedBackground && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numCached);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numEmpty);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
boolean allChanged;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
final int numCachedAndEmpty=numCached + numEmpty;
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int step=0;
int fgTrimLevel;
int memFactor;
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_LOW;
}
 else {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_MODERATE;
}
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
allChanged=mProcessTracker.setMemFactorLocked(memFactor,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(memFactor,now);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
allChanged=mProcessTracker.setMemFactorLocked(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,now);
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false);
}
if (mProcessTracker.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessTracker.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}","final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedBackground && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numCached);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numEmpty);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
boolean allChanged;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
final int numCachedAndEmpty=numCached + numEmpty;
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int step=0;
int fgTrimLevel;
int memFactor;
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_LOW;
}
 else {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_MODERATE;
}
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
allChanged=mProcessTracker.setMemFactorLocked(memFactor,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(memFactor,now);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
allChanged=mProcessTracker.setMemFactorLocked(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,now);
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false);
}
if (mProcessTracker.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessTracker.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}"
1807,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  app.hasClientActivities=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.hasActivities=false;
    app.foregroundActivities=false;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
      app.hasActivities=true;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
        if (r.app == app) {
          app.hasActivities=true;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.keeping=false;
  app.systemNoUi=false;
  app.hasActivities=false;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  boolean interesting=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    interesting=true;
    app.hasActivities=true;
    procState=ActivityManager.PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str"");
        continue;
      }
      app.hasActivities=true;
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app.foregroundServices) {
    interesting=true;
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
      app.keeping=true;
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
 else           if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
            if ((cr.flags & Context.BIND_NOT_VISIBLE) == 0) {
              if (client.hasActivities) {
                if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT) {
                  procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
                  app.adjType=""String_Node_Str"";
                }
              }
              app.hasClientActivities|=client.hasActivities;
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              if (client.keeping) {
                app.keeping=true;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceOom=clientAdj;
            app.adjTarget=s.name;
          }
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceOom=adj;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.keeping|=client.keeping;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceOom=clientAdj;
        app.adjTarget=cpr.name;
      }
      if (procState > client.curProcState) {
        procState=client.curProcState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND ? client.curProcState : ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.keeping=true;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (adj == ProcessList.SERVICE_ADJ) {
    if (doingAll) {
      app.serviceb=mNewNumServiceProcs > (mNumServiceProcs / 3);
      mNewNumServiceProcs++;
    }
    if (app.serviceb) {
      adj=ProcessList.SERVICE_B_ADJ;
    }
  }
 else {
    app.serviceb=false;
  }
  app.curRawAdj=adj;
  if (adj > app.maxAdj) {
    adj=app.maxAdj;
    if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (adj < ProcessList.CACHED_APP_MIN_ADJ) {
    app.keeping=true;
  }
  adj=app.modifyRawOomAdj(adj);
  app.curProcState=procState;
  int importance=app.memImportance;
  if (importance == 0 || adj != app.curAdj || schedGroup != app.curSchedGroup) {
    app.curAdj=adj;
    app.curSchedGroup=schedGroup;
    if (!interesting) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.CACHED_APP_MIN_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.SERVICE_B_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    }
 else     if (adj >= ProcessList.HOME_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.SERVICE_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    }
 else     if (adj >= ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_CANT_SAVE_STATE;
    }
 else     if (adj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE;
    }
 else     if (adj >= ProcessList.VISIBLE_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE;
    }
 else     if (adj >= ProcessList.FOREGROUND_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
    }
 else {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERSISTENT;
    }
  }
  int changes=importance != app.memImportance ? ProcessChangeItem.CHANGE_IMPORTANCE : 0;
  if (foregroundActivities != app.foregroundActivities) {
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    app.memImportance=importance;
    app.foregroundActivities=foregroundActivities;
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"");
        mHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.importance=importance;
    item.foregroundActivities=foregroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.importance+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  app.hasClientActivities=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.hasActivities=false;
    app.foregroundActivities=false;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
      app.hasActivities=true;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
        if (r.app == app) {
          app.hasActivities=true;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.keeping=false;
  app.systemNoUi=false;
  app.hasActivities=false;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  boolean interesting=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    interesting=true;
    app.hasActivities=true;
    procState=ActivityManager.PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str"");
        continue;
      }
      app.hasActivities=true;
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app.foregroundServices) {
    interesting=true;
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
      app.keeping=true;
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
 else           if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
            if ((cr.flags & Context.BIND_NOT_VISIBLE) == 0) {
              if (client.hasActivities) {
                if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT) {
                  procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
                  app.adjType=""String_Node_Str"";
                }
                app.hasClientActivities=true;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              if (client.keeping) {
                app.keeping=true;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceOom=clientAdj;
            app.adjTarget=s.name;
          }
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceOom=adj;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.keeping|=client.keeping;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceOom=clientAdj;
        app.adjTarget=cpr.name;
      }
      if (procState > clientProcState) {
        procState=clientProcState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND ? clientProcState : ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.keeping=true;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (adj == ProcessList.SERVICE_ADJ) {
    if (doingAll) {
      app.serviceb=mNewNumServiceProcs > (mNumServiceProcs / 3);
      mNewNumServiceProcs++;
    }
    if (app.serviceb) {
      adj=ProcessList.SERVICE_B_ADJ;
    }
  }
 else {
    app.serviceb=false;
  }
  app.curRawAdj=adj;
  if (adj > app.maxAdj) {
    adj=app.maxAdj;
    if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (adj < ProcessList.CACHED_APP_MIN_ADJ) {
    app.keeping=true;
  }
  adj=app.modifyRawOomAdj(adj);
  app.curProcState=procState;
  int importance=app.memImportance;
  if (importance == 0 || adj != app.curAdj || schedGroup != app.curSchedGroup) {
    app.curAdj=adj;
    app.curSchedGroup=schedGroup;
    if (!interesting) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.CACHED_APP_MIN_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.SERVICE_B_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    }
 else     if (adj >= ProcessList.HOME_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.SERVICE_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    }
 else     if (adj >= ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_CANT_SAVE_STATE;
    }
 else     if (adj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE;
    }
 else     if (adj >= ProcessList.VISIBLE_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE;
    }
 else     if (adj >= ProcessList.FOREGROUND_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
    }
 else {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERSISTENT;
    }
  }
  int changes=importance != app.memImportance ? ProcessChangeItem.CHANGE_IMPORTANCE : 0;
  if (foregroundActivities != app.foregroundActivities) {
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    app.memImportance=importance;
    app.foregroundActivities=foregroundActivities;
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"");
        mHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.importance=importance;
    item.foregroundActivities=foregroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.importance+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return app.curRawAdj;
}"
1808,"public String toString(){
  if (stringName != null) {
    return stringName;
  }
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(""String_Node_Str"");
  sb.append(binding.client.userId);
  sb.append(' ');
  if ((flags & Context.BIND_AUTO_CREATE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_DEBUG_UNBIND) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_NOT_FOREGROUND) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ABOVE_CLIENT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_WAIVE_PRIORITY) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_IMPORTANT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_NOT_VISIBLE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_VISIBLE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if (serviceDead) {
    sb.append(""String_Node_Str"");
  }
  sb.append(binding.service.shortName);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(conn.asBinder())));
  sb.append('}');
  return stringName=sb.toString();
}","public String toString(){
  if (stringName != null) {
    return stringName;
  }
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(""String_Node_Str"");
  sb.append(binding.client.userId);
  sb.append(' ');
  if ((flags & Context.BIND_AUTO_CREATE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_DEBUG_UNBIND) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_NOT_FOREGROUND) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ABOVE_CLIENT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_WAIVE_PRIORITY) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_IMPORTANT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_VISIBLE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_SHOWING_UI) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_NOT_VISIBLE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if (serviceDead) {
    sb.append(""String_Node_Str"");
  }
  sb.append(binding.service.shortName);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(conn.asBinder())));
  sb.append('}');
  return stringName=sb.toString();
}"
1809,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.println();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.print(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(serviceb);
  pw.print(""String_Node_Str"");
  pw.print(keeping);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.println(setProcState);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  pw.println(lastPssTime);
  if (hasShownUi || pendingUiClean || hasAboveClient) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.println(hasAboveClient);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasActivities || hasClientActivities || foregroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasActivities);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.println(foregroundActivities);
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (!keeping) {
    long wtime;
synchronized (batteryStats.getBatteryStats()) {
      wtime=batteryStats.getBatteryStats().getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    long timeUsed=wtime - lastWakeTime;
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(timeUsed,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killedBackground || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killedBackground);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.println();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(serviceb);
  pw.print(""String_Node_Str"");
  pw.print(keeping);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.println(setProcState);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  pw.println(lastPssTime);
  if (hasShownUi || pendingUiClean || hasAboveClient) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.println(hasAboveClient);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasActivities || hasClientActivities || foregroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasActivities);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.println(foregroundActivities);
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (!keeping) {
    long wtime;
synchronized (batteryStats.getBatteryStats()) {
      wtime=batteryStats.getBatteryStats().getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    long timeUsed=wtime - lastWakeTime;
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(timeUsed,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killedBackground || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killedBackground);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}"
1810,"final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  int curClientCachedAdj=curEmptyAdj;
  for (int i=0; i < N; i++) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedBackground && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numCached);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numEmpty);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
boolean allChanged;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
final int numCachedAndEmpty=numCached + numEmpty;
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int step=0;
int fgTrimLevel;
int memFactor;
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_LOW;
}
 else {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_MODERATE;
}
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
allChanged=mProcessTracker.setMemFactorLocked(memFactor,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(memFactor,now);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
allChanged=mProcessTracker.setMemFactorLocked(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,now);
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false);
}
if (mProcessTracker.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessTracker.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}","final void updateOomAdjLocked(){
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedBackground && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numCached);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numEmpty);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,""String_Node_Str"");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
boolean allChanged;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
final int numCachedAndEmpty=numCached + numEmpty;
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int step=0;
int fgTrimLevel;
int memFactor;
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_LOW;
}
 else {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_MODERATE;
}
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
allChanged=mProcessTracker.setMemFactorLocked(memFactor,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(memFactor,now);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,""String_Node_Str"");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
allChanged=mProcessTracker.setMemFactorLocked(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,now);
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,""String_Node_Str"");
}
if (allChanged) {
requestPssAllProcsLocked(now,false);
}
if (mProcessTracker.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessTracker.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - now) + ""String_Node_Str"");
}
}"
1811,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  app.hasClientActivities=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.hasActivities=false;
    app.foregroundActivities=false;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
      app.hasActivities=true;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
        if (r.app == app) {
          app.hasActivities=true;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.keeping=false;
  app.systemNoUi=false;
  app.hasActivities=false;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  boolean interesting=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    interesting=true;
    app.hasActivities=true;
    procState=ActivityManager.PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str"");
        continue;
      }
      app.hasActivities=true;
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app.foregroundServices) {
    interesting=true;
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
      app.keeping=true;
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
 else           if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
            if ((cr.flags & Context.BIND_NOT_VISIBLE) == 0) {
              if (client.hasActivities) {
                if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT) {
                  procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
                  app.adjType=""String_Node_Str"";
                }
              }
              app.hasClientActivities|=client.hasActivities;
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              if (client.keeping) {
                app.keeping=true;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceOom=clientAdj;
            app.adjTarget=s.name;
          }
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceOom=adj;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.keeping|=client.keeping;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceOom=clientAdj;
        app.adjTarget=cpr.name;
      }
      if (procState > client.curProcState) {
        procState=client.curProcState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND ? client.curProcState : ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.keeping=true;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (adj == ProcessList.SERVICE_ADJ) {
    if (doingAll) {
      app.serviceb=mNewNumServiceProcs > (mNumServiceProcs / 3);
      mNewNumServiceProcs++;
    }
    if (app.serviceb) {
      adj=ProcessList.SERVICE_B_ADJ;
    }
  }
 else {
    app.serviceb=false;
  }
  app.curRawAdj=adj;
  if (adj > app.maxAdj) {
    adj=app.maxAdj;
    if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (adj < ProcessList.CACHED_APP_MIN_ADJ) {
    app.keeping=true;
  }
  adj=app.modifyRawOomAdj(adj);
  app.curProcState=procState;
  int importance=app.memImportance;
  if (importance == 0 || adj != app.curAdj || schedGroup != app.curSchedGroup) {
    app.curAdj=adj;
    app.curSchedGroup=schedGroup;
    if (!interesting) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.CACHED_APP_MIN_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.SERVICE_B_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    }
 else     if (adj >= ProcessList.HOME_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.SERVICE_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    }
 else     if (adj >= ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_CANT_SAVE_STATE;
    }
 else     if (adj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE;
    }
 else     if (adj >= ProcessList.VISIBLE_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE;
    }
 else     if (adj >= ProcessList.FOREGROUND_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
    }
 else {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERSISTENT;
    }
  }
  int changes=importance != app.memImportance ? ProcessChangeItem.CHANGE_IMPORTANCE : 0;
  if (foregroundActivities != app.foregroundActivities) {
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    app.memImportance=importance;
    app.foregroundActivities=foregroundActivities;
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"");
        mHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.importance=importance;
    item.foregroundActivities=foregroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.importance+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  app.hasClientActivities=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.hasActivities=false;
    app.foregroundActivities=false;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
      app.hasActivities=true;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
        if (r.app == app) {
          app.hasActivities=true;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.keeping=false;
  app.systemNoUi=false;
  app.hasActivities=false;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  boolean interesting=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    interesting=true;
    app.hasActivities=true;
    procState=ActivityManager.PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str"");
        continue;
      }
      app.hasActivities=true;
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app.foregroundServices) {
    interesting=true;
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
      app.keeping=true;
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
 else           if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
            if ((cr.flags & Context.BIND_NOT_VISIBLE) == 0) {
              if (client.hasActivities) {
                if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT) {
                  procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
                  app.adjType=""String_Node_Str"";
                }
                app.hasClientActivities=true;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              if (client.keeping) {
                app.keeping=true;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceOom=clientAdj;
            app.adjTarget=s.name;
          }
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceOom=adj;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.keeping|=client.keeping;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceOom=clientAdj;
        app.adjTarget=cpr.name;
      }
      if (procState > clientProcState) {
        procState=clientProcState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND ? clientProcState : ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.keeping=true;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (adj == ProcessList.SERVICE_ADJ) {
    if (doingAll) {
      app.serviceb=mNewNumServiceProcs > (mNumServiceProcs / 3);
      mNewNumServiceProcs++;
    }
    if (app.serviceb) {
      adj=ProcessList.SERVICE_B_ADJ;
    }
  }
 else {
    app.serviceb=false;
  }
  app.curRawAdj=adj;
  if (adj > app.maxAdj) {
    adj=app.maxAdj;
    if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (adj < ProcessList.CACHED_APP_MIN_ADJ) {
    app.keeping=true;
  }
  adj=app.modifyRawOomAdj(adj);
  app.curProcState=procState;
  int importance=app.memImportance;
  if (importance == 0 || adj != app.curAdj || schedGroup != app.curSchedGroup) {
    app.curAdj=adj;
    app.curSchedGroup=schedGroup;
    if (!interesting) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.CACHED_APP_MIN_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.SERVICE_B_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    }
 else     if (adj >= ProcessList.HOME_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    }
 else     if (adj >= ProcessList.SERVICE_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    }
 else     if (adj >= ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_CANT_SAVE_STATE;
    }
 else     if (adj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE;
    }
 else     if (adj >= ProcessList.VISIBLE_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE;
    }
 else     if (adj >= ProcessList.FOREGROUND_APP_ADJ) {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
    }
 else {
      importance=ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERSISTENT;
    }
  }
  int changes=importance != app.memImportance ? ProcessChangeItem.CHANGE_IMPORTANCE : 0;
  if (foregroundActivities != app.foregroundActivities) {
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    app.memImportance=importance;
    app.foregroundActivities=foregroundActivities;
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,""String_Node_Str"");
        mHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.importance=importance;
    item.foregroundActivities=foregroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.importance+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return app.curRawAdj;
}"
1812,"public String toString(){
  if (stringName != null) {
    return stringName;
  }
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(""String_Node_Str"");
  sb.append(binding.client.userId);
  sb.append(' ');
  if ((flags & Context.BIND_AUTO_CREATE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_DEBUG_UNBIND) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_NOT_FOREGROUND) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ABOVE_CLIENT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_WAIVE_PRIORITY) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_IMPORTANT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_NOT_VISIBLE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_VISIBLE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if (serviceDead) {
    sb.append(""String_Node_Str"");
  }
  sb.append(binding.service.shortName);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(conn.asBinder())));
  sb.append('}');
  return stringName=sb.toString();
}","public String toString(){
  if (stringName != null) {
    return stringName;
  }
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(""String_Node_Str"");
  sb.append(binding.client.userId);
  sb.append(' ');
  if ((flags & Context.BIND_AUTO_CREATE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_DEBUG_UNBIND) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_NOT_FOREGROUND) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ABOVE_CLIENT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_WAIVE_PRIORITY) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_IMPORTANT) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_VISIBLE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_SHOWING_UI) != 0) {
    sb.append(""String_Node_Str"");
  }
  if ((flags & Context.BIND_NOT_VISIBLE) != 0) {
    sb.append(""String_Node_Str"");
  }
  if (serviceDead) {
    sb.append(""String_Node_Str"");
  }
  sb.append(binding.service.shortName);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(conn.asBinder())));
  sb.append('}');
  return stringName=sb.toString();
}"
1813,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.println();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.print(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(serviceb);
  pw.print(""String_Node_Str"");
  pw.print(keeping);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.println(setProcState);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  pw.println(lastPssTime);
  if (hasShownUi || pendingUiClean || hasAboveClient) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.println(hasAboveClient);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasActivities || hasClientActivities || foregroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasActivities);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.println(foregroundActivities);
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (!keeping) {
    long wtime;
synchronized (batteryStats.getBatteryStats()) {
      wtime=batteryStats.getBatteryStats().getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    long timeUsed=wtime - lastWakeTime;
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(timeUsed,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killedBackground || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killedBackground);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.println();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(serviceb);
  pw.print(""String_Node_Str"");
  pw.print(keeping);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.println(setProcState);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  pw.println(lastPssTime);
  if (hasShownUi || pendingUiClean || hasAboveClient) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.println(hasAboveClient);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasActivities || hasClientActivities || foregroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasActivities);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.println(foregroundActivities);
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (!keeping) {
    long wtime;
synchronized (batteryStats.getBatteryStats()) {
      wtime=batteryStats.getBatteryStats().getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    long timeUsed=wtime - lastWakeTime;
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(timeUsed,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killedBackground || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killedBackground);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}"
1814,"@Override protected Animator disappear(ViewGroup sceneRoot,TransitionValues startValues,int startVisibility,TransitionValues endValues,int endVisibility){
  if ((mFadingMode & OUT) != OUT) {
    return null;
  }
  View view;
  View startView=(startValues != null) ? startValues.view : null;
  View endView=(endValues != null) ? endValues.view : null;
  if (Transition.DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + startView + ""String_Node_Str""+ startVisibility+ ""String_Node_Str""+ endView+ ""String_Node_Str""+ endVisibility);
  }
  View overlayView=null;
  View viewToKeep=null;
  if (endView == null) {
    view=startView;
    overlayView=view;
  }
 else {
    if (endVisibility == View.INVISIBLE) {
      view=endView;
      viewToKeep=view;
    }
 else {
      if (startView == endView) {
        view=endView;
        viewToKeep=view;
      }
 else {
        view=startView;
        overlayView=view;
      }
    }
  }
  final int finalVisibility=endVisibility;
  if (overlayView != null) {
    int screenX=(Integer)startValues.values.get(PROPNAME_SCREEN_X);
    int screenY=(Integer)startValues.values.get(PROPNAME_SCREEN_Y);
    int[] loc=new int[2];
    sceneRoot.getLocationOnScreen(loc);
    overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
    overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
    sceneRoot.getOverlay().add(overlayView);
    final float startAlpha=view.getAlpha();
    float endAlpha=0;
    final View finalView=view;
    final View finalOverlayView=overlayView;
    final View finalViewToKeep=viewToKeep;
    final ViewGroup finalSceneRoot=sceneRoot;
    final Animator.AnimatorListener endListener=new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        finalView.setAlpha(startAlpha);
        if (finalViewToKeep != null) {
          finalViewToKeep.setVisibility(finalVisibility);
        }
        if (finalOverlayView != null) {
          finalSceneRoot.getOverlay().remove(finalOverlayView);
        }
      }
    }
;
    return runAnimation(view,startAlpha,endAlpha,endListener);
  }
  if (viewToKeep != null) {
    viewToKeep.setVisibility((View.VISIBLE));
    final float startAlpha=view.getAlpha();
    float endAlpha=0;
    final View finalView=view;
    final View finalOverlayView=overlayView;
    final View finalViewToKeep=viewToKeep;
    final ViewGroup finalSceneRoot=sceneRoot;
    final Animator.AnimatorListener endListener=new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        finalView.setAlpha(startAlpha);
        if (finalViewToKeep != null) {
          finalViewToKeep.setVisibility(finalVisibility);
        }
        if (finalOverlayView != null) {
          finalSceneRoot.getOverlay().remove(finalOverlayView);
        }
      }
    }
;
    return runAnimation(view,startAlpha,endAlpha,endListener);
  }
  return null;
}","@Override protected Animator disappear(ViewGroup sceneRoot,TransitionValues startValues,int startVisibility,TransitionValues endValues,int endVisibility){
  if ((mFadingMode & OUT) != OUT) {
    return null;
  }
  View view;
  View startView=(startValues != null) ? startValues.view : null;
  View endView=(endValues != null) ? endValues.view : null;
  if (DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + startView + ""String_Node_Str""+ startVisibility+ ""String_Node_Str""+ endView+ ""String_Node_Str""+ endVisibility);
  }
  View overlayView=null;
  View viewToKeep=null;
  if (endView == null) {
    view=startView;
    overlayView=view;
  }
 else {
    if (endVisibility == View.INVISIBLE) {
      view=endView;
      viewToKeep=view;
    }
 else {
      if (startView == endView) {
        view=endView;
        viewToKeep=view;
      }
 else {
        view=startView;
        overlayView=view;
      }
    }
  }
  final int finalVisibility=endVisibility;
  if (overlayView != null) {
    int screenX=(Integer)startValues.values.get(PROPNAME_SCREEN_X);
    int screenY=(Integer)startValues.values.get(PROPNAME_SCREEN_Y);
    int[] loc=new int[2];
    sceneRoot.getLocationOnScreen(loc);
    overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
    overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
    sceneRoot.getOverlay().add(overlayView);
    final float startAlpha=view.getAlpha();
    float endAlpha=0;
    final View finalView=view;
    final View finalOverlayView=overlayView;
    final View finalViewToKeep=viewToKeep;
    final ViewGroup finalSceneRoot=sceneRoot;
    final Animator.AnimatorListener endListener=new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        finalView.setAlpha(startAlpha);
        if (finalViewToKeep != null) {
          finalViewToKeep.setVisibility(finalVisibility);
        }
        if (finalOverlayView != null) {
          finalSceneRoot.getOverlay().remove(finalOverlayView);
        }
      }
    }
;
    return runAnimation(view,startAlpha,endAlpha,endListener);
  }
  if (viewToKeep != null) {
    viewToKeep.setVisibility((View.VISIBLE));
    final float startAlpha=view.getAlpha();
    float endAlpha=0;
    final View finalView=view;
    final View finalOverlayView=overlayView;
    final View finalViewToKeep=viewToKeep;
    final ViewGroup finalSceneRoot=sceneRoot;
    final Animator.AnimatorListener endListener=new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        finalView.setAlpha(startAlpha);
        if (finalViewToKeep != null) {
          finalViewToKeep.setVisibility(finalVisibility);
        }
        if (finalOverlayView != null) {
          finalSceneRoot.getOverlay().remove(finalOverlayView);
        }
      }
    }
;
    return runAnimation(view,startAlpha,endAlpha,endListener);
  }
  return null;
}"
1815,"/** 
 * This version of play() is called with the entire set of start/end values. The implementation in Transition iterates through these lists and calls   {@link #play(ViewGroup,TransitionValues,TransitionValues)}with each set of start/end values on this transition. The TransitionGroup subclass overrides this method and delegates it to each of its children in succession.
 * @hide
 */
protected void play(ViewGroup sceneRoot,TransitionValuesMaps startValues,TransitionValuesMaps endValues){
  mPlayStartValuesList.clear();
  mPlayEndValuesList.clear();
  ArrayMap<View,TransitionValues> endCopy=new ArrayMap<View,TransitionValues>(endValues.viewValues);
  SparseArray<TransitionValues> endIdCopy=new SparseArray<TransitionValues>(endValues.idValues.size());
  for (int i=0; i < endValues.idValues.size(); ++i) {
    int id=endValues.idValues.keyAt(i);
    endIdCopy.put(id,endValues.idValues.valueAt(i));
  }
  LongSparseArray<TransitionValues> endItemIdCopy=new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
  for (int i=0; i < endValues.itemIdValues.size(); ++i) {
    long id=endValues.itemIdValues.keyAt(i);
    endItemIdCopy.put(id,endValues.itemIdValues.valueAt(i));
  }
  ArrayList<TransitionValues> startValuesList=new ArrayList<TransitionValues>();
  ArrayList<TransitionValues> endValuesList=new ArrayList<TransitionValues>();
  for (  View view : startValues.viewValues.keySet()) {
    TransitionValues start=null;
    TransitionValues end=null;
    boolean isInListView=false;
    if (view.getParent() instanceof ListView) {
      isInListView=true;
    }
    if (!isInListView) {
      int id=view.getId();
      start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      if (endValues.viewValues.get(view) != null) {
        end=endValues.viewValues.get(view);
        endCopy.remove(view);
      }
 else {
        end=endValues.idValues.get(id);
        View removeView=null;
        for (        View viewToRemove : endCopy.keySet()) {
          if (viewToRemove.getId() == id) {
            removeView=viewToRemove;
          }
        }
        if (removeView != null) {
          endCopy.remove(removeView);
        }
      }
      endIdCopy.remove(id);
      if (isValidTarget(view,id)) {
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
 else {
      ListView parent=(ListView)view.getParent();
      if (parent.getAdapter().hasStableIds()) {
        int position=parent.getPositionForView(view);
        long itemId=parent.getItemIdAtPosition(position);
        start=startValues.itemIdValues.get(itemId);
        endItemIdCopy.remove(itemId);
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
  }
  int startItemIdCopySize=startValues.itemIdValues.size();
  for (int i=0; i < startItemIdCopySize; ++i) {
    long id=startValues.itemIdValues.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.itemIdValues.get(id);
      TransitionValues end=endValues.itemIdValues.get(id);
      endItemIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  for (  View view : endCopy.keySet()) {
    int id=view.getId();
    if (isValidTarget(view,id)) {
      TransitionValues start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      TransitionValues end=endCopy.get(view);
      endIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endIdCopySize=endIdCopy.size();
  for (int i=0; i < endIdCopySize; ++i) {
    int id=endIdCopy.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.idValues.get(id);
      TransitionValues end=endIdCopy.get(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endItemIdCopySize=endItemIdCopy.size();
  for (int i=0; i < endItemIdCopySize; ++i) {
    long id=endItemIdCopy.keyAt(i);
    TransitionValues start=startValues.itemIdValues.get(id);
    TransitionValues end=endItemIdCopy.get(id);
    startValuesList.add(start);
    endValuesList.add(end);
  }
  for (int i=0; i < startValuesList.size(); ++i) {
    TransitionValues start=startValuesList.get(i);
    TransitionValues end=endValuesList.get(i);
    Animator animator=play(sceneRoot,start,end);
    if (animator != null) {
      mAnimatorMap.put(new Pair(start,end),animator);
      mPlayStartValuesList.add(start);
      mPlayEndValuesList.add(end);
    }
  }
}","/** 
 * This version of play() is called with the entire set of start/end values. The implementation in Transition iterates through these lists and calls   {@link #play(ViewGroup,TransitionValues,TransitionValues)}with each set of start/end values on this transition. The TransitionGroup subclass overrides this method and delegates it to each of its children in succession.
 * @hide
 */
protected void play(ViewGroup sceneRoot,TransitionValuesMaps startValues,TransitionValuesMaps endValues){
  if (DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + this);
  }
  mPlayStartValuesList.clear();
  mPlayEndValuesList.clear();
  ArrayMap<View,TransitionValues> endCopy=new ArrayMap<View,TransitionValues>(endValues.viewValues);
  SparseArray<TransitionValues> endIdCopy=new SparseArray<TransitionValues>(endValues.idValues.size());
  for (int i=0; i < endValues.idValues.size(); ++i) {
    int id=endValues.idValues.keyAt(i);
    endIdCopy.put(id,endValues.idValues.valueAt(i));
  }
  LongSparseArray<TransitionValues> endItemIdCopy=new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
  for (int i=0; i < endValues.itemIdValues.size(); ++i) {
    long id=endValues.itemIdValues.keyAt(i);
    endItemIdCopy.put(id,endValues.itemIdValues.valueAt(i));
  }
  ArrayList<TransitionValues> startValuesList=new ArrayList<TransitionValues>();
  ArrayList<TransitionValues> endValuesList=new ArrayList<TransitionValues>();
  for (  View view : startValues.viewValues.keySet()) {
    TransitionValues start=null;
    TransitionValues end=null;
    boolean isInListView=false;
    if (view.getParent() instanceof ListView) {
      isInListView=true;
    }
    if (!isInListView) {
      int id=view.getId();
      start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      if (endValues.viewValues.get(view) != null) {
        end=endValues.viewValues.get(view);
        endCopy.remove(view);
      }
 else {
        end=endValues.idValues.get(id);
        View removeView=null;
        for (        View viewToRemove : endCopy.keySet()) {
          if (viewToRemove.getId() == id) {
            removeView=viewToRemove;
          }
        }
        if (removeView != null) {
          endCopy.remove(removeView);
        }
      }
      endIdCopy.remove(id);
      if (isValidTarget(view,id)) {
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
 else {
      ListView parent=(ListView)view.getParent();
      if (parent.getAdapter().hasStableIds()) {
        int position=parent.getPositionForView(view);
        long itemId=parent.getItemIdAtPosition(position);
        start=startValues.itemIdValues.get(itemId);
        endItemIdCopy.remove(itemId);
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
  }
  int startItemIdCopySize=startValues.itemIdValues.size();
  for (int i=0; i < startItemIdCopySize; ++i) {
    long id=startValues.itemIdValues.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.itemIdValues.get(id);
      TransitionValues end=endValues.itemIdValues.get(id);
      endItemIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  for (  View view : endCopy.keySet()) {
    int id=view.getId();
    if (isValidTarget(view,id)) {
      TransitionValues start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      TransitionValues end=endCopy.get(view);
      endIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endIdCopySize=endIdCopy.size();
  for (int i=0; i < endIdCopySize; ++i) {
    int id=endIdCopy.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.idValues.get(id);
      TransitionValues end=endIdCopy.get(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endItemIdCopySize=endItemIdCopy.size();
  for (int i=0; i < endItemIdCopySize; ++i) {
    long id=endItemIdCopy.keyAt(i);
    TransitionValues start=startValues.itemIdValues.get(id);
    TransitionValues end=endItemIdCopy.get(id);
    startValuesList.add(start);
    endValuesList.add(end);
  }
  for (int i=0; i < startValuesList.size(); ++i) {
    TransitionValues start=startValuesList.get(i);
    TransitionValues end=endValuesList.get(i);
    if (start != null || end != null) {
      if (start == null || !start.equals(end)) {
        if (DBG) {
          View view=(end != null) ? end.view : start.view;
          Log.d(LOG_TAG,""String_Node_Str"" + view);
          if (start == null || end == null) {
            if (start == null) {
              Log.d(LOG_TAG,""String_Node_Str"" + ((start == null) ? ""String_Node_Str"" : ""String_Node_Str""));
            }
          }
 else {
            for (            String key : start.values.keySet()) {
              Object startValue=start.values.get(key);
              Object endValue=end.values.get(key);
              if (startValue != endValue && !startValue.equals(endValue)) {
                Log.d(LOG_TAG,""String_Node_Str"" + key + ""String_Node_Str""+ startValue+ ""String_Node_Str""+ endValue+ ""String_Node_Str"");
              }
            }
          }
        }
        Animator animator=play(sceneRoot,start,end);
        if (animator != null) {
          mAnimatorMap.put(new Pair(start,end),animator);
          mPlayStartValuesList.add(start);
          mPlayEndValuesList.add(end);
        }
      }
 else       if (DBG) {
        View view=(end != null) ? end.view : start.view;
        Log.d(LOG_TAG,""String_Node_Str"" + view);
      }
    }
  }
}"
1816,"/** 
 * This is called internally once all animations have been set up by the transition hierarchy. \
 * @hide
 */
protected void runAnimations(){
  startTransition();
  for (int i=0; i < mPlayStartValuesList.size(); ++i) {
    TransitionValues start=mPlayStartValuesList.get(i);
    TransitionValues end=mPlayEndValuesList.get(i);
    startTransition();
    runAnimator(mAnimatorMap.get(new Pair(start,end)));
  }
  mPlayStartValuesList.clear();
  mPlayEndValuesList.clear();
  mAnimatorMap.clear();
  endTransition();
}","/** 
 * This is called internally once all animations have been set up by the transition hierarchy. \
 * @hide
 */
protected void runAnimations(){
  if (DBG && mPlayStartValuesList.size() > 0) {
    Log.d(LOG_TAG,""String_Node_Str"" + mPlayStartValuesList.size() + ""String_Node_Str""+ this);
  }
  startTransition();
  for (int i=0; i < mPlayStartValuesList.size(); ++i) {
    TransitionValues start=mPlayStartValuesList.get(i);
    TransitionValues end=mPlayEndValuesList.get(i);
    Animator anim=mAnimatorMap.get(new Pair(start,end));
    if (DBG) {
      Log.d(LOG_TAG,""String_Node_Str"" + anim);
    }
    startTransition();
    runAnimator(anim);
  }
  mPlayStartValuesList.clear();
  mPlayEndValuesList.clear();
  mAnimatorMap.clear();
  endTransition();
}"
1817,"String toString(String indent){
  String result=indent + getClass().getSimpleName() + ""String_Node_Str""+ Integer.toHexString(hashCode())+ ""String_Node_Str"";
  result+=""String_Node_Str"" + mDuration + ""String_Node_Str"";
  result+=""String_Node_Str"" + mStartDelay + ""String_Node_Str"";
  result+=""String_Node_Str"" + mInterpolator + ""String_Node_Str"";
  result+=""String_Node_Str"";
  if (mTargetIds != null) {
    for (int i=0; i < mTargetIds.length; ++i) {
      if (i > 0) {
        result+=""String_Node_Str"";
      }
      result+=mTargetIds[i];
    }
  }
  if (mTargets != null) {
    for (int i=0; i < mTargets.length; ++i) {
      if (i > 0) {
        result+=""String_Node_Str"";
      }
      result+=mTargets[i];
    }
  }
  result+=""String_Node_Str"";
  return result;
}","String toString(String indent){
  String result=indent + getClass().getSimpleName() + ""String_Node_Str""+ Integer.toHexString(hashCode())+ ""String_Node_Str"";
  if (mDuration != -1) {
    result+=""String_Node_Str"" + mDuration + ""String_Node_Str"";
  }
  if (mStartDelay != -1) {
    result+=""String_Node_Str"" + mStartDelay + ""String_Node_Str"";
  }
  if (mInterpolator != null) {
    result+=""String_Node_Str"" + mInterpolator + ""String_Node_Str"";
  }
  if (mTargetIds != null || mTargets != null) {
    result+=""String_Node_Str"";
    if (mTargetIds != null) {
      for (int i=0; i < mTargetIds.length; ++i) {
        if (i > 0) {
          result+=""String_Node_Str"";
        }
        result+=mTargetIds[i];
      }
    }
    if (mTargets != null) {
      for (int i=0; i < mTargets.length; ++i) {
        if (i > 0) {
          result+=""String_Node_Str"";
        }
        result+=mTargets[i];
      }
    }
    result+=""String_Node_Str"";
  }
  return result;
}"
1818,"private static void sceneChangeRunTransition(final ViewGroup sceneRoot,final Transition transition){
  if (transition != null) {
    final ViewTreeObserver observer=sceneRoot.getViewTreeObserver();
    observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
      public boolean onPreDraw(){
        sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
        sRunningTransitions.put(sceneRoot,transition);
        transition.addListener(new Transition.TransitionListenerAdapter(){
          @Override public void onTransitionEnd(          Transition transition){
            sRunningTransitions.remove(sceneRoot);
          }
        }
);
        transition.captureValues(sceneRoot,false);
        transition.playTransition(sceneRoot);
        return true;
      }
    }
);
  }
}","private static void sceneChangeRunTransition(final ViewGroup sceneRoot,final Transition transition){
  if (transition != null) {
    final ViewTreeObserver observer=sceneRoot.getViewTreeObserver();
    observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
      public boolean onPreDraw(){
        sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
        sPendingTransitions.remove(sceneRoot);
        sRunningTransitions.put(sceneRoot,transition);
        transition.addListener(new Transition.TransitionListenerAdapter(){
          @Override public void onTransitionEnd(          Transition transition){
            sRunningTransitions.remove(sceneRoot);
          }
        }
);
        transition.captureValues(sceneRoot,false);
        transition.playTransition(sceneRoot);
        return true;
      }
    }
);
  }
}"
1819,"/** 
 * Static utility method to animate to a new scene defined by all changes within the given scene root between calling this method and the next rendering frame. Calling this method causes TransitionManager to capture current values in the scene root and then post a request to run a transition on the next frame. At that time, the new values in the scene root will be captured and changes will be animated. There is no need to create a Scene; it is implied by changes which take place between calling this method and the next frame when the transition begins. <p>Calling this method several times before the next frame (for example, if unrelated code also wants to make dynamic changes and run a transition on the same scene root), only the first call will trigger capturing values and exiting the current scene. Subsequent calls to the method with the same scene root during the same frame will be ignored.</p> <p>Passing in <code>null</code> for the transition parameter will cause the TransitionManager to use its default transition.</p>
 * @param sceneRoot The root of the View hierarchy to run the transition on.
 * @param transition The transition to use for this change. Avalue of null causes the TransitionManager to use the default transition.
 */
public static void beginDelayedTransition(final ViewGroup sceneRoot,Transition transition){
  if (!sPendingTransitions.contains(sceneRoot)) {
    sPendingTransitions.add(sceneRoot);
    if (transition == null) {
      transition=sDefaultTransition;
    }
    final Transition finalTransition=transition.clone();
    sceneChangeSetup(sceneRoot,transition);
    sceneRoot.setCurrentScene(null);
    sceneRoot.postOnAnimation(new Runnable(){
      @Override public void run(){
        sPendingTransitions.remove(sceneRoot);
        sceneChangeRunTransition(sceneRoot,finalTransition);
      }
    }
);
  }
}","/** 
 * Static utility method to animate to a new scene defined by all changes within the given scene root between calling this method and the next rendering frame. Calling this method causes TransitionManager to capture current values in the scene root and then post a request to run a transition on the next frame. At that time, the new values in the scene root will be captured and changes will be animated. There is no need to create a Scene; it is implied by changes which take place between calling this method and the next frame when the transition begins. <p>Calling this method several times before the next frame (for example, if unrelated code also wants to make dynamic changes and run a transition on the same scene root), only the first call will trigger capturing values and exiting the current scene. Subsequent calls to the method with the same scene root during the same frame will be ignored.</p> <p>Passing in <code>null</code> for the transition parameter will cause the TransitionManager to use its default transition.</p>
 * @param sceneRoot The root of the View hierarchy to run the transition on.
 * @param transition The transition to use for this change. Avalue of null causes the TransitionManager to use the default transition.
 */
public static void beginDelayedTransition(final ViewGroup sceneRoot,Transition transition){
  if (!sPendingTransitions.contains(sceneRoot) && sceneRoot.hasLayout()) {
    if (Transition.DBG) {
      Log.d(LOG_TAG,""String_Node_Str"" + sceneRoot + ""String_Node_Str""+ transition);
    }
    sPendingTransitions.add(sceneRoot);
    if (transition == null) {
      transition=sDefaultTransition;
    }
    final Transition finalTransition=transition.clone();
    sceneChangeSetup(sceneRoot,transition);
    sceneRoot.setCurrentScene(null);
    sceneChangeRunTransition(sceneRoot,finalTransition);
  }
}"
1820,"public boolean onPreDraw(){
  sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
  sRunningTransitions.put(sceneRoot,transition);
  transition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      sRunningTransitions.remove(sceneRoot);
    }
  }
);
  transition.captureValues(sceneRoot,false);
  transition.playTransition(sceneRoot);
  return true;
}","public boolean onPreDraw(){
  sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
  sPendingTransitions.remove(sceneRoot);
  sRunningTransitions.put(sceneRoot,transition);
  transition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      sRunningTransitions.remove(sceneRoot);
    }
  }
);
  transition.captureValues(sceneRoot,false);
  transition.playTransition(sceneRoot);
  return true;
}"
1821,"@Override protected Animator disappear(ViewGroup sceneRoot,TransitionValues startValues,int startVisibility,TransitionValues endValues,int endVisibility){
  if ((mFadingMode & OUT) != OUT) {
    return null;
  }
  View view;
  View startView=(startValues != null) ? startValues.view : null;
  View endView=(endValues != null) ? endValues.view : null;
  if (Transition.DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + startView + ""String_Node_Str""+ startVisibility+ ""String_Node_Str""+ endView+ ""String_Node_Str""+ endVisibility);
  }
  View overlayView=null;
  View viewToKeep=null;
  if (endView == null) {
    view=startView;
    overlayView=view;
  }
 else {
    if (endVisibility == View.INVISIBLE) {
      view=endView;
      viewToKeep=view;
    }
 else {
      if (startView == endView) {
        view=endView;
        viewToKeep=view;
      }
 else {
        view=startView;
        overlayView=view;
      }
    }
  }
  final int finalVisibility=endVisibility;
  if (overlayView != null) {
    int screenX=(Integer)startValues.values.get(PROPNAME_SCREEN_X);
    int screenY=(Integer)startValues.values.get(PROPNAME_SCREEN_Y);
    int[] loc=new int[2];
    sceneRoot.getLocationOnScreen(loc);
    overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
    overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
    sceneRoot.getOverlay().add(overlayView);
    final float startAlpha=view.getAlpha();
    float endAlpha=0;
    final View finalView=view;
    final View finalOverlayView=overlayView;
    final View finalViewToKeep=viewToKeep;
    final ViewGroup finalSceneRoot=sceneRoot;
    final Animator.AnimatorListener endListener=new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        finalView.setAlpha(startAlpha);
        if (finalViewToKeep != null) {
          finalViewToKeep.setVisibility(finalVisibility);
        }
        if (finalOverlayView != null) {
          finalSceneRoot.getOverlay().remove(finalOverlayView);
        }
      }
    }
;
    return runAnimation(view,startAlpha,endAlpha,endListener);
  }
  if (viewToKeep != null) {
    viewToKeep.setVisibility((View.VISIBLE));
    final float startAlpha=view.getAlpha();
    float endAlpha=0;
    final View finalView=view;
    final View finalOverlayView=overlayView;
    final View finalViewToKeep=viewToKeep;
    final ViewGroup finalSceneRoot=sceneRoot;
    final Animator.AnimatorListener endListener=new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        finalView.setAlpha(startAlpha);
        if (finalViewToKeep != null) {
          finalViewToKeep.setVisibility(finalVisibility);
        }
        if (finalOverlayView != null) {
          finalSceneRoot.getOverlay().remove(finalOverlayView);
        }
      }
    }
;
    return runAnimation(view,startAlpha,endAlpha,endListener);
  }
  return null;
}","@Override protected Animator disappear(ViewGroup sceneRoot,TransitionValues startValues,int startVisibility,TransitionValues endValues,int endVisibility){
  if ((mFadingMode & OUT) != OUT) {
    return null;
  }
  View view;
  View startView=(startValues != null) ? startValues.view : null;
  View endView=(endValues != null) ? endValues.view : null;
  if (DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + startView + ""String_Node_Str""+ startVisibility+ ""String_Node_Str""+ endView+ ""String_Node_Str""+ endVisibility);
  }
  View overlayView=null;
  View viewToKeep=null;
  if (endView == null) {
    view=startView;
    overlayView=view;
  }
 else {
    if (endVisibility == View.INVISIBLE) {
      view=endView;
      viewToKeep=view;
    }
 else {
      if (startView == endView) {
        view=endView;
        viewToKeep=view;
      }
 else {
        view=startView;
        overlayView=view;
      }
    }
  }
  final int finalVisibility=endVisibility;
  if (overlayView != null) {
    int screenX=(Integer)startValues.values.get(PROPNAME_SCREEN_X);
    int screenY=(Integer)startValues.values.get(PROPNAME_SCREEN_Y);
    int[] loc=new int[2];
    sceneRoot.getLocationOnScreen(loc);
    overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
    overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
    sceneRoot.getOverlay().add(overlayView);
    final float startAlpha=view.getAlpha();
    float endAlpha=0;
    final View finalView=view;
    final View finalOverlayView=overlayView;
    final View finalViewToKeep=viewToKeep;
    final ViewGroup finalSceneRoot=sceneRoot;
    final Animator.AnimatorListener endListener=new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        finalView.setAlpha(startAlpha);
        if (finalViewToKeep != null) {
          finalViewToKeep.setVisibility(finalVisibility);
        }
        if (finalOverlayView != null) {
          finalSceneRoot.getOverlay().remove(finalOverlayView);
        }
      }
    }
;
    return runAnimation(view,startAlpha,endAlpha,endListener);
  }
  if (viewToKeep != null) {
    viewToKeep.setVisibility((View.VISIBLE));
    final float startAlpha=view.getAlpha();
    float endAlpha=0;
    final View finalView=view;
    final View finalOverlayView=overlayView;
    final View finalViewToKeep=viewToKeep;
    final ViewGroup finalSceneRoot=sceneRoot;
    final Animator.AnimatorListener endListener=new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        finalView.setAlpha(startAlpha);
        if (finalViewToKeep != null) {
          finalViewToKeep.setVisibility(finalVisibility);
        }
        if (finalOverlayView != null) {
          finalSceneRoot.getOverlay().remove(finalOverlayView);
        }
      }
    }
;
    return runAnimation(view,startAlpha,endAlpha,endListener);
  }
  return null;
}"
1822,"/** 
 * This version of play() is called with the entire set of start/end values. The implementation in Transition iterates through these lists and calls   {@link #play(ViewGroup,TransitionValues,TransitionValues)}with each set of start/end values on this transition. The TransitionGroup subclass overrides this method and delegates it to each of its children in succession.
 * @hide
 */
protected void play(ViewGroup sceneRoot,TransitionValuesMaps startValues,TransitionValuesMaps endValues){
  mPlayStartValuesList.clear();
  mPlayEndValuesList.clear();
  ArrayMap<View,TransitionValues> endCopy=new ArrayMap<View,TransitionValues>(endValues.viewValues);
  SparseArray<TransitionValues> endIdCopy=new SparseArray<TransitionValues>(endValues.idValues.size());
  for (int i=0; i < endValues.idValues.size(); ++i) {
    int id=endValues.idValues.keyAt(i);
    endIdCopy.put(id,endValues.idValues.valueAt(i));
  }
  LongSparseArray<TransitionValues> endItemIdCopy=new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
  for (int i=0; i < endValues.itemIdValues.size(); ++i) {
    long id=endValues.itemIdValues.keyAt(i);
    endItemIdCopy.put(id,endValues.itemIdValues.valueAt(i));
  }
  ArrayList<TransitionValues> startValuesList=new ArrayList<TransitionValues>();
  ArrayList<TransitionValues> endValuesList=new ArrayList<TransitionValues>();
  for (  View view : startValues.viewValues.keySet()) {
    TransitionValues start=null;
    TransitionValues end=null;
    boolean isInListView=false;
    if (view.getParent() instanceof ListView) {
      isInListView=true;
    }
    if (!isInListView) {
      int id=view.getId();
      start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      if (endValues.viewValues.get(view) != null) {
        end=endValues.viewValues.get(view);
        endCopy.remove(view);
      }
 else {
        end=endValues.idValues.get(id);
        View removeView=null;
        for (        View viewToRemove : endCopy.keySet()) {
          if (viewToRemove.getId() == id) {
            removeView=viewToRemove;
          }
        }
        if (removeView != null) {
          endCopy.remove(removeView);
        }
      }
      endIdCopy.remove(id);
      if (isValidTarget(view,id)) {
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
 else {
      ListView parent=(ListView)view.getParent();
      if (parent.getAdapter().hasStableIds()) {
        int position=parent.getPositionForView(view);
        long itemId=parent.getItemIdAtPosition(position);
        start=startValues.itemIdValues.get(itemId);
        endItemIdCopy.remove(itemId);
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
  }
  int startItemIdCopySize=startValues.itemIdValues.size();
  for (int i=0; i < startItemIdCopySize; ++i) {
    long id=startValues.itemIdValues.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.itemIdValues.get(id);
      TransitionValues end=endValues.itemIdValues.get(id);
      endItemIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  for (  View view : endCopy.keySet()) {
    int id=view.getId();
    if (isValidTarget(view,id)) {
      TransitionValues start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      TransitionValues end=endCopy.get(view);
      endIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endIdCopySize=endIdCopy.size();
  for (int i=0; i < endIdCopySize; ++i) {
    int id=endIdCopy.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.idValues.get(id);
      TransitionValues end=endIdCopy.get(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endItemIdCopySize=endItemIdCopy.size();
  for (int i=0; i < endItemIdCopySize; ++i) {
    long id=endItemIdCopy.keyAt(i);
    TransitionValues start=startValues.itemIdValues.get(id);
    TransitionValues end=endItemIdCopy.get(id);
    startValuesList.add(start);
    endValuesList.add(end);
  }
  for (int i=0; i < startValuesList.size(); ++i) {
    TransitionValues start=startValuesList.get(i);
    TransitionValues end=endValuesList.get(i);
    Animator animator=play(sceneRoot,start,end);
    if (animator != null) {
      mAnimatorMap.put(new Pair(start,end),animator);
      mPlayStartValuesList.add(start);
      mPlayEndValuesList.add(end);
    }
  }
}","/** 
 * This version of play() is called with the entire set of start/end values. The implementation in Transition iterates through these lists and calls   {@link #play(ViewGroup,TransitionValues,TransitionValues)}with each set of start/end values on this transition. The TransitionGroup subclass overrides this method and delegates it to each of its children in succession.
 * @hide
 */
protected void play(ViewGroup sceneRoot,TransitionValuesMaps startValues,TransitionValuesMaps endValues){
  if (DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + this);
  }
  mPlayStartValuesList.clear();
  mPlayEndValuesList.clear();
  ArrayMap<View,TransitionValues> endCopy=new ArrayMap<View,TransitionValues>(endValues.viewValues);
  SparseArray<TransitionValues> endIdCopy=new SparseArray<TransitionValues>(endValues.idValues.size());
  for (int i=0; i < endValues.idValues.size(); ++i) {
    int id=endValues.idValues.keyAt(i);
    endIdCopy.put(id,endValues.idValues.valueAt(i));
  }
  LongSparseArray<TransitionValues> endItemIdCopy=new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
  for (int i=0; i < endValues.itemIdValues.size(); ++i) {
    long id=endValues.itemIdValues.keyAt(i);
    endItemIdCopy.put(id,endValues.itemIdValues.valueAt(i));
  }
  ArrayList<TransitionValues> startValuesList=new ArrayList<TransitionValues>();
  ArrayList<TransitionValues> endValuesList=new ArrayList<TransitionValues>();
  for (  View view : startValues.viewValues.keySet()) {
    TransitionValues start=null;
    TransitionValues end=null;
    boolean isInListView=false;
    if (view.getParent() instanceof ListView) {
      isInListView=true;
    }
    if (!isInListView) {
      int id=view.getId();
      start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      if (endValues.viewValues.get(view) != null) {
        end=endValues.viewValues.get(view);
        endCopy.remove(view);
      }
 else {
        end=endValues.idValues.get(id);
        View removeView=null;
        for (        View viewToRemove : endCopy.keySet()) {
          if (viewToRemove.getId() == id) {
            removeView=viewToRemove;
          }
        }
        if (removeView != null) {
          endCopy.remove(removeView);
        }
      }
      endIdCopy.remove(id);
      if (isValidTarget(view,id)) {
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
 else {
      ListView parent=(ListView)view.getParent();
      if (parent.getAdapter().hasStableIds()) {
        int position=parent.getPositionForView(view);
        long itemId=parent.getItemIdAtPosition(position);
        start=startValues.itemIdValues.get(itemId);
        endItemIdCopy.remove(itemId);
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
  }
  int startItemIdCopySize=startValues.itemIdValues.size();
  for (int i=0; i < startItemIdCopySize; ++i) {
    long id=startValues.itemIdValues.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.itemIdValues.get(id);
      TransitionValues end=endValues.itemIdValues.get(id);
      endItemIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  for (  View view : endCopy.keySet()) {
    int id=view.getId();
    if (isValidTarget(view,id)) {
      TransitionValues start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      TransitionValues end=endCopy.get(view);
      endIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endIdCopySize=endIdCopy.size();
  for (int i=0; i < endIdCopySize; ++i) {
    int id=endIdCopy.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.idValues.get(id);
      TransitionValues end=endIdCopy.get(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endItemIdCopySize=endItemIdCopy.size();
  for (int i=0; i < endItemIdCopySize; ++i) {
    long id=endItemIdCopy.keyAt(i);
    TransitionValues start=startValues.itemIdValues.get(id);
    TransitionValues end=endItemIdCopy.get(id);
    startValuesList.add(start);
    endValuesList.add(end);
  }
  for (int i=0; i < startValuesList.size(); ++i) {
    TransitionValues start=startValuesList.get(i);
    TransitionValues end=endValuesList.get(i);
    if (start != null || end != null) {
      if (start == null || !start.equals(end)) {
        if (DBG) {
          View view=(end != null) ? end.view : start.view;
          Log.d(LOG_TAG,""String_Node_Str"" + view);
          if (start == null || end == null) {
            if (start == null) {
              Log.d(LOG_TAG,""String_Node_Str"" + ((start == null) ? ""String_Node_Str"" : ""String_Node_Str""));
            }
          }
 else {
            for (            String key : start.values.keySet()) {
              Object startValue=start.values.get(key);
              Object endValue=end.values.get(key);
              if (startValue != endValue && !startValue.equals(endValue)) {
                Log.d(LOG_TAG,""String_Node_Str"" + key + ""String_Node_Str""+ startValue+ ""String_Node_Str""+ endValue+ ""String_Node_Str"");
              }
            }
          }
        }
        Animator animator=play(sceneRoot,start,end);
        if (animator != null) {
          mAnimatorMap.put(new Pair(start,end),animator);
          mPlayStartValuesList.add(start);
          mPlayEndValuesList.add(end);
        }
      }
 else       if (DBG) {
        View view=(end != null) ? end.view : start.view;
        Log.d(LOG_TAG,""String_Node_Str"" + view);
      }
    }
  }
}"
1823,"/** 
 * This is called internally once all animations have been set up by the transition hierarchy. \
 * @hide
 */
protected void runAnimations(){
  startTransition();
  for (int i=0; i < mPlayStartValuesList.size(); ++i) {
    TransitionValues start=mPlayStartValuesList.get(i);
    TransitionValues end=mPlayEndValuesList.get(i);
    startTransition();
    runAnimator(mAnimatorMap.get(new Pair(start,end)));
  }
  mPlayStartValuesList.clear();
  mPlayEndValuesList.clear();
  mAnimatorMap.clear();
  endTransition();
}","/** 
 * This is called internally once all animations have been set up by the transition hierarchy. \
 * @hide
 */
protected void runAnimations(){
  if (DBG && mPlayStartValuesList.size() > 0) {
    Log.d(LOG_TAG,""String_Node_Str"" + mPlayStartValuesList.size() + ""String_Node_Str""+ this);
  }
  startTransition();
  for (int i=0; i < mPlayStartValuesList.size(); ++i) {
    TransitionValues start=mPlayStartValuesList.get(i);
    TransitionValues end=mPlayEndValuesList.get(i);
    Animator anim=mAnimatorMap.get(new Pair(start,end));
    if (DBG) {
      Log.d(LOG_TAG,""String_Node_Str"" + anim);
    }
    startTransition();
    runAnimator(anim);
  }
  mPlayStartValuesList.clear();
  mPlayEndValuesList.clear();
  mAnimatorMap.clear();
  endTransition();
}"
1824,"String toString(String indent){
  String result=indent + getClass().getSimpleName() + ""String_Node_Str""+ Integer.toHexString(hashCode())+ ""String_Node_Str"";
  result+=""String_Node_Str"" + mDuration + ""String_Node_Str"";
  result+=""String_Node_Str"" + mStartDelay + ""String_Node_Str"";
  result+=""String_Node_Str"" + mInterpolator + ""String_Node_Str"";
  result+=""String_Node_Str"";
  if (mTargetIds != null) {
    for (int i=0; i < mTargetIds.length; ++i) {
      if (i > 0) {
        result+=""String_Node_Str"";
      }
      result+=mTargetIds[i];
    }
  }
  if (mTargets != null) {
    for (int i=0; i < mTargets.length; ++i) {
      if (i > 0) {
        result+=""String_Node_Str"";
      }
      result+=mTargets[i];
    }
  }
  result+=""String_Node_Str"";
  return result;
}","String toString(String indent){
  String result=indent + getClass().getSimpleName() + ""String_Node_Str""+ Integer.toHexString(hashCode())+ ""String_Node_Str"";
  if (mDuration != -1) {
    result+=""String_Node_Str"" + mDuration + ""String_Node_Str"";
  }
  if (mStartDelay != -1) {
    result+=""String_Node_Str"" + mStartDelay + ""String_Node_Str"";
  }
  if (mInterpolator != null) {
    result+=""String_Node_Str"" + mInterpolator + ""String_Node_Str"";
  }
  if (mTargetIds != null || mTargets != null) {
    result+=""String_Node_Str"";
    if (mTargetIds != null) {
      for (int i=0; i < mTargetIds.length; ++i) {
        if (i > 0) {
          result+=""String_Node_Str"";
        }
        result+=mTargetIds[i];
      }
    }
    if (mTargets != null) {
      for (int i=0; i < mTargets.length; ++i) {
        if (i > 0) {
          result+=""String_Node_Str"";
        }
        result+=mTargets[i];
      }
    }
    result+=""String_Node_Str"";
  }
  return result;
}"
1825,"private static void sceneChangeRunTransition(final ViewGroup sceneRoot,final Transition transition){
  if (transition != null) {
    final ViewTreeObserver observer=sceneRoot.getViewTreeObserver();
    observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
      public boolean onPreDraw(){
        sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
        sRunningTransitions.put(sceneRoot,transition);
        transition.addListener(new Transition.TransitionListenerAdapter(){
          @Override public void onTransitionEnd(          Transition transition){
            sRunningTransitions.remove(sceneRoot);
          }
        }
);
        transition.captureValues(sceneRoot,false);
        transition.playTransition(sceneRoot);
        return true;
      }
    }
);
  }
}","private static void sceneChangeRunTransition(final ViewGroup sceneRoot,final Transition transition){
  if (transition != null) {
    final ViewTreeObserver observer=sceneRoot.getViewTreeObserver();
    observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
      public boolean onPreDraw(){
        sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
        sPendingTransitions.remove(sceneRoot);
        sRunningTransitions.put(sceneRoot,transition);
        transition.addListener(new Transition.TransitionListenerAdapter(){
          @Override public void onTransitionEnd(          Transition transition){
            sRunningTransitions.remove(sceneRoot);
          }
        }
);
        transition.captureValues(sceneRoot,false);
        transition.playTransition(sceneRoot);
        return true;
      }
    }
);
  }
}"
1826,"/** 
 * Static utility method to animate to a new scene defined by all changes within the given scene root between calling this method and the next rendering frame. Calling this method causes TransitionManager to capture current values in the scene root and then post a request to run a transition on the next frame. At that time, the new values in the scene root will be captured and changes will be animated. There is no need to create a Scene; it is implied by changes which take place between calling this method and the next frame when the transition begins. <p>Calling this method several times before the next frame (for example, if unrelated code also wants to make dynamic changes and run a transition on the same scene root), only the first call will trigger capturing values and exiting the current scene. Subsequent calls to the method with the same scene root during the same frame will be ignored.</p> <p>Passing in <code>null</code> for the transition parameter will cause the TransitionManager to use its default transition.</p>
 * @param sceneRoot The root of the View hierarchy to run the transition on.
 * @param transition The transition to use for this change. Avalue of null causes the TransitionManager to use the default transition.
 */
public static void beginDelayedTransition(final ViewGroup sceneRoot,Transition transition){
  if (!sPendingTransitions.contains(sceneRoot)) {
    sPendingTransitions.add(sceneRoot);
    if (transition == null) {
      transition=sDefaultTransition;
    }
    final Transition finalTransition=transition.clone();
    sceneChangeSetup(sceneRoot,transition);
    sceneRoot.setCurrentScene(null);
    sceneRoot.postOnAnimation(new Runnable(){
      @Override public void run(){
        sPendingTransitions.remove(sceneRoot);
        sceneChangeRunTransition(sceneRoot,finalTransition);
      }
    }
);
  }
}","/** 
 * Static utility method to animate to a new scene defined by all changes within the given scene root between calling this method and the next rendering frame. Calling this method causes TransitionManager to capture current values in the scene root and then post a request to run a transition on the next frame. At that time, the new values in the scene root will be captured and changes will be animated. There is no need to create a Scene; it is implied by changes which take place between calling this method and the next frame when the transition begins. <p>Calling this method several times before the next frame (for example, if unrelated code also wants to make dynamic changes and run a transition on the same scene root), only the first call will trigger capturing values and exiting the current scene. Subsequent calls to the method with the same scene root during the same frame will be ignored.</p> <p>Passing in <code>null</code> for the transition parameter will cause the TransitionManager to use its default transition.</p>
 * @param sceneRoot The root of the View hierarchy to run the transition on.
 * @param transition The transition to use for this change. Avalue of null causes the TransitionManager to use the default transition.
 */
public static void beginDelayedTransition(final ViewGroup sceneRoot,Transition transition){
  if (!sPendingTransitions.contains(sceneRoot) && sceneRoot.hasLayout()) {
    if (Transition.DBG) {
      Log.d(LOG_TAG,""String_Node_Str"" + sceneRoot + ""String_Node_Str""+ transition);
    }
    sPendingTransitions.add(sceneRoot);
    if (transition == null) {
      transition=sDefaultTransition;
    }
    final Transition finalTransition=transition.clone();
    sceneChangeSetup(sceneRoot,transition);
    sceneRoot.setCurrentScene(null);
    sceneChangeRunTransition(sceneRoot,finalTransition);
  }
}"
1827,"public boolean onPreDraw(){
  sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
  sRunningTransitions.put(sceneRoot,transition);
  transition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      sRunningTransitions.remove(sceneRoot);
    }
  }
);
  transition.captureValues(sceneRoot,false);
  transition.playTransition(sceneRoot);
  return true;
}","public boolean onPreDraw(){
  sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
  sPendingTransitions.remove(sceneRoot);
  sRunningTransitions.put(sceneRoot,transition);
  transition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      sRunningTransitions.remove(sceneRoot);
    }
  }
);
  transition.captureValues(sceneRoot,false);
  transition.playTransition(sceneRoot);
  return true;
}"
1828,"public void run(){
  mLastEventTimeMillis=SystemClock.uptimeMillis();
  AccessibilityEvent event=AccessibilityEvent.obtain();
  event.setEventType(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
  event.setContentChangeType(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
  mSource.sendAccessibilityEventUnchecked(event);
  mSource.resetSubtreeAccessibilityStateChanged();
  mSource=null;
}","public void run(){
  if (AccessibilityManager.getInstance(mContext).isEnabled()) {
    mLastEventTimeMillis=SystemClock.uptimeMillis();
    AccessibilityEvent event=AccessibilityEvent.obtain();
    event.setEventType(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
    event.setContentChangeType(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
    mSource.sendAccessibilityEventUnchecked(event);
  }
 else {
    mLastEventTimeMillis=0;
  }
  mSource.resetSubtreeAccessibilityStateChanged();
  mSource=null;
}"
1829,"/** 
 * Caches an   {@link AccessibilityNodeInfo} given its accessibility node id.
 * @param info The {@link AccessibilityNodeInfo} to cache.
 */
public void add(AccessibilityNodeInfo info){
  if (ENABLED) {
synchronized (mLock) {
      if (DEBUG) {
      }
      final long sourceId=info.getSourceNodeId();
      AccessibilityNodeInfo oldInfo=mCacheImpl.get(sourceId);
      if (oldInfo != null) {
        SparseLongArray oldChildrenIds=oldInfo.getChildNodeIds();
        SparseLongArray newChildrenIds=info.getChildNodeIds();
        final int oldChildCount=oldChildrenIds.size();
        for (int i=0; i < oldChildCount; i++) {
          final long oldChildId=oldChildrenIds.valueAt(i);
          if (newChildrenIds.indexOfValue(oldChildId) < 0) {
            clearSubTreeLocked(oldChildId);
          }
        }
        final long oldParentId=oldInfo.getParentNodeId();
        if (info.getParentNodeId() != oldParentId) {
          clearSubTreeLocked(oldParentId);
        }
      }
      AccessibilityNodeInfo clone=AccessibilityNodeInfo.obtain(info);
      mCacheImpl.put(sourceId,clone);
    }
  }
}","/** 
 * Caches an   {@link AccessibilityNodeInfo} given its accessibility node id.
 * @param info The {@link AccessibilityNodeInfo} to cache.
 */
public void add(AccessibilityNodeInfo info){
  if (ENABLED) {
synchronized (mLock) {
      if (DEBUG) {
        Log.i(LOG_TAG,""String_Node_Str"" + info + ""String_Node_Str"");
      }
      final long sourceId=info.getSourceNodeId();
      AccessibilityNodeInfo oldInfo=mCacheImpl.get(sourceId);
      if (oldInfo != null) {
        SparseLongArray oldChildrenIds=oldInfo.getChildNodeIds();
        SparseLongArray newChildrenIds=info.getChildNodeIds();
        final int oldChildCount=oldChildrenIds.size();
        for (int i=0; i < oldChildCount; i++) {
          final long oldChildId=oldChildrenIds.valueAt(i);
          if (newChildrenIds.indexOfValue(oldChildId) < 0) {
            clearSubTreeLocked(oldChildId);
          }
        }
        final long oldParentId=oldInfo.getParentNodeId();
        if (info.getParentNodeId() != oldParentId) {
          clearSubTreeLocked(oldParentId);
        }
      }
      AccessibilityNodeInfo clone=AccessibilityNodeInfo.obtain(info);
      mCacheImpl.put(sourceId,clone);
    }
  }
}"
1830,"private void refreshCachedNode(long sourceId){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
synchronized (mLock) {
    AccessibilityNodeInfo cachedInfo=mCacheImpl.get(sourceId);
    if (cachedInfo == null) {
      return;
    }
    if (cachedInfo.refresh(false)) {
      return;
    }
    clearSubTreeLocked(sourceId);
  }
}","private void refreshCachedNode(long sourceId){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
synchronized (mLock) {
    AccessibilityNodeInfo cachedInfo=mCacheImpl.get(sourceId);
    if (cachedInfo == null) {
      return;
    }
    if (cachedInfo.refresh(true)) {
      return;
    }
    clearSubTreeLocked(sourceId);
  }
}"
1831,"/** 
 * Gets a cached   {@link AccessibilityNodeInfo} given its accessibility node id.
 * @param accessibilityNodeId The info accessibility node id.
 * @return The cached {@link AccessibilityNodeInfo} or null if such not found.
 */
public AccessibilityNodeInfo get(long accessibilityNodeId){
  if (ENABLED) {
synchronized (mLock) {
      AccessibilityNodeInfo info=mCacheImpl.get(accessibilityNodeId);
      if (info != null) {
        info=AccessibilityNodeInfo.obtain(info);
      }
      if (DEBUG) {
      }
      return info;
    }
  }
 else {
    return null;
  }
}","/** 
 * Gets a cached   {@link AccessibilityNodeInfo} given its accessibility node id.
 * @param accessibilityNodeId The info accessibility node id.
 * @return The cached {@link AccessibilityNodeInfo} or null if such not found.
 */
public AccessibilityNodeInfo get(long accessibilityNodeId){
  if (ENABLED) {
synchronized (mLock) {
      AccessibilityNodeInfo info=mCacheImpl.get(accessibilityNodeId);
      if (info != null) {
        info=AccessibilityNodeInfo.obtain(info);
      }
      if (DEBUG) {
        Log.i(LOG_TAG,""String_Node_Str"" + accessibilityNodeId + ""String_Node_Str""+ info);
      }
      return info;
    }
  }
 else {
    return null;
  }
}"
1832,"/** 
 * Check the integrity of the cache which is it does not have nodes from more than one window, there are no duplicates, all nodes are connected, there is a single input focused node, and there is a single accessibility focused node.
 */
private void checkIntegrity(){
synchronized (mLock) {
    if (mCacheImpl.size() <= 0) {
      return;
    }
    AccessibilityNodeInfo root=mCacheImpl.valueAt(0);
    AccessibilityNodeInfo parent=root;
    while (parent != null) {
      root=parent;
      parent=mCacheImpl.get(parent.getParentNodeId());
    }
    final int windowId=root.getWindowId();
    AccessibilityNodeInfo accessFocus=null;
    AccessibilityNodeInfo inputFocus=null;
    HashSet<AccessibilityNodeInfo> seen=new HashSet<AccessibilityNodeInfo>();
    Queue<AccessibilityNodeInfo> fringe=new LinkedList<AccessibilityNodeInfo>();
    fringe.add(root);
    while (!fringe.isEmpty()) {
      AccessibilityNodeInfo current=fringe.poll();
      if (!seen.add(current)) {
        Log.e(LOG_TAG,""String_Node_Str"" + current);
        return;
      }
      if (current.isAccessibilityFocused()) {
        if (accessFocus != null) {
          Log.e(LOG_TAG,""String_Node_Str"" + current);
        }
 else {
          accessFocus=current;
        }
      }
      if (current.isFocused()) {
        if (inputFocus != null) {
          Log.e(LOG_TAG,""String_Node_Str"" + current);
        }
 else {
          inputFocus=current;
        }
      }
      SparseLongArray childIds=current.getChildNodeIds();
      final int childCount=childIds.size();
      for (int i=0; i < childCount; i++) {
        final long childId=childIds.valueAt(i);
        AccessibilityNodeInfo child=mCacheImpl.get(childId);
        if (child != null) {
          fringe.add(child);
        }
      }
    }
    for (int i=0; i < mCacheImpl.size(); i++) {
      AccessibilityNodeInfo info=mCacheImpl.valueAt(i);
      if (!seen.contains(info)) {
        if (info.getWindowId() == windowId) {
          Log.e(LOG_TAG,""String_Node_Str"" + info);
        }
 else {
          Log.e(LOG_TAG,""String_Node_Str"" + info.getWindowId() + ""String_Node_Str""+ windowId+ ""String_Node_Str""+ info);
        }
        mCacheImpl.removeAt(i);
        i--;
      }
    }
  }
}","/** 
 * Check the integrity of the cache which is it does not have nodes from more than one window, there are no duplicates, all nodes are connected, there is a single input focused node, and there is a single accessibility focused node.
 */
private void checkIntegrity(){
synchronized (mLock) {
    if (mCacheImpl.size() <= 0) {
      return;
    }
    AccessibilityNodeInfo root=mCacheImpl.valueAt(0);
    AccessibilityNodeInfo parent=root;
    while (parent != null) {
      root=parent;
      parent=mCacheImpl.get(parent.getParentNodeId());
    }
    final int windowId=root.getWindowId();
    AccessibilityNodeInfo accessFocus=null;
    AccessibilityNodeInfo inputFocus=null;
    HashSet<AccessibilityNodeInfo> seen=new HashSet<AccessibilityNodeInfo>();
    Queue<AccessibilityNodeInfo> fringe=new LinkedList<AccessibilityNodeInfo>();
    fringe.add(root);
    while (!fringe.isEmpty()) {
      AccessibilityNodeInfo current=fringe.poll();
      if (!seen.add(current)) {
        Log.e(LOG_TAG,""String_Node_Str"" + current);
        return;
      }
      if (current.isAccessibilityFocused()) {
        if (accessFocus != null) {
          Log.e(LOG_TAG,""String_Node_Str"" + current);
        }
 else {
          accessFocus=current;
        }
      }
      if (current.isFocused()) {
        if (inputFocus != null) {
          Log.e(LOG_TAG,""String_Node_Str"" + current);
        }
 else {
          inputFocus=current;
        }
      }
      SparseLongArray childIds=current.getChildNodeIds();
      final int childCount=childIds.size();
      for (int i=0; i < childCount; i++) {
        final long childId=childIds.valueAt(i);
        AccessibilityNodeInfo child=mCacheImpl.get(childId);
        if (child != null) {
          fringe.add(child);
        }
      }
    }
    for (int i=0; i < mCacheImpl.size(); i++) {
      AccessibilityNodeInfo info=mCacheImpl.valueAt(i);
      if (!seen.contains(info)) {
        if (info.getWindowId() == windowId) {
          Log.e(LOG_TAG,""String_Node_Str"" + info);
        }
 else {
          Log.e(LOG_TAG,""String_Node_Str"" + info.getWindowId() + ""String_Node_Str""+ windowId+ ""String_Node_Str""+ info);
        }
      }
    }
  }
}"
1833,"public void run(){
  mLastEventTimeMillis=SystemClock.uptimeMillis();
  AccessibilityEvent event=AccessibilityEvent.obtain();
  event.setEventType(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
  event.setContentChangeType(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
  mSource.sendAccessibilityEventUnchecked(event);
  mSource.resetSubtreeAccessibilityStateChanged();
  mSource=null;
}","public void run(){
  if (AccessibilityManager.getInstance(mContext).isEnabled()) {
    mLastEventTimeMillis=SystemClock.uptimeMillis();
    AccessibilityEvent event=AccessibilityEvent.obtain();
    event.setEventType(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
    event.setContentChangeType(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
    mSource.sendAccessibilityEventUnchecked(event);
  }
 else {
    mLastEventTimeMillis=0;
  }
  mSource.resetSubtreeAccessibilityStateChanged();
  mSource=null;
}"
1834,"/** 
 * Caches an   {@link AccessibilityNodeInfo} given its accessibility node id.
 * @param info The {@link AccessibilityNodeInfo} to cache.
 */
public void add(AccessibilityNodeInfo info){
  if (ENABLED) {
synchronized (mLock) {
      if (DEBUG) {
      }
      final long sourceId=info.getSourceNodeId();
      AccessibilityNodeInfo oldInfo=mCacheImpl.get(sourceId);
      if (oldInfo != null) {
        SparseLongArray oldChildrenIds=oldInfo.getChildNodeIds();
        SparseLongArray newChildrenIds=info.getChildNodeIds();
        final int oldChildCount=oldChildrenIds.size();
        for (int i=0; i < oldChildCount; i++) {
          final long oldChildId=oldChildrenIds.valueAt(i);
          if (newChildrenIds.indexOfValue(oldChildId) < 0) {
            clearSubTreeLocked(oldChildId);
          }
        }
        final long oldParentId=oldInfo.getParentNodeId();
        if (info.getParentNodeId() != oldParentId) {
          clearSubTreeLocked(oldParentId);
        }
      }
      AccessibilityNodeInfo clone=AccessibilityNodeInfo.obtain(info);
      mCacheImpl.put(sourceId,clone);
    }
  }
}","/** 
 * Caches an   {@link AccessibilityNodeInfo} given its accessibility node id.
 * @param info The {@link AccessibilityNodeInfo} to cache.
 */
public void add(AccessibilityNodeInfo info){
  if (ENABLED) {
synchronized (mLock) {
      if (DEBUG) {
        Log.i(LOG_TAG,""String_Node_Str"" + info + ""String_Node_Str"");
      }
      final long sourceId=info.getSourceNodeId();
      AccessibilityNodeInfo oldInfo=mCacheImpl.get(sourceId);
      if (oldInfo != null) {
        SparseLongArray oldChildrenIds=oldInfo.getChildNodeIds();
        SparseLongArray newChildrenIds=info.getChildNodeIds();
        final int oldChildCount=oldChildrenIds.size();
        for (int i=0; i < oldChildCount; i++) {
          final long oldChildId=oldChildrenIds.valueAt(i);
          if (newChildrenIds.indexOfValue(oldChildId) < 0) {
            clearSubTreeLocked(oldChildId);
          }
        }
        final long oldParentId=oldInfo.getParentNodeId();
        if (info.getParentNodeId() != oldParentId) {
          clearSubTreeLocked(oldParentId);
        }
      }
      AccessibilityNodeInfo clone=AccessibilityNodeInfo.obtain(info);
      mCacheImpl.put(sourceId,clone);
    }
  }
}"
1835,"private void refreshCachedNode(long sourceId){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
synchronized (mLock) {
    AccessibilityNodeInfo cachedInfo=mCacheImpl.get(sourceId);
    if (cachedInfo == null) {
      return;
    }
    if (cachedInfo.refresh(false)) {
      return;
    }
    clearSubTreeLocked(sourceId);
  }
}","private void refreshCachedNode(long sourceId){
  if (DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"");
  }
synchronized (mLock) {
    AccessibilityNodeInfo cachedInfo=mCacheImpl.get(sourceId);
    if (cachedInfo == null) {
      return;
    }
    if (cachedInfo.refresh(true)) {
      return;
    }
    clearSubTreeLocked(sourceId);
  }
}"
1836,"/** 
 * Gets a cached   {@link AccessibilityNodeInfo} given its accessibility node id.
 * @param accessibilityNodeId The info accessibility node id.
 * @return The cached {@link AccessibilityNodeInfo} or null if such not found.
 */
public AccessibilityNodeInfo get(long accessibilityNodeId){
  if (ENABLED) {
synchronized (mLock) {
      AccessibilityNodeInfo info=mCacheImpl.get(accessibilityNodeId);
      if (info != null) {
        info=AccessibilityNodeInfo.obtain(info);
      }
      if (DEBUG) {
      }
      return info;
    }
  }
 else {
    return null;
  }
}","/** 
 * Gets a cached   {@link AccessibilityNodeInfo} given its accessibility node id.
 * @param accessibilityNodeId The info accessibility node id.
 * @return The cached {@link AccessibilityNodeInfo} or null if such not found.
 */
public AccessibilityNodeInfo get(long accessibilityNodeId){
  if (ENABLED) {
synchronized (mLock) {
      AccessibilityNodeInfo info=mCacheImpl.get(accessibilityNodeId);
      if (info != null) {
        info=AccessibilityNodeInfo.obtain(info);
      }
      if (DEBUG) {
        Log.i(LOG_TAG,""String_Node_Str"" + accessibilityNodeId + ""String_Node_Str""+ info);
      }
      return info;
    }
  }
 else {
    return null;
  }
}"
1837,"/** 
 * Check the integrity of the cache which is it does not have nodes from more than one window, there are no duplicates, all nodes are connected, there is a single input focused node, and there is a single accessibility focused node.
 */
private void checkIntegrity(){
synchronized (mLock) {
    if (mCacheImpl.size() <= 0) {
      return;
    }
    AccessibilityNodeInfo root=mCacheImpl.valueAt(0);
    AccessibilityNodeInfo parent=root;
    while (parent != null) {
      root=parent;
      parent=mCacheImpl.get(parent.getParentNodeId());
    }
    final int windowId=root.getWindowId();
    AccessibilityNodeInfo accessFocus=null;
    AccessibilityNodeInfo inputFocus=null;
    HashSet<AccessibilityNodeInfo> seen=new HashSet<AccessibilityNodeInfo>();
    Queue<AccessibilityNodeInfo> fringe=new LinkedList<AccessibilityNodeInfo>();
    fringe.add(root);
    while (!fringe.isEmpty()) {
      AccessibilityNodeInfo current=fringe.poll();
      if (!seen.add(current)) {
        Log.e(LOG_TAG,""String_Node_Str"" + current);
        return;
      }
      if (current.isAccessibilityFocused()) {
        if (accessFocus != null) {
          Log.e(LOG_TAG,""String_Node_Str"" + current);
        }
 else {
          accessFocus=current;
        }
      }
      if (current.isFocused()) {
        if (inputFocus != null) {
          Log.e(LOG_TAG,""String_Node_Str"" + current);
        }
 else {
          inputFocus=current;
        }
      }
      SparseLongArray childIds=current.getChildNodeIds();
      final int childCount=childIds.size();
      for (int i=0; i < childCount; i++) {
        final long childId=childIds.valueAt(i);
        AccessibilityNodeInfo child=mCacheImpl.get(childId);
        if (child != null) {
          fringe.add(child);
        }
      }
    }
    for (int i=0; i < mCacheImpl.size(); i++) {
      AccessibilityNodeInfo info=mCacheImpl.valueAt(i);
      if (!seen.contains(info)) {
        if (info.getWindowId() == windowId) {
          Log.e(LOG_TAG,""String_Node_Str"" + info);
        }
 else {
          Log.e(LOG_TAG,""String_Node_Str"" + info.getWindowId() + ""String_Node_Str""+ windowId+ ""String_Node_Str""+ info);
        }
        mCacheImpl.removeAt(i);
        i--;
      }
    }
  }
}","/** 
 * Check the integrity of the cache which is it does not have nodes from more than one window, there are no duplicates, all nodes are connected, there is a single input focused node, and there is a single accessibility focused node.
 */
private void checkIntegrity(){
synchronized (mLock) {
    if (mCacheImpl.size() <= 0) {
      return;
    }
    AccessibilityNodeInfo root=mCacheImpl.valueAt(0);
    AccessibilityNodeInfo parent=root;
    while (parent != null) {
      root=parent;
      parent=mCacheImpl.get(parent.getParentNodeId());
    }
    final int windowId=root.getWindowId();
    AccessibilityNodeInfo accessFocus=null;
    AccessibilityNodeInfo inputFocus=null;
    HashSet<AccessibilityNodeInfo> seen=new HashSet<AccessibilityNodeInfo>();
    Queue<AccessibilityNodeInfo> fringe=new LinkedList<AccessibilityNodeInfo>();
    fringe.add(root);
    while (!fringe.isEmpty()) {
      AccessibilityNodeInfo current=fringe.poll();
      if (!seen.add(current)) {
        Log.e(LOG_TAG,""String_Node_Str"" + current);
        return;
      }
      if (current.isAccessibilityFocused()) {
        if (accessFocus != null) {
          Log.e(LOG_TAG,""String_Node_Str"" + current);
        }
 else {
          accessFocus=current;
        }
      }
      if (current.isFocused()) {
        if (inputFocus != null) {
          Log.e(LOG_TAG,""String_Node_Str"" + current);
        }
 else {
          inputFocus=current;
        }
      }
      SparseLongArray childIds=current.getChildNodeIds();
      final int childCount=childIds.size();
      for (int i=0; i < childCount; i++) {
        final long childId=childIds.valueAt(i);
        AccessibilityNodeInfo child=mCacheImpl.get(childId);
        if (child != null) {
          fringe.add(child);
        }
      }
    }
    for (int i=0; i < mCacheImpl.size(); i++) {
      AccessibilityNodeInfo info=mCacheImpl.valueAt(i);
      if (!seen.contains(info)) {
        if (info.getWindowId() == windowId) {
          Log.e(LOG_TAG,""String_Node_Str"" + info);
        }
 else {
          Log.e(LOG_TAG,""String_Node_Str"" + info.getWindowId() + ""String_Node_Str""+ windowId+ ""String_Node_Str""+ info);
        }
      }
    }
  }
}"
1838,"@Override protected Animator appear(ViewGroup sceneRoot,TransitionValues startValues,int startVisibility,TransitionValues endValues,int endVisibility){
  View endView=(endValues != null) ? endValues.view : null;
  if ((mFadingMode & IN) != IN) {
    return null;
  }
  endView.setAlpha(0);
  return runAnimation(endView,0,1,null);
}","@Override protected Animator appear(ViewGroup sceneRoot,TransitionValues startValues,int startVisibility,TransitionValues endValues,int endVisibility){
  if ((mFadingMode & IN) != IN || endValues == null) {
    return null;
  }
  final View endView=endValues.view;
  endView.setAlpha(0);
  final Animator.AnimatorListener endListener=new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      endView.setAlpha(1);
    }
  }
;
  return runAnimation(endView,0,1,endListener);
}"
1839,"/** 
 * Adds child transitions to this group. The order of the child transitions passed in determines the order in which they are started.
 * @param transitions A list of child transition to be added to this group.
 */
public void addTransitions(Transition... transitions){
  if (transitions != null) {
    int numTransitions=transitions.length;
    for (int i=0; i < numTransitions; ++i) {
      mTransitions.add(transitions[i]);
      transitions[i].mParent=this;
      if (mDuration >= 0) {
        transitions[0].setDuration(mDuration);
      }
    }
  }
}","/** 
 * Adds child transitions to this group. The order of the child transitions passed in determines the order in which they are started.
 * @param transitions A list of child transition to be added to this group.
 */
public void addTransitions(Transition... transitions){
  if (transitions != null) {
    int numTransitions=transitions.length;
    for (int i=0; i < numTransitions; ++i) {
      mTransitions.add(transitions[i]);
      transitions[i].mParent=this;
      if (mDuration >= 0) {
        transitions[i].setDuration(mDuration);
      }
    }
  }
}"
1840,"@Override protected Animator appear(ViewGroup sceneRoot,TransitionValues startValues,int startVisibility,TransitionValues endValues,int endVisibility){
  View endView=(endValues != null) ? endValues.view : null;
  if ((mFadingMode & IN) != IN) {
    return null;
  }
  endView.setAlpha(0);
  return runAnimation(endView,0,1,null);
}","@Override protected Animator appear(ViewGroup sceneRoot,TransitionValues startValues,int startVisibility,TransitionValues endValues,int endVisibility){
  if ((mFadingMode & IN) != IN || endValues == null) {
    return null;
  }
  final View endView=endValues.view;
  endView.setAlpha(0);
  final Animator.AnimatorListener endListener=new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      endView.setAlpha(1);
    }
  }
;
  return runAnimation(endView,0,1,endListener);
}"
1841,"/** 
 * Adds child transitions to this group. The order of the child transitions passed in determines the order in which they are started.
 * @param transitions A list of child transition to be added to this group.
 */
public void addTransitions(Transition... transitions){
  if (transitions != null) {
    int numTransitions=transitions.length;
    for (int i=0; i < numTransitions; ++i) {
      mTransitions.add(transitions[i]);
      transitions[i].mParent=this;
      if (mDuration >= 0) {
        transitions[0].setDuration(mDuration);
      }
    }
  }
}","/** 
 * Adds child transitions to this group. The order of the child transitions passed in determines the order in which they are started.
 * @param transitions A list of child transition to be added to this group.
 */
public void addTransitions(Transition... transitions){
  if (transitions != null) {
    int numTransitions=transitions.length;
    for (int i=0; i < numTransitions; ++i) {
      mTransitions.add(transitions[i]);
      transitions[i].mParent=this;
      if (mDuration >= 0) {
        transitions[i].setDuration(mDuration);
      }
    }
  }
}"
1842,"void updateCpuStatsNow(){
synchronized (mProcessStatsThread) {
    mProcessStatsMutexFree.set(false);
    final long now=SystemClock.uptimeMillis();
    boolean haveNewCpuStats=false;
    if (MONITOR_CPU_USAGE && mLastCpuTime.get() < (now - MONITOR_CPU_MIN_TIME)) {
      mLastCpuTime.set(now);
      haveNewCpuStats=true;
      mProcessStats.update();
      if (""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""))) {
        int user=mProcessStats.getLastUserTime();
        int system=mProcessStats.getLastSystemTime();
        int iowait=mProcessStats.getLastIoWaitTime();
        int irq=mProcessStats.getLastIrqTime();
        int softIrq=mProcessStats.getLastSoftIrqTime();
        int idle=mProcessStats.getLastIdleTime();
        int total=user + system + iowait+ irq+ softIrq+ idle;
        if (total == 0)         total=1;
        EventLog.writeEvent(EventLogTags.CPU,((user + system + iowait+ irq+ softIrq) * 100) / total,(user * 100) / total,(system * 100) / total,(iowait * 100) / total,(irq * 100) / total,(softIrq * 100) / total);
      }
    }
    long[] cpuSpeedTimes=mProcessStats.getLastCpuSpeedTimes();
    final BatteryStatsImpl bstats=mBatteryStatsService.getActiveStatistics();
synchronized (bstats) {
synchronized (mPidsSelfLocked) {
        if (haveNewCpuStats) {
          if (mOnBattery) {
            int perc=bstats.startAddingCpuLocked();
            int totalUTime=0;
            int totalSTime=0;
            final int N=mProcessStats.countStats();
            for (int i=0; i < N; i++) {
              ProcessStats.Stats st=mProcessStats.getStats(i);
              if (!st.working) {
                continue;
              }
              ProcessRecord pr=mPidsSelfLocked.get(st.pid);
              int otherUTime=(st.rel_utime * perc) / 100;
              int otherSTime=(st.rel_stime * perc) / 100;
              totalUTime+=otherUTime;
              totalSTime+=otherSTime;
              if (pr != null) {
                BatteryStatsImpl.Uid.Proc ps=pr.batteryStats;
                ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                ps.addSpeedStepTimes(cpuSpeedTimes);
                pr.curCpuTime+=(st.rel_utime + st.rel_stime) * 10;
              }
 else               if (st.uid >= Process.FIRST_APPLICATION_UID) {
                BatteryStatsImpl.Uid.Proc ps=st.batteryStats;
                if (ps == null) {
                  st.batteryStats=ps=bstats.getProcessStatsLocked(st.uid,""String_Node_Str"");
                }
                ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                ps.addSpeedStepTimes(cpuSpeedTimes);
                pr.curCpuTime+=(st.rel_utime + st.rel_stime) * 10;
              }
 else {
                BatteryStatsImpl.Uid.Proc ps=bstats.getProcessStatsLocked(st.name,st.pid);
                if (ps != null) {
                  ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                  ps.addSpeedStepTimes(cpuSpeedTimes);
                }
              }
            }
            bstats.finishAddingCpuLocked(perc,totalUTime,totalSTime,cpuSpeedTimes);
          }
        }
      }
      if (mLastWriteTime < (now - BATTERY_STATS_TIME)) {
        mLastWriteTime=now;
        mBatteryStatsService.getActiveStatistics().writeAsyncLocked();
      }
    }
  }
}","void updateCpuStatsNow(){
synchronized (mProcessStatsThread) {
    mProcessStatsMutexFree.set(false);
    final long now=SystemClock.uptimeMillis();
    boolean haveNewCpuStats=false;
    if (MONITOR_CPU_USAGE && mLastCpuTime.get() < (now - MONITOR_CPU_MIN_TIME)) {
      mLastCpuTime.set(now);
      haveNewCpuStats=true;
      mProcessStats.update();
      if (""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""))) {
        int user=mProcessStats.getLastUserTime();
        int system=mProcessStats.getLastSystemTime();
        int iowait=mProcessStats.getLastIoWaitTime();
        int irq=mProcessStats.getLastIrqTime();
        int softIrq=mProcessStats.getLastSoftIrqTime();
        int idle=mProcessStats.getLastIdleTime();
        int total=user + system + iowait+ irq+ softIrq+ idle;
        if (total == 0)         total=1;
        EventLog.writeEvent(EventLogTags.CPU,((user + system + iowait+ irq+ softIrq) * 100) / total,(user * 100) / total,(system * 100) / total,(iowait * 100) / total,(irq * 100) / total,(softIrq * 100) / total);
      }
    }
    long[] cpuSpeedTimes=mProcessStats.getLastCpuSpeedTimes();
    final BatteryStatsImpl bstats=mBatteryStatsService.getActiveStatistics();
synchronized (bstats) {
synchronized (mPidsSelfLocked) {
        if (haveNewCpuStats) {
          if (mOnBattery) {
            int perc=bstats.startAddingCpuLocked();
            int totalUTime=0;
            int totalSTime=0;
            final int N=mProcessStats.countStats();
            for (int i=0; i < N; i++) {
              ProcessStats.Stats st=mProcessStats.getStats(i);
              if (!st.working) {
                continue;
              }
              ProcessRecord pr=mPidsSelfLocked.get(st.pid);
              int otherUTime=(st.rel_utime * perc) / 100;
              int otherSTime=(st.rel_stime * perc) / 100;
              totalUTime+=otherUTime;
              totalSTime+=otherSTime;
              if (pr != null) {
                BatteryStatsImpl.Uid.Proc ps=pr.batteryStats;
                ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                ps.addSpeedStepTimes(cpuSpeedTimes);
                pr.curCpuTime+=(st.rel_utime + st.rel_stime) * 10;
              }
 else               if (st.uid >= Process.FIRST_APPLICATION_UID) {
                BatteryStatsImpl.Uid.Proc ps=st.batteryStats;
                if (ps == null) {
                  st.batteryStats=ps=bstats.getProcessStatsLocked(st.uid,""String_Node_Str"");
                }
                ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                ps.addSpeedStepTimes(cpuSpeedTimes);
              }
 else {
                BatteryStatsImpl.Uid.Proc ps=bstats.getProcessStatsLocked(st.name,st.pid);
                if (ps != null) {
                  ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                  ps.addSpeedStepTimes(cpuSpeedTimes);
                }
              }
            }
            bstats.finishAddingCpuLocked(perc,totalUTime,totalSTime,cpuSpeedTimes);
          }
        }
      }
      if (mLastWriteTime < (now - BATTERY_STATS_TIME)) {
        mLastWriteTime=now;
        mBatteryStatsService.getActiveStatistics().writeAsyncLocked();
      }
    }
  }
}"
1843,"void updateCpuStatsNow(){
synchronized (mProcessStatsThread) {
    mProcessStatsMutexFree.set(false);
    final long now=SystemClock.uptimeMillis();
    boolean haveNewCpuStats=false;
    if (MONITOR_CPU_USAGE && mLastCpuTime.get() < (now - MONITOR_CPU_MIN_TIME)) {
      mLastCpuTime.set(now);
      haveNewCpuStats=true;
      mProcessStats.update();
      if (""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""))) {
        int user=mProcessStats.getLastUserTime();
        int system=mProcessStats.getLastSystemTime();
        int iowait=mProcessStats.getLastIoWaitTime();
        int irq=mProcessStats.getLastIrqTime();
        int softIrq=mProcessStats.getLastSoftIrqTime();
        int idle=mProcessStats.getLastIdleTime();
        int total=user + system + iowait+ irq+ softIrq+ idle;
        if (total == 0)         total=1;
        EventLog.writeEvent(EventLogTags.CPU,((user + system + iowait+ irq+ softIrq) * 100) / total,(user * 100) / total,(system * 100) / total,(iowait * 100) / total,(irq * 100) / total,(softIrq * 100) / total);
      }
    }
    long[] cpuSpeedTimes=mProcessStats.getLastCpuSpeedTimes();
    final BatteryStatsImpl bstats=mBatteryStatsService.getActiveStatistics();
synchronized (bstats) {
synchronized (mPidsSelfLocked) {
        if (haveNewCpuStats) {
          if (mOnBattery) {
            int perc=bstats.startAddingCpuLocked();
            int totalUTime=0;
            int totalSTime=0;
            final int N=mProcessStats.countStats();
            for (int i=0; i < N; i++) {
              ProcessStats.Stats st=mProcessStats.getStats(i);
              if (!st.working) {
                continue;
              }
              ProcessRecord pr=mPidsSelfLocked.get(st.pid);
              int otherUTime=(st.rel_utime * perc) / 100;
              int otherSTime=(st.rel_stime * perc) / 100;
              totalUTime+=otherUTime;
              totalSTime+=otherSTime;
              if (pr != null) {
                BatteryStatsImpl.Uid.Proc ps=pr.batteryStats;
                ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                ps.addSpeedStepTimes(cpuSpeedTimes);
                pr.curCpuTime+=(st.rel_utime + st.rel_stime) * 10;
              }
 else               if (st.uid >= Process.FIRST_APPLICATION_UID) {
                BatteryStatsImpl.Uid.Proc ps=st.batteryStats;
                if (ps == null) {
                  st.batteryStats=ps=bstats.getProcessStatsLocked(st.uid,""String_Node_Str"");
                }
                ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                ps.addSpeedStepTimes(cpuSpeedTimes);
                pr.curCpuTime+=(st.rel_utime + st.rel_stime) * 10;
              }
 else {
                BatteryStatsImpl.Uid.Proc ps=bstats.getProcessStatsLocked(st.name,st.pid);
                if (ps != null) {
                  ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                  ps.addSpeedStepTimes(cpuSpeedTimes);
                }
              }
            }
            bstats.finishAddingCpuLocked(perc,totalUTime,totalSTime,cpuSpeedTimes);
          }
        }
      }
      if (mLastWriteTime < (now - BATTERY_STATS_TIME)) {
        mLastWriteTime=now;
        mBatteryStatsService.getActiveStatistics().writeAsyncLocked();
      }
    }
  }
}","void updateCpuStatsNow(){
synchronized (mProcessStatsThread) {
    mProcessStatsMutexFree.set(false);
    final long now=SystemClock.uptimeMillis();
    boolean haveNewCpuStats=false;
    if (MONITOR_CPU_USAGE && mLastCpuTime.get() < (now - MONITOR_CPU_MIN_TIME)) {
      mLastCpuTime.set(now);
      haveNewCpuStats=true;
      mProcessStats.update();
      if (""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""))) {
        int user=mProcessStats.getLastUserTime();
        int system=mProcessStats.getLastSystemTime();
        int iowait=mProcessStats.getLastIoWaitTime();
        int irq=mProcessStats.getLastIrqTime();
        int softIrq=mProcessStats.getLastSoftIrqTime();
        int idle=mProcessStats.getLastIdleTime();
        int total=user + system + iowait+ irq+ softIrq+ idle;
        if (total == 0)         total=1;
        EventLog.writeEvent(EventLogTags.CPU,((user + system + iowait+ irq+ softIrq) * 100) / total,(user * 100) / total,(system * 100) / total,(iowait * 100) / total,(irq * 100) / total,(softIrq * 100) / total);
      }
    }
    long[] cpuSpeedTimes=mProcessStats.getLastCpuSpeedTimes();
    final BatteryStatsImpl bstats=mBatteryStatsService.getActiveStatistics();
synchronized (bstats) {
synchronized (mPidsSelfLocked) {
        if (haveNewCpuStats) {
          if (mOnBattery) {
            int perc=bstats.startAddingCpuLocked();
            int totalUTime=0;
            int totalSTime=0;
            final int N=mProcessStats.countStats();
            for (int i=0; i < N; i++) {
              ProcessStats.Stats st=mProcessStats.getStats(i);
              if (!st.working) {
                continue;
              }
              ProcessRecord pr=mPidsSelfLocked.get(st.pid);
              int otherUTime=(st.rel_utime * perc) / 100;
              int otherSTime=(st.rel_stime * perc) / 100;
              totalUTime+=otherUTime;
              totalSTime+=otherSTime;
              if (pr != null) {
                BatteryStatsImpl.Uid.Proc ps=pr.batteryStats;
                ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                ps.addSpeedStepTimes(cpuSpeedTimes);
                pr.curCpuTime+=(st.rel_utime + st.rel_stime) * 10;
              }
 else               if (st.uid >= Process.FIRST_APPLICATION_UID) {
                BatteryStatsImpl.Uid.Proc ps=st.batteryStats;
                if (ps == null) {
                  st.batteryStats=ps=bstats.getProcessStatsLocked(st.uid,""String_Node_Str"");
                }
                ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                ps.addSpeedStepTimes(cpuSpeedTimes);
              }
 else {
                BatteryStatsImpl.Uid.Proc ps=bstats.getProcessStatsLocked(st.name,st.pid);
                if (ps != null) {
                  ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                  ps.addSpeedStepTimes(cpuSpeedTimes);
                }
              }
            }
            bstats.finishAddingCpuLocked(perc,totalUTime,totalSTime,cpuSpeedTimes);
          }
        }
      }
      if (mLastWriteTime < (now - BATTERY_STATS_TIME)) {
        mLastWriteTime=now;
        mBatteryStatsService.getActiveStatistics().writeAsyncLocked();
      }
    }
  }
}"
1844,"void updateCpuStatsNow(){
synchronized (mProcessStatsThread) {
    mProcessStatsMutexFree.set(false);
    final long now=SystemClock.uptimeMillis();
    boolean haveNewCpuStats=false;
    if (MONITOR_CPU_USAGE && mLastCpuTime.get() < (now - MONITOR_CPU_MIN_TIME)) {
      mLastCpuTime.set(now);
      haveNewCpuStats=true;
      mProcessStats.update();
      if (""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""))) {
        int user=mProcessStats.getLastUserTime();
        int system=mProcessStats.getLastSystemTime();
        int iowait=mProcessStats.getLastIoWaitTime();
        int irq=mProcessStats.getLastIrqTime();
        int softIrq=mProcessStats.getLastSoftIrqTime();
        int idle=mProcessStats.getLastIdleTime();
        int total=user + system + iowait+ irq+ softIrq+ idle;
        if (total == 0)         total=1;
        EventLog.writeEvent(EventLogTags.CPU,((user + system + iowait+ irq+ softIrq) * 100) / total,(user * 100) / total,(system * 100) / total,(iowait * 100) / total,(irq * 100) / total,(softIrq * 100) / total);
      }
    }
    long[] cpuSpeedTimes=mProcessStats.getLastCpuSpeedTimes();
    final BatteryStatsImpl bstats=mBatteryStatsService.getActiveStatistics();
synchronized (bstats) {
synchronized (mPidsSelfLocked) {
        if (haveNewCpuStats) {
          if (mOnBattery) {
            int perc=bstats.startAddingCpuLocked();
            int totalUTime=0;
            int totalSTime=0;
            final int N=mProcessStats.countStats();
            for (int i=0; i < N; i++) {
              ProcessStats.Stats st=mProcessStats.getStats(i);
              if (!st.working) {
                continue;
              }
              ProcessRecord pr=mPidsSelfLocked.get(st.pid);
              int otherUTime=(st.rel_utime * perc) / 100;
              int otherSTime=(st.rel_stime * perc) / 100;
              totalUTime+=otherUTime;
              totalSTime+=otherSTime;
              if (pr != null) {
                BatteryStatsImpl.Uid.Proc ps=pr.batteryStats;
                ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                ps.addSpeedStepTimes(cpuSpeedTimes);
                pr.curCpuTime+=(st.rel_utime + st.rel_stime) * 10;
              }
 else               if (st.uid >= Process.FIRST_APPLICATION_UID) {
                BatteryStatsImpl.Uid.Proc ps=st.batteryStats;
                if (ps == null) {
                  st.batteryStats=ps=bstats.getProcessStatsLocked(st.uid,""String_Node_Str"");
                }
                ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                ps.addSpeedStepTimes(cpuSpeedTimes);
                pr.curCpuTime+=(st.rel_utime + st.rel_stime) * 10;
              }
 else {
                BatteryStatsImpl.Uid.Proc ps=bstats.getProcessStatsLocked(st.name,st.pid);
                if (ps != null) {
                  ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                  ps.addSpeedStepTimes(cpuSpeedTimes);
                }
              }
            }
            bstats.finishAddingCpuLocked(perc,totalUTime,totalSTime,cpuSpeedTimes);
          }
        }
      }
      if (mLastWriteTime < (now - BATTERY_STATS_TIME)) {
        mLastWriteTime=now;
        mBatteryStatsService.getActiveStatistics().writeAsyncLocked();
      }
    }
  }
}","void updateCpuStatsNow(){
synchronized (mProcessStatsThread) {
    mProcessStatsMutexFree.set(false);
    final long now=SystemClock.uptimeMillis();
    boolean haveNewCpuStats=false;
    if (MONITOR_CPU_USAGE && mLastCpuTime.get() < (now - MONITOR_CPU_MIN_TIME)) {
      mLastCpuTime.set(now);
      haveNewCpuStats=true;
      mProcessStats.update();
      if (""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""))) {
        int user=mProcessStats.getLastUserTime();
        int system=mProcessStats.getLastSystemTime();
        int iowait=mProcessStats.getLastIoWaitTime();
        int irq=mProcessStats.getLastIrqTime();
        int softIrq=mProcessStats.getLastSoftIrqTime();
        int idle=mProcessStats.getLastIdleTime();
        int total=user + system + iowait+ irq+ softIrq+ idle;
        if (total == 0)         total=1;
        EventLog.writeEvent(EventLogTags.CPU,((user + system + iowait+ irq+ softIrq) * 100) / total,(user * 100) / total,(system * 100) / total,(iowait * 100) / total,(irq * 100) / total,(softIrq * 100) / total);
      }
    }
    long[] cpuSpeedTimes=mProcessStats.getLastCpuSpeedTimes();
    final BatteryStatsImpl bstats=mBatteryStatsService.getActiveStatistics();
synchronized (bstats) {
synchronized (mPidsSelfLocked) {
        if (haveNewCpuStats) {
          if (mOnBattery) {
            int perc=bstats.startAddingCpuLocked();
            int totalUTime=0;
            int totalSTime=0;
            final int N=mProcessStats.countStats();
            for (int i=0; i < N; i++) {
              ProcessStats.Stats st=mProcessStats.getStats(i);
              if (!st.working) {
                continue;
              }
              ProcessRecord pr=mPidsSelfLocked.get(st.pid);
              int otherUTime=(st.rel_utime * perc) / 100;
              int otherSTime=(st.rel_stime * perc) / 100;
              totalUTime+=otherUTime;
              totalSTime+=otherSTime;
              if (pr != null) {
                BatteryStatsImpl.Uid.Proc ps=pr.batteryStats;
                ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                ps.addSpeedStepTimes(cpuSpeedTimes);
                pr.curCpuTime+=(st.rel_utime + st.rel_stime) * 10;
              }
 else               if (st.uid >= Process.FIRST_APPLICATION_UID) {
                BatteryStatsImpl.Uid.Proc ps=st.batteryStats;
                if (ps == null) {
                  st.batteryStats=ps=bstats.getProcessStatsLocked(st.uid,""String_Node_Str"");
                }
                ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                ps.addSpeedStepTimes(cpuSpeedTimes);
              }
 else {
                BatteryStatsImpl.Uid.Proc ps=bstats.getProcessStatsLocked(st.name,st.pid);
                if (ps != null) {
                  ps.addCpuTimeLocked(st.rel_utime - otherUTime,st.rel_stime - otherSTime);
                  ps.addSpeedStepTimes(cpuSpeedTimes);
                }
              }
            }
            bstats.finishAddingCpuLocked(perc,totalUTime,totalSTime,cpuSpeedTimes);
          }
        }
      }
      if (mLastWriteTime < (now - BATTERY_STATS_TIME)) {
        mLastWriteTime=now;
        mBatteryStatsService.getActiveStatistics().writeAsyncLocked();
      }
    }
  }
}"
1845,"/** 
 * Updates (in a synchronized way) the periodic sync time of the specified authority id and target periodic sync
 */
public void setPeriodicSyncTime(int authorityId,Pair<Bundle,Long> targetPeriodicSync,long when){
synchronized (mAuthorities) {
    final AuthorityInfo authority=mAuthorities.get(authorityId);
    for (int i=0; i < authority.periodicSyncs.size(); i++) {
      Pair<Bundle,Long> periodicSync=authority.periodicSyncs.get(i);
      if (periodicSync.first == targetPeriodicSync.first && periodicSync.second == targetPeriodicSync.second) {
        mSyncStatus.get(authorityId).setPeriodicSyncTime(i,when);
        break;
      }
    }
  }
}","/** 
 * Updates (in a synchronized way) the periodic sync time of the specified authority id and target periodic sync
 */
public void setPeriodicSyncTime(int authorityId,Pair<Bundle,Long> targetPeriodicSync,long when){
  boolean found=false;
  final AuthorityInfo authorityInfo;
synchronized (mAuthorities) {
    authorityInfo=mAuthorities.get(authorityId);
    for (int i=0; i < authorityInfo.periodicSyncs.size(); i++) {
      Pair<Bundle,Long> periodicSync=authorityInfo.periodicSyncs.get(i);
      if (PeriodicSync.syncExtrasEquals(periodicSync.first,targetPeriodicSync.first) && periodicSync.second == targetPeriodicSync.second) {
        mSyncStatus.get(authorityId).setPeriodicSyncTime(i,when);
        found=true;
        break;
      }
    }
  }
  if (!found) {
    Log.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + authorityInfo.authority);
  }
}"
1846,"/** 
 * Updates (in a synchronized way) the periodic sync time of the specified authority id and target periodic sync
 */
public void setPeriodicSyncTime(int authorityId,Pair<Bundle,Long> targetPeriodicSync,long when){
synchronized (mAuthorities) {
    final AuthorityInfo authority=mAuthorities.get(authorityId);
    for (int i=0; i < authority.periodicSyncs.size(); i++) {
      Pair<Bundle,Long> periodicSync=authority.periodicSyncs.get(i);
      if (periodicSync.first == targetPeriodicSync.first && periodicSync.second == targetPeriodicSync.second) {
        mSyncStatus.get(authorityId).setPeriodicSyncTime(i,when);
        break;
      }
    }
  }
}","/** 
 * Updates (in a synchronized way) the periodic sync time of the specified authority id and target periodic sync
 */
public void setPeriodicSyncTime(int authorityId,Pair<Bundle,Long> targetPeriodicSync,long when){
  boolean found=false;
  final AuthorityInfo authorityInfo;
synchronized (mAuthorities) {
    authorityInfo=mAuthorities.get(authorityId);
    for (int i=0; i < authorityInfo.periodicSyncs.size(); i++) {
      Pair<Bundle,Long> periodicSync=authorityInfo.periodicSyncs.get(i);
      if (PeriodicSync.syncExtrasEquals(periodicSync.first,targetPeriodicSync.first) && periodicSync.second == targetPeriodicSync.second) {
        mSyncStatus.get(authorityId).setPeriodicSyncTime(i,when);
        found=true;
        break;
      }
    }
  }
  if (!found) {
    Log.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + authorityInfo.authority);
  }
}"
1847,"/** 
 * Updates (in a synchronized way) the periodic sync time of the specified authority id and target periodic sync
 */
public void setPeriodicSyncTime(int authorityId,Pair<Bundle,Long> targetPeriodicSync,long when){
synchronized (mAuthorities) {
    final AuthorityInfo authority=mAuthorities.get(authorityId);
    for (int i=0; i < authority.periodicSyncs.size(); i++) {
      Pair<Bundle,Long> periodicSync=authority.periodicSyncs.get(i);
      if (periodicSync.first == targetPeriodicSync.first && periodicSync.second == targetPeriodicSync.second) {
        mSyncStatus.get(authorityId).setPeriodicSyncTime(i,when);
        break;
      }
    }
  }
}","/** 
 * Updates (in a synchronized way) the periodic sync time of the specified authority id and target periodic sync
 */
public void setPeriodicSyncTime(int authorityId,Pair<Bundle,Long> targetPeriodicSync,long when){
  boolean found=false;
  final AuthorityInfo authorityInfo;
synchronized (mAuthorities) {
    authorityInfo=mAuthorities.get(authorityId);
    for (int i=0; i < authorityInfo.periodicSyncs.size(); i++) {
      Pair<Bundle,Long> periodicSync=authorityInfo.periodicSyncs.get(i);
      if (PeriodicSync.syncExtrasEquals(periodicSync.first,targetPeriodicSync.first) && periodicSync.second == targetPeriodicSync.second) {
        mSyncStatus.get(authorityId).setPeriodicSyncTime(i,when);
        found=true;
        break;
      }
    }
  }
  if (!found) {
    Log.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + authorityInfo.authority);
  }
}"
1848,"public void setLockScreenShown(boolean shown){
  if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.DEVICE_POWER);
  }
synchronized (this) {
    mLockScreenShown=shown;
    comeOutOfSleepIfNeededLocked();
  }
}","public void setLockScreenShown(boolean shown){
  if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.DEVICE_POWER);
  }
synchronized (this) {
    long ident=Binder.clearCallingIdentity();
    try {
      mLockScreenShown=shown;
      comeOutOfSleepIfNeededLocked();
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
  }
}"
1849,"public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  if (persistent) {
    final ContentResolver resolver=mContext.getContentResolver();
    Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
    Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
  }
synchronized (this) {
    if (!persistent) {
      mOrigDebugApp=mDebugApp;
      mOrigWaitForDebugger=mWaitForDebugger;
    }
    mDebugApp=packageName;
    mWaitForDebugger=waitForDebugger;
    mDebugTransient=!persistent;
    if (packageName != null) {
      final long origId=Binder.clearCallingIdentity();
      forceStopPackageLocked(packageName,-1,false,false,true,true,UserHandle.USER_ALL,""String_Node_Str"");
      Binder.restoreCallingIdentity(origId);
    }
  }
}","public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    if (persistent) {
      final ContentResolver resolver=mContext.getContentResolver();
      Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
      Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
    }
synchronized (this) {
      if (!persistent) {
        mOrigDebugApp=mDebugApp;
        mOrigWaitForDebugger=mWaitForDebugger;
      }
      mDebugApp=packageName;
      mWaitForDebugger=waitForDebugger;
      mDebugTransient=!persistent;
      if (packageName != null) {
        forceStopPackageLocked(packageName,-1,false,false,true,true,UserHandle.USER_ALL,""String_Node_Str"");
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
1850,"public void setLockScreenShown(boolean shown){
  if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.DEVICE_POWER);
  }
synchronized (this) {
    mLockScreenShown=shown;
    comeOutOfSleepIfNeededLocked();
  }
}","public void setLockScreenShown(boolean shown){
  if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.DEVICE_POWER);
  }
synchronized (this) {
    long ident=Binder.clearCallingIdentity();
    try {
      mLockScreenShown=shown;
      comeOutOfSleepIfNeededLocked();
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
  }
}"
1851,"public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  if (persistent) {
    final ContentResolver resolver=mContext.getContentResolver();
    Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
    Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
  }
synchronized (this) {
    if (!persistent) {
      mOrigDebugApp=mDebugApp;
      mOrigWaitForDebugger=mWaitForDebugger;
    }
    mDebugApp=packageName;
    mWaitForDebugger=waitForDebugger;
    mDebugTransient=!persistent;
    if (packageName != null) {
      final long origId=Binder.clearCallingIdentity();
      forceStopPackageLocked(packageName,-1,false,false,true,true,UserHandle.USER_ALL,""String_Node_Str"");
      Binder.restoreCallingIdentity(origId);
    }
  }
}","public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    if (persistent) {
      final ContentResolver resolver=mContext.getContentResolver();
      Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
      Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
    }
synchronized (this) {
      if (!persistent) {
        mOrigDebugApp=mDebugApp;
        mOrigWaitForDebugger=mWaitForDebugger;
      }
      mDebugApp=packageName;
      mWaitForDebugger=waitForDebugger;
      mDebugTransient=!persistent;
      if (packageName != null) {
        forceStopPackageLocked(packageName,-1,false,false,true,true,UserHandle.USER_ALL,""String_Node_Str"");
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
1852,"public void setLockScreenShown(boolean shown){
  if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.DEVICE_POWER);
  }
synchronized (this) {
    mLockScreenShown=shown;
    comeOutOfSleepIfNeededLocked();
  }
}","public void setLockScreenShown(boolean shown){
  if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.DEVICE_POWER);
  }
synchronized (this) {
    long ident=Binder.clearCallingIdentity();
    try {
      mLockScreenShown=shown;
      comeOutOfSleepIfNeededLocked();
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
  }
}"
1853,"public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  if (persistent) {
    final ContentResolver resolver=mContext.getContentResolver();
    Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
    Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
  }
synchronized (this) {
    if (!persistent) {
      mOrigDebugApp=mDebugApp;
      mOrigWaitForDebugger=mWaitForDebugger;
    }
    mDebugApp=packageName;
    mWaitForDebugger=waitForDebugger;
    mDebugTransient=!persistent;
    if (packageName != null) {
      final long origId=Binder.clearCallingIdentity();
      forceStopPackageLocked(packageName,-1,false,false,true,true,UserHandle.USER_ALL,""String_Node_Str"");
      Binder.restoreCallingIdentity(origId);
    }
  }
}","public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    if (persistent) {
      final ContentResolver resolver=mContext.getContentResolver();
      Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
      Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
    }
synchronized (this) {
      if (!persistent) {
        mOrigDebugApp=mDebugApp;
        mOrigWaitForDebugger=mWaitForDebugger;
      }
      mDebugApp=packageName;
      mWaitForDebugger=waitForDebugger;
      mDebugTransient=!persistent;
      if (packageName != null) {
        forceStopPackageLocked(packageName,-1,false,false,true,true,UserHandle.USER_ALL,""String_Node_Str"");
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
1854,"public void removePeriodicSyncTime(int index){
  ensurePeriodicSyncTimeSize(index);
  periodicSyncTimes.remove(index);
}","public void removePeriodicSyncTime(int index){
  if (periodicSyncTimes != null && index < periodicSyncTimes.size()) {
    periodicSyncTimes.remove(index);
  }
}"
1855,"public SyncStatusInfo(Parcel parcel){
  int version=parcel.readInt();
  if (version != VERSION && version != 1) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + version);
  }
  authorityId=parcel.readInt();
  totalElapsedTime=parcel.readLong();
  numSyncs=parcel.readInt();
  numSourcePoll=parcel.readInt();
  numSourceServer=parcel.readInt();
  numSourceLocal=parcel.readInt();
  numSourceUser=parcel.readInt();
  lastSuccessTime=parcel.readLong();
  lastSuccessSource=parcel.readInt();
  lastFailureTime=parcel.readLong();
  lastFailureSource=parcel.readInt();
  lastFailureMesg=parcel.readString();
  initialFailureTime=parcel.readLong();
  pending=parcel.readInt() != 0;
  initialize=parcel.readInt() != 0;
  if (version == 1) {
    periodicSyncTimes=null;
  }
 else {
    int N=parcel.readInt();
    if (N < 0) {
      periodicSyncTimes=null;
    }
 else {
      periodicSyncTimes=new ArrayList<Long>();
      for (int i=0; i < N; i++) {
        periodicSyncTimes.add(parcel.readLong());
      }
    }
  }
}","public SyncStatusInfo(SyncStatusInfo other){
  authorityId=other.authorityId;
  totalElapsedTime=other.totalElapsedTime;
  numSyncs=other.numSyncs;
  numSourcePoll=other.numSourcePoll;
  numSourceServer=other.numSourceServer;
  numSourceLocal=other.numSourceLocal;
  numSourceUser=other.numSourceUser;
  numSourcePeriodic=other.numSourcePeriodic;
  lastSuccessTime=other.lastSuccessTime;
  lastSuccessSource=other.lastSuccessSource;
  lastFailureTime=other.lastFailureTime;
  lastFailureSource=other.lastFailureSource;
  lastFailureMesg=other.lastFailureMesg;
  initialFailureTime=other.initialFailureTime;
  pending=other.pending;
  initialize=other.initialize;
  if (other.periodicSyncTimes != null) {
    periodicSyncTimes=new ArrayList<Long>(other.periodicSyncTimes);
  }
}"
1856,"public long getPeriodicSyncTime(int index){
  if (periodicSyncTimes == null || periodicSyncTimes.size() < (index + 1)) {
    return 0;
  }
  return periodicSyncTimes.get(index);
}","public long getPeriodicSyncTime(int index){
  if (periodicSyncTimes != null && index < periodicSyncTimes.size()) {
    return periodicSyncTimes.get(index);
  }
 else {
    return 0;
  }
}"
1857,"protected void dumpSyncState(PrintWriter pw){
  pw.print(""String_Node_Str"");
  pw.println(mDataConnectionIsConnected);
  pw.print(""String_Node_Str"");
  List<UserInfo> users=getAllUsers();
  if (users != null) {
    for (    UserInfo user : users) {
      pw.print(""String_Node_Str"" + user.id + ""String_Node_Str""+ mSyncStorageEngine.getMasterSyncAutomatically(user.id)+ ""String_Node_Str"");
    }
    pw.println();
  }
  pw.print(""String_Node_Str"");
  pw.println(mStorageIsLow);
  final AccountAndUser[] accounts=AccountManagerService.getSingleton().getAllAccounts();
  pw.print(""String_Node_Str"");
  if (accounts != INITIAL_ACCOUNTS_ARRAY) {
    pw.println(accounts.length);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  final long now=SystemClock.elapsedRealtime();
  pw.print(""String_Node_Str"");
  pw.print(now);
  pw.println(""String_Node_Str"" + formatTime(System.currentTimeMillis()) + ""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(DateUtils.formatElapsedTime(mSyncRandomOffsetMillis / 1000));
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(DateUtils.formatElapsedTime(now / 1000));
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(DateUtils.formatElapsedTime(mSyncHandler.mSyncTimeTracker.timeSpentSyncing() / 1000));
  pw.print(""String_Node_Str"");
  pw.print(mSyncHandler.mSyncTimeTracker.mLastWasSyncing ? ""String_Node_Str"" : ""String_Node_Str"");
  pw.println(""String_Node_Str"");
  if (mSyncHandler.mAlarmScheduleTime != null) {
    pw.print(""String_Node_Str"");
    pw.print(mSyncHandler.mAlarmScheduleTime);
    pw.print(""String_Node_Str"");
    pw.print(DateUtils.formatElapsedTime((mSyncHandler.mAlarmScheduleTime - now) / 1000));
    pw.println(""String_Node_Str"");
  }
 else {
    pw.println(""String_Node_Str"");
  }
  pw.print(""String_Node_Str"");
  final StringBuilder sb=new StringBuilder();
  mSyncHandler.mSyncNotificationInfo.toString(sb);
  pw.println(sb.toString());
  pw.println();
  pw.println(""String_Node_Str"" + mActiveSyncContexts.size());
  final PackageManager pm=mContext.getPackageManager();
  for (  SyncManager.ActiveSyncContext activeSyncContext : mActiveSyncContexts) {
    final long durationInSeconds=(now - activeSyncContext.mStartTime) / 1000;
    pw.print(""String_Node_Str"");
    pw.print(DateUtils.formatElapsedTime(durationInSeconds));
    pw.print(""String_Node_Str"");
    pw.print(activeSyncContext.mSyncOperation.dump(pm,false));
    pw.println();
  }
synchronized (mSyncQueue) {
    sb.setLength(0);
    mSyncQueue.dump(sb);
  }
  pw.println();
  pw.print(sb.toString());
  pw.println();
  pw.println(""String_Node_Str"");
  for (  AccountAndUser account : accounts) {
    pw.printf(""String_Node_Str"",account.account.name,account.userId,account.account.type);
    pw.println(""String_Node_Str"");
    final PrintTable table=new PrintTable(13);
    table.set(0,0,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    final List<RegisteredServicesCache.ServiceInfo<SyncAdapterType>> sorted=Lists.newArrayList();
    sorted.addAll(mSyncAdapters.getAllServices(account.userId));
    Collections.sort(sorted,new Comparator<RegisteredServicesCache.ServiceInfo<SyncAdapterType>>(){
      @Override public int compare(      RegisteredServicesCache.ServiceInfo<SyncAdapterType> lhs,      RegisteredServicesCache.ServiceInfo<SyncAdapterType> rhs){
        return lhs.type.authority.compareTo(rhs.type.authority);
      }
    }
);
    for (    RegisteredServicesCache.ServiceInfo<SyncAdapterType> syncAdapterType : sorted) {
      if (!syncAdapterType.type.accountType.equals(account.account.type)) {
        continue;
      }
      int row=table.getNumRows();
      SyncStorageEngine.AuthorityInfo settings=mSyncStorageEngine.getOrCreateAuthority(account.account,account.userId,syncAdapterType.type.authority);
      SyncStatusInfo status=mSyncStorageEngine.getOrCreateSyncStatus(settings);
      String authority=settings.authority;
      if (authority.length() > 50) {
        authority=authority.substring(authority.length() - 50);
      }
      table.set(row,0,authority,settings.syncable,settings.enabled);
      table.set(row,4,status.numSourceLocal,status.numSourcePoll,status.numSourcePeriodic,status.numSourceServer,status.numSourceUser,status.numSyncs,DateUtils.formatElapsedTime(status.totalElapsedTime / 1000));
      for (int i=0; i < settings.periodicSyncs.size(); i++) {
        final Pair<Bundle,Long> pair=settings.periodicSyncs.get(0);
        final String period=String.valueOf(pair.second);
        final String extras=pair.first.size() > 0 ? pair.first.toString() : ""String_Node_Str"";
        final String next=formatTime(status.getPeriodicSyncTime(0) + pair.second * 1000);
        table.set(row + i * 2,12,period + extras);
        table.set(row + i * 2 + 1,12,next);
      }
      int row1=row;
      if (settings.delayUntil > now) {
        table.set(row1++,12,""String_Node_Str"" + (settings.delayUntil - now) / 1000);
        if (settings.backoffTime > now) {
          table.set(row1++,12,""String_Node_Str"" + (settings.backoffTime - now) / 1000);
          table.set(row1++,12,settings.backoffDelay / 1000);
        }
      }
      if (status.lastSuccessTime != 0) {
        table.set(row1++,11,SyncStorageEngine.SOURCES[status.lastSuccessSource] + ""String_Node_Str"" + ""String_Node_Str"");
        table.set(row1++,11,formatTime(status.lastSuccessTime));
      }
      if (status.lastFailureTime != 0) {
        table.set(row1++,11,SyncStorageEngine.SOURCES[status.lastFailureSource] + ""String_Node_Str"" + ""String_Node_Str"");
        table.set(row1++,11,formatTime(status.lastFailureTime));
        table.set(row1++,11,status.lastFailureMesg);
      }
    }
    table.writeTo(pw);
  }
}","protected void dumpSyncState(PrintWriter pw){
  pw.print(""String_Node_Str"");
  pw.println(mDataConnectionIsConnected);
  pw.print(""String_Node_Str"");
  List<UserInfo> users=getAllUsers();
  if (users != null) {
    for (    UserInfo user : users) {
      pw.print(""String_Node_Str"" + user.id + ""String_Node_Str""+ mSyncStorageEngine.getMasterSyncAutomatically(user.id)+ ""String_Node_Str"");
    }
    pw.println();
  }
  pw.print(""String_Node_Str"");
  pw.println(mStorageIsLow);
  final AccountAndUser[] accounts=AccountManagerService.getSingleton().getAllAccounts();
  pw.print(""String_Node_Str"");
  if (accounts != INITIAL_ACCOUNTS_ARRAY) {
    pw.println(accounts.length);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  final long now=SystemClock.elapsedRealtime();
  pw.print(""String_Node_Str"");
  pw.print(now);
  pw.println(""String_Node_Str"" + formatTime(System.currentTimeMillis()) + ""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(DateUtils.formatElapsedTime(mSyncRandomOffsetMillis / 1000));
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(DateUtils.formatElapsedTime(now / 1000));
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(DateUtils.formatElapsedTime(mSyncHandler.mSyncTimeTracker.timeSpentSyncing() / 1000));
  pw.print(""String_Node_Str"");
  pw.print(mSyncHandler.mSyncTimeTracker.mLastWasSyncing ? ""String_Node_Str"" : ""String_Node_Str"");
  pw.println(""String_Node_Str"");
  if (mSyncHandler.mAlarmScheduleTime != null) {
    pw.print(""String_Node_Str"");
    pw.print(mSyncHandler.mAlarmScheduleTime);
    pw.print(""String_Node_Str"");
    pw.print(DateUtils.formatElapsedTime((mSyncHandler.mAlarmScheduleTime - now) / 1000));
    pw.println(""String_Node_Str"");
  }
 else {
    pw.println(""String_Node_Str"");
  }
  pw.print(""String_Node_Str"");
  final StringBuilder sb=new StringBuilder();
  mSyncHandler.mSyncNotificationInfo.toString(sb);
  pw.println(sb.toString());
  pw.println();
  pw.println(""String_Node_Str"" + mActiveSyncContexts.size());
  final PackageManager pm=mContext.getPackageManager();
  for (  SyncManager.ActiveSyncContext activeSyncContext : mActiveSyncContexts) {
    final long durationInSeconds=(now - activeSyncContext.mStartTime) / 1000;
    pw.print(""String_Node_Str"");
    pw.print(DateUtils.formatElapsedTime(durationInSeconds));
    pw.print(""String_Node_Str"");
    pw.print(activeSyncContext.mSyncOperation.dump(pm,false));
    pw.println();
  }
synchronized (mSyncQueue) {
    sb.setLength(0);
    mSyncQueue.dump(sb);
  }
  pw.println();
  pw.print(sb.toString());
  pw.println();
  pw.println(""String_Node_Str"");
  for (  AccountAndUser account : accounts) {
    pw.printf(""String_Node_Str"",account.account.name,account.userId,account.account.type);
    pw.println(""String_Node_Str"");
    final PrintTable table=new PrintTable(13);
    table.set(0,0,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    final List<RegisteredServicesCache.ServiceInfo<SyncAdapterType>> sorted=Lists.newArrayList();
    sorted.addAll(mSyncAdapters.getAllServices(account.userId));
    Collections.sort(sorted,new Comparator<RegisteredServicesCache.ServiceInfo<SyncAdapterType>>(){
      @Override public int compare(      RegisteredServicesCache.ServiceInfo<SyncAdapterType> lhs,      RegisteredServicesCache.ServiceInfo<SyncAdapterType> rhs){
        return lhs.type.authority.compareTo(rhs.type.authority);
      }
    }
);
    for (    RegisteredServicesCache.ServiceInfo<SyncAdapterType> syncAdapterType : sorted) {
      if (!syncAdapterType.type.accountType.equals(account.account.type)) {
        continue;
      }
      int row=table.getNumRows();
      Pair<AuthorityInfo,SyncStatusInfo> syncAuthoritySyncStatus=mSyncStorageEngine.getCopyOfAuthorityWithSyncStatus(account.account,account.userId,syncAdapterType.type.authority);
      SyncStorageEngine.AuthorityInfo settings=syncAuthoritySyncStatus.first;
      SyncStatusInfo status=syncAuthoritySyncStatus.second;
      String authority=settings.authority;
      if (authority.length() > 50) {
        authority=authority.substring(authority.length() - 50);
      }
      table.set(row,0,authority,settings.syncable,settings.enabled);
      table.set(row,4,status.numSourceLocal,status.numSourcePoll,status.numSourcePeriodic,status.numSourceServer,status.numSourceUser,status.numSyncs,DateUtils.formatElapsedTime(status.totalElapsedTime / 1000));
      for (int i=0; i < settings.periodicSyncs.size(); i++) {
        final Pair<Bundle,Long> pair=settings.periodicSyncs.get(i);
        final String period=String.valueOf(pair.second);
        final String extras=pair.first.size() > 0 ? pair.first.toString() : ""String_Node_Str"";
        final String next=formatTime(status.getPeriodicSyncTime(i) + pair.second * 1000);
        table.set(row + i * 2,12,period + extras);
        table.set(row + i * 2 + 1,12,next);
      }
      int row1=row;
      if (settings.delayUntil > now) {
        table.set(row1++,12,""String_Node_Str"" + (settings.delayUntil - now) / 1000);
        if (settings.backoffTime > now) {
          table.set(row1++,12,""String_Node_Str"" + (settings.backoffTime - now) / 1000);
          table.set(row1++,12,settings.backoffDelay / 1000);
        }
      }
      if (status.lastSuccessTime != 0) {
        table.set(row1++,11,SyncStorageEngine.SOURCES[status.lastSuccessSource] + ""String_Node_Str"" + ""String_Node_Str"");
        table.set(row1++,11,formatTime(status.lastSuccessTime));
      }
      if (status.lastFailureTime != 0) {
        table.set(row1++,11,SyncStorageEngine.SOURCES[status.lastFailureSource] + ""String_Node_Str"" + ""String_Node_Str"");
        table.set(row1++,11,formatTime(status.lastFailureTime));
        table.set(row1++,11,status.lastFailureMesg);
      }
    }
    table.writeTo(pw);
  }
}"
1858,"/** 
 * Turn any periodic sync operations that are ready to run into pending sync operations.
 * @return the desired start time of the earliest future  periodic sync operation,in milliseconds since boot
 */
private long scheduleReadyPeriodicSyncs(){
  final boolean backgroundDataUsageAllowed=getConnectivityManager().getBackgroundDataSetting();
  long earliestFuturePollTime=Long.MAX_VALUE;
  if (!backgroundDataUsageAllowed) {
    return earliestFuturePollTime;
  }
  AccountAndUser[] accounts=mRunningAccounts;
  final long nowAbsolute=System.currentTimeMillis();
  final long shiftedNowAbsolute=(0 < nowAbsolute - mSyncRandomOffsetMillis) ? (nowAbsolute - mSyncRandomOffsetMillis) : 0;
  ArrayList<SyncStorageEngine.AuthorityInfo> infos=mSyncStorageEngine.getAuthorities();
  for (  SyncStorageEngine.AuthorityInfo info : infos) {
    if (!containsAccountAndUser(accounts,info.account,info.userId)) {
      continue;
    }
    if (!mSyncStorageEngine.getMasterSyncAutomatically(info.userId) || !mSyncStorageEngine.getSyncAutomatically(info.account,info.userId,info.authority)) {
      continue;
    }
    if (getIsSyncable(info.account,info.userId,info.authority) == 0) {
      continue;
    }
    SyncStatusInfo status=mSyncStorageEngine.getOrCreateSyncStatus(info);
    for (int i=0, N=info.periodicSyncs.size(); i < N; i++) {
      final Bundle extras=info.periodicSyncs.get(i).first;
      final Long periodInMillis=info.periodicSyncs.get(i).second * 1000;
      if (periodInMillis <= 0) {
        continue;
      }
      final long lastPollTimeAbsolute=status.getPeriodicSyncTime(i);
      long remainingMillis=periodInMillis - (shiftedNowAbsolute % periodInMillis);
      if (remainingMillis == periodInMillis || lastPollTimeAbsolute > nowAbsolute || (nowAbsolute - lastPollTimeAbsolute >= periodInMillis)) {
        final Pair<Long,Long> backoff=mSyncStorageEngine.getBackoff(info.account,info.userId,info.authority);
        final RegisteredServicesCache.ServiceInfo<SyncAdapterType> syncAdapterInfo;
        syncAdapterInfo=mSyncAdapters.getServiceInfo(SyncAdapterType.newKey(info.authority,info.account.type),info.userId);
        if (syncAdapterInfo == null) {
          continue;
        }
        scheduleSyncOperation(new SyncOperation(info.account,info.userId,SyncOperation.REASON_PERIODIC,SyncStorageEngine.SOURCE_PERIODIC,info.authority,extras,0,backoff != null ? backoff.first : 0,mSyncStorageEngine.getDelayUntilTime(info.account,info.userId,info.authority),syncAdapterInfo.type.allowParallelSyncs()));
        status.setPeriodicSyncTime(i,nowAbsolute);
      }
      final long nextPollTimeAbsolute=nowAbsolute + remainingMillis;
      if (nextPollTimeAbsolute < earliestFuturePollTime) {
        earliestFuturePollTime=nextPollTimeAbsolute;
      }
    }
  }
  if (earliestFuturePollTime == Long.MAX_VALUE) {
    return Long.MAX_VALUE;
  }
  return SystemClock.elapsedRealtime() + ((earliestFuturePollTime < nowAbsolute) ? 0 : (earliestFuturePollTime - nowAbsolute));
}","/** 
 * Turn any periodic sync operations that are ready to run into pending sync operations.
 * @return the desired start time of the earliest future  periodic sync operation,in milliseconds since boot
 */
private long scheduleReadyPeriodicSyncs(){
  final boolean backgroundDataUsageAllowed=getConnectivityManager().getBackgroundDataSetting();
  long earliestFuturePollTime=Long.MAX_VALUE;
  if (!backgroundDataUsageAllowed) {
    return earliestFuturePollTime;
  }
  AccountAndUser[] accounts=mRunningAccounts;
  final long nowAbsolute=System.currentTimeMillis();
  final long shiftedNowAbsolute=(0 < nowAbsolute - mSyncRandomOffsetMillis) ? (nowAbsolute - mSyncRandomOffsetMillis) : 0;
  ArrayList<Pair<AuthorityInfo,SyncStatusInfo>> infos=mSyncStorageEngine.getCopyOfAllAuthoritiesWithSyncStatus();
  for (  Pair<AuthorityInfo,SyncStatusInfo> info : infos) {
    final AuthorityInfo authorityInfo=info.first;
    final SyncStatusInfo status=info.second;
    if (!containsAccountAndUser(accounts,authorityInfo.account,authorityInfo.userId)) {
      continue;
    }
    if (!mSyncStorageEngine.getMasterSyncAutomatically(authorityInfo.userId) || !mSyncStorageEngine.getSyncAutomatically(authorityInfo.account,authorityInfo.userId,authorityInfo.authority)) {
      continue;
    }
    if (getIsSyncable(authorityInfo.account,authorityInfo.userId,authorityInfo.authority) == 0) {
      continue;
    }
    for (int i=0, N=authorityInfo.periodicSyncs.size(); i < N; i++) {
      final Bundle extras=authorityInfo.periodicSyncs.get(i).first;
      final Long periodInMillis=authorityInfo.periodicSyncs.get(i).second * 1000;
      if (periodInMillis <= 0) {
        continue;
      }
      final long lastPollTimeAbsolute=status.getPeriodicSyncTime(i);
      long remainingMillis=periodInMillis - (shiftedNowAbsolute % periodInMillis);
      if (remainingMillis == periodInMillis || lastPollTimeAbsolute > nowAbsolute || (nowAbsolute - lastPollTimeAbsolute >= periodInMillis)) {
        final Pair<Long,Long> backoff=mSyncStorageEngine.getBackoff(authorityInfo.account,authorityInfo.userId,authorityInfo.authority);
        final RegisteredServicesCache.ServiceInfo<SyncAdapterType> syncAdapterInfo;
        syncAdapterInfo=mSyncAdapters.getServiceInfo(SyncAdapterType.newKey(authorityInfo.authority,authorityInfo.account.type),authorityInfo.userId);
        if (syncAdapterInfo == null) {
          continue;
        }
        scheduleSyncOperation(new SyncOperation(authorityInfo.account,authorityInfo.userId,SyncOperation.REASON_PERIODIC,SyncStorageEngine.SOURCE_PERIODIC,authorityInfo.authority,extras,0,backoff != null ? backoff.first : 0,mSyncStorageEngine.getDelayUntilTime(authorityInfo.account,authorityInfo.userId,authorityInfo.authority),syncAdapterInfo.type.allowParallelSyncs()));
        mSyncStorageEngine.setPeriodicSyncTime(authorityInfo.ident,authorityInfo.periodicSyncs.get(i),nowAbsolute);
      }
      final long nextPollTimeAbsolute=nowAbsolute + remainingMillis;
      if (nextPollTimeAbsolute < earliestFuturePollTime) {
        earliestFuturePollTime=nextPollTimeAbsolute;
      }
    }
  }
  if (earliestFuturePollTime == Long.MAX_VALUE) {
    return Long.MAX_VALUE;
  }
  return SystemClock.elapsedRealtime() + ((earliestFuturePollTime < nowAbsolute) ? 0 : (earliestFuturePollTime - nowAbsolute));
}"
1859,"public void removePeriodicSyncTime(int index){
  ensurePeriodicSyncTimeSize(index);
  periodicSyncTimes.remove(index);
}","public void removePeriodicSyncTime(int index){
  if (periodicSyncTimes != null && index < periodicSyncTimes.size()) {
    periodicSyncTimes.remove(index);
  }
}"
1860,"public SyncStatusInfo(Parcel parcel){
  int version=parcel.readInt();
  if (version != VERSION && version != 1) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + version);
  }
  authorityId=parcel.readInt();
  totalElapsedTime=parcel.readLong();
  numSyncs=parcel.readInt();
  numSourcePoll=parcel.readInt();
  numSourceServer=parcel.readInt();
  numSourceLocal=parcel.readInt();
  numSourceUser=parcel.readInt();
  lastSuccessTime=parcel.readLong();
  lastSuccessSource=parcel.readInt();
  lastFailureTime=parcel.readLong();
  lastFailureSource=parcel.readInt();
  lastFailureMesg=parcel.readString();
  initialFailureTime=parcel.readLong();
  pending=parcel.readInt() != 0;
  initialize=parcel.readInt() != 0;
  if (version == 1) {
    periodicSyncTimes=null;
  }
 else {
    int N=parcel.readInt();
    if (N < 0) {
      periodicSyncTimes=null;
    }
 else {
      periodicSyncTimes=new ArrayList<Long>();
      for (int i=0; i < N; i++) {
        periodicSyncTimes.add(parcel.readLong());
      }
    }
  }
}","public SyncStatusInfo(SyncStatusInfo other){
  authorityId=other.authorityId;
  totalElapsedTime=other.totalElapsedTime;
  numSyncs=other.numSyncs;
  numSourcePoll=other.numSourcePoll;
  numSourceServer=other.numSourceServer;
  numSourceLocal=other.numSourceLocal;
  numSourceUser=other.numSourceUser;
  numSourcePeriodic=other.numSourcePeriodic;
  lastSuccessTime=other.lastSuccessTime;
  lastSuccessSource=other.lastSuccessSource;
  lastFailureTime=other.lastFailureTime;
  lastFailureSource=other.lastFailureSource;
  lastFailureMesg=other.lastFailureMesg;
  initialFailureTime=other.initialFailureTime;
  pending=other.pending;
  initialize=other.initialize;
  if (other.periodicSyncTimes != null) {
    periodicSyncTimes=new ArrayList<Long>(other.periodicSyncTimes);
  }
}"
1861,"public long getPeriodicSyncTime(int index){
  if (periodicSyncTimes == null || periodicSyncTimes.size() < (index + 1)) {
    return 0;
  }
  return periodicSyncTimes.get(index);
}","public long getPeriodicSyncTime(int index){
  if (periodicSyncTimes != null && index < periodicSyncTimes.size()) {
    return periodicSyncTimes.get(index);
  }
 else {
    return 0;
  }
}"
1862,"protected void dumpSyncState(PrintWriter pw){
  pw.print(""String_Node_Str"");
  pw.println(mDataConnectionIsConnected);
  pw.print(""String_Node_Str"");
  List<UserInfo> users=getAllUsers();
  if (users != null) {
    for (    UserInfo user : users) {
      pw.print(""String_Node_Str"" + user.id + ""String_Node_Str""+ mSyncStorageEngine.getMasterSyncAutomatically(user.id)+ ""String_Node_Str"");
    }
    pw.println();
  }
  pw.print(""String_Node_Str"");
  pw.println(mStorageIsLow);
  final AccountAndUser[] accounts=AccountManagerService.getSingleton().getAllAccounts();
  pw.print(""String_Node_Str"");
  if (accounts != INITIAL_ACCOUNTS_ARRAY) {
    pw.println(accounts.length);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  final long now=SystemClock.elapsedRealtime();
  pw.print(""String_Node_Str"");
  pw.print(now);
  pw.println(""String_Node_Str"" + formatTime(System.currentTimeMillis()) + ""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(DateUtils.formatElapsedTime(mSyncRandomOffsetMillis / 1000));
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(DateUtils.formatElapsedTime(now / 1000));
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(DateUtils.formatElapsedTime(mSyncHandler.mSyncTimeTracker.timeSpentSyncing() / 1000));
  pw.print(""String_Node_Str"");
  pw.print(mSyncHandler.mSyncTimeTracker.mLastWasSyncing ? ""String_Node_Str"" : ""String_Node_Str"");
  pw.println(""String_Node_Str"");
  if (mSyncHandler.mAlarmScheduleTime != null) {
    pw.print(""String_Node_Str"");
    pw.print(mSyncHandler.mAlarmScheduleTime);
    pw.print(""String_Node_Str"");
    pw.print(DateUtils.formatElapsedTime((mSyncHandler.mAlarmScheduleTime - now) / 1000));
    pw.println(""String_Node_Str"");
  }
 else {
    pw.println(""String_Node_Str"");
  }
  pw.print(""String_Node_Str"");
  final StringBuilder sb=new StringBuilder();
  mSyncHandler.mSyncNotificationInfo.toString(sb);
  pw.println(sb.toString());
  pw.println();
  pw.println(""String_Node_Str"" + mActiveSyncContexts.size());
  final PackageManager pm=mContext.getPackageManager();
  for (  SyncManager.ActiveSyncContext activeSyncContext : mActiveSyncContexts) {
    final long durationInSeconds=(now - activeSyncContext.mStartTime) / 1000;
    pw.print(""String_Node_Str"");
    pw.print(DateUtils.formatElapsedTime(durationInSeconds));
    pw.print(""String_Node_Str"");
    pw.print(activeSyncContext.mSyncOperation.dump(pm,false));
    pw.println();
  }
synchronized (mSyncQueue) {
    sb.setLength(0);
    mSyncQueue.dump(sb);
  }
  pw.println();
  pw.print(sb.toString());
  pw.println();
  pw.println(""String_Node_Str"");
  for (  AccountAndUser account : accounts) {
    pw.printf(""String_Node_Str"",account.account.name,account.userId,account.account.type);
    pw.println(""String_Node_Str"");
    final PrintTable table=new PrintTable(13);
    table.set(0,0,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    final List<RegisteredServicesCache.ServiceInfo<SyncAdapterType>> sorted=Lists.newArrayList();
    sorted.addAll(mSyncAdapters.getAllServices(account.userId));
    Collections.sort(sorted,new Comparator<RegisteredServicesCache.ServiceInfo<SyncAdapterType>>(){
      @Override public int compare(      RegisteredServicesCache.ServiceInfo<SyncAdapterType> lhs,      RegisteredServicesCache.ServiceInfo<SyncAdapterType> rhs){
        return lhs.type.authority.compareTo(rhs.type.authority);
      }
    }
);
    for (    RegisteredServicesCache.ServiceInfo<SyncAdapterType> syncAdapterType : sorted) {
      if (!syncAdapterType.type.accountType.equals(account.account.type)) {
        continue;
      }
      int row=table.getNumRows();
      SyncStorageEngine.AuthorityInfo settings=mSyncStorageEngine.getOrCreateAuthority(account.account,account.userId,syncAdapterType.type.authority);
      SyncStatusInfo status=mSyncStorageEngine.getOrCreateSyncStatus(settings);
      String authority=settings.authority;
      if (authority.length() > 50) {
        authority=authority.substring(authority.length() - 50);
      }
      table.set(row,0,authority,settings.syncable,settings.enabled);
      table.set(row,4,status.numSourceLocal,status.numSourcePoll,status.numSourcePeriodic,status.numSourceServer,status.numSourceUser,status.numSyncs,DateUtils.formatElapsedTime(status.totalElapsedTime / 1000));
      for (int i=0; i < settings.periodicSyncs.size(); i++) {
        final Pair<Bundle,Long> pair=settings.periodicSyncs.get(0);
        final String period=String.valueOf(pair.second);
        final String extras=pair.first.size() > 0 ? pair.first.toString() : ""String_Node_Str"";
        final String next=formatTime(status.getPeriodicSyncTime(0) + pair.second * 1000);
        table.set(row + i * 2,12,period + extras);
        table.set(row + i * 2 + 1,12,next);
      }
      int row1=row;
      if (settings.delayUntil > now) {
        table.set(row1++,12,""String_Node_Str"" + (settings.delayUntil - now) / 1000);
        if (settings.backoffTime > now) {
          table.set(row1++,12,""String_Node_Str"" + (settings.backoffTime - now) / 1000);
          table.set(row1++,12,settings.backoffDelay / 1000);
        }
      }
      if (status.lastSuccessTime != 0) {
        table.set(row1++,11,SyncStorageEngine.SOURCES[status.lastSuccessSource] + ""String_Node_Str"" + ""String_Node_Str"");
        table.set(row1++,11,formatTime(status.lastSuccessTime));
      }
      if (status.lastFailureTime != 0) {
        table.set(row1++,11,SyncStorageEngine.SOURCES[status.lastFailureSource] + ""String_Node_Str"" + ""String_Node_Str"");
        table.set(row1++,11,formatTime(status.lastFailureTime));
        table.set(row1++,11,status.lastFailureMesg);
      }
    }
    table.writeTo(pw);
  }
}","protected void dumpSyncState(PrintWriter pw){
  pw.print(""String_Node_Str"");
  pw.println(mDataConnectionIsConnected);
  pw.print(""String_Node_Str"");
  List<UserInfo> users=getAllUsers();
  if (users != null) {
    for (    UserInfo user : users) {
      pw.print(""String_Node_Str"" + user.id + ""String_Node_Str""+ mSyncStorageEngine.getMasterSyncAutomatically(user.id)+ ""String_Node_Str"");
    }
    pw.println();
  }
  pw.print(""String_Node_Str"");
  pw.println(mStorageIsLow);
  final AccountAndUser[] accounts=AccountManagerService.getSingleton().getAllAccounts();
  pw.print(""String_Node_Str"");
  if (accounts != INITIAL_ACCOUNTS_ARRAY) {
    pw.println(accounts.length);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  final long now=SystemClock.elapsedRealtime();
  pw.print(""String_Node_Str"");
  pw.print(now);
  pw.println(""String_Node_Str"" + formatTime(System.currentTimeMillis()) + ""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(DateUtils.formatElapsedTime(mSyncRandomOffsetMillis / 1000));
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(DateUtils.formatElapsedTime(now / 1000));
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(DateUtils.formatElapsedTime(mSyncHandler.mSyncTimeTracker.timeSpentSyncing() / 1000));
  pw.print(""String_Node_Str"");
  pw.print(mSyncHandler.mSyncTimeTracker.mLastWasSyncing ? ""String_Node_Str"" : ""String_Node_Str"");
  pw.println(""String_Node_Str"");
  if (mSyncHandler.mAlarmScheduleTime != null) {
    pw.print(""String_Node_Str"");
    pw.print(mSyncHandler.mAlarmScheduleTime);
    pw.print(""String_Node_Str"");
    pw.print(DateUtils.formatElapsedTime((mSyncHandler.mAlarmScheduleTime - now) / 1000));
    pw.println(""String_Node_Str"");
  }
 else {
    pw.println(""String_Node_Str"");
  }
  pw.print(""String_Node_Str"");
  final StringBuilder sb=new StringBuilder();
  mSyncHandler.mSyncNotificationInfo.toString(sb);
  pw.println(sb.toString());
  pw.println();
  pw.println(""String_Node_Str"" + mActiveSyncContexts.size());
  final PackageManager pm=mContext.getPackageManager();
  for (  SyncManager.ActiveSyncContext activeSyncContext : mActiveSyncContexts) {
    final long durationInSeconds=(now - activeSyncContext.mStartTime) / 1000;
    pw.print(""String_Node_Str"");
    pw.print(DateUtils.formatElapsedTime(durationInSeconds));
    pw.print(""String_Node_Str"");
    pw.print(activeSyncContext.mSyncOperation.dump(pm,false));
    pw.println();
  }
synchronized (mSyncQueue) {
    sb.setLength(0);
    mSyncQueue.dump(sb);
  }
  pw.println();
  pw.print(sb.toString());
  pw.println();
  pw.println(""String_Node_Str"");
  for (  AccountAndUser account : accounts) {
    pw.printf(""String_Node_Str"",account.account.name,account.userId,account.account.type);
    pw.println(""String_Node_Str"");
    final PrintTable table=new PrintTable(13);
    table.set(0,0,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    final List<RegisteredServicesCache.ServiceInfo<SyncAdapterType>> sorted=Lists.newArrayList();
    sorted.addAll(mSyncAdapters.getAllServices(account.userId));
    Collections.sort(sorted,new Comparator<RegisteredServicesCache.ServiceInfo<SyncAdapterType>>(){
      @Override public int compare(      RegisteredServicesCache.ServiceInfo<SyncAdapterType> lhs,      RegisteredServicesCache.ServiceInfo<SyncAdapterType> rhs){
        return lhs.type.authority.compareTo(rhs.type.authority);
      }
    }
);
    for (    RegisteredServicesCache.ServiceInfo<SyncAdapterType> syncAdapterType : sorted) {
      if (!syncAdapterType.type.accountType.equals(account.account.type)) {
        continue;
      }
      int row=table.getNumRows();
      Pair<AuthorityInfo,SyncStatusInfo> syncAuthoritySyncStatus=mSyncStorageEngine.getCopyOfAuthorityWithSyncStatus(account.account,account.userId,syncAdapterType.type.authority);
      SyncStorageEngine.AuthorityInfo settings=syncAuthoritySyncStatus.first;
      SyncStatusInfo status=syncAuthoritySyncStatus.second;
      String authority=settings.authority;
      if (authority.length() > 50) {
        authority=authority.substring(authority.length() - 50);
      }
      table.set(row,0,authority,settings.syncable,settings.enabled);
      table.set(row,4,status.numSourceLocal,status.numSourcePoll,status.numSourcePeriodic,status.numSourceServer,status.numSourceUser,status.numSyncs,DateUtils.formatElapsedTime(status.totalElapsedTime / 1000));
      for (int i=0; i < settings.periodicSyncs.size(); i++) {
        final Pair<Bundle,Long> pair=settings.periodicSyncs.get(i);
        final String period=String.valueOf(pair.second);
        final String extras=pair.first.size() > 0 ? pair.first.toString() : ""String_Node_Str"";
        final String next=formatTime(status.getPeriodicSyncTime(i) + pair.second * 1000);
        table.set(row + i * 2,12,period + extras);
        table.set(row + i * 2 + 1,12,next);
      }
      int row1=row;
      if (settings.delayUntil > now) {
        table.set(row1++,12,""String_Node_Str"" + (settings.delayUntil - now) / 1000);
        if (settings.backoffTime > now) {
          table.set(row1++,12,""String_Node_Str"" + (settings.backoffTime - now) / 1000);
          table.set(row1++,12,settings.backoffDelay / 1000);
        }
      }
      if (status.lastSuccessTime != 0) {
        table.set(row1++,11,SyncStorageEngine.SOURCES[status.lastSuccessSource] + ""String_Node_Str"" + ""String_Node_Str"");
        table.set(row1++,11,formatTime(status.lastSuccessTime));
      }
      if (status.lastFailureTime != 0) {
        table.set(row1++,11,SyncStorageEngine.SOURCES[status.lastFailureSource] + ""String_Node_Str"" + ""String_Node_Str"");
        table.set(row1++,11,formatTime(status.lastFailureTime));
        table.set(row1++,11,status.lastFailureMesg);
      }
    }
    table.writeTo(pw);
  }
}"
1863,"/** 
 * Turn any periodic sync operations that are ready to run into pending sync operations.
 * @return the desired start time of the earliest future  periodic sync operation,in milliseconds since boot
 */
private long scheduleReadyPeriodicSyncs(){
  final boolean backgroundDataUsageAllowed=getConnectivityManager().getBackgroundDataSetting();
  long earliestFuturePollTime=Long.MAX_VALUE;
  if (!backgroundDataUsageAllowed) {
    return earliestFuturePollTime;
  }
  AccountAndUser[] accounts=mRunningAccounts;
  final long nowAbsolute=System.currentTimeMillis();
  final long shiftedNowAbsolute=(0 < nowAbsolute - mSyncRandomOffsetMillis) ? (nowAbsolute - mSyncRandomOffsetMillis) : 0;
  ArrayList<SyncStorageEngine.AuthorityInfo> infos=mSyncStorageEngine.getAuthorities();
  for (  SyncStorageEngine.AuthorityInfo info : infos) {
    if (!containsAccountAndUser(accounts,info.account,info.userId)) {
      continue;
    }
    if (!mSyncStorageEngine.getMasterSyncAutomatically(info.userId) || !mSyncStorageEngine.getSyncAutomatically(info.account,info.userId,info.authority)) {
      continue;
    }
    if (getIsSyncable(info.account,info.userId,info.authority) == 0) {
      continue;
    }
    SyncStatusInfo status=mSyncStorageEngine.getOrCreateSyncStatus(info);
    for (int i=0, N=info.periodicSyncs.size(); i < N; i++) {
      final Bundle extras=info.periodicSyncs.get(i).first;
      final Long periodInMillis=info.periodicSyncs.get(i).second * 1000;
      if (periodInMillis <= 0) {
        continue;
      }
      final long lastPollTimeAbsolute=status.getPeriodicSyncTime(i);
      long remainingMillis=periodInMillis - (shiftedNowAbsolute % periodInMillis);
      if (remainingMillis == periodInMillis || lastPollTimeAbsolute > nowAbsolute || (nowAbsolute - lastPollTimeAbsolute >= periodInMillis)) {
        final Pair<Long,Long> backoff=mSyncStorageEngine.getBackoff(info.account,info.userId,info.authority);
        final RegisteredServicesCache.ServiceInfo<SyncAdapterType> syncAdapterInfo;
        syncAdapterInfo=mSyncAdapters.getServiceInfo(SyncAdapterType.newKey(info.authority,info.account.type),info.userId);
        if (syncAdapterInfo == null) {
          continue;
        }
        scheduleSyncOperation(new SyncOperation(info.account,info.userId,SyncOperation.REASON_PERIODIC,SyncStorageEngine.SOURCE_PERIODIC,info.authority,extras,0,backoff != null ? backoff.first : 0,mSyncStorageEngine.getDelayUntilTime(info.account,info.userId,info.authority),syncAdapterInfo.type.allowParallelSyncs()));
        status.setPeriodicSyncTime(i,nowAbsolute);
      }
      final long nextPollTimeAbsolute=nowAbsolute + remainingMillis;
      if (nextPollTimeAbsolute < earliestFuturePollTime) {
        earliestFuturePollTime=nextPollTimeAbsolute;
      }
    }
  }
  if (earliestFuturePollTime == Long.MAX_VALUE) {
    return Long.MAX_VALUE;
  }
  return SystemClock.elapsedRealtime() + ((earliestFuturePollTime < nowAbsolute) ? 0 : (earliestFuturePollTime - nowAbsolute));
}","/** 
 * Turn any periodic sync operations that are ready to run into pending sync operations.
 * @return the desired start time of the earliest future  periodic sync operation,in milliseconds since boot
 */
private long scheduleReadyPeriodicSyncs(){
  final boolean backgroundDataUsageAllowed=getConnectivityManager().getBackgroundDataSetting();
  long earliestFuturePollTime=Long.MAX_VALUE;
  if (!backgroundDataUsageAllowed) {
    return earliestFuturePollTime;
  }
  AccountAndUser[] accounts=mRunningAccounts;
  final long nowAbsolute=System.currentTimeMillis();
  final long shiftedNowAbsolute=(0 < nowAbsolute - mSyncRandomOffsetMillis) ? (nowAbsolute - mSyncRandomOffsetMillis) : 0;
  ArrayList<Pair<AuthorityInfo,SyncStatusInfo>> infos=mSyncStorageEngine.getCopyOfAllAuthoritiesWithSyncStatus();
  for (  Pair<AuthorityInfo,SyncStatusInfo> info : infos) {
    final AuthorityInfo authorityInfo=info.first;
    final SyncStatusInfo status=info.second;
    if (!containsAccountAndUser(accounts,authorityInfo.account,authorityInfo.userId)) {
      continue;
    }
    if (!mSyncStorageEngine.getMasterSyncAutomatically(authorityInfo.userId) || !mSyncStorageEngine.getSyncAutomatically(authorityInfo.account,authorityInfo.userId,authorityInfo.authority)) {
      continue;
    }
    if (getIsSyncable(authorityInfo.account,authorityInfo.userId,authorityInfo.authority) == 0) {
      continue;
    }
    for (int i=0, N=authorityInfo.periodicSyncs.size(); i < N; i++) {
      final Bundle extras=authorityInfo.periodicSyncs.get(i).first;
      final Long periodInMillis=authorityInfo.periodicSyncs.get(i).second * 1000;
      if (periodInMillis <= 0) {
        continue;
      }
      final long lastPollTimeAbsolute=status.getPeriodicSyncTime(i);
      long remainingMillis=periodInMillis - (shiftedNowAbsolute % periodInMillis);
      if (remainingMillis == periodInMillis || lastPollTimeAbsolute > nowAbsolute || (nowAbsolute - lastPollTimeAbsolute >= periodInMillis)) {
        final Pair<Long,Long> backoff=mSyncStorageEngine.getBackoff(authorityInfo.account,authorityInfo.userId,authorityInfo.authority);
        final RegisteredServicesCache.ServiceInfo<SyncAdapterType> syncAdapterInfo;
        syncAdapterInfo=mSyncAdapters.getServiceInfo(SyncAdapterType.newKey(authorityInfo.authority,authorityInfo.account.type),authorityInfo.userId);
        if (syncAdapterInfo == null) {
          continue;
        }
        scheduleSyncOperation(new SyncOperation(authorityInfo.account,authorityInfo.userId,SyncOperation.REASON_PERIODIC,SyncStorageEngine.SOURCE_PERIODIC,authorityInfo.authority,extras,0,backoff != null ? backoff.first : 0,mSyncStorageEngine.getDelayUntilTime(authorityInfo.account,authorityInfo.userId,authorityInfo.authority),syncAdapterInfo.type.allowParallelSyncs()));
        mSyncStorageEngine.setPeriodicSyncTime(authorityInfo.ident,authorityInfo.periodicSyncs.get(i),nowAbsolute);
      }
      final long nextPollTimeAbsolute=nowAbsolute + remainingMillis;
      if (nextPollTimeAbsolute < earliestFuturePollTime) {
        earliestFuturePollTime=nextPollTimeAbsolute;
      }
    }
  }
  if (earliestFuturePollTime == Long.MAX_VALUE) {
    return Long.MAX_VALUE;
  }
  return SystemClock.elapsedRealtime() + ((earliestFuturePollTime < nowAbsolute) ? 0 : (earliestFuturePollTime - nowAbsolute));
}"
1864,"void generate(CharSequence source,int bufStart,int bufEnd,TextPaint paint,int outerWidth,TextDirectionHeuristic textDir,float spacingmult,float spacingadd,boolean includepad,boolean trackpad,float ellipsizedWidth,TextUtils.TruncateAt ellipsize){
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=mMeasured;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int DEFAULT_DIR=DIR_LEFT_TO_RIGHT;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineLimit=mLineCount + 1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          int lmsFirstLine=getLineForOffset(spanned.getSpanStart(lms2));
          firstWidthLineLimit=lmsFirstLine + lms2.getLeadingMarginLineCount();
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=new int[ArrayUtils.idealIntArraySize(chooseHt.length)];
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int width=firstWidth;
    float w=0;
    int here=paraStart;
    int ok=paraStart;
    float okWidth=w;
    int okAscent=0, okDescent=0, okTop=0, okBottom=0;
    int fit=paraStart;
    float fitWidth=w;
    int fitAscent=0, fitDescent=0, fitTop=0, fitBottom=0;
    boolean hasTabOrEmoji=false;
    boolean hasTab=false;
    TabStops tabStops=null;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      int fmTop=fm.top;
      int fmBottom=fm.bottom;
      int fmAscent=fm.ascent;
      int fmDescent=fm.descent;
      for (int j=spanStart; j < spanEnd; j++) {
        char c=chs[j - paraStart];
        if (c == CHAR_NEW_LINE) {
        }
 else         if (c == CHAR_TAB) {
          if (hasTab == false) {
            hasTab=true;
            hasTabOrEmoji=true;
            if (spanned != null) {
              TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
              if (spans.length > 0) {
                tabStops=new TabStops(TAB_INCREMENT,spans);
              }
            }
          }
          if (tabStops != null) {
            w=tabStops.nextTab(w);
          }
 else {
            w=TabStops.nextDefaultStop(w,TAB_INCREMENT);
          }
        }
 else         if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
          int emoji=Character.codePointAt(chs,j - paraStart);
          if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
            Bitmap bm=EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
            if (bm != null) {
              Paint whichPaint;
              if (spanned == null) {
                whichPaint=paint;
              }
 else {
                whichPaint=mWorkPaint;
              }
              float wid=bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
              w+=wid;
              hasTabOrEmoji=true;
              j++;
            }
 else {
              w+=widths[j - paraStart];
            }
          }
 else {
            w+=widths[j - paraStart];
          }
        }
 else {
          w+=widths[j - paraStart];
        }
        boolean isSpaceOrTab=c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
        if (w <= width || isSpaceOrTab) {
          fitWidth=w;
          fit=j + 1;
          if (fmTop < fitTop)           fitTop=fmTop;
          if (fmAscent < fitAscent)           fitAscent=fmAscent;
          if (fmDescent > fitDescent)           fitDescent=fmDescent;
          if (fmBottom > fitBottom)           fitBottom=fmBottom;
          boolean isLineBreak=isSpaceOrTab || ((c == CHAR_SLASH || c == CHAR_HYPHEN) && (j + 1 >= spanEnd || !Character.isDigit(chs[j + 1 - paraStart]))) || (c >= CHAR_FIRST_CJK && isIdeographic(c,true) && j + 1 < spanEnd && isIdeographic(chs[j + 1 - paraStart],false));
          if (isLineBreak) {
            okWidth=w;
            ok=j + 1;
            if (fitTop < okTop)             okTop=fitTop;
            if (fitAscent < okAscent)             okAscent=fitAscent;
            if (fitDescent > okDescent)             okDescent=fitDescent;
            if (fitBottom > okBottom)             okBottom=fitBottom;
          }
        }
 else {
          final boolean moreChars=(j + 1 < spanEnd);
          int endPos;
          int above, below, top, bottom;
          float currentTextWidth;
          if (ok != here) {
            endPos=ok;
            above=okAscent;
            below=okDescent;
            top=okTop;
            bottom=okBottom;
            currentTextWidth=okWidth;
          }
 else           if (fit != here) {
            endPos=fit;
            above=fitAscent;
            below=fitDescent;
            top=fitTop;
            bottom=fitBottom;
            currentTextWidth=fitWidth;
          }
 else {
            endPos=here + 1;
            above=fm.ascent;
            below=fm.descent;
            top=fm.top;
            bottom=fm.bottom;
            currentTextWidth=widths[here - paraStart];
          }
          v=out(source,here,endPos,above,below,top,bottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,hasTabOrEmoji,needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,currentTextWidth,paint,moreChars);
          here=endPos;
          j=here - 1;
          ok=fit=here;
          w=0;
          fitAscent=fitDescent=fitTop=fitBottom=0;
          okAscent=okDescent=okTop=okBottom=0;
          if (--firstWidthLineLimit <= 0) {
            width=restWidth;
          }
          if (here < spanStart) {
            measured.setPos(here);
            spanEnd=here;
            break;
          }
          if (mLineCount >= mMaximumVisibleLineCount) {
            break;
          }
        }
      }
    }
    if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
      if ((fitTop | fitBottom | fitDescent| fitAscent) == 0) {
        paint.getFontMetricsInt(fm);
        fitTop=fm.top;
        fitBottom=fm.bottom;
        fitAscent=fm.ascent;
        fitDescent=fm.descent;
      }
      v=out(source,here,paraEnd,fitAscent,fitDescent,fitTop,fitBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,hasTabOrEmoji,needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,w,paint,paraEnd != bufEnd);
    }
    paraStart=paraEnd;
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,false,needMultiply,null,DEFAULT_DIR,true,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}","void generate(CharSequence source,int bufStart,int bufEnd,TextPaint paint,int outerWidth,TextDirectionHeuristic textDir,float spacingmult,float spacingadd,boolean includepad,boolean trackpad,float ellipsizedWidth,TextUtils.TruncateAt ellipsize){
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=mMeasured;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int DEFAULT_DIR=DIR_LEFT_TO_RIGHT;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineLimit=mLineCount + 1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          int lmsFirstLine=getLineForOffset(spanned.getSpanStart(lms2));
          firstWidthLineLimit=lmsFirstLine + lms2.getLeadingMarginLineCount();
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=new int[ArrayUtils.idealIntArraySize(chooseHt.length)];
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int width=firstWidth;
    float w=0;
    int here=paraStart;
    int ok=paraStart;
    float okWidth=w;
    int okAscent=0, okDescent=0, okTop=0, okBottom=0;
    int fit=paraStart;
    float fitWidth=w;
    int fitAscent=0, fitDescent=0, fitTop=0, fitBottom=0;
    boolean hasTabOrEmoji=false;
    boolean hasTab=false;
    TabStops tabStops=null;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      int fmTop=fm.top;
      int fmBottom=fm.bottom;
      int fmAscent=fm.ascent;
      int fmDescent=fm.descent;
      for (int j=spanStart; j < spanEnd; j++) {
        char c=chs[j - paraStart];
        if (c == CHAR_NEW_LINE) {
        }
 else         if (c == CHAR_TAB) {
          if (hasTab == false) {
            hasTab=true;
            hasTabOrEmoji=true;
            if (spanned != null) {
              TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
              if (spans.length > 0) {
                tabStops=new TabStops(TAB_INCREMENT,spans);
              }
            }
          }
          if (tabStops != null) {
            w=tabStops.nextTab(w);
          }
 else {
            w=TabStops.nextDefaultStop(w,TAB_INCREMENT);
          }
        }
 else         if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
          int emoji=Character.codePointAt(chs,j - paraStart);
          if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
            Bitmap bm=EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
            if (bm != null) {
              Paint whichPaint;
              if (spanned == null) {
                whichPaint=paint;
              }
 else {
                whichPaint=mWorkPaint;
              }
              float wid=bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
              w+=wid;
              hasTabOrEmoji=true;
              j++;
            }
 else {
              w+=widths[j - paraStart];
            }
          }
 else {
            w+=widths[j - paraStart];
          }
        }
 else {
          w+=widths[j - paraStart];
        }
        boolean isSpaceOrTab=c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
        if (w <= width || isSpaceOrTab) {
          fitWidth=w;
          fit=j + 1;
          if (fmTop < fitTop)           fitTop=fmTop;
          if (fmAscent < fitAscent)           fitAscent=fmAscent;
          if (fmDescent > fitDescent)           fitDescent=fmDescent;
          if (fmBottom > fitBottom)           fitBottom=fmBottom;
          boolean isLineBreak=isSpaceOrTab || ((c == CHAR_SLASH || c == CHAR_HYPHEN) && (j + 1 >= spanEnd || !Character.isDigit(chs[j + 1 - paraStart]))) || (c >= CHAR_FIRST_CJK && isIdeographic(c,true) && j + 1 < spanEnd && isIdeographic(chs[j + 1 - paraStart],false));
          if (isLineBreak) {
            okWidth=w;
            ok=j + 1;
            if (fitTop < okTop)             okTop=fitTop;
            if (fitAscent < okAscent)             okAscent=fitAscent;
            if (fitDescent > okDescent)             okDescent=fitDescent;
            if (fitBottom > okBottom)             okBottom=fitBottom;
          }
        }
 else {
          final boolean moreChars=(j + 1 < spanEnd);
          int endPos;
          int above, below, top, bottom;
          float currentTextWidth;
          if (ok != here) {
            endPos=ok;
            above=okAscent;
            below=okDescent;
            top=okTop;
            bottom=okBottom;
            currentTextWidth=okWidth;
          }
 else           if (fit != here) {
            endPos=fit;
            above=fitAscent;
            below=fitDescent;
            top=fitTop;
            bottom=fitBottom;
            currentTextWidth=fitWidth;
          }
 else {
            endPos=here + 1;
            above=fm.ascent;
            below=fm.descent;
            top=fm.top;
            bottom=fm.bottom;
            currentTextWidth=widths[here - paraStart];
          }
          v=out(source,here,endPos,above,below,top,bottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,hasTabOrEmoji,needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,currentTextWidth,paint,moreChars);
          here=endPos;
          j=here - 1;
          ok=fit=here;
          w=0;
          fitAscent=fitDescent=fitTop=fitBottom=0;
          okAscent=okDescent=okTop=okBottom=0;
          if (--firstWidthLineLimit <= 0) {
            width=restWidth;
          }
          if (here < spanStart) {
            measured.setPos(here);
            spanEnd=here;
            break;
          }
          if (mLineCount >= mMaximumVisibleLineCount) {
            break;
          }
        }
      }
    }
    if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
      if ((fitTop | fitBottom | fitDescent| fitAscent) == 0) {
        paint.getFontMetricsInt(fm);
        fitTop=fm.top;
        fitBottom=fm.bottom;
        fitAscent=fm.ascent;
        fitDescent=fm.descent;
      }
      v=out(source,here,paraEnd,fitAscent,fitDescent,fitTop,fitBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,hasTabOrEmoji,needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,w,paint,paraEnd != bufEnd);
    }
    paraStart=paraEnd;
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufStart,bufEnd,textDir);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,false,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}"
1865,"void generate(CharSequence source,int bufStart,int bufEnd,TextPaint paint,int outerWidth,TextDirectionHeuristic textDir,float spacingmult,float spacingadd,boolean includepad,boolean trackpad,float ellipsizedWidth,TextUtils.TruncateAt ellipsize){
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=mMeasured;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int DEFAULT_DIR=DIR_LEFT_TO_RIGHT;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineLimit=mLineCount + 1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          int lmsFirstLine=getLineForOffset(spanned.getSpanStart(lms2));
          firstWidthLineLimit=lmsFirstLine + lms2.getLeadingMarginLineCount();
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=new int[ArrayUtils.idealIntArraySize(chooseHt.length)];
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int width=firstWidth;
    float w=0;
    int here=paraStart;
    int ok=paraStart;
    float okWidth=w;
    int okAscent=0, okDescent=0, okTop=0, okBottom=0;
    int fit=paraStart;
    float fitWidth=w;
    int fitAscent=0, fitDescent=0, fitTop=0, fitBottom=0;
    boolean hasTabOrEmoji=false;
    boolean hasTab=false;
    TabStops tabStops=null;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      int fmTop=fm.top;
      int fmBottom=fm.bottom;
      int fmAscent=fm.ascent;
      int fmDescent=fm.descent;
      for (int j=spanStart; j < spanEnd; j++) {
        char c=chs[j - paraStart];
        if (c == CHAR_NEW_LINE) {
        }
 else         if (c == CHAR_TAB) {
          if (hasTab == false) {
            hasTab=true;
            hasTabOrEmoji=true;
            if (spanned != null) {
              TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
              if (spans.length > 0) {
                tabStops=new TabStops(TAB_INCREMENT,spans);
              }
            }
          }
          if (tabStops != null) {
            w=tabStops.nextTab(w);
          }
 else {
            w=TabStops.nextDefaultStop(w,TAB_INCREMENT);
          }
        }
 else         if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
          int emoji=Character.codePointAt(chs,j - paraStart);
          if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
            Bitmap bm=EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
            if (bm != null) {
              Paint whichPaint;
              if (spanned == null) {
                whichPaint=paint;
              }
 else {
                whichPaint=mWorkPaint;
              }
              float wid=bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
              w+=wid;
              hasTabOrEmoji=true;
              j++;
            }
 else {
              w+=widths[j - paraStart];
            }
          }
 else {
            w+=widths[j - paraStart];
          }
        }
 else {
          w+=widths[j - paraStart];
        }
        boolean isSpaceOrTab=c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
        if (w <= width || isSpaceOrTab) {
          fitWidth=w;
          fit=j + 1;
          if (fmTop < fitTop)           fitTop=fmTop;
          if (fmAscent < fitAscent)           fitAscent=fmAscent;
          if (fmDescent > fitDescent)           fitDescent=fmDescent;
          if (fmBottom > fitBottom)           fitBottom=fmBottom;
          boolean isLineBreak=isSpaceOrTab || ((c == CHAR_SLASH || c == CHAR_HYPHEN) && (j + 1 >= spanEnd || !Character.isDigit(chs[j + 1 - paraStart]))) || (c >= CHAR_FIRST_CJK && isIdeographic(c,true) && j + 1 < spanEnd && isIdeographic(chs[j + 1 - paraStart],false));
          if (isLineBreak) {
            okWidth=w;
            ok=j + 1;
            if (fitTop < okTop)             okTop=fitTop;
            if (fitAscent < okAscent)             okAscent=fitAscent;
            if (fitDescent > okDescent)             okDescent=fitDescent;
            if (fitBottom > okBottom)             okBottom=fitBottom;
          }
        }
 else {
          final boolean moreChars=(j + 1 < spanEnd);
          int endPos;
          int above, below, top, bottom;
          float currentTextWidth;
          if (ok != here) {
            endPos=ok;
            above=okAscent;
            below=okDescent;
            top=okTop;
            bottom=okBottom;
            currentTextWidth=okWidth;
          }
 else           if (fit != here) {
            endPos=fit;
            above=fitAscent;
            below=fitDescent;
            top=fitTop;
            bottom=fitBottom;
            currentTextWidth=fitWidth;
          }
 else {
            endPos=here + 1;
            above=fm.ascent;
            below=fm.descent;
            top=fm.top;
            bottom=fm.bottom;
            currentTextWidth=widths[here - paraStart];
          }
          v=out(source,here,endPos,above,below,top,bottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,hasTabOrEmoji,needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,currentTextWidth,paint,moreChars);
          here=endPos;
          j=here - 1;
          ok=fit=here;
          w=0;
          fitAscent=fitDescent=fitTop=fitBottom=0;
          okAscent=okDescent=okTop=okBottom=0;
          if (--firstWidthLineLimit <= 0) {
            width=restWidth;
          }
          if (here < spanStart) {
            measured.setPos(here);
            spanEnd=here;
            break;
          }
          if (mLineCount >= mMaximumVisibleLineCount) {
            break;
          }
        }
      }
    }
    if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
      if ((fitTop | fitBottom | fitDescent| fitAscent) == 0) {
        paint.getFontMetricsInt(fm);
        fitTop=fm.top;
        fitBottom=fm.bottom;
        fitAscent=fm.ascent;
        fitDescent=fm.descent;
      }
      v=out(source,here,paraEnd,fitAscent,fitDescent,fitTop,fitBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,hasTabOrEmoji,needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,w,paint,paraEnd != bufEnd);
    }
    paraStart=paraEnd;
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,false,needMultiply,null,DEFAULT_DIR,true,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}","void generate(CharSequence source,int bufStart,int bufEnd,TextPaint paint,int outerWidth,TextDirectionHeuristic textDir,float spacingmult,float spacingadd,boolean includepad,boolean trackpad,float ellipsizedWidth,TextUtils.TruncateAt ellipsize){
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=mMeasured;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int DEFAULT_DIR=DIR_LEFT_TO_RIGHT;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineLimit=mLineCount + 1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          int lmsFirstLine=getLineForOffset(spanned.getSpanStart(lms2));
          firstWidthLineLimit=lmsFirstLine + lms2.getLeadingMarginLineCount();
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=new int[ArrayUtils.idealIntArraySize(chooseHt.length)];
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int width=firstWidth;
    float w=0;
    int here=paraStart;
    int ok=paraStart;
    float okWidth=w;
    int okAscent=0, okDescent=0, okTop=0, okBottom=0;
    int fit=paraStart;
    float fitWidth=w;
    int fitAscent=0, fitDescent=0, fitTop=0, fitBottom=0;
    boolean hasTabOrEmoji=false;
    boolean hasTab=false;
    TabStops tabStops=null;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      int fmTop=fm.top;
      int fmBottom=fm.bottom;
      int fmAscent=fm.ascent;
      int fmDescent=fm.descent;
      for (int j=spanStart; j < spanEnd; j++) {
        char c=chs[j - paraStart];
        if (c == CHAR_NEW_LINE) {
        }
 else         if (c == CHAR_TAB) {
          if (hasTab == false) {
            hasTab=true;
            hasTabOrEmoji=true;
            if (spanned != null) {
              TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
              if (spans.length > 0) {
                tabStops=new TabStops(TAB_INCREMENT,spans);
              }
            }
          }
          if (tabStops != null) {
            w=tabStops.nextTab(w);
          }
 else {
            w=TabStops.nextDefaultStop(w,TAB_INCREMENT);
          }
        }
 else         if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
          int emoji=Character.codePointAt(chs,j - paraStart);
          if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
            Bitmap bm=EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
            if (bm != null) {
              Paint whichPaint;
              if (spanned == null) {
                whichPaint=paint;
              }
 else {
                whichPaint=mWorkPaint;
              }
              float wid=bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
              w+=wid;
              hasTabOrEmoji=true;
              j++;
            }
 else {
              w+=widths[j - paraStart];
            }
          }
 else {
            w+=widths[j - paraStart];
          }
        }
 else {
          w+=widths[j - paraStart];
        }
        boolean isSpaceOrTab=c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
        if (w <= width || isSpaceOrTab) {
          fitWidth=w;
          fit=j + 1;
          if (fmTop < fitTop)           fitTop=fmTop;
          if (fmAscent < fitAscent)           fitAscent=fmAscent;
          if (fmDescent > fitDescent)           fitDescent=fmDescent;
          if (fmBottom > fitBottom)           fitBottom=fmBottom;
          boolean isLineBreak=isSpaceOrTab || ((c == CHAR_SLASH || c == CHAR_HYPHEN) && (j + 1 >= spanEnd || !Character.isDigit(chs[j + 1 - paraStart]))) || (c >= CHAR_FIRST_CJK && isIdeographic(c,true) && j + 1 < spanEnd && isIdeographic(chs[j + 1 - paraStart],false));
          if (isLineBreak) {
            okWidth=w;
            ok=j + 1;
            if (fitTop < okTop)             okTop=fitTop;
            if (fitAscent < okAscent)             okAscent=fitAscent;
            if (fitDescent > okDescent)             okDescent=fitDescent;
            if (fitBottom > okBottom)             okBottom=fitBottom;
          }
        }
 else {
          final boolean moreChars=(j + 1 < spanEnd);
          int endPos;
          int above, below, top, bottom;
          float currentTextWidth;
          if (ok != here) {
            endPos=ok;
            above=okAscent;
            below=okDescent;
            top=okTop;
            bottom=okBottom;
            currentTextWidth=okWidth;
          }
 else           if (fit != here) {
            endPos=fit;
            above=fitAscent;
            below=fitDescent;
            top=fitTop;
            bottom=fitBottom;
            currentTextWidth=fitWidth;
          }
 else {
            endPos=here + 1;
            above=fm.ascent;
            below=fm.descent;
            top=fm.top;
            bottom=fm.bottom;
            currentTextWidth=widths[here - paraStart];
          }
          v=out(source,here,endPos,above,below,top,bottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,hasTabOrEmoji,needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,currentTextWidth,paint,moreChars);
          here=endPos;
          j=here - 1;
          ok=fit=here;
          w=0;
          fitAscent=fitDescent=fitTop=fitBottom=0;
          okAscent=okDescent=okTop=okBottom=0;
          if (--firstWidthLineLimit <= 0) {
            width=restWidth;
          }
          if (here < spanStart) {
            measured.setPos(here);
            spanEnd=here;
            break;
          }
          if (mLineCount >= mMaximumVisibleLineCount) {
            break;
          }
        }
      }
    }
    if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
      if ((fitTop | fitBottom | fitDescent| fitAscent) == 0) {
        paint.getFontMetricsInt(fm);
        fitTop=fm.top;
        fitBottom=fm.bottom;
        fitAscent=fm.ascent;
        fitDescent=fm.descent;
      }
      v=out(source,here,paraEnd,fitAscent,fitDescent,fitTop,fitBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,hasTabOrEmoji,needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,w,paint,paraEnd != bufEnd);
    }
    paraStart=paraEnd;
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufStart,bufEnd,textDir);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,false,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}"
1866,"@Override public void moveTaskToBack(int taskId){
  enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,""String_Node_Str"");
synchronized (this) {
    TaskRecord tr=recentTaskForIdLocked(taskId);
    if (tr != null) {
      ActivityStack stack=tr.stack;
      if (stack.mResumedActivity != null && stack.mResumedActivity.task == tr) {
        if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(),Binder.getCallingUid(),""String_Node_Str"")) {
          return;
        }
      }
      final long origId=Binder.clearCallingIdentity();
      stack.moveTaskToBackLocked(taskId,null);
      Binder.restoreCallingIdentity(origId);
    }
  }
}","@Override public void moveTaskToBack(int taskId){
  enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,""String_Node_Str"");
synchronized (this) {
    TaskRecord tr=recentTaskForIdLocked(taskId);
    if (tr != null) {
      if (DEBUG_STACK)       Slog.d(TAG,""String_Node_Str"" + tr);
      ActivityStack stack=tr.stack;
      if (stack.mResumedActivity != null && stack.mResumedActivity.task == tr) {
        if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(),Binder.getCallingUid(),""String_Node_Str"")) {
          return;
        }
      }
      final long origId=Binder.clearCallingIdentity();
      stack.moveTaskToBackLocked(taskId,null);
      Binder.restoreCallingIdentity(origId);
    }
  }
}"
1867,"/** 
 * TODO: Add mController hook
 */
@Override public void moveTaskToFront(int task,int flags,Bundle options){
  enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,""String_Node_Str"");
synchronized (this) {
    if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(),Binder.getCallingUid(),""String_Node_Str"")) {
      ActivityOptions.abort(options);
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    try {
      mStackSupervisor.findTaskToMoveToFrontLocked(task,flags,options);
    }
  finally {
      Binder.restoreCallingIdentity(origId);
    }
    ActivityOptions.abort(options);
  }
}","/** 
 * TODO: Add mController hook
 */
@Override public void moveTaskToFront(int task,int flags,Bundle options){
  enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,""String_Node_Str"");
  if (DEBUG_STACK)   Slog.d(TAG,""String_Node_Str"" + task);
synchronized (this) {
    if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(),Binder.getCallingUid(),""String_Node_Str"")) {
      ActivityOptions.abort(options);
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    try {
      mStackSupervisor.findTaskToMoveToFrontLocked(task,flags,options);
    }
  finally {
      Binder.restoreCallingIdentity(origId);
    }
    ActivityOptions.abort(options);
  }
}"
1868,"@Override public void moveTaskToStack(int taskId,int stackId,boolean toTop){
  if (stackId == HOME_STACK_ID) {
    Slog.e(TAG,""String_Node_Str"" + taskId + ""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
  }
synchronized (this) {
    mStackSupervisor.moveTaskToStack(taskId,stackId,toTop);
  }
}","@Override public void moveTaskToStack(int taskId,int stackId,boolean toTop){
  if (stackId == HOME_STACK_ID) {
    Slog.e(TAG,""String_Node_Str"" + taskId + ""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
  }
synchronized (this) {
    if (DEBUG_STACK)     Slog.d(TAG,""String_Node_Str"" + taskId + ""String_Node_Str""+ stackId+ ""String_Node_Str""+ toTop);
    mStackSupervisor.moveTaskToStack(taskId,stackId,toTop);
  }
}"
1869,"ActivityStack getCorrectStack(ActivityRecord r){
  if (r.isApplicationActivity() || (r.task != null && r.task.isApplicationTask())) {
    int stackNdx;
    for (stackNdx=mStacks.size() - 1; stackNdx > 0; --stackNdx) {
      if (mStacks.get(stackNdx).mCurrentUser == mCurrentUser) {
        break;
      }
    }
    if (stackNdx == 0) {
      int stackId=mService.createStack(-1,HOME_STACK_ID,StackBox.TASK_STACK_GOES_OVER,1.0f);
      mFocusedStack=getStack(stackId);
    }
    return mFocusedStack;
  }
  return mHomeStack;
}","ActivityStack getCorrectStack(ActivityRecord r){
  final TaskRecord task=r.task;
  if (r.isApplicationActivity() || (task != null && task.isApplicationTask())) {
    int stackNdx;
    for (stackNdx=mStacks.size() - 1; stackNdx > 0; --stackNdx) {
      if (mStacks.get(stackNdx).mCurrentUser == mCurrentUser) {
        break;
      }
    }
    if (stackNdx == 0) {
      int stackId=mService.createStack(-1,HOME_STACK_ID,StackBox.TASK_STACK_GOES_OVER,1.0f);
      mFocusedStack=getStack(stackId);
    }
    if (task != null) {
      mFocusedStack=task.stack;
    }
    return mFocusedStack;
  }
  return mHomeStack;
}"
1870,"final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(intent,r.info) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && curTop.task != intentActivity.task) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || sourceStack.topActivity() == sourceRecord) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=getCorrectStack(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=getCorrectStack(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  return ActivityManager.START_SUCCESS;
}","final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(intent,r.info) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && curTop.task != intentActivity.task) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || sourceStack.topActivity() == sourceRecord) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=getCorrectStack(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=getCorrectStack(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  mService.setFocusedActivityLocked(r);
  return ActivityManager.START_SUCCESS;
}"
1871,"boolean reportResumedActivityLocked(ActivityRecord r){
  final ActivityStack stack=r.task.stack;
  if (isFrontStack(stack)) {
    mService.updateUsageStats(r,true);
    mService.setFocusedActivityLocked(r);
  }
  if (allResumedActivitiesComplete()) {
    ensureActivitiesVisibleLocked(null,0);
    mWindowManager.executeAppTransition();
    return true;
  }
  return false;
}","boolean reportResumedActivityLocked(ActivityRecord r){
  final ActivityStack stack=r.task.stack;
  if (isFrontStack(stack)) {
    mService.updateUsageStats(r,true);
  }
  if (allResumedActivitiesComplete()) {
    ensureActivitiesVisibleLocked(null,0);
    mWindowManager.executeAppTransition();
    return true;
  }
  return false;
}"
1872,"void findTaskToMoveToFrontLocked(int taskId,int flags,Bundle options){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    if (mStacks.get(stackNdx).findTaskToMoveToFrontLocked(taskId,flags,options)) {
      return;
    }
  }
}","void findTaskToMoveToFrontLocked(int taskId,int flags,Bundle options){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    if (mStacks.get(stackNdx).findTaskToMoveToFrontLocked(taskId,flags,options)) {
      if (DEBUG_STACK)       Slog.d(TAG,""String_Node_Str"" + mStacks.get(stackNdx));
      return;
    }
  }
}"
1873,"public void removeTask(int taskId){
synchronized (mWindowMap) {
    Task task=mTaskIdToTask.get(taskId);
    if (task == null) {
      return;
    }
    final TaskStack stack=task.mStack;
    stack.removeTask(task);
    stack.getDisplayContent().layoutNeeded=true;
  }
}","public void removeTask(int taskId){
synchronized (mWindowMap) {
    Task task=mTaskIdToTask.get(taskId);
    if (task == null) {
      if (DEBUG_STACK)       Slog.i(TAG,""String_Node_Str"" + taskId);
      return;
    }
    final TaskStack stack=task.mStack;
    stack.removeTask(task);
    stack.getDisplayContent().layoutNeeded=true;
  }
}"
1874,"public void validateAppTokens(int stackId,List<TaskGroup> tasks){
synchronized (mWindowMap) {
    int t=tasks.size() - 1;
    if (t < 0) {
      Slog.w(TAG,""String_Node_Str"");
      return;
    }
    TaskGroup task=tasks.get(0);
    int taskId=task.taskId;
    Task targetTask=mTaskIdToTask.get(taskId);
    DisplayContent displayContent=targetTask.getDisplayContent();
    if (displayContent == null) {
      Slog.w(TAG,""String_Node_Str"" + taskId);
      return;
    }
    final ArrayList<Task> localTasks=mStackIdToStack.get(stackId).getTasks();
    int taskNdx;
    for (taskNdx=localTasks.size() - 1; taskNdx >= 0 && t >= 0; --taskNdx, --t) {
      AppTokenList localTokens=localTasks.get(taskNdx).mAppTokens;
      task=tasks.get(t);
      List<IApplicationToken> tokens=task.tokens;
      DisplayContent lastDisplayContent=displayContent;
      displayContent=mTaskIdToTask.get(taskId).getDisplayContent();
      if (displayContent != lastDisplayContent) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
      int tokenNdx;
      int v;
      for (tokenNdx=localTokens.size() - 1, v=task.tokens.size() - 1; tokenNdx >= 0 && v >= 0; ) {
        final AppWindowToken atoken=localTokens.get(tokenNdx);
        if (atoken.removed) {
          --tokenNdx;
          continue;
        }
        if (tokens.get(v) != atoken.token) {
          break;
        }
        --tokenNdx;
        v--;
      }
      if (tokenNdx >= 0 || v >= 0) {
        break;
      }
    }
    if (taskNdx >= 0 || t >= 0) {
      Slog.w(TAG,""String_Node_Str"" + tasks);
      Slog.w(TAG,""String_Node_Str"" + displayContent.getTasks());
      Slog.w(TAG,""String_Node_Str"" + Debug.getCallers(4));
    }
  }
}","public void validateAppTokens(int stackId,List<TaskGroup> tasks){
synchronized (mWindowMap) {
    int t=tasks.size() - 1;
    if (t < 0) {
      Slog.w(TAG,""String_Node_Str"");
      return;
    }
    TaskGroup task=tasks.get(0);
    int taskId=task.taskId;
    Task targetTask=mTaskIdToTask.get(taskId);
    DisplayContent displayContent=targetTask.getDisplayContent();
    if (displayContent == null) {
      Slog.w(TAG,""String_Node_Str"" + taskId);
      return;
    }
    final ArrayList<Task> localTasks=mStackIdToStack.get(stackId).getTasks();
    int taskNdx;
    for (taskNdx=localTasks.size() - 1; taskNdx >= 0 && t >= 0; --taskNdx, --t) {
      AppTokenList localTokens=localTasks.get(taskNdx).mAppTokens;
      task=tasks.get(t);
      List<IApplicationToken> tokens=task.tokens;
      DisplayContent lastDisplayContent=displayContent;
      displayContent=mTaskIdToTask.get(taskId).getDisplayContent();
      if (displayContent != lastDisplayContent) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
      int tokenNdx;
      int v;
      for (tokenNdx=localTokens.size() - 1, v=task.tokens.size() - 1; tokenNdx >= 0 && v >= 0; ) {
        final AppWindowToken atoken=localTokens.get(tokenNdx);
        if (atoken.removed) {
          --tokenNdx;
          continue;
        }
        if (tokens.get(v) != atoken.token) {
          break;
        }
        --tokenNdx;
        v--;
      }
      if (tokenNdx >= 0 || v >= 0) {
        break;
      }
    }
    if (taskNdx >= 0 || t >= 0) {
      Slog.w(TAG,""String_Node_Str"" + tasks);
      Slog.w(TAG,""String_Node_Str"" + localTasks);
      Slog.w(TAG,""String_Node_Str"" + Debug.getCallers(4));
    }
  }
}"
1875,"@Override public void moveTaskToBack(int taskId){
  enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,""String_Node_Str"");
synchronized (this) {
    TaskRecord tr=recentTaskForIdLocked(taskId);
    if (tr != null) {
      ActivityStack stack=tr.stack;
      if (stack.mResumedActivity != null && stack.mResumedActivity.task == tr) {
        if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(),Binder.getCallingUid(),""String_Node_Str"")) {
          return;
        }
      }
      final long origId=Binder.clearCallingIdentity();
      stack.moveTaskToBackLocked(taskId,null);
      Binder.restoreCallingIdentity(origId);
    }
  }
}","@Override public void moveTaskToBack(int taskId){
  enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,""String_Node_Str"");
synchronized (this) {
    TaskRecord tr=recentTaskForIdLocked(taskId);
    if (tr != null) {
      if (DEBUG_STACK)       Slog.d(TAG,""String_Node_Str"" + tr);
      ActivityStack stack=tr.stack;
      if (stack.mResumedActivity != null && stack.mResumedActivity.task == tr) {
        if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(),Binder.getCallingUid(),""String_Node_Str"")) {
          return;
        }
      }
      final long origId=Binder.clearCallingIdentity();
      stack.moveTaskToBackLocked(taskId,null);
      Binder.restoreCallingIdentity(origId);
    }
  }
}"
1876,"/** 
 * TODO: Add mController hook
 */
@Override public void moveTaskToFront(int task,int flags,Bundle options){
  enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,""String_Node_Str"");
synchronized (this) {
    if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(),Binder.getCallingUid(),""String_Node_Str"")) {
      ActivityOptions.abort(options);
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    try {
      mStackSupervisor.findTaskToMoveToFrontLocked(task,flags,options);
    }
  finally {
      Binder.restoreCallingIdentity(origId);
    }
    ActivityOptions.abort(options);
  }
}","/** 
 * TODO: Add mController hook
 */
@Override public void moveTaskToFront(int task,int flags,Bundle options){
  enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,""String_Node_Str"");
  if (DEBUG_STACK)   Slog.d(TAG,""String_Node_Str"" + task);
synchronized (this) {
    if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(),Binder.getCallingUid(),""String_Node_Str"")) {
      ActivityOptions.abort(options);
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    try {
      mStackSupervisor.findTaskToMoveToFrontLocked(task,flags,options);
    }
  finally {
      Binder.restoreCallingIdentity(origId);
    }
    ActivityOptions.abort(options);
  }
}"
1877,"@Override public void moveTaskToStack(int taskId,int stackId,boolean toTop){
  if (stackId == HOME_STACK_ID) {
    Slog.e(TAG,""String_Node_Str"" + taskId + ""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
  }
synchronized (this) {
    mStackSupervisor.moveTaskToStack(taskId,stackId,toTop);
  }
}","@Override public void moveTaskToStack(int taskId,int stackId,boolean toTop){
  if (stackId == HOME_STACK_ID) {
    Slog.e(TAG,""String_Node_Str"" + taskId + ""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
  }
synchronized (this) {
    if (DEBUG_STACK)     Slog.d(TAG,""String_Node_Str"" + taskId + ""String_Node_Str""+ stackId+ ""String_Node_Str""+ toTop);
    mStackSupervisor.moveTaskToStack(taskId,stackId,toTop);
  }
}"
1878,"ActivityStack getCorrectStack(ActivityRecord r){
  if (r.isApplicationActivity() || (r.task != null && r.task.isApplicationTask())) {
    int stackNdx;
    for (stackNdx=mStacks.size() - 1; stackNdx > 0; --stackNdx) {
      if (mStacks.get(stackNdx).mCurrentUser == mCurrentUser) {
        break;
      }
    }
    if (stackNdx == 0) {
      int stackId=mService.createStack(-1,HOME_STACK_ID,StackBox.TASK_STACK_GOES_OVER,1.0f);
      mFocusedStack=getStack(stackId);
    }
    return mFocusedStack;
  }
  return mHomeStack;
}","ActivityStack getCorrectStack(ActivityRecord r){
  final TaskRecord task=r.task;
  if (r.isApplicationActivity() || (task != null && task.isApplicationTask())) {
    int stackNdx;
    for (stackNdx=mStacks.size() - 1; stackNdx > 0; --stackNdx) {
      if (mStacks.get(stackNdx).mCurrentUser == mCurrentUser) {
        break;
      }
    }
    if (stackNdx == 0) {
      int stackId=mService.createStack(-1,HOME_STACK_ID,StackBox.TASK_STACK_GOES_OVER,1.0f);
      mFocusedStack=getStack(stackId);
    }
    if (task != null) {
      mFocusedStack=task.stack;
    }
    return mFocusedStack;
  }
  return mHomeStack;
}"
1879,"final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(intent,r.info) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && curTop.task != intentActivity.task) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || sourceStack.topActivity() == sourceRecord) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=getCorrectStack(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=getCorrectStack(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  return ActivityManager.START_SUCCESS;
}","final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(intent,r.info) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && curTop.task != intentActivity.task) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || sourceStack.topActivity() == sourceRecord) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=getCorrectStack(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    targetStack=sourceTask.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceTask.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=sourceTask.findActivityInHistoryLocked(r);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceTask,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    targetStack=getCorrectStack(r);
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  mService.setFocusedActivityLocked(r);
  return ActivityManager.START_SUCCESS;
}"
1880,"boolean reportResumedActivityLocked(ActivityRecord r){
  final ActivityStack stack=r.task.stack;
  if (isFrontStack(stack)) {
    mService.updateUsageStats(r,true);
    mService.setFocusedActivityLocked(r);
  }
  if (allResumedActivitiesComplete()) {
    ensureActivitiesVisibleLocked(null,0);
    mWindowManager.executeAppTransition();
    return true;
  }
  return false;
}","boolean reportResumedActivityLocked(ActivityRecord r){
  final ActivityStack stack=r.task.stack;
  if (isFrontStack(stack)) {
    mService.updateUsageStats(r,true);
  }
  if (allResumedActivitiesComplete()) {
    ensureActivitiesVisibleLocked(null,0);
    mWindowManager.executeAppTransition();
    return true;
  }
  return false;
}"
1881,"void findTaskToMoveToFrontLocked(int taskId,int flags,Bundle options){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    if (mStacks.get(stackNdx).findTaskToMoveToFrontLocked(taskId,flags,options)) {
      return;
    }
  }
}","void findTaskToMoveToFrontLocked(int taskId,int flags,Bundle options){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    if (mStacks.get(stackNdx).findTaskToMoveToFrontLocked(taskId,flags,options)) {
      if (DEBUG_STACK)       Slog.d(TAG,""String_Node_Str"" + mStacks.get(stackNdx));
      return;
    }
  }
}"
1882,"public void removeTask(int taskId){
synchronized (mWindowMap) {
    Task task=mTaskIdToTask.get(taskId);
    if (task == null) {
      return;
    }
    final TaskStack stack=task.mStack;
    stack.removeTask(task);
    stack.getDisplayContent().layoutNeeded=true;
  }
}","public void removeTask(int taskId){
synchronized (mWindowMap) {
    Task task=mTaskIdToTask.get(taskId);
    if (task == null) {
      if (DEBUG_STACK)       Slog.i(TAG,""String_Node_Str"" + taskId);
      return;
    }
    final TaskStack stack=task.mStack;
    stack.removeTask(task);
    stack.getDisplayContent().layoutNeeded=true;
  }
}"
1883,"public void validateAppTokens(int stackId,List<TaskGroup> tasks){
synchronized (mWindowMap) {
    int t=tasks.size() - 1;
    if (t < 0) {
      Slog.w(TAG,""String_Node_Str"");
      return;
    }
    TaskGroup task=tasks.get(0);
    int taskId=task.taskId;
    Task targetTask=mTaskIdToTask.get(taskId);
    DisplayContent displayContent=targetTask.getDisplayContent();
    if (displayContent == null) {
      Slog.w(TAG,""String_Node_Str"" + taskId);
      return;
    }
    final ArrayList<Task> localTasks=mStackIdToStack.get(stackId).getTasks();
    int taskNdx;
    for (taskNdx=localTasks.size() - 1; taskNdx >= 0 && t >= 0; --taskNdx, --t) {
      AppTokenList localTokens=localTasks.get(taskNdx).mAppTokens;
      task=tasks.get(t);
      List<IApplicationToken> tokens=task.tokens;
      DisplayContent lastDisplayContent=displayContent;
      displayContent=mTaskIdToTask.get(taskId).getDisplayContent();
      if (displayContent != lastDisplayContent) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
      int tokenNdx;
      int v;
      for (tokenNdx=localTokens.size() - 1, v=task.tokens.size() - 1; tokenNdx >= 0 && v >= 0; ) {
        final AppWindowToken atoken=localTokens.get(tokenNdx);
        if (atoken.removed) {
          --tokenNdx;
          continue;
        }
        if (tokens.get(v) != atoken.token) {
          break;
        }
        --tokenNdx;
        v--;
      }
      if (tokenNdx >= 0 || v >= 0) {
        break;
      }
    }
    if (taskNdx >= 0 || t >= 0) {
      Slog.w(TAG,""String_Node_Str"" + tasks);
      Slog.w(TAG,""String_Node_Str"" + displayContent.getTasks());
      Slog.w(TAG,""String_Node_Str"" + Debug.getCallers(4));
    }
  }
}","public void validateAppTokens(int stackId,List<TaskGroup> tasks){
synchronized (mWindowMap) {
    int t=tasks.size() - 1;
    if (t < 0) {
      Slog.w(TAG,""String_Node_Str"");
      return;
    }
    TaskGroup task=tasks.get(0);
    int taskId=task.taskId;
    Task targetTask=mTaskIdToTask.get(taskId);
    DisplayContent displayContent=targetTask.getDisplayContent();
    if (displayContent == null) {
      Slog.w(TAG,""String_Node_Str"" + taskId);
      return;
    }
    final ArrayList<Task> localTasks=mStackIdToStack.get(stackId).getTasks();
    int taskNdx;
    for (taskNdx=localTasks.size() - 1; taskNdx >= 0 && t >= 0; --taskNdx, --t) {
      AppTokenList localTokens=localTasks.get(taskNdx).mAppTokens;
      task=tasks.get(t);
      List<IApplicationToken> tokens=task.tokens;
      DisplayContent lastDisplayContent=displayContent;
      displayContent=mTaskIdToTask.get(taskId).getDisplayContent();
      if (displayContent != lastDisplayContent) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
      int tokenNdx;
      int v;
      for (tokenNdx=localTokens.size() - 1, v=task.tokens.size() - 1; tokenNdx >= 0 && v >= 0; ) {
        final AppWindowToken atoken=localTokens.get(tokenNdx);
        if (atoken.removed) {
          --tokenNdx;
          continue;
        }
        if (tokens.get(v) != atoken.token) {
          break;
        }
        --tokenNdx;
        v--;
      }
      if (tokenNdx >= 0 || v >= 0) {
        break;
      }
    }
    if (taskNdx >= 0 || t >= 0) {
      Slog.w(TAG,""String_Node_Str"" + tasks);
      Slog.w(TAG,""String_Node_Str"" + localTasks);
      Slog.w(TAG,""String_Node_Str"" + Debug.getCallers(4));
    }
  }
}"
1884,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  super.onLayout(changed,l,t,r,b);
  mIsLayoutDirty=false;
  if (mChildToScrollTo != null && isViewDescendantOf(mChildToScrollTo,this)) {
    scrollToChild(mChildToScrollTo);
  }
  mChildToScrollTo=null;
  final View child=getChildAt(0);
  final int childHeight=child.getMeasuredHeight();
  if (!hasLayout()) {
    final int scrollRange=Math.max(0,childHeight - (b - t - mPaddingBottom- mPaddingTop));
    if (mSavedState != null) {
      mScrollY=mSavedState.scrollPosition;
      mSavedState=null;
    }
    if (mScrollY > scrollRange) {
      mScrollY=scrollRange;
    }
 else     if (mScrollY < 0) {
      mScrollY=0;
    }
  }
  scrollTo(mScrollX,mScrollY);
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  super.onLayout(changed,l,t,r,b);
  mIsLayoutDirty=false;
  if (mChildToScrollTo != null && isViewDescendantOf(mChildToScrollTo,this)) {
    scrollToChild(mChildToScrollTo);
  }
  mChildToScrollTo=null;
  if (!hasLayout()) {
    if (mSavedState != null) {
      mScrollY=mSavedState.scrollPosition;
      mSavedState=null;
    }
    final int childHeight=(getChildCount() > 0) ? getChildAt(0).getMeasuredHeight() : 0;
    final int scrollRange=Math.max(0,childHeight - (b - t - mPaddingBottom- mPaddingTop));
    if (mScrollY > scrollRange) {
      mScrollY=scrollRange;
    }
 else     if (mScrollY < 0) {
      mScrollY=0;
    }
  }
  scrollTo(mScrollX,mScrollY);
}"
1885,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  super.onLayout(changed,l,t,r,b);
  mIsLayoutDirty=false;
  if (mChildToScrollTo != null && isViewDescendantOf(mChildToScrollTo,this)) {
    scrollToChild(mChildToScrollTo);
  }
  mChildToScrollTo=null;
  final View child=getChildAt(0);
  final int childHeight=child.getMeasuredHeight();
  if (!hasLayout()) {
    final int scrollRange=Math.max(0,childHeight - (b - t - mPaddingBottom- mPaddingTop));
    if (mSavedState != null) {
      mScrollY=mSavedState.scrollPosition;
      mSavedState=null;
    }
    if (mScrollY > scrollRange) {
      mScrollY=scrollRange;
    }
 else     if (mScrollY < 0) {
      mScrollY=0;
    }
  }
  scrollTo(mScrollX,mScrollY);
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  super.onLayout(changed,l,t,r,b);
  mIsLayoutDirty=false;
  if (mChildToScrollTo != null && isViewDescendantOf(mChildToScrollTo,this)) {
    scrollToChild(mChildToScrollTo);
  }
  mChildToScrollTo=null;
  if (!hasLayout()) {
    if (mSavedState != null) {
      mScrollY=mSavedState.scrollPosition;
      mSavedState=null;
    }
    final int childHeight=(getChildCount() > 0) ? getChildAt(0).getMeasuredHeight() : 0;
    final int scrollRange=Math.max(0,childHeight - (b - t - mPaddingBottom- mPaddingTop));
    if (mScrollY > scrollRange) {
      mScrollY=scrollRange;
    }
 else     if (mScrollY < 0) {
      mScrollY=0;
    }
  }
  scrollTo(mScrollX,mScrollY);
}"
1886,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  final View child=getChildAt(0);
  final int childWidth=child.getMeasuredWidth();
  final LayoutParams childParams=(LayoutParams)child.getLayoutParams();
  final int available=r - l - getPaddingLeftWithForeground()- getPaddingRightWithForeground()- childParams.leftMargin- childParams.rightMargin;
  final boolean forceLeftGravity=(childWidth > available);
  layoutChildren(l,t,r,b,forceLeftGravity);
  mIsLayoutDirty=false;
  if (mChildToScrollTo != null && isViewDescendantOf(mChildToScrollTo,this)) {
    scrollToChild(mChildToScrollTo);
  }
  mChildToScrollTo=null;
  if (!hasLayout()) {
    final int scrollRange=Math.max(0,childWidth - (r - l - mPaddingLeft- mPaddingRight));
    if (mSavedState != null) {
      if (isLayoutRtl() == mSavedState.isLayoutRtl) {
        mScrollX=mSavedState.scrollPosition;
      }
 else {
        mScrollX=scrollRange - mSavedState.scrollPosition;
      }
    }
 else {
      if (isLayoutRtl()) {
        mScrollX=scrollRange - mScrollX;
      }
    }
    if (mScrollX > scrollRange) {
      mScrollX=scrollRange;
    }
 else     if (mScrollX < 0) {
      mScrollX=0;
    }
  }
  scrollTo(mScrollX,mScrollY);
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  final View child=getChildAt(0);
  final int childWidth=child.getMeasuredWidth();
  final LayoutParams childParams=(LayoutParams)child.getLayoutParams();
  final int available=r - l - getPaddingLeftWithForeground()- getPaddingRightWithForeground()- childParams.leftMargin- childParams.rightMargin;
  final boolean forceLeftGravity=(childWidth > available);
  layoutChildren(l,t,r,b,forceLeftGravity);
  mIsLayoutDirty=false;
  if (mChildToScrollTo != null && isViewDescendantOf(mChildToScrollTo,this)) {
    scrollToChild(mChildToScrollTo);
  }
  mChildToScrollTo=null;
  if (!hasLayout()) {
    final int scrollRange=Math.max(0,childWidth - (r - l - mPaddingLeft- mPaddingRight));
    if (mSavedState != null) {
      if (isLayoutRtl() == mSavedState.isLayoutRtl) {
        mScrollX=mSavedState.scrollPosition;
      }
 else {
        mScrollX=scrollRange - mSavedState.scrollPosition;
      }
      mSavedState=null;
    }
 else {
      if (isLayoutRtl()) {
        mScrollX=scrollRange - mScrollX;
      }
    }
    if (mScrollX > scrollRange) {
      mScrollX=scrollRange;
    }
 else     if (mScrollX < 0) {
      mScrollX=0;
    }
  }
  scrollTo(mScrollX,mScrollY);
}"
1887,"private int getPaddingRightWithForeground(){
  return mForegroundInPadding ? Math.max(mPaddingRight,mForegroundPaddingRight) : mPaddingRight + mForegroundPaddingRight;
}","int getPaddingRightWithForeground(){
  return mForegroundInPadding ? Math.max(mPaddingRight,mForegroundPaddingRight) : mPaddingRight + mForegroundPaddingRight;
}"
1888,"/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=getPaddingLeftWithForeground();
  final int parentRight=right - left - getPaddingRightWithForeground();
  final int parentTop=getPaddingTopWithForeground();
  final int parentBottom=bottom - top - getPaddingBottomWithForeground();
  mForegroundBoundsChanged=true;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft;
      int childTop;
      int gravity=lp.gravity;
      if (gravity == -1) {
        gravity=DEFAULT_CHILD_GRAVITY;
      }
      final int layoutDirection=getLayoutDirection();
      final int absoluteGravity=Gravity.getAbsoluteGravity(gravity,layoutDirection);
      final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
case Gravity.LEFT:
        childLeft=parentLeft + lp.leftMargin;
      break;
case Gravity.CENTER_HORIZONTAL:
    childLeft=parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin;
  break;
case Gravity.RIGHT:
childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}","/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  layoutChildren(left,top,right,bottom,false);
}"
1889,"private int getPaddingLeftWithForeground(){
  return mForegroundInPadding ? Math.max(mPaddingLeft,mForegroundPaddingLeft) : mPaddingLeft + mForegroundPaddingLeft;
}","int getPaddingLeftWithForeground(){
  return mForegroundInPadding ? Math.max(mPaddingLeft,mForegroundPaddingLeft) : mPaddingLeft + mForegroundPaddingLeft;
}"
1890,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  super.onLayout(changed,l,t,r,b);
  mIsLayoutDirty=false;
  if (mChildToScrollTo != null && isViewDescendantOf(mChildToScrollTo,this)) {
    scrollToChild(mChildToScrollTo);
  }
  mChildToScrollTo=null;
  scrollTo(mScrollX,mScrollY);
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  final View child=getChildAt(0);
  final int childWidth=child.getMeasuredWidth();
  final LayoutParams childParams=(LayoutParams)child.getLayoutParams();
  final int available=r - l - getPaddingLeftWithForeground()- getPaddingRightWithForeground()- childParams.leftMargin- childParams.rightMargin;
  final boolean forceLeftGravity=(childWidth > available);
  layoutChildren(l,t,r,b,forceLeftGravity);
  mIsLayoutDirty=false;
  if (mChildToScrollTo != null && isViewDescendantOf(mChildToScrollTo,this)) {
    scrollToChild(mChildToScrollTo);
  }
  mChildToScrollTo=null;
  if (!hasLayout()) {
    final int scrollRange=Math.max(0,childWidth - (r - l - mPaddingLeft- mPaddingRight));
    if (mSavedState != null) {
      if (isLayoutRtl() == mSavedState.isLayoutRtl) {
        mScrollX=mSavedState.scrollPosition;
      }
 else {
        mScrollX=scrollRange - mSavedState.scrollPosition;
      }
    }
 else {
      if (isLayoutRtl()) {
        mScrollX=scrollRange - mScrollX;
      }
    }
    if (mScrollX > scrollRange) {
      mScrollX=scrollRange;
    }
 else     if (mScrollX < 0) {
      mScrollX=0;
    }
  }
  scrollTo(mScrollX,mScrollY);
}"
1891,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  final View child=getChildAt(0);
  final int childWidth=child.getMeasuredWidth();
  final LayoutParams childParams=(LayoutParams)child.getLayoutParams();
  final int available=r - l - getPaddingLeftWithForeground()- getPaddingRightWithForeground()- childParams.leftMargin- childParams.rightMargin;
  final boolean forceLeftGravity=(childWidth > available);
  layoutChildren(l,t,r,b,forceLeftGravity);
  mIsLayoutDirty=false;
  if (mChildToScrollTo != null && isViewDescendantOf(mChildToScrollTo,this)) {
    scrollToChild(mChildToScrollTo);
  }
  mChildToScrollTo=null;
  if (!hasLayout()) {
    final int scrollRange=Math.max(0,childWidth - (r - l - mPaddingLeft- mPaddingRight));
    if (mSavedState != null) {
      if (isLayoutRtl() == mSavedState.isLayoutRtl) {
        mScrollX=mSavedState.scrollPosition;
      }
 else {
        mScrollX=scrollRange - mSavedState.scrollPosition;
      }
    }
 else {
      if (isLayoutRtl()) {
        mScrollX=scrollRange - mScrollX;
      }
    }
    if (mScrollX > scrollRange) {
      mScrollX=scrollRange;
    }
 else     if (mScrollX < 0) {
      mScrollX=0;
    }
  }
  scrollTo(mScrollX,mScrollY);
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  final View child=getChildAt(0);
  final int childWidth=child.getMeasuredWidth();
  final LayoutParams childParams=(LayoutParams)child.getLayoutParams();
  final int available=r - l - getPaddingLeftWithForeground()- getPaddingRightWithForeground()- childParams.leftMargin- childParams.rightMargin;
  final boolean forceLeftGravity=(childWidth > available);
  layoutChildren(l,t,r,b,forceLeftGravity);
  mIsLayoutDirty=false;
  if (mChildToScrollTo != null && isViewDescendantOf(mChildToScrollTo,this)) {
    scrollToChild(mChildToScrollTo);
  }
  mChildToScrollTo=null;
  if (!hasLayout()) {
    final int scrollRange=Math.max(0,childWidth - (r - l - mPaddingLeft- mPaddingRight));
    if (mSavedState != null) {
      if (isLayoutRtl() == mSavedState.isLayoutRtl) {
        mScrollX=mSavedState.scrollPosition;
      }
 else {
        mScrollX=scrollRange - mSavedState.scrollPosition;
      }
      mSavedState=null;
    }
 else {
      if (isLayoutRtl()) {
        mScrollX=scrollRange - mScrollX;
      }
    }
    if (mScrollX > scrollRange) {
      mScrollX=scrollRange;
    }
 else     if (mScrollX < 0) {
      mScrollX=0;
    }
  }
  scrollTo(mScrollX,mScrollY);
}"
1892,"private int getPaddingRightWithForeground(){
  return mForegroundInPadding ? Math.max(mPaddingRight,mForegroundPaddingRight) : mPaddingRight + mForegroundPaddingRight;
}","int getPaddingRightWithForeground(){
  return mForegroundInPadding ? Math.max(mPaddingRight,mForegroundPaddingRight) : mPaddingRight + mForegroundPaddingRight;
}"
1893,"/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=getPaddingLeftWithForeground();
  final int parentRight=right - left - getPaddingRightWithForeground();
  final int parentTop=getPaddingTopWithForeground();
  final int parentBottom=bottom - top - getPaddingBottomWithForeground();
  mForegroundBoundsChanged=true;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft;
      int childTop;
      int gravity=lp.gravity;
      if (gravity == -1) {
        gravity=DEFAULT_CHILD_GRAVITY;
      }
      final int layoutDirection=getLayoutDirection();
      final int absoluteGravity=Gravity.getAbsoluteGravity(gravity,layoutDirection);
      final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
case Gravity.LEFT:
        childLeft=parentLeft + lp.leftMargin;
      break;
case Gravity.CENTER_HORIZONTAL:
    childLeft=parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin;
  break;
case Gravity.RIGHT:
childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}","/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  layoutChildren(left,top,right,bottom,false);
}"
1894,"private int getPaddingLeftWithForeground(){
  return mForegroundInPadding ? Math.max(mPaddingLeft,mForegroundPaddingLeft) : mPaddingLeft + mForegroundPaddingLeft;
}","int getPaddingLeftWithForeground(){
  return mForegroundInPadding ? Math.max(mPaddingLeft,mForegroundPaddingLeft) : mPaddingLeft + mForegroundPaddingLeft;
}"
1895,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  super.onLayout(changed,l,t,r,b);
  mIsLayoutDirty=false;
  if (mChildToScrollTo != null && isViewDescendantOf(mChildToScrollTo,this)) {
    scrollToChild(mChildToScrollTo);
  }
  mChildToScrollTo=null;
  scrollTo(mScrollX,mScrollY);
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  final View child=getChildAt(0);
  final int childWidth=child.getMeasuredWidth();
  final LayoutParams childParams=(LayoutParams)child.getLayoutParams();
  final int available=r - l - getPaddingLeftWithForeground()- getPaddingRightWithForeground()- childParams.leftMargin- childParams.rightMargin;
  final boolean forceLeftGravity=(childWidth > available);
  layoutChildren(l,t,r,b,forceLeftGravity);
  mIsLayoutDirty=false;
  if (mChildToScrollTo != null && isViewDescendantOf(mChildToScrollTo,this)) {
    scrollToChild(mChildToScrollTo);
  }
  mChildToScrollTo=null;
  if (!hasLayout()) {
    final int scrollRange=Math.max(0,childWidth - (r - l - mPaddingLeft- mPaddingRight));
    if (mSavedState != null) {
      if (isLayoutRtl() == mSavedState.isLayoutRtl) {
        mScrollX=mSavedState.scrollPosition;
      }
 else {
        mScrollX=scrollRange - mSavedState.scrollPosition;
      }
    }
 else {
      if (isLayoutRtl()) {
        mScrollX=scrollRange - mScrollX;
      }
    }
    if (mScrollX > scrollRange) {
      mScrollX=scrollRange;
    }
 else     if (mScrollX < 0) {
      mScrollX=0;
    }
  }
  scrollTo(mScrollX,mScrollY);
}"
1896,"/** 
 * Private method containing a userId
 * @hide
 */
protected void onProvidersChanged(int userId){
}","/** 
 * Called when the set of available widgets changes (ie. widget containing packages are added, updated or removed, or widget components are enabled or disabled.)
 */
protected void onProvidersChanged(){
}"
1897,"public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_UPDATE:
{
      updateAppWidgetView(msg.arg1,(RemoteViews)msg.obj,msg.arg2);
      break;
    }
case HANDLE_PROVIDER_CHANGED:
{
    onProviderChanged(msg.arg1,(AppWidgetProviderInfo)msg.obj);
    break;
  }
case HANDLE_PROVIDERS_CHANGED:
{
  onProvidersChanged(msg.arg1);
  break;
}
case HANDLE_VIEW_DATA_CHANGED:
{
viewDataChanged(msg.arg1,msg.arg2,(Integer)msg.obj);
break;
}
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_UPDATE:
{
      updateAppWidgetView(msg.arg1,(RemoteViews)msg.obj,msg.arg2);
      break;
    }
case HANDLE_PROVIDER_CHANGED:
{
    onProviderChanged(msg.arg1,(AppWidgetProviderInfo)msg.obj);
    break;
  }
case HANDLE_PROVIDERS_CHANGED:
{
  onProvidersChanged();
  break;
}
case HANDLE_VIEW_DATA_CHANGED:
{
viewDataChanged(msg.arg1,msg.arg2,(Integer)msg.obj);
break;
}
}
}"
1898,"/** 
 * Sets the clockwise rotation angle in degrees relative to the orientation of the camera. This affects the pictures returned from JPEG   {@link PictureCallback}. The camera driver may set orientation in the EXIF header without rotating the picture. Or the driver may rotate the picture and the EXIF thumbnail. If the Jpeg picture is rotated, the orientation in the EXIF header will be missing or 1 (row #0 is top and column #0 is left side). <p>If applications want to rotate the picture to match the orientation of what users see, apps should use   {@link android.view.OrientationEventListener} and {@link CameraInfo}. The value from OrientationEventListener is relative to the natural orientation of the device. CameraInfo.orientation is the angle between camera orientation and natural device orientation. The sum of the two is the rotation angle for back-facing camera. The difference of the two is the rotation angle for front-facing camera. Note that the JPEG pictures of front-facing cameras are not mirrored as in preview display. <p>For example, suppose the natural orientation of the device is portrait. The device is rotated 270 degrees clockwise, so the device orientation is 270. Suppose a back-facing camera sensor is mounted in landscape and the top side of the camera sensor is aligned with the right edge of the display in natural orientation. So the camera orientation is 90. The rotation should be set to 0 (270 + 90). <p>The reference code is as follows. <pre> public void onOrientationChanged(int orientation) { if (orientation == ORIENTATION_UNKNOWN) return; android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); orientation = (orientation + 45) / 90 * 90; int rotation = 0; if (info.facing == CameraInfo.CAMERA_FACING_FRONT) { rotation = (info.orientation - orientation + 360) % 360; } else {  // back-facing camera rotation = (info.orientation + orientation) % 360; } mParameters.setRotation(rotation); } </pre>
 * @param rotation The rotation angle in degrees relative to theorientation of the camera. Rotation can only be 0, 90, 180 or 270.
 * @throws IllegalArgumentException if rotation value is invalid.
 * @see android.view.OrientationEventListener
 * @see #getCameraInfo(int,CameraInfo)
 */
public void setRotation(int rotation){
  if (rotation == 0 || rotation == 90 || rotation == 180 || rotation == 270) {
    set(KEY_ROTATION,Integer.toString(rotation));
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + rotation);
  }
}","/** 
 * Sets the clockwise rotation angle in degrees relative to the orientation of the camera. This affects the pictures returned from JPEG   {@link PictureCallback}. The camera driver may set orientation in the EXIF header without rotating the picture. Or the driver may rotate the picture and the EXIF thumbnail. If the Jpeg picture is rotated, the orientation in the EXIF header will be missing or 1 (row #0 is top and column #0 is left side). <p> If applications want to rotate the picture to match the orientation of what users see, apps should use  {@link android.view.OrientationEventListener} and{@link android.hardware.Camera.CameraInfo}. The value from OrientationEventListener is relative to the natural orientation of the device. CameraInfo.orientation is the angle between camera orientation and natural device orientation. The sum of the two is the rotation angle for back-facing camera. The difference of the two is the rotation angle for front-facing camera. Note that the JPEG pictures of front-facing cameras are not mirrored as in preview display. <p> For example, suppose the natural orientation of the device is portrait. The device is rotated 270 degrees clockwise, so the device orientation is 270. Suppose a back-facing camera sensor is mounted in landscape and the top side of the camera sensor is aligned with the right edge of the display in natural orientation. So the camera orientation is 90. The rotation should be set to 0 (270 + 90). <p>The reference code is as follows. <pre> public void onOrientationChanged(int orientation) { if (orientation == ORIENTATION_UNKNOWN) return; android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); orientation = (orientation + 45) / 90 * 90; int rotation = 0; if (info.facing == CameraInfo.CAMERA_FACING_FRONT) { rotation = (info.orientation - orientation + 360) % 360; } else {  // back-facing camera rotation = (info.orientation + orientation) % 360; } mParameters.setRotation(rotation); } </pre>
 * @param rotation The rotation angle in degrees relative to theorientation of the camera. Rotation can only be 0, 90, 180 or 270.
 * @throws IllegalArgumentException if rotation value is invalid.
 * @see android.view.OrientationEventListener
 * @see #getCameraInfo(int,CameraInfo)
 */
public void setRotation(int rotation){
  if (rotation == 0 || rotation == 90 || rotation == 180 || rotation == 270) {
    set(KEY_ROTATION,Integer.toString(rotation));
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + rotation);
  }
}"
1899,"/** 
 * Sets the clockwise rotation angle in degrees relative to the orientation of the camera. This affects the pictures returned from JPEG   {@link PictureCallback}. The camera driver may set orientation in the EXIF header without rotating the picture. Or the driver may rotate the picture and the EXIF thumbnail. If the Jpeg picture is rotated, the orientation in the EXIF header will be missing or 1 (row #0 is top and column #0 is left side). <p>If applications want to rotate the picture to match the orientation of what users see, apps should use   {@link android.view.OrientationEventListener} and {@link CameraInfo}. The value from OrientationEventListener is relative to the natural orientation of the device. CameraInfo.orientation is the angle between camera orientation and natural device orientation. The sum of the two is the rotation angle for back-facing camera. The difference of the two is the rotation angle for front-facing camera. Note that the JPEG pictures of front-facing cameras are not mirrored as in preview display. <p>For example, suppose the natural orientation of the device is portrait. The device is rotated 270 degrees clockwise, so the device orientation is 270. Suppose a back-facing camera sensor is mounted in landscape and the top side of the camera sensor is aligned with the right edge of the display in natural orientation. So the camera orientation is 90. The rotation should be set to 0 (270 + 90). <p>The reference code is as follows. <pre> public void onOrientationChanged(int orientation) { if (orientation == ORIENTATION_UNKNOWN) return; android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); orientation = (orientation + 45) / 90 * 90; int rotation = 0; if (info.facing == CameraInfo.CAMERA_FACING_FRONT) { rotation = (info.orientation - orientation + 360) % 360; } else {  // back-facing camera rotation = (info.orientation + orientation) % 360; } mParameters.setRotation(rotation); } </pre>
 * @param rotation The rotation angle in degrees relative to theorientation of the camera. Rotation can only be 0, 90, 180 or 270.
 * @throws IllegalArgumentException if rotation value is invalid.
 * @see android.view.OrientationEventListener
 * @see #getCameraInfo(int,CameraInfo)
 */
public void setRotation(int rotation){
  if (rotation == 0 || rotation == 90 || rotation == 180 || rotation == 270) {
    set(KEY_ROTATION,Integer.toString(rotation));
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + rotation);
  }
}","/** 
 * Sets the clockwise rotation angle in degrees relative to the orientation of the camera. This affects the pictures returned from JPEG   {@link PictureCallback}. The camera driver may set orientation in the EXIF header without rotating the picture. Or the driver may rotate the picture and the EXIF thumbnail. If the Jpeg picture is rotated, the orientation in the EXIF header will be missing or 1 (row #0 is top and column #0 is left side). <p> If applications want to rotate the picture to match the orientation of what users see, apps should use  {@link android.view.OrientationEventListener} and{@link android.hardware.Camera.CameraInfo}. The value from OrientationEventListener is relative to the natural orientation of the device. CameraInfo.orientation is the angle between camera orientation and natural device orientation. The sum of the two is the rotation angle for back-facing camera. The difference of the two is the rotation angle for front-facing camera. Note that the JPEG pictures of front-facing cameras are not mirrored as in preview display. <p> For example, suppose the natural orientation of the device is portrait. The device is rotated 270 degrees clockwise, so the device orientation is 270. Suppose a back-facing camera sensor is mounted in landscape and the top side of the camera sensor is aligned with the right edge of the display in natural orientation. So the camera orientation is 90. The rotation should be set to 0 (270 + 90). <p>The reference code is as follows. <pre> public void onOrientationChanged(int orientation) { if (orientation == ORIENTATION_UNKNOWN) return; android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); orientation = (orientation + 45) / 90 * 90; int rotation = 0; if (info.facing == CameraInfo.CAMERA_FACING_FRONT) { rotation = (info.orientation - orientation + 360) % 360; } else {  // back-facing camera rotation = (info.orientation + orientation) % 360; } mParameters.setRotation(rotation); } </pre>
 * @param rotation The rotation angle in degrees relative to theorientation of the camera. Rotation can only be 0, 90, 180 or 270.
 * @throws IllegalArgumentException if rotation value is invalid.
 * @see android.view.OrientationEventListener
 * @see #getCameraInfo(int,CameraInfo)
 */
public void setRotation(int rotation){
  if (rotation == 0 || rotation == 90 || rotation == 180 || rotation == 270) {
    set(KEY_ROTATION,Integer.toString(rotation));
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + rotation);
  }
}"
1900,"/** 
 * Create new SpellCheckSpans on the modified region.
 */
private void updateSpellCheckSpans(int start,int end,boolean createSpellChecker){
  if (mTextView.isTextEditable() && mTextView.isSuggestionsEnabled() && !(mTextView instanceof ExtractEditText)) {
    if (mSpellChecker == null && createSpellChecker) {
      mSpellChecker=new SpellChecker(mTextView);
    }
    if (mSpellChecker != null) {
      mSpellChecker.spellCheck(start,end);
    }
  }
}","/** 
 * Create new SpellCheckSpans on the modified region.
 */
private void updateSpellCheckSpans(int start,int end,boolean createSpellChecker){
  mTextView.removeAdjacentSuggestionSpans(start);
  mTextView.removeAdjacentSuggestionSpans(end);
  if (mTextView.isTextEditable() && mTextView.isSuggestionsEnabled() && !(mTextView instanceof ExtractEditText)) {
    if (mSpellChecker == null && createSpellChecker) {
      mSpellChecker=new SpellChecker(mTextView);
    }
    if (mSpellChecker != null) {
      mSpellChecker.spellCheck(start,end);
    }
  }
}"
1901,"private void sendBeforeTextChanged(CharSequence text,int start,int before,int after){
  if (mListeners != null) {
    final ArrayList<TextWatcher> list=mListeners;
    final int count=list.size();
    for (int i=0; i < count; i++) {
      list.get(i).beforeTextChanged(text,start,before,after);
    }
  }
  removeIntersectingSpans(start,start + before,SpellCheckSpan.class);
  removeIntersectingSpans(start,start + before,SuggestionSpan.class);
}","private void sendBeforeTextChanged(CharSequence text,int start,int before,int after){
  if (mListeners != null) {
    final ArrayList<TextWatcher> list=mListeners;
    final int count=list.size();
    for (int i=0; i < count; i++) {
      list.get(i).beforeTextChanged(text,start,before,after);
    }
  }
  removeIntersectingNonAdjacentSpans(start,start + before,SpellCheckSpan.class);
  removeIntersectingNonAdjacentSpans(start,start + before,SuggestionSpan.class);
}"
1902,"@Override public void requestLocationUpdates(LocationRequest request,ILocationListener listener,PendingIntent intent,String packageName){
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  checkPackageName(packageName);
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  LocationRequest sanitizedRequest=createSanitizedRequest(request,allowedResolutionLevel);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  long identity=Binder.clearCallingIdentity();
  try {
    checkLocationAccess(uid,packageName,allowedResolutionLevel);
    Receiver recevier=checkListenerOrIntent(listener,intent,pid,uid,packageName);
synchronized (mLock) {
      requestLocationUpdatesLocked(sanitizedRequest,recevier,pid,uid,packageName);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void requestLocationUpdates(LocationRequest request,ILocationListener listener,PendingIntent intent,String packageName){
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  checkPackageName(packageName);
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  LocationRequest sanitizedRequest=createSanitizedRequest(request,allowedResolutionLevel);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  long identity=Binder.clearCallingIdentity();
  try {
    checkLocationAccess(uid,packageName,allowedResolutionLevel);
synchronized (mLock) {
      Receiver recevier=checkListenerOrIntentLocked(listener,intent,pid,uid,packageName);
      requestLocationUpdatesLocked(sanitizedRequest,recevier,pid,uid,packageName);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}"
1903,"@Override public void removeUpdates(ILocationListener listener,PendingIntent intent,String packageName){
  checkPackageName(packageName);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  Receiver receiver=checkListenerOrIntent(listener,intent,pid,uid,packageName);
  long identity=Binder.clearCallingIdentity();
  try {
synchronized (mLock) {
      removeUpdatesLocked(receiver);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void removeUpdates(ILocationListener listener,PendingIntent intent,String packageName){
  checkPackageName(packageName);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
synchronized (mLock) {
    Receiver receiver=checkListenerOrIntentLocked(listener,intent,pid,uid,packageName);
    long identity=Binder.clearCallingIdentity();
    try {
      removeUpdatesLocked(receiver);
    }
  finally {
      Binder.restoreCallingIdentity(identity);
    }
  }
}"
1904,"@Override public void locationCallbackFinished(ILocationListener listener){
  IBinder binder=listener.asBinder();
  Receiver receiver=mReceivers.get(binder);
  if (receiver != null) {
synchronized (receiver) {
      long identity=Binder.clearCallingIdentity();
      receiver.decrementPendingBroadcastsLocked();
      Binder.restoreCallingIdentity(identity);
    }
  }
}","@Override public void locationCallbackFinished(ILocationListener listener){
synchronized (mLock) {
    IBinder binder=listener.asBinder();
    Receiver receiver=mReceivers.get(binder);
    if (receiver != null) {
synchronized (receiver) {
        long identity=Binder.clearCallingIdentity();
        receiver.decrementPendingBroadcastsLocked();
        Binder.restoreCallingIdentity(identity);
      }
    }
  }
}"
1905,"@Override public void requestLocationUpdates(LocationRequest request,ILocationListener listener,PendingIntent intent,String packageName){
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  checkPackageName(packageName);
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  LocationRequest sanitizedRequest=createSanitizedRequest(request,allowedResolutionLevel);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  long identity=Binder.clearCallingIdentity();
  try {
    checkLocationAccess(uid,packageName,allowedResolutionLevel);
    Receiver recevier=checkListenerOrIntent(listener,intent,pid,uid,packageName);
synchronized (mLock) {
      requestLocationUpdatesLocked(sanitizedRequest,recevier,pid,uid,packageName);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void requestLocationUpdates(LocationRequest request,ILocationListener listener,PendingIntent intent,String packageName){
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  checkPackageName(packageName);
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  LocationRequest sanitizedRequest=createSanitizedRequest(request,allowedResolutionLevel);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  long identity=Binder.clearCallingIdentity();
  try {
    checkLocationAccess(uid,packageName,allowedResolutionLevel);
synchronized (mLock) {
      Receiver recevier=checkListenerOrIntentLocked(listener,intent,pid,uid,packageName);
      requestLocationUpdatesLocked(sanitizedRequest,recevier,pid,uid,packageName);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}"
1906,"@Override public void removeUpdates(ILocationListener listener,PendingIntent intent,String packageName){
  checkPackageName(packageName);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  Receiver receiver=checkListenerOrIntent(listener,intent,pid,uid,packageName);
  long identity=Binder.clearCallingIdentity();
  try {
synchronized (mLock) {
      removeUpdatesLocked(receiver);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void removeUpdates(ILocationListener listener,PendingIntent intent,String packageName){
  checkPackageName(packageName);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
synchronized (mLock) {
    Receiver receiver=checkListenerOrIntentLocked(listener,intent,pid,uid,packageName);
    long identity=Binder.clearCallingIdentity();
    try {
      removeUpdatesLocked(receiver);
    }
  finally {
      Binder.restoreCallingIdentity(identity);
    }
  }
}"
1907,"@Override public void locationCallbackFinished(ILocationListener listener){
  IBinder binder=listener.asBinder();
  Receiver receiver=mReceivers.get(binder);
  if (receiver != null) {
synchronized (receiver) {
      long identity=Binder.clearCallingIdentity();
      receiver.decrementPendingBroadcastsLocked();
      Binder.restoreCallingIdentity(identity);
    }
  }
}","@Override public void locationCallbackFinished(ILocationListener listener){
synchronized (mLock) {
    IBinder binder=listener.asBinder();
    Receiver receiver=mReceivers.get(binder);
    if (receiver != null) {
synchronized (receiver) {
        long identity=Binder.clearCallingIdentity();
        receiver.decrementPendingBroadcastsLocked();
        Binder.restoreCallingIdentity(identity);
      }
    }
  }
}"
1908,"@Override public void requestLocationUpdates(LocationRequest request,ILocationListener listener,PendingIntent intent,String packageName){
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  checkPackageName(packageName);
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  LocationRequest sanitizedRequest=createSanitizedRequest(request,allowedResolutionLevel);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  long identity=Binder.clearCallingIdentity();
  try {
    checkLocationAccess(uid,packageName,allowedResolutionLevel);
    Receiver recevier=checkListenerOrIntent(listener,intent,pid,uid,packageName);
synchronized (mLock) {
      requestLocationUpdatesLocked(sanitizedRequest,recevier,pid,uid,packageName);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void requestLocationUpdates(LocationRequest request,ILocationListener listener,PendingIntent intent,String packageName){
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  checkPackageName(packageName);
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  LocationRequest sanitizedRequest=createSanitizedRequest(request,allowedResolutionLevel);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  long identity=Binder.clearCallingIdentity();
  try {
    checkLocationAccess(uid,packageName,allowedResolutionLevel);
synchronized (mLock) {
      Receiver recevier=checkListenerOrIntentLocked(listener,intent,pid,uid,packageName);
      requestLocationUpdatesLocked(sanitizedRequest,recevier,pid,uid,packageName);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}"
1909,"@Override public void removeUpdates(ILocationListener listener,PendingIntent intent,String packageName){
  checkPackageName(packageName);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  Receiver receiver=checkListenerOrIntent(listener,intent,pid,uid,packageName);
  long identity=Binder.clearCallingIdentity();
  try {
synchronized (mLock) {
      removeUpdatesLocked(receiver);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void removeUpdates(ILocationListener listener,PendingIntent intent,String packageName){
  checkPackageName(packageName);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
synchronized (mLock) {
    Receiver receiver=checkListenerOrIntentLocked(listener,intent,pid,uid,packageName);
    long identity=Binder.clearCallingIdentity();
    try {
      removeUpdatesLocked(receiver);
    }
  finally {
      Binder.restoreCallingIdentity(identity);
    }
  }
}"
1910,"@Override public void locationCallbackFinished(ILocationListener listener){
  IBinder binder=listener.asBinder();
  Receiver receiver=mReceivers.get(binder);
  if (receiver != null) {
synchronized (receiver) {
      long identity=Binder.clearCallingIdentity();
      receiver.decrementPendingBroadcastsLocked();
      Binder.restoreCallingIdentity(identity);
    }
  }
}","@Override public void locationCallbackFinished(ILocationListener listener){
synchronized (mLock) {
    IBinder binder=listener.asBinder();
    Receiver receiver=mReceivers.get(binder);
    if (receiver != null) {
synchronized (receiver) {
        long identity=Binder.clearCallingIdentity();
        receiver.decrementPendingBroadcastsLocked();
        Binder.restoreCallingIdentity(identity);
      }
    }
  }
}"
1911,"@Override public void requestLocationUpdates(LocationRequest request,ILocationListener listener,PendingIntent intent,String packageName){
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  checkPackageName(packageName);
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  LocationRequest sanitizedRequest=createSanitizedRequest(request,allowedResolutionLevel);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  long identity=Binder.clearCallingIdentity();
  try {
    checkLocationAccess(uid,packageName,allowedResolutionLevel);
    Receiver recevier=checkListenerOrIntent(listener,intent,pid,uid,packageName);
synchronized (mLock) {
      requestLocationUpdatesLocked(sanitizedRequest,recevier,pid,uid,packageName);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void requestLocationUpdates(LocationRequest request,ILocationListener listener,PendingIntent intent,String packageName){
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  checkPackageName(packageName);
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  LocationRequest sanitizedRequest=createSanitizedRequest(request,allowedResolutionLevel);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  long identity=Binder.clearCallingIdentity();
  try {
    checkLocationAccess(uid,packageName,allowedResolutionLevel);
synchronized (mLock) {
      Receiver recevier=checkListenerOrIntentLocked(listener,intent,pid,uid,packageName);
      requestLocationUpdatesLocked(sanitizedRequest,recevier,pid,uid,packageName);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}"
1912,"@Override public void removeUpdates(ILocationListener listener,PendingIntent intent,String packageName){
  checkPackageName(packageName);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  Receiver receiver=checkListenerOrIntent(listener,intent,pid,uid,packageName);
  long identity=Binder.clearCallingIdentity();
  try {
synchronized (mLock) {
      removeUpdatesLocked(receiver);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void removeUpdates(ILocationListener listener,PendingIntent intent,String packageName){
  checkPackageName(packageName);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
synchronized (mLock) {
    Receiver receiver=checkListenerOrIntentLocked(listener,intent,pid,uid,packageName);
    long identity=Binder.clearCallingIdentity();
    try {
      removeUpdatesLocked(receiver);
    }
  finally {
      Binder.restoreCallingIdentity(identity);
    }
  }
}"
1913,"@Override public void locationCallbackFinished(ILocationListener listener){
  IBinder binder=listener.asBinder();
  Receiver receiver=mReceivers.get(binder);
  if (receiver != null) {
synchronized (receiver) {
      long identity=Binder.clearCallingIdentity();
      receiver.decrementPendingBroadcastsLocked();
      Binder.restoreCallingIdentity(identity);
    }
  }
}","@Override public void locationCallbackFinished(ILocationListener listener){
synchronized (mLock) {
    IBinder binder=listener.asBinder();
    Receiver receiver=mReceivers.get(binder);
    if (receiver != null) {
synchronized (receiver) {
        long identity=Binder.clearCallingIdentity();
        receiver.decrementPendingBroadcastsLocked();
        Binder.restoreCallingIdentity(identity);
      }
    }
  }
}"
1914,"@Override public void requestLocationUpdates(LocationRequest request,ILocationListener listener,PendingIntent intent,String packageName){
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  checkPackageName(packageName);
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  LocationRequest sanitizedRequest=createSanitizedRequest(request,allowedResolutionLevel);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  long identity=Binder.clearCallingIdentity();
  try {
    checkLocationAccess(uid,packageName,allowedResolutionLevel);
    Receiver recevier=checkListenerOrIntent(listener,intent,pid,uid,packageName);
synchronized (mLock) {
      requestLocationUpdatesLocked(sanitizedRequest,recevier,pid,uid,packageName);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void requestLocationUpdates(LocationRequest request,ILocationListener listener,PendingIntent intent,String packageName){
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  checkPackageName(packageName);
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  LocationRequest sanitizedRequest=createSanitizedRequest(request,allowedResolutionLevel);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  long identity=Binder.clearCallingIdentity();
  try {
    checkLocationAccess(uid,packageName,allowedResolutionLevel);
synchronized (mLock) {
      Receiver recevier=checkListenerOrIntentLocked(listener,intent,pid,uid,packageName);
      requestLocationUpdatesLocked(sanitizedRequest,recevier,pid,uid,packageName);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}"
1915,"@Override public void removeUpdates(ILocationListener listener,PendingIntent intent,String packageName){
  checkPackageName(packageName);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  Receiver receiver=checkListenerOrIntent(listener,intent,pid,uid,packageName);
  long identity=Binder.clearCallingIdentity();
  try {
synchronized (mLock) {
      removeUpdatesLocked(receiver);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void removeUpdates(ILocationListener listener,PendingIntent intent,String packageName){
  checkPackageName(packageName);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
synchronized (mLock) {
    Receiver receiver=checkListenerOrIntentLocked(listener,intent,pid,uid,packageName);
    long identity=Binder.clearCallingIdentity();
    try {
      removeUpdatesLocked(receiver);
    }
  finally {
      Binder.restoreCallingIdentity(identity);
    }
  }
}"
1916,"@Override public void locationCallbackFinished(ILocationListener listener){
  IBinder binder=listener.asBinder();
  Receiver receiver=mReceivers.get(binder);
  if (receiver != null) {
synchronized (receiver) {
      long identity=Binder.clearCallingIdentity();
      receiver.decrementPendingBroadcastsLocked();
      Binder.restoreCallingIdentity(identity);
    }
  }
}","@Override public void locationCallbackFinished(ILocationListener listener){
synchronized (mLock) {
    IBinder binder=listener.asBinder();
    Receiver receiver=mReceivers.get(binder);
    if (receiver != null) {
synchronized (receiver) {
        long identity=Binder.clearCallingIdentity();
        receiver.decrementPendingBroadcastsLocked();
        Binder.restoreCallingIdentity(identity);
      }
    }
  }
}"
1917,"/** 
 * Private method containing a userId
 * @hide
 */
protected void onProvidersChanged(int userId){
}","/** 
 * Called when the set of available widgets changes (ie. widget containing packages are added, updated or removed, or widget components are enabled or disabled.)
 */
protected void onProvidersChanged(){
}"
1918,"public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_UPDATE:
{
      updateAppWidgetView(msg.arg1,(RemoteViews)msg.obj,msg.arg2);
      break;
    }
case HANDLE_PROVIDER_CHANGED:
{
    onProviderChanged(msg.arg1,(AppWidgetProviderInfo)msg.obj);
    break;
  }
case HANDLE_PROVIDERS_CHANGED:
{
  onProvidersChanged(msg.arg1);
  break;
}
case HANDLE_VIEW_DATA_CHANGED:
{
viewDataChanged(msg.arg1,msg.arg2,(Integer)msg.obj);
break;
}
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_UPDATE:
{
      updateAppWidgetView(msg.arg1,(RemoteViews)msg.obj,msg.arg2);
      break;
    }
case HANDLE_PROVIDER_CHANGED:
{
    onProviderChanged(msg.arg1,(AppWidgetProviderInfo)msg.obj);
    break;
  }
case HANDLE_PROVIDERS_CHANGED:
{
  onProvidersChanged();
  break;
}
case HANDLE_VIEW_DATA_CHANGED:
{
viewDataChanged(msg.arg1,msg.arg2,(Integer)msg.obj);
break;
}
}
}"
1919,"/** 
 * Private method containing a userId
 * @hide
 */
protected void onProvidersChanged(int userId){
}","/** 
 * Called when the set of available widgets changes (ie. widget containing packages are added, updated or removed, or widget components are enabled or disabled.)
 */
protected void onProvidersChanged(){
}"
1920,"public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_UPDATE:
{
      updateAppWidgetView(msg.arg1,(RemoteViews)msg.obj,msg.arg2);
      break;
    }
case HANDLE_PROVIDER_CHANGED:
{
    onProviderChanged(msg.arg1,(AppWidgetProviderInfo)msg.obj);
    break;
  }
case HANDLE_PROVIDERS_CHANGED:
{
  onProvidersChanged(msg.arg1);
  break;
}
case HANDLE_VIEW_DATA_CHANGED:
{
viewDataChanged(msg.arg1,msg.arg2,(Integer)msg.obj);
break;
}
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_UPDATE:
{
      updateAppWidgetView(msg.arg1,(RemoteViews)msg.obj,msg.arg2);
      break;
    }
case HANDLE_PROVIDER_CHANGED:
{
    onProviderChanged(msg.arg1,(AppWidgetProviderInfo)msg.obj);
    break;
  }
case HANDLE_PROVIDERS_CHANGED:
{
  onProvidersChanged();
  break;
}
case HANDLE_VIEW_DATA_CHANGED:
{
viewDataChanged(msg.arg1,msg.arg2,(Integer)msg.obj);
break;
}
}
}"
1921,"/** 
 * Private method containing a userId
 * @hide
 */
protected void onProvidersChanged(int userId){
}","/** 
 * Called when the set of available widgets changes (ie. widget containing packages are added, updated or removed, or widget components are enabled or disabled.)
 */
protected void onProvidersChanged(){
}"
1922,"public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_UPDATE:
{
      updateAppWidgetView(msg.arg1,(RemoteViews)msg.obj,msg.arg2);
      break;
    }
case HANDLE_PROVIDER_CHANGED:
{
    onProviderChanged(msg.arg1,(AppWidgetProviderInfo)msg.obj);
    break;
  }
case HANDLE_PROVIDERS_CHANGED:
{
  onProvidersChanged(msg.arg1);
  break;
}
case HANDLE_VIEW_DATA_CHANGED:
{
viewDataChanged(msg.arg1,msg.arg2,(Integer)msg.obj);
break;
}
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_UPDATE:
{
      updateAppWidgetView(msg.arg1,(RemoteViews)msg.obj,msg.arg2);
      break;
    }
case HANDLE_PROVIDER_CHANGED:
{
    onProviderChanged(msg.arg1,(AppWidgetProviderInfo)msg.obj);
    break;
  }
case HANDLE_PROVIDERS_CHANGED:
{
  onProvidersChanged();
  break;
}
case HANDLE_VIEW_DATA_CHANGED:
{
viewDataChanged(msg.arg1,msg.arg2,(Integer)msg.obj);
break;
}
}
}"
1923,"/** 
 * Create new SpellCheckSpans on the modified region.
 */
private void updateSpellCheckSpans(int start,int end,boolean createSpellChecker){
  if (mTextView.isTextEditable() && mTextView.isSuggestionsEnabled() && !(mTextView instanceof ExtractEditText)) {
    if (mSpellChecker == null && createSpellChecker) {
      mSpellChecker=new SpellChecker(mTextView);
    }
    if (mSpellChecker != null) {
      mSpellChecker.spellCheck(start,end);
    }
  }
}","/** 
 * Create new SpellCheckSpans on the modified region.
 */
private void updateSpellCheckSpans(int start,int end,boolean createSpellChecker){
  mTextView.removeAdjacentSuggestionSpans(start);
  mTextView.removeAdjacentSuggestionSpans(end);
  if (mTextView.isTextEditable() && mTextView.isSuggestionsEnabled() && !(mTextView instanceof ExtractEditText)) {
    if (mSpellChecker == null && createSpellChecker) {
      mSpellChecker=new SpellChecker(mTextView);
    }
    if (mSpellChecker != null) {
      mSpellChecker.spellCheck(start,end);
    }
  }
}"
1924,"private void sendBeforeTextChanged(CharSequence text,int start,int before,int after){
  if (mListeners != null) {
    final ArrayList<TextWatcher> list=mListeners;
    final int count=list.size();
    for (int i=0; i < count; i++) {
      list.get(i).beforeTextChanged(text,start,before,after);
    }
  }
  removeIntersectingSpans(start,start + before,SpellCheckSpan.class);
  removeIntersectingSpans(start,start + before,SuggestionSpan.class);
}","private void sendBeforeTextChanged(CharSequence text,int start,int before,int after){
  if (mListeners != null) {
    final ArrayList<TextWatcher> list=mListeners;
    final int count=list.size();
    for (int i=0; i < count; i++) {
      list.get(i).beforeTextChanged(text,start,before,after);
    }
  }
  removeIntersectingNonAdjacentSpans(start,start + before,SpellCheckSpan.class);
  removeIntersectingNonAdjacentSpans(start,start + before,SuggestionSpan.class);
}"
1925,"/** 
 * Private method containing a userId
 * @hide
 */
protected void onProvidersChanged(int userId){
}","/** 
 * Called when the set of available widgets changes (ie. widget containing packages are added, updated or removed, or widget components are enabled or disabled.)
 */
protected void onProvidersChanged(){
}"
1926,"public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_UPDATE:
{
      updateAppWidgetView(msg.arg1,(RemoteViews)msg.obj,msg.arg2);
      break;
    }
case HANDLE_PROVIDER_CHANGED:
{
    onProviderChanged(msg.arg1,(AppWidgetProviderInfo)msg.obj);
    break;
  }
case HANDLE_PROVIDERS_CHANGED:
{
  onProvidersChanged(msg.arg1);
  break;
}
case HANDLE_VIEW_DATA_CHANGED:
{
viewDataChanged(msg.arg1,msg.arg2,(Integer)msg.obj);
break;
}
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_UPDATE:
{
      updateAppWidgetView(msg.arg1,(RemoteViews)msg.obj,msg.arg2);
      break;
    }
case HANDLE_PROVIDER_CHANGED:
{
    onProviderChanged(msg.arg1,(AppWidgetProviderInfo)msg.obj);
    break;
  }
case HANDLE_PROVIDERS_CHANGED:
{
  onProvidersChanged();
  break;
}
case HANDLE_VIEW_DATA_CHANGED:
{
viewDataChanged(msg.arg1,msg.arg2,(Integer)msg.obj);
break;
}
}
}"
1927,"private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  mPlaybackState=dcs.playbackState;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + mTransportState + ""String_Node_Str""+ mPlaybackState);
}","private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + mTransportState + ""String_Node_Str""+ dcs.playbackState);
}"
1928,"@Override void onMusicClientIdChanged(int clientGeneration,boolean clearing,android.app.PendingIntent intent){
  if (DEBUGXPORT && (mClientGeneration != clientGeneration || clearing)) {
    Log.v(TAG,(clearing ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + clientGeneration);
  }
  mClientGeneration=clientGeneration;
  mTransportState=(clearing ? TRANSPORT_GONE : TRANSPORT_INVISIBLE);
  KeyguardHostView.this.post(mSwitchPageRunnable);
}","@Override void onMusicClientIdChanged(int clientGeneration,boolean clearing,android.app.PendingIntent intent){
  if (DEBUGXPORT && (mClientGeneration != clientGeneration || clearing)) {
    Log.v(TAG,(clearing ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + clientGeneration);
  }
  mClientGeneration=clientGeneration;
  final int newState=(clearing ? TRANSPORT_GONE : (mTransportState == TRANSPORT_VISIBLE ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  if (newState != mTransportState) {
    mTransportState=newState;
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    KeyguardHostView.this.post(mSwitchPageRunnable);
  }
}"
1929,"@Override public void onMusicPlaybackStateChanged(int playbackState,long eventTime){
  mPlaybackState=playbackState;
  if (DEBUGXPORT)   Log.v(TAG,""String_Node_Str"" + playbackState);
  if (mTransportState != TRANSPORT_GONE) {
    mTransportState=(isMusicPlaying(mPlaybackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE);
  }
  KeyguardHostView.this.post(mSwitchPageRunnable);
}","@Override public void onMusicPlaybackStateChanged(int playbackState,long eventTime){
  if (DEBUGXPORT)   Log.v(TAG,""String_Node_Str"" + playbackState);
  if (mTransportState != TRANSPORT_GONE) {
    final int newState=(isMusicPlaying(playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE);
    if (newState != mTransportState) {
      mTransportState=newState;
      if (DEBUGXPORT)       Log.v(TAG,""String_Node_Str"");
      KeyguardHostView.this.post(mSwitchPageRunnable);
    }
  }
}"
1930,"private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  mPlaybackState=dcs.playbackState;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + mTransportState + ""String_Node_Str""+ mPlaybackState);
}","private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + mTransportState + ""String_Node_Str""+ dcs.playbackState);
}"
1931,"@Override void onMusicClientIdChanged(int clientGeneration,boolean clearing,android.app.PendingIntent intent){
  if (DEBUGXPORT && (mClientGeneration != clientGeneration || clearing)) {
    Log.v(TAG,(clearing ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + clientGeneration);
  }
  mClientGeneration=clientGeneration;
  mTransportState=(clearing ? TRANSPORT_GONE : TRANSPORT_INVISIBLE);
  KeyguardHostView.this.post(mSwitchPageRunnable);
}","@Override void onMusicClientIdChanged(int clientGeneration,boolean clearing,android.app.PendingIntent intent){
  if (DEBUGXPORT && (mClientGeneration != clientGeneration || clearing)) {
    Log.v(TAG,(clearing ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + clientGeneration);
  }
  mClientGeneration=clientGeneration;
  final int newState=(clearing ? TRANSPORT_GONE : (mTransportState == TRANSPORT_VISIBLE ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  if (newState != mTransportState) {
    mTransportState=newState;
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    KeyguardHostView.this.post(mSwitchPageRunnable);
  }
}"
1932,"@Override public void onMusicPlaybackStateChanged(int playbackState,long eventTime){
  mPlaybackState=playbackState;
  if (DEBUGXPORT)   Log.v(TAG,""String_Node_Str"" + playbackState);
  if (mTransportState != TRANSPORT_GONE) {
    mTransportState=(isMusicPlaying(mPlaybackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE);
  }
  KeyguardHostView.this.post(mSwitchPageRunnable);
}","@Override public void onMusicPlaybackStateChanged(int playbackState,long eventTime){
  if (DEBUGXPORT)   Log.v(TAG,""String_Node_Str"" + playbackState);
  if (mTransportState != TRANSPORT_GONE) {
    final int newState=(isMusicPlaying(playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE);
    if (newState != mTransportState) {
      mTransportState=newState;
      if (DEBUGXPORT)       Log.v(TAG,""String_Node_Str"");
      KeyguardHostView.this.post(mSwitchPageRunnable);
    }
  }
}"
1933,"private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  mPlaybackState=dcs.playbackState;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + mTransportState + ""String_Node_Str""+ mPlaybackState);
}","private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + mTransportState + ""String_Node_Str""+ dcs.playbackState);
}"
1934,"@Override void onMusicClientIdChanged(int clientGeneration,boolean clearing,android.app.PendingIntent intent){
  if (DEBUGXPORT && (mClientGeneration != clientGeneration || clearing)) {
    Log.v(TAG,(clearing ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + clientGeneration);
  }
  mClientGeneration=clientGeneration;
  mTransportState=(clearing ? TRANSPORT_GONE : TRANSPORT_INVISIBLE);
  KeyguardHostView.this.post(mSwitchPageRunnable);
}","@Override void onMusicClientIdChanged(int clientGeneration,boolean clearing,android.app.PendingIntent intent){
  if (DEBUGXPORT && (mClientGeneration != clientGeneration || clearing)) {
    Log.v(TAG,(clearing ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + clientGeneration);
  }
  mClientGeneration=clientGeneration;
  final int newState=(clearing ? TRANSPORT_GONE : (mTransportState == TRANSPORT_VISIBLE ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  if (newState != mTransportState) {
    mTransportState=newState;
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    KeyguardHostView.this.post(mSwitchPageRunnable);
  }
}"
1935,"@Override public void onMusicPlaybackStateChanged(int playbackState,long eventTime){
  mPlaybackState=playbackState;
  if (DEBUGXPORT)   Log.v(TAG,""String_Node_Str"" + playbackState);
  if (mTransportState != TRANSPORT_GONE) {
    mTransportState=(isMusicPlaying(mPlaybackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE);
  }
  KeyguardHostView.this.post(mSwitchPageRunnable);
}","@Override public void onMusicPlaybackStateChanged(int playbackState,long eventTime){
  if (DEBUGXPORT)   Log.v(TAG,""String_Node_Str"" + playbackState);
  if (mTransportState != TRANSPORT_GONE) {
    final int newState=(isMusicPlaying(playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE);
    if (newState != mTransportState) {
      mTransportState=newState;
      if (DEBUGXPORT)       Log.v(TAG,""String_Node_Str"");
      KeyguardHostView.this.post(mSwitchPageRunnable);
    }
  }
}"
1936,"private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  mPlaybackState=dcs.playbackState;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + mTransportState + ""String_Node_Str""+ mPlaybackState);
}","private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + mTransportState + ""String_Node_Str""+ dcs.playbackState);
}"
1937,"@Override void onMusicClientIdChanged(int clientGeneration,boolean clearing,android.app.PendingIntent intent){
  if (DEBUGXPORT && (mClientGeneration != clientGeneration || clearing)) {
    Log.v(TAG,(clearing ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + clientGeneration);
  }
  mClientGeneration=clientGeneration;
  mTransportState=(clearing ? TRANSPORT_GONE : TRANSPORT_INVISIBLE);
  KeyguardHostView.this.post(mSwitchPageRunnable);
}","@Override void onMusicClientIdChanged(int clientGeneration,boolean clearing,android.app.PendingIntent intent){
  if (DEBUGXPORT && (mClientGeneration != clientGeneration || clearing)) {
    Log.v(TAG,(clearing ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + clientGeneration);
  }
  mClientGeneration=clientGeneration;
  final int newState=(clearing ? TRANSPORT_GONE : (mTransportState == TRANSPORT_VISIBLE ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  if (newState != mTransportState) {
    mTransportState=newState;
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    KeyguardHostView.this.post(mSwitchPageRunnable);
  }
}"
1938,"@Override public void onMusicPlaybackStateChanged(int playbackState,long eventTime){
  mPlaybackState=playbackState;
  if (DEBUGXPORT)   Log.v(TAG,""String_Node_Str"" + playbackState);
  if (mTransportState != TRANSPORT_GONE) {
    mTransportState=(isMusicPlaying(mPlaybackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE);
  }
  KeyguardHostView.this.post(mSwitchPageRunnable);
}","@Override public void onMusicPlaybackStateChanged(int playbackState,long eventTime){
  if (DEBUGXPORT)   Log.v(TAG,""String_Node_Str"" + playbackState);
  if (mTransportState != TRANSPORT_GONE) {
    final int newState=(isMusicPlaying(playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE);
    if (newState != mTransportState) {
      mTransportState=newState;
      if (DEBUGXPORT)       Log.v(TAG,""String_Node_Str"");
      KeyguardHostView.this.post(mSwitchPageRunnable);
    }
  }
}"
1939,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings({""String_Node_Str""}) @Override protected boolean dispatchHoverEvent(MotionEvent event){
  final int action=event.getAction();
  final boolean interceptHover=onInterceptHoverEvent(event);
  event.setAction(action);
  MotionEvent eventNoHistory=event;
  boolean handled=false;
  HoverTarget firstOldHoverTarget=mFirstHoverTarget;
  mFirstHoverTarget=null;
  if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
    final float x=event.getX();
    final float y=event.getY();
    final int childrenCount=mChildrenCount;
    if (childrenCount != 0) {
      final boolean customChildOrder=isChildrenDrawingOrderEnabled();
      final View[] children=mChildren;
      HoverTarget lastHoverTarget=null;
      for (int i=childrenCount - 1; i >= 0; i--) {
        final int childIndex=customChildOrder ? getChildDrawingOrder(childrenCount,i) : i;
        final View child=children[childIndex];
        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)) {
          continue;
        }
        HoverTarget hoverTarget=firstOldHoverTarget;
        final boolean wasHovered;
        for (HoverTarget predecessor=null; ; ) {
          if (hoverTarget == null) {
            hoverTarget=HoverTarget.obtain(child);
            wasHovered=false;
            break;
          }
          if (hoverTarget.child == child) {
            if (predecessor != null) {
              predecessor.next=hoverTarget.next;
            }
 else {
              firstOldHoverTarget=hoverTarget.next;
            }
            hoverTarget.next=null;
            wasHovered=true;
            break;
          }
          predecessor=hoverTarget;
          hoverTarget=hoverTarget.next;
        }
        if (lastHoverTarget != null) {
          lastHoverTarget.next=hoverTarget;
        }
 else {
          lastHoverTarget=hoverTarget;
          mFirstHoverTarget=hoverTarget;
        }
        if (action == MotionEvent.ACTION_HOVER_ENTER) {
          if (!wasHovered) {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
 else         if (action == MotionEvent.ACTION_HOVER_MOVE) {
          if (!wasHovered) {
            eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
            eventNoHistory.setAction(action);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
          }
 else {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
        if (handled) {
          break;
        }
      }
    }
  }
  while (firstOldHoverTarget != null) {
    final View child=firstOldHoverTarget.child;
    if (action == MotionEvent.ACTION_HOVER_EXIT) {
      handled|=dispatchTransformedGenericPointerEvent(event,child);
    }
 else {
      if (action == MotionEvent.ACTION_HOVER_MOVE) {
        dispatchTransformedGenericPointerEvent(event,child);
      }
      eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
      eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
      dispatchTransformedGenericPointerEvent(eventNoHistory,child);
      eventNoHistory.setAction(action);
    }
    final HoverTarget nextOldHoverTarget=firstOldHoverTarget.next;
    firstOldHoverTarget.recycle();
    firstOldHoverTarget=nextOldHoverTarget;
  }
  boolean newHoveredSelf=!handled;
  if (newHoveredSelf == mHoveredSelf) {
    if (newHoveredSelf) {
      handled|=super.dispatchHoverEvent(event);
    }
  }
 else {
    if (mHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_EXIT) {
        handled|=super.dispatchHoverEvent(event);
      }
 else {
        if (action == MotionEvent.ACTION_HOVER_MOVE) {
          super.dispatchHoverEvent(event);
        }
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
        super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
      }
      mHoveredSelf=false;
    }
    if (newHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_ENTER) {
        handled|=super.dispatchHoverEvent(event);
        mHoveredSelf=true;
      }
 else       if (action == MotionEvent.ACTION_HOVER_MOVE) {
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        mHoveredSelf=true;
      }
    }
  }
  if (eventNoHistory != event) {
    eventNoHistory.recycle();
  }
  return handled;
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings({""String_Node_Str""}) @Override protected boolean dispatchHoverEvent(MotionEvent event){
  final int action=event.getAction();
  final boolean interceptHover=onInterceptHoverEvent(event);
  event.setAction(action);
  MotionEvent eventNoHistory=event;
  boolean handled=false;
  HoverTarget firstOldHoverTarget=mFirstHoverTarget;
  mFirstHoverTarget=null;
  if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
    final float x=event.getX();
    final float y=event.getY();
    final int childrenCount=mChildrenCount;
    if (childrenCount != 0) {
      final boolean customChildOrder=isChildrenDrawingOrderEnabled();
      final View[] children=mChildren;
      HoverTarget lastHoverTarget=null;
      for (int i=childrenCount - 1; i >= 0; i--) {
        final int childIndex=customChildOrder ? getChildDrawingOrder(childrenCount,i) : i;
        final View child=children[childIndex];
        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)) {
          continue;
        }
        HoverTarget hoverTarget=firstOldHoverTarget;
        final boolean wasHovered;
        for (HoverTarget predecessor=null; ; ) {
          if (hoverTarget == null) {
            hoverTarget=HoverTarget.obtain(child);
            wasHovered=false;
            break;
          }
          if (hoverTarget.child == child) {
            if (predecessor != null) {
              predecessor.next=hoverTarget.next;
            }
 else {
              firstOldHoverTarget=hoverTarget.next;
            }
            hoverTarget.next=null;
            wasHovered=true;
            break;
          }
          predecessor=hoverTarget;
          hoverTarget=hoverTarget.next;
        }
        if (lastHoverTarget != null) {
          lastHoverTarget.next=hoverTarget;
        }
 else {
          mFirstHoverTarget=hoverTarget;
        }
        lastHoverTarget=hoverTarget;
        if (action == MotionEvent.ACTION_HOVER_ENTER) {
          if (!wasHovered) {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
 else         if (action == MotionEvent.ACTION_HOVER_MOVE) {
          if (!wasHovered) {
            eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
            eventNoHistory.setAction(action);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
          }
 else {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
        if (handled) {
          break;
        }
      }
    }
  }
  while (firstOldHoverTarget != null) {
    final View child=firstOldHoverTarget.child;
    if (action == MotionEvent.ACTION_HOVER_EXIT) {
      handled|=dispatchTransformedGenericPointerEvent(event,child);
    }
 else {
      if (action == MotionEvent.ACTION_HOVER_MOVE) {
        dispatchTransformedGenericPointerEvent(event,child);
      }
      eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
      eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
      dispatchTransformedGenericPointerEvent(eventNoHistory,child);
      eventNoHistory.setAction(action);
    }
    final HoverTarget nextOldHoverTarget=firstOldHoverTarget.next;
    firstOldHoverTarget.recycle();
    firstOldHoverTarget=nextOldHoverTarget;
  }
  boolean newHoveredSelf=!handled;
  if (newHoveredSelf == mHoveredSelf) {
    if (newHoveredSelf) {
      handled|=super.dispatchHoverEvent(event);
    }
  }
 else {
    if (mHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_EXIT) {
        handled|=super.dispatchHoverEvent(event);
      }
 else {
        if (action == MotionEvent.ACTION_HOVER_MOVE) {
          super.dispatchHoverEvent(event);
        }
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
        super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
      }
      mHoveredSelf=false;
    }
    if (newHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_ENTER) {
        handled|=super.dispatchHoverEvent(event);
        mHoveredSelf=true;
      }
 else       if (action == MotionEvent.ACTION_HOVER_MOVE) {
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        mHoveredSelf=true;
      }
    }
  }
  if (eventNoHistory != event) {
    eventNoHistory.recycle();
  }
  return handled;
}"
1940,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings({""String_Node_Str""}) @Override protected boolean dispatchHoverEvent(MotionEvent event){
  final int action=event.getAction();
  final boolean interceptHover=onInterceptHoverEvent(event);
  event.setAction(action);
  MotionEvent eventNoHistory=event;
  boolean handled=false;
  HoverTarget firstOldHoverTarget=mFirstHoverTarget;
  mFirstHoverTarget=null;
  if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
    final float x=event.getX();
    final float y=event.getY();
    final int childrenCount=mChildrenCount;
    if (childrenCount != 0) {
      final boolean customChildOrder=isChildrenDrawingOrderEnabled();
      final View[] children=mChildren;
      HoverTarget lastHoverTarget=null;
      for (int i=childrenCount - 1; i >= 0; i--) {
        final int childIndex=customChildOrder ? getChildDrawingOrder(childrenCount,i) : i;
        final View child=children[childIndex];
        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)) {
          continue;
        }
        HoverTarget hoverTarget=firstOldHoverTarget;
        final boolean wasHovered;
        for (HoverTarget predecessor=null; ; ) {
          if (hoverTarget == null) {
            hoverTarget=HoverTarget.obtain(child);
            wasHovered=false;
            break;
          }
          if (hoverTarget.child == child) {
            if (predecessor != null) {
              predecessor.next=hoverTarget.next;
            }
 else {
              firstOldHoverTarget=hoverTarget.next;
            }
            hoverTarget.next=null;
            wasHovered=true;
            break;
          }
          predecessor=hoverTarget;
          hoverTarget=hoverTarget.next;
        }
        if (lastHoverTarget != null) {
          lastHoverTarget.next=hoverTarget;
        }
 else {
          lastHoverTarget=hoverTarget;
          mFirstHoverTarget=hoverTarget;
        }
        if (action == MotionEvent.ACTION_HOVER_ENTER) {
          if (!wasHovered) {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
 else         if (action == MotionEvent.ACTION_HOVER_MOVE) {
          if (!wasHovered) {
            eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
            eventNoHistory.setAction(action);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
          }
 else {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
        if (handled) {
          break;
        }
      }
    }
  }
  while (firstOldHoverTarget != null) {
    final View child=firstOldHoverTarget.child;
    if (action == MotionEvent.ACTION_HOVER_EXIT) {
      handled|=dispatchTransformedGenericPointerEvent(event,child);
    }
 else {
      if (action == MotionEvent.ACTION_HOVER_MOVE) {
        dispatchTransformedGenericPointerEvent(event,child);
      }
      eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
      eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
      dispatchTransformedGenericPointerEvent(eventNoHistory,child);
      eventNoHistory.setAction(action);
    }
    final HoverTarget nextOldHoverTarget=firstOldHoverTarget.next;
    firstOldHoverTarget.recycle();
    firstOldHoverTarget=nextOldHoverTarget;
  }
  boolean newHoveredSelf=!handled;
  if (newHoveredSelf == mHoveredSelf) {
    if (newHoveredSelf) {
      handled|=super.dispatchHoverEvent(event);
    }
  }
 else {
    if (mHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_EXIT) {
        handled|=super.dispatchHoverEvent(event);
      }
 else {
        if (action == MotionEvent.ACTION_HOVER_MOVE) {
          super.dispatchHoverEvent(event);
        }
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
        super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
      }
      mHoveredSelf=false;
    }
    if (newHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_ENTER) {
        handled|=super.dispatchHoverEvent(event);
        mHoveredSelf=true;
      }
 else       if (action == MotionEvent.ACTION_HOVER_MOVE) {
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        mHoveredSelf=true;
      }
    }
  }
  if (eventNoHistory != event) {
    eventNoHistory.recycle();
  }
  return handled;
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings({""String_Node_Str""}) @Override protected boolean dispatchHoverEvent(MotionEvent event){
  final int action=event.getAction();
  final boolean interceptHover=onInterceptHoverEvent(event);
  event.setAction(action);
  MotionEvent eventNoHistory=event;
  boolean handled=false;
  HoverTarget firstOldHoverTarget=mFirstHoverTarget;
  mFirstHoverTarget=null;
  if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
    final float x=event.getX();
    final float y=event.getY();
    final int childrenCount=mChildrenCount;
    if (childrenCount != 0) {
      final boolean customChildOrder=isChildrenDrawingOrderEnabled();
      final View[] children=mChildren;
      HoverTarget lastHoverTarget=null;
      for (int i=childrenCount - 1; i >= 0; i--) {
        final int childIndex=customChildOrder ? getChildDrawingOrder(childrenCount,i) : i;
        final View child=children[childIndex];
        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)) {
          continue;
        }
        HoverTarget hoverTarget=firstOldHoverTarget;
        final boolean wasHovered;
        for (HoverTarget predecessor=null; ; ) {
          if (hoverTarget == null) {
            hoverTarget=HoverTarget.obtain(child);
            wasHovered=false;
            break;
          }
          if (hoverTarget.child == child) {
            if (predecessor != null) {
              predecessor.next=hoverTarget.next;
            }
 else {
              firstOldHoverTarget=hoverTarget.next;
            }
            hoverTarget.next=null;
            wasHovered=true;
            break;
          }
          predecessor=hoverTarget;
          hoverTarget=hoverTarget.next;
        }
        if (lastHoverTarget != null) {
          lastHoverTarget.next=hoverTarget;
        }
 else {
          mFirstHoverTarget=hoverTarget;
        }
        lastHoverTarget=hoverTarget;
        if (action == MotionEvent.ACTION_HOVER_ENTER) {
          if (!wasHovered) {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
 else         if (action == MotionEvent.ACTION_HOVER_MOVE) {
          if (!wasHovered) {
            eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
            eventNoHistory.setAction(action);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
          }
 else {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
        if (handled) {
          break;
        }
      }
    }
  }
  while (firstOldHoverTarget != null) {
    final View child=firstOldHoverTarget.child;
    if (action == MotionEvent.ACTION_HOVER_EXIT) {
      handled|=dispatchTransformedGenericPointerEvent(event,child);
    }
 else {
      if (action == MotionEvent.ACTION_HOVER_MOVE) {
        dispatchTransformedGenericPointerEvent(event,child);
      }
      eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
      eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
      dispatchTransformedGenericPointerEvent(eventNoHistory,child);
      eventNoHistory.setAction(action);
    }
    final HoverTarget nextOldHoverTarget=firstOldHoverTarget.next;
    firstOldHoverTarget.recycle();
    firstOldHoverTarget=nextOldHoverTarget;
  }
  boolean newHoveredSelf=!handled;
  if (newHoveredSelf == mHoveredSelf) {
    if (newHoveredSelf) {
      handled|=super.dispatchHoverEvent(event);
    }
  }
 else {
    if (mHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_EXIT) {
        handled|=super.dispatchHoverEvent(event);
      }
 else {
        if (action == MotionEvent.ACTION_HOVER_MOVE) {
          super.dispatchHoverEvent(event);
        }
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
        super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
      }
      mHoveredSelf=false;
    }
    if (newHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_ENTER) {
        handled|=super.dispatchHoverEvent(event);
        mHoveredSelf=true;
      }
 else       if (action == MotionEvent.ACTION_HOVER_MOVE) {
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        mHoveredSelf=true;
      }
    }
  }
  if (eventNoHistory != event) {
    eventNoHistory.recycle();
  }
  return handled;
}"
1941,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings({""String_Node_Str""}) @Override protected boolean dispatchHoverEvent(MotionEvent event){
  final int action=event.getAction();
  final boolean interceptHover=onInterceptHoverEvent(event);
  event.setAction(action);
  MotionEvent eventNoHistory=event;
  boolean handled=false;
  HoverTarget firstOldHoverTarget=mFirstHoverTarget;
  mFirstHoverTarget=null;
  if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
    final float x=event.getX();
    final float y=event.getY();
    final int childrenCount=mChildrenCount;
    if (childrenCount != 0) {
      final boolean customChildOrder=isChildrenDrawingOrderEnabled();
      final View[] children=mChildren;
      HoverTarget lastHoverTarget=null;
      for (int i=childrenCount - 1; i >= 0; i--) {
        final int childIndex=customChildOrder ? getChildDrawingOrder(childrenCount,i) : i;
        final View child=children[childIndex];
        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)) {
          continue;
        }
        HoverTarget hoverTarget=firstOldHoverTarget;
        final boolean wasHovered;
        for (HoverTarget predecessor=null; ; ) {
          if (hoverTarget == null) {
            hoverTarget=HoverTarget.obtain(child);
            wasHovered=false;
            break;
          }
          if (hoverTarget.child == child) {
            if (predecessor != null) {
              predecessor.next=hoverTarget.next;
            }
 else {
              firstOldHoverTarget=hoverTarget.next;
            }
            hoverTarget.next=null;
            wasHovered=true;
            break;
          }
          predecessor=hoverTarget;
          hoverTarget=hoverTarget.next;
        }
        if (lastHoverTarget != null) {
          lastHoverTarget.next=hoverTarget;
        }
 else {
          lastHoverTarget=hoverTarget;
          mFirstHoverTarget=hoverTarget;
        }
        if (action == MotionEvent.ACTION_HOVER_ENTER) {
          if (!wasHovered) {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
 else         if (action == MotionEvent.ACTION_HOVER_MOVE) {
          if (!wasHovered) {
            eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
            eventNoHistory.setAction(action);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
          }
 else {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
        if (handled) {
          break;
        }
      }
    }
  }
  while (firstOldHoverTarget != null) {
    final View child=firstOldHoverTarget.child;
    if (action == MotionEvent.ACTION_HOVER_EXIT) {
      handled|=dispatchTransformedGenericPointerEvent(event,child);
    }
 else {
      if (action == MotionEvent.ACTION_HOVER_MOVE) {
        dispatchTransformedGenericPointerEvent(event,child);
      }
      eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
      eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
      dispatchTransformedGenericPointerEvent(eventNoHistory,child);
      eventNoHistory.setAction(action);
    }
    final HoverTarget nextOldHoverTarget=firstOldHoverTarget.next;
    firstOldHoverTarget.recycle();
    firstOldHoverTarget=nextOldHoverTarget;
  }
  boolean newHoveredSelf=!handled;
  if (newHoveredSelf == mHoveredSelf) {
    if (newHoveredSelf) {
      handled|=super.dispatchHoverEvent(event);
    }
  }
 else {
    if (mHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_EXIT) {
        handled|=super.dispatchHoverEvent(event);
      }
 else {
        if (action == MotionEvent.ACTION_HOVER_MOVE) {
          super.dispatchHoverEvent(event);
        }
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
        super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
      }
      mHoveredSelf=false;
    }
    if (newHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_ENTER) {
        handled|=super.dispatchHoverEvent(event);
        mHoveredSelf=true;
      }
 else       if (action == MotionEvent.ACTION_HOVER_MOVE) {
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        mHoveredSelf=true;
      }
    }
  }
  if (eventNoHistory != event) {
    eventNoHistory.recycle();
  }
  return handled;
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings({""String_Node_Str""}) @Override protected boolean dispatchHoverEvent(MotionEvent event){
  final int action=event.getAction();
  final boolean interceptHover=onInterceptHoverEvent(event);
  event.setAction(action);
  MotionEvent eventNoHistory=event;
  boolean handled=false;
  HoverTarget firstOldHoverTarget=mFirstHoverTarget;
  mFirstHoverTarget=null;
  if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
    final float x=event.getX();
    final float y=event.getY();
    final int childrenCount=mChildrenCount;
    if (childrenCount != 0) {
      final boolean customChildOrder=isChildrenDrawingOrderEnabled();
      final View[] children=mChildren;
      HoverTarget lastHoverTarget=null;
      for (int i=childrenCount - 1; i >= 0; i--) {
        final int childIndex=customChildOrder ? getChildDrawingOrder(childrenCount,i) : i;
        final View child=children[childIndex];
        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)) {
          continue;
        }
        HoverTarget hoverTarget=firstOldHoverTarget;
        final boolean wasHovered;
        for (HoverTarget predecessor=null; ; ) {
          if (hoverTarget == null) {
            hoverTarget=HoverTarget.obtain(child);
            wasHovered=false;
            break;
          }
          if (hoverTarget.child == child) {
            if (predecessor != null) {
              predecessor.next=hoverTarget.next;
            }
 else {
              firstOldHoverTarget=hoverTarget.next;
            }
            hoverTarget.next=null;
            wasHovered=true;
            break;
          }
          predecessor=hoverTarget;
          hoverTarget=hoverTarget.next;
        }
        if (lastHoverTarget != null) {
          lastHoverTarget.next=hoverTarget;
        }
 else {
          mFirstHoverTarget=hoverTarget;
        }
        lastHoverTarget=hoverTarget;
        if (action == MotionEvent.ACTION_HOVER_ENTER) {
          if (!wasHovered) {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
 else         if (action == MotionEvent.ACTION_HOVER_MOVE) {
          if (!wasHovered) {
            eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
            eventNoHistory.setAction(action);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
          }
 else {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
        if (handled) {
          break;
        }
      }
    }
  }
  while (firstOldHoverTarget != null) {
    final View child=firstOldHoverTarget.child;
    if (action == MotionEvent.ACTION_HOVER_EXIT) {
      handled|=dispatchTransformedGenericPointerEvent(event,child);
    }
 else {
      if (action == MotionEvent.ACTION_HOVER_MOVE) {
        dispatchTransformedGenericPointerEvent(event,child);
      }
      eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
      eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
      dispatchTransformedGenericPointerEvent(eventNoHistory,child);
      eventNoHistory.setAction(action);
    }
    final HoverTarget nextOldHoverTarget=firstOldHoverTarget.next;
    firstOldHoverTarget.recycle();
    firstOldHoverTarget=nextOldHoverTarget;
  }
  boolean newHoveredSelf=!handled;
  if (newHoveredSelf == mHoveredSelf) {
    if (newHoveredSelf) {
      handled|=super.dispatchHoverEvent(event);
    }
  }
 else {
    if (mHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_EXIT) {
        handled|=super.dispatchHoverEvent(event);
      }
 else {
        if (action == MotionEvent.ACTION_HOVER_MOVE) {
          super.dispatchHoverEvent(event);
        }
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
        super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
      }
      mHoveredSelf=false;
    }
    if (newHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_ENTER) {
        handled|=super.dispatchHoverEvent(event);
        mHoveredSelf=true;
      }
 else       if (action == MotionEvent.ACTION_HOVER_MOVE) {
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        mHoveredSelf=true;
      }
    }
  }
  if (eventNoHistory != event) {
    eventNoHistory.recycle();
  }
  return handled;
}"
1942,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings({""String_Node_Str""}) @Override protected boolean dispatchHoverEvent(MotionEvent event){
  final int action=event.getAction();
  final boolean interceptHover=onInterceptHoverEvent(event);
  event.setAction(action);
  MotionEvent eventNoHistory=event;
  boolean handled=false;
  HoverTarget firstOldHoverTarget=mFirstHoverTarget;
  mFirstHoverTarget=null;
  if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
    final float x=event.getX();
    final float y=event.getY();
    final int childrenCount=mChildrenCount;
    if (childrenCount != 0) {
      final View[] children=mChildren;
      HoverTarget lastHoverTarget=null;
      for (int i=childrenCount - 1; i >= 0; i--) {
        final View child=children[i];
        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)) {
          continue;
        }
        HoverTarget hoverTarget=firstOldHoverTarget;
        final boolean wasHovered;
        for (HoverTarget predecessor=null; ; ) {
          if (hoverTarget == null) {
            hoverTarget=HoverTarget.obtain(child);
            wasHovered=false;
            break;
          }
          if (hoverTarget.child == child) {
            if (predecessor != null) {
              predecessor.next=hoverTarget.next;
            }
 else {
              firstOldHoverTarget=hoverTarget.next;
            }
            hoverTarget.next=null;
            wasHovered=true;
            break;
          }
          predecessor=hoverTarget;
          hoverTarget=hoverTarget.next;
        }
        if (lastHoverTarget != null) {
          lastHoverTarget.next=hoverTarget;
        }
 else {
          lastHoverTarget=hoverTarget;
          mFirstHoverTarget=hoverTarget;
        }
        if (action == MotionEvent.ACTION_HOVER_ENTER) {
          if (!wasHovered) {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
 else         if (action == MotionEvent.ACTION_HOVER_MOVE) {
          if (!wasHovered) {
            eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
            eventNoHistory.setAction(action);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
          }
 else {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
        if (handled) {
          break;
        }
      }
    }
  }
  while (firstOldHoverTarget != null) {
    final View child=firstOldHoverTarget.child;
    if (action == MotionEvent.ACTION_HOVER_EXIT) {
      handled|=dispatchTransformedGenericPointerEvent(event,child);
    }
 else {
      if (action == MotionEvent.ACTION_HOVER_MOVE) {
        dispatchTransformedGenericPointerEvent(event,child);
      }
      eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
      eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
      dispatchTransformedGenericPointerEvent(eventNoHistory,child);
      eventNoHistory.setAction(action);
    }
    final HoverTarget nextOldHoverTarget=firstOldHoverTarget.next;
    firstOldHoverTarget.recycle();
    firstOldHoverTarget=nextOldHoverTarget;
  }
  boolean newHoveredSelf=!handled;
  if (newHoveredSelf == mHoveredSelf) {
    if (newHoveredSelf) {
      handled|=super.dispatchHoverEvent(event);
    }
  }
 else {
    if (mHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_EXIT) {
        handled|=super.dispatchHoverEvent(event);
      }
 else {
        if (action == MotionEvent.ACTION_HOVER_MOVE) {
          super.dispatchHoverEvent(event);
        }
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
        super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
      }
      mHoveredSelf=false;
    }
    if (newHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_ENTER) {
        handled|=super.dispatchHoverEvent(event);
        mHoveredSelf=true;
      }
 else       if (action == MotionEvent.ACTION_HOVER_MOVE) {
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        mHoveredSelf=true;
      }
    }
  }
  if (eventNoHistory != event) {
    eventNoHistory.recycle();
  }
  return handled;
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings({""String_Node_Str""}) @Override protected boolean dispatchHoverEvent(MotionEvent event){
  final int action=event.getAction();
  final boolean interceptHover=onInterceptHoverEvent(event);
  event.setAction(action);
  MotionEvent eventNoHistory=event;
  boolean handled=false;
  HoverTarget firstOldHoverTarget=mFirstHoverTarget;
  mFirstHoverTarget=null;
  if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
    final float x=event.getX();
    final float y=event.getY();
    final int childrenCount=mChildrenCount;
    if (childrenCount != 0) {
      final View[] children=mChildren;
      HoverTarget lastHoverTarget=null;
      for (int i=childrenCount - 1; i >= 0; i--) {
        final View child=children[i];
        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)) {
          continue;
        }
        HoverTarget hoverTarget=firstOldHoverTarget;
        final boolean wasHovered;
        for (HoverTarget predecessor=null; ; ) {
          if (hoverTarget == null) {
            hoverTarget=HoverTarget.obtain(child);
            wasHovered=false;
            break;
          }
          if (hoverTarget.child == child) {
            if (predecessor != null) {
              predecessor.next=hoverTarget.next;
            }
 else {
              firstOldHoverTarget=hoverTarget.next;
            }
            hoverTarget.next=null;
            wasHovered=true;
            break;
          }
          predecessor=hoverTarget;
          hoverTarget=hoverTarget.next;
        }
        if (lastHoverTarget != null) {
          lastHoverTarget.next=hoverTarget;
        }
 else {
          mFirstHoverTarget=hoverTarget;
        }
        lastHoverTarget=hoverTarget;
        if (action == MotionEvent.ACTION_HOVER_ENTER) {
          if (!wasHovered) {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
 else         if (action == MotionEvent.ACTION_HOVER_MOVE) {
          if (!wasHovered) {
            eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
            eventNoHistory.setAction(action);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
          }
 else {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
        if (handled) {
          break;
        }
      }
    }
  }
  while (firstOldHoverTarget != null) {
    final View child=firstOldHoverTarget.child;
    if (action == MotionEvent.ACTION_HOVER_EXIT) {
      handled|=dispatchTransformedGenericPointerEvent(event,child);
    }
 else {
      if (action == MotionEvent.ACTION_HOVER_MOVE) {
        dispatchTransformedGenericPointerEvent(event,child);
      }
      eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
      eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
      dispatchTransformedGenericPointerEvent(eventNoHistory,child);
      eventNoHistory.setAction(action);
    }
    final HoverTarget nextOldHoverTarget=firstOldHoverTarget.next;
    firstOldHoverTarget.recycle();
    firstOldHoverTarget=nextOldHoverTarget;
  }
  boolean newHoveredSelf=!handled;
  if (newHoveredSelf == mHoveredSelf) {
    if (newHoveredSelf) {
      handled|=super.dispatchHoverEvent(event);
    }
  }
 else {
    if (mHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_EXIT) {
        handled|=super.dispatchHoverEvent(event);
      }
 else {
        if (action == MotionEvent.ACTION_HOVER_MOVE) {
          super.dispatchHoverEvent(event);
        }
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
        super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
      }
      mHoveredSelf=false;
    }
    if (newHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_ENTER) {
        handled|=super.dispatchHoverEvent(event);
        mHoveredSelf=true;
      }
 else       if (action == MotionEvent.ACTION_HOVER_MOVE) {
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        mHoveredSelf=true;
      }
    }
  }
  if (eventNoHistory != event) {
    eventNoHistory.recycle();
  }
  return handled;
}"
1943,"/** 
 * Set whether SELinux is permissive or enforcing.
 * @param boolean representing whether to set SELinux to enforcing
 * @return a boolean representing whether the desired mode was set
 */
public static final native boolean setSELinuxEnforce(boolean value);","/** 
 * Set whether SELinux is permissive or enforcing.
 * @param value representing whether to set SELinux to enforcing
 * @return a boolean representing whether the desired mode was set
 */
public static final native boolean setSELinuxEnforce(boolean value);"
1944,"/** 
 * Gets the security context of a given process id. Use of this function is discouraged for Binder transactions. Use Binder.getCallingSecctx() instead.
 * @param pid an int representing the process id to check.
 * @return a String representing the security context of the given pid.
 */
public static final native String getPidContext(int pid);","/** 
 * Gets the security context of a given process id.
 * @param pid an int representing the process id to check.
 * @return a String representing the security context of the given pid.
 */
public static final native String getPidContext(int pid);"
1945,"/** 
 * Sets the value for the given SELinux boolean name.
 * @param String The name of the SELinux boolean.
 * @param Boolean The new value of the SELinux boolean.
 * @return a boolean indicating whether or not the operation succeeded.
 */
public static final native boolean setBooleanValue(String name,boolean value);","/** 
 * Sets the value for the given SELinux boolean name.
 * @param name The name of the SELinux boolean.
 * @param value The new value of the SELinux boolean.
 * @return a boolean indicating whether or not the operation succeeded.
 */
public static final native boolean setBooleanValue(String name,boolean value);"
1946,"/** 
 * Change the security context of an existing file object.
 * @param path representing the path of file object to relabel.
 * @param con new security context given as a String.
 * @return a boolean indicating whether the operation succeeded.
 */
public static final native boolean setFileContext(String path,String context);","/** 
 * Change the security context of an existing file object.
 * @param path representing the path of file object to relabel.
 * @param context new security context given as a String.
 * @return a boolean indicating whether the operation succeeded.
 */
public static final native boolean setFileContext(String path,String context);"
1947,"/** 
 * Gets the value for the given SELinux boolean name.
 * @param String The name of the SELinux boolean.
 * @return a boolean indicating whether the SELinux boolean is set.
 */
public static final native boolean getBooleanValue(String name);","/** 
 * Gets the value for the given SELinux boolean name.
 * @param name The name of the SELinux boolean.
 * @return a boolean indicating whether the SELinux boolean is set.
 */
public static final native boolean getBooleanValue(String name);"
1948,"/** 
 * Handle an arrow scroll going up or down.  Take into account whether items are selectable, whether there are focusable items etc.
 * @param direction Either {@link android.view.View#FOCUS_UP} or {@link android.view.View#FOCUS_DOWN}.
 * @return Whether any scrolling, selection or focus change occured.
 */
private boolean arrowScrollImpl(int direction){
  if (getChildCount() <= 0) {
    return false;
  }
  View selectedView=getSelectedView();
  int selectedPos=mSelectedPosition;
  int nextSelectedPosition=nextSelectedPositionForDirection(selectedPos,direction);
  int amountToScroll=amountToScroll(direction,nextSelectedPosition);
  final ArrowScrollFocusResult focusResult=mItemsCanFocus ? arrowScrollFocused(direction) : null;
  if (focusResult != null) {
    nextSelectedPosition=focusResult.getSelectedPosition();
    amountToScroll=focusResult.getAmountToScroll();
  }
  boolean needToRedraw=focusResult != null;
  if (nextSelectedPosition != INVALID_POSITION) {
    handleNewSelectionChange(selectedView,direction,nextSelectedPosition,focusResult != null);
    setSelectedPositionInt(nextSelectedPosition);
    setNextSelectedPositionInt(nextSelectedPosition);
    selectedView=getSelectedView();
    selectedPos=nextSelectedPosition;
    if (mItemsCanFocus && focusResult == null) {
      final View focused=getFocusedChild();
      if (focused != null) {
        focused.clearFocus();
      }
    }
    needToRedraw=true;
    checkSelectionChanged();
  }
  if (amountToScroll > 0) {
    scrollListItemsBy((direction == View.FOCUS_UP) ? amountToScroll : -amountToScroll);
    needToRedraw=true;
  }
  if (mItemsCanFocus && (focusResult == null) && selectedView != null && selectedView.hasFocus()) {
    final View focused=selectedView.findFocus();
    if (!isViewAncestorOf(focused,this) || distanceToView(focused) > 0) {
      focused.clearFocus();
    }
  }
  if (nextSelectedPosition == INVALID_POSITION && selectedView != null && !isViewAncestorOf(selectedView,this)) {
    selectedView=null;
    hideSelector();
    mResurrectToPosition=INVALID_POSITION;
  }
  if (needToRedraw) {
    if (selectedView != null) {
      positionSelector(selectedPos,selectedView);
      mSelectedTop=selectedView.getTop();
    }
    if (!awakenScrollBars()) {
      invalidate();
    }
    invokeOnItemScrollListener();
    return true;
  }
  return false;
}","/** 
 * Handle an arrow scroll going up or down.  Take into account whether items are selectable, whether there are focusable items etc.
 * @param direction Either {@link android.view.View#FOCUS_UP} or {@link android.view.View#FOCUS_DOWN}.
 * @return Whether any scrolling, selection or focus change occured.
 */
private boolean arrowScrollImpl(int direction){
  if (getChildCount() <= 0) {
    return false;
  }
  View selectedView=getSelectedView();
  int selectedPos=mSelectedPosition;
  int nextSelectedPosition=nextSelectedPositionForDirection(selectedView,selectedPos,direction);
  int amountToScroll=amountToScroll(direction,nextSelectedPosition);
  final ArrowScrollFocusResult focusResult=mItemsCanFocus ? arrowScrollFocused(direction) : null;
  if (focusResult != null) {
    nextSelectedPosition=focusResult.getSelectedPosition();
    amountToScroll=focusResult.getAmountToScroll();
  }
  boolean needToRedraw=focusResult != null;
  if (nextSelectedPosition != INVALID_POSITION) {
    handleNewSelectionChange(selectedView,direction,nextSelectedPosition,focusResult != null);
    setSelectedPositionInt(nextSelectedPosition);
    setNextSelectedPositionInt(nextSelectedPosition);
    selectedView=getSelectedView();
    selectedPos=nextSelectedPosition;
    if (mItemsCanFocus && focusResult == null) {
      final View focused=getFocusedChild();
      if (focused != null) {
        focused.clearFocus();
      }
    }
    needToRedraw=true;
    checkSelectionChanged();
  }
  if (amountToScroll > 0) {
    scrollListItemsBy((direction == View.FOCUS_UP) ? amountToScroll : -amountToScroll);
    needToRedraw=true;
  }
  if (mItemsCanFocus && (focusResult == null) && selectedView != null && selectedView.hasFocus()) {
    final View focused=selectedView.findFocus();
    if (!isViewAncestorOf(focused,this) || distanceToView(focused) > 0) {
      focused.clearFocus();
    }
  }
  if (nextSelectedPosition == INVALID_POSITION && selectedView != null && !isViewAncestorOf(selectedView,this)) {
    selectedView=null;
    hideSelector();
    mResurrectToPosition=INVALID_POSITION;
  }
  if (needToRedraw) {
    if (selectedView != null) {
      positionSelector(selectedPos,selectedView);
      mSelectedTop=selectedView.getTop();
    }
    if (!awakenScrollBars()) {
      invalidate();
    }
    invokeOnItemScrollListener();
    return true;
  }
  return false;
}"
1949,"/** 
 * Used by   {@link #arrowScrollImpl(int)} to help determine the next selected positionto move to. This can return a position currently not represented by a view on screen but only in the direction given.
 * @param selectedPos Current selected position to move from
 * @param direction Direction to move in
 * @return Desired selected position after moving in the given direction
 */
private final int nextSelectedPositionForDirection(int selectedPos,int direction){
  int nextSelected;
  if (direction == View.FOCUS_DOWN) {
    nextSelected=selectedPos != INVALID_POSITION && selectedPos >= mFirstPosition ? selectedPos + 1 : mFirstPosition;
  }
 else {
    final int lastPos=mFirstPosition + getChildCount() - 1;
    nextSelected=selectedPos != INVALID_POSITION && selectedPos <= lastPos ? selectedPos - 1 : lastPos;
  }
  if (nextSelected < 0 || nextSelected >= mAdapter.getCount()) {
    return INVALID_POSITION;
  }
  return lookForSelectablePosition(nextSelected,direction == View.FOCUS_DOWN);
}","/** 
 * Used by   {@link #arrowScrollImpl(int)} to help determine the next selected positionto move to. This return a position in the direction given if the selected item is fully visible.
 * @param selectedView Current selected view to move from
 * @param selectedPos Current selected position to move from
 * @param direction Direction to move in
 * @return Desired selected position after moving in the given direction
 */
private final int nextSelectedPositionForDirection(View selectedView,int selectedPos,int direction){
  int nextSelected;
  if (direction == View.FOCUS_DOWN) {
    final int listBottom=getHeight() - mListPadding.bottom;
    if (selectedView != null && selectedView.getBottom() <= listBottom) {
      nextSelected=selectedPos != INVALID_POSITION && selectedPos >= mFirstPosition ? selectedPos + 1 : mFirstPosition;
    }
 else {
      return INVALID_POSITION;
    }
  }
 else {
    final int listTop=mListPadding.top;
    if (selectedView != null && selectedView.getTop() >= listTop) {
      final int lastPos=mFirstPosition + getChildCount() - 1;
      nextSelected=selectedPos != INVALID_POSITION && selectedPos <= lastPos ? selectedPos - 1 : lastPos;
    }
 else {
      return INVALID_POSITION;
    }
  }
  if (nextSelected < 0 || nextSelected >= mAdapter.getCount()) {
    return INVALID_POSITION;
  }
  return lookForSelectablePosition(nextSelected,direction == View.FOCUS_DOWN);
}"
1950,"private boolean doDeferEnable(Message msg){
  long delaySoFar=SystemClock.elapsedRealtime() - mDisabledTimestamp;
  if (delaySoFar > mReEnableDelayMillis) {
    return false;
  }
  log(""String_Node_Str"" + msg + ""String_Node_Str""+ (mReEnableDelayMillis - delaySoFar)+ ""String_Node_Str"");
  Message deferredMsg=obtainMessage(CMD_DEFERRED_TOGGLE);
  deferredMsg.obj=Message.obtain(msg);
  deferredMsg.arg1=++mDeferredEnableSerialNumber;
  sendMessageDelayed(deferredMsg,mReEnableDelayMillis - delaySoFar);
  return true;
}","private boolean doDeferEnable(Message msg){
  long delaySoFar=SystemClock.elapsedRealtime() - mDisabledTimestamp;
  if (delaySoFar >= mReEnableDelayMillis) {
    return false;
  }
  log(""String_Node_Str"" + msg + ""String_Node_Str""+ (mReEnableDelayMillis - delaySoFar)+ ""String_Node_Str"");
  Message deferredMsg=obtainMessage(CMD_DEFERRED_TOGGLE);
  deferredMsg.obj=Message.obtain(msg);
  deferredMsg.arg1=++mDeferredEnableSerialNumber;
  sendMessageDelayed(deferredMsg,mReEnableDelayMillis - delaySoFar);
  return true;
}"
1951,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  if (mTextDir == null) {
    getTextDirectionHeuristic();
  }
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mTextDir,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWant=want;
  int hintWidth=(mHintLayout == null) ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else {
    final boolean layoutChanged=(mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight());
    final boolean widthChanged=(mHint == null) && (mEllipsize == null) && (want > mLayout.getWidth())&& (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want));
    final boolean maximumChanged=(mMaxMode != mOldMaxMode) || (mMaximum != mOldMaximum);
    if (layoutChanged || maximumChanged) {
      if (!maximumChanged && widthChanged) {
        mLayout.increaseWidthTo(want);
      }
 else {
        makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
      }
    }
 else {
    }
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,heightSize);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  if (mTextDir == null) {
    mTextDir=getTextDirectionHeuristic();
  }
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mTextDir,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWant=want;
  int hintWidth=(mHintLayout == null) ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else {
    final boolean layoutChanged=(mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight());
    final boolean widthChanged=(mHint == null) && (mEllipsize == null) && (want > mLayout.getWidth())&& (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want));
    final boolean maximumChanged=(mMaxMode != mOldMaxMode) || (mMaximum != mOldMaximum);
    if (layoutChanged || maximumChanged) {
      if (!maximumChanged && widthChanged) {
        mLayout.increaseWidthTo(want);
      }
 else {
        makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
      }
    }
 else {
    }
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,heightSize);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}"
1952,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  if (mTextDir == null) {
    getTextDirectionHeuristic();
  }
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mTextDir,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWant=want;
  int hintWidth=(mHintLayout == null) ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else {
    final boolean layoutChanged=(mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight());
    final boolean widthChanged=(mHint == null) && (mEllipsize == null) && (want > mLayout.getWidth())&& (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want));
    final boolean maximumChanged=(mMaxMode != mOldMaxMode) || (mMaximum != mOldMaximum);
    if (layoutChanged || maximumChanged) {
      if (!maximumChanged && widthChanged) {
        mLayout.increaseWidthTo(want);
      }
 else {
        makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
      }
    }
 else {
    }
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,heightSize);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  if (mTextDir == null) {
    mTextDir=getTextDirectionHeuristic();
  }
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mTextDir,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWant=want;
  int hintWidth=(mHintLayout == null) ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else {
    final boolean layoutChanged=(mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight());
    final boolean widthChanged=(mHint == null) && (mEllipsize == null) && (want > mLayout.getWidth())&& (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want));
    final boolean maximumChanged=(mMaxMode != mOldMaxMode) || (mMaximum != mOldMaximum);
    if (layoutChanged || maximumChanged) {
      if (!maximumChanged && widthChanged) {
        mLayout.increaseWidthTo(want);
      }
 else {
        makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
      }
    }
 else {
    }
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,heightSize);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}"
1953,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  if (mTextDir == null) {
    getTextDirectionHeuristic();
  }
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mTextDir,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWant=want;
  int hintWidth=(mHintLayout == null) ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else {
    final boolean layoutChanged=(mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight());
    final boolean widthChanged=(mHint == null) && (mEllipsize == null) && (want > mLayout.getWidth())&& (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want));
    final boolean maximumChanged=(mMaxMode != mOldMaxMode) || (mMaximum != mOldMaximum);
    if (layoutChanged || maximumChanged) {
      if (!maximumChanged && widthChanged) {
        mLayout.increaseWidthTo(want);
      }
 else {
        makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
      }
    }
 else {
    }
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,heightSize);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  if (mTextDir == null) {
    mTextDir=getTextDirectionHeuristic();
  }
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mTextDir,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWant=want;
  int hintWidth=(mHintLayout == null) ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else {
    final boolean layoutChanged=(mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight());
    final boolean widthChanged=(mHint == null) && (mEllipsize == null) && (want > mLayout.getWidth())&& (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want));
    final boolean maximumChanged=(mMaxMode != mOldMaxMode) || (mMaximum != mOldMaximum);
    if (layoutChanged || maximumChanged) {
      if (!maximumChanged && widthChanged) {
        mLayout.increaseWidthTo(want);
      }
 else {
        makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
      }
    }
 else {
    }
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,heightSize);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}"
1954,"private boolean updateFocusedWindowLocked(int mode,boolean updateInputWindows){
  WindowState newFocus=computeFocusedWindowLocked();
  if (mCurrentFocus != newFocus) {
    Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER,""String_Node_Str"");
    mH.removeMessages(H.REPORT_FOCUS_CHANGE);
    mH.sendEmptyMessage(H.REPORT_FOCUS_CHANGE);
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + mCurrentFocus + ""String_Node_Str""+ newFocus);
    final WindowState oldFocus=mCurrentFocus;
    mCurrentFocus=newFocus;
    mLosingFocus.remove(newFocus);
    int focusChanged=mPolicy.focusChangedLw(oldFocus,newFocus);
    final DisplayContent displayContent=getDefaultDisplayContentLocked();
    final WindowState imWindow=mInputMethodWindow;
    if (newFocus != imWindow && oldFocus != imWindow) {
      if (moveInputMethodWindowsIfNeededLocked(mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS && mode != UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        displayContent.layoutNeeded=true;
      }
      if (mode == UPDATE_FOCUS_PLACING_SURFACES) {
        performLayoutLockedInner(displayContent,true,updateInputWindows);
        focusChanged&=~WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
      }
 else       if (mode == UPDATE_FOCUS_WILL_PLACE_SURFACES) {
        assignLayersLocked(displayContent.getWindowList());
      }
    }
    if ((focusChanged & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
      displayContent.layoutNeeded=true;
      if (mode == UPDATE_FOCUS_PLACING_SURFACES) {
        performLayoutLockedInner(displayContent,true,updateInputWindows);
      }
    }
    if (mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS) {
      finishUpdateFocusedWindowAfterAssignLayersLocked(updateInputWindows);
    }
    Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
    return true;
  }
  return false;
}","private boolean updateFocusedWindowLocked(int mode,boolean updateInputWindows){
  WindowState newFocus=computeFocusedWindowLocked();
  if (mCurrentFocus != newFocus) {
    Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER,""String_Node_Str"");
    mH.removeMessages(H.REPORT_FOCUS_CHANGE);
    mH.sendEmptyMessage(H.REPORT_FOCUS_CHANGE);
    final DisplayContent displayContent=getDefaultDisplayContentLocked();
    final boolean imWindowChanged=moveInputMethodWindowsIfNeededLocked(mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS && mode != UPDATE_FOCUS_WILL_PLACE_SURFACES);
    if (imWindowChanged) {
      displayContent.layoutNeeded=true;
      newFocus=computeFocusedWindowLocked();
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + mCurrentFocus + ""String_Node_Str""+ newFocus);
    final WindowState oldFocus=mCurrentFocus;
    mCurrentFocus=newFocus;
    mLosingFocus.remove(newFocus);
    int focusChanged=mPolicy.focusChangedLw(oldFocus,newFocus);
    final WindowState imWindow=mInputMethodWindow;
    if (imWindowChanged && oldFocus != imWindow) {
      if (mode == UPDATE_FOCUS_PLACING_SURFACES) {
        performLayoutLockedInner(displayContent,true,updateInputWindows);
        focusChanged&=~WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
      }
 else       if (mode == UPDATE_FOCUS_WILL_PLACE_SURFACES) {
        assignLayersLocked(displayContent.getWindowList());
      }
    }
    if ((focusChanged & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
      displayContent.layoutNeeded=true;
      if (mode == UPDATE_FOCUS_PLACING_SURFACES) {
        performLayoutLockedInner(displayContent,true,updateInputWindows);
      }
    }
    if (mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS) {
      finishUpdateFocusedWindowAfterAssignLayersLocked(updateInputWindows);
    }
    Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
    return true;
  }
  return false;
}"
1955,"/** 
 * Handle an arrow scroll going up or down.  Take into account whether items are selectable, whether there are focusable items etc.
 * @param direction Either {@link android.view.View#FOCUS_UP} or {@link android.view.View#FOCUS_DOWN}.
 * @return Whether any scrolling, selection or focus change occured.
 */
private boolean arrowScrollImpl(int direction){
  if (getChildCount() <= 0) {
    return false;
  }
  View selectedView=getSelectedView();
  int selectedPos=mSelectedPosition;
  int nextSelectedPosition=nextSelectedPositionForDirection(selectedPos,direction);
  int amountToScroll=amountToScroll(direction,nextSelectedPosition);
  final ArrowScrollFocusResult focusResult=mItemsCanFocus ? arrowScrollFocused(direction) : null;
  if (focusResult != null) {
    nextSelectedPosition=focusResult.getSelectedPosition();
    amountToScroll=focusResult.getAmountToScroll();
  }
  boolean needToRedraw=focusResult != null;
  if (nextSelectedPosition != INVALID_POSITION) {
    handleNewSelectionChange(selectedView,direction,nextSelectedPosition,focusResult != null);
    setSelectedPositionInt(nextSelectedPosition);
    setNextSelectedPositionInt(nextSelectedPosition);
    selectedView=getSelectedView();
    selectedPos=nextSelectedPosition;
    if (mItemsCanFocus && focusResult == null) {
      final View focused=getFocusedChild();
      if (focused != null) {
        focused.clearFocus();
      }
    }
    needToRedraw=true;
    checkSelectionChanged();
  }
  if (amountToScroll > 0) {
    scrollListItemsBy((direction == View.FOCUS_UP) ? amountToScroll : -amountToScroll);
    needToRedraw=true;
  }
  if (mItemsCanFocus && (focusResult == null) && selectedView != null && selectedView.hasFocus()) {
    final View focused=selectedView.findFocus();
    if (!isViewAncestorOf(focused,this) || distanceToView(focused) > 0) {
      focused.clearFocus();
    }
  }
  if (nextSelectedPosition == INVALID_POSITION && selectedView != null && !isViewAncestorOf(selectedView,this)) {
    selectedView=null;
    hideSelector();
    mResurrectToPosition=INVALID_POSITION;
  }
  if (needToRedraw) {
    if (selectedView != null) {
      positionSelector(selectedPos,selectedView);
      mSelectedTop=selectedView.getTop();
    }
    if (!awakenScrollBars()) {
      invalidate();
    }
    invokeOnItemScrollListener();
    return true;
  }
  return false;
}","/** 
 * Handle an arrow scroll going up or down.  Take into account whether items are selectable, whether there are focusable items etc.
 * @param direction Either {@link android.view.View#FOCUS_UP} or {@link android.view.View#FOCUS_DOWN}.
 * @return Whether any scrolling, selection or focus change occured.
 */
private boolean arrowScrollImpl(int direction){
  if (getChildCount() <= 0) {
    return false;
  }
  View selectedView=getSelectedView();
  int selectedPos=mSelectedPosition;
  int nextSelectedPosition=nextSelectedPositionForDirection(selectedView,selectedPos,direction);
  int amountToScroll=amountToScroll(direction,nextSelectedPosition);
  final ArrowScrollFocusResult focusResult=mItemsCanFocus ? arrowScrollFocused(direction) : null;
  if (focusResult != null) {
    nextSelectedPosition=focusResult.getSelectedPosition();
    amountToScroll=focusResult.getAmountToScroll();
  }
  boolean needToRedraw=focusResult != null;
  if (nextSelectedPosition != INVALID_POSITION) {
    handleNewSelectionChange(selectedView,direction,nextSelectedPosition,focusResult != null);
    setSelectedPositionInt(nextSelectedPosition);
    setNextSelectedPositionInt(nextSelectedPosition);
    selectedView=getSelectedView();
    selectedPos=nextSelectedPosition;
    if (mItemsCanFocus && focusResult == null) {
      final View focused=getFocusedChild();
      if (focused != null) {
        focused.clearFocus();
      }
    }
    needToRedraw=true;
    checkSelectionChanged();
  }
  if (amountToScroll > 0) {
    scrollListItemsBy((direction == View.FOCUS_UP) ? amountToScroll : -amountToScroll);
    needToRedraw=true;
  }
  if (mItemsCanFocus && (focusResult == null) && selectedView != null && selectedView.hasFocus()) {
    final View focused=selectedView.findFocus();
    if (!isViewAncestorOf(focused,this) || distanceToView(focused) > 0) {
      focused.clearFocus();
    }
  }
  if (nextSelectedPosition == INVALID_POSITION && selectedView != null && !isViewAncestorOf(selectedView,this)) {
    selectedView=null;
    hideSelector();
    mResurrectToPosition=INVALID_POSITION;
  }
  if (needToRedraw) {
    if (selectedView != null) {
      positionSelector(selectedPos,selectedView);
      mSelectedTop=selectedView.getTop();
    }
    if (!awakenScrollBars()) {
      invalidate();
    }
    invokeOnItemScrollListener();
    return true;
  }
  return false;
}"
1956,"/** 
 * Used by   {@link #arrowScrollImpl(int)} to help determine the next selected positionto move to. This can return a position currently not represented by a view on screen but only in the direction given.
 * @param selectedPos Current selected position to move from
 * @param direction Direction to move in
 * @return Desired selected position after moving in the given direction
 */
private final int nextSelectedPositionForDirection(int selectedPos,int direction){
  int nextSelected;
  if (direction == View.FOCUS_DOWN) {
    nextSelected=selectedPos != INVALID_POSITION && selectedPos >= mFirstPosition ? selectedPos + 1 : mFirstPosition;
  }
 else {
    final int lastPos=mFirstPosition + getChildCount() - 1;
    nextSelected=selectedPos != INVALID_POSITION && selectedPos <= lastPos ? selectedPos - 1 : lastPos;
  }
  if (nextSelected < 0 || nextSelected >= mAdapter.getCount()) {
    return INVALID_POSITION;
  }
  return lookForSelectablePosition(nextSelected,direction == View.FOCUS_DOWN);
}","/** 
 * Used by   {@link #arrowScrollImpl(int)} to help determine the next selected positionto move to. This return a position in the direction given if the selected item is fully visible.
 * @param selectedView Current selected view to move from
 * @param selectedPos Current selected position to move from
 * @param direction Direction to move in
 * @return Desired selected position after moving in the given direction
 */
private final int nextSelectedPositionForDirection(View selectedView,int selectedPos,int direction){
  int nextSelected;
  if (direction == View.FOCUS_DOWN) {
    final int listBottom=getHeight() - mListPadding.bottom;
    if (selectedView != null && selectedView.getBottom() <= listBottom) {
      nextSelected=selectedPos != INVALID_POSITION && selectedPos >= mFirstPosition ? selectedPos + 1 : mFirstPosition;
    }
 else {
      return INVALID_POSITION;
    }
  }
 else {
    final int listTop=mListPadding.top;
    if (selectedView != null && selectedView.getTop() >= listTop) {
      final int lastPos=mFirstPosition + getChildCount() - 1;
      nextSelected=selectedPos != INVALID_POSITION && selectedPos <= lastPos ? selectedPos - 1 : lastPos;
    }
 else {
      return INVALID_POSITION;
    }
  }
  if (nextSelected < 0 || nextSelected >= mAdapter.getCount()) {
    return INVALID_POSITION;
  }
  return lookForSelectablePosition(nextSelected,direction == View.FOCUS_DOWN);
}"
1957,"private boolean updateFocusedWindowLocked(int mode,boolean updateInputWindows){
  WindowState newFocus=computeFocusedWindowLocked();
  if (mCurrentFocus != newFocus) {
    Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER,""String_Node_Str"");
    mH.removeMessages(H.REPORT_FOCUS_CHANGE);
    mH.sendEmptyMessage(H.REPORT_FOCUS_CHANGE);
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + mCurrentFocus + ""String_Node_Str""+ newFocus);
    final WindowState oldFocus=mCurrentFocus;
    mCurrentFocus=newFocus;
    mLosingFocus.remove(newFocus);
    int focusChanged=mPolicy.focusChangedLw(oldFocus,newFocus);
    final DisplayContent displayContent=getDefaultDisplayContentLocked();
    final WindowState imWindow=mInputMethodWindow;
    if (newFocus != imWindow && oldFocus != imWindow) {
      if (moveInputMethodWindowsIfNeededLocked(mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS && mode != UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        displayContent.layoutNeeded=true;
      }
      if (mode == UPDATE_FOCUS_PLACING_SURFACES) {
        performLayoutLockedInner(displayContent,true,updateInputWindows);
        focusChanged&=~WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
      }
 else       if (mode == UPDATE_FOCUS_WILL_PLACE_SURFACES) {
        assignLayersLocked(displayContent.getWindowList());
      }
    }
    if ((focusChanged & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
      displayContent.layoutNeeded=true;
      if (mode == UPDATE_FOCUS_PLACING_SURFACES) {
        performLayoutLockedInner(displayContent,true,updateInputWindows);
      }
    }
    if (mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS) {
      finishUpdateFocusedWindowAfterAssignLayersLocked(updateInputWindows);
    }
    Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
    return true;
  }
  return false;
}","private boolean updateFocusedWindowLocked(int mode,boolean updateInputWindows){
  WindowState newFocus=computeFocusedWindowLocked();
  if (mCurrentFocus != newFocus) {
    Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER,""String_Node_Str"");
    mH.removeMessages(H.REPORT_FOCUS_CHANGE);
    mH.sendEmptyMessage(H.REPORT_FOCUS_CHANGE);
    final DisplayContent displayContent=getDefaultDisplayContentLocked();
    final boolean imWindowChanged=moveInputMethodWindowsIfNeededLocked(mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS && mode != UPDATE_FOCUS_WILL_PLACE_SURFACES);
    if (imWindowChanged) {
      displayContent.layoutNeeded=true;
      newFocus=computeFocusedWindowLocked();
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + mCurrentFocus + ""String_Node_Str""+ newFocus);
    final WindowState oldFocus=mCurrentFocus;
    mCurrentFocus=newFocus;
    mLosingFocus.remove(newFocus);
    int focusChanged=mPolicy.focusChangedLw(oldFocus,newFocus);
    final WindowState imWindow=mInputMethodWindow;
    if (imWindowChanged && oldFocus != imWindow) {
      if (mode == UPDATE_FOCUS_PLACING_SURFACES) {
        performLayoutLockedInner(displayContent,true,updateInputWindows);
        focusChanged&=~WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
      }
 else       if (mode == UPDATE_FOCUS_WILL_PLACE_SURFACES) {
        assignLayersLocked(displayContent.getWindowList());
      }
    }
    if ((focusChanged & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
      displayContent.layoutNeeded=true;
      if (mode == UPDATE_FOCUS_PLACING_SURFACES) {
        performLayoutLockedInner(displayContent,true,updateInputWindows);
      }
    }
    if (mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS) {
      finishUpdateFocusedWindowAfterAssignLayersLocked(updateInputWindows);
    }
    Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
    return true;
  }
  return false;
}"
1958,"private boolean doDeferEnable(Message msg){
  long delaySoFar=SystemClock.elapsedRealtime() - mDisabledTimestamp;
  if (delaySoFar > mReEnableDelayMillis) {
    return false;
  }
  log(""String_Node_Str"" + msg + ""String_Node_Str""+ (mReEnableDelayMillis - delaySoFar)+ ""String_Node_Str"");
  Message deferredMsg=obtainMessage(CMD_DEFERRED_TOGGLE);
  deferredMsg.obj=Message.obtain(msg);
  deferredMsg.arg1=++mDeferredEnableSerialNumber;
  sendMessageDelayed(deferredMsg,mReEnableDelayMillis - delaySoFar);
  return true;
}","private boolean doDeferEnable(Message msg){
  long delaySoFar=SystemClock.elapsedRealtime() - mDisabledTimestamp;
  if (delaySoFar >= mReEnableDelayMillis) {
    return false;
  }
  log(""String_Node_Str"" + msg + ""String_Node_Str""+ (mReEnableDelayMillis - delaySoFar)+ ""String_Node_Str"");
  Message deferredMsg=obtainMessage(CMD_DEFERRED_TOGGLE);
  deferredMsg.obj=Message.obtain(msg);
  deferredMsg.arg1=++mDeferredEnableSerialNumber;
  sendMessageDelayed(deferredMsg,mReEnableDelayMillis - delaySoFar);
  return true;
}"
1959,"private boolean doDeferEnable(Message msg){
  long delaySoFar=SystemClock.elapsedRealtime() - mDisabledTimestamp;
  if (delaySoFar > mReEnableDelayMillis) {
    return false;
  }
  log(""String_Node_Str"" + msg + ""String_Node_Str""+ (mReEnableDelayMillis - delaySoFar)+ ""String_Node_Str"");
  Message deferredMsg=obtainMessage(CMD_DEFERRED_TOGGLE);
  deferredMsg.obj=Message.obtain(msg);
  deferredMsg.arg1=++mDeferredEnableSerialNumber;
  sendMessageDelayed(deferredMsg,mReEnableDelayMillis - delaySoFar);
  return true;
}","private boolean doDeferEnable(Message msg){
  long delaySoFar=SystemClock.elapsedRealtime() - mDisabledTimestamp;
  if (delaySoFar >= mReEnableDelayMillis) {
    return false;
  }
  log(""String_Node_Str"" + msg + ""String_Node_Str""+ (mReEnableDelayMillis - delaySoFar)+ ""String_Node_Str"");
  Message deferredMsg=obtainMessage(CMD_DEFERRED_TOGGLE);
  deferredMsg.obj=Message.obtain(msg);
  deferredMsg.arg1=++mDeferredEnableSerialNumber;
  sendMessageDelayed(deferredMsg,mReEnableDelayMillis - delaySoFar);
  return true;
}"
1960,"private boolean doDeferEnable(Message msg){
  long delaySoFar=SystemClock.elapsedRealtime() - mDisabledTimestamp;
  if (delaySoFar > mReEnableDelayMillis) {
    return false;
  }
  log(""String_Node_Str"" + msg + ""String_Node_Str""+ (mReEnableDelayMillis - delaySoFar)+ ""String_Node_Str"");
  Message deferredMsg=obtainMessage(CMD_DEFERRED_TOGGLE);
  deferredMsg.obj=Message.obtain(msg);
  deferredMsg.arg1=++mDeferredEnableSerialNumber;
  sendMessageDelayed(deferredMsg,mReEnableDelayMillis - delaySoFar);
  return true;
}","private boolean doDeferEnable(Message msg){
  long delaySoFar=SystemClock.elapsedRealtime() - mDisabledTimestamp;
  if (delaySoFar >= mReEnableDelayMillis) {
    return false;
  }
  log(""String_Node_Str"" + msg + ""String_Node_Str""+ (mReEnableDelayMillis - delaySoFar)+ ""String_Node_Str"");
  Message deferredMsg=obtainMessage(CMD_DEFERRED_TOGGLE);
  deferredMsg.obj=Message.obtain(msg);
  deferredMsg.arg1=++mDeferredEnableSerialNumber;
  sendMessageDelayed(deferredMsg,mReEnableDelayMillis - delaySoFar);
  return true;
}"
1961,"private void replacePackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package oldPackage;
  String pkgName=pkg.packageName;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.returnCode=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
      return;
    }
    PackageSetting ps=mSettings.mPackages.get(pkgName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps.getInstalled(allUsers[i]);
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    replaceSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
}","private void replacePackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package oldPackage;
  String pkgName=pkg.packageName;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.returnCode=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
      return;
    }
    PackageSetting ps=mSettings.mPackages.get(pkgName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps != null ? ps.getInstalled(allUsers[i]) : false;
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    replaceSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
}"
1962,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private int deletePackageX(String packageName,int userId,int flags){
  final PackageRemovedInfo info=new PackageRemovedInfo();
  final boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && (dpm.packageHasActiveAdmins(packageName,userId) || dpm.isDeviceOwner(packageName))) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
  }
 catch (  RemoteException e) {
  }
  boolean removedForAllUsers=false;
  boolean systemUpdate=false;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    PackageSetting ps=mSettings.mPackages.get(packageName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps.getInstalled(allUsers[i]);
    }
  }
synchronized (mInstallLock) {
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ userId);
    res=deletePackageLI(packageName,(flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId),true,allUsers,perUserInstalled,flags | REMOVE_CHATTY,info,true);
    systemUpdate=info.isRemovedPackageSystemUpdate;
    if (res && !systemUpdate && mPackages.get(packageName) == null) {
      removedForAllUsers=true;
    }
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + systemUpdate + ""String_Node_Str""+ removedForAllUsers);
  }
  if (res) {
    info.sendBroadcast(true,systemUpdate,removedForAllUsers);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedAppId >= 0 ? info.removedAppId : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(true);
    }
  }
  return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private int deletePackageX(String packageName,int userId,int flags){
  final PackageRemovedInfo info=new PackageRemovedInfo();
  final boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && (dpm.packageHasActiveAdmins(packageName,userId) || dpm.isDeviceOwner(packageName))) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
  }
 catch (  RemoteException e) {
  }
  boolean removedForAllUsers=false;
  boolean systemUpdate=false;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    PackageSetting ps=mSettings.mPackages.get(packageName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps != null ? ps.getInstalled(allUsers[i]) : false;
    }
  }
synchronized (mInstallLock) {
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ userId);
    res=deletePackageLI(packageName,(flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId),true,allUsers,perUserInstalled,flags | REMOVE_CHATTY,info,true);
    systemUpdate=info.isRemovedPackageSystemUpdate;
    if (res && !systemUpdate && mPackages.get(packageName) == null) {
      removedForAllUsers=true;
    }
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + systemUpdate + ""String_Node_Str""+ removedForAllUsers);
  }
  if (res) {
    info.sendBroadcast(true,systemUpdate,removedForAllUsers);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedAppId >= 0 ? info.removedAppId : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(true);
    }
  }
  return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}"
1963,"private void replacePackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package oldPackage;
  String pkgName=pkg.packageName;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.returnCode=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
      return;
    }
    PackageSetting ps=mSettings.mPackages.get(pkgName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps.getInstalled(allUsers[i]);
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    replaceSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
}","private void replacePackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package oldPackage;
  String pkgName=pkg.packageName;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.returnCode=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
      return;
    }
    PackageSetting ps=mSettings.mPackages.get(pkgName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps != null ? ps.getInstalled(allUsers[i]) : false;
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    replaceSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
}"
1964,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private int deletePackageX(String packageName,int userId,int flags){
  final PackageRemovedInfo info=new PackageRemovedInfo();
  final boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && (dpm.packageHasActiveAdmins(packageName,userId) || dpm.isDeviceOwner(packageName))) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
  }
 catch (  RemoteException e) {
  }
  boolean removedForAllUsers=false;
  boolean systemUpdate=false;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    PackageSetting ps=mSettings.mPackages.get(packageName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps.getInstalled(allUsers[i]);
    }
  }
synchronized (mInstallLock) {
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ userId);
    res=deletePackageLI(packageName,(flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId),true,allUsers,perUserInstalled,flags | REMOVE_CHATTY,info,true);
    systemUpdate=info.isRemovedPackageSystemUpdate;
    if (res && !systemUpdate && mPackages.get(packageName) == null) {
      removedForAllUsers=true;
    }
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + systemUpdate + ""String_Node_Str""+ removedForAllUsers);
  }
  if (res) {
    info.sendBroadcast(true,systemUpdate,removedForAllUsers);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedAppId >= 0 ? info.removedAppId : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(true);
    }
  }
  return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private int deletePackageX(String packageName,int userId,int flags){
  final PackageRemovedInfo info=new PackageRemovedInfo();
  final boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && (dpm.packageHasActiveAdmins(packageName,userId) || dpm.isDeviceOwner(packageName))) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
  }
 catch (  RemoteException e) {
  }
  boolean removedForAllUsers=false;
  boolean systemUpdate=false;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    PackageSetting ps=mSettings.mPackages.get(packageName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps != null ? ps.getInstalled(allUsers[i]) : false;
    }
  }
synchronized (mInstallLock) {
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ userId);
    res=deletePackageLI(packageName,(flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId),true,allUsers,perUserInstalled,flags | REMOVE_CHATTY,info,true);
    systemUpdate=info.isRemovedPackageSystemUpdate;
    if (res && !systemUpdate && mPackages.get(packageName) == null) {
      removedForAllUsers=true;
    }
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + systemUpdate + ""String_Node_Str""+ removedForAllUsers);
  }
  if (res) {
    info.sendBroadcast(true,systemUpdate,removedForAllUsers);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedAppId >= 0 ? info.removedAppId : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(true);
    }
  }
  return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}"
1965,"private void replacePackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package oldPackage;
  String pkgName=pkg.packageName;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.returnCode=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
      return;
    }
    PackageSetting ps=mSettings.mPackages.get(pkgName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps.getInstalled(allUsers[i]);
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    replaceSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
}","private void replacePackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package oldPackage;
  String pkgName=pkg.packageName;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.returnCode=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
      return;
    }
    PackageSetting ps=mSettings.mPackages.get(pkgName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps != null ? ps.getInstalled(allUsers[i]) : false;
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    replaceSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
}"
1966,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private int deletePackageX(String packageName,int userId,int flags){
  final PackageRemovedInfo info=new PackageRemovedInfo();
  final boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && (dpm.packageHasActiveAdmins(packageName,userId) || dpm.isDeviceOwner(packageName))) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
  }
 catch (  RemoteException e) {
  }
  boolean removedForAllUsers=false;
  boolean systemUpdate=false;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    PackageSetting ps=mSettings.mPackages.get(packageName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps.getInstalled(allUsers[i]);
    }
  }
synchronized (mInstallLock) {
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ userId);
    res=deletePackageLI(packageName,(flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId),true,allUsers,perUserInstalled,flags | REMOVE_CHATTY,info,true);
    systemUpdate=info.isRemovedPackageSystemUpdate;
    if (res && !systemUpdate && mPackages.get(packageName) == null) {
      removedForAllUsers=true;
    }
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + systemUpdate + ""String_Node_Str""+ removedForAllUsers);
  }
  if (res) {
    info.sendBroadcast(true,systemUpdate,removedForAllUsers);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedAppId >= 0 ? info.removedAppId : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(true);
    }
  }
  return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private int deletePackageX(String packageName,int userId,int flags){
  final PackageRemovedInfo info=new PackageRemovedInfo();
  final boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && (dpm.packageHasActiveAdmins(packageName,userId) || dpm.isDeviceOwner(packageName))) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
  }
 catch (  RemoteException e) {
  }
  boolean removedForAllUsers=false;
  boolean systemUpdate=false;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    PackageSetting ps=mSettings.mPackages.get(packageName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps != null ? ps.getInstalled(allUsers[i]) : false;
    }
  }
synchronized (mInstallLock) {
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ userId);
    res=deletePackageLI(packageName,(flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId),true,allUsers,perUserInstalled,flags | REMOVE_CHATTY,info,true);
    systemUpdate=info.isRemovedPackageSystemUpdate;
    if (res && !systemUpdate && mPackages.get(packageName) == null) {
      removedForAllUsers=true;
    }
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + systemUpdate + ""String_Node_Str""+ removedForAllUsers);
  }
  if (res) {
    info.sendBroadcast(true,systemUpdate,removedForAllUsers);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedAppId >= 0 ? info.removedAppId : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(true);
    }
  }
  return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}"
1967,"private void replacePackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package oldPackage;
  String pkgName=pkg.packageName;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.returnCode=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
      return;
    }
    PackageSetting ps=mSettings.mPackages.get(pkgName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps.getInstalled(allUsers[i]);
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    replaceSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
}","private void replacePackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package oldPackage;
  String pkgName=pkg.packageName;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.returnCode=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
      return;
    }
    PackageSetting ps=mSettings.mPackages.get(pkgName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps != null ? ps.getInstalled(allUsers[i]) : false;
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    replaceSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
}"
1968,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private int deletePackageX(String packageName,int userId,int flags){
  final PackageRemovedInfo info=new PackageRemovedInfo();
  final boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && (dpm.packageHasActiveAdmins(packageName,userId) || dpm.isDeviceOwner(packageName))) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
  }
 catch (  RemoteException e) {
  }
  boolean removedForAllUsers=false;
  boolean systemUpdate=false;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    PackageSetting ps=mSettings.mPackages.get(packageName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps.getInstalled(allUsers[i]);
    }
  }
synchronized (mInstallLock) {
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ userId);
    res=deletePackageLI(packageName,(flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId),true,allUsers,perUserInstalled,flags | REMOVE_CHATTY,info,true);
    systemUpdate=info.isRemovedPackageSystemUpdate;
    if (res && !systemUpdate && mPackages.get(packageName) == null) {
      removedForAllUsers=true;
    }
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + systemUpdate + ""String_Node_Str""+ removedForAllUsers);
  }
  if (res) {
    info.sendBroadcast(true,systemUpdate,removedForAllUsers);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedAppId >= 0 ? info.removedAppId : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(true);
    }
  }
  return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private int deletePackageX(String packageName,int userId,int flags){
  final PackageRemovedInfo info=new PackageRemovedInfo();
  final boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && (dpm.packageHasActiveAdmins(packageName,userId) || dpm.isDeviceOwner(packageName))) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
  }
 catch (  RemoteException e) {
  }
  boolean removedForAllUsers=false;
  boolean systemUpdate=false;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    PackageSetting ps=mSettings.mPackages.get(packageName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps != null ? ps.getInstalled(allUsers[i]) : false;
    }
  }
synchronized (mInstallLock) {
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ userId);
    res=deletePackageLI(packageName,(flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId),true,allUsers,perUserInstalled,flags | REMOVE_CHATTY,info,true);
    systemUpdate=info.isRemovedPackageSystemUpdate;
    if (res && !systemUpdate && mPackages.get(packageName) == null) {
      removedForAllUsers=true;
    }
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + systemUpdate + ""String_Node_Str""+ removedForAllUsers);
  }
  if (res) {
    info.sendBroadcast(true,systemUpdate,removedForAllUsers);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedAppId >= 0 ? info.removedAppId : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(true);
    }
  }
  return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}"
1969,"private void replacePackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package oldPackage;
  String pkgName=pkg.packageName;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.returnCode=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
      return;
    }
    PackageSetting ps=mSettings.mPackages.get(pkgName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps.getInstalled(allUsers[i]);
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    replaceSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
}","private void replacePackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package oldPackage;
  String pkgName=pkg.packageName;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.returnCode=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
      return;
    }
    PackageSetting ps=mSettings.mPackages.get(pkgName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps != null ? ps.getInstalled(allUsers[i]) : false;
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    replaceSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLI(oldPackage,pkg,parseFlags,scanMode,user,allUsers,perUserInstalled,installerPackageName,res);
  }
}"
1970,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private int deletePackageX(String packageName,int userId,int flags){
  final PackageRemovedInfo info=new PackageRemovedInfo();
  final boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && (dpm.packageHasActiveAdmins(packageName,userId) || dpm.isDeviceOwner(packageName))) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
  }
 catch (  RemoteException e) {
  }
  boolean removedForAllUsers=false;
  boolean systemUpdate=false;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    PackageSetting ps=mSettings.mPackages.get(packageName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps.getInstalled(allUsers[i]);
    }
  }
synchronized (mInstallLock) {
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ userId);
    res=deletePackageLI(packageName,(flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId),true,allUsers,perUserInstalled,flags | REMOVE_CHATTY,info,true);
    systemUpdate=info.isRemovedPackageSystemUpdate;
    if (res && !systemUpdate && mPackages.get(packageName) == null) {
      removedForAllUsers=true;
    }
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + systemUpdate + ""String_Node_Str""+ removedForAllUsers);
  }
  if (res) {
    info.sendBroadcast(true,systemUpdate,removedForAllUsers);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedAppId >= 0 ? info.removedAppId : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(true);
    }
  }
  return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private int deletePackageX(String packageName,int userId,int flags){
  final PackageRemovedInfo info=new PackageRemovedInfo();
  final boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && (dpm.packageHasActiveAdmins(packageName,userId) || dpm.isDeviceOwner(packageName))) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
  }
 catch (  RemoteException e) {
  }
  boolean removedForAllUsers=false;
  boolean systemUpdate=false;
  int[] allUsers;
  boolean[] perUserInstalled;
synchronized (mPackages) {
    PackageSetting ps=mSettings.mPackages.get(packageName);
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps != null ? ps.getInstalled(allUsers[i]) : false;
    }
  }
synchronized (mInstallLock) {
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ userId);
    res=deletePackageLI(packageName,(flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId),true,allUsers,perUserInstalled,flags | REMOVE_CHATTY,info,true);
    systemUpdate=info.isRemovedPackageSystemUpdate;
    if (res && !systemUpdate && mPackages.get(packageName) == null) {
      removedForAllUsers=true;
    }
    if (DEBUG_REMOVE)     Slog.d(TAG,""String_Node_Str"" + systemUpdate + ""String_Node_Str""+ removedForAllUsers);
  }
  if (res) {
    info.sendBroadcast(true,systemUpdate,removedForAllUsers);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedAppId >= 0 ? info.removedAppId : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,null);
      sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(true);
    }
  }
  return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}"
1971,"/** 
 * Scrolls the specified widget to the specified coordinates, except constrains the X scrolling position to the horizontal regions of the text that will be visible after scrolling to the specified Y position.
 */
public static void scrollTo(TextView widget,Layout layout,int x,int y){
  final int horizontalPadding=widget.getTotalPaddingLeft() + widget.getTotalPaddingRight();
  final int availableWidth=widget.getWidth() - horizontalPadding;
  final int top=layout.getLineForVertical(y);
  Alignment a=layout.getParagraphAlignment(top);
  boolean ltr=layout.getParagraphDirection(top) > 0;
  int left, right;
  if (widget.getHorizontallyScrolling()) {
    final int verticalPadding=widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
    final int bottom=layout.getLineForVertical(y + widget.getHeight() - verticalPadding);
    left=Integer.MAX_VALUE;
    right=0;
    for (int i=top; i <= bottom; i++) {
      left=(int)Math.min(left,layout.getLineLeft(i));
      right=(int)Math.max(right,layout.getLineRight(i));
    }
  }
 else {
    left=0;
    right=availableWidth;
  }
  final int actualWidth=right - left;
  if (actualWidth < availableWidth) {
    if (a == Alignment.ALIGN_CENTER) {
      x=left - ((availableWidth - actualWidth) / 2);
    }
 else     if ((ltr && (a == Alignment.ALIGN_OPPOSITE)) || (a == Alignment.ALIGN_RIGHT)) {
      x=left - (availableWidth - actualWidth);
    }
 else {
      x=left;
    }
  }
 else {
    x=Math.min(x,right - availableWidth);
    x=Math.max(x,left);
  }
  widget.scrollTo(x,y);
}","/** 
 * Scrolls the specified widget to the specified coordinates, except constrains the X scrolling position to the horizontal regions of the text that will be visible after scrolling to the specified Y position.
 */
public static void scrollTo(TextView widget,Layout layout,int x,int y){
  final int horizontalPadding=widget.getTotalPaddingLeft() + widget.getTotalPaddingRight();
  final int availableWidth=widget.getWidth() - horizontalPadding;
  final int top=layout.getLineForVertical(y);
  Alignment a=layout.getParagraphAlignment(top);
  boolean ltr=layout.getParagraphDirection(top) > 0;
  int left, right;
  if (widget.getHorizontallyScrolling()) {
    final int verticalPadding=widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
    final int bottom=layout.getLineForVertical(y + widget.getHeight() - verticalPadding);
    left=Integer.MAX_VALUE;
    right=0;
    for (int i=top; i <= bottom; i++) {
      left=(int)Math.min(left,layout.getLineLeft(i));
      right=(int)Math.max(right,layout.getLineRight(i));
    }
  }
 else {
    left=0;
    right=availableWidth;
  }
  final int actualWidth=right - left;
  if (actualWidth < availableWidth) {
    if (a == Alignment.ALIGN_CENTER) {
      x=left - ((availableWidth - actualWidth) / 2);
    }
 else     if ((ltr && (a == Alignment.ALIGN_OPPOSITE)) || (!ltr && (a == Alignment.ALIGN_NORMAL)) || (a == Alignment.ALIGN_RIGHT)) {
      x=left - (availableWidth - actualWidth);
    }
 else {
      x=left;
    }
  }
 else {
    x=Math.min(x,right - availableWidth);
    x=Math.max(x,left);
  }
  widget.scrollTo(x,y);
}"
1972,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  if (mTextDir == null) {
    getTextDirectionHeuristic();
  }
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mTextDir,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWant=want;
  int hintWidth=(mHintLayout == null) ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else {
    final boolean layoutChanged=(mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight());
    final boolean widthChanged=(mHint == null) && (mEllipsize == null) && (want > mLayout.getWidth())&& (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want));
    final boolean maximumChanged=(mMaxMode != mOldMaxMode) || (mMaximum != mOldMaximum);
    if (layoutChanged || maximumChanged) {
      if (!maximumChanged && widthChanged) {
        mLayout.increaseWidthTo(want);
      }
 else {
        makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
      }
    }
 else {
    }
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,heightSize);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  if (mTextDir == null) {
    mTextDir=getTextDirectionHeuristic();
  }
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mTextDir,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWant=want;
  int hintWidth=(mHintLayout == null) ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else {
    final boolean layoutChanged=(mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight());
    final boolean widthChanged=(mHint == null) && (mEllipsize == null) && (want > mLayout.getWidth())&& (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want));
    final boolean maximumChanged=(mMaxMode != mOldMaxMode) || (mMaximum != mOldMaximum);
    if (layoutChanged || maximumChanged) {
      if (!maximumChanged && widthChanged) {
        mLayout.increaseWidthTo(want);
      }
 else {
        makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
      }
    }
 else {
    }
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,heightSize);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}"
1973,"/** 
 * Scrolls the specified widget to the specified coordinates, except constrains the X scrolling position to the horizontal regions of the text that will be visible after scrolling to the specified Y position.
 */
public static void scrollTo(TextView widget,Layout layout,int x,int y){
  final int horizontalPadding=widget.getTotalPaddingLeft() + widget.getTotalPaddingRight();
  final int availableWidth=widget.getWidth() - horizontalPadding;
  final int top=layout.getLineForVertical(y);
  Alignment a=layout.getParagraphAlignment(top);
  boolean ltr=layout.getParagraphDirection(top) > 0;
  int left, right;
  if (widget.getHorizontallyScrolling()) {
    final int verticalPadding=widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
    final int bottom=layout.getLineForVertical(y + widget.getHeight() - verticalPadding);
    left=Integer.MAX_VALUE;
    right=0;
    for (int i=top; i <= bottom; i++) {
      left=(int)Math.min(left,layout.getLineLeft(i));
      right=(int)Math.max(right,layout.getLineRight(i));
    }
  }
 else {
    left=0;
    right=availableWidth;
  }
  final int actualWidth=right - left;
  if (actualWidth < availableWidth) {
    if (a == Alignment.ALIGN_CENTER) {
      x=left - ((availableWidth - actualWidth) / 2);
    }
 else     if ((ltr && (a == Alignment.ALIGN_OPPOSITE)) || (a == Alignment.ALIGN_RIGHT)) {
      x=left - (availableWidth - actualWidth);
    }
 else {
      x=left;
    }
  }
 else {
    x=Math.min(x,right - availableWidth);
    x=Math.max(x,left);
  }
  widget.scrollTo(x,y);
}","/** 
 * Scrolls the specified widget to the specified coordinates, except constrains the X scrolling position to the horizontal regions of the text that will be visible after scrolling to the specified Y position.
 */
public static void scrollTo(TextView widget,Layout layout,int x,int y){
  final int horizontalPadding=widget.getTotalPaddingLeft() + widget.getTotalPaddingRight();
  final int availableWidth=widget.getWidth() - horizontalPadding;
  final int top=layout.getLineForVertical(y);
  Alignment a=layout.getParagraphAlignment(top);
  boolean ltr=layout.getParagraphDirection(top) > 0;
  int left, right;
  if (widget.getHorizontallyScrolling()) {
    final int verticalPadding=widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
    final int bottom=layout.getLineForVertical(y + widget.getHeight() - verticalPadding);
    left=Integer.MAX_VALUE;
    right=0;
    for (int i=top; i <= bottom; i++) {
      left=(int)Math.min(left,layout.getLineLeft(i));
      right=(int)Math.max(right,layout.getLineRight(i));
    }
  }
 else {
    left=0;
    right=availableWidth;
  }
  final int actualWidth=right - left;
  if (actualWidth < availableWidth) {
    if (a == Alignment.ALIGN_CENTER) {
      x=left - ((availableWidth - actualWidth) / 2);
    }
 else     if ((ltr && (a == Alignment.ALIGN_OPPOSITE)) || (!ltr && (a == Alignment.ALIGN_NORMAL)) || (a == Alignment.ALIGN_RIGHT)) {
      x=left - (availableWidth - actualWidth);
    }
 else {
      x=left;
    }
  }
 else {
    x=Math.min(x,right - availableWidth);
    x=Math.max(x,left);
  }
  widget.scrollTo(x,y);
}"
1974,"/** 
 * Scrolls the specified widget to the specified coordinates, except constrains the X scrolling position to the horizontal regions of the text that will be visible after scrolling to the specified Y position.
 */
public static void scrollTo(TextView widget,Layout layout,int x,int y){
  final int horizontalPadding=widget.getTotalPaddingLeft() + widget.getTotalPaddingRight();
  final int availableWidth=widget.getWidth() - horizontalPadding;
  final int top=layout.getLineForVertical(y);
  Alignment a=layout.getParagraphAlignment(top);
  boolean ltr=layout.getParagraphDirection(top) > 0;
  int left, right;
  if (widget.getHorizontallyScrolling()) {
    final int verticalPadding=widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
    final int bottom=layout.getLineForVertical(y + widget.getHeight() - verticalPadding);
    left=Integer.MAX_VALUE;
    right=0;
    for (int i=top; i <= bottom; i++) {
      left=(int)Math.min(left,layout.getLineLeft(i));
      right=(int)Math.max(right,layout.getLineRight(i));
    }
  }
 else {
    left=0;
    right=availableWidth;
  }
  final int actualWidth=right - left;
  if (actualWidth < availableWidth) {
    if (a == Alignment.ALIGN_CENTER) {
      x=left - ((availableWidth - actualWidth) / 2);
    }
 else     if ((ltr && (a == Alignment.ALIGN_OPPOSITE)) || (a == Alignment.ALIGN_RIGHT)) {
      x=left - (availableWidth - actualWidth);
    }
 else {
      x=left;
    }
  }
 else {
    x=Math.min(x,right - availableWidth);
    x=Math.max(x,left);
  }
  widget.scrollTo(x,y);
}","/** 
 * Scrolls the specified widget to the specified coordinates, except constrains the X scrolling position to the horizontal regions of the text that will be visible after scrolling to the specified Y position.
 */
public static void scrollTo(TextView widget,Layout layout,int x,int y){
  final int horizontalPadding=widget.getTotalPaddingLeft() + widget.getTotalPaddingRight();
  final int availableWidth=widget.getWidth() - horizontalPadding;
  final int top=layout.getLineForVertical(y);
  Alignment a=layout.getParagraphAlignment(top);
  boolean ltr=layout.getParagraphDirection(top) > 0;
  int left, right;
  if (widget.getHorizontallyScrolling()) {
    final int verticalPadding=widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
    final int bottom=layout.getLineForVertical(y + widget.getHeight() - verticalPadding);
    left=Integer.MAX_VALUE;
    right=0;
    for (int i=top; i <= bottom; i++) {
      left=(int)Math.min(left,layout.getLineLeft(i));
      right=(int)Math.max(right,layout.getLineRight(i));
    }
  }
 else {
    left=0;
    right=availableWidth;
  }
  final int actualWidth=right - left;
  if (actualWidth < availableWidth) {
    if (a == Alignment.ALIGN_CENTER) {
      x=left - ((availableWidth - actualWidth) / 2);
    }
 else     if ((ltr && (a == Alignment.ALIGN_OPPOSITE)) || (!ltr && (a == Alignment.ALIGN_NORMAL)) || (a == Alignment.ALIGN_RIGHT)) {
      x=left - (availableWidth - actualWidth);
    }
 else {
      x=left;
    }
  }
 else {
    x=Math.min(x,right - availableWidth);
    x=Math.max(x,left);
  }
  widget.scrollTo(x,y);
}"
1975,"/** 
 * Scrolls the specified widget to the specified coordinates, except constrains the X scrolling position to the horizontal regions of the text that will be visible after scrolling to the specified Y position.
 */
public static void scrollTo(TextView widget,Layout layout,int x,int y){
  final int horizontalPadding=widget.getTotalPaddingLeft() + widget.getTotalPaddingRight();
  final int availableWidth=widget.getWidth() - horizontalPadding;
  final int top=layout.getLineForVertical(y);
  Alignment a=layout.getParagraphAlignment(top);
  boolean ltr=layout.getParagraphDirection(top) > 0;
  int left, right;
  if (widget.getHorizontallyScrolling()) {
    final int verticalPadding=widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
    final int bottom=layout.getLineForVertical(y + widget.getHeight() - verticalPadding);
    left=Integer.MAX_VALUE;
    right=0;
    for (int i=top; i <= bottom; i++) {
      left=(int)Math.min(left,layout.getLineLeft(i));
      right=(int)Math.max(right,layout.getLineRight(i));
    }
  }
 else {
    left=0;
    right=availableWidth;
  }
  final int actualWidth=right - left;
  if (actualWidth < availableWidth) {
    if (a == Alignment.ALIGN_CENTER) {
      x=left - ((availableWidth - actualWidth) / 2);
    }
 else     if ((ltr && (a == Alignment.ALIGN_OPPOSITE)) || (a == Alignment.ALIGN_RIGHT)) {
      x=left - (availableWidth - actualWidth);
    }
 else {
      x=left;
    }
  }
 else {
    x=Math.min(x,right - availableWidth);
    x=Math.max(x,left);
  }
  widget.scrollTo(x,y);
}","/** 
 * Scrolls the specified widget to the specified coordinates, except constrains the X scrolling position to the horizontal regions of the text that will be visible after scrolling to the specified Y position.
 */
public static void scrollTo(TextView widget,Layout layout,int x,int y){
  final int horizontalPadding=widget.getTotalPaddingLeft() + widget.getTotalPaddingRight();
  final int availableWidth=widget.getWidth() - horizontalPadding;
  final int top=layout.getLineForVertical(y);
  Alignment a=layout.getParagraphAlignment(top);
  boolean ltr=layout.getParagraphDirection(top) > 0;
  int left, right;
  if (widget.getHorizontallyScrolling()) {
    final int verticalPadding=widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
    final int bottom=layout.getLineForVertical(y + widget.getHeight() - verticalPadding);
    left=Integer.MAX_VALUE;
    right=0;
    for (int i=top; i <= bottom; i++) {
      left=(int)Math.min(left,layout.getLineLeft(i));
      right=(int)Math.max(right,layout.getLineRight(i));
    }
  }
 else {
    left=0;
    right=availableWidth;
  }
  final int actualWidth=right - left;
  if (actualWidth < availableWidth) {
    if (a == Alignment.ALIGN_CENTER) {
      x=left - ((availableWidth - actualWidth) / 2);
    }
 else     if ((ltr && (a == Alignment.ALIGN_OPPOSITE)) || (!ltr && (a == Alignment.ALIGN_NORMAL)) || (a == Alignment.ALIGN_RIGHT)) {
      x=left - (availableWidth - actualWidth);
    }
 else {
      x=left;
    }
  }
 else {
    x=Math.min(x,right - availableWidth);
    x=Math.max(x,left);
  }
  widget.scrollTo(x,y);
}"
1976,"public AnimatedRotateState(AnimatedRotateState source,AnimatedRotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFramesCount=source.mFramesCount;
    mFrameDuration=source.mFrameDuration;
    mCanConstantState=mCheckedConstantState=true;
  }
}","public AnimatedRotateState(AnimatedRotateState source,AnimatedRotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(source.mDrawable.getLayoutDirection());
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFramesCount=source.mFramesCount;
    mFrameDuration=source.mFrameDuration;
    mCanConstantState=mCheckedConstantState=true;
  }
}"
1977,"ClipState(ClipState orig,ClipDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mOrientation=orig.mOrientation;
    mGravity=orig.mGravity;
    mCheckedConstantState=mCanConstantState=true;
  }
}","ClipState(ClipState orig,ClipDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(orig.mDrawable.getLayoutDirection());
    mOrientation=orig.mOrientation;
    mGravity=orig.mGravity;
    mCheckedConstantState=mCanConstantState=true;
  }
}"
1978,"DrawableContainerState(DrawableContainerState orig,DrawableContainer owner,Resources res){
  mOwner=owner;
  if (orig != null) {
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    final Drawable[] origDr=orig.mDrawables;
    mDrawables=new Drawable[origDr.length];
    mNumChildren=orig.mNumChildren;
    final int N=mNumChildren;
    for (int i=0; i < N; i++) {
      if (res != null) {
        mDrawables[i]=origDr[i].getConstantState().newDrawable(res);
      }
 else {
        mDrawables[i]=origDr[i].getConstantState().newDrawable();
      }
      mDrawables[i].setCallback(owner);
    }
    mCheckedConstantState=mCanConstantState=true;
    mVariablePadding=orig.mVariablePadding;
    if (orig.mConstantPadding != null) {
      mConstantPadding=new Rect(orig.mConstantPadding);
    }
    mConstantSize=orig.mConstantSize;
    mComputedConstantSize=orig.mComputedConstantSize;
    mConstantWidth=orig.mConstantWidth;
    mConstantHeight=orig.mConstantHeight;
    mConstantMinimumWidth=orig.mConstantMinimumWidth;
    mConstantMinimumHeight=orig.mConstantMinimumHeight;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mDither=orig.mDither;
    mEnterFadeDuration=orig.mEnterFadeDuration;
    mExitFadeDuration=orig.mExitFadeDuration;
  }
 else {
    mDrawables=new Drawable[10];
    mNumChildren=0;
    mCheckedConstantState=mCanConstantState=false;
  }
}","DrawableContainerState(DrawableContainerState orig,DrawableContainer owner,Resources res){
  mOwner=owner;
  if (orig != null) {
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    final Drawable[] origDr=orig.mDrawables;
    mDrawables=new Drawable[origDr.length];
    mNumChildren=orig.mNumChildren;
    final int N=mNumChildren;
    for (int i=0; i < N; i++) {
      if (res != null) {
        mDrawables[i]=origDr[i].getConstantState().newDrawable(res);
      }
 else {
        mDrawables[i]=origDr[i].getConstantState().newDrawable();
      }
      mDrawables[i].setCallback(owner);
      mDrawables[i].setLayoutDirection(origDr[i].getLayoutDirection());
    }
    mCheckedConstantState=mCanConstantState=true;
    mVariablePadding=orig.mVariablePadding;
    if (orig.mConstantPadding != null) {
      mConstantPadding=new Rect(orig.mConstantPadding);
    }
    mConstantSize=orig.mConstantSize;
    mComputedConstantSize=orig.mComputedConstantSize;
    mConstantWidth=orig.mConstantWidth;
    mConstantHeight=orig.mConstantHeight;
    mConstantMinimumWidth=orig.mConstantMinimumWidth;
    mConstantMinimumHeight=orig.mConstantMinimumHeight;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mDither=orig.mDither;
    mEnterFadeDuration=orig.mEnterFadeDuration;
    mExitFadeDuration=orig.mExitFadeDuration;
  }
 else {
    mDrawables=new Drawable[10];
    mNumChildren=0;
    mCheckedConstantState=mCanConstantState=false;
  }
}"
1979,"public boolean selectDrawable(int idx){
  if (idx == mCurIndex) {
    return false;
  }
  final long now=SystemClock.uptimeMillis();
  if (DEBUG)   android.util.Log.i(TAG,toString() + ""String_Node_Str"" + mCurIndex+ ""String_Node_Str""+ idx+ ""String_Node_Str""+ mDrawableContainerState.mExitFadeDuration+ ""String_Node_Str""+ mDrawableContainerState.mEnterFadeDuration);
  if (mDrawableContainerState.mExitFadeDuration > 0) {
    if (mLastDrawable != null) {
      mLastDrawable.setVisible(false,false);
    }
    if (mCurrDrawable != null) {
      mLastDrawable=mCurrDrawable;
      mExitAnimationEnd=now + mDrawableContainerState.mExitFadeDuration;
    }
 else {
      mLastDrawable=null;
      mExitAnimationEnd=0;
    }
  }
 else   if (mCurrDrawable != null) {
    mCurrDrawable.setVisible(false,false);
  }
  if (idx >= 0 && idx < mDrawableContainerState.mNumChildren) {
    Drawable d=mDrawableContainerState.mDrawables[idx];
    mCurrDrawable=d;
    mCurIndex=idx;
    if (d != null) {
      d.mutate();
      if (mDrawableContainerState.mEnterFadeDuration > 0) {
        mEnterAnimationEnd=now + mDrawableContainerState.mEnterFadeDuration;
      }
 else {
        d.setAlpha(mAlpha);
      }
      d.setVisible(isVisible(),true);
      d.setDither(mDrawableContainerState.mDither);
      d.setColorFilter(mColorFilter);
      d.setState(getState());
      d.setLevel(getLevel());
      d.setBounds(getBounds());
    }
  }
 else {
    mCurrDrawable=null;
    mCurIndex=-1;
  }
  if (mEnterAnimationEnd != 0 || mExitAnimationEnd != 0) {
    if (mAnimationRunnable == null) {
      mAnimationRunnable=new Runnable(){
        @Override public void run(){
          animate(true);
          invalidateSelf();
        }
      }
;
    }
 else {
      unscheduleSelf(mAnimationRunnable);
    }
    animate(true);
  }
  invalidateSelf();
  return true;
}","public boolean selectDrawable(int idx){
  if (idx == mCurIndex) {
    return false;
  }
  final long now=SystemClock.uptimeMillis();
  if (DEBUG)   android.util.Log.i(TAG,toString() + ""String_Node_Str"" + mCurIndex+ ""String_Node_Str""+ idx+ ""String_Node_Str""+ mDrawableContainerState.mExitFadeDuration+ ""String_Node_Str""+ mDrawableContainerState.mEnterFadeDuration);
  if (mDrawableContainerState.mExitFadeDuration > 0) {
    if (mLastDrawable != null) {
      mLastDrawable.setVisible(false,false);
    }
    if (mCurrDrawable != null) {
      mLastDrawable=mCurrDrawable;
      mExitAnimationEnd=now + mDrawableContainerState.mExitFadeDuration;
    }
 else {
      mLastDrawable=null;
      mExitAnimationEnd=0;
    }
  }
 else   if (mCurrDrawable != null) {
    mCurrDrawable.setVisible(false,false);
  }
  if (idx >= 0 && idx < mDrawableContainerState.mNumChildren) {
    Drawable d=mDrawableContainerState.mDrawables[idx];
    mCurrDrawable=d;
    mCurIndex=idx;
    if (d != null) {
      d.mutate();
      if (mDrawableContainerState.mEnterFadeDuration > 0) {
        mEnterAnimationEnd=now + mDrawableContainerState.mEnterFadeDuration;
      }
 else {
        d.setAlpha(mAlpha);
      }
      d.setVisible(isVisible(),true);
      d.setDither(mDrawableContainerState.mDither);
      d.setColorFilter(mColorFilter);
      d.setState(getState());
      d.setLevel(getLevel());
      d.setBounds(getBounds());
      d.setLayoutDirection(getLayoutDirection());
    }
  }
 else {
    mCurrDrawable=null;
    mCurIndex=-1;
  }
  if (mEnterAnimationEnd != 0 || mExitAnimationEnd != 0) {
    if (mAnimationRunnable == null) {
      mAnimationRunnable=new Runnable(){
        @Override public void run(){
          animate(true);
          invalidateSelf();
        }
      }
;
    }
 else {
      unscheduleSelf(mAnimationRunnable);
    }
    animate(true);
  }
  invalidateSelf();
  return true;
}"
1980,"InsetState(InsetState orig,InsetDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mInsetLeft=orig.mInsetLeft;
    mInsetTop=orig.mInsetTop;
    mInsetRight=orig.mInsetRight;
    mInsetBottom=orig.mInsetBottom;
    mCheckedConstantState=mCanConstantState=true;
  }
}","InsetState(InsetState orig,InsetDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(orig.mDrawable.getLayoutDirection());
    mInsetLeft=orig.mInsetLeft;
    mInsetTop=orig.mInsetTop;
    mInsetRight=orig.mInsetRight;
    mInsetBottom=orig.mInsetBottom;
    mCheckedConstantState=mCanConstantState=true;
  }
}"
1981,"/** 
 * @hide 
 */
@Override public void setLayoutDirection(int layoutDirection){
  if (getLayoutDirection() != layoutDirection) {
    final ChildDrawable[] array=mLayerState.mChildren;
    final int N=mLayerState.mNum;
    for (int i=0; i < N; i++) {
      array[i].mDrawable.setLayoutDirection(layoutDirection);
    }
  }
  super.setLayoutDirection(layoutDirection);
}","/** 
 * @hide 
 */
@Override public void setLayoutDirection(int layoutDirection){
  final ChildDrawable[] array=mLayerState.mChildren;
  final int N=mLayerState.mNum;
  for (int i=0; i < N; i++) {
    array[i].mDrawable.setLayoutDirection(layoutDirection);
  }
  super.setLayoutDirection(layoutDirection);
}"
1982,"LayerState(LayerState orig,LayerDrawable owner,Resources res){
  if (orig != null) {
    final ChildDrawable[] origChildDrawable=orig.mChildren;
    final int N=orig.mNum;
    mNum=N;
    mChildren=new ChildDrawable[N];
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    for (int i=0; i < N; i++) {
      final ChildDrawable r=mChildren[i]=new ChildDrawable();
      final ChildDrawable or=origChildDrawable[i];
      if (res != null) {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable(res);
      }
 else {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable();
      }
      r.mDrawable.setCallback(owner);
      r.mInsetL=or.mInsetL;
      r.mInsetT=or.mInsetT;
      r.mInsetR=or.mInsetR;
      r.mInsetB=or.mInsetB;
      r.mId=or.mId;
    }
    mHaveOpacity=orig.mHaveOpacity;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mCheckedConstantState=mCanConstantState=true;
  }
 else {
    mNum=0;
    mChildren=null;
  }
}","LayerState(LayerState orig,LayerDrawable owner,Resources res){
  if (orig != null) {
    final ChildDrawable[] origChildDrawable=orig.mChildren;
    final int N=orig.mNum;
    mNum=N;
    mChildren=new ChildDrawable[N];
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    for (int i=0; i < N; i++) {
      final ChildDrawable r=mChildren[i]=new ChildDrawable();
      final ChildDrawable or=origChildDrawable[i];
      if (res != null) {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable(res);
      }
 else {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable();
      }
      r.mDrawable.setCallback(owner);
      r.mDrawable.setLayoutDirection(or.mDrawable.getLayoutDirection());
      r.mInsetL=or.mInsetL;
      r.mInsetT=or.mInsetT;
      r.mInsetR=or.mInsetR;
      r.mInsetB=or.mInsetB;
      r.mId=or.mId;
    }
    mHaveOpacity=orig.mHaveOpacity;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mCheckedConstantState=mCanConstantState=true;
  }
 else {
    mNum=0;
    mChildren=null;
  }
}"
1983,"public RotateState(RotateState source,RotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFromDegrees=mCurrentDegrees=source.mFromDegrees;
    mToDegrees=source.mToDegrees;
    mCanConstantState=mCheckedConstantState=true;
  }
}","public RotateState(RotateState source,RotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(source.mDrawable.getLayoutDirection());
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFromDegrees=mCurrentDegrees=source.mFromDegrees;
    mToDegrees=source.mToDegrees;
    mCanConstantState=mCheckedConstantState=true;
  }
}"
1984,"ScaleState(ScaleState orig,ScaleDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mScaleWidth=orig.mScaleWidth;
    mScaleHeight=orig.mScaleHeight;
    mGravity=orig.mGravity;
    mUseIntrinsicSizeAsMin=orig.mUseIntrinsicSizeAsMin;
    mCheckedConstantState=mCanConstantState=true;
  }
}","ScaleState(ScaleState orig,ScaleDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(orig.mDrawable.getLayoutDirection());
    mScaleWidth=orig.mScaleWidth;
    mScaleHeight=orig.mScaleHeight;
    mGravity=orig.mGravity;
    mUseIntrinsicSizeAsMin=orig.mUseIntrinsicSizeAsMin;
    mCheckedConstantState=mCanConstantState=true;
  }
}"
1985,"public AnimatedRotateState(AnimatedRotateState source,AnimatedRotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFramesCount=source.mFramesCount;
    mFrameDuration=source.mFrameDuration;
    mCanConstantState=mCheckedConstantState=true;
  }
}","public AnimatedRotateState(AnimatedRotateState source,AnimatedRotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(source.mDrawable.getLayoutDirection());
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFramesCount=source.mFramesCount;
    mFrameDuration=source.mFrameDuration;
    mCanConstantState=mCheckedConstantState=true;
  }
}"
1986,"ClipState(ClipState orig,ClipDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mOrientation=orig.mOrientation;
    mGravity=orig.mGravity;
    mCheckedConstantState=mCanConstantState=true;
  }
}","ClipState(ClipState orig,ClipDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(orig.mDrawable.getLayoutDirection());
    mOrientation=orig.mOrientation;
    mGravity=orig.mGravity;
    mCheckedConstantState=mCanConstantState=true;
  }
}"
1987,"DrawableContainerState(DrawableContainerState orig,DrawableContainer owner,Resources res){
  mOwner=owner;
  if (orig != null) {
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    final Drawable[] origDr=orig.mDrawables;
    mDrawables=new Drawable[origDr.length];
    mNumChildren=orig.mNumChildren;
    final int N=mNumChildren;
    for (int i=0; i < N; i++) {
      if (res != null) {
        mDrawables[i]=origDr[i].getConstantState().newDrawable(res);
      }
 else {
        mDrawables[i]=origDr[i].getConstantState().newDrawable();
      }
      mDrawables[i].setCallback(owner);
    }
    mCheckedConstantState=mCanConstantState=true;
    mVariablePadding=orig.mVariablePadding;
    if (orig.mConstantPadding != null) {
      mConstantPadding=new Rect(orig.mConstantPadding);
    }
    mConstantSize=orig.mConstantSize;
    mComputedConstantSize=orig.mComputedConstantSize;
    mConstantWidth=orig.mConstantWidth;
    mConstantHeight=orig.mConstantHeight;
    mConstantMinimumWidth=orig.mConstantMinimumWidth;
    mConstantMinimumHeight=orig.mConstantMinimumHeight;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mDither=orig.mDither;
    mEnterFadeDuration=orig.mEnterFadeDuration;
    mExitFadeDuration=orig.mExitFadeDuration;
  }
 else {
    mDrawables=new Drawable[10];
    mNumChildren=0;
    mCheckedConstantState=mCanConstantState=false;
  }
}","DrawableContainerState(DrawableContainerState orig,DrawableContainer owner,Resources res){
  mOwner=owner;
  if (orig != null) {
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    final Drawable[] origDr=orig.mDrawables;
    mDrawables=new Drawable[origDr.length];
    mNumChildren=orig.mNumChildren;
    final int N=mNumChildren;
    for (int i=0; i < N; i++) {
      if (res != null) {
        mDrawables[i]=origDr[i].getConstantState().newDrawable(res);
      }
 else {
        mDrawables[i]=origDr[i].getConstantState().newDrawable();
      }
      mDrawables[i].setCallback(owner);
      mDrawables[i].setLayoutDirection(origDr[i].getLayoutDirection());
    }
    mCheckedConstantState=mCanConstantState=true;
    mVariablePadding=orig.mVariablePadding;
    if (orig.mConstantPadding != null) {
      mConstantPadding=new Rect(orig.mConstantPadding);
    }
    mConstantSize=orig.mConstantSize;
    mComputedConstantSize=orig.mComputedConstantSize;
    mConstantWidth=orig.mConstantWidth;
    mConstantHeight=orig.mConstantHeight;
    mConstantMinimumWidth=orig.mConstantMinimumWidth;
    mConstantMinimumHeight=orig.mConstantMinimumHeight;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mDither=orig.mDither;
    mEnterFadeDuration=orig.mEnterFadeDuration;
    mExitFadeDuration=orig.mExitFadeDuration;
  }
 else {
    mDrawables=new Drawable[10];
    mNumChildren=0;
    mCheckedConstantState=mCanConstantState=false;
  }
}"
1988,"public boolean selectDrawable(int idx){
  if (idx == mCurIndex) {
    return false;
  }
  final long now=SystemClock.uptimeMillis();
  if (DEBUG)   android.util.Log.i(TAG,toString() + ""String_Node_Str"" + mCurIndex+ ""String_Node_Str""+ idx+ ""String_Node_Str""+ mDrawableContainerState.mExitFadeDuration+ ""String_Node_Str""+ mDrawableContainerState.mEnterFadeDuration);
  if (mDrawableContainerState.mExitFadeDuration > 0) {
    if (mLastDrawable != null) {
      mLastDrawable.setVisible(false,false);
    }
    if (mCurrDrawable != null) {
      mLastDrawable=mCurrDrawable;
      mExitAnimationEnd=now + mDrawableContainerState.mExitFadeDuration;
    }
 else {
      mLastDrawable=null;
      mExitAnimationEnd=0;
    }
  }
 else   if (mCurrDrawable != null) {
    mCurrDrawable.setVisible(false,false);
  }
  if (idx >= 0 && idx < mDrawableContainerState.mNumChildren) {
    Drawable d=mDrawableContainerState.mDrawables[idx];
    mCurrDrawable=d;
    mCurIndex=idx;
    if (d != null) {
      d.mutate();
      if (mDrawableContainerState.mEnterFadeDuration > 0) {
        mEnterAnimationEnd=now + mDrawableContainerState.mEnterFadeDuration;
      }
 else {
        d.setAlpha(mAlpha);
      }
      d.setVisible(isVisible(),true);
      d.setDither(mDrawableContainerState.mDither);
      d.setColorFilter(mColorFilter);
      d.setState(getState());
      d.setLevel(getLevel());
      d.setBounds(getBounds());
    }
  }
 else {
    mCurrDrawable=null;
    mCurIndex=-1;
  }
  if (mEnterAnimationEnd != 0 || mExitAnimationEnd != 0) {
    if (mAnimationRunnable == null) {
      mAnimationRunnable=new Runnable(){
        @Override public void run(){
          animate(true);
          invalidateSelf();
        }
      }
;
    }
 else {
      unscheduleSelf(mAnimationRunnable);
    }
    animate(true);
  }
  invalidateSelf();
  return true;
}","public boolean selectDrawable(int idx){
  if (idx == mCurIndex) {
    return false;
  }
  final long now=SystemClock.uptimeMillis();
  if (DEBUG)   android.util.Log.i(TAG,toString() + ""String_Node_Str"" + mCurIndex+ ""String_Node_Str""+ idx+ ""String_Node_Str""+ mDrawableContainerState.mExitFadeDuration+ ""String_Node_Str""+ mDrawableContainerState.mEnterFadeDuration);
  if (mDrawableContainerState.mExitFadeDuration > 0) {
    if (mLastDrawable != null) {
      mLastDrawable.setVisible(false,false);
    }
    if (mCurrDrawable != null) {
      mLastDrawable=mCurrDrawable;
      mExitAnimationEnd=now + mDrawableContainerState.mExitFadeDuration;
    }
 else {
      mLastDrawable=null;
      mExitAnimationEnd=0;
    }
  }
 else   if (mCurrDrawable != null) {
    mCurrDrawable.setVisible(false,false);
  }
  if (idx >= 0 && idx < mDrawableContainerState.mNumChildren) {
    Drawable d=mDrawableContainerState.mDrawables[idx];
    mCurrDrawable=d;
    mCurIndex=idx;
    if (d != null) {
      d.mutate();
      if (mDrawableContainerState.mEnterFadeDuration > 0) {
        mEnterAnimationEnd=now + mDrawableContainerState.mEnterFadeDuration;
      }
 else {
        d.setAlpha(mAlpha);
      }
      d.setVisible(isVisible(),true);
      d.setDither(mDrawableContainerState.mDither);
      d.setColorFilter(mColorFilter);
      d.setState(getState());
      d.setLevel(getLevel());
      d.setBounds(getBounds());
      d.setLayoutDirection(getLayoutDirection());
    }
  }
 else {
    mCurrDrawable=null;
    mCurIndex=-1;
  }
  if (mEnterAnimationEnd != 0 || mExitAnimationEnd != 0) {
    if (mAnimationRunnable == null) {
      mAnimationRunnable=new Runnable(){
        @Override public void run(){
          animate(true);
          invalidateSelf();
        }
      }
;
    }
 else {
      unscheduleSelf(mAnimationRunnable);
    }
    animate(true);
  }
  invalidateSelf();
  return true;
}"
1989,"InsetState(InsetState orig,InsetDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mInsetLeft=orig.mInsetLeft;
    mInsetTop=orig.mInsetTop;
    mInsetRight=orig.mInsetRight;
    mInsetBottom=orig.mInsetBottom;
    mCheckedConstantState=mCanConstantState=true;
  }
}","InsetState(InsetState orig,InsetDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(orig.mDrawable.getLayoutDirection());
    mInsetLeft=orig.mInsetLeft;
    mInsetTop=orig.mInsetTop;
    mInsetRight=orig.mInsetRight;
    mInsetBottom=orig.mInsetBottom;
    mCheckedConstantState=mCanConstantState=true;
  }
}"
1990,"/** 
 * @hide 
 */
@Override public void setLayoutDirection(int layoutDirection){
  if (getLayoutDirection() != layoutDirection) {
    final ChildDrawable[] array=mLayerState.mChildren;
    final int N=mLayerState.mNum;
    for (int i=0; i < N; i++) {
      array[i].mDrawable.setLayoutDirection(layoutDirection);
    }
  }
  super.setLayoutDirection(layoutDirection);
}","/** 
 * @hide 
 */
@Override public void setLayoutDirection(int layoutDirection){
  final ChildDrawable[] array=mLayerState.mChildren;
  final int N=mLayerState.mNum;
  for (int i=0; i < N; i++) {
    array[i].mDrawable.setLayoutDirection(layoutDirection);
  }
  super.setLayoutDirection(layoutDirection);
}"
1991,"LayerState(LayerState orig,LayerDrawable owner,Resources res){
  if (orig != null) {
    final ChildDrawable[] origChildDrawable=orig.mChildren;
    final int N=orig.mNum;
    mNum=N;
    mChildren=new ChildDrawable[N];
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    for (int i=0; i < N; i++) {
      final ChildDrawable r=mChildren[i]=new ChildDrawable();
      final ChildDrawable or=origChildDrawable[i];
      if (res != null) {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable(res);
      }
 else {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable();
      }
      r.mDrawable.setCallback(owner);
      r.mInsetL=or.mInsetL;
      r.mInsetT=or.mInsetT;
      r.mInsetR=or.mInsetR;
      r.mInsetB=or.mInsetB;
      r.mId=or.mId;
    }
    mHaveOpacity=orig.mHaveOpacity;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mCheckedConstantState=mCanConstantState=true;
  }
 else {
    mNum=0;
    mChildren=null;
  }
}","LayerState(LayerState orig,LayerDrawable owner,Resources res){
  if (orig != null) {
    final ChildDrawable[] origChildDrawable=orig.mChildren;
    final int N=orig.mNum;
    mNum=N;
    mChildren=new ChildDrawable[N];
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    for (int i=0; i < N; i++) {
      final ChildDrawable r=mChildren[i]=new ChildDrawable();
      final ChildDrawable or=origChildDrawable[i];
      if (res != null) {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable(res);
      }
 else {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable();
      }
      r.mDrawable.setCallback(owner);
      r.mDrawable.setLayoutDirection(or.mDrawable.getLayoutDirection());
      r.mInsetL=or.mInsetL;
      r.mInsetT=or.mInsetT;
      r.mInsetR=or.mInsetR;
      r.mInsetB=or.mInsetB;
      r.mId=or.mId;
    }
    mHaveOpacity=orig.mHaveOpacity;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mCheckedConstantState=mCanConstantState=true;
  }
 else {
    mNum=0;
    mChildren=null;
  }
}"
1992,"public RotateState(RotateState source,RotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFromDegrees=mCurrentDegrees=source.mFromDegrees;
    mToDegrees=source.mToDegrees;
    mCanConstantState=mCheckedConstantState=true;
  }
}","public RotateState(RotateState source,RotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(source.mDrawable.getLayoutDirection());
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFromDegrees=mCurrentDegrees=source.mFromDegrees;
    mToDegrees=source.mToDegrees;
    mCanConstantState=mCheckedConstantState=true;
  }
}"
1993,"ScaleState(ScaleState orig,ScaleDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mScaleWidth=orig.mScaleWidth;
    mScaleHeight=orig.mScaleHeight;
    mGravity=orig.mGravity;
    mUseIntrinsicSizeAsMin=orig.mUseIntrinsicSizeAsMin;
    mCheckedConstantState=mCanConstantState=true;
  }
}","ScaleState(ScaleState orig,ScaleDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(orig.mDrawable.getLayoutDirection());
    mScaleWidth=orig.mScaleWidth;
    mScaleHeight=orig.mScaleHeight;
    mGravity=orig.mGravity;
    mUseIntrinsicSizeAsMin=orig.mUseIntrinsicSizeAsMin;
    mCheckedConstantState=mCanConstantState=true;
  }
}"
1994,"public AnimatedRotateState(AnimatedRotateState source,AnimatedRotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFramesCount=source.mFramesCount;
    mFrameDuration=source.mFrameDuration;
    mCanConstantState=mCheckedConstantState=true;
  }
}","public AnimatedRotateState(AnimatedRotateState source,AnimatedRotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(source.mDrawable.getLayoutDirection());
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFramesCount=source.mFramesCount;
    mFrameDuration=source.mFrameDuration;
    mCanConstantState=mCheckedConstantState=true;
  }
}"
1995,"ClipState(ClipState orig,ClipDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mOrientation=orig.mOrientation;
    mGravity=orig.mGravity;
    mCheckedConstantState=mCanConstantState=true;
  }
}","ClipState(ClipState orig,ClipDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(orig.mDrawable.getLayoutDirection());
    mOrientation=orig.mOrientation;
    mGravity=orig.mGravity;
    mCheckedConstantState=mCanConstantState=true;
  }
}"
1996,"DrawableContainerState(DrawableContainerState orig,DrawableContainer owner,Resources res){
  mOwner=owner;
  if (orig != null) {
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    final Drawable[] origDr=orig.mDrawables;
    mDrawables=new Drawable[origDr.length];
    mNumChildren=orig.mNumChildren;
    final int N=mNumChildren;
    for (int i=0; i < N; i++) {
      if (res != null) {
        mDrawables[i]=origDr[i].getConstantState().newDrawable(res);
      }
 else {
        mDrawables[i]=origDr[i].getConstantState().newDrawable();
      }
      mDrawables[i].setCallback(owner);
    }
    mCheckedConstantState=mCanConstantState=true;
    mVariablePadding=orig.mVariablePadding;
    if (orig.mConstantPadding != null) {
      mConstantPadding=new Rect(orig.mConstantPadding);
    }
    mConstantSize=orig.mConstantSize;
    mComputedConstantSize=orig.mComputedConstantSize;
    mConstantWidth=orig.mConstantWidth;
    mConstantHeight=orig.mConstantHeight;
    mConstantMinimumWidth=orig.mConstantMinimumWidth;
    mConstantMinimumHeight=orig.mConstantMinimumHeight;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mDither=orig.mDither;
    mEnterFadeDuration=orig.mEnterFadeDuration;
    mExitFadeDuration=orig.mExitFadeDuration;
  }
 else {
    mDrawables=new Drawable[10];
    mNumChildren=0;
    mCheckedConstantState=mCanConstantState=false;
  }
}","DrawableContainerState(DrawableContainerState orig,DrawableContainer owner,Resources res){
  mOwner=owner;
  if (orig != null) {
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    final Drawable[] origDr=orig.mDrawables;
    mDrawables=new Drawable[origDr.length];
    mNumChildren=orig.mNumChildren;
    final int N=mNumChildren;
    for (int i=0; i < N; i++) {
      if (res != null) {
        mDrawables[i]=origDr[i].getConstantState().newDrawable(res);
      }
 else {
        mDrawables[i]=origDr[i].getConstantState().newDrawable();
      }
      mDrawables[i].setCallback(owner);
      mDrawables[i].setLayoutDirection(origDr[i].getLayoutDirection());
    }
    mCheckedConstantState=mCanConstantState=true;
    mVariablePadding=orig.mVariablePadding;
    if (orig.mConstantPadding != null) {
      mConstantPadding=new Rect(orig.mConstantPadding);
    }
    mConstantSize=orig.mConstantSize;
    mComputedConstantSize=orig.mComputedConstantSize;
    mConstantWidth=orig.mConstantWidth;
    mConstantHeight=orig.mConstantHeight;
    mConstantMinimumWidth=orig.mConstantMinimumWidth;
    mConstantMinimumHeight=orig.mConstantMinimumHeight;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mDither=orig.mDither;
    mEnterFadeDuration=orig.mEnterFadeDuration;
    mExitFadeDuration=orig.mExitFadeDuration;
  }
 else {
    mDrawables=new Drawable[10];
    mNumChildren=0;
    mCheckedConstantState=mCanConstantState=false;
  }
}"
1997,"public boolean selectDrawable(int idx){
  if (idx == mCurIndex) {
    return false;
  }
  final long now=SystemClock.uptimeMillis();
  if (DEBUG)   android.util.Log.i(TAG,toString() + ""String_Node_Str"" + mCurIndex+ ""String_Node_Str""+ idx+ ""String_Node_Str""+ mDrawableContainerState.mExitFadeDuration+ ""String_Node_Str""+ mDrawableContainerState.mEnterFadeDuration);
  if (mDrawableContainerState.mExitFadeDuration > 0) {
    if (mLastDrawable != null) {
      mLastDrawable.setVisible(false,false);
    }
    if (mCurrDrawable != null) {
      mLastDrawable=mCurrDrawable;
      mExitAnimationEnd=now + mDrawableContainerState.mExitFadeDuration;
    }
 else {
      mLastDrawable=null;
      mExitAnimationEnd=0;
    }
  }
 else   if (mCurrDrawable != null) {
    mCurrDrawable.setVisible(false,false);
  }
  if (idx >= 0 && idx < mDrawableContainerState.mNumChildren) {
    Drawable d=mDrawableContainerState.mDrawables[idx];
    mCurrDrawable=d;
    mCurIndex=idx;
    if (d != null) {
      d.mutate();
      if (mDrawableContainerState.mEnterFadeDuration > 0) {
        mEnterAnimationEnd=now + mDrawableContainerState.mEnterFadeDuration;
      }
 else {
        d.setAlpha(mAlpha);
      }
      d.setVisible(isVisible(),true);
      d.setDither(mDrawableContainerState.mDither);
      d.setColorFilter(mColorFilter);
      d.setState(getState());
      d.setLevel(getLevel());
      d.setBounds(getBounds());
    }
  }
 else {
    mCurrDrawable=null;
    mCurIndex=-1;
  }
  if (mEnterAnimationEnd != 0 || mExitAnimationEnd != 0) {
    if (mAnimationRunnable == null) {
      mAnimationRunnable=new Runnable(){
        @Override public void run(){
          animate(true);
          invalidateSelf();
        }
      }
;
    }
 else {
      unscheduleSelf(mAnimationRunnable);
    }
    animate(true);
  }
  invalidateSelf();
  return true;
}","public boolean selectDrawable(int idx){
  if (idx == mCurIndex) {
    return false;
  }
  final long now=SystemClock.uptimeMillis();
  if (DEBUG)   android.util.Log.i(TAG,toString() + ""String_Node_Str"" + mCurIndex+ ""String_Node_Str""+ idx+ ""String_Node_Str""+ mDrawableContainerState.mExitFadeDuration+ ""String_Node_Str""+ mDrawableContainerState.mEnterFadeDuration);
  if (mDrawableContainerState.mExitFadeDuration > 0) {
    if (mLastDrawable != null) {
      mLastDrawable.setVisible(false,false);
    }
    if (mCurrDrawable != null) {
      mLastDrawable=mCurrDrawable;
      mExitAnimationEnd=now + mDrawableContainerState.mExitFadeDuration;
    }
 else {
      mLastDrawable=null;
      mExitAnimationEnd=0;
    }
  }
 else   if (mCurrDrawable != null) {
    mCurrDrawable.setVisible(false,false);
  }
  if (idx >= 0 && idx < mDrawableContainerState.mNumChildren) {
    Drawable d=mDrawableContainerState.mDrawables[idx];
    mCurrDrawable=d;
    mCurIndex=idx;
    if (d != null) {
      d.mutate();
      if (mDrawableContainerState.mEnterFadeDuration > 0) {
        mEnterAnimationEnd=now + mDrawableContainerState.mEnterFadeDuration;
      }
 else {
        d.setAlpha(mAlpha);
      }
      d.setVisible(isVisible(),true);
      d.setDither(mDrawableContainerState.mDither);
      d.setColorFilter(mColorFilter);
      d.setState(getState());
      d.setLevel(getLevel());
      d.setBounds(getBounds());
      d.setLayoutDirection(getLayoutDirection());
    }
  }
 else {
    mCurrDrawable=null;
    mCurIndex=-1;
  }
  if (mEnterAnimationEnd != 0 || mExitAnimationEnd != 0) {
    if (mAnimationRunnable == null) {
      mAnimationRunnable=new Runnable(){
        @Override public void run(){
          animate(true);
          invalidateSelf();
        }
      }
;
    }
 else {
      unscheduleSelf(mAnimationRunnable);
    }
    animate(true);
  }
  invalidateSelf();
  return true;
}"
1998,"InsetState(InsetState orig,InsetDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mInsetLeft=orig.mInsetLeft;
    mInsetTop=orig.mInsetTop;
    mInsetRight=orig.mInsetRight;
    mInsetBottom=orig.mInsetBottom;
    mCheckedConstantState=mCanConstantState=true;
  }
}","InsetState(InsetState orig,InsetDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(orig.mDrawable.getLayoutDirection());
    mInsetLeft=orig.mInsetLeft;
    mInsetTop=orig.mInsetTop;
    mInsetRight=orig.mInsetRight;
    mInsetBottom=orig.mInsetBottom;
    mCheckedConstantState=mCanConstantState=true;
  }
}"
1999,"/** 
 * @hide 
 */
@Override public void setLayoutDirection(int layoutDirection){
  if (getLayoutDirection() != layoutDirection) {
    final ChildDrawable[] array=mLayerState.mChildren;
    final int N=mLayerState.mNum;
    for (int i=0; i < N; i++) {
      array[i].mDrawable.setLayoutDirection(layoutDirection);
    }
  }
  super.setLayoutDirection(layoutDirection);
}","/** 
 * @hide 
 */
@Override public void setLayoutDirection(int layoutDirection){
  final ChildDrawable[] array=mLayerState.mChildren;
  final int N=mLayerState.mNum;
  for (int i=0; i < N; i++) {
    array[i].mDrawable.setLayoutDirection(layoutDirection);
  }
  super.setLayoutDirection(layoutDirection);
}"
2000,"LayerState(LayerState orig,LayerDrawable owner,Resources res){
  if (orig != null) {
    final ChildDrawable[] origChildDrawable=orig.mChildren;
    final int N=orig.mNum;
    mNum=N;
    mChildren=new ChildDrawable[N];
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    for (int i=0; i < N; i++) {
      final ChildDrawable r=mChildren[i]=new ChildDrawable();
      final ChildDrawable or=origChildDrawable[i];
      if (res != null) {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable(res);
      }
 else {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable();
      }
      r.mDrawable.setCallback(owner);
      r.mInsetL=or.mInsetL;
      r.mInsetT=or.mInsetT;
      r.mInsetR=or.mInsetR;
      r.mInsetB=or.mInsetB;
      r.mId=or.mId;
    }
    mHaveOpacity=orig.mHaveOpacity;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mCheckedConstantState=mCanConstantState=true;
  }
 else {
    mNum=0;
    mChildren=null;
  }
}","LayerState(LayerState orig,LayerDrawable owner,Resources res){
  if (orig != null) {
    final ChildDrawable[] origChildDrawable=orig.mChildren;
    final int N=orig.mNum;
    mNum=N;
    mChildren=new ChildDrawable[N];
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    for (int i=0; i < N; i++) {
      final ChildDrawable r=mChildren[i]=new ChildDrawable();
      final ChildDrawable or=origChildDrawable[i];
      if (res != null) {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable(res);
      }
 else {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable();
      }
      r.mDrawable.setCallback(owner);
      r.mDrawable.setLayoutDirection(or.mDrawable.getLayoutDirection());
      r.mInsetL=or.mInsetL;
      r.mInsetT=or.mInsetT;
      r.mInsetR=or.mInsetR;
      r.mInsetB=or.mInsetB;
      r.mId=or.mId;
    }
    mHaveOpacity=orig.mHaveOpacity;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mCheckedConstantState=mCanConstantState=true;
  }
 else {
    mNum=0;
    mChildren=null;
  }
}"
