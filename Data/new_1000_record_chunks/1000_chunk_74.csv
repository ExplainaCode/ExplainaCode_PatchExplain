record_number,buggy_code,fixed_code
73001,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MetroIIDEDirector newObject=(MetroIIDEDirector)super.clone(workspace);
  newObject._nameToActor=(Hashtable<String,Actor>)_nameToActor.clone();
  newObject._actorDictionary=(Hashtable<String,FireMachine>)_actorDictionary.clone();
  newObject._events=(ArrayList<Builder>)_events.clone();
  newObject.actorList=(ArrayList<Actor>)actorList.clone();
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MetroIIDEDirector newObject=(MetroIIDEDirector)super.clone(workspace);
  newObject._nameToActor=(Hashtable<String,Actor>)_nameToActor.clone();
  newObject._actorDictionary=(Hashtable<String,FireMachine>)_actorDictionary.clone();
  newObject._events=(ArrayList<Builder>)_events.clone();
  newObject.actorList=(ArrayList<Actor>)actorList.clone();
  newObject._pendingIteration=(Hashtable<String,Integer>)_pendingIteration.clone();
  return newObject;
}"
73002,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MetroIIDirector newObject=(MetroIIDirector)super.clone(workspace);
  newObject._mappingConstraintSolver=new MappingConstraintSolver(_maxEvent);
  newObject._actorList=(LinkedList)_actorList.clone();
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MetroIIDirector newObject=(MetroIIDirector)super.clone(workspace);
  newObject._mappingConstraintSolver=new MappingConstraintSolver(_maxEvent);
  newObject._actorList=(LinkedList)_actorList.clone();
  newObject._timeScheduler=(TimeScheduler)_timeScheduler.clone();
  return newObject;
}"
73003,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MetroIIDirector newObject=(MetroIIDirector)super.clone(workspace);
  newObject._mappingConstraintSolver=new MappingConstraintSolver(_maxEvent);
  newObject._actorList=(LinkedList)_actorList.clone();
  newObject._timeScheduler=(TimeScheduler)_timeScheduler.clone();
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MetroIIDirector newObject=(MetroIIDirector)super.clone(workspace);
  newObject._mappingConstraintSolver=new MappingConstraintSolver(_maxEvent);
  newObject._actorList=new LinkedList<StartOrResumable>();
  newObject._timeScheduler=new TimeScheduler();
  return newObject;
}"
73004,"public FireMachine(Actor actor){
  _actor=actor;
  _iteration=0;
  reset();
}","public FireMachine(Actor actor){
  _actor=actor;
  reset();
}"
73005,"/** 
 * Dispose the current execution.
 */
public void reset(){
  if (_iteration > 0) {
    setStatus(Status.BEGIN);
    _currentStateEvent=_createMetroIIEvent(""String_Node_Str"");
    _iteration--;
  }
 else {
    setStatus(Status.START);
    _currentStateEvent=null;
    _iteration=0;
  }
}","/** 
 * Dispose the current execution.
 */
public void reset(){
  if (_iteration > 0) {
    setStatus(Status.BEGIN);
    _currentStateEvent=_createMetroIIEvent(""String_Node_Str"");
  }
 else {
    setStatus(Status.START);
    _currentStateEvent=null;
  }
}"
73006,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MetroIIDEDirector newObject=(MetroIIDEDirector)super.clone(workspace);
  newObject._nameToActor=(Hashtable<String,Actor>)_nameToActor.clone();
  newObject._actorDictionary=(Hashtable<String,FireMachine>)_actorDictionary.clone();
  newObject._events=(ArrayList<Builder>)_events.clone();
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MetroIIDEDirector newObject=(MetroIIDEDirector)super.clone(workspace);
  newObject._nameToActor=(Hashtable<String,Actor>)_nameToActor.clone();
  newObject._actorDictionary=(Hashtable<String,FireMachine>)_actorDictionary.clone();
  newObject._events=(ArrayList<Builder>)_events.clone();
  newObject.actorList=(ArrayList<Actor>)actorList.clone();
  return newObject;
}"
73007,"@Override public void initialize() throws IllegalActionException {
  super.initialize();
  Nameable container=getContainer();
  if (container instanceof CompositeActor) {
    Iterator<?> actors=((CompositeActor)container).deepEntityList().iterator();
    _actorDictionary.clear();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      if (actor instanceof MetroIIEventHandler) {
        _actorDictionary.put(actor.getFullName(),new ResumableFire(actor));
      }
 else {
        _actorDictionary.put(actor.getFullName(),new NonBlockingFire(actor));
      }
    }
  }
}","@Override public void initialize() throws IllegalActionException {
  super.initialize();
  Nameable container=getContainer();
  if (container instanceof CompositeActor) {
    Iterator<?> actors=((CompositeActor)container).deepEntityList().iterator();
    _actorDictionary.clear();
    _pendingIteration.clear();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      if (actor instanceof MetroIIEventHandler) {
        _actorDictionary.put(actor.getFullName(),new ResumableFire(actor));
      }
 else {
        _actorDictionary.put(actor.getFullName(),new NonBlockingFire(actor));
      }
      _pendingIteration.put(actor.getFullName(),0);
    }
  }
  _events=new ArrayList<Event.Builder>();
  actorList=new ArrayList<Actor>();
}"
73008,"@Override public void resolve(Iterable<Builder> metroIIEventList){
  long time=Long.MAX_VALUE;
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.NOTIFIED) {
      if (event.hasTime()) {
        if (event.getTime() < time) {
          time=event.getTime();
        }
      }
    }
  }
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.NOTIFIED) {
      if (event.hasTime()) {
        if (event.getTime() > time) {
          event.setStatus(Status.WAITING);
        }
      }
    }
  }
}","@Override public void resolve(Iterable<Builder> metroIIEventList){
  long time=Long.MAX_VALUE;
  boolean hasEventWithoutTime=false;
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.NOTIFIED) {
      if (event.hasTime()) {
        if (event.getTime() < time) {
          time=event.getTime();
        }
      }
 else {
        hasEventWithoutTime=true;
      }
    }
  }
  if (hasEventWithoutTime) {
    for (    Builder event : metroIIEventList) {
      if (event.getStatus() == Status.NOTIFIED) {
        if (event.hasTime()) {
          event.setStatus(Status.WAITING);
        }
      }
    }
  }
 else {
    for (    Builder event : metroIIEventList) {
      if (event.getStatus() == Status.NOTIFIED) {
        if (event.hasTime()) {
          if (event.getTime() > time) {
            event.setStatus(Status.WAITING);
          }
        }
      }
    }
  }
}"
73009,"/** 
 * Evaluate the expression and send its result to the output.
 * @exception IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  _omcProxy=OMCProxy.getInstance();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (input.getWidth() > 0) {
    IntToken inputPortValue=(IntToken)input.get(0);
    try {
      _omcProxy.loadFile(fileName.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    try {
      System.out.println(""String_Node_Str"");
      _omcProxy.modifyVariables(inputPortValue,modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
  try {
    _omcProxy.simulateModel(fileName.getExpression(),modelName.getExpression(),fileNamePrefix.getExpression(),simulationStartTime.getExpression(),simulationStopTime.getExpression(),Integer.parseInt(numberOfIntervals.getExpression()),tolerance.getExpression(),method.getExpression(),outputFormat.getExpression(),variableFilter.getExpression(),cflags.getExpression(),simflags.getExpression(),processingType.getExpression());
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(this,throwable,""String_Node_Str"" + modelName.getExpression() + ""String_Node_Str"");
  }
  if ((processingType.getExpression().compareTo(""String_Node_Str"") == 0) && (outputFormat.getExpression().compareTo(""String_Node_Str"") == 0)) {
    String simulationResult=null;
    try {
      simulationResult=_omcProxy.displaySimulationResult(fileName.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + modelName.getExpression() + ""String_Node_Str"");
    }
    output.send(0,new StringToken(simulationResult));
  }
  if (outputFormat.getExpression().compareTo(""String_Node_Str"") == 0) {
    try {
      _omcProxy.plotPltFile(fileNamePrefix.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + modelName.getExpression() + ""String_Node_Str"");
    }
  }
}","/** 
 * Evaluate the expression and send its result to the output.
 * @exception IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  _omcProxy=OMCProxy.getInstance();
  try {
    _omcProxy.loadFile(fileName.getExpression(),modelName.getExpression());
  }
 catch (  ConnectException e) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  if (input.getWidth() > 0) {
    IntToken inputPortValue=(IntToken)input.get(0);
    try {
      System.out.println(""String_Node_Str"");
      _omcProxy.modifyVariables(inputPortValue,modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
  try {
    try {
      _omcProxy.loadFile(fileName.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    _omcProxy.simulateModel(fileName.getExpression(),modelName.getExpression(),fileNamePrefix.getExpression(),simulationStartTime.getExpression(),simulationStopTime.getExpression(),Integer.parseInt(numberOfIntervals.getExpression()),tolerance.getExpression(),method.getExpression(),outputFormat.getExpression(),variableFilter.getExpression(),cflags.getExpression(),simflags.getExpression(),processingType.getExpression());
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(this,throwable,""String_Node_Str"" + modelName.getExpression() + ""String_Node_Str"");
  }
  if ((processingType.getExpression().compareTo(""String_Node_Str"") == 0) && (outputFormat.getExpression().compareTo(""String_Node_Str"") == 0)) {
    String simulationResult=null;
    try {
      _omcProxy.loadFile(fileName.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    try {
      simulationResult=_omcProxy.displaySimulationResult(fileName.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + modelName.getExpression() + ""String_Node_Str"");
    }
    output.send(0,new StringToken(simulationResult));
  }
  if (outputFormat.getExpression().compareTo(""String_Node_Str"") == 0) {
    try {
      _omcProxy.plotPltFile(fileNamePrefix.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + modelName.getExpression() + ""String_Node_Str"");
    }
  }
}"
73010,"/** 
 * load the Modelica file and library.   Build the Modelica model. Then, run the executable result file of buildModel() in both interactive and non-interactive processing mode in order to generate the simulation result file.
 * @param fileName File which the model should be loaded from.
 * @param modelName Name of the model which should be built.
 * @param fileNamePrefix User preferable name for the result file.
 * @param startTime The start time of simulation.
 * @param stopTime The stop time of simulation.
 * @param numberOfIntervals Number of intervals in the result file.
 * @param tolerance Tolerance used by the integration method.
 * @param method Integration method used for simulation.
 * @param outputFormat Format of the result file.
 * @param variableFilter Filter for variables that should be stored in the result file.
 * @param cflags Any standard C language flags.
 * @param simflags Simulation flags.
 * @param processingType Type of processing for running the executable result file of building the Modelica model.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @throws IOException If the executable result file of buildModel()couldn't be executed.
 * @throws IllegalActionException 
 */
public void simulateModel(String fileName,String modelName,String fileNamePrefix,String startTime,String stopTime,int numberOfIntervals,String tolerance,String method,String outputFormat,String variableFilter,String cflags,String simflags,String processingType) throws ConnectException, IOException, IllegalActionException ;","/** 
 * Build the Modelica model. Then, run the executable result file of buildModel() in both interactive and non-interactive processing mode in order to generate the simulation result file.
 * @param fileName File which the model should be loaded from.
 * @param modelName Name of the model which should be built.
 * @param fileNamePrefix User preferable name for the result file.
 * @param startTime The start time of simulation.
 * @param stopTime The stop time of simulation.
 * @param numberOfIntervals Number of intervals in the result file.
 * @param tolerance Tolerance used by the integration method.
 * @param method Integration method used for simulation.
 * @param outputFormat Format of the result file.
 * @param variableFilter Filter for variables that should be stored in the result file.
 * @param cflags Any standard C language flags.
 * @param simflags Simulation flags.
 * @param processingType Type of processing for running the executable result file of building the Modelica model.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @throws IOException If the executable result file of buildModel()couldn't be executed.
 * @throws IllegalActionException 
 */
public void simulateModel(String fileName,String modelName,String fileNamePrefix,String startTime,String stopTime,int numberOfIntervals,String tolerance,String method,String outputFormat,String variableFilter,String cflags,String simflags,String processingType) throws ConnectException, IOException, IllegalActionException ;"
73011,"/** 
 * Send a command to the OpenModelica Compiler(OMC) server and fetches the string result.
 * @param modelicaCommand The command which should be sent to the OMC.
 * @return CompilerResult The result of sendExpression(""modelicaCommand"") to the OMC.
 * @exception ConnectException If commands couldn't be sent to the OMC.
 */
public CompilerResult sendCommand(String modelicaCommand) throws ConnectException {
  String error=null;
  String[] retval={""String_Node_Str""};
  if (_couldNotStartOMC) {
    return CompilerResult.makeResult(retval,error);
  }
  if (_numberOfErrors > _showMaxErrors) {
    return CompilerResult.makeResult(retval,error);
  }
  modelicaCommand=modelicaCommand.trim();
  if (hasInitialized == false) {
    initServer();
  }
  try {
    retval[0]=omcc.sendExpression(modelicaCommand);
    if (!modelicaCommand.equalsIgnoreCase(""String_Node_Str"")) {
      error=omcc.sendExpression(""String_Node_Str"");
    }
    if (error != null && error.length() > 2) {
      error=error.trim();
      error=error.substring(1,error.length() - 1);
    }
 else {
      error=null;
    }
    return CompilerResult.makeResult(retval,error);
  }
 catch (  org.omg.CORBA.COMM_FAILURE x) {
    _numberOfErrors++;
    throw new ConnectException(""String_Node_Str"" + modelicaCommand);
  }
}","/** 
 * Send a command to the OpenModelica Compiler(OMC) server and fetches the string result.
 * @param modelicaCommand The command which should be sent to the OMC.
 * @return CompilerResult The result of sendExpression(""modelicaCommand"") to the OMC.
 * @exception ConnectException If commands couldn't be sent to the OMC.
 */
public CompilerResult sendCommand(String modelicaCommand) throws ConnectException {
  String error=null;
  String[] retval={""String_Node_Str""};
  if (_couldNotStartOMC)   return CompilerResult.makeResult(retval,error);
  if (_numberOfErrors > _showMaxErrors)   return CompilerResult.makeResult(retval,error);
  modelicaCommand=modelicaCommand.trim();
  if (hasInitialized == false)   initServer();
  try {
    retval[0]=omcc.sendExpression(modelicaCommand);
    if (!modelicaCommand.equalsIgnoreCase(""String_Node_Str""))     error=omcc.sendExpression(""String_Node_Str"");
    if (error != null && error.length() > 2) {
      error=error.trim();
      error=error.substring(1,error.length() - 1);
    }
 else {
      error=null;
    }
    return CompilerResult.makeResult(retval,error);
  }
 catch (  org.omg.CORBA.COMM_FAILURE x) {
    _numberOfErrors++;
    throw new ConnectException(""String_Node_Str"" + modelicaCommand);
  }
}"
73012,"/** 
 * load the Modelica file and library.   Build the Modelica model. Then, run the executable result file of buildModel() in both interactive and non-interactive processing mode in order to generate the simulation result file.
 * @param fileName File which the model should be loaded from.
 * @param modelName Name of the model which should be built.
 * @param fileNamePrefix User preferable name for the result file.
 * @param startTime The start time of simulation.
 * @param stopTime The stop time of simulation.
 * @param numberOfIntervals Number of intervals in the result file.
 * @param tolerance Tolerance used by the integration method.
 * @param method Integration method used for simulation.
 * @param outputFormat Format of the result file.
 * @param variableFilter Filter for variables that should be stored in the result file.
 * @param cflags Any standard C language flags.
 * @param simflags Simulation flags.
 * @param processingType Type of processing for running the executable result file of building the Modelica model.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @throws IOException If the executable result file of buildModel()couldn't be executed.
 * @throws IllegalActionException 
 */
public void simulateModel(String fileName,String modelName,String fileNamePrefix,String startTime,String stopTime,int numberOfIntervals,String tolerance,String method,String outputFormat,String variableFilter,String cflags,String simflags,String processingType) throws ConnectException, IOException, IllegalActionException {
  loadFile(fileName,modelName);
  String commands=null;
  String loggerInfo=null;
  if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
    commands=modelName + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ Float.valueOf(tolerance).floatValue()+ ""String_Node_Str""+ method+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ variableFilter+ ""String_Node_Str""+ cflags+ ""String_Node_Str""+ simflags+ ""String_Node_Str"";
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
 else {
    commands=modelName + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ Float.valueOf(tolerance).floatValue()+ ""String_Node_Str""+ method+ ""String_Node_Str""+ fileNamePrefix+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ variableFilter+ ""String_Node_Str""+ cflags+ ""String_Node_Str""+ simflags+ ""String_Node_Str"";
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  CompilerResult buildModelResult=_omcCommand.buildModel(commands);
  if (buildModelResult.getFirstResult().compareTo(""String_Node_Str"") != 0 && buildModelResult.getError().compareTo(""String_Node_Str"") == 0) {
    loggerInfo=modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  if (buildModelResult.getError().compareTo(""String_Node_Str"") != 0) {
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new ConnectException(loggerInfo);
  }
  if (!outputFormat.equals(""String_Node_Str"")) {
    if (processingType.compareTo(""String_Node_Str"") == 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
switch (getOs()) {
case WINDOWS:
          commands=_temp + _username + ""String_Node_Str""+ modelName+ ""String_Node_Str"";
        break;
case UNIX:
      commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ modelName;
    break;
case MAC:
  commands=_temp + _username + ""String_Node_Str""+ modelName;
break;
}
}
 else {
switch (getOs()) {
case WINDOWS:
commands=_temp + _username + ""String_Node_Str""+ fileNamePrefix+ ""String_Node_Str"";
break;
case UNIX:
commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ fileNamePrefix;
break;
case MAC:
commands=_temp + _username + ""String_Node_Str""+ fileNamePrefix;
break;
}
}
try {
Runtime.getRuntime().exec(commands,_environmentalVariables,_workDir);
}
 catch (IOException e) {
loggerInfo=""String_Node_Str"" + commands;
_omcLogger.getInfo(loggerInfo);
hasInitialized=false;
return;
}
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
switch (getOs()) {
case WINDOWS:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case UNIX:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ ""String_Node_Str""+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case MAC:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
}
}
 else if (fileNamePrefix.length() != 0) {
switch (getOs()) {
case WINDOWS:
loggerInfo=fileNamePrefix + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case UNIX:
loggerInfo=fileNamePrefix + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ ""String_Node_Str""+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case MAC:
loggerInfo=fileNamePrefix + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
}
}
}
 else {
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
switch (getOs()) {
case WINDOWS:
commands=_temp + _username + ""String_Node_Str""+ modelName+ ""String_Node_Str"";
break;
case UNIX:
commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ modelName;
break;
case MAC:
commands=_temp + _username + ""String_Node_Str""+ modelName;
break;
}
commands=commands + ""String_Node_Str"";
try {
loggerInfo=""String_Node_Str"" + commands + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
Runtime.getRuntime().exec(commands,_environmentalVariables,_workDir);
}
 catch (IOException e) {
loggerInfo=""String_Node_Str"" + commands;
_omcLogger.getInfo(loggerInfo);
hasInitialized=false;
return;
}
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
}
 else {
loggerInfo=modelName + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
}","/** 
 * Build the Modelica model. Then, run the executable result file of buildModel() in both interactive and non-interactive processing mode in order to generate the simulation result file.
 * @param fileName File which the model should be loaded from.
 * @param modelName Name of the model which should be built.
 * @param fileNamePrefix User preferable name for the result file.
 * @param startTime The start time of simulation.
 * @param stopTime The stop time of simulation.
 * @param numberOfIntervals Number of intervals in the result file.
 * @param tolerance Tolerance used by the integration method.
 * @param method Integration method used for simulation.
 * @param outputFormat Format of the result file.
 * @param variableFilter Filter for variables that should be stored in the result file.
 * @param cflags Any standard C language flags.
 * @param simflags Simulation flags.
 * @param processingType Type of processing for running the executable result file of building the Modelica model.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @throws IOException If the executable result file of buildModel()couldn't be executed.
 * @throws IllegalActionException 
 */
public void simulateModel(String fileName,String modelName,String fileNamePrefix,String startTime,String stopTime,int numberOfIntervals,String tolerance,String method,String outputFormat,String variableFilter,String cflags,String simflags,String processingType) throws ConnectException, IOException, IllegalActionException {
  String commands=null;
  String loggerInfo=null;
  if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
    commands=modelName + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ Float.valueOf(tolerance).floatValue()+ ""String_Node_Str""+ method+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ variableFilter+ ""String_Node_Str""+ cflags+ ""String_Node_Str""+ simflags+ ""String_Node_Str"";
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
 else {
    commands=modelName + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ Float.valueOf(tolerance).floatValue()+ ""String_Node_Str""+ method+ ""String_Node_Str""+ fileNamePrefix+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ variableFilter+ ""String_Node_Str""+ cflags+ ""String_Node_Str""+ simflags+ ""String_Node_Str"";
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  CompilerResult buildModelResult=buildModel(commands);
  if (buildModelResult.getFirstResult().compareTo(""String_Node_Str"") != 0 && buildModelResult.getError().compareTo(""String_Node_Str"") == 0) {
    loggerInfo=modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  if (buildModelResult.getError().compareTo(""String_Node_Str"") != 0) {
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new ConnectException(loggerInfo);
  }
  if (!outputFormat.equals(""String_Node_Str"")) {
    if (processingType.compareTo(""String_Node_Str"") == 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
switch (getOs()) {
case WINDOWS:
          commands=_temp + _username + ""String_Node_Str""+ modelName+ ""String_Node_Str"";
        break;
case UNIX:
      commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ modelName;
    break;
case MAC:
  commands=_temp + _username + ""String_Node_Str""+ modelName;
break;
}
}
 else {
switch (getOs()) {
case WINDOWS:
commands=_temp + _username + ""String_Node_Str""+ fileNamePrefix+ ""String_Node_Str"";
break;
case UNIX:
commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ fileNamePrefix;
break;
case MAC:
commands=_temp + _username + ""String_Node_Str""+ fileNamePrefix;
break;
}
}
try {
Runtime.getRuntime().exec(commands,_environmentalVariables,_workDir);
}
 catch (IOException e) {
loggerInfo=""String_Node_Str"" + commands;
_omcLogger.getInfo(loggerInfo);
hasInitialized=false;
return;
}
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
switch (getOs()) {
case WINDOWS:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case UNIX:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ ""String_Node_Str""+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case MAC:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
}
}
 else if (fileNamePrefix.length() != 0) {
switch (getOs()) {
case WINDOWS:
loggerInfo=fileNamePrefix + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case UNIX:
loggerInfo=fileNamePrefix + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ ""String_Node_Str""+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case MAC:
loggerInfo=fileNamePrefix + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
}
}
}
 else {
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
switch (getOs()) {
case WINDOWS:
commands=_temp + _username + ""String_Node_Str""+ modelName+ ""String_Node_Str"";
break;
case UNIX:
commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ modelName;
break;
case MAC:
commands=_temp + _username + ""String_Node_Str""+ modelName;
break;
}
commands=commands + ""String_Node_Str"";
try {
loggerInfo=""String_Node_Str"" + commands + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
Runtime.getRuntime().exec(commands,_environmentalVariables,_workDir);
}
 catch (IOException e) {
loggerInfo=""String_Node_Str"" + commands;
_omcLogger.getInfo(loggerInfo);
hasInitialized=false;
return;
}
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
}
 else {
loggerInfo=modelName + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
}"
73013,"/** 
 * Leave and quit OpenModelica environment. Deallocate OMCProxy and OMCLogger objects.
 * @exception ConnectException If quit command couldn'tbe sent to OMC.
 */
public void quitServer() throws ConnectException {
  if (hasInitialized=true) {
    sendCommand(""String_Node_Str"");
    _omcCommand=null;
    _omcLogger=null;
    _omcProxyInstance=null;
  }
}","/** 
 * Leave and quit OpenModelica environment. Deallocate OMCProxy and OMCLogger objects.
 * @exception ConnectException If quit command couldn'tbe sent to OMC.
 */
public void quitServer() throws ConnectException {
  if (hasInitialized=true) {
    sendCommand(""String_Node_Str"");
    _omcLogger=null;
    _omcProxyInstance=null;
  }
}"
73014,"/** 
 * Read a result file and return a matrix corresponding to the variables and size given.
 * @param fileName The executable result file of simulation in CSV format.
 * @param modelName Name of the model which should be built.
 * @return The value of the variables in the simulation file.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelica Compiler)OMC. 
 * @throws IllegalActionException 
 */
public String displaySimulationResult(String fileName,String modelName) throws ConnectException, IllegalActionException {
  loadFile(fileName,modelName);
  CompilerResult readSimulationResultVars=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str"");
  String variableList=readSimulationResultVars.getFirstResult();
  StringBuffer variableBuffer=new StringBuffer(variableList);
  variableBuffer.deleteCharAt(0);
  variableList=variableBuffer.deleteCharAt(variableBuffer.length() - 1).toString();
  String[] variables=variableList.split(""String_Node_Str"");
  CompilerResult readSimulationResult=null;
  String simulationResult=null;
  for (  String variable : variables) {
    variableBuffer=new StringBuffer(variable.toString());
    variableBuffer.deleteCharAt(0);
    variableList=variableBuffer.deleteCharAt(variableBuffer.length() - 1).toString();
    if (variableList.compareTo(""String_Node_Str"") == 0)     variableList=variableBuffer.deleteCharAt(variableBuffer.length() - 1).toString();
    readSimulationResult=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str""+ variableList+ ""String_Node_Str""+ 2+ ""String_Node_Str"");
    if (simulationResult == null)     simulationResult=""String_Node_Str"" + variableList + ""String_Node_Str""+ readSimulationResult.getFirstResult();
 else     simulationResult+=""String_Node_Str"" + variableList + ""String_Node_Str""+ readSimulationResult.getFirstResult();
  }
  System.out.println(simulationResult);
  return simulationResult;
}","/** 
 * Read a result file and return a matrix corresponding to the variables and size given.
 * @param fileName The executable result file of simulation in CSV format.
 * @param modelName Name of the model which should be built.
 * @return The value of the variables in the simulation file.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelica Compiler)OMC. 
 * @throws IllegalActionException 
 */
public String displaySimulationResult(String fileName,String modelName) throws ConnectException, IllegalActionException {
  CompilerResult readSimulationResultVars=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str"");
  String variableList=readSimulationResultVars.getFirstResult();
  StringBuffer variableBuffer=new StringBuffer(variableList);
  variableBuffer.deleteCharAt(0);
  variableList=variableBuffer.deleteCharAt(variableBuffer.length() - 1).toString();
  String[] variables=variableList.split(""String_Node_Str"");
  CompilerResult readSimulationResult=null;
  String simulationResult=null;
  for (  String variable : variables) {
    variableBuffer=new StringBuffer(variable.toString());
    variableBuffer.deleteCharAt(0);
    variableList=variableBuffer.deleteCharAt(variableBuffer.length() - 1).toString();
    if (variableList.compareTo(""String_Node_Str"") == 0)     variableList=variableBuffer.deleteCharAt(variableBuffer.length() - 1).toString();
    readSimulationResult=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str""+ variableList+ ""String_Node_Str""+ 2+ ""String_Node_Str"");
    if (simulationResult == null)     simulationResult=""String_Node_Str"" + variableList + ""String_Node_Str""+ readSimulationResult.getFirstResult();
 else     simulationResult+=""String_Node_Str"" + variableList + ""String_Node_Str""+ readSimulationResult.getFirstResult();
  }
  System.out.println(simulationResult);
  return simulationResult;
}"
73015,"/** 
 * load the Modelica file and library.  
 * @param fileName File which the model should be loaded from.
 * @param modelName Name of the model which should be built.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @throws IllegalActionException 
 */
public void loadFile(String fileName,String modelName) throws ConnectException, IllegalActionException {
  String loggerInfo=null;
  _testFilePath=_systemPath + ""String_Node_Str"" + fileName;
  File file=new File(_testFilePath.toString());
  if (file.exists()) {
    if (_omcLogger == null) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str""+ _testFilePath;
    _omcLogger.getInfo(loggerInfo);
    CompilerResult loadFileResult=_omcCommand.loadFile(_testFilePath);
    if (loadFileResult.getFirstResult().compareTo(""String_Node_Str"") != 0 && loadFileResult.getError().compareTo(""String_Node_Str"") == 0) {
      loggerInfo=modelName + ""String_Node_Str"" + _testFilePath+ ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
    if (loadFileResult.getError().compareTo(""String_Node_Str"") != 0) {
      loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
    loadFileResult=_omcCommand.loadModel(""String_Node_Str"");
    if (loadFileResult.getFirstResult().compareTo(""String_Node_Str"") == 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
    if (loadFileResult.getError().compareTo(""String_Node_Str"") != 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
  }
 else   if (!file.exists()) {
    loggerInfo=""String_Node_Str"" + _testFilePath + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new ConnectException(""String_Node_Str"" + _testFilePath + ""String_Node_Str"");
  }
}","/** 
 * load the Modelica file and library.  
 * @param fileName File which the model should be loaded from.
 * @param modelName Name of the model which should be built.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @throws IllegalActionException 
 */
public void loadFile(String fileName,String modelName) throws ConnectException, IllegalActionException {
  String loggerInfo=null;
  _testFilePath=_systemPath + ""String_Node_Str"" + fileName;
  File file=new File(_testFilePath.toString());
  if (file.exists()) {
    if (_omcLogger == null) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str""+ _testFilePath;
    _omcLogger.getInfo(loggerInfo);
    CompilerResult loadFileInteractiveQualifiedResult=sendCommand(""String_Node_Str"" + _testFilePath + ""String_Node_Str"");
    if (loadFileInteractiveQualifiedResult.getFirstResult().compareTo(""String_Node_Str"") != 0 && loadFileInteractiveQualifiedResult.getError().compareTo(""String_Node_Str"") == 0) {
      loggerInfo=modelName + ""String_Node_Str"" + _testFilePath+ ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
    if (loadFileInteractiveQualifiedResult.getError().compareTo(""String_Node_Str"") != 0) {
      loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
    CompilerResult loadModelResult=sendCommand(""String_Node_Str"");
    if (loadModelResult.getFirstResult().compareTo(""String_Node_Str"") == 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
    if (loadModelResult.getError().compareTo(""String_Node_Str"") != 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
  }
 else   if (!file.exists()) {
    loggerInfo=""String_Node_Str"" + _testFilePath + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new ConnectException(""String_Node_Str"" + _testFilePath + ""String_Node_Str"");
  }
}"
73016,"/** 
 * Create an instance of OMCProxy object in order to provide a global point of access to the instance. It provides a unique source of OMCProxy instance.
 * @return An OMCProxy object representing the instance value.
 */
public static OMCProxy getInstance(){
  if (_omcProxyInstance == null) {
    _omcProxyInstance=new OMCProxy();
  }
  return _omcProxyInstance;
}","/** 
 * Create an instance of OMCProxy object in order to provide a global point of access to the instance. It provides a unique source of OMCProxy instance.
 * @return An OMCProxy object representing the instance value.
 */
public static OMCProxy getInstance(){
  return _omcProxyInstance;
}"
73017,"/** 
 * Construct a director in the given container with the given name.  The container argument must not be null, or a NullPointerException will be thrown.  If the name argument is null, then the name is set to the empty string. Increment the version number of the workspace.
 * @param container Container of the director.
 * @param name Name of this director.
 * @exception IllegalActionException If the director is not compatiblewith the specified container.  May be thrown in a derived class.
 * @exception NameDuplicationException If the container is not aCompositeActor and the name collides with an entity in the container.
 */
public MetroIIDirector(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  _actorList=new LinkedList<StartOrResumable>();
  _mappingConstraintSolver=new MappingConstraintSolver(_maxEvent);
  _initializeParameters();
  initialize();
}","/** 
 * Construct a director in the given container with the given name.  The container argument must not be null, or a NullPointerException will be thrown.  If the name argument is null, then the name is set to the empty string. Increment the version number of the workspace.
 * @param container Container of the director.
 * @param name Name of this director.
 * @exception IllegalActionException If the director is not compatiblewith the specified container.  May be thrown in a derived class.
 * @exception NameDuplicationException If the container is not aCompositeActor and the name collides with an entity in the container.
 */
public MetroIIDirector(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  _actorList=new LinkedList<StartOrResumable>();
  _mappingConstraintSolver=new MappingConstraintSolver(_maxEvent);
  _timeScheduler=new TimeScheduler();
  _initializeParameters();
  initialize();
}"
73018,"/** 
 * Construct an OpenModelica Compiler(OMC) logger. This constructor has no parameter. It creates the log file in the temporary folder and sets the format of the log to show date and time first. This private Constructor prevents other class from instantiating.
 * @exception IllegalActionException
 */
private OMCLogger() throws IllegalActionException {
  String logPath=createDirectoryForResult();
  String logFileName=logPath + ""String_Node_Str"";
  try {
    _fileHandler=new FileHandler(logFileName);
  }
 catch (  SecurityException ex) {
    String message=""String_Node_Str"" + ""String_Node_Str"" + logFileName + ""String_Node_Str"";
    omcLogger.severe(message);
    throw new IllegalActionException(null,ex,message);
  }
catch (  IOException ex) {
    String message=""String_Node_Str"" + ""String_Node_Str"" + logFileName + ""String_Node_Str"";
    omcLogger.severe(message);
    throw new IllegalActionException(null,ex,message);
  }
  _fileHandler.setFormatter(new Formatter(){
    public String format(    LogRecord rec){
      StringBuffer buf=new StringBuffer(1000);
      buf.append(new java.util.Date());
      buf.append(' ');
      buf.append(rec.getLevel());
      buf.append(' ');
      buf.append(formatMessage(rec));
      buf.append('\n');
      return buf.toString();
    }
  }
);
  omcLogger.addHandler(_fileHandler);
}","/** 
 * Construct an OpenModelica Compiler(OMC) logger. This constructor has no parameter. It creates the log file in the temporary folder and sets the format of the log to show date and time first. This private Constructor prevents other class from instantiating.
 * @throws IllegalActionException 
 */
private OMCLogger() throws IllegalActionException {
  String logPath=createDirectoryForResult();
  String logFileName=logPath + ""String_Node_Str"";
  try {
    _fileHandler=new FileHandler(logFileName);
  }
 catch (  SecurityException ex) {
    String message=""String_Node_Str"" + ""String_Node_Str"" + logFileName + ""String_Node_Str"";
    omcLogger.severe(message);
    throw new IllegalActionException(null,ex,message);
  }
catch (  IOException ex) {
    String message=""String_Node_Str"" + ""String_Node_Str"" + logFileName + ""String_Node_Str"";
    omcLogger.severe(message);
    throw new IllegalActionException(null,ex,message);
  }
  _fileHandler.setFormatter(new Formatter(){
    public String format(    LogRecord rec){
      StringBuffer buf=new StringBuffer(1000);
      buf.append(new java.util.Date());
      buf.append(' ');
      buf.append(rec.getLevel());
      buf.append(' ');
      buf.append(formatMessage(rec));
      buf.append('\n');
      return buf.toString();
    }
  }
);
  omcLogger.addHandler(_fileHandler);
}"
73019,"/** 
 * Get the Info LogLevel and info message will be written in the log file.
 * @param infoMessage The info message.
 */
public void getInfo(String infoMessage){
  omcLogger.info(infoMessage);
}","/** 
 * Get the Info LogLevel and info message will be written in the log file. 
 * @param infoMessage The info message. 
 */
public void getInfo(String infoMessage){
  omcLogger.info(infoMessage);
}"
73020,"/** 
 * Create an instance of OMCLogger object in order to provide a global point of access to the instance. It provides a unique source of OMCLogger instance.
 * @return An OMCLogger object representing the instance value.
 */
public static OMCLogger getInstance(){
  if (_omcLoggerInstance == null) {
    try {
      _omcLoggerInstance=new OMCLogger();
    }
 catch (    IllegalActionException e) {
      String message=""String_Node_Str"";
      _omcLoggerInstance.getSever(message);
    }
  }
  return _omcLoggerInstance;
}","/** 
 * Create an instance of OMCLogger object in order to provide a global point of access to the instance. It provides a unique source of OMCLogger instance.
 * @return An OMCLogger object representing the instance value.
 */
public static OMCLogger getInstance(){
  if (_omcLoggerInstance == null) {
    try {
      _omcLoggerInstance=new OMCLogger();
    }
 catch (    IllegalActionException e) {
      new Exception(""String_Node_Str"").printStackTrace();
    }
  }
  return _omcLoggerInstance;
}"
73021,"/** 
 * Return the path to the (OpenModelica Compiler)OMC CORBA object that is stored on a disk.
 * @return String The path to the OMC CORBA object.
 */
private String _getPathToObject(){
  String fileName=null;
switch (getOs()) {
case UNIX:
    if (_username == null) {
      System.err.println(""String_Node_Str"");
      _username=""String_Node_Str"";
    }
  if (_corbaSessionName == null || _corbaSessionName.equalsIgnoreCase(""String_Node_Str"")) {
    fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str"";
  }
 else {
    fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ ""String_Node_Str""+ _corbaSessionName;
  }
break;
case WINDOWS:
if (_corbaSessionName == null || _corbaSessionName.equalsIgnoreCase(""String_Node_Str"")) {
fileName=_temp + ""String_Node_Str"";
}
 else {
fileName=_temp + ""String_Node_Str"" + ""String_Node_Str""+ _corbaSessionName;
}
break;
case MAC:
if (_username == null) {
System.err.println(""String_Node_Str"");
_username=""String_Node_Str"";
}
if (_corbaSessionName == null || _corbaSessionName.equalsIgnoreCase(""String_Node_Str"")) {
fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str"";
}
 else {
fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ ""String_Node_Str""+ _corbaSessionName;
}
break;
}
String loggerInfo=""String_Node_Str"" + fileName + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
return fileName;
}","/** 
 * Return the path to the (OpenModelica Compiler)OMC CORBA object that is stored on a disk.
 * @return String The path to the OMC CORBA object.
 */
private String _getPathToObject(){
  String fileName=null;
switch (getOs()) {
case UNIX:
    if (_username == null) {
      System.err.println(""String_Node_Str"");
      _username=""String_Node_Str"";
    }
  if (_corbaSessionName == null || _corbaSessionName.equalsIgnoreCase(""String_Node_Str"")) {
    fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str"";
  }
 else {
    fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ ""String_Node_Str""+ _corbaSessionName;
  }
break;
case WINDOWS:
if (_corbaSessionName == null || _corbaSessionName.equalsIgnoreCase(""String_Node_Str"")) {
fileName=_temp + ""String_Node_Str"";
}
 else {
fileName=_temp + ""String_Node_Str"" + ""String_Node_Str""+ _corbaSessionName;
}
break;
case MAC:
if (_username == null) {
System.err.println(""String_Node_Str"");
_username=""String_Node_Str"";
}
if (_corbaSessionName == null || _corbaSessionName.equalsIgnoreCase(""String_Node_Str"")) {
fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str"";
}
 else {
fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ ""String_Node_Str""+ _corbaSessionName;
}
break;
}
if (_omcLogger == null) {
new Exception(""String_Node_Str"").printStackTrace();
_omcLogger=OMCLogger.getInstance();
}
String loggerInfo=""String_Node_Str"" + fileName + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
return fileName;
}"
73022,"/** 
 * Leave and quit OpenModelica environment. Deallocate OMCProxy and OMCLogger objects.
 * @exception ConnectException If quit command couldn'tbe sent to OMC.
 */
public void quitServer() throws ConnectException {
  if (hasInitialized=true) {
    sendCommand(""String_Node_Str"");
    _omcLogger=null;
  }
}","/** 
 * Leave and quit OpenModelica environment. Deallocate OMCProxy and OMCLogger objects.
 * @exception ConnectException If quit command couldn'tbe sent to OMC.
 */
public void quitServer() throws ConnectException {
  if (hasInitialized=true) {
    sendCommand(""String_Node_Str"");
    _omcLogger=null;
    _omcProxyInstance=null;
  }
}"
73023,"/** 
 * Create an instance of OMCProxy object in order to provide a global point of access to the instance. It provides a unique source of OMCProxy instance.
 * @return An OMCProxy object representing the instance value.
 */
public static synchronized OMCProxy getInstance(){
  return _omcProxyInstance;
}","/** 
 * Create an instance of OMCProxy object in order to provide a global point of access to the instance. It provides a unique source of OMCProxy instance.
 * @return An OMCProxy object representing the instance value.
 */
public static synchronized OMCProxy getInstance(){
  if (_omcProxyInstance == null)   _omcProxyInstance=new OMCProxy();
  return _omcProxyInstance;
}"
73024,"/** 
 * Construct an OpenModelica Compiler(OMC) proxy. This constructor has no parameter.  This private Constructor prevents other class from instantiating. 
 */
private OMCProxy(){
  _omcLogger=OMCLogger.getInstance();
}","/** 
 * Construct an OpenModelica Compiler(OMC) proxy. This constructor has no parameter.  This private Constructor prevents other class from instantiating. 
 */
private OMCProxy(){
}"
73025,"/** 
 * Leave and quit OpenModelica environment. Deallocate OMCProxy and OMCLogger objects.
 * @exception ConnectException If quit command couldn'tbe sent to OMC.
 */
public void quitServer() throws ConnectException {
  if (hasInitialized=true) {
    sendCommand(""String_Node_Str"");
    _omcLogger=null;
    _omcProxyInstance=null;
  }
}","/** 
 * Leave and quit OpenModelica environment. Deallocate OMCProxy and OMCLogger objects.
 * @exception ConnectException If quit command couldn'tbe sent to OMC.
 */
public void quitServer() throws ConnectException {
  if (hasInitialized=true) {
    sendCommand(""String_Node_Str"");
    _omcLogger=null;
  }
}"
73026,"/** 
 * Create an instance of OMCProxy object in order to provide a global point of access to the instance. It provides a unique source of OMCProxy instance.
 * @return An OMCProxy object representing the instance value.
 */
public static OMCProxy getInstance(){
  return _omcProxyInstance;
}","/** 
 * Create an instance of OMCProxy object in order to provide a global point of access to the instance. It provides a unique source of OMCProxy instance.
 * @return An OMCProxy object representing the instance value.
 */
public static synchronized OMCProxy getInstance(){
  return _omcProxyInstance;
}"
73027,"/** 
 * Check if event is safe to process.
 * @param event The event to be checked.
 * @return true if the event is safe to process.
 * @exception IllegalActionException If the delayOffset a parametercannot be read.
 */
private boolean _isSafeToProcess(PtidesEvent event) throws IllegalActionException {
  Time eventTimestamp=event.timeStamp();
  IOPort port=event.ioPort();
  Double delayOffset=null;
  StartOrResumable metroActor=_actorDictionary.get(event.actor().getFullName());
  if (metroActor.getState() != State.START) {
    System.out.println(metroActor.getState());
    System.out.println(State.START);
    return false;
  }
  Integer maxFutureEvents=_getIntParameterValue((NamedObj)event.actor(),""String_Node_Str"");
  if (maxFutureEvents != null) {
    int futureEvents=_getNumberOfFutureEventsFrom(event.actor());
    if (futureEvents > maxFutureEvents) {
      return false;
    }
 else {
      return true;
    }
  }
  if (port != null) {
    Actor actor=(Actor)port.getContainer();
    for (    Object ioPort : actor.inputPortList()) {
      Double ioPortDelayOffset=_getDoubleParameterValue((NamedObj)ioPort,""String_Node_Str"");
      if (ioPortDelayOffset != null && (delayOffset == null || ioPortDelayOffset < delayOffset)) {
        delayOffset=ioPortDelayOffset;
      }
    }
  }
 else {
    delayOffset=_getDoubleParameterValue((NamedObj)event.actor(),""String_Node_Str"");
  }
  if (delayOffset == null || localClock.getLocalTime().compareTo(eventTimestamp.subtract(delayOffset)) >= 0) {
    return true;
  }
  _setNextFireTime(eventTimestamp.subtract(delayOffset));
  return false;
}","/** 
 * Check if event is safe to process.
 * @param event The event to be checked.
 * @return true if the event is safe to process.
 * @exception IllegalActionException If the delayOffset a parametercannot be read.
 */
private boolean _isSafeToProcess(PtidesEvent event) throws IllegalActionException {
  if (getFiringEventSize() > 0 && event.depth() > getCurrentEventDepth()) {
    return false;
  }
  Time eventTimestamp=event.timeStamp();
  IOPort port=event.ioPort();
  Double delayOffset=null;
  StartOrResumable metroActor=_actorDictionary.get(event.actor().getFullName());
  if (metroActor.getState() != State.START) {
    System.out.println(metroActor.getState());
    System.out.println(State.START);
    return false;
  }
  Integer maxFutureEvents=_getIntParameterValue((NamedObj)event.actor(),""String_Node_Str"");
  if (maxFutureEvents != null) {
    int futureEvents=_getNumberOfFutureEventsFrom(event.actor());
    if (futureEvents > maxFutureEvents) {
      return false;
    }
 else {
      return true;
    }
  }
  if (port != null) {
    Actor actor=(Actor)port.getContainer();
    for (    Object ioPort : actor.inputPortList()) {
      Double ioPortDelayOffset=_getDoubleParameterValue((NamedObj)ioPort,""String_Node_Str"");
      if (ioPortDelayOffset != null && (delayOffset == null || ioPortDelayOffset < delayOffset)) {
        delayOffset=ioPortDelayOffset;
      }
    }
  }
 else {
    delayOffset=_getDoubleParameterValue((NamedObj)event.actor(),""String_Node_Str"");
  }
  if (delayOffset == null || localClock.getLocalTime().compareTo(eventTimestamp.subtract(delayOffset)) >= 0) {
    return true;
  }
  _setNextFireTime(eventTimestamp.subtract(delayOffset));
  return false;
}"
73028,"/** 
 * Construct a Bus with a name and a container. The container argument must not be null, or a NullPointerException will be thrown.  This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public Bus(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _tokens=new FIFOQueue();
  _receiversAndTokensToSendTo=new HashMap<Receiver,Token>();
  _tempReceiverQueue=new FIFOQueue();
  _messageLengths=new Hashtable<IOPort,Double>();
  _parameters=new HashMap<IOPort,List<Attribute>>();
  serviceTimeMultiplicationFactor=new Parameter(this,""String_Node_Str"");
  serviceTimeMultiplicationFactor.setExpression(""String_Node_Str"");
  serviceTimeMultiplicationFactor.setTypeEquals(BaseType.DOUBLE);
}","/** 
 * Construct a Bus with a name and a container. The container argument must not be null, or a NullPointerException will be thrown.  This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public Bus(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _tokens=new FIFOQueue();
  _receiversAndTokensToSendTo=new HashMap<Receiver,Token>();
  _tempReceiverQueue=new FIFOQueue();
  _messageLengths=new Hashtable<IOPort,Double>();
  serviceTimeMultiplicationFactor=new Parameter(this,""String_Node_Str"");
  serviceTimeMultiplicationFactor.setExpression(""String_Node_Str"");
  serviceTimeMultiplicationFactor.setTypeEquals(BaseType.DOUBLE);
}"
73029,"/** 
 * Return the list of Attributes that can be specified per port with default values for the specified port.
 * @param container The container parameter.
 * @param The port.
 * @return List of attributes.
 * @exception IllegalActionException Thrown if attributeList could not be created.
 */
public List<Attribute> getPortAttributeList(Parameter container,Port port) throws IllegalActionException {
  List<Attribute> list=_parameters.get(port);
  if (list == null) {
    list=new ArrayList<Attribute>();
    try {
      Parameter messageLengthParameter=new Parameter(container,""String_Node_Str"",new IntToken(1));
      list.add(messageLengthParameter);
    }
 catch (    NameDuplicationException ex) {
    }
  }
  return list;
}","/** 
 * Return the list of Attributes that can be specified per port with default values for the specified port.
 * @param container The container parameter.
 * @param port The port.
 * @return List of attributes.
 * @exception IllegalActionException Thrown if attributeList could not be created.
 */
public List<Attribute> getPortAttributeList(Parameter container,Port port) throws IllegalActionException {
  List<Attribute> list=_parameters.get(port);
  if (list == null) {
    list=new ArrayList<Attribute>();
    try {
      Parameter messageLengthParameter=new Parameter(container,""String_Node_Str"",new IntToken(1));
      list.add(messageLengthParameter);
    }
 catch (    NameDuplicationException ex) {
    }
  }
  return list;
}"
73030,"/** 
 * React to a change in an attribute.  This method updates the local data structure provided by   {@link #getExportParameters()}.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == backgroundColor) {
    _parameters.backgroundColor=backgroundColor.asColor();
  }
 else   if (attribute == copyJavaScriptFiles) {
    _parameters.copyJavaScriptFiles=((BooleanToken)copyJavaScriptFiles.getToken()).booleanValue();
  }
 else   if (attribute == directoryToExportTo) {
    _parameters.directoryToExportTo=directoryToExportTo.asFile();
  }
 else   if (attribute == imageFormat) {
    _parameters.imageFormat=imageFormat.stringValue();
  }
 else   if (attribute == openCompositesBeforeExport) {
    _parameters.openCompositesBeforeExport=((BooleanToken)openCompositesBeforeExport.getToken()).booleanValue();
  }
 else   if (attribute == runBeforeExport) {
    _parameters.runBeforeExport=((BooleanToken)runBeforeExport.getToken()).booleanValue();
  }
 else   if (attribute == showInBrowser) {
    _parameters.showInBrowser=((BooleanToken)showInBrowser.getToken()).booleanValue();
  }
 else   if (attribute == usePtWebsite) {
    _parameters.usePtWebsite=((BooleanToken)usePtWebsite.getToken()).booleanValue();
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * React to a change in an attribute.  This method updates the local data structure provided by   {@link #getExportParameters()}.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == backgroundColor) {
    if (!backgroundColor.getExpression().trim().equals(""String_Node_Str"")) {
      _parameters.backgroundColor=backgroundColor.asColor();
    }
 else {
      _parameters.backgroundColor=BasicGraphFrame.BACKGROUND_COLOR;
    }
  }
 else   if (attribute == copyJavaScriptFiles) {
    _parameters.copyJavaScriptFiles=((BooleanToken)copyJavaScriptFiles.getToken()).booleanValue();
  }
 else   if (attribute == directoryToExportTo) {
    _parameters.directoryToExportTo=directoryToExportTo.asFile();
  }
 else   if (attribute == imageFormat) {
    _parameters.imageFormat=imageFormat.stringValue();
  }
 else   if (attribute == openCompositesBeforeExport) {
    _parameters.openCompositesBeforeExport=((BooleanToken)openCompositesBeforeExport.getToken()).booleanValue();
  }
 else   if (attribute == runBeforeExport) {
    _parameters.runBeforeExport=((BooleanToken)runBeforeExport.getToken()).booleanValue();
  }
 else   if (attribute == showInBrowser) {
    _parameters.showInBrowser=((BooleanToken)showInBrowser.getToken()).booleanValue();
  }
 else   if (attribute == usePtWebsite) {
    _parameters.usePtWebsite=((BooleanToken)usePtWebsite.getToken()).booleanValue();
  }
 else {
    super.attributeChanged(attribute);
  }
}"
73031,"/** 
 * Get the value of the attribute, which is the evaluated expression. If the value is null, this returns the string ""null""
 * @see #getExpression()
 */
public String getValueAsString(){
  ptolemy.data.Token value=null;
  try {
    value=getToken();
  }
 catch (  IllegalActionException ex) {
  }
  String tokenString;
  if (value == null) {
    tokenString=""String_Node_Str"";
  }
 else {
    tokenString=value.toString();
  }
  return tokenString;
}","/** 
 * Get the value of the attribute, which is the evaluated expression. If the value is null, this returns the string ""null""
 * @see #getExpression()
 */
public String getValueAsString(){
  ptolemy.data.Token value=null;
  try {
    value=getToken();
  }
 catch (  IllegalActionException ex) {
  }
  String tokenString;
  if (value == null) {
    tokenString=""String_Node_Str"";
  }
 else   if (isStringMode()) {
    tokenString=((StringToken)value).stringValue();
  }
 else {
    tokenString=value.toString();
  }
  return tokenString;
}"
73032,"/** 
 * Call propagate() on all value listeners.
 * @return A list of instances of IllegalActionException, onefor each exception triggered by a failure to evaluate a value dependent, or null if there were no failures.
 */
protected List _propagateToValueListeners(){
  List result=null;
  if (_valueListeners != null) {
    Iterator listeners;
synchronized (this) {
      listeners=new LinkedList(_valueListeners).iterator();
    }
    while (listeners.hasNext()) {
      ValueListener listener=(ValueListener)listeners.next();
      if (listener instanceof Variable) {
        if (((Variable)listener)._needsEvaluation) {
          List additionalErrors=((Variable)listener)._propagate();
          if (additionalErrors != null) {
            if (result == null) {
              result=new LinkedList();
            }
            result.addAll(additionalErrors);
          }
        }
      }
    }
  }
  return result;
}","/** 
 * Call propagate() on all value listeners.
 * @return A list of instances of IllegalActionException, onefor each exception triggered by a failure to evaluate a value dependent, or null if there were no failures.
 */
protected List _propagateToValueListeners(){
  List result=null;
  if (_valueListeners != null) {
    Iterator listeners;
synchronized (this) {
      listeners=new LinkedList(_valueListeners).iterator();
    }
    while (listeners.hasNext()) {
      ValueListener listener=(ValueListener)listeners.next();
      if (listener instanceof Variable) {
        try {
          if (((Variable)listener).getVariable(getName()) != this) {
            listeners.remove();
            continue;
          }
        }
 catch (        IllegalActionException e) {
          listeners.remove();
          continue;
        }
        if (((Variable)listener)._needsEvaluation) {
          List additionalErrors=((Variable)listener)._propagate();
          if (additionalErrors != null) {
            if (result == null) {
              result=new LinkedList();
            }
            result.addAll(additionalErrors);
          }
        }
      }
    }
  }
  return result;
}"
73033,"/** 
 * Force evaluation of this variable, unless it is lazy, and call _propagate() on its value dependents.
 * @return A list of instances of IllegalActionException, onefor each exception triggered by a failure to evaluate a value dependent, or null if there were no failures.
 */
protected List _propagate(){
  if (_propagating) {
    return null;
  }
  _propagating=true;
  try {
    List result=null;
    if (_needsEvaluation && !_isLazy) {
      try {
        _evaluate();
      }
 catch (      IllegalActionException ex) {
        try {
          if (!handleModelError(this,ex)) {
            new IllegalActionException(this,ex,""String_Node_Str"" + getName() + ""String_Node_Str"").printStackTrace();
          }
        }
 catch (        IllegalActionException ex2) {
          result=new LinkedList();
          result.add(ex2);
        }
      }
    }
    List additionalErrors=_propagateToValueListeners();
    if (result == null) {
      result=additionalErrors;
    }
 else {
      if (additionalErrors != null) {
        result.addAll(additionalErrors);
      }
    }
    return result;
  }
  finally {
    _propagating=false;
  }
}","/** 
 * Force evaluation of this variable, unless it is lazy, and call _propagate() on its value dependents.
 * @return A list of instances of IllegalActionException, onefor each exception triggered by a failure to evaluate a value dependent, or null if there were no failures.
 */
protected List _propagate(){
  if (_propagating) {
    return null;
  }
  _propagating=true;
  try {
    List result=null;
    if (_needsEvaluation && !_isLazy) {
      try {
        _evaluate();
      }
 catch (      IllegalActionException ex) {
        try {
          if (!handleModelError(this,ex)) {
            result=new LinkedList();
            result.add(ex);
          }
        }
 catch (        IllegalActionException ex2) {
          result=new LinkedList();
          result.add(ex2);
        }
      }
    }
    List additionalErrors=_propagateToValueListeners();
    if (result == null) {
      result=additionalErrors;
    }
 else {
      if (additionalErrors != null) {
        result.addAll(additionalErrors);
      }
    }
    return result;
  }
  finally {
    _propagating=false;
  }
}"
73034,"/** 
 * Evaluate the current expression to a token. If this variable was last set directly with a token, then do nothing. In other words, the expression is evaluated only if the value of the token was most recently given by an expression.  The expression is also evaluated if any of the variables it refers to have changed since the last evaluation.  If the value of this variable changes due to this evaluation, then notify all value dependents and notify the container (if there is one) by calling its attributeChanged() and attributeTypeChanged() methods, as appropriate. An exception is thrown if the expression is illegal, for example if a parse error occurs or if there is a dependency loop. <p> If evaluation results in a token that is not of the same type as the current type of the variable, then the type of the variable is changed, unless the new type is incompatible with statically specified types (setTypeEquals() and setTypeAtMost()). If the type is changed, the attributeTypeChanged() method of the container is called.  The container can reject the change by throwing an exception. <p> This method may trigger a model error, which is delegated up the container hierarchy until an error handler is found, and is ignored if no error handler is found.  A model error occurs if the expression cannot be parsed or cannot be evaluated. <p> Part of this method is read-synchronized on the workspace.
 * @exception IllegalActionException If the expression cannotbe parsed or cannot be evaluated, or if a dependency loop is found.
 */
protected void _evaluate() throws IllegalActionException {
  if (_currentExpression == null || (isStringMode() ? _currentExpression.equals(""String_Node_Str"") : _currentExpression.trim().equals(""String_Node_Str""))) {
    _setToken(null);
    return;
  }
  if (_dependencyLoop && _needsEvaluation) {
    _dependencyLoop=false;
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ _currentExpression);
  }
  _dependencyLoop=true;
  try {
    workspace().getReadAccess();
    _parseIfNecessary();
    if (_parseTreeEvaluator == null) {
      _parseTreeEvaluator=new ParseTreeEvaluator();
    }
    if (_parserScope == null) {
      _parserScope=new VariableScope();
    }
    Token result=_parseTreeEvaluator.evaluateParseTree(_parseTree,_parserScope);
    _setTokenAndNotify(result);
  }
 catch (  IllegalActionException ex) {
    _needsEvaluation=true;
    if (!_isWithinClassDefinition() || !(ex instanceof UndefinedConstantOrIdentifierException)) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + _currentExpression);
    }
  }
 finally {
    _dependencyLoop=false;
    workspace().doneReading();
  }
}","/** 
 * Evaluate the current expression to a token. If this variable was last set directly with a token, then do nothing. In other words, the expression is evaluated only if the value of the token was most recently given by an expression.  The expression is also evaluated if any of the variables it refers to have changed since the last evaluation.  If the value of this variable changes due to this evaluation, then notify all value dependents and notify the container (if there is one) by calling its attributeChanged() and attributeTypeChanged() methods, as appropriate. An exception is thrown if the expression is illegal, for example if a parse error occurs or if there is a dependency loop. <p> If evaluation results in a token that is not of the same type as the current type of the variable, then the type of the variable is changed, unless the new type is incompatible with statically specified types (setTypeEquals() and setTypeAtMost()). If the type is changed, the attributeTypeChanged() method of the container is called.  The container can reject the change by throwing an exception. <p> This method may trigger a model error, which is delegated up the container hierarchy until an error handler is found, and is ignored if no error handler is found.  A model error occurs if the expression cannot be parsed or cannot be evaluated. <p> Part of this method is read-synchronized on the workspace.
 * @exception IllegalActionException If the expression cannotbe parsed or cannot be evaluated, or if a dependency loop is found.
 */
protected void _evaluate() throws IllegalActionException {
  if (_currentExpression == null || (isStringMode() ? _currentExpression.equals(""String_Node_Str"") : _currentExpression.trim().equals(""String_Node_Str""))) {
    _setToken(null);
    return;
  }
  if (_dependencyLoop && _needsEvaluation) {
    _dependencyLoop=false;
  }
  _dependencyLoop=true;
  try {
    workspace().getReadAccess();
    _parseIfNecessary();
    if (_parseTreeEvaluator == null) {
      _parseTreeEvaluator=new ParseTreeEvaluator();
    }
    if (_parserScope == null) {
      _parserScope=new VariableScope();
    }
    Token result=_parseTreeEvaluator.evaluateParseTree(_parseTree,_parserScope);
    _setTokenAndNotify(result);
  }
 catch (  IllegalActionException ex) {
    _needsEvaluation=true;
    if (!_isWithinClassDefinition() || !(ex instanceof UndefinedConstantOrIdentifierException)) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + _currentExpression);
    }
  }
 finally {
    _dependencyLoop=false;
    workspace().doneReading();
  }
}"
73035,"/** 
 * Specify the container, and add this variable to the list of attributes in the container. If this variable already has a container, remove this variable from the attribute list of the current container first. Otherwise, remove it from the directory of the workspace, if it is there. If the specified container is null, remove this variable from the list of attributes of the current container. If the specified container already contains an attribute with the same name, then throw an exception and do not make any changes. Similarly, if the container is not in the same workspace as this variable, throw an exception. If this variable is already contained by the specified container, do nothing. <p> If this method results in a change of container (which it usually does), then remove this variable from the scope of any scope dependent of this variable. <p> This method is write-synchronized on the workspace and increments its version number.
 * @param container The proposed container of this variable.
 * @exception IllegalActionException If the container will not accepta variable as its attribute, or this variable and the container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this variable.
 */
public void setContainer(NamedObj container) throws IllegalActionException, NameDuplicationException {
  Nameable previousContainer=getContainer();
  if (container != previousContainer && previousContainer != null && _valueListeners != null && _valueListeners.size() > 0) {
    new IllegalActionException(this,""String_Node_Str"" + getName() + ""String_Node_Str""+ _valueListeners.size()+ ""String_Node_Str""+ ""String_Node_Str""+ _valueListeners.get(0)).printStackTrace();
  }
  super.setContainer(container);
  if (container != previousContainer) {
    _invalidateShadowedSettables(container);
    if (previousContainer != null) {
      if (container != null) {
        validate();
      }
 else {
        _notifyValueListeners();
      }
    }
  }
}","/** 
 * Specify the container, and add this variable to the list of attributes in the container. If this variable already has a container, remove this variable from the attribute list of the current container first. Otherwise, remove it from the directory of the workspace, if it is there. If the specified container is null, remove this variable from the list of attributes of the current container. If the specified container already contains an attribute with the same name, then throw an exception and do not make any changes. Similarly, if the container is not in the same workspace as this variable, throw an exception. If this variable is already contained by the specified container, do nothing. <p> If this method results in a change of container (which it usually does), then remove this variable from the scope of any scope dependent of this variable. <p> This method is write-synchronized on the workspace and increments its version number.
 * @param container The proposed container of this variable.
 * @exception IllegalActionException If the container will not accepta variable as its attribute, or this variable and the container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this variable.
 */
public void setContainer(NamedObj container) throws IllegalActionException, NameDuplicationException {
  Nameable previousContainer=getContainer();
  if (container != previousContainer && previousContainer != null && _valueListeners != null && _valueListeners.size() > 0) {
    if (!MessageHandler.yesNoQuestion(""String_Node_Str"" + getName() + ""String_Node_Str"")) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
  }
  super.setContainer(container);
  if (container != previousContainer) {
    _invalidateShadowedSettables(container);
    if (previousContainer != null) {
      if (container != null) {
        validate();
      }
 else {
        _notifyValueListeners();
      }
    }
  }
}"
73036,"/** 
 * If there are still tokens in the queue and a token has been produced in the fire, schedule a refiring.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree != null && _tokens.size() > 0 && currentTime.compareTo(_nextTimeFree) == 0) {
    _tokens.take();
    _tokenCount--;
    sendQMTokenEvent(null,0,_tokenCount,EventType.RECEIVED);
  }
  if ((getDirector() instanceof FixedPointDirector) && _receiversAndTokensToSendTo != null) {
    while (_tempReceiverQueue.size() > 0) {
      Receiver receiver=(Receiver)_tempReceiverQueue.take();
      Token token=_receiversAndTokensToSendTo.get(receiver);
      if (token != null) {
        _tokens.put(new Object[]{receiver,token});
        _tokenCount++;
        sendQMTokenEvent((Actor)receiver.getContainer().getContainer(),0,_tokenCount,EventType.RECEIVED);
      }
    }
  }
  if (_tokens.size() > 0 && (_nextTimeFree == null || currentTime.compareTo(_nextTimeFree) >= 0)) {
    _scheduleRefire();
  }
  _receiversAndTokensToSendTo.clear();
  return super.postfire();
}","/** 
 * If there are still tokens in the queue and a token has been produced in the fire, schedule a refiring.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree != null && _tokens.size() > 0 && currentTime.compareTo(_nextTimeFree) == 0) {
    _tokens.take();
    _tokenCount--;
    sendQMTokenEvent(null,0,_tokenCount,EventType.SENT);
  }
  if ((getDirector() instanceof FixedPointDirector) && _receiversAndTokensToSendTo != null) {
    while (_tempReceiverQueue.size() > 0) {
      Receiver receiver=(Receiver)_tempReceiverQueue.take();
      Token token=_receiversAndTokensToSendTo.get(receiver);
      if (token != null) {
        _tokens.put(new Object[]{receiver,token});
        _tokenCount++;
        sendQMTokenEvent((Actor)receiver.getContainer().getContainer(),0,_tokenCount,EventType.RECEIVED);
      }
    }
  }
  if (_tokens.size() > 0 && (_nextTimeFree == null || currentTime.compareTo(_nextTimeFree) >= 0)) {
    _scheduleRefire();
  }
  _receiversAndTokensToSendTo.clear();
  return super.postfire();
}"
73037,"/** 
 * Send token to receiver.
 * @param receiver The receiver.
 * @param token The token.
 * @exception NoRoomException If the receiver has no room for the token.
 * @exception IllegalActionException If the receiver cannot receive the token.
 */
protected void _sendToReceiver(Receiver receiver,Token token) throws NoRoomException, IllegalActionException {
  if (receiver instanceof IntermediateReceiver) {
    ((IntermediateReceiver)receiver).source=this;
  }
  receiver.put(token);
  _tokenCount--;
  sendQMTokenEvent((Actor)receiver.getContainer().getContainer(),0,_tokenCount,EventType.SENT);
}","/** 
 * Send token to receiver.
 * @param receiver The receiver.
 * @param token The token.
 * @exception NoRoomException If the receiver has no room for the token.
 * @exception IllegalActionException If the receiver cannot receive the token.
 */
protected void _sendToReceiver(Receiver receiver,Token token) throws NoRoomException, IllegalActionException {
  if (receiver instanceof IntermediateReceiver) {
    ((IntermediateReceiver)receiver).source=this;
  }
  receiver.put(token);
}"
73038,"/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor if there is not one already scheduled.
 * @param source Sender of the token.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @exception IllegalActionException If the refiring request fails.
 */
public void sendToken(Receiver source,Receiver receiver,Token token) throws IllegalActionException {
  if (getDirector() instanceof DEDirector && token == null) {
    return;
  }
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree == null || _tokens.size() == 0 || currentTime.compareTo(_nextTimeFree) != 0 || receiver != _nextReceiver) {
    if (getDirector() instanceof FixedPointDirector) {
      receiver.put(null);
    }
  }
  Token tokenToSend=_receiversAndTokensToSendTo.get(receiver);
  if (tokenToSend != null) {
    if (!tokenToSend.equals(token)) {
      throw new IllegalActionException(this,receiver.getContainer(),""String_Node_Str"" + tokenToSend + ""String_Node_Str""+ token+ ""String_Node_Str"");
    }
  }
 else {
    if (token != null) {
      _receiversAndTokensToSendTo.put(receiver,token);
      _tempReceiverQueue.put(receiver);
      if (!(getDirector() instanceof FixedPointDirector)) {
        _tokens.put(new Object[]{receiver,token});
        _tokenCount++;
        sendQMTokenEvent((Actor)source.getContainer().getContainer(),0,_tokenCount,EventType.RECEIVED);
        if (_tokens.size() == 1) {
          _scheduleRefire();
        }
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime() + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
  }
}","/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor if there is not one already scheduled.
 * @param source Sender of the token.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @exception IllegalActionException If the refiring request fails.
 */
public void sendToken(Receiver source,Receiver receiver,Token token) throws IllegalActionException {
  if (getDirector() instanceof DEDirector && token == null) {
    return;
  }
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree == null || _tokens.size() == 0 || currentTime.compareTo(_nextTimeFree) != 0 || receiver != _nextReceiver) {
    if (getDirector() instanceof FixedPointDirector) {
      receiver.put(null);
    }
  }
  Token tokenToSend=null;
  if (getDirector() instanceof FixedPointDirector) {
    tokenToSend=_receiversAndTokensToSendTo.get(receiver);
  }
  if (tokenToSend != null) {
    if (!tokenToSend.equals(token)) {
      throw new IllegalActionException(this,receiver.getContainer(),""String_Node_Str"" + tokenToSend + ""String_Node_Str""+ token+ ""String_Node_Str"");
    }
  }
 else {
    if (token != null) {
      _receiversAndTokensToSendTo.put(receiver,token);
      _tempReceiverQueue.put(receiver);
      if (!(getDirector() instanceof FixedPointDirector)) {
        _tokens.put(new Object[]{receiver,token});
        _tokenCount++;
        sendQMTokenEvent((Actor)source.getContainer().getContainer(),0,_tokenCount,EventType.RECEIVED);
        if (_tokens.size() == 1) {
          _scheduleRefire();
        }
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime() + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
  }
}"
73039,"/** 
 * If there are still tokens in the queue and a token has been produced in the fire, schedule a refiring.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree != null && _tokens.size() > 0 && currentTime.compareTo(_nextTimeFree) == 0) {
    _tokens.take();
    _tokenCount--;
    sendQMTokenEvent(null,0,_tokenCount,EventType.RECEIVED);
  }
  if ((getDirector() instanceof FixedPointDirector) && _receiversAndTokensToSendTo != null) {
    while (_tempReceiverQueue.size() > 0) {
      Receiver receiver=(Receiver)_tempReceiverQueue.take();
      Token token=_receiversAndTokensToSendTo.get(receiver);
      if (token != null) {
        _tokens.put(new Object[]{receiver,token});
        _tokenCount++;
        sendQMTokenEvent((Actor)receiver.getContainer().getContainer(),0,_tokenCount,EventType.RECEIVED);
      }
    }
    _receiversAndTokensToSendTo.clear();
  }
  if (_tokens.size() > 0 && (_nextTimeFree == null || currentTime.compareTo(_nextTimeFree) >= 0)) {
    _scheduleRefire();
  }
  return super.postfire();
}","/** 
 * If there are still tokens in the queue and a token has been produced in the fire, schedule a refiring.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree != null && _tokens.size() > 0 && currentTime.compareTo(_nextTimeFree) == 0) {
    _tokens.take();
    _tokenCount--;
    sendQMTokenEvent(null,0,_tokenCount,EventType.RECEIVED);
  }
  if ((getDirector() instanceof FixedPointDirector) && _receiversAndTokensToSendTo != null) {
    while (_tempReceiverQueue.size() > 0) {
      Receiver receiver=(Receiver)_tempReceiverQueue.take();
      Token token=_receiversAndTokensToSendTo.get(receiver);
      if (token != null) {
        _tokens.put(new Object[]{receiver,token});
        _tokenCount++;
        sendQMTokenEvent((Actor)receiver.getContainer().getContainer(),0,_tokenCount,EventType.RECEIVED);
      }
    }
  }
  if (_tokens.size() > 0 && (_nextTimeFree == null || currentTime.compareTo(_nextTimeFree) >= 0)) {
    _scheduleRefire();
  }
  _receiversAndTokensToSendTo.clear();
  return super.postfire();
}"
73040,"/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor if there is not one already scheduled.
 * @param source Sender of the token.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @exception IllegalActionException If the refiring request fails.
 */
public void sendToken(Receiver source,Receiver receiver,Token token) throws IllegalActionException {
  if (getDirector() instanceof DEDirector && token == null) {
    return;
  }
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree == null || _tokens.size() == 0 || currentTime.compareTo(_nextTimeFree) != 0 || receiver != _nextReceiver) {
    if (getDirector() instanceof FixedPointDirector) {
      receiver.put(null);
    }
  }
  Token tokenToSend=null;
  if (getDirector() instanceof FixedPointDirector) {
    tokenToSend=_receiversAndTokensToSendTo.get(receiver);
  }
  if (tokenToSend != null) {
    if (!tokenToSend.equals(token)) {
      throw new IllegalActionException(this,receiver.getContainer(),""String_Node_Str"" + tokenToSend + ""String_Node_Str""+ token+ ""String_Node_Str"");
    }
  }
 else {
    if (token != null) {
      _receiversAndTokensToSendTo.put(receiver,token);
      _tempReceiverQueue.put(receiver);
      if (!(getDirector() instanceof FixedPointDirector)) {
        _tokens.put(new Object[]{receiver,token});
        _tokenCount++;
        sendQMTokenEvent((Actor)source.getContainer().getContainer(),0,_tokenCount,EventType.RECEIVED);
        if (_tokens.size() == 1) {
          _scheduleRefire();
        }
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime() + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
  }
}","/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor if there is not one already scheduled.
 * @param source Sender of the token.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @exception IllegalActionException If the refiring request fails.
 */
public void sendToken(Receiver source,Receiver receiver,Token token) throws IllegalActionException {
  if (getDirector() instanceof DEDirector && token == null) {
    return;
  }
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree == null || _tokens.size() == 0 || currentTime.compareTo(_nextTimeFree) != 0 || receiver != _nextReceiver) {
    if (getDirector() instanceof FixedPointDirector) {
      receiver.put(null);
    }
  }
  Token tokenToSend=_receiversAndTokensToSendTo.get(receiver);
  if (tokenToSend != null) {
    if (!tokenToSend.equals(token)) {
      throw new IllegalActionException(this,receiver.getContainer(),""String_Node_Str"" + tokenToSend + ""String_Node_Str""+ token+ ""String_Node_Str"");
    }
  }
 else {
    if (token != null) {
      _receiversAndTokensToSendTo.put(receiver,token);
      _tempReceiverQueue.put(receiver);
      if (!(getDirector() instanceof FixedPointDirector)) {
        _tokens.put(new Object[]{receiver,token});
        _tokenCount++;
        sendQMTokenEvent((Actor)source.getContainer().getContainer(),0,_tokenCount,EventType.RECEIVED);
        if (_tokens.size() == 1) {
          _scheduleRefire();
        }
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime() + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
  }
}"
73041,"/** 
 * Dispose the current execution. 
 */
public void reset(){
  this.state=State.POSTFIRE_END_PREFIRE_BEGIN;
  currentStateEvent=createMetroIIEvent(""String_Node_Str"");
}","/** 
 * Dispose the current execution. 
 */
public void reset(){
  _state=State.POSTFIRE_END_PREFIRE_BEGIN;
  _currentStateEvent=_createMetroIIEvent(""String_Node_Str"");
}"
73042,"/** 
 * Construct a basic wrapper.
 * @param actor The actor
 */
public MetroIIActorBasicWrapper(Actor actor){
  this.actor=actor;
  this.state=State.POSTFIRE_END_PREFIRE_BEGIN;
  currentStateEvent=createMetroIIEvent(""String_Node_Str"");
}","/** 
 * Construct a basic wrapper.
 * @param actor The actor
 */
public MetroIIActorBasicWrapper(Actor actor){
  this._actor=actor;
  reset();
}"
73043,"/** 
 * Stop and dispose any associated thread. 
 */
@Override public void reset(){
  if (state == State.FIRING) {
    eventIterator.dispose();
    actor.stop();
  }
}","/** 
 * Stop and dispose any associated thread. 
 */
@Override public void reset(){
  if (_state == State.FIRING) {
    _eventIterator.dispose();
    _actor.stop();
  }
}"
73044,"/** 
 * Start or resume the execution of an actor. The execution means  calling prefire(), getfire(), and postfire(). The  execution of getfire() is encapsulated in a thread (implemented  in YieldAdapter).  The thread pauses when getfire() yield-returns a list of MetroII  events. 
 * @param metroIIEventList the list of MetroII events getfire() returns. 
 */
@Override public void startOrResume(LinkedList<Builder> metroIIEventList) throws IllegalActionException {
}","/** 
 * Start or resume the execution of an actor. The execution means  calling prefire(), getfire(), and postfire(). The  execution of getfire() is encapsulated in a thread (implemented  in YieldAdapter @see net.jimblackler.Utils.YieldAdapter).  The thread pauses when getfire() yield-returns a list of MetroII  events. 
 * @param metroIIEventList the list of MetroII events getfire() returns. 
 */
@Override public void startOrResume(LinkedList<Builder> metroIIEventList) throws IllegalActionException {
}"
73045,"/** 
 * Construct a Actor-Thread pair.
 * @param actor The actor
 */
public MetroIIActorGeneralWrapper(Actor actor){
  super(actor);
  this.eventIterator=null;
}","/** 
 * Construct a Actor-Thread pair.
 * @param actor The actor
 */
public MetroIIActorGeneralWrapper(Actor actor){
  super(actor);
  this._eventIterator=null;
}"
73046,"/** 
 * Schedule an actor for execution on a ResourceScheduler. If the actor can execute this method returns true. If resources are not available this  method returns false. 
 * @param actor The actor.
 * @param timestamp The time the actor requests to be scheduled.
 * @param executionTime The execution Time for this event. 
 * @return True if actor was scheduled and can be fired.
 * @exception IllegalActionException Thrown if parameters cannot be read, actor cannot bescheduled or container cannot be fired at future time.
 */
protected boolean _schedule(Actor actor,Time timestamp) throws IllegalActionException {
  _resourceBusy=false;
  ResourceSchedulerInterface scheduler=_getScheduler(actor);
  Time time=null;
  Boolean finished=true;
  if (timestamp == null) {
    timestamp=getModelTime();
  }
  if (scheduler != null) {
    double deadline=_getDeadline(actor,timestamp);
    time=(scheduler).schedule(actor,getEnvironmentTime(),deadline,_getExecutionTime(actor));
    finished=_actorFinished(actor);
    if (time != null && time.getDoubleValue() > 0.0) {
      CompositeActor container=(CompositeActor)((Attribute)scheduler).getContainer();
      container.getDirector().fireContainerAt(getEnvironmentTime().add(time));
    }
  }
 else   if (isEmbedded()) {
    return ((CompositeActor)(((CompositeActor)getContainer())).getContainer()).getDirector()._schedule(actor,timestamp);
  }
  return _resourceBusy=(time == null || finished);
}","/** 
 * Schedule an actor for execution on a ResourceScheduler. If the actor can execute this method returns true. If resources are not available this  method returns false. 
 * @param actor The actor.
 * @param timestamp The time the actor requests to be scheduled.
 * @param executionTime The execution Time for this event. 
 * @return True if actor was scheduled and can be fired.
 * @exception IllegalActionException Thrown if parameters cannot be read, actor cannot bescheduled or container cannot be fired at future time.
 */
protected boolean _schedule(Actor actor,Time timestamp) throws IllegalActionException {
  ResourceSchedulerInterface scheduler=_getScheduler(actor);
  Time time=null;
  Boolean finished=true;
  if (timestamp == null) {
    timestamp=getModelTime();
  }
  if (scheduler != null) {
    double deadline=_getDeadline(actor,timestamp);
    time=(scheduler).schedule(actor,getEnvironmentTime(),deadline,_getExecutionTime(actor));
    finished=_actorFinished(actor);
    if (time != null && time.getDoubleValue() > 0.0) {
      CompositeActor container=(CompositeActor)((Attribute)scheduler).getContainer();
      container.getDirector().fireContainerAt(getEnvironmentTime().add(time));
    }
  }
 else   if (isEmbedded()) {
    return ((CompositeActor)(((CompositeActor)getContainer())).getContainer()).getDirector()._schedule(actor,timestamp);
  }
  return (time == null || finished);
}"
73047,"/** 
 * Dequeue the events that have the smallest tag from the event queue. Return their destination actor. Advance the model tag to their tag. If the timestamp of the smallest tag is greater than the stop time then return null. If there are no events in the event queue, and the stopWhenQueueIsEmpty parameter is set to true, then return null. Both cases will have the effect of stopping the simulation. <p> If the stopWhenQueueIsEmpty parameter is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are new events available.  If the synchronizeToRealTime parameter is true, then this method may suspend the calling thread by using Object.wait(long) to let elapsed real time catch up with the current model time.</p>
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  if (_eventQueue == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  Actor actorToFire=null;
  DEEvent lastFoundEvent=null;
  DEEvent nextEvent=null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
    }
    if (isEmbedded()) {
      if (_eventQueue.isEmpty()) {
        break;
      }
      nextEvent=_eventQueue.get();
      if ((nextEvent.timeStamp().compareTo(getModelTime()) < 0)) {
        throw new IllegalActionException(""String_Node_Str"" + nextEvent.timeStamp() + ""String_Node_Str""+ nextEvent.microstep()+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
      }
      boolean microstepMatches=true;
      Nameable container=getContainer();
      if (container instanceof CompositeActor) {
        Director executiveDirector=((CompositeActor)container).getExecutiveDirector();
        if (executiveDirector instanceof SuperdenseTimeDirector && !_isTopLevel()) {
          microstepMatches=nextEvent.microstep() <= _microstep;
        }
      }
      int comparison=nextEvent.timeStamp().compareTo(getModelTime());
      if (comparison > 0 || (comparison == 0 && !microstepMatches)) {
        nextEvent=null;
        break;
      }
    }
 else {
      if (_eventQueue.isEmpty()) {
        if ((actorToFire != null) || (getModelTime().equals(getModelStopTime()))) {
          break;
        }
      }
synchronized (_eventQueue) {
        while (_eventQueue.isEmpty() && !_stopRequested && !_stopFireRequested) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          try {
            workspace().wait(_eventQueue);
          }
 catch (          InterruptedException e) {
            break;
          }
        }
        if (_eventQueue.isEmpty()) {
          return null;
        }
        nextEvent=_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      Time currentTime;
      if (_synchronizeToRealTime) {
        int depth=0;
        try {
synchronized (_eventQueue) {
            while (!_stopRequested && !_stopFireRequested) {
              lastFoundEvent=_eventQueue.get();
              currentTime=lastFoundEvent.timeStamp();
              long elapsedTime=System.currentTimeMillis() - _realStartTime;
              double elapsedTimeInSeconds=elapsedTime / 1000.0;
              ptolemy.actor.util.Time elapsed=new ptolemy.actor.util.Time(this,elapsedTimeInSeconds);
              if (currentTime.compareTo(elapsed) <= 0) {
                break;
              }
              long timeToWait=(long)(currentTime.subtract(elapsed).getDoubleValue() * 1000.0);
              if (timeToWait > 0) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + timeToWait);
                }
                try {
                  depth=_workspace.releaseReadPermission();
                  _eventQueue.wait(timeToWait);
                }
 catch (                InterruptedException ex) {
                  throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
                }
              }
            }
            if (_stopRequested || _stopFireRequested) {
              return null;
            }
          }
        }
  finally {
          if (depth > 0) {
            _workspace.reacquireReadPermission(depth);
          }
        }
      }
synchronized (_eventQueue) {
        lastFoundEvent=_eventQueue.take();
        currentTime=lastFoundEvent.timeStamp();
        actorToFire=lastFoundEvent.actor();
        if ((_disabledActors != null) && _disabledActors.contains(actorToFire)) {
          if (_debugging) {
            _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          }
          actorToFire=null;
          continue;
        }
        setModelTime(currentTime);
        _microstep=lastFoundEvent.microstep();
        if (_debugging) {
          _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
      }
      if (currentTime.compareTo(getModelStopTime()) > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
    }
 else {
      if (nextEvent.hasTheSameTagAs(lastFoundEvent) && nextEvent.actor() == actorToFire) {
synchronized (_eventQueue) {
          _eventQueue.take();
        }
      }
 else {
        break;
      }
    }
  }
  if (actorToFire != null && !_schedule(actorToFire,getModelTime())) {
    return null;
  }
  return actorToFire;
}","/** 
 * Dequeue the events that have the smallest tag from the event queue. Return their destination actor. Advance the model tag to their tag. If the timestamp of the smallest tag is greater than the stop time then return null. If there are no events in the event queue, and the stopWhenQueueIsEmpty parameter is set to true, then return null. Both cases will have the effect of stopping the simulation. <p> If the stopWhenQueueIsEmpty parameter is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are new events available.  If the synchronizeToRealTime parameter is true, then this method may suspend the calling thread by using Object.wait(long) to let elapsed real time catch up with the current model time.</p>
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  if (_eventQueue == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  Actor actorToFire=null;
  DEEvent lastFoundEvent=null;
  DEEvent nextEvent=null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
    }
    if (isEmbedded()) {
      if (_eventQueue.isEmpty()) {
        break;
      }
      nextEvent=_eventQueue.get();
      if ((nextEvent.timeStamp().compareTo(getModelTime()) < 0)) {
        throw new IllegalActionException(""String_Node_Str"" + nextEvent.timeStamp() + ""String_Node_Str""+ nextEvent.microstep()+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
      }
      boolean microstepMatches=true;
      Nameable container=getContainer();
      if (container instanceof CompositeActor) {
        Director executiveDirector=((CompositeActor)container).getExecutiveDirector();
        if (executiveDirector instanceof SuperdenseTimeDirector && !_isTopLevel()) {
          microstepMatches=nextEvent.microstep() <= _microstep;
        }
      }
      int comparison=nextEvent.timeStamp().compareTo(getModelTime());
      if (comparison > 0 || (comparison == 0 && !microstepMatches)) {
        nextEvent=null;
        break;
      }
    }
 else {
      if (_eventQueue.isEmpty()) {
        if ((actorToFire != null) || (getModelTime().equals(getModelStopTime()))) {
          break;
        }
      }
synchronized (_eventQueue) {
        while (_eventQueue.isEmpty() && !_stopRequested && !_stopFireRequested) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          try {
            workspace().wait(_eventQueue);
          }
 catch (          InterruptedException e) {
            break;
          }
        }
        if (_eventQueue.isEmpty()) {
          return null;
        }
        nextEvent=_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      Time currentTime;
      if (_synchronizeToRealTime) {
        int depth=0;
        try {
synchronized (_eventQueue) {
            while (!_stopRequested && !_stopFireRequested) {
              lastFoundEvent=_eventQueue.get();
              currentTime=lastFoundEvent.timeStamp();
              long elapsedTime=System.currentTimeMillis() - _realStartTime;
              double elapsedTimeInSeconds=elapsedTime / 1000.0;
              ptolemy.actor.util.Time elapsed=new ptolemy.actor.util.Time(this,elapsedTimeInSeconds);
              if (currentTime.compareTo(elapsed) <= 0) {
                break;
              }
              long timeToWait=(long)(currentTime.subtract(elapsed).getDoubleValue() * 1000.0);
              if (timeToWait > 0) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + timeToWait);
                }
                try {
                  depth=_workspace.releaseReadPermission();
                  _eventQueue.wait(timeToWait);
                }
 catch (                InterruptedException ex) {
                  throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
                }
              }
            }
            if (_stopRequested || _stopFireRequested) {
              return null;
            }
          }
        }
  finally {
          if (depth > 0) {
            _workspace.reacquireReadPermission(depth);
          }
        }
      }
synchronized (_eventQueue) {
        lastFoundEvent=_eventQueue.take();
        currentTime=lastFoundEvent.timeStamp();
        actorToFire=lastFoundEvent.actor();
        if ((_disabledActors != null) && _disabledActors.contains(actorToFire)) {
          if (_debugging) {
            _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          }
          actorToFire=null;
          continue;
        }
        setModelTime(currentTime);
        _microstep=lastFoundEvent.microstep();
        if (_debugging) {
          _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
      }
      if (currentTime.compareTo(getModelStopTime()) > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
    }
 else {
      if (nextEvent.hasTheSameTagAs(lastFoundEvent) && nextEvent.actor() == actorToFire) {
synchronized (_eventQueue) {
          _eventQueue.take();
        }
      }
 else {
        break;
      }
    }
  }
  if (actorToFire != null && _resourceScheduling && !_schedule(actorToFire,getModelTime())) {
    return null;
  }
  return actorToFire;
}"
73048,"/** 
 * Add a pure event to the queue of pure events.
 * @param actor Actor to fire.
 * @param time Time the actor should be fired at.
 * @param index Microstep the actor should be fired at.
 * @return The time the actor requested to be refired at.
 * @exception IllegalActionException If firing of the container doesn't succeed.
 */
public Time fireAt(Actor actor,Time time,int index) throws IllegalActionException {
  if (actor == this.getContainer()) {
    fireContainerAt(time);
    return time;
  }
  int newIndex=index;
  if (_currentLogicalTime != null && _currentLogicalTime.compareTo(time) == 0 && index <= getIndex()) {
    if (!resourceBusy()) {
      newIndex=Math.max(getIndex(),index) + 1;
    }
  }
  if (_isInitializing) {
    _currentSourceTimestamp=time;
  }
  _pureEvents.put(new PtidesEvent(actor,null,time,newIndex,0,_zeroTime,_currentSourceTimestamp));
  _currentSourceTimestamp=null;
  Time environmentTime=super.getEnvironmentTime();
  if (environmentTime.compareTo(time) <= 0) {
    fireContainerAt(time,1);
  }
  return time;
}","/** 
 * Add a pure event to the queue of pure events.
 * @param actor Actor to fire.
 * @param time Time the actor should be fired at.
 * @param index Microstep the actor should be fired at.
 * @return The time the actor requested to be refired at.
 * @exception IllegalActionException If firing of the container doesn't succeed.
 */
public Time fireAt(Actor actor,Time time,int index) throws IllegalActionException {
  if (actor == this.getContainer()) {
    fireContainerAt(time);
    return time;
  }
  int newIndex=index;
  if (_currentLogicalTime != null && _currentLogicalTime.compareTo(time) == 0 && index <= getIndex()) {
    if (((CompositeActor)actor).getDirector().scheduleContainedActors()) {
      newIndex=Math.max(getIndex(),index) + 1;
    }
  }
  if (_isInitializing) {
    _currentSourceTimestamp=time;
  }
  _pureEvents.put(new PtidesEvent(actor,null,time,newIndex,0,_zeroTime,_currentSourceTimestamp));
  _currentSourceTimestamp=null;
  Time environmentTime=super.getEnvironmentTime();
  if (environmentTime.compareTo(time) <= 0) {
    fireContainerAt(time,1);
  }
  return time;
}"
73049,"/** 
 * Construct a director in the given container with the given name. The container argument must not be null, or a NullPointerException will be thrown. If the name argument is null, then the name is set to the empty string. Increment the version number of the workspace.
 * @param container Container of the director.
 * @param name Name of this director.
 * @exception IllegalActionException If thedirector is not compatible with the specified container.
 * @exception NameDuplicationException If the container not aCompositeActor and the name collides with an entity in the container.
 */
public SchedulerDirector(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
}","/** 
 * Construct a director in the given container with the given name. The container argument must not be null, or a NullPointerException will be thrown. If the name argument is null, then the name is set to the empty string. Increment the version number of the workspace.
 * @param container Container of the director.
 * @param name Name of this director.
 * @exception IllegalActionException If thedirector is not compatible with the specified container.
 * @exception NameDuplicationException If the container not aCompositeActor and the name collides with an entity in the container.
 */
public SchedulerDirector(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _resourceScheduling=false;
}"
73050,"/** 
 * Return true if next actor in list of fire requests was scheduled and can execute.
 * @return true If next actor can execute.
 * @exception IllegalActionExcepiton If request to resource scheduler fails.
 */
public boolean scheduleContainedActors() throws IllegalActionException {
  RefireRequest request=_fireAtRequests.peek();
  return _schedule(request.actor,getModelTime());
}","/** 
 * Return true if next actor in list of fire requests was scheduled and can execute.
 * @return true If next actor can execute.
 * @exception IllegalActionExcepiton If request to resource scheduler fails.
 */
public boolean scheduleContainedActors() throws IllegalActionException {
  RefireRequest request=_fireAtRequests.peek();
  if (request == null) {
    return true;
  }
  return _schedule(request.actor,getModelTime());
}"
73051,"/** 
 * Iterate the specified actor once.
 * @return True if either prefire() returns falseor postfire() returns true.
 * @throws IllegalActionException If the actor throws it.
 */
protected boolean _iterateActorOnce(Actor actor) throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str"");
  }
  FiringsRecordable firingsRecordable=null;
  if (actor instanceof FiringsRecordable) {
    firingsRecordable=(FiringsRecordable)actor;
  }
  if (firingsRecordable != null) {
    firingsRecordable.recordFiring(FiringEvent.BEFORE_PREFIRE);
  }
  boolean result=true;
  if (actor.prefire()) {
    if (firingsRecordable != null) {
      firingsRecordable.recordFiring(FiringEvent.AFTER_PREFIRE);
      firingsRecordable.recordFiring(FiringEvent.BEFORE_FIRE);
    }
    actor.fire();
    if (firingsRecordable != null) {
      firingsRecordable.recordFiring(FiringEvent.AFTER_FIRE);
      firingsRecordable.recordFiring(FiringEvent.BEFORE_POSTFIRE);
    }
    result=actor.postfire();
    if (firingsRecordable != null) {
      firingsRecordable.recordFiring(FiringEvent.AFTER_POSTFIRE);
    }
  }
 else   if (firingsRecordable != null) {
    firingsRecordable.recordFiring(FiringEvent.AFTER_PREFIRE);
  }
  if (!result) {
    if (_debugging) {
      _debug(actor.getFullName() + ""String_Node_Str"");
    }
    _actorsFinishedExecution.add(actor);
  }
  return result;
}","/** 
 * Iterate the specified actor once.
 * @return True if either prefire() returns falseor postfire() returns true.
 * @throws IllegalActionException If the actor throws it.
 */
protected boolean _iterateActorOnce(Actor actor) throws IllegalActionException {
  FiringsRecordable firingsRecordable=null;
  if (actor instanceof FiringsRecordable) {
    firingsRecordable=(FiringsRecordable)actor;
  }
  if (firingsRecordable != null) {
    firingsRecordable.recordFiring(FiringEvent.BEFORE_PREFIRE);
  }
  boolean result=true;
  if (actor.prefire()) {
    if (firingsRecordable != null) {
      firingsRecordable.recordFiring(FiringEvent.AFTER_PREFIRE);
      firingsRecordable.recordFiring(FiringEvent.BEFORE_FIRE);
    }
    actor.fire();
    if (firingsRecordable != null) {
      firingsRecordable.recordFiring(FiringEvent.AFTER_FIRE);
      firingsRecordable.recordFiring(FiringEvent.BEFORE_POSTFIRE);
    }
    result=actor.postfire();
    if (firingsRecordable != null) {
      firingsRecordable.recordFiring(FiringEvent.AFTER_POSTFIRE);
    }
  }
 else   if (firingsRecordable != null) {
    firingsRecordable.recordFiring(FiringEvent.AFTER_PREFIRE);
  }
  if (!result) {
    if (_debugging) {
      _debug(actor.getFullName() + ""String_Node_Str"");
    }
    _actorsFinishedExecution.add(actor);
  }
  return result;
}"
73052,"/** 
 * Start a new iteration (at a new time, presumably) and either run the actors to completion in order of creation or wait until a deadlock is detected, depending on activeObjects. Then deal with the deadlock by calling the protected method _resolveDeadlock() and return. This method is synchronized on the director.
 * @exception IllegalActionException If a derived class throws it.
 */
public synchronized void fire() throws IllegalActionException {
  Time currentTime=getModelTime();
  if (_debugging) {
    _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ _microstep);
  }
  if (_stopRequested) {
    _debug(""String_Node_Str"" + currentTime);
    return;
  }
  for (  Advanceable advanceable : _getAdvanceables()) {
    _iterateActorOnce((Actor)advanceable);
  }
  if (_fireAtRequests.size() > 0) {
    RefireRequest request=_fireAtRequests.peek();
    if (currentTime.equals(request.time) && _microstep == request.microstep) {
      while (true) {
        if (_stopRequested) {
          return;
        }
        request=_fireAtRequests.poll();
        if (_debugging) {
          _debug(request.actor.getFullName() + ""String_Node_Str"");
        }
        _iterateActorOnce(request.actor);
        if (_fireAtRequests.size() > 0) {
          request=_fireAtRequests.peek();
          if (!_schedule(request.actor,getModelTime())) {
            break;
          }
          if (!currentTime.equals(request.time) || _microstep != request.microstep) {
            break;
          }
        }
 else {
          break;
        }
      }
    }
  }
  while (_inputQueue.size() > 0 && !_stopRequested) {
    Input input=_inputQueue.get(0);
    IOPort port=input.receiver.getContainer();
    int channel=port.getChannelForReceiver(input.receiver);
    Actor actor=(Actor)port.getContainer();
    if (!_schedule(actor,getModelTime())) {
      break;
    }
    input=_inputQueue.remove(0);
    _clearReceivers(actor);
    if (!input.isChangeEvent) {
      input.receiver.reallyPut(input.token);
      if (_debugging) {
        _debug(actor.getFullName() + ""String_Node_Str"" + port.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ input.token);
      }
    }
 else     if (_debugging) {
      _debug(actor.getFullName() + ""String_Node_Str"" + port.getName()+ ""String_Node_Str""+ channel);
    }
    if (actor != getContainer()) {
      _iterateActorOnce(actor);
    }
 else {
      _transferOutputs(port);
    }
  }
}","/** 
 * Start a new iteration (at a new time, presumably) and either run the actors to completion in order of creation or wait until a deadlock is detected, depending on activeObjects. Then deal with the deadlock by calling the protected method _resolveDeadlock() and return. This method is synchronized on the director.
 * @exception IllegalActionException If a derived class throws it.
 */
public synchronized void fire() throws IllegalActionException {
  Time currentTime=getModelTime();
  if (_debugging) {
    _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ _microstep);
  }
  if (_stopRequested) {
    _debug(""String_Node_Str"" + currentTime);
    return;
  }
  for (  Advanceable advanceable : _getAdvanceables()) {
    _iterateActorOnce((Actor)advanceable);
  }
  if (_fireAtRequests.size() > 0) {
    RefireRequest request=_fireAtRequests.peek();
    if (currentTime.equals(request.time) && _microstep == request.microstep) {
      while (true) {
        if (_stopRequested) {
          return;
        }
        request=_fireAtRequests.poll();
        if (_debugging) {
          _debug(request.actor.getFullName() + ""String_Node_Str"");
        }
        _iterateActorOnce(request.actor);
        if (_fireAtRequests.size() > 0) {
          request=_fireAtRequests.peek();
          if (!_schedule(request.actor,getModelTime())) {
            break;
          }
          if (!currentTime.equals(request.time) || _microstep != request.microstep) {
            break;
          }
        }
 else {
          break;
        }
      }
    }
  }
  while (_inputQueue.size() > 0 && !_stopRequested) {
    Input input=_inputQueue.get(0);
    IOPort port=input.receiver.getContainer();
    int channel=port.getChannelForReceiver(input.receiver);
    Actor actor=(Actor)port.getContainer();
    input=_inputQueue.remove(0);
    _clearReceivers(actor);
    if (!input.isChangeEvent) {
      input.receiver.reallyPut(input.token);
      if (_debugging) {
        _debug(actor.getFullName() + ""String_Node_Str"" + port.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ input.token);
      }
    }
 else     if (_debugging) {
      _debug(actor.getFullName() + ""String_Node_Str"" + port.getName()+ ""String_Node_Str""+ channel);
    }
    if (actor != getContainer()) {
      if (!_schedule(actor,getModelTime())) {
        break;
      }
      _iterateActorOnce(actor);
    }
 else {
      _transferOutputs(port);
    }
  }
}"
73053,"/** 
 * Add a pure event to the queue of pure events.
 * @param actor Actor to fire.
 * @param time Time the actor should be fired at.
 * @param index Microstep the actor should be fired at.
 * @return The time the actor requested to be refired at.
 * @exception IllegalActionException If firing of the container doesn't succeed.
 */
public Time fireAt(Actor actor,Time time,int index) throws IllegalActionException {
  if (actor == this.getContainer()) {
    fireContainerAt(time);
    return time;
  }
  int newIndex=index;
  if (_currentLogicalTime != null && _currentLogicalTime.compareTo(time) == 0 && index <= getIndex()) {
    if (((CompositeActor)actor).getDirector().scheduleContainedActors()) {
      newIndex=Math.max(getIndex(),index) + 1;
    }
  }
  if (_isInitializing) {
    _currentSourceTimestamp=time;
  }
  _pureEvents.put(new PtidesEvent(actor,null,time,newIndex,0,_zeroTime,_currentSourceTimestamp));
  _currentSourceTimestamp=null;
  Time environmentTime=super.getEnvironmentTime();
  if (environmentTime.compareTo(time) <= 0) {
    fireContainerAt(time,1);
  }
  return time;
}","/** 
 * Add a pure event to the queue of pure events.
 * @param actor Actor to fire.
 * @param time Time the actor should be fired at.
 * @param index Microstep the actor should be fired at.
 * @return The time the actor requested to be refired at.
 * @exception IllegalActionException If firing of the container doesn't succeed.
 */
public Time fireAt(Actor actor,Time time,int index) throws IllegalActionException {
  if (actor == this.getContainer()) {
    fireContainerAt(time);
    return time;
  }
  int newIndex=index;
  if (_currentLogicalTime != null && _currentLogicalTime.compareTo(time) == 0 && index <= getIndex()) {
    if (!(actor instanceof CompositeActor) || ((CompositeActor)actor).getDirector().scheduleContainedActors()) {
      newIndex=Math.max(getIndex(),index) + 1;
    }
  }
  if (_isInitializing) {
    _currentSourceTimestamp=time;
  }
  _pureEvents.put(new PtidesEvent(actor,null,time,newIndex,0,_zeroTime,_currentSourceTimestamp));
  _currentSourceTimestamp=null;
  Time environmentTime=super.getEnvironmentTime();
  if (environmentTime.compareTo(time) <= 0) {
    fireContainerAt(time,1);
  }
  return time;
}"
73054,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Director newObject=(Director)super.clone(workspace);
  newObject._actorsFinishedExecution=null;
  newObject._initializables=null;
  newObject._startTime=null;
  newObject._stopTime=null;
  newObject._zeroTime=new Time(newObject);
  newObject._executionTimes=new HashMap<Actor,Time>();
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Director newObject=(Director)super.clone(workspace);
  newObject._actorsFinishedExecution=null;
  newObject._initializables=null;
  newObject._startTime=null;
  newObject._stopTime=null;
  newObject._zeroTime=new Time(newObject);
  newObject._executionTimes=new HashMap<Actor,Time>();
  newObject._resourceSchedulers=new ArrayList<ResourceSchedulerInterface>();
  return newObject;
}"
73055,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Director newObject=(Director)super.clone(workspace);
  newObject._actorsFinishedExecution=null;
  newObject._initializables=null;
  newObject._startTime=null;
  newObject._stopTime=null;
  newObject._zeroTime=new Time(newObject);
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Director newObject=(Director)super.clone(workspace);
  newObject._actorsFinishedExecution=null;
  newObject._initializables=null;
  newObject._startTime=null;
  newObject._stopTime=null;
  newObject._zeroTime=new Time(newObject);
  newObject._executionTimes=new HashMap<Actor,Time>();
  return newObject;
}"
73056,"/** 
 * Call requestFinish() on all receivers.
 */
private void _requestFinishOnReceivers(){
  CompositeActor container=(CompositeActor)getContainer();
  Iterator actors=container.deepEntityList().iterator();
  Iterator actorPorts;
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    actorPorts=actor.inputPortList().iterator();
    while (actorPorts.hasNext()) {
      IOPort port=(IOPort)actorPorts.next();
      Receiver[][] receivers=port.getReceivers();
      for (int i=0; i < receivers.length; i++) {
        for (int j=0; j < receivers[i].length; j++) {
          if (receivers[i][j] instanceof ProcessReceiver) {
            ((ProcessReceiver)receivers[i][j]).requestFinish();
          }
        }
      }
    }
  }
}","/** 
 * Call requestFinish() on all receivers.
 */
protected void _requestFinishOnReceivers(){
  CompositeActor container=(CompositeActor)getContainer();
  Iterator actors=container.deepEntityList().iterator();
  Iterator actorPorts;
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    actorPorts=actor.inputPortList().iterator();
    while (actorPorts.hasNext()) {
      IOPort port=(IOPort)actorPorts.next();
      Receiver[][] receivers=port.getReceivers();
      for (int i=0; i < receivers.length; i++) {
        for (int j=0; j < receivers[i].length; j++) {
          if (receivers[i][j] instanceof ProcessReceiver) {
            ((ProcessReceiver)receivers[i][j]).requestFinish();
          }
        }
      }
    }
  }
}"
73057,"/** 
 * Update the MetroII event list.
 * @param metroIIEventList MetroII event list
 */
public void resolve(Iterable<Event.Builder> metroIIEventList);","/** 
 * Update the MetroII events in the specified list
 * @param metroIIEventList A list of MetroII events to be updated
 */
public void resolve(Iterable<Event.Builder> metroIIEventList);"
73058,"/** 
 * Construct a mapping constraint solver of given size.
 * @param size The maximum number of allowed events.
 */
public MappingConstraintSolver(int size){
  _mapping=new int[size][size];
  _size=size;
  for (int i=0; i < _size; i++) {
    for (int j=0; j < _size; j++) {
      _mapping[i][j]=0;
    }
  }
  _currentMAXID=0;
}","/** 
 * Construct a mapping constraint solver of given size.
 * @param size The maximum number of allowed events.
 */
public MappingConstraintSolver(int size){
  _mapping=new int[size][size];
  _size=size;
  _initialize();
}"
73059,"/** 
 * Implement the MetroIIActorInterface. prefire(), fire() and postfire() are wrapped  in startOrResume(). The execution of startOrResume() can be seen as  follows:  <ol> <li> 1. Propose MetroII event POSTFIRE_END_PREFIRE_BEGIN </li> <li> 2. Check if POSTFIRE_END_PREFIRE_BEGIN is Notified. If not, go to 1 </li> <li> 3. prefire() </li> <li> 4. Propose MetroII event PREFIRE_END_FIRE_BEGIN </li> <li> 5. Check if PREFIRE_END_FIRE_BEGIN is Notified. If not, go to 4 </li> <li> 6. fire() </li> <li> 7. Propose MetroII event FIRE_END_POSTFIRE_BEGIN </li> <li> 8. Check if FIRE_END_POSTFIRE_BEGIN is Notified. If not, go to 4 </li> <li> 9. postfire() </li> </ol>
 */
@Override public void startOrResume(LinkedList<Builder> metroIIEventList) throws IllegalActionException {
}","/** 
 * The functions prefire(), fire() and postfire()  are wrapped in startOrResume() as follows:  <ol> <li> Propose MetroII event POSTFIRE_END_PREFIRE_BEGIN and wait for  the event being notified</li> <li> prefire() </li> <li> Propose MetroII event PREFIRE_END_FIRE_BEGIN and wait for the  event being notified</li> <li> fire() </li> <li> Propose MetroII event FIRE_END_POSTFIRE_BEGIN and wait for the  the event being notified</li> <li> postfire() </li> </ol> where 'wait' means checking the status of MetroII event. If notified,  continue execution, otherwise proposing the same event again.
 * @param metroIIEventList A list of MetroII events. 
 */
@Override public void startOrResume(LinkedList<Builder> metroIIEventList) throws IllegalActionException {
}"
73060,"/** 
 * The postfire() counts the number of iterations and returns false when  the number of iteration exceeds the parameter iterations.  postfire() will always return true if the parameter iterations is less  or equal to 0. 
 */
public boolean postfire() throws IllegalActionException {
  _iterationCount++;
  int iterationsValue=((IntToken)iterations.getToken()).intValue();
  if (iterationsValue > 0 && _iterationCount >= iterationsValue) {
    _iterationCount=0;
    for (    MetroIIActorInterface actor : _actorList) {
      actor.close();
    }
    return false;
  }
  return true;
}","/** 
 * The postfire() counts the number of iterations and returns false when  the number of iteration exceeds the parameter iterations.  postfire() will always return true if the parameter iterations is less  or equal to 0. 
 */
public boolean postfire() throws IllegalActionException {
  _iterationCount++;
  int iterationsValue=((IntToken)(iterations.getToken())).intValue();
  if (_stopRequested || (iterationsValue > 0) && (_iterationCount >= iterationsValue)) {
    _iterationCount=0;
    for (    MetroIIActorInterface actor : _actorList) {
      actor.reset();
    }
    return false;
  }
  return true;
}"
73061,"/** 
 * Construct a director in the given container with the given name.  The container argument must not be null, or a NullPointerException will be thrown.  If the name argument is null, then the name is set to the empty string. Increment the version number of the workspace.
 * @param container Container of the director.
 * @param name Name of this director.
 * @exception IllegalActionException If the director is not compatiblewith the specified container.  May be thrown in a derived class.
 * @exception NameDuplicationException If the container is not aCompositeActor and the name collides with an entity in the container.
 */
public MetroIIDirector(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  _initializeParameters();
  initialize();
}","/** 
 * Construct a director in the given container with the given name.  The container argument must not be null, or a NullPointerException will be thrown.  If the name argument is null, then the name is set to the empty string. Increment the version number of the workspace.
 * @param container Container of the director.
 * @param name Name of this director.
 * @exception IllegalActionException If the director is not compatiblewith the specified container.  May be thrown in a derived class.
 * @exception NameDuplicationException If the container is not aCompositeActor and the name collides with an entity in the container.
 */
public MetroIIDirector(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  _actorList=new LinkedList<MetroIIActorInterface>();
  _mappingConstraintSolver=new MappingConstraintSolver(_maxEvent);
  _initializeParameters();
  initialize();
}"
73062,"/** 
 * Each iteration has two phases. In Phase 1, MetroIIDirector  calls each actor (no particular order should be presumed. See  Note 1). Each actor runs until it wants to propose MetroII  events: the actor saves the state and returns with MetroII events.  In Phase 2, MetroIIDirector calls the MappingConstraintSolver,  which updates the MetroII events based on the mapping constraints.  
 */
public void fire() throws IllegalActionException {
  if (!_stopRequested) {
    LinkedList<Event.Builder> globalMetroIIEventList=new LinkedList<Event.Builder>();
    System.out.println(""String_Node_Str"" + Integer.toString(_iterationCount) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    for (    MetroIIActorInterface actor : _actorList) {
      LinkedList<Event.Builder> metroIIEventList=new LinkedList<Event.Builder>();
      actor.startOrResume(metroIIEventList);
      globalMetroIIEventList.addAll(metroIIEventList);
    }
    for (    Event.Builder builder : globalMetroIIEventList) {
      System.out.format(""String_Node_Str"",builder.getName(),builder.getStatus());
    }
    System.out.println(""String_Node_Str"");
    _mappingConstraintSolver.resolve(globalMetroIIEventList);
    for (    Event.Builder mtb : globalMetroIIEventList) {
      System.out.format(""String_Node_Str"",mtb.getName(),mtb.getStatus());
    }
  }
  if (_stopRequested) {
    for (    MetroIIActorInterface actor : _actorList) {
      actor.close();
    }
  }
}","/** 
 * Each iteration has two phases. In Phase 1, MetroIIDirector  calls each actor (no particular order should be presumed. See  Note 1). Each actor runs until it wants to propose MetroII  events: the actor saves the state and returns with MetroII events.  In Phase 2, MetroIIDirector calls the MappingConstraintSolver,  which updates the MetroII events based on the mapping constraints.  
 */
public void fire() throws IllegalActionException {
  if (!_stopRequested) {
    LinkedList<Event.Builder> globalMetroIIEventList=new LinkedList<Event.Builder>();
    System.out.println(""String_Node_Str"" + Integer.toString(_iterationCount) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    for (    MetroIIActorInterface actor : _actorList) {
      LinkedList<Event.Builder> metroIIEventList=new LinkedList<Event.Builder>();
      actor.startOrResume(metroIIEventList);
      globalMetroIIEventList.addAll(metroIIEventList);
    }
    for (    Event.Builder builder : globalMetroIIEventList) {
      System.out.format(""String_Node_Str"",builder.getName(),builder.getStatus());
    }
    System.out.println(""String_Node_Str"");
    _mappingConstraintSolver.resolve(globalMetroIIEventList);
    for (    Event.Builder mtb : globalMetroIIEventList) {
      System.out.format(""String_Node_Str"",mtb.getName(),mtb.getStatus());
    }
  }
}"
73063,"/** 
 * Initialize the model controlled by this director. Call the  initialize() of super class and then wrap each actor that  is controlled by this director. This method should typically be invoked once per execution, after the preinitialization phase, but before any iteration. It may be invoked in the middle of an execution, if reinitialization is desired.  This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  Nameable container=getContainer();
  if (container instanceof CompositeActor) {
    Iterator<?> actors=((CompositeActor)container).deepEntityList().iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      if (actor instanceof MetroIIEventHandler) {
        _actorList.add(new MetroIIActorGeneralWrapper(actor));
      }
 else {
        _actorList.add(new MetroIIActorBasicWrapper(actor));
      }
    }
  }
  _iterationCount=0;
}","/** 
 * Initialize the model controlled by this director. Call the  initialize() of super class and then wrap each actor that  is controlled by this director. This method should typically be invoked once per execution, after the preinitialization phase, but before any iteration. It may be invoked in the middle of an execution, if reinitialization is desired.  This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  Nameable container=getContainer();
  if (container instanceof CompositeActor) {
    Iterator<?> actors=((CompositeActor)container).deepEntityList().iterator();
    _actorList.clear();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      if (actor instanceof MetroIIEventHandler) {
        _actorList.add(new MetroIIActorGeneralWrapper(actor));
      }
 else {
        _actorList.add(new MetroIIActorBasicWrapper(actor));
      }
    }
  }
  _iterationCount=0;
}"
73064,"/** 
 * Implement fire() with MetroII event handling.  In each iteration, getfire() waits until all other threads are blocked  and yield returns MetroII events. When getfire() continues, notify the  threads blocked on MetroII events based on the event status. A thread  blocked on MetroII event is not notified until the blocking MetroII  event is NOTIFIED.  The rest of the function is copied from fire() of ProcessDirector
 */
@Override public void getfire(ResultHandler<Iterable<Builder>> resultHandler) throws CollectionAbortedException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Workspace workspace=workspace();
  CompositeActor container=(CompositeActor)getContainer();
  Director outsideDirector=container.getExecutiveDirector();
  if (!(outsideDirector instanceof ProcessDirector)) {
    outsideDirector=null;
  }
  int depth=0;
  try {
synchronized (this) {
      while (!_areThreadsDeadlocked() && !_areAllThreadsStopped() && !_stopRequested) {
        if (_stopRequested) {
          return;
        }
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        try {
          if (outsideDirector != null) {
            ((ProcessDirector)outsideDirector).threadBlocked(Thread.currentThread(),null);
          }
          if (depth == 0) {
            depth=workspace.releaseReadPermission();
          }
          System.out.println(_getActiveThreadsCount());
          System.out.println(_getMetroIIEventBlockedThreadsCount());
          System.out.println(_getStoppedThreadsCount());
          System.out.println(_getBlockedThreadsCount());
          while (!_areThreadsDeadlocked() && !_areAllThreadsStopped() && _getActiveThreadsCount() != _getMetroIIEventBlockedThreadsCount() + _getBlockedThreadsCount()) {
            wait(1);
          }
          if (!_areThreadsDeadlocked() && !_areAllThreadsStopped()) {
            System.out.println(""String_Node_Str"" + _proposedMetroIIEventList.size());
            ArrayList<Event.Builder> tmp_events=new ArrayList<Event.Builder>(_proposedMetroIIEventList);
            System.out.println(""String_Node_Str"" + tmp_events.size());
            _proposedMetroIIEventList.clear();
            resultHandler.handleResult(tmp_events);
            for (            Builder etb : tmp_events) {
              if (etb.getStatus() == Event.Status.NOTIFIED) {
                String event_name=etb.getName();
                Object lock=_eventLock.get(_eventName2Id(event_name));
synchronized (lock) {
                  lock.notifyAll();
                  System.out.println(""String_Node_Str"" + event_name);
                }
              }
 else {
                _proposedMetroIIEventList.add(etb);
              }
            }
          }
        }
 catch (        InterruptedException e) {
          stop();
          return;
        }
 finally {
          if (outsideDirector != null) {
            ((ProcessDirector)outsideDirector).threadUnblocked(Thread.currentThread(),null);
          }
        }
      }
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      if (_areThreadsDeadlocked() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        try {
          _notDone=_resolveDeadlock();
        }
 catch (        IllegalActionException e) {
          stop();
          try {
            throw e;
          }
 catch (          IllegalActionException e1) {
            e1.printStackTrace();
          }
        }
      }
    }
  }
  finally {
    if (depth > 0) {
      workspace.reacquireReadPermission(depth);
    }
  }
}","/** 
 * Implement fire() with MetroII event handling.  In each iteration, getfire() waits until all other threads are blocked  and yield returns MetroII events. When getfire() continues, notify the  threads blocked on MetroII events based on the event status. A thread  blocked on MetroII event is not notified until the blocking MetroII  event is NOTIFIED.  The rest of the function is copied from fire() of ProcessDirector
 */
@Override public void getfire(ResultHandler<Iterable<Builder>> resultHandler) throws CollectionAbortedException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Workspace workspace=workspace();
  CompositeActor container=(CompositeActor)getContainer();
  Director outsideDirector=container.getExecutiveDirector();
  if (!(outsideDirector instanceof ProcessDirector)) {
    outsideDirector=null;
  }
  int depth=0;
  try {
synchronized (this) {
      while (!_areThreadsDeadlocked() && !_areAllThreadsStopped() && !_stopRequested) {
        if (_stopRequested) {
          return;
        }
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        try {
          if (outsideDirector != null) {
            ((ProcessDirector)outsideDirector).threadBlocked(Thread.currentThread(),null);
          }
          if (depth == 0) {
            depth=workspace.releaseReadPermission();
          }
          System.out.println(""String_Node_Str"" + _getActiveThreadsCount());
          System.out.println(""String_Node_Str"" + _getMetroIIEventBlockedThreadsCount());
          System.out.println(""String_Node_Str"" + _getStoppedThreadsCount());
          System.out.println(""String_Node_Str"" + _getBlockedThreadsCount());
          while (!_areThreadsDeadlocked() && !_areAllThreadsStopped() && _getActiveThreadsCount() != _getMetroIIEventBlockedThreadsCount() + _getBlockedThreadsCount()) {
            wait(1);
          }
          if (!_areThreadsDeadlocked() && !_areAllThreadsStopped()) {
            System.out.println(""String_Node_Str"" + _proposedMetroIIEventList.size());
            ArrayList<Event.Builder> tmp_events=new ArrayList<Event.Builder>(_proposedMetroIIEventList);
            System.out.println(""String_Node_Str"" + tmp_events.size());
            _proposedMetroIIEventList.clear();
            resultHandler.handleResult(tmp_events);
            for (            Builder etb : tmp_events) {
              if (etb.getStatus() == Event.Status.NOTIFIED) {
                String event_name=etb.getName();
                Object lock=_eventLock.get(_eventName2Id(event_name));
synchronized (lock) {
                  lock.notifyAll();
                  System.out.println(""String_Node_Str"" + event_name);
                }
              }
 else {
                _proposedMetroIIEventList.add(etb);
              }
            }
          }
        }
 catch (        InterruptedException e) {
          stop();
          return;
        }
 finally {
          if (outsideDirector != null) {
            ((ProcessDirector)outsideDirector).threadUnblocked(Thread.currentThread(),null);
          }
        }
      }
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      if (_areThreadsDeadlocked() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        try {
          _notDone=_resolveDeadlock();
        }
 catch (        IllegalActionException e) {
          stop();
          try {
            throw e;
          }
 catch (          IllegalActionException e1) {
            e1.printStackTrace();
          }
        }
      }
    }
  }
  finally {
    if (depth > 0) {
      workspace.reacquireReadPermission(depth);
    }
  }
}"
73065,"/** 
 * Dequeue the events that have the smallest tag from the event queue. Return their destination actor. Advance the model tag to their tag. If the timestamp of the smallest tag is greater than the stop time then return null. If there are no events in the event queue, and the stopWhenQueueIsEmpty parameter is set to true, then return null. Both cases will have the effect of stopping the simulation. <p> If the stopWhenQueueIsEmpty parameter is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are new events available.  If the synchronizeToRealTime parameter is true, then this method may suspend the calling thread by using Object.wait(long) to let elapsed real time catch up with the current model time.</p>
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  if (_eventQueue == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  Actor actorToFire=null;
  DEEvent lastFoundEvent=null;
  DEEvent nextEvent=null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
    }
    if (isEmbedded()) {
      if (_eventQueue.isEmpty()) {
        break;
      }
      nextEvent=_eventQueue.get();
      if ((nextEvent.timeStamp().compareTo(getModelTime()) < 0)) {
        throw new IllegalActionException(""String_Node_Str"" + nextEvent.timeStamp() + ""String_Node_Str""+ nextEvent.microstep()+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
      }
      boolean microstepMatches=true;
      Nameable container=getContainer();
      if (container instanceof CompositeActor) {
        Director executiveDirector=((CompositeActor)container).getExecutiveDirector();
        if (executiveDirector instanceof SuperdenseTimeDirector && !_isTopLevel()) {
          microstepMatches=nextEvent.microstep() <= _microstep;
        }
      }
      int comparison=nextEvent.timeStamp().compareTo(getModelTime());
      if (comparison > 0 || (comparison == 0 && !microstepMatches)) {
        nextEvent=null;
        break;
      }
    }
 else {
      if (_eventQueue.isEmpty()) {
        if ((actorToFire != null) || (getModelTime().equals(getModelStopTime()))) {
          break;
        }
      }
synchronized (_eventQueue) {
        while (_eventQueue.isEmpty() && !_stopRequested && !_stopFireRequested) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          try {
            workspace().wait(_eventQueue);
          }
 catch (          InterruptedException e) {
            break;
          }
        }
        if (_eventQueue.isEmpty()) {
          return null;
        }
        nextEvent=_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      Time currentTime;
      if (_synchronizeToRealTime) {
        int depth=0;
        try {
synchronized (_eventQueue) {
            while (!_stopRequested && !_stopFireRequested) {
              lastFoundEvent=_eventQueue.get();
              currentTime=lastFoundEvent.timeStamp();
              long elapsedTime=System.currentTimeMillis() - _realStartTime;
              double elapsedTimeInSeconds=elapsedTime / 1000.0;
              ptolemy.actor.util.Time elapsed=new ptolemy.actor.util.Time(this,elapsedTimeInSeconds);
              if (currentTime.compareTo(elapsed) <= 0) {
                break;
              }
              long timeToWait=(long)(currentTime.subtract(elapsed).getDoubleValue() * 1000.0);
              if (timeToWait > 0) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + timeToWait);
                }
                try {
                  depth=_workspace.releaseReadPermission();
                  _eventQueue.wait(timeToWait);
                }
 catch (                InterruptedException ex) {
                  throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
                }
              }
            }
            if (_stopRequested || _stopFireRequested) {
              return null;
            }
          }
        }
  finally {
          if (depth > 0) {
            _workspace.reacquireReadPermission(depth);
          }
        }
      }
synchronized (_eventQueue) {
        lastFoundEvent=_eventQueue.take();
        currentTime=lastFoundEvent.timeStamp();
        actorToFire=lastFoundEvent.actor();
        if ((_disabledActors != null) && _disabledActors.contains(actorToFire)) {
          if (_debugging) {
            _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          }
          actorToFire=null;
          continue;
        }
        setModelTime(currentTime);
        _microstep=lastFoundEvent.microstep();
        if (_debugging) {
          _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
      }
      if (currentTime.compareTo(getModelStopTime()) > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
    }
 else {
      if (nextEvent.hasTheSameTagAs(lastFoundEvent) && nextEvent.actor() == actorToFire) {
synchronized (_eventQueue) {
          _eventQueue.take();
        }
      }
 else {
        break;
      }
    }
  }
  if (!_schedule(actorToFire,getModelTime(),null)) {
    return null;
  }
  return actorToFire;
}","/** 
 * Dequeue the events that have the smallest tag from the event queue. Return their destination actor. Advance the model tag to their tag. If the timestamp of the smallest tag is greater than the stop time then return null. If there are no events in the event queue, and the stopWhenQueueIsEmpty parameter is set to true, then return null. Both cases will have the effect of stopping the simulation. <p> If the stopWhenQueueIsEmpty parameter is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are new events available.  If the synchronizeToRealTime parameter is true, then this method may suspend the calling thread by using Object.wait(long) to let elapsed real time catch up with the current model time.</p>
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  if (_eventQueue == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  Actor actorToFire=null;
  DEEvent lastFoundEvent=null;
  DEEvent nextEvent=null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
    }
    if (isEmbedded()) {
      if (_eventQueue.isEmpty()) {
        break;
      }
      nextEvent=_eventQueue.get();
      if ((nextEvent.timeStamp().compareTo(getModelTime()) < 0)) {
        throw new IllegalActionException(""String_Node_Str"" + nextEvent.timeStamp() + ""String_Node_Str""+ nextEvent.microstep()+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
      }
      boolean microstepMatches=true;
      Nameable container=getContainer();
      if (container instanceof CompositeActor) {
        Director executiveDirector=((CompositeActor)container).getExecutiveDirector();
        if (executiveDirector instanceof SuperdenseTimeDirector && !_isTopLevel()) {
          microstepMatches=nextEvent.microstep() <= _microstep;
        }
      }
      int comparison=nextEvent.timeStamp().compareTo(getModelTime());
      if (comparison > 0 || (comparison == 0 && !microstepMatches)) {
        nextEvent=null;
        break;
      }
    }
 else {
      if (_eventQueue.isEmpty()) {
        if ((actorToFire != null) || (getModelTime().equals(getModelStopTime()))) {
          break;
        }
      }
synchronized (_eventQueue) {
        while (_eventQueue.isEmpty() && !_stopRequested && !_stopFireRequested) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          try {
            workspace().wait(_eventQueue);
          }
 catch (          InterruptedException e) {
            break;
          }
        }
        if (_eventQueue.isEmpty()) {
          return null;
        }
        nextEvent=_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      Time currentTime;
      if (_synchronizeToRealTime) {
        int depth=0;
        try {
synchronized (_eventQueue) {
            while (!_stopRequested && !_stopFireRequested) {
              lastFoundEvent=_eventQueue.get();
              currentTime=lastFoundEvent.timeStamp();
              long elapsedTime=System.currentTimeMillis() - _realStartTime;
              double elapsedTimeInSeconds=elapsedTime / 1000.0;
              ptolemy.actor.util.Time elapsed=new ptolemy.actor.util.Time(this,elapsedTimeInSeconds);
              if (currentTime.compareTo(elapsed) <= 0) {
                break;
              }
              long timeToWait=(long)(currentTime.subtract(elapsed).getDoubleValue() * 1000.0);
              if (timeToWait > 0) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + timeToWait);
                }
                try {
                  depth=_workspace.releaseReadPermission();
                  _eventQueue.wait(timeToWait);
                }
 catch (                InterruptedException ex) {
                  throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
                }
              }
            }
            if (_stopRequested || _stopFireRequested) {
              return null;
            }
          }
        }
  finally {
          if (depth > 0) {
            _workspace.reacquireReadPermission(depth);
          }
        }
      }
synchronized (_eventQueue) {
        lastFoundEvent=_eventQueue.take();
        currentTime=lastFoundEvent.timeStamp();
        actorToFire=lastFoundEvent.actor();
        if ((_disabledActors != null) && _disabledActors.contains(actorToFire)) {
          if (_debugging) {
            _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          }
          actorToFire=null;
          continue;
        }
        setModelTime(currentTime);
        _microstep=lastFoundEvent.microstep();
        if (_debugging) {
          _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
      }
      if (currentTime.compareTo(getModelStopTime()) > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
    }
 else {
      if (nextEvent.hasTheSameTagAs(lastFoundEvent) && nextEvent.actor() == actorToFire) {
synchronized (_eventQueue) {
          _eventQueue.take();
        }
      }
 else {
        break;
      }
    }
  }
  if (actorToFire != null && !_schedule(actorToFire,getModelTime(),null)) {
    return null;
  }
  return actorToFire;
}"
73066,"/** 
 * Invoke the wrapup() of the super class.  Leave and quit OpenModelica environment. OMCProxy and OMCLogger objects are reset.
 * @exception IllegalActionException If the wrapup() ofOpenModelica actor throws it.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  try {
    _omcProxy.quit();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    _omcProxy=null;
    _omcLogger=null;
  }
 catch (  ConnectException ex) {
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new IllegalActionException(loggerInfo);
  }
}","/** 
 * Invoke the wrapup() of the super class.  Leave and quit OpenModelica environment.
 * @exception IllegalActionException If the wrapup() ofOpenModelica actor throws it.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  try {
    _omcProxy.quit();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
  }
 catch (  ConnectException ex) {
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new IllegalActionException(loggerInfo);
  }
}"
73067,"/** 
 * Invoke the preinitialize() of the super class.  Preinitialize the OpenModelica actor and initialize the OpenModelica Compiler(OMC).
 * @exception IllegalActionException If the preinitialize() ofone of the associated actors throws it.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  try {
    String omcResultFilePath=null;
    String temp=System.getProperty(""String_Node_Str"");
    String username=System.getenv(""String_Node_Str"");
    if (username == null)     omcResultFilePath=temp + ""String_Node_Str"";
 else     omcResultFilePath=temp + ""String_Node_Str"" + username+ ""String_Node_Str"";
    File userFile=new File(omcResultFilePath);
    if (!userFile.exists())     new File(omcResultFilePath).mkdirs();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    _omcProxy.initServer();
  }
 catch (  ConnectException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
}","/** 
 * Invoke the preinitialize() of the super class.  Preinitialize the OpenModelica actor and initialize the OpenModelica Compiler(OMC).
 * @exception IllegalActionException If the preinitialize() ofone of the associated actors throws it.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  try {
    String omcResultFilePath=null;
    String temp=System.getProperty(""String_Node_Str"");
    String username=System.getenv(""String_Node_Str"");
    if (username == null)     omcResultFilePath=temp + ""String_Node_Str"";
 else     omcResultFilePath=temp + ""String_Node_Str"" + username+ ""String_Node_Str"";
    File userFile=new File(omcResultFilePath);
    if (!userFile.exists())     new File(omcResultFilePath).mkdirs();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    _omcLogger=OMCLogger.getInstance();
    _omcProxy=OMCProxy.getInstance();
    _omcProxy.initServer();
  }
 catch (  ConnectException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
}"
73068,"/** 
 * Evaluate the expression and send its result to the output.
 * @exception IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  if (director == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  try {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    _simulate();
    _plot();
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(this,throwable,""String_Node_Str"");
  }
}","/** 
 * Evaluate the expression and send its result to the output.
 * @exception IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  if (director == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  try {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    _omcProxy=OMCProxy.getInstance();
    _omcLogger=OMCLogger.getInstance();
    _simulate();
    _plot();
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(this,throwable,""String_Node_Str"");
  }
}"
73069,"/** 
 * Construct an OpenModelica Compiler(OMC) proxy. This constructor has no parameter.  This private Constructor prevents other class from instantiating. 
 */
private OMCProxy(){
}","/** 
 * Construct an OpenModelica Compiler(OMC) proxy. This constructor has no parameter.  This private Constructor prevents other class from instantiating. 
 */
private OMCProxy(){
  _omcLogger=OMCLogger.getInstance();
}"
73070,"public void run(){
  File tmp[]=null;
  try {
    tmp=_getOmcBinaryPaths();
  }
 catch (  ConnectException e) {
    _omcLoggerInstance.getSever(""String_Node_Str"");
    _couldNotStartOMC=true;
    hasInitialized=false;
    return;
  }
  File omcBinary=tmp[0];
  final File workingDirectory=tmp[1];
  Process proc=null;
  String command[]={omcBinary.getAbsolutePath(),""String_Node_Str"" + _corbaSession,""String_Node_Str""};
  ArrayList<String> both=new ArrayList<String>(command.length);
  Collections.addAll(both,command);
  String cmd[]=new String[both.size()];
  int nonNull=0;
  for (int i=0; i < both.size(); i++) {
    String str=both.get(i);
    if (str != null) {
      cmd[nonNull]=str;
      nonNull++;
    }
  }
  StringBuffer bufferCMD=new StringBuffer();
  for (int i=0; i < nonNull; i++) {
    bufferCMD.append(cmd[i] + ""String_Node_Str"");
  }
  String fullCMD=bufferCMD.toString();
  String loggerInfo=""String_Node_Str"" + fullCMD;
  _omcLoggerInstance.getInfo(loggerInfo);
  loggerInfo=""String_Node_Str"" + workingDirectory.getAbsolutePath();
  _omcLoggerInstance.getInfo(loggerInfo);
  try {
    if (System.getenv(""String_Node_Str"") == null) {
      Map<String,String> environmentalVariablesMap=System.getenv();
      Set<Entry<String,String>> entrySet=environmentalVariablesMap.entrySet();
      Collection<String> lst=new ArrayList<String>();
      String x=""String_Node_Str"" + omcBinary.getParentFile().getParentFile().getAbsolutePath();
      lst.add(x);
      if (System.getenv(""String_Node_Str"") == null) {
        String y=""String_Node_Str"" + omcBinary.getParentFile().getParentFile().getAbsolutePath() + ""String_Node_Str"";
        lst.add(y);
      }
      Iterator<Entry<String,String>> i=entrySet.iterator();
      while (i.hasNext()) {
        Entry<String,String> z=i.next();
        lst.add(z.getKey() + ""String_Node_Str"" + z.getValue());
      }
      environmentalVariables=lst.toArray(new String[lst.size()]);
    }
    proc=Runtime.getRuntime().exec(cmd,environmentalVariables,workingDirectory);
    workDir=workingDirectory;
  }
 catch (  IOException e) {
    loggerInfo=""String_Node_Str"" + fullCMD;
    _omcLoggerInstance.getInfo(loggerInfo);
    _couldNotStartOMC=true;
    hasInitialized=false;
    return;
  }
  loggerInfo=""String_Node_Str"";
  _omcLoggerInstance.getInfo(loggerInfo);
  loggerInfo=""String_Node_Str"";
  _omcLoggerInstance.getInfo(loggerInfo);
  loggerInfo=""String_Node_Str"";
  _omcLoggerInstance.getInfo(loggerInfo);
  try {
    proc.waitFor();
  }
 catch (  InterruptedException e) {
    String loggerSever=""String_Node_Str"" + e.getMessage() + (proc == null ? ""String_Node_Str"" : ""String_Node_Str"" + proc.exitValue());
    _omcLoggerInstance.getSever(loggerSever);
    hasInitialized=false;
    return;
  }
  if (proc != null) {
    if (_omcLoggerInstance != null) {
      loggerInfo=""String_Node_Str"" + proc.exitValue();
      _omcLoggerInstance.getInfo(loggerInfo);
    }
 else {
      new Exception(""String_Node_Str"" + proc.exitValue());
    }
  }
  hasInitialized=false;
}","public void run(){
  File tmp[]=null;
  try {
    tmp=_getOmcBinaryPaths();
  }
 catch (  ConnectException e) {
    _omcLogger.getSever(""String_Node_Str"");
    _couldNotStartOMC=true;
    hasInitialized=false;
    return;
  }
  File omcBinary=tmp[0];
  final File workingDirectory=tmp[1];
  Process proc=null;
  String command[]={omcBinary.getAbsolutePath(),""String_Node_Str"" + _corbaSession,""String_Node_Str""};
  ArrayList<String> both=new ArrayList<String>(command.length);
  Collections.addAll(both,command);
  String cmd[]=new String[both.size()];
  int nonNull=0;
  for (int i=0; i < both.size(); i++) {
    String str=both.get(i);
    if (str != null) {
      cmd[nonNull]=str;
      nonNull++;
    }
  }
  StringBuffer bufferCMD=new StringBuffer();
  for (int i=0; i < nonNull; i++) {
    bufferCMD.append(cmd[i] + ""String_Node_Str"");
  }
  String fullCMD=bufferCMD.toString();
  String loggerInfo=""String_Node_Str"" + fullCMD;
  _omcLogger.getInfo(loggerInfo);
  loggerInfo=""String_Node_Str"" + workingDirectory.getAbsolutePath();
  _omcLogger.getInfo(loggerInfo);
  try {
    if (System.getenv(""String_Node_Str"") == null) {
      Map<String,String> environmentalVariablesMap=System.getenv();
      Set<Entry<String,String>> entrySet=environmentalVariablesMap.entrySet();
      Collection<String> lst=new ArrayList<String>();
      String x=""String_Node_Str"" + omcBinary.getParentFile().getParentFile().getAbsolutePath();
      lst.add(x);
      if (System.getenv(""String_Node_Str"") == null) {
        String y=""String_Node_Str"" + omcBinary.getParentFile().getParentFile().getAbsolutePath() + ""String_Node_Str"";
        lst.add(y);
      }
      Iterator<Entry<String,String>> i=entrySet.iterator();
      while (i.hasNext()) {
        Entry<String,String> z=i.next();
        lst.add(z.getKey() + ""String_Node_Str"" + z.getValue());
      }
      environmentalVariables=lst.toArray(new String[lst.size()]);
    }
    proc=Runtime.getRuntime().exec(cmd,environmentalVariables,workingDirectory);
    workDir=workingDirectory;
  }
 catch (  IOException e) {
    loggerInfo=""String_Node_Str"" + fullCMD;
    _omcLogger.getInfo(loggerInfo);
    _couldNotStartOMC=true;
    hasInitialized=false;
    return;
  }
  loggerInfo=""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  loggerInfo=""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  loggerInfo=""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  try {
    proc.waitFor();
  }
 catch (  InterruptedException e) {
    String loggerSever=""String_Node_Str"" + e.getMessage() + (proc == null ? ""String_Node_Str"" : ""String_Node_Str"" + proc.exitValue());
    _omcLogger.getSever(loggerSever);
    hasInitialized=false;
    return;
  }
  if (proc != null) {
    if (_omcLogger != null) {
      loggerInfo=""String_Node_Str"" + proc.exitValue();
      _omcLogger.getInfo(loggerInfo);
    }
 else {
      new Exception(""String_Node_Str"" + proc.exitValue());
    }
  }
  hasInitialized=false;
}"
73071,"/** 
 * Initialize the communication with the OpenModelica compiler(OMC).
 * @exception ConnectException If we're unable to start communicating withthe server.
 * @throws InterruptedException 
 */
public synchronized void initServer() throws ConnectException {
  _os=getOs();
  String strDate=""String_Node_Str"";
  Date date=new Date();
  SimpleDateFormat timeFormat=new SimpleDateFormat(""String_Node_Str"");
  strDate=timeFormat.format(date);
  _corbaSession=strDate;
  File f=new File(_getPathToObject());
  String stringifiedObjectReference=null;
  if (!f.exists()) {
    String loggerInfo=""String_Node_Str"";
    _omcLoggerInstance.getInfo(loggerInfo);
    _startServer();
  }
 else {
    String loggerInfo=""String_Node_Str"";
    _omcLoggerInstance.getInfo(loggerInfo);
  }
  stringifiedObjectReference=_readObjectFromFile();
  _setupOmcc(stringifiedObjectReference);
  hasInitialized=true;
}","/** 
 * Initialize the communication with the OpenModelica compiler(OMC).
 * @exception ConnectException If we're unable to start communicating withthe server.
 * @throws InterruptedException 
 */
public synchronized void initServer() throws ConnectException {
  _os=getOs();
  String strDate=""String_Node_Str"";
  Date date=new Date();
  SimpleDateFormat timeFormat=new SimpleDateFormat(""String_Node_Str"");
  strDate=timeFormat.format(date);
  _corbaSession=strDate;
  File f=new File(_getPathToObject());
  String stringifiedObjectReference=null;
  if (!f.exists()) {
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    _startServer();
  }
 else {
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  stringifiedObjectReference=_readObjectFromFile();
  _setupOmcc(stringifiedObjectReference);
  hasInitialized=true;
}"
73072,"/** 
 * Return the path to the OMC CORBA object that is stored on a disk.
 */
private String _getPathToObject(){
  String fileName=null;
  String username=System.getenv(""String_Node_Str"");
  String temp=System.getProperty(""String_Node_Str"");
switch (OMCProxy.getOs()) {
case UNIX:
    if (username == null) {
      username=""String_Node_Str"";
    }
  if (_corbaSession == null || _corbaSession.equalsIgnoreCase(""String_Node_Str"")) {
    fileName=temp + ""String_Node_Str"" + username+ ""String_Node_Str"";
  }
 else {
    fileName=temp + ""String_Node_Str"" + username+ ""String_Node_Str""+ ""String_Node_Str""+ _corbaSession;
  }
break;
case WINDOWS:
if (_corbaSession == null || _corbaSession.equalsIgnoreCase(""String_Node_Str"")) {
fileName=temp + ""String_Node_Str"";
}
 else {
fileName=temp + ""String_Node_Str"" + ""String_Node_Str""+ _corbaSession;
}
break;
case MAC:
String macUsername=System.getenv(""String_Node_Str"");
if (macUsername == null) {
macUsername=""String_Node_Str"";
}
if (_corbaSession == null || _corbaSession.equalsIgnoreCase(""String_Node_Str"")) {
fileName=temp + ""String_Node_Str"" + macUsername+ ""String_Node_Str"";
}
 else {
fileName=temp + ""String_Node_Str"" + macUsername+ ""String_Node_Str""+ ""String_Node_Str""+ _corbaSession;
}
break;
}
String loggerInfo=""String_Node_Str"" + fileName + ""String_Node_Str"";
_omcLoggerInstance.getInfo(loggerInfo);
return fileName;
}","/** 
 * Return the path to the OMC CORBA object that is stored on a disk.
 */
private String _getPathToObject(){
  String fileName=null;
  String username=System.getenv(""String_Node_Str"");
  String temp=System.getProperty(""String_Node_Str"");
switch (OMCProxy.getOs()) {
case UNIX:
    if (username == null) {
      username=""String_Node_Str"";
    }
  if (_corbaSession == null || _corbaSession.equalsIgnoreCase(""String_Node_Str"")) {
    fileName=temp + ""String_Node_Str"" + username+ ""String_Node_Str"";
  }
 else {
    fileName=temp + ""String_Node_Str"" + username+ ""String_Node_Str""+ ""String_Node_Str""+ _corbaSession;
  }
break;
case WINDOWS:
if (_corbaSession == null || _corbaSession.equalsIgnoreCase(""String_Node_Str"")) {
fileName=temp + ""String_Node_Str"";
}
 else {
fileName=temp + ""String_Node_Str"" + ""String_Node_Str""+ _corbaSession;
}
break;
case MAC:
String macUsername=System.getenv(""String_Node_Str"");
if (macUsername == null) {
macUsername=""String_Node_Str"";
}
if (_corbaSession == null || _corbaSession.equalsIgnoreCase(""String_Node_Str"")) {
fileName=temp + ""String_Node_Str"" + macUsername+ ""String_Node_Str"";
}
 else {
fileName=temp + ""String_Node_Str"" + macUsername+ ""String_Node_Str""+ ""String_Node_Str""+ _corbaSession;
}
break;
}
String loggerInfo=""String_Node_Str"" + fileName + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
return fileName;
}"
73073,"/** 
 * Determine the path to the omc binary that user (probably) wants to use and the working directory of where that binary (most likely) should be started in. This will returns for example 'c:\openmodelica132\omc.exe' or '/usr/local/share/openmodelica/omc' depending on such factors as: OS type, environmental Variables settings, where the first matching binary found.
 * @return full path to the omc binary and the working folder.
 * @exception ConnectException If OPENMODELICAHOME is not set and we could not find binary file in the path.
 */
private File[] _getOmcBinaryPaths() throws ConnectException {
  String binaryName=""String_Node_Str"";
  if (_os == osType.WINDOWS) {
    binaryName+=""String_Node_Str"";
  }
  File omcBinary=null;
  File omcWorkingDirectory=null;
  File openModelicaHomeDirectory=null;
  String loggerInfo=""String_Node_Str"";
  _omcLoggerInstance.getInfo(loggerInfo);
  String openModelicaHome=System.getenv(""String_Node_Str"");
  if (openModelicaHome == null) {
    loggerInfo=""String_Node_Str"";
    _omcLoggerInstance.getInfo(loggerInfo);
    File omc=_findExecutableOnPath(binaryName);
    if (omc != null) {
      loggerInfo=""String_Node_Str"" + omc.getAbsolutePath();
      _omcLoggerInstance.getInfo(loggerInfo);
      openModelicaHome=omc.getParentFile().getParentFile().getAbsolutePath();
    }
 else {
      final String m=""String_Node_Str"" + binaryName + ""String_Node_Str"";
      _omcLoggerInstance.getInfo(m);
      throw new ConnectException(m);
    }
  }
  openModelicaHomeDirectory=new File(openModelicaHome);
  String[] subdirs={""String_Node_Str""};
  for (  String subdir : subdirs) {
    String path=openModelicaHomeDirectory.getAbsolutePath() + File.separator;
    path+=subdir.equals(""String_Node_Str"") ? binaryName : subdir + File.separator + binaryName;
    File file=new File(path);
    if (file.exists()) {
      omcBinary=file;
      loggerInfo=""String_Node_Str"" + omcBinary.getAbsolutePath() + ""String_Node_Str"";
      _omcLoggerInstance.getInfo(loggerInfo);
      break;
    }
 else {
      loggerInfo=""String_Node_Str"" + path + ""String_Node_Str"";
      _omcLoggerInstance.getInfo(loggerInfo);
    }
  }
  if (omcBinary == null) {
    loggerInfo=""String_Node_Str"";
    _omcLoggerInstance.getInfo(loggerInfo);
    throw new ConnectException(loggerInfo);
  }
  if (System.getenv(""String_Node_Str"") == null)   omcWorkingDirectory=new File(System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
 else   omcWorkingDirectory=new File(System.getProperty(""String_Node_Str"") + ""String_Node_Str"" + System.getenv(""String_Node_Str"")+ ""String_Node_Str"");
  String workingDirectory=""String_Node_Str"" + omcWorkingDirectory.getAbsolutePath() + ""String_Node_Str"";
  loggerInfo=workingDirectory;
  _omcLoggerInstance.getInfo(loggerInfo);
  System.out.println(""String_Node_Str"" + omcWorkingDirectory);
  return new File[]{omcBinary,omcWorkingDirectory};
}","/** 
 * Determine the path to the omc binary that user (probably) wants to use and the working directory of where that binary (most likely) should be started in. This will returns for example 'c:\openmodelica132\omc.exe' or '/usr/local/share/openmodelica/omc' depending on such factors as: OS type, environmental Variables settings, where the first matching binary found.
 * @return full path to the omc binary and the working folder.
 * @exception ConnectException If OPENMODELICAHOME is not set and we could not find binary file in the path.
 */
private File[] _getOmcBinaryPaths() throws ConnectException {
  String binaryName=""String_Node_Str"";
  if (_os == osType.WINDOWS) {
    binaryName+=""String_Node_Str"";
  }
  File omcBinary=null;
  File omcWorkingDirectory=null;
  File openModelicaHomeDirectory=null;
  String loggerInfo=""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  String openModelicaHome=System.getenv(""String_Node_Str"");
  if (openModelicaHome == null) {
    loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    File omc=_findExecutableOnPath(binaryName);
    if (omc != null) {
      loggerInfo=""String_Node_Str"" + omc.getAbsolutePath();
      _omcLogger.getInfo(loggerInfo);
      openModelicaHome=omc.getParentFile().getParentFile().getAbsolutePath();
    }
 else {
      final String m=""String_Node_Str"" + binaryName + ""String_Node_Str"";
      _omcLogger.getInfo(m);
      throw new ConnectException(m);
    }
  }
  openModelicaHomeDirectory=new File(openModelicaHome);
  String[] subdirs={""String_Node_Str""};
  for (  String subdir : subdirs) {
    String path=openModelicaHomeDirectory.getAbsolutePath() + File.separator;
    path+=subdir.equals(""String_Node_Str"") ? binaryName : subdir + File.separator + binaryName;
    File file=new File(path);
    if (file.exists()) {
      omcBinary=file;
      loggerInfo=""String_Node_Str"" + omcBinary.getAbsolutePath() + ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      break;
    }
 else {
      loggerInfo=""String_Node_Str"" + path + ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
  }
  if (omcBinary == null) {
    loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new ConnectException(loggerInfo);
  }
  if (System.getenv(""String_Node_Str"") == null)   omcWorkingDirectory=new File(System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
 else   omcWorkingDirectory=new File(System.getProperty(""String_Node_Str"") + ""String_Node_Str"" + System.getenv(""String_Node_Str"")+ ""String_Node_Str"");
  String workingDirectory=""String_Node_Str"" + omcWorkingDirectory.getAbsolutePath() + ""String_Node_Str"";
  loggerInfo=workingDirectory;
  _omcLogger.getInfo(loggerInfo);
  System.out.println(""String_Node_Str"" + omcWorkingDirectory);
  return new File[]{omcBinary,omcWorkingDirectory};
}"
73074,"/** 
 * Leave and quit OpenModelica environment.
 * @exception ConnectException If quit command couldn'tbe sent to OMC.
 */
public void quit() throws ConnectException {
  if (hasInitialized=true) {
    sendCommand(""String_Node_Str"");
  }
}","/** 
 * Leave and quit OpenModelica environment. Deallocate OMCProxy and OMCLogger objects.
 * @exception ConnectException If quit command couldn'tbe sent to OMC.
 */
public void quit() throws ConnectException {
  if (hasInitialized=true) {
    sendCommand(""String_Node_Str"");
    _omcProxyInstance=null;
    _omcLogger=null;
  }
}"
73075,"/** 
 * Create an instance of OMCProxy in order to provide a global point of access to this instance. It provides a unique source of OMCProxy instance.
 */
public static OMCProxy getInstance(){
  if (_omcProxyInstance == null) {
    _omcProxyInstance=new OMCProxy();
  }
  return _omcProxyInstance;
}","/** 
 * Create an instance of OMCProxy object in order to provide a global point of access to the instance. It provides a unique source of OMCProxy instance.
 */
public static OMCProxy getInstance(){
  if (_omcProxyInstance == null) {
    _omcProxyInstance=new OMCProxy();
  }
  return _omcProxyInstance;
}"
73076,"/** 
 * Invoke the wrapup() of the super class.  Leave and quit OpenModelica environment.
 * @exception IllegalActionException If the wrapup() ofOpenModelica actor throws it.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  try {
    _omcCommand=OMCCommand.getInstance();
    _omcCommand.quitServer();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
  }
 catch (  ConnectException ex) {
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new IllegalActionException(loggerInfo);
  }
}","/** 
 * Invoke the wrapup() of the super class.  Leave and quit OpenModelica environment.
 * @exception IllegalActionException If the wrapup() ofOpenModelica actor throws it.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  try {
    _omcProxy.quitServer();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
  }
 catch (  ConnectException ex) {
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new IllegalActionException(loggerInfo);
  }
}"
73077,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  OpenModelicaDirector newObject=(OpenModelicaDirector)super.clone(workspace);
  try {
    newObject._omcCommand=OMCCommand.getInstance();
    newObject._omcLogger=OMCLogger.getInstance();
    newObject._omcProxy=OMCProxy.getInstance();
  }
 catch (  Throwable throwable) {
    throw new CloneNotSupportedException(""String_Node_Str"" + getFullName() + ""String_Node_Str""+ throwable);
  }
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  OpenModelicaDirector newObject=(OpenModelicaDirector)super.clone(workspace);
  try {
    newObject._omcLogger=OMCLogger.getInstance();
    newObject._omcProxy=OMCProxy.getInstance();
  }
 catch (  Throwable throwable) {
    throw new CloneNotSupportedException(""String_Node_Str"" + getFullName() + ""String_Node_Str""+ throwable);
  }
  return newObject;
}"
73078,"/** 
 * Load the model from the file in the first step. Then, build the model. Finally, run the simulation executable result of buildModel() in order to generate the simulation result.
 * @param fileName File which the model should be loaded from.
 * @param modelicaScript Modelica command.
 * @param modelName Name of the model which should be built.
 * @param fileNamePrefix User preferable name for the result file.
 * @param startTime The start time of simulation.
 * @param stopTime The stop time of simulation.
 * @param numberOfIntervals Number of intervals in the result file.
 * @param tolerance Tolerance used by the integration method.
 * @param method Integration method used for simulation.
 * @param outputFormat Format of the result file.
 * @param variableFilter Filter for variables that should be stored in the result file.
 * @param cflags Any standard C language flags.
 * @param simflags Simulation flags.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @throws IOException If the executable result of buildModel()couldn't be executed.
 * @throws IllegalActionException 
 */
public void simulateModel(String fileName,String modelicaScript,String modelName,String fileNamePrefix,String startTime,String stopTime,int numberOfIntervals,String tolerance,String method,String outputFormat,String variableFilter,String cflags,String simflags) throws ConnectException, IOException, IllegalActionException {
  String commands=null;
  String systemPath=StringUtilities.getProperty(""String_Node_Str"");
  String testFilePath=null;
  testFilePath=systemPath + ""String_Node_Str"" + fileName;
  File file=new File(testFilePath);
  if (file.exists()) {
    if (_omcLogger == null) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    String loggerInfo=""String_Node_Str"" + testFilePath + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    _omcCommand=OMCCommand.getInstance();
    _result=_omcCommand.loadFile(testFilePath);
    if (_result.getFirstResult().compareTo(""String_Node_Str"") != 0 && _result.getError().compareTo(""String_Node_Str"") == 0) {
      loggerInfo=""String_Node_Str"" + modelicaScript + ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
    if (_result.getError().compareTo(""String_Node_Str"") != 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
    _omcCommand=OMCCommand.getInstance();
    _result=_omcCommand.loadModelicaModel(modelicaScript);
    if (_result.getFirstResult().compareTo(""String_Node_Str"") == 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
    if (_result.getError().compareTo(""String_Node_Str"") != 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
    if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
      commands=modelName + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ Float.valueOf(tolerance).floatValue()+ ""String_Node_Str""+ method+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ variableFilter+ ""String_Node_Str""+ cflags+ ""String_Node_Str""+ simflags+ ""String_Node_Str"";
    }
 else {
      commands=modelName + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ Float.valueOf(tolerance).floatValue()+ ""String_Node_Str""+ method+ ""String_Node_Str""+ fileNamePrefix+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ variableFilter+ ""String_Node_Str""+ cflags+ ""String_Node_Str""+ simflags+ ""String_Node_Str"";
    }
    _omcCommand=OMCCommand.getInstance();
    _result=_omcCommand.buildModel(commands);
    if (_result.getFirstResult().compareTo(""String_Node_Str"") != 0 && _result.getError().compareTo(""String_Node_Str"") == 0) {
      loggerInfo=modelName + ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
    if (_result.getError().compareTo(""String_Node_Str"") != 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
    String command=null;
switch (OMCProxy.getOs()) {
case WINDOWS:
      command=OMCProxy.workDir.getPath() + ""String_Node_Str"" + modelName+ ""String_Node_Str"";
    break;
case UNIX:
  command=OMCProxy.workDir.getPath() + ""String_Node_Str"" + modelName;
break;
case MAC:
command=OMCProxy.workDir.getPath() + ""String_Node_Str"" + modelName;
break;
}
Runtime.getRuntime().exec(command,OMCProxy.environmentalVariables,OMCProxy.workDir);
if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
 else {
loggerInfo=""String_Node_Str"" + fileNamePrefix + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
}
 else {
String loggerInfo=""String_Node_Str"" + testFilePath + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
throw new ConnectException(""String_Node_Str"" + testFilePath + ""String_Node_Str"");
}
}","/** 
 * Load the model from the file in the first step. Then, build the model. Finally, run the simulation executable result of buildModel() in order to generate the simulation result.
 * @param fileName File which the model should be loaded from.
 * @param modelicaScript Modelica command.
 * @param modelName Name of the model which should be built.
 * @param fileNamePrefix User preferable name for the result file.
 * @param startTime The start time of simulation.
 * @param stopTime The stop time of simulation.
 * @param numberOfIntervals Number of intervals in the result file.
 * @param tolerance Tolerance used by the integration method.
 * @param method Integration method used for simulation.
 * @param outputFormat Format of the result file.
 * @param variableFilter Filter for variables that should be stored in the result file.
 * @param cflags Any standard C language flags.
 * @param simflags Simulation flags.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @throws IOException If the executable result of buildModel()couldn't be executed.
 * @throws IllegalActionException 
 */
public void simulateModel(String fileName,String modelicaScript,String modelName,String fileNamePrefix,String startTime,String stopTime,int numberOfIntervals,String tolerance,String method,String outputFormat,String variableFilter,String cflags,String simflags) throws ConnectException, IOException, IllegalActionException {
  String commands=null;
  String systemPath=StringUtilities.getProperty(""String_Node_Str"");
  String testFilePath=null;
  testFilePath=systemPath + ""String_Node_Str"" + fileName;
  File file=new File(testFilePath);
  if (file.exists()) {
    if (_omcLogger == null) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    String loggerInfo=""String_Node_Str"" + testFilePath + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    _omcCommand=OMCCommand.getInstance();
    _result=_omcCommand.loadFile(testFilePath);
    if (_result.getFirstResult().compareTo(""String_Node_Str"") != 0 && _result.getError().compareTo(""String_Node_Str"") == 0) {
      loggerInfo=""String_Node_Str"" + modelicaScript + ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
    if (_result.getError().compareTo(""String_Node_Str"") != 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
    _result=_omcCommand.loadModelicaModel(modelicaScript);
    if (_result.getFirstResult().compareTo(""String_Node_Str"") == 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
    if (_result.getError().compareTo(""String_Node_Str"") != 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
    if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
      commands=modelName + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ Float.valueOf(tolerance).floatValue()+ ""String_Node_Str""+ method+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ variableFilter+ ""String_Node_Str""+ cflags+ ""String_Node_Str""+ simflags+ ""String_Node_Str"";
    }
 else {
      commands=modelName + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ Float.valueOf(tolerance).floatValue()+ ""String_Node_Str""+ method+ ""String_Node_Str""+ fileNamePrefix+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ variableFilter+ ""String_Node_Str""+ cflags+ ""String_Node_Str""+ simflags+ ""String_Node_Str"";
    }
    _result=_omcCommand.buildModel(commands);
    if (_result.getFirstResult().compareTo(""String_Node_Str"") != 0 && _result.getError().compareTo(""String_Node_Str"") == 0) {
      loggerInfo=modelName + ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
    if (_result.getError().compareTo(""String_Node_Str"") != 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
    String command=null;
switch (OMCProxy.getOs()) {
case WINDOWS:
      command=OMCProxy.workDir.getPath() + ""String_Node_Str"" + modelName+ ""String_Node_Str"";
    break;
case UNIX:
  command=OMCProxy.workDir.getPath() + ""String_Node_Str"" + modelName;
break;
case MAC:
command=OMCProxy.workDir.getPath() + ""String_Node_Str"" + modelName;
break;
}
Runtime.getRuntime().exec(command,OMCProxy.environmentalVariables,OMCProxy.workDir);
if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
 else {
loggerInfo=""String_Node_Str"" + fileNamePrefix + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
}
 else {
String loggerInfo=""String_Node_Str"" + testFilePath + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
throw new ConnectException(""String_Node_Str"" + testFilePath + ""String_Node_Str"");
}
}"
73079,"/** 
 * Add a type constraint for backward type inference that forces the input to be an array of which the elements have a type greater than or equal to the output port. If the <i>enforceArrayLength</i> parameter is set to true, the input is also forced to have a length equal to the <i>arrayLength</i> parameter. If backward type inference is disabled, this method returns an empty set.
 * @see ArrayOfTypesFunction
 * @return A set of inequalities.
 */
@Override protected Set<Inequality> _customTypeConstraints(){
  Set<Inequality> result=new HashSet<Inequality>();
  if (isBackwardTypeInferenceEnabled()) {
    boolean enforceLength=false;
    int length=1;
    try {
      enforceLength=((BooleanToken)enforceArrayLength.getToken()).booleanValue();
      length=((IntToken)arrayLength.getToken()).intValue();
    }
 catch (    IllegalActionException e) {
      e.printStackTrace();
    }
    if (enforceLength) {
      result.add(new Inequality(new ArrayOfTypesFunction(output,length),input.getTypeTerm()));
    }
 else {
      result.add(new Inequality(new ArrayOfTypesFunction(output),input.getTypeTerm()));
    }
  }
  return result;
}","/** 
 * Add a type constraint for backward type inference that forces the input to be an array of which the elements have a type greater than or equal to the output port. If the <i>enforceArrayLength</i> parameter is set to true, the input is also forced to have a length equal to the <i>arrayLength</i> parameter. If backward type inference is disabled, this method returns an empty set.
 * @see ArrayOfTypesFunction
 * @return A set of inequalities.
 */
@Override protected Set<Inequality> _customTypeConstraints(){
  Set<Inequality> result=new HashSet<Inequality>();
  if (isBackwardTypeInferenceEnabled()) {
    boolean enforceLength=false;
    int length=1;
    try {
      if (((BooleanToken)enforceArrayLength.getToken()).booleanValue()) {
        result.add(new Inequality(new ArrayOfTypesFunction(output,((IntToken)arrayLength.getToken()).intValue()),input.getTypeTerm()));
      }
 else {
        result.add(new Inequality(new ArrayOfTypesFunction(output),input.getTypeTerm()));
      }
    }
 catch (    IllegalActionException e) {
      e.printStackTrace();
    }
  }
  return result;
}"
73080,"/** 
 * Construct a RecordAssembler with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If this actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public RecordAssembler(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Construct a RecordAssembler with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If this actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public RecordAssembler(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  _inputs=new LinkedList<TypedIOPort>();
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}"
73081,"/** 
 * Generate a list of all connected input ports. 
 */
@Override public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  _inputs=new LinkedList<TypedIOPort>();
  for (  TypedIOPort port : inputPortList()) {
    if (port.numberOfSources() > 0) {
      _inputs.add(port);
    }
  }
}","/** 
 * Generate a list of all connected input ports. 
 */
@Override public void preinitialize() throws IllegalActionException {
  _inputs=new LinkedList<TypedIOPort>();
  for (  TypedIOPort port : inputPortList()) {
    if (port.numberOfSources() > 0) {
      _inputs.add(port);
    }
  }
  super.preinitialize();
}"
73082,"@Override public boolean hasTheSameTagAs(DEEvent event){
  Actor actor=event.actor();
  if (actor == null) {
    actor=(Actor)event.ioPort().getContainer();
  }
  Double timePrecision=null;
  try {
    timePrecision=PtidesDirector._getDoubleParameterValue((NamedObj)actor,""String_Node_Str"");
  }
 catch (  IllegalActionException e) {
  }
  if (timePrecision == null) {
    timePrecision=0.0;
  }
  return (_timestamp.subtract(timePrecision).compareTo(event.timeStamp()) <= 0 && _timestamp.add(timePrecision).compareTo(event.timeStamp()) >= 0 && (_microstep == event.microstep()));
}","@Override public boolean hasTheSameTagAs(DEEvent event){
  Actor actor=event.actor();
  if (actor == null) {
    actor=(Actor)event.ioPort().getContainer();
  }
  Double timePrecision=null;
  try {
    timePrecision=PtidesDirector._getDoubleParameterValue((NamedObj)actor,""String_Node_Str"");
  }
 catch (  IllegalActionException e) {
  }
  if (timePrecision == null) {
    timePrecision=0.0;
  }
  return ((_timestamp.compareTo(event.timeStamp()) == 0 && _microstep == event.microstep()) || _timestamp.compareTo(event.timeStamp()) <= 0 || (_timestamp.subtract(timePrecision).compareTo(event.timeStamp()) <= 0 && _timestamp.add(timePrecision).compareTo(event.timeStamp()) >= 0));
}"
73083,"/** 
 * Add a type constraint for backward type inference that forces the input to be an array of which the elements have a type greater than or equal to the output port. If the <i>enforceArrayLength</i> parameter is set to true, the input is also forced to have a length equal to the <i>arrayLength</i> parameter. If backward type inference is disabled, this method returns an empty set.
 * @see ArrayOfTypesFunction
 * @return A set of inequalities.
 */
@Override protected Set<Inequality> _customTypeConstraints(){
  Set<Inequality> result=new HashSet<Inequality>();
  if (isBackwardTypeInferenceEnabled()) {
    boolean enforceLength=false;
    int length=1;
    try {
      enforceLength=((BooleanToken)enforceArrayLength.getToken()).booleanValue();
      length=((IntToken)arrayLength.getToken()).intValue();
    }
 catch (    IllegalActionException e) {
      e.printStackTrace();
    }
    if (enforceLength) {
      result.add(new Inequality(input.getTypeTerm(),new ArrayOfTypesFunction(output,length)));
    }
 else {
      result.add(new Inequality(input.getTypeTerm(),new ArrayOfTypesFunction(output)));
    }
  }
  return result;
}","/** 
 * Add a type constraint for backward type inference that forces the input to be an array of which the elements have a type greater than or equal to the output port. If the <i>enforceArrayLength</i> parameter is set to true, the input is also forced to have a length equal to the <i>arrayLength</i> parameter. If backward type inference is disabled, this method returns an empty set.
 * @see ArrayOfTypesFunction
 * @return A set of inequalities.
 */
@Override protected Set<Inequality> _customTypeConstraints(){
  Set<Inequality> result=new HashSet<Inequality>();
  if (isBackwardTypeInferenceEnabled()) {
    boolean enforceLength=false;
    int length=1;
    try {
      enforceLength=((BooleanToken)enforceArrayLength.getToken()).booleanValue();
      length=((IntToken)arrayLength.getToken()).intValue();
    }
 catch (    IllegalActionException e) {
      e.printStackTrace();
    }
    if (enforceLength) {
      result.add(new Inequality(new ArrayOfTypesFunction(output,length),input.getTypeTerm()));
    }
 else {
      result.add(new Inequality(new ArrayOfTypesFunction(output),input.getTypeTerm()));
    }
  }
  return result;
}"
73084,"/** 
 * Return the hash code for the XMLToken object. If two XMLToken objects contains the same timestamp and index, then they have the same hashcode.
 * @return The hash code for this XMLToken object.
 */
public int hashCode(){
  int hashCode=31;
  if (_isNew) {
    hashCode=31 * hashCode + 1;
  }
  if (_listParents != null) {
    hashCode=31 * hashCode + _listParents.hashCode();
  }
  if (_parentsMap != null) {
    hashCode=31 * hashCode + _parentsMap.hashCode();
  }
  if (_listReferencedChildren != null) {
    hashCode=31 * hashCode + _listReferencedChildren.hashCode();
  }
  if (_modelContent != null) {
    hashCode=31 * hashCode + _modelContent.hashCode();
  }
  if (_modelName != null) {
    hashCode=31 * hashCode + _modelName.hashCode();
  }
  if (_modelId != null) {
    hashCode=31 * hashCode + _modelId.hashCode();
  }
  return hashCode;
}","/** 
 * Return the hash code for the XMLDBModel object.
 * @return The hash code for this XMLDBModel object.
 */
public int hashCode(){
  int hashCode=31;
  if (_isNew) {
    hashCode=31 * hashCode + 1;
  }
  if (_listParents != null) {
    hashCode=31 * hashCode + _listParents.hashCode();
  }
  if (_parentsMap != null) {
    hashCode=31 * hashCode + _parentsMap.hashCode();
  }
  if (_listReferencedChildren != null) {
    hashCode=31 * hashCode + _listReferencedChildren.hashCode();
  }
  if (_modelContent != null) {
    hashCode=31 * hashCode + _modelContent.hashCode();
  }
  if (_modelName != null) {
    hashCode=31 * hashCode + _modelName.hashCode();
  }
  if (_modelId != null) {
    hashCode=31 * hashCode + _modelId.hashCode();
  }
  return hashCode;
}"
73085,"/** 
 * Implementations of this method should return the suggested refined step size for restarting the current integration. If any actor returns false when isStepSizeAccurate() is called, then this method will be called on all actors that implement this interface. The minimum of their returned value will be the new step size. If the actor does not need a smaller step size, then this method should return the current step size.
 * @return The suggested refined step size.
 * @exception IllegalActionException If the step size cannot be further refined.
 */
public double refinedStepSize() throws IllegalActionException {
  if (_refinedStepSize >= 0.0) {
    return _refinedStepSize;
  }
  Director director=getDirector();
  if (director instanceof ContinuousDirector) {
    return ((ContinuousDirector)director).getCurrentStepSize() * 0.5;
  }
  return Double.MAX_VALUE;
}","/** 
 * Implementations of this method should return the suggested refined step size for restarting the current integration. If any actor returns false when isStepSizeAccurate() is called, then this method will be called on all actors that implement this interface. The minimum of their returned value will be the new step size. If the actor does not need a smaller step size, then this method should return the current step size.
 * @return The suggested refined step size.
 * @exception IllegalActionException If the step size cannot be further refined.
 */
public double refinedStepSize() throws IllegalActionException {
  if (_refinedStepSize >= 0.0) {
    if (_debugging) {
      _debug(""String_Node_Str"" + _refinedStepSize);
    }
    return _refinedStepSize;
  }
  Director director=getDirector();
  if (director instanceof ContinuousDirector) {
    double half=((ContinuousDirector)director).getCurrentStepSize() * 0.5;
    if (_debugging) {
      _debug(""String_Node_Str"" + half);
    }
    return half;
  }
  return Double.MAX_VALUE;
}"
73086,"/** 
 * Instantiate the slave FMU component.
 * @exception IllegalActionException if it cannot be instantiated.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  _checkFmi();
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  String fmuLocation=null;
  try {
    String fmuFileName=fmuFile.asFile().getCanonicalPath();
    fmuLocation=new File(fmuFileName).toURI().toURL().toString();
  }
 catch (  Exception ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"" + fmuFile + ""String_Node_Str"");
  }
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte visible=0;
  byte interactive=0;
  FMICallbackFunctions.ByValue callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
  byte loggingOn=_debugging ? (byte)1 : (byte)0;
  loggingOn=1;
  if (_debugging) {
    _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
  }
  _fmiComponent=(Pointer)_fmiInstantiateSlave.invoke(Pointer.class,new Object[]{modelIdentifier,_fmiModelDescription.guid,fmuLocation,mimeType,timeout,visible,interactive,callbacks,loggingOn});
  if (_fmiComponent.equals(Pointer.NULL)) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Instantiate the slave FMU component.
 * @exception IllegalActionException if it cannot be instantiated.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  _checkFmi();
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  String fmuLocation=null;
  try {
    String fmuFileName=fmuFile.asFile().getCanonicalPath();
    fmuLocation=new File(fmuFileName).toURI().toURL().toString();
  }
 catch (  Exception ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"" + fmuFile + ""String_Node_Str"");
  }
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte visible=0;
  byte interactive=0;
  FMICallbackFunctions.ByValue callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
  byte loggingOn=_debugging ? (byte)1 : (byte)0;
  loggingOn=1;
  if (_debugging) {
    _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
  }
  _fmiComponent=(Pointer)_fmiInstantiateSlave.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,fmuLocation,mimeType,timeout,visible,interactive,callbacks,loggingOn});
  if (_fmiComponent.equals(Pointer.NULL)) {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
73087,"/** 
 * Update the parameters listed in the modelDescription.xml file contained in the zipped file named by the <i>fmuFile</i> parameter
 * @exception IllegalActionException If the file named by the<i>fmuFile<i> parameter cannot be unzipped or if there is a problem deleting any pre=existing parameters or creating new parameters.
 * @exception NameDuplicationException If a paramater to be createdhas the same name as a pre-existing parameter.
 */
private void _updateParameters() throws IllegalActionException, NameDuplicationException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  String fmuFileName=null;
  try {
    fmuFileName=fmuFile.asFile().getCanonicalPath();
    if (fmuFileName.equals(_fmuFileName)) {
      return;
    }
    _fmuFileName=fmuFileName;
    long modificationTime=new File(fmuFileName).lastModified();
    if (_fmuFileModificationTime == modificationTime) {
      return;
    }
    _fmuFileModificationTime=modificationTime;
    _fmiModelDescription=FMUFile.parseFMUFile(fmuFileName,true);
    if (_fmiModelDescription.nativeLibrary != null) {
      _fmiDoStep=_fmiModelDescription.nativeLibrary.getFunction(_fmiModelDescription.modelIdentifier + ""String_Node_Str"");
      _fmiInstantiateSlave=_fmiModelDescription.nativeLibrary.getFunction(_fmiModelDescription.modelIdentifier + ""String_Node_Str"");
      try {
        _fmiGetRealStatus=_fmiModelDescription.nativeLibrary.getFunction(_fmiModelDescription.modelIdentifier + ""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetRealStatus=null;
      }
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"" + fmuFileName + ""String_Node_Str"");
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}","/** 
 * Update the parameters listed in the modelDescription.xml file contained in the zipped file named by the <i>fmuFile</i> parameter
 * @exception IllegalActionException If the file named by the<i>fmuFile<i> parameter cannot be unzipped or if there is a problem deleting any pre=existing parameters or creating new parameters.
 * @exception NameDuplicationException If a paramater to be createdhas the same name as a pre-existing parameter.
 */
private void _updateParameters() throws IllegalActionException, NameDuplicationException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  String fmuFileName=null;
  try {
    fmuFileName=fmuFile.asFile().getCanonicalPath();
    if (fmuFileName.equals(_fmuFileName)) {
      return;
    }
    _fmuFileName=fmuFileName;
    long modificationTime=new File(fmuFileName).lastModified();
    if (_fmuFileModificationTime == modificationTime) {
      return;
    }
    _fmuFileModificationTime=modificationTime;
    _fmiModelDescription=FMUFile.parseFMUFile(fmuFileName,true);
    if (_fmiModelDescription.fmiVersion != null) {
      fmiVersion.setExpression(_fmiModelDescription.fmiVersion);
    }
    if (_fmiModelDescription.nativeLibrary != null) {
      _fmiDoStep=_fmiModelDescription.nativeLibrary.getFunction(_fmiModelDescription.modelIdentifier + ""String_Node_Str"");
      _fmiInstantiateSlave=_fmiModelDescription.nativeLibrary.getFunction(_fmiModelDescription.modelIdentifier + ""String_Node_Str"");
      try {
        _fmiGetRealStatus=_fmiModelDescription.nativeLibrary.getFunction(_fmiModelDescription.modelIdentifier + ""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetRealStatus=null;
      }
    }
    if (_fmiModelDescription.canGetAndSetFMUstate) {
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"" + fmuFileName + ""String_Node_Str"");
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}"
73088,"/** 
 * Read data from output ports, set the input ports and invoke fmiDoStep() of the slave fmu. <p>Note that we get the outputs <b>before</b> invoking fmiDoStep() of the slave fmu so that we can get the data for time 0.  This is done so that FMUs can share initialization data if necessary.  For details, see the Section 3.4, Pseudo Code Example in the FMI-1.0 Co-simulation Specification at <a href=""http://www.modelisar.com/specifications/FMI_for_CoSimulation_v1.0.pdf"">http://www.modelisar.com/specifications/FMI_for_CoSimulation_v1.0.pdf</a>. For an explanation, see figure 4 of <br> Michael Wetter, ""<a href=""http://dx.doi.org/10.1080/19401493.2010.518631"">Co-simulation of building energy and control systems with the Building Controls Virtual Test Bed</a>,"" Journal of Building Performance Simulation, Volume 4, Issue 3, 2011.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  _checkFmi();
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  Director director=getDirector();
  Time currentTime=director.getModelTime();
  int currentMicrostep=1;
  if (director instanceof SuperdenseTimeDirector) {
    currentMicrostep=((SuperdenseTimeDirector)director).getIndex();
  }
  int timeAdvance=currentTime.compareTo(_lastFireTime);
  if (timeAdvance > 0 || (timeAdvance == 0 && currentMicrostep > _lastFireMicrostep)) {
    double time=_lastFireTime.getDoubleValue();
    double stepSize=currentTime.subtract(_lastFireTime).getDoubleValue();
    if (_debugging) {
      _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str"");
    }
    _refinedStepSize=-1.0;
    int fmiFlag=((Integer)_fmiDoStep.invokeInt(new Object[]{_fmiComponent,time,stepSize,(byte)1})).intValue();
    if (fmiFlag == FMILibrary.FMIStatus.fmiDiscard) {
      _stepSizeRejected=true;
      if (_debugging) {
        _debug(""String_Node_Str"" + stepSize + ""String_Node_Str""+ time);
      }
      if (_fmiGetRealStatus != null) {
        DoubleBuffer valueBuffer=DoubleBuffer.allocate(1);
        fmiFlag=((Integer)_fmiGetRealStatus.invokeInt(new Object[]{_fmiComponent,FMILibrary.FMIStatusKind.fmiLastSuccessfulTime,valueBuffer})).intValue();
        if (fmiFlag == FMILibrary.FMIStatus.fmiOK) {
          double lastSuccessfulTime=valueBuffer.get(0);
          if (lastSuccessfulTime >= time) {
            _refinedStepSize=lastSuccessfulTime - _lastCommitTime.getDoubleValue();
          }
        }
      }
    }
 else     if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
      throw new IllegalActionException(this,""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str""+ _fmiStatusDescription(fmiFlag));
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
    }
  }
 else   if (timeAdvance < 0 || (timeAdvance == 0 && currentMicrostep < _lastFireMicrostep)) {
    double time=_lastCommitTime.getDoubleValue();
    double stepSize=currentTime.subtract(_lastCommitTime).getDoubleValue();
    if (_debugging) {
      _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str"");
    }
    int fmiFlag=((Integer)_fmiDoStep.invokeInt(new Object[]{_fmiComponent,time,stepSize,(byte)0})).intValue();
    if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
      throw new IllegalActionException(this,""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str""+ _fmiStatusDescription(fmiFlag));
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
    }
  }
  _lastFireTime=currentTime;
  _lastFireMicrostep=currentMicrostep;
  for (  FMIScalarVariable scalarVariable : _fmiModelDescription.modelVariables) {
    if (scalarVariable.alias != null && scalarVariable.alias != Alias.noAlias) {
      continue;
    }
    if (scalarVariable.variability != FMIScalarVariable.Variability.parameter && scalarVariable.variability != FMIScalarVariable.Variability.constant && scalarVariable.causality == Causality.input) {
      TypedIOPort port=(TypedIOPort)getPort(scalarVariable.name);
      if (port != null) {
        if (port.isKnown(0)) {
          if (port.hasToken(0)) {
            Token token=port.get(0);
            _setScalarVariable(scalarVariable,token);
            if (_debugging) {
              _debug(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token);
            }
          }
 else {
            throw new IllegalActionException(this,""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
 else {
        throw new IllegalActionException(this,""String_Node_Str"" + scalarVariable.name + ""String_Node_Str"");
      }
    }
  }
  for (  Output output : _getOutputs()) {
    TypedIOPort port=output.port;
    if (_skipIfKnown() && port.isKnown(0)) {
      continue;
    }
    boolean foundUnknownInputOnWhichOutputDepends=false;
    if (output.dependencies != null) {
      for (      TypedIOPort inputPort : output.dependencies) {
        if (!inputPort.isKnown(0)) {
          if (_debugging) {
            _debug(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          foundUnknownInputOnWhichOutputDepends=true;
          break;
        }
      }
    }
 else {
      List<TypedIOPort> inputPorts=inputPortList();
      for (      TypedIOPort inputPort : inputPorts) {
        if (inputPort.getWidth() < 0 || !inputPort.isKnown(0)) {
          foundUnknownInputOnWhichOutputDepends=true;
          break;
        }
      }
    }
    if (!foundUnknownInputOnWhichOutputDepends) {
      Token token=null;
      FMIScalarVariable scalarVariable=output.scalarVariable;
      if (scalarVariable.type instanceof FMIBooleanType) {
        boolean result=scalarVariable.getBoolean(_fmiComponent);
        token=new BooleanToken(result);
      }
 else       if (scalarVariable.type instanceof FMIIntegerType) {
        int result=scalarVariable.getInt(_fmiComponent);
        token=new IntToken(result);
      }
 else       if (scalarVariable.type instanceof FMIRealType) {
        double result=scalarVariable.getDouble(_fmiComponent);
        token=new DoubleToken(result);
      }
 else       if (scalarVariable.type instanceof FMIStringType) {
        String result=scalarVariable.getString(_fmiComponent);
        token=new StringToken(result);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + scalarVariable.type + ""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token+ ""String_Node_Str""+ currentTime+ ""String_Node_Str""+ currentMicrostep);
      }
      port.send(0,token);
    }
  }
}","/** 
 * Read data from output ports, set the input ports and invoke fmiDoStep() of the slave fmu. <p>Note that we get the outputs <b>before</b> invoking fmiDoStep() of the slave fmu so that we can get the data for time 0.  This is done so that FMUs can share initialization data if necessary.  For details, see the Section 3.4, Pseudo Code Example in the FMI-1.0 Co-simulation Specification at <a href=""http://www.modelisar.com/specifications/FMI_for_CoSimulation_v1.0.pdf"">http://www.modelisar.com/specifications/FMI_for_CoSimulation_v1.0.pdf</a>. For an explanation, see figure 4 of <br> Michael Wetter, ""<a href=""http://dx.doi.org/10.1080/19401493.2010.518631"">Co-simulation of building energy and control systems with the Building Controls Virtual Test Bed</a>,"" Journal of Building Performance Simulation, Volume 4, Issue 3, 2011.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  _checkFmi();
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  Director director=getDirector();
  Time currentTime=director.getModelTime();
  int currentMicrostep=1;
  if (director instanceof SuperdenseTimeDirector) {
    currentMicrostep=((SuperdenseTimeDirector)director).getIndex();
  }
  int timeAdvance=currentTime.compareTo(_lastFireTime);
  if (timeAdvance > 0 || (timeAdvance == 0 && currentMicrostep > _lastFireMicrostep)) {
    double time=_lastFireTime.getDoubleValue();
    double stepSize=currentTime.subtract(_lastFireTime).getDoubleValue();
    if (_debugging) {
      _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str"");
    }
    if (time >= 2.9) {
      Math.sin(3.14159);
    }
    _refinedStepSize=-1.0;
    int fmiFlag=((Integer)_fmiDoStep.invokeInt(new Object[]{_fmiComponent,time,stepSize,(byte)1})).intValue();
    if (fmiFlag == FMILibrary.FMIStatus.fmiDiscard) {
      _stepSizeRejected=true;
      if (_debugging) {
        _debug(""String_Node_Str"" + stepSize + ""String_Node_Str""+ time);
      }
      if (_fmiGetRealStatus != null) {
        DoubleBuffer valueBuffer=DoubleBuffer.allocate(1);
        fmiFlag=((Integer)_fmiGetRealStatus.invokeInt(new Object[]{_fmiComponent,FMILibrary.FMIStatusKind.fmiLastSuccessfulTime,valueBuffer})).intValue();
        if (fmiFlag == FMILibrary.FMIStatus.fmiOK) {
          double lastSuccessfulTime=valueBuffer.get(0);
          if (lastSuccessfulTime >= _lastCommitTime.getDoubleValue()) {
            _refinedStepSize=lastSuccessfulTime - _lastCommitTime.getDoubleValue();
          }
        }
      }
    }
 else     if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
      throw new IllegalActionException(this,""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str""+ _fmiStatusDescription(fmiFlag));
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
    }
  }
 else   if (timeAdvance < 0 || (timeAdvance == 0 && currentMicrostep < _lastFireMicrostep)) {
    double time=_lastCommitTime.getDoubleValue();
    double stepSize=currentTime.subtract(_lastCommitTime).getDoubleValue();
    if (_debugging) {
      _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str"");
    }
    int fmiFlag=((Integer)_fmiDoStep.invokeInt(new Object[]{_fmiComponent,time,stepSize,(byte)0})).intValue();
    if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
      throw new IllegalActionException(this,""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str""+ _fmiStatusDescription(fmiFlag));
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
    }
  }
  _lastFireTime=currentTime;
  _lastFireMicrostep=currentMicrostep;
  for (  FMIScalarVariable scalarVariable : _fmiModelDescription.modelVariables) {
    if (scalarVariable.alias != null && scalarVariable.alias != Alias.noAlias) {
      continue;
    }
    if (scalarVariable.variability != FMIScalarVariable.Variability.parameter && scalarVariable.variability != FMIScalarVariable.Variability.constant && scalarVariable.causality == Causality.input) {
      TypedIOPort port=(TypedIOPort)getPort(scalarVariable.name);
      if (port != null) {
        if (port.isKnown(0)) {
          if (port.hasToken(0)) {
            Token token=port.get(0);
            _setScalarVariable(scalarVariable,token);
            if (_debugging) {
              _debug(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token);
            }
          }
 else {
            throw new IllegalActionException(this,""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
 else {
        throw new IllegalActionException(this,""String_Node_Str"" + scalarVariable.name + ""String_Node_Str"");
      }
    }
  }
  for (  Output output : _getOutputs()) {
    TypedIOPort port=output.port;
    if (_skipIfKnown() && port.isKnown(0)) {
      continue;
    }
    boolean foundUnknownInputOnWhichOutputDepends=false;
    if (output.dependencies != null) {
      for (      TypedIOPort inputPort : output.dependencies) {
        if (!inputPort.isKnown(0)) {
          if (_debugging) {
            _debug(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          foundUnknownInputOnWhichOutputDepends=true;
          break;
        }
      }
    }
 else {
      List<TypedIOPort> inputPorts=inputPortList();
      for (      TypedIOPort inputPort : inputPorts) {
        if (inputPort.getWidth() < 0 || !inputPort.isKnown(0)) {
          foundUnknownInputOnWhichOutputDepends=true;
          break;
        }
      }
    }
    if (!foundUnknownInputOnWhichOutputDepends) {
      Token token=null;
      FMIScalarVariable scalarVariable=output.scalarVariable;
      if (scalarVariable.type instanceof FMIBooleanType) {
        boolean result=scalarVariable.getBoolean(_fmiComponent);
        token=new BooleanToken(result);
      }
 else       if (scalarVariable.type instanceof FMIIntegerType) {
        int result=scalarVariable.getInt(_fmiComponent);
        token=new IntToken(result);
      }
 else       if (scalarVariable.type instanceof FMIRealType) {
        double result=scalarVariable.getDouble(_fmiComponent);
        token=new DoubleToken(result);
      }
 else       if (scalarVariable.type instanceof FMIStringType) {
        String result=scalarVariable.getString(_fmiComponent);
        token=new StringToken(result);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + scalarVariable.type + ""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token+ ""String_Node_Str""+ currentTime+ ""String_Node_Str""+ currentMicrostep);
      }
      port.send(0,token);
    }
  }
}"
73089,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public FMUImport(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  fmuFile=new FileParameter(this,""String_Node_Str"");
  fmuFile.setExpression(""String_Node_Str"");
  fmuFile.setVisibility(Settable.NOT_EDITABLE);
  suppressWarnings=new Parameter(this,""String_Node_Str"");
  suppressWarnings.setTypeEquals(BaseType.BOOLEAN);
  suppressWarnings.setExpression(""String_Node_Str"");
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public FMUImport(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  fmuFile=new FileParameter(this,""String_Node_Str"");
  fmuFile.setExpression(""String_Node_Str"");
  fmuFile.setVisibility(Settable.NOT_EDITABLE);
  fmiVersion=new StringParameter(this,""String_Node_Str"");
  fmiVersion.setExpression(""String_Node_Str"");
  fmiVersion.setVisibility(Settable.NOT_EDITABLE);
  suppressWarnings=new Parameter(this,""String_Node_Str"");
  suppressWarnings.setTypeEquals(BaseType.BOOLEAN);
  suppressWarnings.setExpression(""String_Node_Str"");
}"
73090,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ArcAttribute newObject=(ArcAttribute)super.clone(workspace);
  newObject._icon.setShape(newObject._newShape());
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ArcAttribute newObject=(ArcAttribute)super.clone(workspace);
  newObject._icon.setShape(_newShape());
  return newObject;
}"
73091,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  EllipseAttribute newObject=(EllipseAttribute)super.clone(workspace);
  newObject._icon.setShape(newObject._newShape());
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  EllipseAttribute newObject=(EllipseAttribute)super.clone(workspace);
  newObject._icon.setShape(_newShape());
  return newObject;
}"
73092,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  RectangleAttribute newObject=(RectangleAttribute)super.clone(workspace);
  newObject._icon.setShape(newObject._newShape());
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  RectangleAttribute newObject=(RectangleAttribute)super.clone(workspace);
  newObject._icon.setShape(_newShape());
  return newObject;
}"
73093,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ResizablePolygonAttribute newObject=(ResizablePolygonAttribute)super.clone(workspace);
  newObject._icon.setShape(newObject._newShape());
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ResizablePolygonAttribute newObject=(ResizablePolygonAttribute)super.clone(workspace);
  newObject._icon.setShape(_newShape());
  return newObject;
}"
73094,"/** 
 * Open the file and read the first line, putting its value into the _currentLine variable. Also, read the second line, putting its value in the _nextLine variable.
 * @exception IllegalActionException If the file cannot be read.
 */
protected void _openAndReadFirstTwoLines() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + ((StringToken)fileOrURL.getToken()).stringValue());
  }
  _reader=fileOrURL.openForReading();
  if (_reader == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + fileOrURL.getDisplayName());
  }
  try {
    int numberOfLines=((IntToken)numberOfLinesToSkip.getToken()).intValue();
    for (int i=0; i <= numberOfLines; i++) {
      _currentLine=_reader.readLine();
      if (_debugging) {
        _debug(""String_Node_Str"" + _currentLine);
      }
      if (_currentLine == null) {
        throw new IllegalActionException(this,""String_Node_Str"" + fileOrURL.stringValue() + ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
    _nextLine=_reader.readLine();
    if (_debugging) {
      _debug(""String_Node_Str"" + _nextLine);
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
}","/** 
 * Open the file and read the first line, putting its value into the _currentLine variable. Also, read the second line, putting its value in the _nextLine variable.
 * @exception IllegalActionException If the file cannot be read.
 */
protected void _openAndReadFirstTwoLines() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + ((StringToken)fileOrURL.getToken()).stringValue());
  }
  _reader=fileOrURL.openForReading();
  if (_reader == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + fileOrURL.getDisplayName());
  }
  try {
    int numberOfLines=((IntToken)numberOfLinesToSkip.getToken()).intValue();
    for (int i=0; i <= numberOfLines; i++) {
      _currentLine=_reader.readLine();
      if (_debugging && i < numberOfLines) {
        _debug(""String_Node_Str"" + _currentLine);
      }
      if (_currentLine == null) {
        throw new IllegalActionException(this,""String_Node_Str"" + fileOrURL.stringValue() + ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
    _nextLine=_reader.readLine();
    if (_debugging) {
      _debug(""String_Node_Str"" + _nextLine);
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
}"
73095,"private void readMapping(String finename){
}","/** 
 * Read constraints from the mapping file.
 * @param finename mapping file
 */
private void readMapping(String finename){
}"
73096,"private void _initializeParameters(){
  _verbose=true;
  try {
    _mapping_file_name=new Parameter(this,""String_Node_Str"");
    _mapping_file_name.setTypeEquals(BaseType.STRING);
  }
 catch (  IllegalActionException e1) {
    e1.printStackTrace();
  }
catch (  NameDuplicationException e1) {
    e1.printStackTrace();
  }
}","private void _initializeParameters(){
  _verbose=true;
  try {
    _mappingFileName=new Parameter(this,""String_Node_Str"");
    _mappingFileName.setTypeEquals(BaseType.STRING);
  }
 catch (  IllegalActionException e1) {
    e1.printStackTrace();
  }
catch (  NameDuplicationException e1) {
    e1.printStackTrace();
  }
}"
73097,"void _init(){
  try {
    _mapping_file_name.moveToLast();
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
}","void _init(){
  try {
    _mappingFileName.moveToLast();
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
}"
73098,"public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == _mapping_file_name) {
    StringToken str_token=(StringToken)_mapping_file_name.getToken();
    if (str_token == null) {
      _mapping_file_name=null;
    }
 else {
      readMapping(str_token.stringValue());
      System.out.println(_mapping_constraint_solver);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == _mappingFileName) {
    StringToken str_token=(StringToken)_mappingFileName.getToken();
    if (str_token == null) {
      _mappingFileName=null;
    }
 else {
      readMapping(str_token.stringValue());
      System.out.println(_mappingConstraintSolver);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
73099,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MetroIIDirector newObject=(MetroIIDirector)super.clone(workspace);
  newObject._mapping_constraint_solver=new MappingConstraintSolver(100);
  newObject.eventname2id=new Hashtable<String,Integer>();
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MetroIIDirector newObject=(MetroIIDirector)super.clone(workspace);
  newObject._mappingConstraintSolver=new MappingConstraintSolver(100);
  newObject._eventName2ID=new Hashtable<String,Integer>();
  return newObject;
}"
73100,"public void fire() throws IllegalActionException {
  try {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    Nameable container=getContainer();
    Iterator<?> actors=((CompositeActor)container).deepEntityList().iterator();
    LinkedList<MetroIIActorThread> actor_thread_list=new LinkedList<MetroIIActorThread>();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      if (actor instanceof MetroIIEventHandler) {
        actor_thread_list.add(new MetroIIActorThread(actor,MetroIIActorThread.Type.Metropolis,MetroIIActorThread.State.WAITING,null));
      }
 else {
        actor_thread_list.add(new MetroIIActorThread(actor,MetroIIActorThread.Type.Ptolemy,MetroIIActorThread.State.WAITING,null));
      }
    }
    boolean stable=false;
    while (!_stopRequested) {
      LinkedList<Event.Builder> m2event_list=new LinkedList<Event.Builder>();
      stable=true;
      for (      MetroIIActorThread actor_thread : actor_thread_list) {
        if (actor_thread._actor.prefire()) {
          if (actor_thread._type == MetroIIActorThread.Type.Metropolis) {
            if (actor_thread._state == MetroIIActorThread.State.WAITING) {
              final YieldAdapterIterable<Iterable<Event.Builder>> results=((MetroIIEventHandler)actor_thread._actor).adapter();
              actor_thread._thread=results.iterator();
              actor_thread._state=MetroIIActorThread.State.ACTIVE;
            }
          }
 else           if (actor_thread._type == MetroIIActorThread.Type.Ptolemy) {
            actor_thread._state=MetroIIActorThread.State.ACTIVE;
          }
        }
      }
      for (      MetroIIActorThread actor_thread : actor_thread_list) {
        if (actor_thread._type == MetroIIActorThread.Type.Metropolis && actor_thread._state == MetroIIActorThread.State.ACTIVE) {
          Actor actor=actor_thread._actor;
          Iterator<Iterable<Event.Builder>> thread=actor_thread._thread;
          if (thread.hasNext()) {
            Iterable<Event.Builder> result=thread.next();
            for (            Builder builder : result) {
              Event.Builder etb=builder;
              String event_name=etb.getName();
              if (!eventname2id.containsKey(event_name)) {
                eventname2id.put(event_name,next_avail_id);
                next_avail_id++;
              }
              etb.setStatus(Event.Status.WAITING);
              m2event_list.add(etb);
              stable=false;
            }
          }
 else {
            boolean pfire=actor.postfire();
            actor_thread._state=MetroIIActorThread.State.WAITING;
            if (!pfire) {
              if (_debugging) {
                _debug(""String_Node_Str"" + ((Nameable)actor).getFullName());
              }
            }
            if (_stopRequested) {
              if (_debugging) {
                _debug(""String_Node_Str"" + ((Nameable)actor).getFullName());
              }
            }
          }
        }
      }
      for (      MetroIIActorThread actor_thread : actor_thread_list) {
        if (actor_thread._type == MetroIIActorThread.Type.Ptolemy && actor_thread._state == MetroIIActorThread.State.ACTIVE) {
          actor_thread._actor.fire();
          boolean pfire=actor_thread._actor.postfire();
          actor_thread._state=MetroIIActorThread.State.WAITING;
          if (!pfire) {
            if (_debugging) {
              _debug(""String_Node_Str"" + ((Nameable)actor_thread._actor).getFullName());
            }
          }
        }
      }
      for (      Event.Builder etb : m2event_list) {
        String event_name=etb.getName();
        _mapping_constraint_solver.presentM2Event(eventname2id.get(event_name));
      }
      System.out.println(_mapping_constraint_solver);
      System.out.println(""String_Node_Str"");
      for (      Event.Builder etb : m2event_list) {
        System.out.println(eventname2id.get(etb.getName()) + etb.getName() + ""String_Node_Str""+ etb.getStatus().toString());
      }
      for (      Event.Builder etb : m2event_list) {
        String event_name=etb.getName();
        if (_mapping_constraint_solver.isSatisfied(eventname2id.get(event_name))) {
          etb.setStatus(Event.Status.NOTIFIED);
        }
      }
      System.out.println(""String_Node_Str"");
      for (      Event.Builder etb : m2event_list) {
        System.out.println(eventname2id.get(etb.getName()) + etb.getName() + ""String_Node_Str""+ etb.getStatus().toString());
      }
      _mapping_constraint_solver.reset();
    }
    if (_stopRequested) {
      for (      MetroIIActorThread actor_thread : actor_thread_list) {
        if (actor_thread._type == MetroIIActorThread.Type.Metropolis && actor_thread._state == MetroIIActorThread.State.ACTIVE) {
          actor_thread._thread.dispose();
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    System.err.println(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Tries to call prefire(), fire(), and postfire() of each actor in the model. If the actor  is a CompositeActor that has a MetroII compatible director, the getfire() is called instead of fire().  In addition to do everything fire() does, getfire() proposes events in firing. And when proposing events, the CompositeActor is blocked.  Tries to resolve the mapping constraints. The MetroIIDirector collects all the events and reset the  statuses of events based on the mapping constraints. In the next iteration, CompositeActor executes  based on the updated statuses of events.  
 */
public void fire() throws IllegalActionException {
  try {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    Nameable container=getContainer();
    Iterator<?> actors=((CompositeActor)container).deepEntityList().iterator();
    LinkedList<MetroIIActorThread> actor_thread_list=new LinkedList<MetroIIActorThread>();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      if (actor instanceof MetroIIEventHandler) {
        actor_thread_list.add(new MetroIIActorThread(actor,MetroIIActorThread.Type.Metropolis,MetroIIActorThread.State.WAITING,null));
      }
 else {
        actor_thread_list.add(new MetroIIActorThread(actor,MetroIIActorThread.Type.Ptolemy,MetroIIActorThread.State.WAITING,null));
      }
    }
    boolean stable=false;
    while (!_stopRequested) {
      LinkedList<Event.Builder> m2event_list=new LinkedList<Event.Builder>();
      stable=true;
      for (      MetroIIActorThread actor_thread : actor_thread_list) {
        if (actor_thread._actor.prefire()) {
          if (actor_thread._type == MetroIIActorThread.Type.Metropolis) {
            if (actor_thread._state == MetroIIActorThread.State.WAITING) {
              final YieldAdapterIterable<Iterable<Event.Builder>> results=((MetroIIEventHandler)actor_thread._actor).adapter();
              actor_thread._thread=results.iterator();
              actor_thread._state=MetroIIActorThread.State.ACTIVE;
            }
          }
 else           if (actor_thread._type == MetroIIActorThread.Type.Ptolemy) {
            actor_thread._state=MetroIIActorThread.State.ACTIVE;
          }
        }
      }
      for (      MetroIIActorThread actor_thread : actor_thread_list) {
        if (actor_thread._type == MetroIIActorThread.Type.Metropolis && actor_thread._state == MetroIIActorThread.State.ACTIVE) {
          Actor actor=actor_thread._actor;
          Iterator<Iterable<Event.Builder>> thread=actor_thread._thread;
          if (thread.hasNext()) {
            Iterable<Event.Builder> result=thread.next();
            for (            Builder builder : result) {
              Event.Builder etb=builder;
              String event_name=etb.getName();
              if (!_eventName2ID.containsKey(event_name)) {
                _eventName2ID.put(event_name,_nextAvailID);
                _nextAvailID++;
              }
              etb.setStatus(Event.Status.WAITING);
              m2event_list.add(etb);
              stable=false;
            }
          }
 else {
            boolean pfire=actor.postfire();
            actor_thread._state=MetroIIActorThread.State.WAITING;
            if (!pfire) {
              if (_debugging) {
                _debug(""String_Node_Str"" + ((Nameable)actor).getFullName());
              }
            }
            if (_stopRequested) {
              if (_debugging) {
                _debug(""String_Node_Str"" + ((Nameable)actor).getFullName());
              }
            }
          }
        }
      }
      for (      MetroIIActorThread actor_thread : actor_thread_list) {
        if (actor_thread._type == MetroIIActorThread.Type.Ptolemy && actor_thread._state == MetroIIActorThread.State.ACTIVE) {
          actor_thread._actor.fire();
          boolean pfire=actor_thread._actor.postfire();
          actor_thread._state=MetroIIActorThread.State.WAITING;
          if (!pfire) {
            if (_debugging) {
              _debug(""String_Node_Str"" + ((Nameable)actor_thread._actor).getFullName());
            }
          }
        }
      }
      for (      Event.Builder etb : m2event_list) {
        String event_name=etb.getName();
        _mappingConstraintSolver.presentM2Event(_eventName2ID.get(event_name));
      }
      System.out.println(_mappingConstraintSolver);
      System.out.println(""String_Node_Str"");
      for (      Event.Builder etb : m2event_list) {
        System.out.println(_eventName2ID.get(etb.getName()) + etb.getName() + ""String_Node_Str""+ etb.getStatus().toString());
      }
      for (      Event.Builder etb : m2event_list) {
        String event_name=etb.getName();
        if (_mappingConstraintSolver.isSatisfied(_eventName2ID.get(event_name))) {
          etb.setStatus(Event.Status.NOTIFIED);
        }
      }
      System.out.println(""String_Node_Str"");
      for (      Event.Builder etb : m2event_list) {
        System.out.println(_eventName2ID.get(etb.getName()) + etb.getName() + ""String_Node_Str""+ etb.getStatus().toString());
      }
      _mappingConstraintSolver.reset();
    }
    if (_stopRequested) {
      for (      MetroIIActorThread actor_thread : actor_thread_list) {
        if (actor_thread._type == MetroIIActorThread.Type.Metropolis && actor_thread._state == MetroIIActorThread.State.ACTIVE) {
          actor_thread._thread.dispose();
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    System.err.println(""String_Node_Str"" + e.getMessage());
  }
}"
73101,"/** 
 * Update the local variable associated with the changed attribute and disconnect from the server. 
 * @param attribute The changed attribute.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == port) {
    _portNumber=((IntToken)port.getToken()).intValue();
    _disconnect();
  }
 else   if (attribute == server) {
    _serverName=((StringToken)server.getToken()).stringValue();
    _disconnect();
  }
 else   if (attribute == username) {
    _userName=((StringToken)username.getToken()).stringValue();
    _disconnect();
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * Update the local variable associated with the changed attribute and disconnect from the server. 
 * @param attribute The changed attribute.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == port) {
    _portNumber=((IntToken)port.getToken()).intValue();
    _disconnect();
  }
 else   if (attribute == server) {
    _serverName=((StringToken)server.getToken()).stringValue();
    _disconnect();
  }
 else   if (attribute == username) {
    _userName=((StringToken)username.getToken()).stringValue();
    _disconnect();
  }
 else   if (attribute == password) {
    _password=((StringToken)password.getToken()).stringValue();
    _disconnect();
  }
 else {
    super.attributeChanged(attribute);
  }
}"
73102,"/** 
 * Add a pure event to the queue of pure events.
 * @param actor Actor to fire.
 * @param time Time the actor should be fired at.
 * @param index Microstep the actor should be fired at.
 * @return The time the actor requested to be refired at.
 * @exception IllegalActionException If firing of the container doesn't succeed.
 */
public Time fireAt(Actor actor,Time time,int index) throws IllegalActionException {
  if (actor == this.getContainer()) {
    fireContainerAt(time);
    return time;
  }
  int newIndex=index;
  if (index <= getIndex()) {
    newIndex=Math.max(getIndex(),index) + 1;
  }
  if (_isInitializing) {
    _currentSourceTimestamp=time;
  }
  _pureEvents.put(new PtidesEvent(actor,null,time,newIndex,0,_zeroTime,_currentSourceTimestamp));
  _currentSourceTimestamp=null;
  Time environmentTime=super.getEnvironmentTime();
  if (environmentTime.compareTo(time) <= 0) {
    fireContainerAt(time);
  }
  return time;
}","/** 
 * Add a pure event to the queue of pure events.
 * @param actor Actor to fire.
 * @param time Time the actor should be fired at.
 * @param index Microstep the actor should be fired at.
 * @return The time the actor requested to be refired at.
 * @exception IllegalActionException If firing of the container doesn't succeed.
 */
public Time fireAt(Actor actor,Time time,int index) throws IllegalActionException {
  if (actor == this.getContainer()) {
    fireContainerAt(time);
    return time;
  }
  int newIndex=index;
  if (index <= getIndex()) {
    newIndex=Math.max(getIndex(),index) + 1;
  }
  if (_isInitializing) {
    _currentSourceTimestamp=time;
  }
  _pureEvents.put(new PtidesEvent(actor,null,time,newIndex,0,_zeroTime,_currentSourceTimestamp));
  _currentSourceTimestamp=null;
  Time environmentTime=super.getEnvironmentTime();
  if (environmentTime.compareTo(time) <= 0) {
    fireContainerAt(time,1);
  }
  return time;
}"
73103,"/** 
 * Set up and return two type constraints. <ul> <li><tt>output >= {x = typeOf(inputPortX), y = typeOf(inputPortY), ..} </tt>, which requires the types of the input ports to be compatible with the corresponding types in the output record. </li> <li><tt>each input <= the type of the corresponding field inside the output record</tt>, which is similar to the usual default constraints, however this constraint establishes a dependency between the inputs of this actor and the fields inside the output record, instead of just between its inputs and outputs. </li> </ul> Note that the output record is not required to contain a corresponding field for every input, as downstream actors might require fewer fields in the record they accept for input.
 * @return A set of type constraints
 * @see ConstructAssociativeType
 * @see ExtractFieldType
 */
@Override protected Set<Inequality> _customTypeConstraints(){
  Set<Inequality> result=new HashSet<Inequality>();
  for (  TypedIOPort input : inputPortList()) {
    result.add(new Inequality(new ExtractFieldType(output,input.getName()),input.getTypeTerm()));
  }
  result.add(new Inequality(new ConstructAssociativeType(inputPortList(),RecordType.class),output.getTypeTerm()));
  return result;
}","/** 
 * Set up and return two type constraints. <ul> <li><tt>output >= {x = typeOf(inputPortX), y = typeOf(inputPortY), ..} </tt>, which requires the types of the input ports to be compatible with the corresponding types in the output record. </li> <li><tt>each input >= the type of the corresponding field inside the output record</tt>, which together with the first constraint forces the input types to be exactly equal to the types of the corresponding fields in the output record. This constraint is intended to back- propagate type information upstream, not to assure type compatibility. Therefore, this constraint is only set up for input ports that do not already have a type declared.</li> </ul> Note that the output record is not required to contain a corresponding field for every input, as downstream actors might require fewer fields in the record they accept for input.
 * @return A set of type constraints
 * @see ConstructAssociativeType
 * @see ExtractFieldType
 */
@Override protected Set<Inequality> _customTypeConstraints(){
  Set<Inequality> result=new HashSet<Inequality>();
  for (  TypedIOPort input : inputPortList()) {
    if (input.getTypeTerm().isSettable()) {
      result.add(new Inequality(new ExtractFieldType(output,input.getName()),input.getTypeTerm()));
    }
  }
  result.add(new Inequality(new ConstructAssociativeType(inputPortList(),RecordType.class),output.getTypeTerm()));
  return result;
}"
73104,"/** 
 * If the attribute for the input, switch fabric or output delay is changed, then ensure that the value is non-negative.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the buffer delays are negative.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == inputBufferDelay) {
    double value=((DoubleToken)inputBufferDelay.getToken()).doubleValue();
    if (value <= 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + value);
    }
    _inputBufferDelay=value;
  }
 else   if (attribute == outputBufferDelay) {
    double value=((DoubleToken)outputBufferDelay.getToken()).doubleValue();
    if (value <= 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + value);
    }
    _outputBufferDelay=value;
  }
 else   if (attribute == switchFabricDelay) {
    double value=((DoubleToken)switchFabricDelay.getToken()).doubleValue();
    if (value <= 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + value);
    }
    _switchFabricDelay=value;
  }
 else   if (attribute == numberOfPorts) {
    int ports=((IntToken)numberOfPorts.getToken()).intValue();
    for (int i=0; i < ports; i++) {
      _inputTokens.put(i,new TreeSet());
      _outputTokens.put(i,new TreeSet());
    }
  }
  super.attributeChanged(attribute);
}","/** 
 * If the attribute for the input, switch fabric or output delay is changed, then ensure that the value is non-negative.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the buffer delays are negative.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == inputBufferDelay) {
    double value=((DoubleToken)inputBufferDelay.getToken()).doubleValue();
    if (value <= 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + value);
    }
    _inputBufferDelay=value;
  }
 else   if (attribute == outputBufferDelay) {
    double value=((DoubleToken)outputBufferDelay.getToken()).doubleValue();
    if (value <= 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + value);
    }
    _outputBufferDelay=value;
  }
 else   if (attribute == switchFabricDelay) {
    double value=((DoubleToken)switchFabricDelay.getToken()).doubleValue();
    if (value <= 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + value);
    }
    _switchFabricDelay=value;
  }
 else   if (attribute == numberOfPorts) {
    int ports=((IntToken)numberOfPorts.getToken()).intValue();
    _numberOfPorts=ports;
    for (int i=0; i < ports; i++) {
      _inputTokens.put(i,new TreeSet());
      _outputTokens.put(i,new TreeSet());
    }
  }
  super.attributeChanged(attribute);
}"
73105,"/** 
 * If the shell has not already been created, create it. Then wait for user input and produce it on the output.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (shell == null) {
    Effigy containerEffigy=Configuration.findEffigy(toplevel());
    if (containerEffigy == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + toplevel().getFullName());
    }
    try {
      ExpressionShellEffigy shellEffigy=new ExpressionShellEffigy(containerEffigy,containerEffigy.uniqueName(""String_Node_Str""));
      shellEffigy.identifier.setExpression(getFullName());
      _tableau=new ShellTableau(shellEffigy,""String_Node_Str"");
      _frame=_tableau.frame;
      shell=_tableau.shell;
      shell.setInterpreter(this);
      shell.setEditable(false);
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,null,ex,""String_Node_Str"");
    }
    _windowProperties.setProperties(_frame);
    _frame.pack();
  }
 else {
    shell.clearJTextArea();
  }
  if (_frame != null) {
    _frame.show();
    _frame.toFront();
  }
  _firstTime=true;
  _returnFalseInPostfire=false;
}","/** 
 * If the shell has not already been created, create it. Then wait for user input and produce it on the output.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  Runnable doInitialize=new Runnable(){
    public void run(){
      if (shell == null) {
        Effigy containerEffigy=Configuration.findEffigy(toplevel());
        if (containerEffigy == null) {
          MessageHandler.error(""String_Node_Str"" + toplevel().getFullName());
          return;
        }
        try {
          ExpressionShellEffigy shellEffigy=new ExpressionShellEffigy(containerEffigy,containerEffigy.uniqueName(""String_Node_Str""));
          shellEffigy.identifier.setExpression(getFullName());
          _tableau=new ShellTableau(shellEffigy,""String_Node_Str"");
          _frame=_tableau.frame;
          shell=_tableau.shell;
          shell.setInterpreter(InteractiveShell.this);
          shell.setEditable(false);
        }
 catch (        Exception ex) {
          MessageHandler.error(""String_Node_Str"" + InteractiveShell.this.getFullName(),ex);
          return;
        }
        _windowProperties.setProperties(_frame);
        _frame.pack();
      }
 else {
        shell.clearJTextArea();
      }
      if (_frame != null) {
        _frame.show();
        _frame.toFront();
      }
    }
  }
;
  try {
    SwingUtilities.invokeAndWait(doInitialize);
  }
 catch (  Exception e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
  _firstTime=true;
  _returnFalseInPostfire=false;
}"
73106,"/** 
 * Initialize to the default, which is to use channel zero. 
 */
public void initialize(){
  _selectChannel=null;
}","/** 
 * Initialize to the default, which is to use channel zero. 
 */
public void initialize(){
  _selectChannel=new IntToken(0);
}"
73107,"/** 
 * Add a pure event to the queue of pure events.
 * @param actor Actor to fire.
 * @param time Time the actor should be fired at.
 * @param index Microstep the actor should be fired at.
 * @return The time the actor requested to be refired at.
 * @exception IllegalActionException If firing of the container doesn't succeed.
 */
public Time fireAt(Actor actor,Time time,int index) throws IllegalActionException {
  if (actor == this.getContainer()) {
    fireContainerAt(time);
    return time;
  }
  int newIndex=index;
  if (index <= getIndex()) {
    newIndex=Math.max(getIndex(),index) + 1;
  }
  if (_isInitializing) {
    _currentSourceTimestamp=time;
  }
  _pureEvents.put(new PtidesEvent(actor,null,time,newIndex,0,_zeroTime,_currentSourceTimestamp));
  _currentSourceTimestamp=null;
  Time environmentTime=super.getEnvironmentTime();
  if (environmentTime.compareTo(time) <= 0) {
    fireContainerAt(time);
  }
  if (_isInitializing) {
  }
  return time;
}","/** 
 * Add a pure event to the queue of pure events.
 * @param actor Actor to fire.
 * @param time Time the actor should be fired at.
 * @param index Microstep the actor should be fired at.
 * @return The time the actor requested to be refired at.
 * @exception IllegalActionException If firing of the container doesn't succeed.
 */
public Time fireAt(Actor actor,Time time,int index) throws IllegalActionException {
  if (actor == this.getContainer()) {
    fireContainerAt(time);
    return time;
  }
  int newIndex=index;
  if (index <= getIndex()) {
    newIndex=Math.max(getIndex(),index) + 1;
  }
  if (_isInitializing) {
    _currentSourceTimestamp=time;
  }
  _pureEvents.put(new PtidesEvent(actor,null,time,newIndex,0,_zeroTime,_currentSourceTimestamp));
  Time environmentTime=super.getEnvironmentTime();
  if (environmentTime.compareTo(time) <= 0) {
    fireContainerAt(time);
  }
  if (_isInitializing) {
  }
  return time;
}"
73108,"/** 
 * Add a pure event to the queue of pure events.
 * @param actor Actor to fire.
 * @param time Time the actor should be fired at.
 * @param index Microstep the actor should be fired at.
 * @return The time the actor requested to be refired at.
 * @exception IllegalActionException If firing of the container doesn't succeed.
 */
public Time fireAt(Actor actor,Time time,int index) throws IllegalActionException {
  if (actor == this.getContainer()) {
    fireContainerAt(time);
    return time;
  }
  int newIndex=index;
  if (index <= getIndex()) {
    newIndex=Math.max(getIndex(),index) + 1;
  }
  if (_isInitializing) {
    _currentSourceTimestamp=time;
  }
  _pureEvents.put(new PtidesEvent(actor,null,time,newIndex,0,_zeroTime,_currentSourceTimestamp));
  Time environmentTime=super.getEnvironmentTime();
  if (environmentTime.compareTo(time) <= 0) {
    fireContainerAt(time);
  }
  if (_isInitializing) {
  }
  return time;
}","/** 
 * Add a pure event to the queue of pure events.
 * @param actor Actor to fire.
 * @param time Time the actor should be fired at.
 * @param index Microstep the actor should be fired at.
 * @return The time the actor requested to be refired at.
 * @exception IllegalActionException If firing of the container doesn't succeed.
 */
public Time fireAt(Actor actor,Time time,int index) throws IllegalActionException {
  if (actor == this.getContainer()) {
    fireContainerAt(time);
    return time;
  }
  int newIndex=index;
  if (index <= getIndex()) {
    newIndex=Math.max(getIndex(),index) + 1;
  }
  if (_isInitializing) {
    _currentSourceTimestamp=time;
  }
  _pureEvents.put(new PtidesEvent(actor,null,time,newIndex,0,_zeroTime,_currentSourceTimestamp));
  Time environmentTime=super.getEnvironmentTime();
  if (environmentTime.compareTo(time) <= 0) {
    fireContainerAt(time);
  }
  return time;
}"
73109,"/** 
 * Get the number of tokens that are produced on the given port during initialization.  If the port is not an output port, then return zero.  Otherwise, return the value of the port's <i>tokenInitProduction</i> parameter.   If the parameter does not exist, then assume the actor is zero-delay and return a value of zero.
 * @param port The given port.
 * @return The number of tokens the scheduler believes will be producedfrom the given output port during initialization.
 * @exception IllegalActionException If the tokenInitProductionparameter has an invalid expression.
 * @see #setTokenInitProduction
 */
public static int getTokenInitProduction(IOPort port) throws IllegalActionException {
  if (!port.isOutput()) {
    return 0;
  }
 else {
    return getRateVariableValue(port,""String_Node_Str"",0);
  }
}","/** 
 * Get the number of tokens that are produced on the given port during initialization.  If the port is not an output port, then the number of tokens is presumably the number of initial tokens produced on the inside of the port. The number of tokens returned is the value of the port's <i>tokenInitProduction</i> parameter.   If the parameter does not exist, then assume the actor is zero-delay and return a value of zero.
 * @param port The given port.
 * @return The number of tokens the scheduler believes will be producedfrom the given output port during initialization.
 * @exception IllegalActionException If the tokenInitProductionparameter has an invalid expression.
 * @see #setTokenInitProduction
 */
public static int getTokenInitProduction(IOPort port) throws IllegalActionException {
  return getRateVariableValue(port,""String_Node_Str"",0);
}"
73110,"/** 
 * Generate the initialize code for this director. The initialize code for the director is generated by appending the initialize code for each actor.
 * @return The generated initialize code.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating initialize code for the actor.
 */
public String generateInitializeCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  boolean variablesAsArrays=((BooleanToken)getCodeGenerator().variablesAsArrays.getToken()).booleanValue();
  if (variablesAsArrays) {
    CompositeActor container=(CompositeActor)_director.getContainer();
    StringBuffer code2=new StringBuffer();
    Iterator<?> ports=container.inputPortList().iterator();
    while (ports.hasNext()) {
      TypedIOPort port=(TypedIOPort)ports.next();
      int rate=DFUtilities.getTokenInitProduction(port);
      if (rate > 0) {
        int bufferSize=_ports.getBufferSize(port);
        code2.append(generatePortName(port) + ""String_Node_Str"" + targetType(port.getType())+ ""String_Node_Str""+ java.lang.Math.max(port.getWidth(),port.getWidthInside())+ ""String_Node_Str""+ ""String_Node_Str""+ bufferSize+ ""String_Node_Str""+ _eol);
      }
 else       if (port.getWidth() > 1 || port.getWidthInside() > 1) {
        code2.append(generatePortName(port) + ""String_Node_Str"" + targetType(port.getType())+ ""String_Node_Str""+ java.lang.Math.max(port.getWidth(),port.getWidthInside())+ ""String_Node_Str""+ _eol);
      }
    }
    ports=container.outputPortList().iterator();
    while (ports.hasNext()) {
      TypedIOPort port=(TypedIOPort)ports.next();
      int rate=DFUtilities.getTokenInitProduction(port);
      if (rate > 0) {
        int bufferSize=_ports.getBufferSize(port);
        code2.append(generatePortName(port) + ""String_Node_Str"" + targetType(port.getType())+ ""String_Node_Str""+ java.lang.Math.max(port.getWidth(),port.getWidthInside())+ ""String_Node_Str""+ ""String_Node_Str""+ bufferSize+ ""String_Node_Str""+ _eol);
      }
 else       if (port.getWidth() > 1 || port.getWidthInside() > 1) {
        code2.append(generatePortName(port) + ""String_Node_Str"" + targetType(port.getType())+ ""String_Node_Str""+ java.lang.Math.max(port.getWidth(),port.getWidthInside())+ ""String_Node_Str""+ _eol);
      }
    }
    if (code2.length() > 0) {
      code.append(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"") + code2.toString());
    }
    code.append(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str""));
    Iterator<?> actors=container.deepEntityList().iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
      if (actor instanceof CompositeActor && ((CompositeActor)actor).isOpaque()) {
        code.append(getCodeGenerator().comment(""String_Node_Str"" + actor.getFullName()));
      }
 else {
        code.append(_generatePortVariableDeclaration(adapterObject));
        if (variablesAsArrays) {
          code.append(getCodeGenerator().comment(""String_Node_Str""));
          ports=actor.outputPortList().iterator();
          while (ports.hasNext()) {
            TypedIOPort port=(TypedIOPort)ports.next();
            int rate=DFUtilities.getTokenInitProduction(port);
            int bufferSize=_ports.getBufferSize(port);
            if (port.isMultiport() && rate > 0) {
              code.append(generatePortName(port) + ""String_Node_Str"" + targetType(port.getType())+ ""String_Node_Str""+ java.lang.Math.max(port.getWidth(),port.getWidthInside())+ ""String_Node_Str""+ ""String_Node_Str""+ bufferSize+ ""String_Node_Str""+ _eol);
            }
          }
        }
      }
    }
  }
  code.append(super.generateInitializeCode());
  return code.toString();
}","/** 
 * Generate the initialize code for this director. The initialize code for the director is generated by appending the initialize code for each actor.
 * @return The generated initialize code.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating initialize code for the actor.
 */
public String generateInitializeCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  boolean variablesAsArrays=((BooleanToken)getCodeGenerator().variablesAsArrays.getToken()).booleanValue();
  if (variablesAsArrays) {
    CompositeActor container=(CompositeActor)_director.getContainer();
    StringBuffer code2=new StringBuffer();
    Iterator<?> ports=container.inputPortList().iterator();
    while (ports.hasNext()) {
      TypedIOPort port=(TypedIOPort)ports.next();
      int rate=DFUtilities.getTokenInitConsumption(port);
      if (rate > 0) {
        int bufferSize=_ports.getBufferSize(port);
        code2.append(generatePortName(port) + ""String_Node_Str"" + targetType(port.getType())+ ""String_Node_Str""+ java.lang.Math.max(port.getWidth(),port.getWidthInside())+ ""String_Node_Str""+ ""String_Node_Str""+ bufferSize+ ""String_Node_Str""+ _eol);
      }
 else       if (port.getWidth() > 1 || port.getWidthInside() > 1) {
        code2.append(generatePortName(port) + ""String_Node_Str"" + targetType(port.getType())+ ""String_Node_Str""+ java.lang.Math.max(port.getWidth(),port.getWidthInside())+ ""String_Node_Str""+ _eol);
      }
    }
    ports=container.outputPortList().iterator();
    while (ports.hasNext()) {
      TypedIOPort port=(TypedIOPort)ports.next();
      int rate=DFUtilities.getTokenInitProduction(port);
      if (rate > 0) {
        int bufferSize=_ports.getBufferSize(port);
        code2.append(generatePortName(port) + ""String_Node_Str"" + targetType(port.getType())+ ""String_Node_Str""+ java.lang.Math.max(port.getWidth(),port.getWidthInside())+ ""String_Node_Str""+ ""String_Node_Str""+ bufferSize+ ""String_Node_Str""+ _eol);
      }
 else       if (port.getWidth() > 1 || port.getWidthInside() > 1) {
        code2.append(generatePortName(port) + ""String_Node_Str"" + targetType(port.getType())+ ""String_Node_Str""+ java.lang.Math.max(port.getWidth(),port.getWidthInside())+ ""String_Node_Str""+ _eol);
      }
    }
    if (code2.length() > 0) {
      code.append(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"") + code2.toString());
    }
    code.append(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str""));
    Iterator<?> actors=container.deepEntityList().iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
      if (actor instanceof CompositeActor && ((CompositeActor)actor).isOpaque()) {
        code.append(getCodeGenerator().comment(""String_Node_Str"" + actor.getFullName()));
      }
 else {
        code.append(_generatePortVariableDeclaration(adapterObject));
        if (variablesAsArrays) {
          code.append(getCodeGenerator().comment(""String_Node_Str""));
          ports=actor.outputPortList().iterator();
          while (ports.hasNext()) {
            TypedIOPort port=(TypedIOPort)ports.next();
            int rate=DFUtilities.getTokenInitProduction(port);
            int bufferSize=_ports.getBufferSize(port);
            if (port.isMultiport() && rate > 0) {
              code.append(generatePortName(port) + ""String_Node_Str"" + targetType(port.getType())+ ""String_Node_Str""+ java.lang.Math.max(port.getWidth(),port.getWidthInside())+ ""String_Node_Str""+ ""String_Node_Str""+ bufferSize+ ""String_Node_Str""+ _eol);
            }
          }
        }
      }
    }
  }
  code.append(super.generateInitializeCode());
  return code.toString();
}"
73111,"/** 
 * Simulate the consumption of tokens from the given external input port.  This assumes the input ports have the number of tokens given by their rate.
 * @param port The external input port.
 * @param count The number of tokens assumed to be on that port.
 * @param actorList The list of actors.
 * @param readyToScheduleActorList The list of actors that are readyto be scheduled.  This will be updated if any actors that receive tokens from outputPort are now ready to fire.
 * @exception IllegalActionException If thrown while reading a token,setting the capacity of a receiver or counting unfulfilled input.s
 */
@SuppressWarnings(""String_Node_Str"") protected void _simulateExternalInputs(IOPort port,int count,List actorList,LinkedList readyToScheduleActorList) throws IllegalActionException {
  Receiver[][] receivers=port.deepGetReceivers();
  if (_debugging && VERBOSE) {
    _debug(""String_Node_Str"" + port.getFullName());
    _debug(""String_Node_Str"" + receivers.length);
  }
  for (int channel=0; channel < receivers.length; channel++) {
    if (receivers[channel] == null) {
      continue;
    }
    for (int copy=0; copy < receivers[channel].length; copy++) {
      if (!(receivers[channel][copy] instanceof SDFReceiver)) {
        continue;
      }
      SDFReceiver receiver=(SDFReceiver)receivers[channel][copy];
      IOPort connectedPort=receivers[channel][copy].getContainer();
      ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
      receiver._waitingTokens=count;
      boolean enforce=((BooleanToken)constrainBufferSizes.getToken()).booleanValue();
      if (enforce) {
        int capacity=receiver.getCapacity();
        if ((capacity == SDFReceiver.INFINITE_CAPACITY) || (receiver._waitingTokens > capacity)) {
          receiver.setCapacity(count);
        }
      }
      if (actorList.contains(connectedActor)) {
        int inputCount=_countUnfulfilledInputs((Actor)connectedActor,actorList,false);
        int firingsRemaining=_getFiringCount(connectedActor);
        if ((inputCount < 1) && (firingsRemaining > 0)) {
          readyToScheduleActorList.addFirst(connectedActor);
        }
      }
    }
  }
}","/** 
 * Simulate the consumption of tokens from the given external input port.  This assumes the input ports have the number of tokens given by their rate.
 * @param port The external input port.
 * @param count The number of tokens assumed to be on that port.
 * @param actorList The list of actors.
 * @param readyToScheduleActorList The list of actors that are readyto be scheduled.  This will be updated if any actors that receive tokens from outputPort are now ready to fire.
 * @exception IllegalActionException If thrown while reading a token,setting the capacity of a receiver or counting unfulfilled input.s
 */
@SuppressWarnings(""String_Node_Str"") protected void _simulateExternalInputs(IOPort port,int count,List actorList,LinkedList readyToScheduleActorList) throws IllegalActionException {
  Receiver[][] receivers=port.deepGetReceivers();
  if (_debugging && VERBOSE) {
    _debug(""String_Node_Str"" + port.getFullName());
    _debug(""String_Node_Str"" + receivers.length);
  }
  for (int channel=0; channel < receivers.length; channel++) {
    if (receivers[channel] == null) {
      continue;
    }
    for (int copy=0; copy < receivers[channel].length; copy++) {
      if (!(receivers[channel][copy] instanceof SDFReceiver)) {
        continue;
      }
      SDFReceiver receiver=(SDFReceiver)receivers[channel][copy];
      IOPort connectedPort=receivers[channel][copy].getContainer();
      ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
      count+=DFUtilities.getTokenInitConsumption(connectedPort);
      receiver._waitingTokens=count;
      boolean enforce=((BooleanToken)constrainBufferSizes.getToken()).booleanValue();
      if (enforce) {
        int capacity=receiver.getCapacity();
        if ((capacity == SDFReceiver.INFINITE_CAPACITY) || (receiver._waitingTokens > capacity)) {
          receiver.setCapacity(count);
        }
      }
      if (actorList.contains(connectedActor)) {
        int inputCount=_countUnfulfilledInputs((Actor)connectedActor,actorList,false);
        int firingsRemaining=_getFiringCount(connectedActor);
        if ((inputCount < 1) && (firingsRemaining > 0)) {
          readyToScheduleActorList.addFirst(connectedActor);
        }
      }
    }
  }
}"
73112,"/** 
 * Create a schedule for a set of actors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param externalRates Map from external port to an Integerrepresenting the number of tokens produced or consumed from that port during the course of an iteration.
 * @param actorList The actors that need to be scheduled.
 * @param container The container.
 * @return An instance of the Schedule class, indicating the orderin which actors should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
@SuppressWarnings(""String_Node_Str"") private Schedule _scheduleConnectedActors(Map externalRates,List actorList,CompositeActor container) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  Schedule newSchedule=new Schedule();
  Map firingsRemainingVector=new HashMap();
  firingsRemainingVector.putAll(_firingVector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator actorsIterator=actorList.iterator();
    while (actorsIterator.hasNext()) {
      Actor actor=(Actor)actorsIterator.next();
      Iterator inputPorts=actor.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort inputPort=(IOPort)inputPorts.next();
        Receiver[][] receivers=inputPort.getReceivers();
        if (receivers != null) {
          for (int m=0; m < receivers.length; m++) {
            for (int n=0; n < receivers[m].length; n++) {
              ((SDFReceiver)receivers[m][n])._waitingTokens=0;
            }
          }
        }
      }
    }
    Iterator externalOutputPorts=container.outputPortList().iterator();
    while (externalOutputPorts.hasNext()) {
      IOPort outputPort=(IOPort)externalOutputPorts.next();
      Receiver[][] receivers=outputPort.getInsideReceivers();
      if (receivers != null) {
        for (int m=0; m < receivers.length; m++) {
          for (int n=0; n < receivers[m].length; n++) {
            ((SDFReceiver)receivers[m][n])._waitingTokens=0;
          }
        }
      }
    }
    Iterator actors=actorList.iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      int firingsRemaining=((Integer)firingsRemainingVector.get(actor)).intValue();
      if (firingsRemaining == 0) {
        unscheduledActorList.remove(actor);
        continue;
      }
      int inputCount=_countUnfulfilledInputs(actor,actorList,true);
      if (inputCount == 0) {
        readyToScheduleActorList.addFirst(actor);
      }
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + ((ComponentEntity)actor).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
      }
    }
    actors=actorList.iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      Iterator outputPorts=actor.outputPortList().iterator();
      while (outputPorts.hasNext()) {
        IOPort outputPort=(IOPort)outputPorts.next();
        int count=DFUtilities.getTokenInitProduction(outputPort);
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"" + count + ""String_Node_Str""+ outputPort);
        }
        if (count > 0) {
          _simulateTokensCreated(outputPort,count,actorList,readyToScheduleActorList);
        }
      }
      Iterator inputPorts=actor.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort inputPort=(IOPort)inputPorts.next();
        int count=DFUtilities.getTokenInitConsumption(inputPort);
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"" + count + ""String_Node_Str""+ inputPort);
        }
        if (count > 0) {
          _simulateInitialTokens(inputPort,count,actorList,readyToScheduleActorList);
        }
      }
    }
    for (Iterator inputPorts=container.inputPortList().iterator(); inputPorts.hasNext(); ) {
      IOPort port=(IOPort)inputPorts.next();
      int count=((Integer)externalRates.get(port)).intValue();
      if (count > 0) {
        _simulateExternalInputs(port,count,actorList,readyToScheduleActorList);
      }
    }
    while (readyToScheduleActorList.size() > 0) {
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"");
        for (Iterator readyActors=readyToScheduleActorList.iterator(); readyActors.hasNext(); ) {
          Entity readyActor=(Entity)readyActors.next();
          _debug(readyActor.getFullName());
        }
        _debug(""String_Node_Str"");
        for (Iterator remainingActors=unscheduledActorList.iterator(); remainingActors.hasNext(); ) {
          Entity remainingActor=(Entity)remainingActors.next();
          _debug(remainingActor.getFullName());
        }
      }
      Actor currentActor=(Actor)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor)) {
      }
      int numberOfFirings=_computeMaximumFirings(currentActor);
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      if (numberOfFirings > firingsRemaining) {
        numberOfFirings=firingsRemaining;
      }
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + currentActor.getName() + ""String_Node_Str""+ numberOfFirings+ ""String_Node_Str"");
      }
      firingsRemaining-=numberOfFirings;
      firingsRemainingVector.put(currentActor,Integer.valueOf(firingsRemaining));
      if (_debugging && VERBOSE) {
        _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      }
      _simulateInputConsumption(currentActor,numberOfFirings);
      Firing firing=new Firing();
      firing.setActor(currentActor);
      firing.setIterationCount(numberOfFirings);
      newSchedule.add(firing);
      for (Iterator outputPorts=(currentActor).outputPortList().iterator(); outputPorts.hasNext(); ) {
        IOPort outputPort=(IOPort)outputPorts.next();
        int count=DFUtilities.getTokenProductionRate(outputPort);
        _simulateTokensCreated(outputPort,count * numberOfFirings,unscheduledActorList,readyToScheduleActorList);
      }
      if (firingsRemaining < 0) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      if (firingsRemaining == 0) {
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"" + currentActor + ""String_Node_Str"");
        }
        while (unscheduledActorList.remove(currentActor)) {
          ;
        }
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"");
          for (Iterator readyActors=readyToScheduleActorList.iterator(); readyActors.hasNext(); ) {
            Entity entity=(Entity)readyActors.next();
            _debug(entity.getFullName());
          }
        }
      }
 else {
        int inputCount=_countUnfulfilledInputs(currentActor,unscheduledActorList,false);
        if ((inputCount <= 0) && unscheduledActorList.contains(currentActor)) {
          readyToScheduleActorList.addFirst(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(this,ex,""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    StringBuffer message=new StringBuffer(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    int count=0;
    for (Iterator actors=unscheduledActorList.iterator(); actors.hasNext() && count < 100; count++) {
      Entity entity=(Entity)actors.next();
      message.append(entity.getFullName() + ""String_Node_Str"");
    }
    if (count >= 99) {
      message.append(""String_Node_Str"");
    }
    message.append(""String_Node_Str"");
    List scheduledActorList=new LinkedList();
    scheduledActorList.addAll(actorList);
    scheduledActorList.removeAll(unscheduledActorList);
    count=0;
    for (Iterator actors=scheduledActorList.iterator(); actors.hasNext() && count < 100; count++) {
      Entity entity=(Entity)actors.next();
      message.append(entity.getFullName() + ""String_Node_Str"");
    }
    if (count >= 99) {
      message.append(""String_Node_Str"");
    }
    throw new NotSchedulableException(this,message.toString());
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(newSchedule.toString());
  }
  return newSchedule;
}","/** 
 * Create a schedule for a set of actors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param externalRates Map from external port to an Integerrepresenting the number of tokens produced or consumed from that port during the course of an iteration.
 * @param actorList The actors that need to be scheduled.
 * @param container The container.
 * @return An instance of the Schedule class, indicating the orderin which actors should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
@SuppressWarnings(""String_Node_Str"") private Schedule _scheduleConnectedActors(Map externalRates,List actorList,CompositeActor container) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  Schedule newSchedule=new Schedule();
  Map firingsRemainingVector=new HashMap();
  firingsRemainingVector.putAll(_firingVector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator actorsIterator=actorList.iterator();
    while (actorsIterator.hasNext()) {
      Actor actor=(Actor)actorsIterator.next();
      Iterator inputPorts=actor.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort inputPort=(IOPort)inputPorts.next();
        Receiver[][] receivers=inputPort.getReceivers();
        if (receivers != null) {
          for (int m=0; m < receivers.length; m++) {
            for (int n=0; n < receivers[m].length; n++) {
              ((SDFReceiver)receivers[m][n])._waitingTokens=0;
            }
          }
        }
      }
    }
    Iterator externalOutputPorts=container.outputPortList().iterator();
    while (externalOutputPorts.hasNext()) {
      IOPort outputPort=(IOPort)externalOutputPorts.next();
      Receiver[][] receivers=outputPort.getInsideReceivers();
      if (receivers != null) {
        for (int m=0; m < receivers.length; m++) {
          for (int n=0; n < receivers[m].length; n++) {
            ((SDFReceiver)receivers[m][n])._waitingTokens=0;
          }
        }
      }
    }
    Iterator actors=actorList.iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      int firingsRemaining=((Integer)firingsRemainingVector.get(actor)).intValue();
      if (firingsRemaining == 0) {
        unscheduledActorList.remove(actor);
        continue;
      }
      int inputCount=_countUnfulfilledInputs(actor,actorList,true);
      if (inputCount == 0) {
        readyToScheduleActorList.addFirst(actor);
      }
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + ((ComponentEntity)actor).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
      }
    }
    actors=actorList.iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      Iterator outputPorts=actor.outputPortList().iterator();
      while (outputPorts.hasNext()) {
        IOPort outputPort=(IOPort)outputPorts.next();
        int count=DFUtilities.getTokenInitProduction(outputPort);
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"" + count + ""String_Node_Str""+ outputPort);
        }
        if (count > 0) {
          _simulateTokensCreated(outputPort,count,actorList,readyToScheduleActorList);
        }
      }
      Iterator inputPorts=actor.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort inputPort=(IOPort)inputPorts.next();
        int count=DFUtilities.getTokenInitConsumption(inputPort);
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"" + count + ""String_Node_Str""+ inputPort);
        }
        if (count > 0) {
          _simulateInitialTokens(inputPort,count,actorList,readyToScheduleActorList);
        }
      }
    }
    for (Iterator inputPorts=container.inputPortList().iterator(); inputPorts.hasNext(); ) {
      IOPort port=(IOPort)inputPorts.next();
      int count=((Integer)externalRates.get(port)).intValue();
      count+=DFUtilities.getTokenInitProduction(port);
      if (count > 0) {
        _simulateExternalInputs(port,count,actorList,readyToScheduleActorList);
      }
    }
    for (Iterator outputPorts=container.outputPortList().iterator(); outputPorts.hasNext(); ) {
      IOPort port=(IOPort)outputPorts.next();
      int count=DFUtilities.getTokenInitProduction(port);
      if (count > 0) {
        _simulateInitialOutputTokens(port,count);
      }
    }
    while (readyToScheduleActorList.size() > 0) {
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"");
        for (Iterator readyActors=readyToScheduleActorList.iterator(); readyActors.hasNext(); ) {
          Entity readyActor=(Entity)readyActors.next();
          _debug(readyActor.getFullName());
        }
        _debug(""String_Node_Str"");
        for (Iterator remainingActors=unscheduledActorList.iterator(); remainingActors.hasNext(); ) {
          Entity remainingActor=(Entity)remainingActors.next();
          _debug(remainingActor.getFullName());
        }
      }
      Actor currentActor=(Actor)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor)) {
      }
      int numberOfFirings=_computeMaximumFirings(currentActor);
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      if (numberOfFirings > firingsRemaining) {
        numberOfFirings=firingsRemaining;
      }
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + currentActor.getName() + ""String_Node_Str""+ numberOfFirings+ ""String_Node_Str"");
      }
      firingsRemaining-=numberOfFirings;
      firingsRemainingVector.put(currentActor,Integer.valueOf(firingsRemaining));
      if (_debugging && VERBOSE) {
        _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      }
      _simulateInputConsumption(currentActor,numberOfFirings);
      Firing firing=new Firing();
      firing.setActor(currentActor);
      firing.setIterationCount(numberOfFirings);
      newSchedule.add(firing);
      for (Iterator outputPorts=(currentActor).outputPortList().iterator(); outputPorts.hasNext(); ) {
        IOPort outputPort=(IOPort)outputPorts.next();
        int count=DFUtilities.getTokenProductionRate(outputPort);
        _simulateTokensCreated(outputPort,count * numberOfFirings,unscheduledActorList,readyToScheduleActorList);
      }
      if (firingsRemaining < 0) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      if (firingsRemaining == 0) {
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"" + currentActor + ""String_Node_Str"");
        }
        while (unscheduledActorList.remove(currentActor)) {
          ;
        }
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"");
          for (Iterator readyActors=readyToScheduleActorList.iterator(); readyActors.hasNext(); ) {
            Entity entity=(Entity)readyActors.next();
            _debug(entity.getFullName());
          }
        }
      }
 else {
        int inputCount=_countUnfulfilledInputs(currentActor,unscheduledActorList,false);
        if ((inputCount <= 0) && unscheduledActorList.contains(currentActor)) {
          readyToScheduleActorList.addFirst(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(this,ex,""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    StringBuffer message=new StringBuffer(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    int count=0;
    for (Iterator actors=unscheduledActorList.iterator(); actors.hasNext() && count < 100; count++) {
      Entity entity=(Entity)actors.next();
      message.append(entity.getFullName() + ""String_Node_Str"");
    }
    if (count >= 99) {
      message.append(""String_Node_Str"");
    }
    message.append(""String_Node_Str"");
    List scheduledActorList=new LinkedList();
    scheduledActorList.addAll(actorList);
    scheduledActorList.removeAll(unscheduledActorList);
    count=0;
    for (Iterator actors=scheduledActorList.iterator(); actors.hasNext() && count < 100; count++) {
      Entity entity=(Entity)actors.next();
      message.append(entity.getFullName() + ""String_Node_Str"");
    }
    if (count >= 99) {
      message.append(""String_Node_Str"");
    }
    throw new NotSchedulableException(this,message.toString());
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(newSchedule.toString());
  }
  return newSchedule;
}"
73113,"/** 
 * Add to the specified result list the bounds of the icon for the specified object.
 * @param result The list to add to.
 * @param viewSize The view size.
 * @param scaleX The x scaling factor.
 * @param scaleY The y scaling factor.
 * @param translateX The x translation.
 * @param translateY The y translation.
 * @param object The object to add.
 */
private void _addRectangle(List<IconVisibleLocation> result,Rectangle2D viewSize,double scaleX,double scaleY,double translateX,double translateY,NamedObj object){
  Locatable location=null;
  try {
    location=(Locatable)object.getAttribute(""String_Node_Str"",Locatable.class);
  }
 catch (  IllegalActionException e1) {
  }
  if (location != null) {
    GraphController controller=_basicGraphFrame.getJGraph().getGraphPane().getGraphController();
    Figure figure=controller.getFigure(location);
    if (figure != null) {
      Rectangle2D figureBounds=figure.getShape().getBounds2D();
      double width=figureBounds.getWidth();
      double height=figureBounds.getHeight();
      IconVisibleLocation i=new IconVisibleLocation();
      i.object=object;
      i.topLeftX=figureBounds.getX() * scaleX + translateX - _PADDING;
      i.topLeftY=figureBounds.getY() * scaleY + translateY - _PADDING;
      i.bottomRightX=i.topLeftX + (width * scaleX) + 2 * _PADDING;
      i.bottomRightY=i.topLeftY + (height * scaleY) + 2 * _PADDING;
      if (i.bottomRightX < 0.0 || i.bottomRightY < 0.0 || i.topLeftX > viewSize.getWidth() || i.topLeftY > viewSize.getHeight()) {
        return;
      }
 else {
        if (i.topLeftX < 0.0) {
          i.topLeftX=0.0;
        }
        if (i.topLeftY < 0.0) {
          i.topLeftY=0.0;
        }
        if (i.bottomRightX > viewSize.getWidth()) {
          i.bottomRightX=viewSize.getWidth();
        }
        if (i.bottomRightY > viewSize.getHeight()) {
          i.bottomRightY=viewSize.getHeight();
        }
        result.add(i);
      }
    }
  }
}","/** 
 * Add to the specified result list the bounds of the icon for the specified object.
 * @param result The list to add to.
 * @param viewSize The view size.
 * @param scaleX The x scaling factor.
 * @param scaleY The y scaling factor.
 * @param translateX The x translation.
 * @param translateY The y translation.
 * @param object The object to add.
 */
private void _addRectangle(List<IconVisibleLocation> result,Rectangle2D viewSize,double scaleX,double scaleY,double translateX,double translateY,NamedObj object){
  Locatable location=null;
  try {
    location=(Locatable)object.getAttribute(""String_Node_Str"",Locatable.class);
  }
 catch (  IllegalActionException e1) {
  }
  if (location != null) {
    GraphController controller=_basicGraphFrame.getJGraph().getGraphPane().getGraphController();
    Figure figure=controller.getFigure(location);
    if (figure != null) {
      Rectangle2D figureBounds=figure.getShape().getBounds2D();
      double width=figureBounds.getWidth();
      double height=figureBounds.getHeight();
      IconVisibleLocation i=new IconVisibleLocation();
      i.object=object;
      i.topLeftX=figureBounds.getX() * scaleX + translateX - _PADDING;
      i.topLeftY=figureBounds.getY() * scaleY + translateY - _PADDING;
      i.bottomRightX=i.topLeftX + (width * scaleX) + 2 * _PADDING;
      i.bottomRightY=i.topLeftY + (height * scaleY) + 2 * _PADDING;
      if (i.bottomRightX < 0.0 || i.bottomRightY < 0.0 || i.topLeftX > viewSize.getWidth() || i.topLeftY > viewSize.getHeight()) {
        return;
      }
 else {
        if (i.topLeftX < 0.0) {
          i.topLeftX=0.0;
        }
        if (i.topLeftY < 0.0) {
          i.topLeftY=0.0;
        }
        if (i.bottomRightX > viewSize.getWidth()) {
          i.bottomRightX=viewSize.getWidth();
        }
        if (i.bottomRightY > viewSize.getHeight()) {
          i.bottomRightY=viewSize.getHeight();
        }
        result.add(0,i);
      }
    }
  }
}"
73114,"/** 
 * Provide content to the specified web exporter to be included in a web page. This class provides a default title for the web page and for each object as specified by <i>include</i> and <i>instancesOf</i>.
 * @param exporter  The web exporter to which to write content.
 * @exception IllegalActionException If something is wrong with the webcontent or the object already has an attribute with the same name as the the created WebAttribute
 */
protected void _provideAttributes(WebExporter exporter) throws IllegalActionException {
  WebAttribute webAttribute;
  String titleValue=stringValue();
  if (titleValue == null || titleValue.equals(""String_Node_Str"")) {
    titleValue=toplevel().getName();
  }
  exporter.setTitle(titleValue,((BooleanToken)showTitleInHTML.getToken()).booleanValue());
  webAttribute=WebAttribute.createWebAttribute(getContainer(),""String_Node_Str"",""String_Node_Str"");
  webAttribute.setExpression(titleValue);
  exporter.defineAttribute(webAttribute,true);
  boolean entities=false, attributes=false;
  String includeValue=include.stringValue().toLowerCase();
  if (includeValue.equals(""String_Node_Str"")) {
    entities=true;
    attributes=true;
  }
 else   if (includeValue.equals(""String_Node_Str"")) {
    entities=true;
  }
 else   if (includeValue.equals(""String_Node_Str"")) {
    attributes=true;
  }
  List<NamedObj> objects;
  String instances=instancesOf.stringValue();
  NamedObj container=getContainer();
  if (entities && container instanceof CompositeEntity) {
    if (instances.trim().equals(""String_Node_Str"")) {
      objects=((CompositeEntity)container).entityList();
    }
 else {
      try {
        Class restrict=Class.forName(instances);
        objects=((CompositeEntity)container).entityList(restrict);
      }
 catch (      ClassNotFoundException e) {
        throw new IllegalActionException(this,""String_Node_Str"" + instances);
      }
    }
    for (    NamedObj object : objects) {
      webAttribute=WebAttribute.createWebAttribute(object,""String_Node_Str"",""String_Node_Str"");
      webAttribute.setExpression(object.getName());
      exporter.defineAttribute(webAttribute,true);
    }
  }
  if (attributes) {
    if (instances.trim().equals(""String_Node_Str"")) {
      objects=((CompositeEntity)container).attributeList();
    }
 else {
      try {
        Class restrict=Class.forName(instances);
        objects=((CompositeEntity)container).attributeList(restrict);
      }
 catch (      ClassNotFoundException e) {
        throw new IllegalActionException(this,""String_Node_Str"" + instances);
      }
    }
    for (    NamedObj object : objects) {
      webAttribute=WebAttribute.createWebAttribute(object,""String_Node_Str"",""String_Node_Str"");
      webAttribute.setExpression(object.getName());
      exporter.defineAttribute(webAttribute,true);
    }
  }
}","/** 
 * Provide content to the specified web exporter to be included in a web page. This class provides a default title for the web page and for each object as specified by <i>include</i> and <i>instancesOf</i>.
 * @param exporter  The web exporter to which to write content.
 * @exception IllegalActionException If something is wrong with the webcontent or the object already has an attribute with the same name as the the created WebAttribute
 */
protected void _provideAttributes(WebExporter exporter) throws IllegalActionException {
  WebAttribute webAttribute;
  String titleValue=stringValue();
  if (titleValue == null || titleValue.equals(""String_Node_Str"")) {
    titleValue=toplevel().getDisplayName();
  }
  exporter.setTitle(titleValue,((BooleanToken)showTitleInHTML.getToken()).booleanValue());
  webAttribute=WebAttribute.createWebAttribute(getContainer(),""String_Node_Str"",""String_Node_Str"");
  webAttribute.setExpression(titleValue);
  exporter.defineAttribute(webAttribute,true);
  boolean entities=false, attributes=false;
  String includeValue=include.stringValue().toLowerCase();
  if (includeValue.equals(""String_Node_Str"")) {
    entities=true;
    attributes=true;
  }
 else   if (includeValue.equals(""String_Node_Str"")) {
    entities=true;
  }
 else   if (includeValue.equals(""String_Node_Str"")) {
    attributes=true;
  }
  List<NamedObj> objects;
  String instances=instancesOf.stringValue();
  NamedObj container=getContainer();
  if (entities && container instanceof CompositeEntity) {
    if (instances.trim().equals(""String_Node_Str"")) {
      objects=((CompositeEntity)container).entityList();
    }
 else {
      try {
        Class restrict=Class.forName(instances);
        objects=((CompositeEntity)container).entityList(restrict);
      }
 catch (      ClassNotFoundException e) {
        throw new IllegalActionException(this,""String_Node_Str"" + instances);
      }
    }
    for (    NamedObj object : objects) {
      webAttribute=WebAttribute.createWebAttribute(object,""String_Node_Str"",""String_Node_Str"");
      webAttribute.setExpression(object.getDisplayName());
      exporter.defineAttribute(webAttribute,true);
    }
  }
  if (attributes) {
    if (instances.trim().equals(""String_Node_Str"")) {
      objects=((CompositeEntity)container).attributeList();
    }
 else {
      try {
        Class restrict=Class.forName(instances);
        objects=((CompositeEntity)container).attributeList(restrict);
      }
 catch (      ClassNotFoundException e) {
        throw new IllegalActionException(this,""String_Node_Str"" + instances);
      }
    }
    for (    NamedObj object : objects) {
      webAttribute=WebAttribute.createWebAttribute(object,""String_Node_Str"",""String_Node_Str"");
      webAttribute.setExpression(object.getDisplayName());
      exporter.defineAttribute(webAttribute,true);
    }
  }
}"
73115,"/** 
 * Provide a title for this object to the specified web exporter.
 * @param exporter The WebExporter to add content to
 * @exception IllegalActionException If something is wrong with thespecification of the content.
 */
protected void _provideAttributes(WebExporter exporter) throws IllegalActionException {
  WebAttribute webAttribute=WebAttribute.createWebAttribute(getContainer(),""String_Node_Str"",""String_Node_Str"");
  webAttribute.setExpression(stringValue());
  exporter.defineAttribute(webAttribute,true);
}","/** 
 * Provide a title for this object to the specified web exporter.
 * @param exporter The WebExporter to add content to
 * @exception IllegalActionException If something is wrong with thespecification of the content.
 */
protected void _provideAttributes(WebExporter exporter) throws IllegalActionException {
  exporter.setTitle(stringValue(),((BooleanToken)showTitleInHTML.getToken()).booleanValue());
  WebAttribute webAttribute=WebAttribute.createWebAttribute(getContainer(),""String_Node_Str"",""String_Node_Str"");
  webAttribute.setExpression(stringValue());
  exporter.defineAttribute(webAttribute,true);
}"
73116,"/** 
 * Construct an actor in the default workspace with an empty string as its name.  The object is added to the workspace directory. Increment the version number of the workspace.
 */
public ErrorHandlingAction(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  action=new Parameter(this,""String_Node_Str"");
  action.setTypeEquals(BaseType.STRING);
  action.addChoice(""String_Node_Str"" + DropEvent + ""String_Node_Str"");
  action.addChoice(""String_Node_Str"" + ExecuteEvent + ""String_Node_Str"");
  action.addChoice(""String_Node_Str"" + FixTimestamp + ""String_Node_Str"");
  action.addChoice(""String_Node_Str"" + ClearAllEvents + ""String_Node_Str"");
  action.addChoice(""String_Node_Str"" + ClearEarlierEvents + ""String_Node_Str"");
  action.addChoice(""String_Node_Str"" + ClearCorruptEvents + ""String_Node_Str"");
  action.setExpression(""String_Node_Str"" + DropEvent + ""String_Node_Str"");
  delayed.setExpression(""String_Node_Str"");
}","/** 
 * Construct an ErrorHandlingAction in the container with  a specified name.
 * @param container The container for this actor.
 * @param name The name of this actor.
 * @exception NameDuplicationException Thrown if the name is already used.
 * @exception IllegalActionException Thrown if parameters cannot be created.
 */
public ErrorHandlingAction(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  action=new Parameter(this,""String_Node_Str"");
  action.setTypeEquals(BaseType.STRING);
  action.addChoice(""String_Node_Str"" + DropEvent + ""String_Node_Str"");
  action.addChoice(""String_Node_Str"" + ExecuteEvent + ""String_Node_Str"");
  action.addChoice(""String_Node_Str"" + FixTimestamp + ""String_Node_Str"");
  action.addChoice(""String_Node_Str"" + ClearAllEvents + ""String_Node_Str"");
  action.addChoice(""String_Node_Str"" + ClearEarlierEvents + ""String_Node_Str"");
  action.addChoice(""String_Node_Str"" + ClearCorruptEvents + ""String_Node_Str"");
  action.setExpression(""String_Node_Str"" + DropEvent + ""String_Node_Str"");
  delayed.setExpression(""String_Node_Str"");
}"
73117,"@Override public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == action) {
    String string=((StringToken)action.getToken()).stringValue();
    variableName.setExpression(string);
    if (getContainer() instanceof CompositeActor) {
      CompositeActor container=(CompositeActor)getContainer();
      while (!container.getName().equals(""String_Node_Str"")) {
        if (container == container.toplevel()) {
          throw new IllegalActionException(this,""String_Node_Str"");
        }
        container=(CompositeActor)getContainer();
      }
      if (container.getAttribute(string) == null) {
        try {
          Parameter parameter=new Parameter(container,string);
          parameter.setExpression(""String_Node_Str"");
        }
 catch (        NameDuplicationException e) {
        }
      }
    }
  }
  super.attributeChanged(attribute);
}","/** 
 * Upon choosing an error handling action, set the variableName of this actor and make sure the corresponding parameter is in the container.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == action) {
    String string=((StringToken)action.getToken()).stringValue();
    variableName.setExpression(string);
    if (getContainer() instanceof CompositeActor) {
      CompositeActor container=(CompositeActor)getContainer();
      while (!container.getName().equals(""String_Node_Str"")) {
        if (container == container.toplevel()) {
          throw new IllegalActionException(this,""String_Node_Str"");
        }
        container=(CompositeActor)container.getContainer();
      }
      if (container.getAttribute(string) == null) {
        try {
          Parameter parameter=new Parameter(container,string);
          parameter.setExpression(""String_Node_Str"");
        }
 catch (        NameDuplicationException e) {
        }
      }
    }
  }
  super.attributeChanged(attribute);
}"
73118,"/** 
 * Set the values of input variables. Choose the enabled transition among the outgoing transitions of the current state. Throw an exception if there is more than one transition enabled. Otherwise, execute the output actions contained by the chosen transition.
 * @exception IllegalActionException If there is more than onetransition enabled.
 */
public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Time environmentTime=_getEnvironmentTime();
  Director director=getDirector();
  boolean inModalModel=false;
  if (director instanceof FSMDirector) {
    inModalModel=true;
    director.setModelTime(environmentTime);
  }
  readInputs();
  _lastChosenTransitions.clear();
  _lastChosenTransition=null;
  _outputsThatMustBeUnknown.clear();
  _transitionRefinementsToPostfire.clear();
  _stateRefinementsToPostfire.clear();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  List<Transition> transitionList=_currentState.nonErrorNonTerminationTransitionList();
  _chooseTransitions(transitionList,true,false);
  if (_lastChosenTransitions.size() > 0) {
    if (inModalModel) {
      director.setModelTime(environmentTime);
    }
    TypedActor[] refinements=_currentState.getRefinement();
    if (refinements != null) {
      for (      Actor refinementActor : refinements) {
        if (refinementActor instanceof CompositeActor) {
          CompositeActor refinement=(CompositeActor)refinementActor;
          for (          IOPort refinementPort : ((List<IOPort>)refinement.outputPortList())) {
            for (int i=0; i < refinementPort.getWidth(); i++) {
              if (!refinementPort.isKnown(i)) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + refinementPort.getName() + ""String_Node_Str""+ i);
                }
                refinementPort.sendClear(i);
              }
            }
          }
        }
      }
    }
  }
 else {
    if (!foundUnknown()) {
      Actor[] stateRefinements=_currentState.getRefinement();
      if (stateRefinements != null) {
        try {
          for (int i=0; i < stateRefinements.length; ++i) {
            if (_stopRequested || _disabledRefinements.contains(stateRefinements[i])) {
              continue;
            }
            _setTimeForRefinement(stateRefinements[i]);
            if (stateRefinements[i].prefire()) {
              if (_debugging) {
                _debug(""String_Node_Str"",stateRefinements[i].getName());
              }
              stateRefinements[i].fire();
              _stateRefinementsToPostfire.add(stateRefinements[i]);
            }
          }
        }
 catch (        Throwable ex) {
          if (_lastChosenTransitions.size() == 0) {
            _chooseErrorTransition(ex);
          }
          if (_lastChosenTransitions.size() > 0) {
            if (inModalModel) {
              director.setModelTime(environmentTime);
            }
            return;
          }
          throw new IllegalActionException(this,ex,""String_Node_Str"");
        }
      }
      if (inModalModel) {
        director.setModelTime(environmentTime);
      }
      readOutputsFromRefinement();
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      List<Transition> terminationTransitions=_currentState.terminationTransitionList();
      boolean checkTerminationTransitions=false;
      if (terminationTransitions.size() > 0) {
        TypedActor[] refinements=_currentState.getRefinement();
        if (refinements != null && refinements.length > 0) {
          checkTerminationTransitions=true;
          for (          Actor refinementActor : refinements) {
            if (refinementActor instanceof ModalRefinement) {
              ModalRefinement refinement=(ModalRefinement)refinementActor;
              FSMActor refinementController=refinement.getController();
              State destinationState=refinementController._destinationState();
              if (!(((BooleanToken)refinementController.currentState().isFinalState.getToken()).booleanValue()) && (destinationState == null || !((BooleanToken)destinationState.isFinalState.getToken()).booleanValue())) {
                checkTerminationTransitions=false;
                break;
              }
            }
 else {
              checkTerminationTransitions=false;
              break;
            }
          }
        }
      }
      if (checkTerminationTransitions) {
        _chooseTransitions(_currentState.nonpreemptiveTransitionList(),false,false);
      }
 else {
        _chooseTransitions(transitionList,false,false);
      }
    }
  }
  _assertAbsentOutputs(this);
}","/** 
 * Set the values of input variables. Choose the enabled transition among the outgoing transitions of the current state. Throw an exception if there is more than one transition enabled. Otherwise, execute the output actions contained by the chosen transition.
 * @exception IllegalActionException If there is more than onetransition enabled.
 */
public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Time environmentTime=_getEnvironmentTime();
  Director director=getDirector();
  boolean inModalModel=false;
  if (director instanceof FSMDirector) {
    inModalModel=true;
    director.setModelTime(environmentTime);
  }
  readInputs();
  _lastChosenTransitions.clear();
  _lastChosenTransition=null;
  _outputsThatMustBeUnknown.clear();
  _transitionRefinementsToPostfire.clear();
  _stateRefinementsToPostfire.clear();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  List<Transition> transitionList=_currentState.nonErrorNonTerminationTransitionList();
  _chooseTransitions(transitionList,true,false);
  if (_lastChosenTransitions.size() > 0) {
    if (inModalModel) {
      director.setModelTime(environmentTime);
    }
    TypedActor[] refinements=_currentState.getRefinement();
    if (refinements != null) {
      for (      Actor refinementActor : refinements) {
        if (refinementActor instanceof CompositeActor) {
          CompositeActor refinement=(CompositeActor)refinementActor;
          for (          IOPort refinementPort : ((List<IOPort>)refinement.outputPortList())) {
            for (int i=0; i < refinementPort.getWidth(); i++) {
              if (!refinementPort.isKnown(i)) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + refinementPort.getName() + ""String_Node_Str""+ i);
                }
                refinementPort.sendClear(i);
              }
            }
          }
        }
      }
    }
  }
 else {
    if (!foundUnknown()) {
      Actor[] stateRefinements=_currentState.getRefinement();
      if (stateRefinements != null) {
        try {
          for (int i=0; i < stateRefinements.length; ++i) {
            if (_stopRequested || _disabledRefinements.contains(stateRefinements[i])) {
              continue;
            }
            _setTimeForRefinement(stateRefinements[i]);
            if (stateRefinements[i].prefire()) {
              if (_debugging) {
                _debug(""String_Node_Str"",stateRefinements[i].getName());
              }
              if (_modelErrorHandled == null) {
                stateRefinements[i].fire();
                if (_modelErrorHandled == null) {
                  _stateRefinementsToPostfire.add(stateRefinements[i]);
                }
              }
            }
          }
        }
 catch (        Throwable ex) {
          _chooseErrorTransition(ex);
          if (_lastChosenTransitions.size() > 0) {
            if (inModalModel) {
              director.setModelTime(environmentTime);
            }
            return;
          }
          throw new IllegalActionException(this,ex,""String_Node_Str"");
        }
        if (_modelErrorHandled != null) {
          _chooseErrorTransition(_modelErrorHandled);
          if (inModalModel) {
            director.setModelTime(environmentTime);
          }
          return;
        }
      }
      if (inModalModel) {
        director.setModelTime(environmentTime);
      }
      readOutputsFromRefinement();
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      List<Transition> terminationTransitions=_currentState.terminationTransitionList();
      boolean checkTerminationTransitions=false;
      if (terminationTransitions.size() > 0) {
        TypedActor[] refinements=_currentState.getRefinement();
        if (refinements != null && refinements.length > 0) {
          checkTerminationTransitions=true;
          for (          Actor refinementActor : refinements) {
            if (refinementActor instanceof ModalRefinement) {
              ModalRefinement refinement=(ModalRefinement)refinementActor;
              FSMActor refinementController=refinement.getController();
              State destinationState=refinementController._destinationState();
              if (!(((BooleanToken)refinementController.currentState().isFinalState.getToken()).booleanValue()) && (destinationState == null || !((BooleanToken)destinationState.isFinalState.getToken()).booleanValue())) {
                checkTerminationTransitions=false;
                break;
              }
            }
 else {
              checkTerminationTransitions=false;
              break;
            }
          }
        }
      }
      if (checkTerminationTransitions) {
        _chooseTransitions(_currentState.nonpreemptiveTransitionList(),false,false);
      }
 else {
        _chooseTransitions(transitionList,false,false);
      }
    }
  }
  _assertAbsentOutputs(this);
}"
73119,"/** 
 * Handle a model error.
 * @param context The object in which the error occurred.
 * @param exception An exception that represents the error.
 * @return True if the error has been handled, or false if theerror is not handled.
 * @exception IllegalActionException If the handler handles theerror by throwing an exception.
 */
public boolean handleModelError(NamedObj context,IllegalActionException exception) throws IllegalActionException {
  _chooseErrorTransition(exception);
  if (_lastChosenTransitions.size() > 0) {
    throw exception;
  }
  return false;
}","/** 
 * Handle a model error.
 * @param context The object in which the error occurred.
 * @param exception An exception that represents the error.
 * @return True if the error has been handled, or false if theerror is not handled.
 * @exception IllegalActionException If the handler handles theerror by throwing an exception.
 */
public boolean handleModelError(NamedObj context,IllegalActionException exception) throws IllegalActionException {
  _chooseErrorTransition(exception);
  if (_lastChosenTransitions.size() > 0) {
    _modelErrorHandled=exception;
    return true;
  }
  return false;
}"
73120,"/** 
 * Create receivers and input variables for the input ports of this actor, and validate attributes of this actor, and attributes of the ports of this actor. Set current state to the initial state.
 * @exception IllegalActionException If this actor does not contain aninitial state.
 */
public void preinitialize() throws IllegalActionException {
  if (_initializables != null) {
    for (    Initializable initializable : _initializables) {
      initializable.preinitialize();
    }
  }
  _stopRequested=false;
  _reachedFinalState=false;
  _newIteration=true;
  _tokenListArrays=new Hashtable();
  _inputTokenMap.clear();
  errorMessage.setExpression(""String_Node_Str"");
  errorClass.setExpression(""String_Node_Str"");
  errorCause.setToken((Token)null);
  reset();
  if (_currentState != null) {
    List transitionList=_currentState.outgoingPort.linkedRelationList();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    _chooseTransitions(transitionList,true,true);
    if (_lastChosenTransitions.size() == 0) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      _chooseTransitions(transitionList,false,true);
    }
    _commitLastChosenTransition();
    _transitionsPreviouslyChosenInIteration.clear();
  }
}","/** 
 * Create receivers and input variables for the input ports of this actor, and validate attributes of this actor, and attributes of the ports of this actor. Set current state to the initial state.
 * @exception IllegalActionException If this actor does not contain aninitial state.
 */
public void preinitialize() throws IllegalActionException {
  if (_initializables != null) {
    for (    Initializable initializable : _initializables) {
      initializable.preinitialize();
    }
  }
  _stopRequested=false;
  _reachedFinalState=false;
  _newIteration=true;
  _tokenListArrays=new Hashtable();
  _inputTokenMap.clear();
  errorMessage.setExpression(""String_Node_Str"");
  errorClass.setExpression(""String_Node_Str"");
  errorCause.setToken((Token)null);
  _modelErrorHandled=null;
  reset();
  if (_currentState != null) {
    List transitionList=_currentState.outgoingPort.linkedRelationList();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    _chooseTransitions(transitionList,true,true);
    if (_lastChosenTransitions.size() == 0) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      _chooseTransitions(transitionList,false,true);
    }
    _commitLastChosenTransition();
    _transitionsPreviouslyChosenInIteration.clear();
  }
}"
73121,"/** 
 * Execute actions on the last chosen transition. Change state to the destination state of the last chosen transition.
 * @return True, unless stop() has been called, in which case, false.
 * @exception IllegalActionException If any action throws it.
 */
public boolean postfire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Director director=getDirector();
  boolean inModalModel=false;
  if (director instanceof FSMDirector) {
    inModalModel=true;
  }
  Time environmentTime=_getEnvironmentTime();
  for (  Actor stateRefinement : _stateRefinementsToPostfire) {
    if (_debugging) {
      _debug(""String_Node_Str"",stateRefinement.getName());
    }
    _setTimeForRefinement(stateRefinement);
    if (!stateRefinement.postfire()) {
      _disabledRefinements.add(stateRefinement);
    }
    if (inModalModel) {
      director.setModelTime(environmentTime);
    }
  }
  Actor[] refinements=_currentState.getRefinement();
  if (refinements != null) {
    for (    Actor stateRefinement : refinements) {
      Director refinementDirector=stateRefinement.getDirector();
      if (_lastChosenTransitions.size() != 0 && refinementDirector != director) {
        refinementDirector.suspend();
      }
    }
  }
  if (refinements != null && refinements.length > 0 && _disabledRefinements.size() == refinements.length) {
    if (_lastChosenTransitions.size() == 0) {
      List<Transition> transitionList=_currentState.terminationTransitionList();
      _chooseTransitions(transitionList,false,false);
    }
  }
  if (_lastChosenTransitions.size() != 0) {
    _transitionTaken=true;
    State destinationState=_destinationState();
    if (destinationState != null) {
      TypedActor[] destinationRefinements=destinationState.getRefinement();
      if (destinationRefinements != null) {
        for (        TypedActor destinationRefinement : destinationRefinements) {
          Director refinementDirector=destinationRefinement.getDirector();
          if (refinementDirector != director) {
            refinementDirector.resume();
          }
        }
      }
    }
  }
 else {
    _transitionTaken=false;
  }
  _transitionsPreviouslyChosenInIteration.clear();
  _commitLastChosenTransition();
  for (  Actor transitionRefinement : _transitionRefinementsToPostfire) {
    if (_debugging) {
      _debug(""String_Node_Str"",transitionRefinement.getName());
    }
    if (!transitionRefinement.postfire()) {
      _disabledRefinements.add(transitionRefinement);
    }
  }
  _inputTokenMap.clear();
  errorMessage.setExpression(""String_Node_Str"");
  errorClass.setExpression(""String_Node_Str"");
  errorCause.setToken((Token)null);
  return !_reachedFinalState && !_stopRequested;
}","/** 
 * Execute actions on the last chosen transition. Change state to the destination state of the last chosen transition.
 * @return True, unless stop() has been called, in which case, false.
 * @exception IllegalActionException If any action throws it.
 */
public boolean postfire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Director director=getDirector();
  boolean inModalModel=false;
  if (director instanceof FSMDirector) {
    inModalModel=true;
  }
  Time environmentTime=_getEnvironmentTime();
  for (  Actor stateRefinement : _stateRefinementsToPostfire) {
    if (_debugging) {
      _debug(""String_Node_Str"",stateRefinement.getName());
    }
    _setTimeForRefinement(stateRefinement);
    if (!stateRefinement.postfire()) {
      _disabledRefinements.add(stateRefinement);
    }
    if (inModalModel) {
      director.setModelTime(environmentTime);
    }
  }
  Actor[] refinements=_currentState.getRefinement();
  if (refinements != null) {
    for (    Actor stateRefinement : refinements) {
      Director refinementDirector=stateRefinement.getDirector();
      if (_lastChosenTransitions.size() != 0 && refinementDirector != director) {
        refinementDirector.suspend();
      }
    }
  }
  if (refinements != null && refinements.length > 0 && _disabledRefinements.size() == refinements.length) {
    if (_lastChosenTransitions.size() == 0) {
      List<Transition> transitionList=_currentState.terminationTransitionList();
      _chooseTransitions(transitionList,false,false);
    }
  }
  if (_lastChosenTransitions.size() != 0) {
    _transitionTaken=true;
    State destinationState=_destinationState();
    if (destinationState != null) {
      TypedActor[] destinationRefinements=destinationState.getRefinement();
      if (destinationRefinements != null) {
        for (        TypedActor destinationRefinement : destinationRefinements) {
          Director refinementDirector=destinationRefinement.getDirector();
          if (refinementDirector != director) {
            refinementDirector.resume();
          }
        }
      }
    }
  }
 else {
    _transitionTaken=false;
  }
  _transitionsPreviouslyChosenInIteration.clear();
  _commitLastChosenTransition();
  for (  Actor transitionRefinement : _transitionRefinementsToPostfire) {
    if (_debugging) {
      _debug(""String_Node_Str"",transitionRefinement.getName());
    }
    if (!transitionRefinement.postfire()) {
      _disabledRefinements.add(transitionRefinement);
    }
  }
  _inputTokenMap.clear();
  errorMessage.setExpression(""String_Node_Str"");
  errorClass.setExpression(""String_Node_Str"");
  errorCause.setToken((Token)null);
  _modelErrorHandled=null;
  return !_reachedFinalState && !_stopRequested;
}"
73122,"/** 
 * Initialize this actor by setting the current state to the initial state.
 * @exception IllegalActionException If a derived class throws it.
 */
public void initialize() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  _inputTokenMap.clear();
  errorMessage.setExpression(""String_Node_Str"");
  errorClass.setExpression(""String_Node_Str"");
  errorCause.setToken((Token)null);
  _transitionTaken=false;
  if (_initializables != null) {
    for (    Initializable initializable : _initializables) {
      initializable.initialize();
    }
  }
  reset();
  if (_currentState != null) {
    List transitionList=_currentState.outgoingPort.linkedRelationList();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    _chooseTransitions(transitionList,true,true);
    if (_lastChosenTransitions.size() > 0) {
      _transitionTaken=true;
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      _chooseTransitions(transitionList,false,true);
      if (_lastChosenTransitions.size() > 0) {
        _transitionTaken=true;
      }
 else {
        _transitionTaken=false;
      }
    }
    _commitLastChosenTransition();
    _transitionsPreviouslyChosenInIteration.clear();
    try {
      transitionList=_currentState.outgoingPort.linkedRelationList();
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      List enabledTransitions=enabledTransitions(transitionList,true,false);
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      enabledTransitions.addAll(enabledTransitions(transitionList,false,false));
      if (enabledTransitions.size() > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"" + getDirector().getModelTime());
        }
        getDirector().fireAtCurrentTime(this);
      }
    }
 catch (    IllegalActionException ex) {
    }
  }
}","/** 
 * Initialize this actor by setting the current state to the initial state.
 * @exception IllegalActionException If a derived class throws it.
 */
public void initialize() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  _inputTokenMap.clear();
  errorMessage.setExpression(""String_Node_Str"");
  errorClass.setExpression(""String_Node_Str"");
  errorCause.setToken((Token)null);
  _modelErrorHandled=null;
  _transitionTaken=false;
  if (_initializables != null) {
    for (    Initializable initializable : _initializables) {
      initializable.initialize();
    }
  }
  reset();
  if (_currentState != null) {
    List transitionList=_currentState.outgoingPort.linkedRelationList();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    _chooseTransitions(transitionList,true,true);
    if (_lastChosenTransitions.size() > 0) {
      _transitionTaken=true;
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      _chooseTransitions(transitionList,false,true);
      if (_lastChosenTransitions.size() > 0) {
        _transitionTaken=true;
      }
 else {
        _transitionTaken=false;
      }
    }
    _commitLastChosenTransition();
    _transitionsPreviouslyChosenInIteration.clear();
    try {
      transitionList=_currentState.outgoingPort.linkedRelationList();
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      List enabledTransitions=enabledTransitions(transitionList,true,false);
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      enabledTransitions.addAll(enabledTransitions(transitionList,false,false));
      if (enabledTransitions.size() > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"" + getDirector().getModelTime());
        }
        getDirector().fireAtCurrentTime(this);
      }
    }
 catch (    IllegalActionException ex) {
    }
  }
}"
73123,"/** 
 * Check the input ports of the container composite actor (if there are any) to see whether they have enough tokens, and return true if they do.  If there are no input ports, then also return true. Otherwise, return false.  Note that this does not call prefire() on the contained actors. <p> This method also implements the functionality of <i>synchronizeToRealTime</i> by waiting for real time to elapse if the parameter value is true.
 * @exception IllegalActionException If port methods throw it.
 * @return true If all of the input ports of the container of thisdirector have enough tokens.
 */
public boolean prefire() throws IllegalActionException {
  if (_prefire) {
    return true;
  }
  _prefire=super.prefire();
  if (!super.prefire()) {
    return false;
  }
  double periodValue=periodValue();
  boolean synchronizeValue=((BooleanToken)synchronizeToRealTime.getToken()).booleanValue();
  if ((periodValue > 0.0) && synchronizeValue) {
    int depth=0;
    try {
synchronized (this) {
        while (true) {
          long elapsedTime=System.currentTimeMillis() - _realStartTime;
          double elapsedTimeInSeconds=elapsedTime / 1000.0;
          double currentTime=getModelTime().getDoubleValue();
          if (currentTime <= elapsedTimeInSeconds) {
            break;
          }
          long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
          if (_debugging) {
            _debug(""String_Node_Str"" + timeToWait);
          }
          try {
            if (timeToWait > 0) {
              depth=_workspace.releaseReadPermission();
              wait(timeToWait);
            }
          }
 catch (          InterruptedException ex) {
          }
        }
      }
    }
  finally {
      if (depth > 0) {
        _workspace.reacquireReadPermission(depth);
      }
    }
  }
  if (_periodicDirectorHelper != null && !_periodicDirectorHelper.prefire()) {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + getModelTime() + ""String_Node_Str""+ periodValue);
    }
    return false;
  }
  TypedCompositeActor container=((TypedCompositeActor)getContainer());
  Iterator inputPorts=container.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    if (inputPort instanceof ParameterPort) {
      continue;
    }
    int threshold=DFUtilities.getTokenConsumptionRate(inputPort);
    if (_debugging) {
      _debug(""String_Node_Str"" + inputPort.getFullName());
      _debug(""String_Node_Str"" + threshold);
    }
    for (int channel=0; channel < inputPort.getWidth(); channel++) {
      if ((threshold > 0) && !inputPort.hasToken(channel,threshold)) {
        if (_debugging) {
          _debug(""String_Node_Str"" + inputPort.getFullName() + ""String_Node_Str""+ threshold+ ""String_Node_Str"");
        }
        return false;
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return true;
}","/** 
 * Check the input ports of the container composite actor (if there are any) to see whether they have enough tokens, and return true if they do.  If there are no input ports, then also return true. Otherwise, return false.  Note that this does not call prefire() on the contained actors. <p> This method also implements the functionality of <i>synchronizeToRealTime</i> by waiting for real time to elapse if the parameter value is true.
 * @exception IllegalActionException If port methods throw it.
 * @return true If all of the input ports of the container of thisdirector have enough tokens.
 */
public boolean prefire() throws IllegalActionException {
  if (_resourceScheduling && _prefire) {
    return true;
  }
  _prefire=super.prefire();
  if (!_prefire) {
    return false;
  }
  double periodValue=periodValue();
  boolean synchronizeValue=((BooleanToken)synchronizeToRealTime.getToken()).booleanValue();
  if ((periodValue > 0.0) && synchronizeValue) {
    int depth=0;
    try {
synchronized (this) {
        while (true) {
          long elapsedTime=System.currentTimeMillis() - _realStartTime;
          double elapsedTimeInSeconds=elapsedTime / 1000.0;
          double currentTime=getModelTime().getDoubleValue();
          if (currentTime <= elapsedTimeInSeconds) {
            break;
          }
          long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
          if (_debugging) {
            _debug(""String_Node_Str"" + timeToWait);
          }
          try {
            if (timeToWait > 0) {
              depth=_workspace.releaseReadPermission();
              wait(timeToWait);
            }
          }
 catch (          InterruptedException ex) {
          }
        }
      }
    }
  finally {
      if (depth > 0) {
        _workspace.reacquireReadPermission(depth);
      }
    }
  }
  if (_periodicDirectorHelper != null && !_periodicDirectorHelper.prefire()) {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + getModelTime() + ""String_Node_Str""+ periodValue);
    }
    return false;
  }
  TypedCompositeActor container=((TypedCompositeActor)getContainer());
  Iterator inputPorts=container.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    if (inputPort instanceof ParameterPort) {
      continue;
    }
    int threshold=DFUtilities.getTokenConsumptionRate(inputPort);
    if (_debugging) {
      _debug(""String_Node_Str"" + inputPort.getFullName());
      _debug(""String_Node_Str"" + threshold);
    }
    for (int channel=0; channel < inputPort.getWidth(); channel++) {
      if ((threshold > 0) && !inputPort.hasToken(channel,threshold)) {
        if (_debugging) {
          _debug(""String_Node_Str"" + inputPort.getFullName() + ""String_Node_Str""+ threshold+ ""String_Node_Str"");
        }
        return false;
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return true;
}"
73124,"/** 
 * Return true if the director is ready to fire. This method is called by the container of this director to determine whether the director is ready to execute. It does <i>not</i> call prefire() on the contained actors.  If this director is not at the top level of the hierarchy, and the current time of the enclosing model is greater than the current time of this director, then this base class updates current time to match that of the enclosing model.  <p> In this base class, assume that the director is always ready to be fired, and so return true.  Domain directors should probably override this method to provide domain-specific operation.  However, they should call super.prefire() if they wish to propagate time as done here.
 * @return True.
 * @exception IllegalActionException Not thrown in this base class.
 */
public boolean prefire() throws IllegalActionException {
  _postfireReturns=true;
  if (_prefire) {
    return true;
  }
  _prefire=super.prefire();
  if (_resourceScheduling && _prefire) {
    Iterator firings=null;
    if (_savedSchedule == null) {
      Scheduler scheduler=getScheduler();
      Schedule schedule=scheduler.getSchedule();
      _savedSchedule=schedule;
      _savedSchedulePosition=0;
      firings=schedule.firingIterator();
    }
 else {
      firings=_savedSchedule.firingIterator();
      for (int i=0; i < _savedSchedulePosition; i++) {
        firings.next();
      }
    }
    Firing firing=null;
    while ((_savedIterationCount > 0 || firings.hasNext()) && !_stopRequested) {
      if (firing == null || _savedIterationCount == 0) {
        firing=(Firing)firings.next();
      }
      Actor actor=firing.getActor();
      boolean finished=_schedule(actor,null,null);
      if (!finished) {
        _prefire=false;
        return false;
      }
      if (_savedIterationCount == 0) {
        _savedIterationCount=firing.getIterationCount();
      }
      _savedIterationCount--;
      if (_savedIterationCount == 0) {
        _savedSchedulePosition++;
      }
    }
    if (_savedSchedule.size() <= _savedSchedulePosition) {
      _savedSchedule=null;
    }
  }
  return _prefire;
}","/** 
 * Return true if the director is ready to fire. This method is called by the container of this director to determine whether the director is ready to execute. It does <i>not</i> call prefire() on the contained actors.  If this director is not at the top level of the hierarchy, and the current time of the enclosing model is greater than the current time of this director, then this base class updates current time to match that of the enclosing model.  <p> In this base class, assume that the director is always ready to be fired, and so return true.  Domain directors should probably override this method to provide domain-specific operation.  However, they should call super.prefire() if they wish to propagate time as done here.
 * @return True.
 * @exception IllegalActionException Not thrown in this base class.
 */
public boolean prefire() throws IllegalActionException {
  _postfireReturns=true;
  _prefire=super.prefire();
  if (_resourceScheduling && _prefire) {
    Iterator firings=null;
    if (_savedSchedule == null) {
      Scheduler scheduler=getScheduler();
      Schedule schedule=scheduler.getSchedule();
      _savedSchedule=schedule;
      _savedSchedulePosition=0;
      firings=schedule.firingIterator();
    }
 else {
      firings=_savedSchedule.firingIterator();
      for (int i=0; i < _savedSchedulePosition; i++) {
        firings.next();
      }
    }
    Firing firing=null;
    while ((_savedIterationCount > 0 || firings.hasNext()) && !_stopRequested) {
      if (firing == null || _savedIterationCount == 0) {
        firing=(Firing)firings.next();
      }
      Actor actor=firing.getActor();
      boolean finished=_schedule(actor,null,null);
      if (!finished) {
        _prefire=false;
        return false;
      }
      if (_savedIterationCount == 0) {
        _savedIterationCount=firing.getIterationCount();
      }
      _savedIterationCount--;
      if (_savedIterationCount == 0) {
        _savedSchedulePosition++;
      }
    }
    if (_savedSchedule.size() <= _savedSchedulePosition) {
      _savedSchedule=null;
    }
  }
  return _prefire;
}"
73125,"/** 
 * Calculate the current schedule, if necessary, and iterate the contained actors in the order given by the schedule. Iterating an actor involves calling the actor's iterate() method, which is equivalent to calling the actor's prefire(), fire() and postfire() methods in succession.  If iterate() returns NOT_READY, indicating that the actor is not ready to execute, then an IllegalActionException will be thrown. The values returned from iterate() are recorded and are used to determine the value that postfire() will return at the end of the director's iteration. NOTE: This method does not conform with the strict actor semantics because it calls postfire() of actors. Thus, it should not be used in domains that require a strict actor semantics, such as SR or Continuous.
 * @exception IllegalActionException If any actor executed by thisactor return false in prefire.
 * @exception InvalidStateException If this director does not have acontainer.
 */
public void fire() throws IllegalActionException {
  _prefire=false;
  Iterator firings=null;
  Scheduler scheduler=getScheduler();
  if (scheduler == null) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Schedule schedule=scheduler.getSchedule();
  firings=schedule.firingIterator();
  Firing firing=null;
  while (firings.hasNext() && !_stopRequested) {
    firing=(Firing)firings.next();
    Actor actor=firing.getActor();
    int iterationCount=firing.getIterationCount();
    if (_debugging) {
      _debug(new FiringEvent(this,actor,FiringEvent.BEFORE_ITERATE,iterationCount));
    }
    int returnValue=actor.iterate(iterationCount);
    if (returnValue == STOP_ITERATING) {
      _postfireReturns=false;
    }
 else     if (returnValue == NOT_READY) {
      throw new IllegalActionException(this,actor,""String_Node_Str"" + ""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (_debugging) {
      _debug(new FiringEvent(this,actor,FiringEvent.AFTER_ITERATE,iterationCount));
    }
  }
}","/** 
 * Calculate the current schedule, if necessary, and iterate the contained actors in the order given by the schedule. Iterating an actor involves calling the actor's iterate() method, which is equivalent to calling the actor's prefire(), fire() and postfire() methods in succession.  If iterate() returns NOT_READY, indicating that the actor is not ready to execute, then an IllegalActionException will be thrown. The values returned from iterate() are recorded and are used to determine the value that postfire() will return at the end of the director's iteration. NOTE: This method does not conform with the strict actor semantics because it calls postfire() of actors. Thus, it should not be used in domains that require a strict actor semantics, such as SR or Continuous.
 * @exception IllegalActionException If any actor executed by thisactor return false in prefire.
 * @exception InvalidStateException If this director does not have acontainer.
 */
public void fire() throws IllegalActionException {
  Iterator firings=null;
  Scheduler scheduler=getScheduler();
  if (scheduler == null) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Schedule schedule=scheduler.getSchedule();
  firings=schedule.firingIterator();
  Firing firing=null;
  while (firings.hasNext() && !_stopRequested) {
    firing=(Firing)firings.next();
    Actor actor=firing.getActor();
    int iterationCount=firing.getIterationCount();
    if (_debugging) {
      _debug(new FiringEvent(this,actor,FiringEvent.BEFORE_ITERATE,iterationCount));
    }
    int returnValue=actor.iterate(iterationCount);
    if (returnValue == STOP_ITERATING) {
      _postfireReturns=false;
    }
 else     if (returnValue == NOT_READY) {
      throw new IllegalActionException(this,actor,""String_Node_Str"" + ""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (_debugging) {
      _debug(new FiringEvent(this,actor,FiringEvent.AFTER_ITERATE,iterationCount));
    }
  }
}"
73126,"/** 
 * Check the input ports of the container composite actor (if there are any) to see whether they have enough tokens, and return true if they do.  If there are no input ports, then also return true. Otherwise, return false.  Note that this does not call prefire() on the contained actors. <p> This method also implements the functionality of <i>synchronizeToRealTime</i> by waiting for real time to elapse if the parameter value is true.
 * @exception IllegalActionException If port methods throw it.
 * @return true If all of the input ports of the container of thisdirector have enough tokens.
 */
public boolean prefire() throws IllegalActionException {
  if (!super.prefire()) {
    return false;
  }
  double periodValue=periodValue();
  boolean synchronizeValue=((BooleanToken)synchronizeToRealTime.getToken()).booleanValue();
  if ((periodValue > 0.0) && synchronizeValue) {
    int depth=0;
    try {
synchronized (this) {
        while (true) {
          long elapsedTime=System.currentTimeMillis() - _realStartTime;
          double elapsedTimeInSeconds=elapsedTime / 1000.0;
          double currentTime=getModelTime().getDoubleValue();
          if (currentTime <= elapsedTimeInSeconds) {
            break;
          }
          long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
          if (_debugging) {
            _debug(""String_Node_Str"" + timeToWait);
          }
          try {
            if (timeToWait > 0) {
              depth=_workspace.releaseReadPermission();
              wait(timeToWait);
            }
          }
 catch (          InterruptedException ex) {
          }
        }
      }
    }
  finally {
      if (depth > 0) {
        _workspace.reacquireReadPermission(depth);
      }
    }
  }
  if (_periodicDirectorHelper != null && !_periodicDirectorHelper.prefire()) {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + getModelTime() + ""String_Node_Str""+ periodValue);
    }
    return false;
  }
  TypedCompositeActor container=((TypedCompositeActor)getContainer());
  Iterator inputPorts=container.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    if (inputPort instanceof ParameterPort) {
      continue;
    }
    int threshold=DFUtilities.getTokenConsumptionRate(inputPort);
    if (_debugging) {
      _debug(""String_Node_Str"" + inputPort.getFullName());
      _debug(""String_Node_Str"" + threshold);
    }
    for (int channel=0; channel < inputPort.getWidth(); channel++) {
      if ((threshold > 0) && !inputPort.hasToken(channel,threshold)) {
        if (_debugging) {
          _debug(""String_Node_Str"" + inputPort.getFullName() + ""String_Node_Str""+ threshold+ ""String_Node_Str"");
        }
        return false;
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return true;
}","/** 
 * Check the input ports of the container composite actor (if there are any) to see whether they have enough tokens, and return true if they do.  If there are no input ports, then also return true. Otherwise, return false.  Note that this does not call prefire() on the contained actors. <p> This method also implements the functionality of <i>synchronizeToRealTime</i> by waiting for real time to elapse if the parameter value is true.
 * @exception IllegalActionException If port methods throw it.
 * @return true If all of the input ports of the container of thisdirector have enough tokens.
 */
public boolean prefire() throws IllegalActionException {
  if (_prefire) {
    return true;
  }
  _prefire=super.prefire();
  if (!super.prefire()) {
    return false;
  }
  double periodValue=periodValue();
  boolean synchronizeValue=((BooleanToken)synchronizeToRealTime.getToken()).booleanValue();
  if ((periodValue > 0.0) && synchronizeValue) {
    int depth=0;
    try {
synchronized (this) {
        while (true) {
          long elapsedTime=System.currentTimeMillis() - _realStartTime;
          double elapsedTimeInSeconds=elapsedTime / 1000.0;
          double currentTime=getModelTime().getDoubleValue();
          if (currentTime <= elapsedTimeInSeconds) {
            break;
          }
          long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
          if (_debugging) {
            _debug(""String_Node_Str"" + timeToWait);
          }
          try {
            if (timeToWait > 0) {
              depth=_workspace.releaseReadPermission();
              wait(timeToWait);
            }
          }
 catch (          InterruptedException ex) {
          }
        }
      }
    }
  finally {
      if (depth > 0) {
        _workspace.reacquireReadPermission(depth);
      }
    }
  }
  if (_periodicDirectorHelper != null && !_periodicDirectorHelper.prefire()) {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + getModelTime() + ""String_Node_Str""+ periodValue);
    }
    return false;
  }
  TypedCompositeActor container=((TypedCompositeActor)getContainer());
  Iterator inputPorts=container.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    if (inputPort instanceof ParameterPort) {
      continue;
    }
    int threshold=DFUtilities.getTokenConsumptionRate(inputPort);
    if (_debugging) {
      _debug(""String_Node_Str"" + inputPort.getFullName());
      _debug(""String_Node_Str"" + threshold);
    }
    for (int channel=0; channel < inputPort.getWidth(); channel++) {
      if ((threshold > 0) && !inputPort.hasToken(channel,threshold)) {
        if (_debugging) {
          _debug(""String_Node_Str"" + inputPort.getFullName() + ""String_Node_Str""+ threshold+ ""String_Node_Str"");
        }
        return false;
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return true;
}"
73127,"/** 
 * Return the type constraints on all connections starting from the specified source port to all the ports in a group of destination ports.
 * @param source The source port.
 * @return A list of instances of Inequality.
 */
protected List<Inequality> _destinationTypeConstraints(TypedIOPort source){
  Iterator<IOPort> destinationPorts;
  List<Inequality> result=new LinkedList<Inequality>();
  boolean srcUndeclared=source.getTypeTerm().isSettable();
  if (source.isInput() && source.isOutput()) {
    List<IOPort> sinks=source.sinkPortList();
    sinks.addAll(source.insideSinkPortList());
    destinationPorts=sinks.iterator();
  }
 else   if (source.isInput()) {
    destinationPorts=source.insideSinkPortList().iterator();
  }
 else {
    destinationPorts=source.sinkPortList().iterator();
  }
  while (destinationPorts.hasNext()) {
    TypedIOPort destinationPort=(TypedIOPort)destinationPorts.next();
    boolean destUndeclared=destinationPort.getTypeTerm().isSettable();
    if (srcUndeclared || destUndeclared) {
      Inequality ineq=new Inequality(source.getTypeTerm(),destinationPort.getTypeTerm());
      result.add(ineq);
    }
    if (srcUndeclared) {
      if (isBackwardTypeInferenceEnabled()) {
        result.add(new Inequality(new GLBFunction(source),source.getTypeTerm()));
      }
    }
  }
  return result;
}","/** 
 * Return the type constraints on all connections starting from the specified source port to all the ports in a group of destination ports.
 * @param source The source port.
 * @return A list of instances of Inequality.
 */
protected List<Inequality> _destinationTypeConstraints(TypedIOPort source){
  Iterator<IOPort> destinationPorts;
  List<Inequality> result=new LinkedList<Inequality>();
  boolean srcUndeclared=source.getTypeTerm().isSettable();
  if (source.isInput() && source.isOutput()) {
    List<IOPort> sinks=source.sinkPortList();
    sinks.addAll(source.insideSinkPortList());
    destinationPorts=sinks.iterator();
  }
 else   if (source.isInput()) {
    destinationPorts=source.insideSinkPortList().iterator();
  }
 else {
    destinationPorts=source.sinkPortList().iterator();
  }
  while (destinationPorts.hasNext()) {
    TypedIOPort destinationPort=(TypedIOPort)destinationPorts.next();
    boolean destUndeclared=destinationPort.getTypeTerm().isSettable();
    if (srcUndeclared || destUndeclared) {
      Inequality ineq=new Inequality(source.getTypeTerm(),destinationPort.getTypeTerm());
      result.add(ineq);
    }
  }
  if (srcUndeclared) {
    if (isBackwardTypeInferenceEnabled()) {
      result.add(new Inequality(new GLBFunction(source),source.getTypeTerm()));
    }
  }
  return result;
}"
73128,"public void publish(String nodeId,String value) throws IllegalActionException {
  Node n;
  LeafNode ln;
  try {
    if ((n=_manager.getNode(nodeId)) instanceof LeafNode) {
      ln=(LeafNode)n;
    }
 else {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
 catch (  XMPPException e) {
    try {
      ln=_manager.createNode(nodeId);
    }
 catch (    XMPPException e1) {
      throw new IllegalActionException(""String_Node_Str"" + nodeId + ""String_Node_Str"");
    }
  }
  ln.publish(new Item(value));
}","public void publish(String nodeId,String value) throws IllegalActionException {
  Node n;
  LeafNode ln;
  try {
    if ((n=_manager.getNode(nodeId)) instanceof LeafNode) {
      ln=(LeafNode)n;
    }
 else {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
 catch (  XMPPException e) {
    try {
      ln=_manager.createNode(nodeId);
    }
 catch (    XMPPException e1) {
      throw new IllegalActionException(""String_Node_Str"" + nodeId + ""String_Node_Str"");
    }
  }
  SimplePayload payload=new SimplePayload(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + value + ""String_Node_Str"");
  PayloadItem<SimplePayload> item=new PayloadItem<SimplePayload>(null,payload);
  ln.publish(item);
}"
73129,"@Override public void handlePublishedItems(ItemPublishEvent<Item> items){
  _currentValue=items.getItems().toString();
  System.out.println(""String_Node_Str"");
  try {
    getDirector().fireAtCurrentTime(this);
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
}","@Override public void handlePublishedItems(ItemPublishEvent<Item> items){
  PayloadItem<SimplePayload> item=(PayloadItem<SimplePayload>)items.getItems().get(0);
  SimplePayload payload=item.getPayload();
  _currentValue=payload.toXML();
  System.out.println(""String_Node_Str"");
  try {
    getDirector().fireAtCurrentTime(this);
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
}"
73130,"/** 
 * Increment the version number by one.
 */
public final synchronized void incrVersion(){
  notifyObservers();
  _version++;
}","/** 
 * Increment the version number by one.
 */
public final synchronized void incrVersion(){
  _version++;
}"
73131,"/** 
 * Import a Functional Mock-up Unit (FMU) file.
 */
private void _importFMU(){
  try {
    if (_frame instanceof BasicGraphFrame) {
      throw new InternalErrorException(""String_Node_Str"" + _frame + ""String_Node_Str"");
    }
 else {
      BasicGraphFrame basicGraphFrame=(BasicGraphFrame)_frame;
      Query query=new Query();
      query.setTextWidth(60);
      query.addFileChooser(""String_Node_Str"",""String_Node_Str"",_lastLocation,null,basicGraphFrame.getLastDirectory(),true,false,PtolemyQuery.preferredBackgroundColor(_frame),PtolemyQuery.preferredForegroundColor(_frame));
      ComponentDialog dialog=new ComponentDialog(_frame,""String_Node_Str"",query);
      if (dialog.buttonPressed().equals(""String_Node_Str"")) {
        _lastLocation=query.getStringValue(""String_Node_Str"");
        GraphController controller=basicGraphFrame.getJGraph().getGraphPane().getGraphController();
        AbstractBasicGraphModel model=(AbstractBasicGraphModel)controller.getGraphModel();
        NamedObj context=model.getPtolemyModel();
        Rectangle2D bounds=basicGraphFrame.getVisibleCanvasRectangle();
        double x=bounds.getWidth() / 2.0;
        double y=bounds.getHeight() / 2.0;
        String fmuFileName=null;
        fmuFileName=_lastLocation;
        if (fmuFileName.equals(_fmuFileName)) {
          return;
        }
        _fmuFileName=fmuFileName;
        long modificationTime=new File(fmuFileName).lastModified();
        if (_fmuFileModificationTime == modificationTime) {
          return;
        }
        _fmuFileModificationTime=modificationTime;
        FMUImport.importFMU(this,fmuFileName,context,x,y);
      }
    }
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
  }
}","/** 
 * Import a Functional Mock-up Unit (FMU) file.
 */
private void _importFMU(){
  try {
    Class basicGraphFrameClass=null;
    try {
      basicGraphFrameClass=Class.forName(""String_Node_Str"");
    }
 catch (    Throwable throwable) {
      throw new InternalErrorException(null,throwable,""String_Node_Str"");
    }
    if (basicGraphFrameClass == null) {
      throw new InternalErrorException(null,null,""String_Node_Str"");
    }
 else     if (!basicGraphFrameClass.isInstance(_frame)) {
      throw new InternalErrorException(""String_Node_Str"" + _frame + ""String_Node_Str"");
    }
 else {
      BasicGraphFrame basicGraphFrame=(BasicGraphFrame)_frame;
      Query query=new Query();
      query.setTextWidth(60);
      query.addFileChooser(""String_Node_Str"",""String_Node_Str"",_lastLocation,null,basicGraphFrame.getLastDirectory(),true,false,PtolemyQuery.preferredBackgroundColor(_frame),PtolemyQuery.preferredForegroundColor(_frame));
      ComponentDialog dialog=new ComponentDialog(_frame,""String_Node_Str"",query);
      if (dialog.buttonPressed().equals(""String_Node_Str"")) {
        _lastLocation=query.getStringValue(""String_Node_Str"");
        GraphController controller=basicGraphFrame.getJGraph().getGraphPane().getGraphController();
        AbstractBasicGraphModel model=(AbstractBasicGraphModel)controller.getGraphModel();
        NamedObj context=model.getPtolemyModel();
        Rectangle2D bounds=basicGraphFrame.getVisibleCanvasRectangle();
        double x=bounds.getWidth() / 2.0;
        double y=bounds.getHeight() / 2.0;
        String fmuFileName=null;
        fmuFileName=_lastLocation;
        if (fmuFileName.equals(_fmuFileName)) {
          return;
        }
        _fmuFileName=fmuFileName;
        long modificationTime=new File(fmuFileName).lastModified();
        if (_fmuFileModificationTime == modificationTime) {
          return;
        }
        _fmuFileModificationTime=modificationTime;
        FMUImport.importFMU(this,fmuFileName,context,x,y);
      }
    }
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
  }
}"
73132,"/** 
 * Calculate the current schedule, if necessary, and iterate the contained actors in the order given by the schedule. Iterating an actor involves calling the actor's iterate() method, which is equivalent to calling the actor's prefire(), fire() and postfire() methods in succession.  If iterate() returns NOT_READY, indicating that the actor is not ready to execute, then an IllegalActionException will be thrown. The values returned from iterate() are recorded and are used to determine the value that postfire() will return at the end of the director's iteration. NOTE: This method does not conform with the strict actor semantics because it calls postfire() of actors. Thus, it should not be used in domains that require a strict actor semantics, such as SR or Continuous.
 * @exception IllegalActionException If any actor executed by thisactor return false in prefire.
 * @exception InvalidStateException If this director does not have acontainer.
 */
public void fire() throws IllegalActionException {
  Iterator firings=null;
  if (_savedSchedule == null) {
    Scheduler scheduler=getScheduler();
    if (scheduler == null) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    Schedule schedule=scheduler.getSchedule();
    _savedSchedule=schedule;
    _savedSchedulePosition=0;
    firings=schedule.firingIterator();
  }
 else {
    firings=_savedSchedule.firingIterator();
    for (int i=0; i < _savedSchedulePosition; i++) {
      firings.next();
    }
  }
  Firing firing=null;
  while ((_savedIterationCount > 0 || firings.hasNext()) && !_stopRequested) {
    if (firing == null || _savedIterationCount == 0) {
      firing=(Firing)firings.next();
    }
    Actor actor=firing.getActor();
    boolean finished=_schedule(actor,null,null);
    if (finished) {
      _waitingForResource=false;
    }
 else {
      _waitingForResource=true;
      break;
    }
    int iterationCount=firing.getIterationCount();
    if (_savedIterationCount == 0) {
      _savedIterationCount=firing.getIterationCount();
    }
    if (_debugging) {
      _debug(new FiringEvent(this,actor,FiringEvent.BEFORE_ITERATE,iterationCount));
    }
    int returnValue=actor.iterate(1);
    _savedIterationCount--;
    if (_savedIterationCount == 0) {
      _savedSchedulePosition++;
    }
    if (returnValue == STOP_ITERATING) {
      _postfireReturns=false;
    }
 else     if (returnValue == NOT_READY) {
      throw new IllegalActionException(this,actor,""String_Node_Str"" + ""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (_debugging) {
      _debug(new FiringEvent(this,actor,FiringEvent.AFTER_ITERATE,iterationCount));
    }
  }
  if (_savedSchedule.size() == _savedSchedulePosition) {
    _savedSchedule=null;
  }
}","/** 
 * Calculate the current schedule, if necessary, and iterate the contained actors in the order given by the schedule. Iterating an actor involves calling the actor's iterate() method, which is equivalent to calling the actor's prefire(), fire() and postfire() methods in succession.  If iterate() returns NOT_READY, indicating that the actor is not ready to execute, then an IllegalActionException will be thrown. The values returned from iterate() are recorded and are used to determine the value that postfire() will return at the end of the director's iteration. NOTE: This method does not conform with the strict actor semantics because it calls postfire() of actors. Thus, it should not be used in domains that require a strict actor semantics, such as SR or Continuous.
 * @exception IllegalActionException If any actor executed by thisactor return false in prefire.
 * @exception InvalidStateException If this director does not have acontainer.
 */
public void fire() throws IllegalActionException {
  Iterator firings=null;
  if (_savedSchedule == null) {
    Scheduler scheduler=getScheduler();
    if (scheduler == null) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    Schedule schedule=scheduler.getSchedule();
    _savedSchedule=schedule;
    _savedSchedulePosition=0;
    firings=schedule.firingIterator();
  }
 else {
    firings=_savedSchedule.firingIterator();
    for (int i=0; i < _savedSchedulePosition; i++) {
      firings.next();
    }
  }
  Firing firing=null;
  while ((_savedIterationCount > 0 || firings.hasNext()) && !_stopRequested) {
    if (firing == null || _savedIterationCount == 0) {
      firing=(Firing)firings.next();
    }
    Actor actor=firing.getActor();
    boolean finished=_schedule(actor,null,null);
    if (finished) {
      _waitingForResource=false;
    }
 else {
      _waitingForResource=true;
      break;
    }
    int iterationCount=firing.getIterationCount();
    if (_savedIterationCount == 0) {
      _savedIterationCount=firing.getIterationCount();
    }
    if (_debugging) {
      _debug(new FiringEvent(this,actor,FiringEvent.BEFORE_ITERATE,iterationCount));
    }
    int returnValue=actor.iterate(1);
    _savedIterationCount--;
    if (_savedIterationCount == 0) {
      _savedSchedulePosition++;
    }
    if (returnValue == STOP_ITERATING) {
      _postfireReturns=false;
    }
 else     if (returnValue == NOT_READY) {
      throw new IllegalActionException(this,actor,""String_Node_Str"" + ""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (_debugging) {
      _debug(new FiringEvent(this,actor,FiringEvent.AFTER_ITERATE,iterationCount));
    }
  }
  if (_savedSchedule.size() <= _savedSchedulePosition) {
    _savedSchedule=null;
  }
}"
73133,"/** 
 * Handle timing error on a PtidesPort.  FIXME: for now this can only drop the event that caused the error or throw a message.  TODO: implement different behaviors.
 * @param port The port where the error occurred.
 * @param event The event that caused the error; i.e. that arrived too late or out of order.
 * @param message The error message.
 * @return A new PtidesEvent that can be safely processed or null if no event should be processed.
 * @throws IllegalActionException If error handling actor throws this.
 */
private PtidesEvent _handleTimingError(PtidesPort port,PtidesEvent event,String message) throws IllegalActionException {
  List list=((CompositeActor)getContainer()).entityList();
  for (int i=0; i < list.size(); i++) {
    Object entity=list.get(i);
    if (entity instanceof CompositeActor && ((CompositeActor)entity).getName().equals(""String_Node_Str"")) {
      CompositeActor errorHandler=(CompositeActor)entity;
      List errorHandlerEntities=errorHandler.entityList();
      for (int j=0; j < errorHandlerEntities.size(); j++) {
        Object errorHandlerEntity=errorHandlerEntities.get(j);
        if (errorHandlerEntity instanceof Const && ((Const)errorHandlerEntity).getName().equals(""String_Node_Str"" + port.getName())) {
          ((Const)errorHandlerEntity).fire();
          errorHandler.fire();
          List attributes=errorHandler.attributeList();
          for (int k=0; k < attributes.size(); k++) {
            Attribute attribute=(Attribute)attributes.get(k);
            if (attribute instanceof Parameter) {
              if (((Parameter)attribute).getName().equals(""String_Node_Str"" + port.getName())) {
                return null;
              }
 else               if (((Parameter)attribute).getName().equals(""String_Node_Str"" + port.getName())) {
                return event;
              }
            }
          }
        }
      }
    }
  }
  throw new IllegalActionException(port,message);
}","/** 
 * Handle timing error on a PtidesPort.  FIXME: for now this can only drop the event that caused the error or throw a message.  TODO: implement different behaviors.
 * @param port The port where the error occurred.
 * @param event The event that caused the error; i.e. that arrived too late or out of order.
 * @param message The error message.
 * @return A new PtidesEvent that can be safely processed or null if no event should be processed.
 * @throws IllegalActionException If error handling actor throws this.
 */
private PtidesEvent _handleTimingError(PtidesPort port,PtidesEvent event,String message) throws IllegalActionException {
  List list=((CompositeActor)getContainer()).entityList();
  for (int i=0; i < list.size(); i++) {
    Object entity=list.get(i);
    if (entity instanceof CompositeActor && ((CompositeActor)entity).getName().equals(""String_Node_Str"")) {
      CompositeActor errorHandler=(CompositeActor)entity;
      List errorHandlerEntities=errorHandler.entityList();
      for (int j=0; j < errorHandlerEntities.size(); j++) {
        Object errorHandlerEntity=errorHandlerEntities.get(j);
        if (errorHandlerEntity instanceof Const && ((Const)errorHandlerEntity).getName().equals(""String_Node_Str"" + port.getName())) {
          ((Const)errorHandlerEntity).fire();
          Time time=errorHandler.getDirector().getModelNextIterationTime();
          int index=1;
          while (time.compareTo(getModelTime()) <= 0) {
            ((CompositeActor)errorHandler).getDirector().setModelTime(time);
            ((DEDirector)((CompositeActor)errorHandler).getDirector()).setIndex(index);
            ((CompositeActor)errorHandler).prefire();
            ((CompositeActor)errorHandler).fire();
            ((CompositeActor)errorHandler).postfire();
            Time previousTime=time;
            time=errorHandler.getDirector().getModelNextIterationTime();
            if (time.equals(previousTime)) {
              index++;
            }
 else {
              index=1;
            }
          }
          List attributes=errorHandler.attributeList();
          for (int k=0; k < attributes.size(); k++) {
            Attribute attribute=(Attribute)attributes.get(k);
            if (attribute instanceof Parameter) {
              if (((Parameter)attribute).getName().equals(""String_Node_Str"" + port.getName())) {
                if (((Parameter)attribute).getToken() != null && ((BooleanToken)((Parameter)attribute).getToken()).booleanValue()) {
                  ((Parameter)attribute).setToken(""String_Node_Str"");
                  return null;
                }
              }
              if (((Parameter)attribute).getName().equals(""String_Node_Str"" + port.getName())) {
                if (((Parameter)attribute).getToken() != null && ((BooleanToken)((Parameter)attribute).getToken()).booleanValue()) {
                  return event;
                }
              }
            }
          }
        }
      }
    }
  }
  throw new IllegalActionException(port,message);
}"
73134,"/** 
 * Route the given connector, returning a Polyline2D. This method is the same as route(), except that the return type is tighter.
 */
public Polyline2D routeManhattan(ManhattanConnector c){
  TransformContext currentContext=c.getTransformContext();
  Site headSite=c.getHeadSite();
  Site tailSite=c.getTailSite();
  Point2D headPt;
  Point2D tailPt;
  if (currentContext != null) {
    tailPt=tailSite.getPoint(currentContext);
    headPt=headSite.getPoint(currentContext);
  }
 else {
    tailPt=tailSite.getPoint();
    headPt=headSite.getPoint();
  }
  double radAngle=Math.atan2(tailPt.getY() - headPt.getY(),headPt.getX() - tailPt.getX());
  double distance=tailPt.distance(headPt);
  int headDir=_getManhattanDirection(radAngle,distance,true,headSite.hasNormal() ? CanvasUtilities.getDirection(headSite.getNormal()) : -1);
  headSite.setNormal(CanvasUtilities.getNormal(headDir));
  if (currentContext != null) {
    headPt=headSite.getPoint(currentContext);
  }
 else {
    headPt=headSite.getPoint();
  }
  int tailDir=_getManhattanDirection(radAngle,distance,false,tailSite.hasNormal() ? CanvasUtilities.getDirection(tailSite.getNormal()) : -1);
  tailSite.setNormal(CanvasUtilities.getNormal(tailDir));
  if (currentContext != null) {
    tailPt=tailSite.getPoint(currentContext);
  }
 else {
    tailPt=tailSite.getPoint();
  }
  headDir=CanvasUtilities.getDirection(headSite.getNormal());
  tailDir=CanvasUtilities.getDirection(tailSite.getNormal());
  double headAngle=CanvasUtilities.getNormal(headDir);
  double tailAngle=CanvasUtilities.getNormal(tailDir);
  if (c.getHeadEnd() != null) {
    c.getHeadEnd().setNormal(headAngle);
    c.getHeadEnd().setOrigin(headPt.getX(),headPt.getY());
    c.getHeadEnd().getConnection(headPt);
  }
  if (c.getTailEnd() != null) {
    c.getTailEnd().setNormal(tailAngle);
    c.getTailEnd().setOrigin(tailPt.getX(),tailPt.getY());
    c.getTailEnd().getConnection(tailPt);
  }
  Polyline2D route=_route(headPt,headDir,tailPt,tailDir);
  return route;
}","/** 
 * Route the given connector, returning a Polyline2D. This method is the same as route(), except that the return type is tighter.
 */
public Polyline2D routeManhattan(ManhattanConnector c){
  TransformContext currentContext=c.getTransformContext();
  Site headSite=c.getHeadSite();
  Site tailSite=c.getTailSite();
  Point2D headPt;
  Point2D tailPt;
  if (currentContext == null) {
    return new Polyline2D.Double();
  }
  tailPt=tailSite.getPoint(currentContext);
  headPt=headSite.getPoint(currentContext);
  double radAngle=Math.atan2(tailPt.getY() - headPt.getY(),headPt.getX() - tailPt.getX());
  double distance=tailPt.distance(headPt);
  int headDir=_getManhattanDirection(radAngle,distance,true,headSite.hasNormal() ? CanvasUtilities.getDirection(headSite.getNormal()) : -1);
  headSite.setNormal(CanvasUtilities.getNormal(headDir));
  headPt=headSite.getPoint(currentContext);
  int tailDir=_getManhattanDirection(radAngle,distance,false,tailSite.hasNormal() ? CanvasUtilities.getDirection(tailSite.getNormal()) : -1);
  tailSite.setNormal(CanvasUtilities.getNormal(tailDir));
  tailPt=tailSite.getPoint(currentContext);
  headDir=CanvasUtilities.getDirection(headSite.getNormal());
  tailDir=CanvasUtilities.getDirection(tailSite.getNormal());
  double headAngle=CanvasUtilities.getNormal(headDir);
  double tailAngle=CanvasUtilities.getNormal(tailDir);
  if (c.getHeadEnd() != null) {
    c.getHeadEnd().setNormal(headAngle);
    c.getHeadEnd().setOrigin(headPt.getX(),headPt.getY());
    c.getHeadEnd().getConnection(headPt);
  }
  if (c.getTailEnd() != null) {
    c.getTailEnd().setNormal(tailAngle);
    c.getTailEnd().setOrigin(tailPt.getX(),tailPt.getY());
    c.getTailEnd().getConnection(tailPt);
  }
  Polyline2D route=_route(headPt,headDir,tailPt,tailDir);
  return route;
}"
73135,"/** 
 * Route the given connector, returning a Polyline2D. This method is the same as route(), except that the return type is tighter.
 */
public Polyline2D routeManhattan(ManhattanConnector c){
  TransformContext currentContext=c.getTransformContext();
  Site headSite=c.getHeadSite();
  Site tailSite=c.getTailSite();
  Point2D headPt;
  Point2D tailPt;
  if (currentContext == null) {
    return new Polyline2D.Double();
  }
  tailPt=tailSite.getPoint(currentContext);
  headPt=headSite.getPoint(currentContext);
  double radAngle=Math.atan2(tailPt.getY() - headPt.getY(),headPt.getX() - tailPt.getX());
  double distance=tailPt.distance(headPt);
  int headDir=_getManhattanDirection(radAngle,distance,true,headSite.hasNormal() ? CanvasUtilities.getDirection(headSite.getNormal()) : -1);
  headSite.setNormal(CanvasUtilities.getNormal(headDir));
  headPt=headSite.getPoint(currentContext);
  int tailDir=_getManhattanDirection(radAngle,distance,false,tailSite.hasNormal() ? CanvasUtilities.getDirection(tailSite.getNormal()) : -1);
  tailSite.setNormal(CanvasUtilities.getNormal(tailDir));
  tailPt=tailSite.getPoint(currentContext);
  headDir=CanvasUtilities.getDirection(headSite.getNormal());
  tailDir=CanvasUtilities.getDirection(tailSite.getNormal());
  double headAngle=CanvasUtilities.getNormal(headDir);
  double tailAngle=CanvasUtilities.getNormal(tailDir);
  if (c.getHeadEnd() != null) {
    c.getHeadEnd().setNormal(headAngle);
    c.getHeadEnd().setOrigin(headPt.getX(),headPt.getY());
    c.getHeadEnd().getConnection(headPt);
  }
  if (c.getTailEnd() != null) {
    c.getTailEnd().setNormal(tailAngle);
    c.getTailEnd().setOrigin(tailPt.getX(),tailPt.getY());
    c.getTailEnd().getConnection(tailPt);
  }
  Polyline2D route=_route(headPt,headDir,tailPt,tailDir);
  return route;
}","/** 
 * Route the given connector, returning a Polyline2D. This method is the same as route(), except that the return type is tighter.
 */
public Polyline2D routeManhattan(ManhattanConnector c){
  TransformContext currentContext=c.getTransformContext();
  Site headSite=c.getHeadSite();
  Site tailSite=c.getTailSite();
  Point2D headPt;
  Point2D tailPt;
  if (currentContext == null) {
    tailPt=tailSite.getPoint();
    headPt=headSite.getPoint();
    Polyline2D.Double polyline=new Polyline2D.Double();
    polyline.moveTo(tailPt.getX(),tailPt.getY());
    polyline.lineTo(headPt.getX(),headPt.getY());
    return polyline;
  }
 else {
    tailPt=tailSite.getPoint(currentContext);
    headPt=headSite.getPoint(currentContext);
  }
  double radAngle=Math.atan2(tailPt.getY() - headPt.getY(),headPt.getX() - tailPt.getX());
  double distance=tailPt.distance(headPt);
  int headDir=_getManhattanDirection(radAngle,distance,true,headSite.hasNormal() ? CanvasUtilities.getDirection(headSite.getNormal()) : -1);
  headSite.setNormal(CanvasUtilities.getNormal(headDir));
  headPt=headSite.getPoint(currentContext);
  int tailDir=_getManhattanDirection(radAngle,distance,false,tailSite.hasNormal() ? CanvasUtilities.getDirection(tailSite.getNormal()) : -1);
  tailSite.setNormal(CanvasUtilities.getNormal(tailDir));
  tailPt=tailSite.getPoint(currentContext);
  headDir=CanvasUtilities.getDirection(headSite.getNormal());
  tailDir=CanvasUtilities.getDirection(tailSite.getNormal());
  double headAngle=CanvasUtilities.getNormal(headDir);
  double tailAngle=CanvasUtilities.getNormal(tailDir);
  if (c.getHeadEnd() != null) {
    c.getHeadEnd().setNormal(headAngle);
    c.getHeadEnd().setOrigin(headPt.getX(),headPt.getY());
    c.getHeadEnd().getConnection(headPt);
  }
  if (c.getTailEnd() != null) {
    c.getTailEnd().setNormal(tailAngle);
    c.getTailEnd().setOrigin(tailPt.getX(),tailPt.getY());
    c.getTailEnd().getConnection(tailPt);
  }
  Polyline2D route=_route(headPt,headDir,tailPt,tailDir);
  return route;
}"
73136,"/** 
 * Tell the connector to route itself between the current positions of the head and tail sites. If bend points are available, draw the line with these instead. Delete bend point information if modification detected (i.e., movement of one or the other end of a link).
 */
public void route(){
  List<Point2D> bendPointList=null;
  Object object=this.getUserObject();
  Link link=null;
  Relation relation=null;
  LayoutHintItem layoutHintItem=null;
  boolean considerBendPoints=false;
  if (object instanceof Link) {
    link=(Link)object;
    relation=link.getRelation();
    if (relation != null) {
      LayoutHint layoutHint=(LayoutHint)relation.getAttribute(""String_Node_Str"");
      if (layoutHint != null) {
        layoutHintItem=layoutHint.getLayoutHintItem(link.getHead(),link.getTail());
        if (layoutHintItem != null) {
          considerBendPoints=KielerLayout.isLayoutInProgress() || layoutHintItem.revalidate();
          if (considerBendPoints) {
            bendPointList=layoutHintItem.getBendPointList();
          }
 else {
            layoutHint.removeLayoutHintItem(layoutHintItem);
          }
        }
      }
    }
  }
  if (considerBendPoints) {
    repaint();
    GeneralPath path=new GeneralPath();
    Point2D[] startEnd=_getHeadTailPoints(bendPointList);
    double startX=startEnd[0].getX();
    double startY=startEnd[0].getY();
    double previousX=startX;
    double previousY=startY;
    double endX=startEnd[1].getX();
    double endY=startEnd[1].getY();
    path.moveTo((float)startX,(float)startY);
    bendPointList.add(0,new Point2D.Double(startX,startY));
    bendPointList.add(new Point2D.Double(endX,endY));
    for (int i=1; i <= bendPointList.size() - 1; i++) {
      int i1=i;
      int i0=i - 1;
      if (i0 < 0) {
        i0=0;
      }
      if (i0 > bendPointList.size() - 1) {
        i0=bendPointList.size() - 1;
      }
      double x0=previousX;
      double y0=previousY;
      double x1=bendPointList.get(i0).getX();
      double y1=bendPointList.get(i0).getY();
      double x2=bendPointList.get(i1).getX();
      double y2=bendPointList.get(i1).getY();
      x2=(x1 + x2) / 2;
      y2=(y1 + y2) / 2;
      double d0=Math.sqrt(((x1 - x0) * (x1 - x0)) + ((y1 - y0) * (y1 - y0)));
      double d1=Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));
      double r=Math.min(_bendRadius,d0);
      r=Math.min(r,d1);
      if ((d0 == 0.0) || (d1 == 0.0)) {
        path.lineTo((float)x1,(float)y1);
      }
 else {
        double intX0=x1 + ((r / d0) * (x0 - x1));
        double intY0=y1 + ((r / d0) * (y0 - y1));
        double intX1=x1 + ((r / d1) * (x2 - x1));
        double intY1=y1 + ((r / d1) * (y2 - y1));
        path.lineTo((float)intX0,(float)intY0);
        path.curveTo((float)x1,(float)y1,(float)x1,(float)y1,(float)intX1,(float)intY1);
        previousX=x2;
        previousY=y2;
      }
    }
    path.lineTo((float)endX,(float)endY);
    setShape(path);
    int count=bendPointList.size();
    Point2D point1=bendPointList.get(count / 2 - 1);
    Point2D point2=bendPointList.get(count / 2);
    _labelLocation=(new Point2D.Double((point1.getX() + point2.getX()) / 2,(point1.getY() + point2.getY()) / 2));
    repositionLabel();
    repaint();
  }
 else {
    super.route();
  }
}","/** 
 * Tell the connector to route itself between the current positions of the head and tail sites. If bend points are available, draw the line with these instead. Delete bend point information if modification detected (i.e., movement of one or the other end of a link).
 */
public void route(){
  List<Point2D> bendPointList=null;
  Object object=this.getUserObject();
  Link link=null;
  Relation relation=null;
  LayoutHintItem layoutHintItem=null;
  boolean considerBendPoints=false;
  if (object instanceof Link) {
    link=(Link)object;
    relation=link.getRelation();
    if (relation != null) {
      LayoutHint layoutHint=(LayoutHint)relation.getAttribute(""String_Node_Str"");
      if (layoutHint != null) {
        layoutHintItem=layoutHint.getLayoutHintItem(link.getHead(),link.getTail());
        if (layoutHintItem != null) {
          considerBendPoints=_layoutInProgress || layoutHintItem.revalidate();
          if (considerBendPoints) {
            bendPointList=layoutHintItem.getBendPointList();
          }
 else {
            layoutHint.removeLayoutHintItem(layoutHintItem);
          }
        }
      }
    }
  }
  if (considerBendPoints) {
    repaint();
    GeneralPath path=new GeneralPath();
    Point2D[] startEnd=_getHeadTailPoints(bendPointList);
    double startX=startEnd[0].getX();
    double startY=startEnd[0].getY();
    double previousX=startX;
    double previousY=startY;
    double endX=startEnd[1].getX();
    double endY=startEnd[1].getY();
    path.moveTo((float)startX,(float)startY);
    bendPointList.add(0,new Point2D.Double(startX,startY));
    bendPointList.add(new Point2D.Double(endX,endY));
    for (int i=1; i <= bendPointList.size() - 1; i++) {
      int i1=i;
      int i0=i - 1;
      if (i0 < 0) {
        i0=0;
      }
      if (i0 > bendPointList.size() - 1) {
        i0=bendPointList.size() - 1;
      }
      double x0=previousX;
      double y0=previousY;
      double x1=bendPointList.get(i0).getX();
      double y1=bendPointList.get(i0).getY();
      double x2=bendPointList.get(i1).getX();
      double y2=bendPointList.get(i1).getY();
      x2=(x1 + x2) / 2;
      y2=(y1 + y2) / 2;
      double d0=Math.sqrt(((x1 - x0) * (x1 - x0)) + ((y1 - y0) * (y1 - y0)));
      double d1=Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));
      double r=Math.min(_bendRadius,d0);
      r=Math.min(r,d1);
      if ((d0 == 0.0) || (d1 == 0.0)) {
        path.lineTo((float)x1,(float)y1);
      }
 else {
        double intX0=x1 + ((r / d0) * (x0 - x1));
        double intY0=y1 + ((r / d0) * (y0 - y1));
        double intX1=x1 + ((r / d1) * (x2 - x1));
        double intY1=y1 + ((r / d1) * (y2 - y1));
        path.lineTo((float)intX0,(float)intY0);
        path.curveTo((float)x1,(float)y1,(float)x1,(float)y1,(float)intX1,(float)intY1);
        previousX=x2;
        previousY=y2;
      }
    }
    path.lineTo((float)endX,(float)endY);
    setShape(path);
    int count=bendPointList.size();
    Point2D point1=bendPointList.get(count / 2 - 1);
    Point2D point2=bendPointList.get(count / 2);
    _labelLocation=(new Point2D.Double((point1.getX() + point2.getX()) / 2,(point1.getY() + point2.getY()) / 2));
    repositionLabel();
    repaint();
  }
 else {
    super.route();
  }
}"
73137,"/** 
 * Layout the given composite. Main entry point for the layout action. Create a KIELER KGraph data structure corresponding to the Ptolemy model, instantiate a KIELER layout algorithm (AbstractLayoutProvider) and run its doLayout() method on the KGraph. The KGraph is augmented with layout information (position and sizes of objects and bend points for connections). This information is then reapplied to the ptolemy model by stating MoMLChangeRequests with location attributes for nodes. Connection bend points are applied using   {@link LayoutHint}s.
 * @param composite the container of the diagram in terms of a GraphModel.
 */
@Override public void layout(Object composite){
  _layoutInProgress=true;
  long overallTime=System.currentTimeMillis();
  _report(""String_Node_Str"");
  long graphOverhead=overallTime;
  KNode parentNode=KimlUtil.createInitializedNode();
  KShapeLayout parentLayout=parentNode.getData(KShapeLayout.class);
  if (_top != null) {
    Dimension contentSize=_top.getContentSize();
    parentLayout.setWidth(contentSize.width);
    parentLayout.setHeight(contentSize.height);
  }
  try {
    Parameters parameters=new Parameters(_compositeEntity);
    parameters.configureLayout(parentLayout,getLayoutTarget().getGraphModel());
    _createGraph(composite,parentNode);
    graphOverhead=System.currentTimeMillis() - graphOverhead;
    InstancePool<AbstractLayoutProvider> layouterPool=_getLayouterPool();
    AbstractLayoutProvider layoutProvider=layouterPool.fetch();
    IKielerProgressMonitor progressMonitor=new BasicProgressMonitor();
    layoutProvider.doLayout(parentNode,progressMonitor);
    if (DEBUG) {
      KielerGraphUtil._writeToFile(parentNode);
    }
    KVector offset=KielerGraphUtil._getUpperLeftCorner(parentNode);
    parentLayout.setXpos(parentLayout.getXpos() - (float)offset.x);
    parentLayout.setYpos(parentLayout.getYpos() - (float)offset.y);
    long momlRequestOverhead=System.currentTimeMillis();
    _applyLayout(parentNode);
    momlRequestOverhead=System.currentTimeMillis() - momlRequestOverhead;
    overallTime=System.currentTimeMillis() - overallTime;
    _report(""String_Node_Str"" + overallTime + ""String_Node_Str""+ graphOverhead+ ""String_Node_Str""+ Math.round(progressMonitor.getExecutionTime() * 1000)+ ""String_Node_Str""+ momlRequestOverhead+ ""String_Node_Str"");
    layouterPool.release(layoutProvider);
  }
 catch (  IllegalActionException exception) {
    throw new InternalErrorException(exception);
  }
  _layoutInProgress=false;
}","/** 
 * Layout the given composite. Main entry point for the layout action. Create a KIELER KGraph data structure corresponding to the Ptolemy model, instantiate a KIELER layout algorithm (AbstractLayoutProvider) and run its doLayout() method on the KGraph. The KGraph is augmented with layout information (position and sizes of objects and bend points for connections). This information is then reapplied to the ptolemy model by stating MoMLChangeRequests with location attributes for nodes. Connection bend points are applied using   {@link LayoutHint}s.
 * @param composite the container of the diagram in terms of a GraphModel.
 */
@Override public void layout(Object composite){
  KielerLayoutConnector.setLayoutInProgress(true);
  long overallTime=System.currentTimeMillis();
  _report(""String_Node_Str"");
  long graphOverhead=overallTime;
  KNode parentNode=KimlUtil.createInitializedNode();
  KShapeLayout parentLayout=parentNode.getData(KShapeLayout.class);
  if (_top != null) {
    Dimension contentSize=_top.getContentSize();
    parentLayout.setWidth(contentSize.width);
    parentLayout.setHeight(contentSize.height);
  }
  try {
    Parameters parameters=new Parameters(_compositeEntity);
    parameters.configureLayout(parentLayout,getLayoutTarget().getGraphModel());
    _createGraph(composite,parentNode);
    graphOverhead=System.currentTimeMillis() - graphOverhead;
    InstancePool<AbstractLayoutProvider> layouterPool=_getLayouterPool();
    AbstractLayoutProvider layoutProvider=layouterPool.fetch();
    IKielerProgressMonitor progressMonitor=new BasicProgressMonitor();
    layoutProvider.doLayout(parentNode,progressMonitor);
    if (DEBUG) {
      KielerGraphUtil._writeToFile(parentNode);
    }
    KVector offset=KielerGraphUtil._getUpperLeftCorner(parentNode);
    parentLayout.setXpos(parentLayout.getXpos() - (float)offset.x);
    parentLayout.setYpos(parentLayout.getYpos() - (float)offset.y);
    long momlRequestOverhead=System.currentTimeMillis();
    _applyLayout(parentNode);
    momlRequestOverhead=System.currentTimeMillis() - momlRequestOverhead;
    overallTime=System.currentTimeMillis() - overallTime;
    _report(""String_Node_Str"" + overallTime + ""String_Node_Str""+ graphOverhead+ ""String_Node_Str""+ Math.round(progressMonitor.getExecutionTime() * 1000)+ ""String_Node_Str""+ momlRequestOverhead+ ""String_Node_Str"");
    layouterPool.release(layoutProvider);
  }
 catch (  IllegalActionException exception) {
    throw new InternalErrorException(exception);
  }
  KielerLayoutConnector.setLayoutInProgress(false);
}"
73138,"/** 
 * Return the visible Settables of NamedObj object. When addDecoratedAttributes is true we will also return the decorated attributes. In case the passed NamedObj is the top level container, the parameter enableBackwardTypeInference is added if not present, with default value false.
 * @param object The named object for which to show the visibleSettables
 * @param addDecoratedAttributes A flag that specifies whetherdecorated attributes should also be included.
 * @return The visible attributes.
 */
static private Set<Settable> _getVisibleSettables(final NamedObj object,boolean addDecoratedAttributes){
  Set<Settable> attributes=new HashSet<Settable>();
  Iterator<?> parameters=object.attributeList(Settable.class).iterator();
  if (object.equals(object.toplevel())) {
    try {
      Parameter onlyForward=(Parameter)object.getAttribute(""String_Node_Str"",Parameter.class);
      if (onlyForward == null) {
        onlyForward=new Parameter(object,""String_Node_Str"");
        onlyForward.setExpression(""String_Node_Str"");
        attributes.add((Settable)onlyForward);
      }
      onlyForward.setTypeEquals(BaseType.BOOLEAN);
    }
 catch (    KernelException e) {
      throw new InternalErrorException(e);
    }
  }
  while (parameters.hasNext()) {
    Settable parameter=(Settable)parameters.next();
    if (isVisible(object,parameter)) {
      attributes.add(parameter);
    }
  }
  if (addDecoratedAttributes) {
    List<Decorator> decorators=DecoratedAttributesImplementation.findDecorators(object);
    for (    Decorator decorator : decorators) {
      DecoratedAttributes decoratedAttributes=object.getDecoratorAttributes(decorator);
      for (      Object attribute : decoratedAttributes.attributeList()) {
        if (attribute instanceof Settable) {
          Settable settable=(Settable)attribute;
          if (isVisible(object,settable)) {
            attributes.add(settable);
          }
        }
      }
    }
  }
  return attributes;
}","/** 
 * Return the visible Settables of NamedObj object. When addDecoratedAttributes is true we will also return the decorated attributes. In case the passed NamedObj is the top level container, the parameter enableBackwardTypeInference is added if not present, with default value false.
 * @param object The named object for which to show the visibleSettables
 * @param addDecoratedAttributes A flag that specifies whetherdecorated attributes should also be included.
 * @return The visible attributes.
 */
static private Set<Settable> _getVisibleSettables(final NamedObj object,boolean addDecoratedAttributes){
  Set<Settable> attributes=new HashSet<Settable>();
  Iterator<?> parameters=object.attributeList(Settable.class).iterator();
  if (object.equals(object.toplevel())) {
    try {
      Parameter backwardTypeInf=(Parameter)object.getAttribute(""String_Node_Str"",Parameter.class);
      if (backwardTypeInf == null) {
        backwardTypeInf=new Parameter(object,""String_Node_Str"");
        backwardTypeInf.setExpression(""String_Node_Str"");
        attributes.add((Settable)backwardTypeInf);
      }
      backwardTypeInf.setTypeEquals(BaseType.BOOLEAN);
    }
 catch (    KernelException e) {
      throw new InternalErrorException(e);
    }
  }
  while (parameters.hasNext()) {
    Settable parameter=(Settable)parameters.next();
    if (isVisible(object,parameter)) {
      attributes.add(parameter);
    }
  }
  if (addDecoratedAttributes) {
    List<Decorator> decorators=DecoratedAttributesImplementation.findDecorators(object);
    for (    Decorator decorator : decorators) {
      DecoratedAttributes decoratedAttributes=object.getDecoratorAttributes(decorator);
      for (      Object attribute : decoratedAttributes.attributeList()) {
        if (attribute instanceof Settable) {
          Settable settable=(Settable)attribute;
          if (isVisible(object,settable)) {
            attributes.add(settable);
          }
        }
      }
    }
  }
  return attributes;
}"
73139,"/** 
 * Return the current value of this monotonic function.
 * @return A Type.
 * @throws IllegalActionException If the type of the argumentcannot be determined.
 */
public Object getValue() throws IllegalActionException {
  Type type=_typeable.getType();
  return new ArrayType(type);
}","/** 
 * Return the current value of this monotonic function.
 * @return A Type.
 * @throws IllegalActionException If the type of the argumentcannot be determined.
 */
public Object getValue() throws IllegalActionException {
  Type type=_typeable.getType();
  if (_arrayLength > 0) {
    return new ArrayType(type,_arrayLength);
  }
 else {
    return new ArrayType(type);
  }
}"
73140,"/** 
 * Construct a ArrayElementTypeFunction whose argument is the type of the specified object.  
 * @param typeable A Typeable object.
 */
public ArrayOfTypesFunction(Typeable typeable){
  _typeable=typeable;
}","/** 
 * Construct a ArrayElementTypeFunction whose argument is the type of the specified object.  
 * @param typeable A Typeable object.
 * @param arrayLength The length of the array.
 */
public ArrayOfTypesFunction(Typeable typeable,int arrayLength){
  _typeable=typeable;
  _arrayLength=arrayLength;
}"
73141,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ArrayToSequence newObject=(ArrayToSequence)(super.clone(workspace));
  try {
    newObject.output.setTypeAtLeast(ArrayType.elementType(newObject.input));
    newObject.input.setTypeAtLeast(new ArrayOfTypesFunction(newObject.output));
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e);
  }
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ArrayToSequence newObject=(ArrayToSequence)(super.clone(workspace));
  try {
    newObject.output.setTypeAtLeast(ArrayType.elementType(newObject.input));
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e);
  }
  return newObject;
}"
73142,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ArrayToSequence(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output.setTypeAtLeast(ArrayType.elementType(input));
  input.setTypeAtLeast(new ArrayOfTypesFunction(output));
  arrayLength=new Parameter(this,""String_Node_Str"");
  arrayLength.setExpression(""String_Node_Str"");
  enforceArrayLength=new Parameter(this,""String_Node_Str"");
  enforceArrayLength.setExpression(""String_Node_Str"");
  enforceArrayLength.setTypeEquals(BaseType.BOOLEAN);
  output_tokenProductionRate.setExpression(""String_Node_Str"");
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ArrayToSequence(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output.setTypeAtLeast(ArrayType.elementType(input));
  arrayLength=new Parameter(this,""String_Node_Str"");
  arrayLength.setExpression(""String_Node_Str"");
  enforceArrayLength=new Parameter(this,""String_Node_Str"");
  enforceArrayLength.setExpression(""String_Node_Str"");
  enforceArrayLength.setTypeEquals(BaseType.BOOLEAN);
  output_tokenProductionRate.setExpression(""String_Node_Str"");
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}"
73143,"/** 
 * Update the size, zoom and position of the window. This method is typically called when closing the window or writing the moml file out.
 * @exception IllegalActionException If there is a problemgetting a parameter.
 * @exception NameDuplicationException If there is a problemcreating a parameter.
 */
private void _updateWindowAttributes() throws IllegalActionException, NameDuplicationException {
  Component component=_getRightComponent().getParent();
  Component parent=component.getParent();
  while ((parent != null) && !(parent instanceof Frame)) {
    component=parent;
    parent=component.getParent();
  }
  if (parent != null) {
    WindowPropertiesAttribute properties=(WindowPropertiesAttribute)getModel().getAttribute(""String_Node_Str"",WindowPropertiesAttribute.class);
    if (properties == null) {
      properties=new WindowPropertiesAttribute(getModel(),""String_Node_Str"");
    }
    properties.recordProperties((Frame)parent);
  }
  _createSizeAttribute();
  JCanvas canvas=getJGraph().getGraphPane().getCanvas();
  AffineTransform current=canvas.getCanvasPane().getTransformContext().getTransform();
  double scale=current.getScaleX();
  Parameter zoom=(Parameter)getModel().getAttribute(""String_Node_Str"",Parameter.class);
  boolean updateValue=false;
  if (zoom == null) {
    zoom=new ExpertParameter(getModel(),""String_Node_Str"");
    updateValue=true;
  }
 else {
    double oldZoom=((DoubleToken)zoom.getToken()).doubleValue();
    if (oldZoom != scale) {
      updateValue=true;
    }
  }
  boolean toplevelHasEntities=false;
  if (updateValue) {
    if (((CompositeEntity)getModel().toplevel()).getEntities().hasMoreElements()) {
      toplevelHasEntities=true;
      String moml=""String_Node_Str"" + ""String_Node_Str"" + scale + ""String_Node_Str"";
      MoMLChangeRequest request=new MoMLChangeRequest(this,getModel(),moml);
      request.setUndoable(true);
      getModel().requestChange(request);
      zoom.setVisibility(Settable.EXPERT);
    }
  }
  Point2D center=getCenter();
  Parameter pan=(Parameter)getModel().getAttribute(""String_Node_Str"",Parameter.class);
  updateValue=false;
  if (pan == null) {
    pan=new ExpertParameter(getModel(),""String_Node_Str"");
    updateValue=true;
  }
 else {
    Token[] oldCenter=((ArrayToken)pan.getToken()).arrayValue();
    double oldCenterX=((DoubleToken)oldCenter[0]).doubleValue();
    double oldCenterY=((DoubleToken)oldCenter[1]).doubleValue();
    if (center.getX() != oldCenterX || center.getY() != oldCenterY) {
      updateValue=true;
    }
  }
  if (updateValue && toplevelHasEntities) {
    String moml=""String_Node_Str"" + ""String_Node_Str"" + center.getX() + ""String_Node_Str""+ center.getY()+ ""String_Node_Str"";
    MoMLChangeRequest request=new MoMLChangeRequest(this,getModel(),moml);
    request.setUndoable(true);
    getModel().requestChange(request);
    pan.setVisibility(Settable.EXPERT);
  }
}","/** 
 * Update the size, zoom and position of the window. This method is typically called when closing the window or writing the moml file out.
 * @exception IllegalActionException If there is a problemgetting a parameter.
 * @exception NameDuplicationException If there is a problemcreating a parameter.
 */
private void _updateWindowAttributes() throws IllegalActionException, NameDuplicationException {
  Component component=_getRightComponent().getParent();
  Component parent=component.getParent();
  while ((parent != null) && !(parent instanceof Frame)) {
    component=parent;
    parent=component.getParent();
  }
  if (parent != null) {
    WindowPropertiesAttribute properties=(WindowPropertiesAttribute)getModel().getAttribute(""String_Node_Str"",WindowPropertiesAttribute.class);
    if (properties == null) {
      properties=new WindowPropertiesAttribute(getModel(),""String_Node_Str"");
    }
    properties.recordProperties((Frame)parent);
  }
  _createSizeAttribute();
  JCanvas canvas=getJGraph().getGraphPane().getCanvas();
  AffineTransform current=canvas.getCanvasPane().getTransformContext().getTransform();
  double scale=current.getScaleX();
  Parameter zoom=(Parameter)getModel().getAttribute(""String_Node_Str"",Parameter.class);
  boolean updateValue=false;
  if (zoom == null || zoom.getToken() == null) {
    zoom=new ExpertParameter(getModel(),""String_Node_Str"");
    zoom.setToken(""String_Node_Str"");
    updateValue=true;
  }
 else {
    double oldZoom=((DoubleToken)zoom.getToken()).doubleValue();
    if (oldZoom != scale) {
      updateValue=true;
    }
  }
  boolean toplevelHasEntities=false;
  if (updateValue) {
    if (((CompositeEntity)getModel().toplevel()).getEntities().hasMoreElements()) {
      toplevelHasEntities=true;
      String moml=""String_Node_Str"" + ""String_Node_Str"" + scale + ""String_Node_Str"";
      MoMLChangeRequest request=new MoMLChangeRequest(this,getModel(),moml);
      request.setUndoable(true);
      getModel().requestChange(request);
      zoom.setVisibility(Settable.EXPERT);
    }
  }
  Point2D center=getCenter();
  Parameter pan=(Parameter)getModel().getAttribute(""String_Node_Str"",Parameter.class);
  updateValue=false;
  if (pan == null || pan.getToken() == null) {
    pan=new ExpertParameter(getModel(),""String_Node_Str"");
    pan.setToken(""String_Node_Str"" + center.getX() + ""String_Node_Str""+ center.getY()+ ""String_Node_Str"");
    updateValue=true;
  }
 else {
    Token[] oldCenter=((ArrayToken)pan.getToken()).arrayValue();
    double oldCenterX=((DoubleToken)oldCenter[0]).doubleValue();
    double oldCenterY=((DoubleToken)oldCenter[1]).doubleValue();
    if (center.getX() != oldCenterX || center.getY() != oldCenterY) {
      updateValue=true;
    }
  }
  if (updateValue && toplevelHasEntities) {
    String moml=""String_Node_Str"" + ""String_Node_Str"" + center.getX() + ""String_Node_Str""+ center.getY()+ ""String_Node_Str"";
    MoMLChangeRequest request=new MoMLChangeRequest(this,getModel(),moml);
    request.setUndoable(true);
    getModel().requestChange(request);
    pan.setVisibility(Settable.EXPERT);
  }
}"
73144,"/** 
 * Schedule a new actor for execution and return the next time this scheduler has to perform a reschedule.
 * @param actor The actor to be scheduled.
 * @param currentPlatformTime The current platform time.
 * @return Relative time when this Scheduler has to be executedagain.
 * @throws IllegalActionException Thrown if actor paramaters suchas execution time or priority cannot be read.
 */
@Override public Time schedule(Actor actor,Time currentPlatformTime) throws IllegalActionException {
  _lastActorFinished=false;
  event(this,currentPlatformTime.getDoubleValue(),ExecutionEventType.START);
  event(this,currentPlatformTime.getDoubleValue(),ExecutionEventType.STOP);
  Time executionTime=null;
  Double executionTimeDouble=_executionTimes.get(actor);
  if (executionTimeDouble == null) {
    executionTime=getTime(0.0);
  }
 else {
    executionTime=getTime(executionTimeDouble);
  }
  Time remainingTime=null;
  if (_currentlyExecuting.size() == 0) {
    scheduleNewActor(actor,currentPlatformTime,executionTime);
    remainingTime=executionTime;
  }
 else {
    Actor executing=_currentlyExecuting.peek();
    Time lasttime=_lastTimeScheduled.get(executing);
    Time timePassed=currentPlatformTime.subtract(lasttime);
    remainingTime=_remainingTimes.get(executing).subtract(timePassed);
    _remainingTimes.put(executing,remainingTime);
    _lastTimeScheduled.put(executing,currentPlatformTime);
    if (!_currentlyExecuting.contains(actor) && executing != actor) {
      int executingPriority=_getPriority(executing);
      int newActorPriority=_getPriority(actor);
      if (newActorPriority < executingPriority) {
        remainingTime=executionTime;
        event(executing,currentPlatformTime.getDoubleValue(),ExecutionEventType.PREEMPTED);
        scheduleNewActor(actor,currentPlatformTime,executionTime);
      }
    }
 else {
      _lastTimeScheduled.put(actor,currentPlatformTime);
    }
  }
  if (remainingTime.getDoubleValue() == 0.0 && _currentlyExecuting.peek() == actor) {
    event(_currentlyExecuting.peek(),currentPlatformTime.getDoubleValue(),ExecutionEventType.STOP);
    _remainingTimes.put(_currentlyExecuting.peek(),null);
    _currentlyExecuting.pop();
    if (_currentlyExecuting.size() > 0) {
      remainingTime=_remainingTimes.get(_currentlyExecuting.peek());
      event(_currentlyExecuting.peek(),currentPlatformTime.getDoubleValue(),ExecutionEventType.START);
    }
    _lastActorFinished=true;
  }
  return remainingTime;
}","/** 
 * Schedule a new actor for execution and return the next time this scheduler has to perform a reschedule.
 * @param actor The actor to be scheduled.
 * @param currentPlatformTime The current platform time.
 * @return Relative time when this Scheduler has to be executedagain.
 * @throws IllegalActionException Thrown if actor paramaters suchas execution time or priority cannot be read.
 */
@Override public Time schedule(Actor actor,Time currentPlatformTime) throws IllegalActionException {
  _lastActorFinished=false;
  event(this,currentPlatformTime.getDoubleValue(),ExecutionEventType.START);
  event(this,currentPlatformTime.getDoubleValue(),ExecutionEventType.STOP);
  Time executionTime=null;
  Double executionTimeDouble=_executionTimes.get(actor);
  if (executionTimeDouble == null) {
    executionTime=getTime(0.0);
  }
 else {
    executionTime=getTime(executionTimeDouble);
  }
  Time remainingTime=null;
  if (_currentlyExecuting.size() == 0) {
    scheduleNewActor(actor,currentPlatformTime,executionTime);
    remainingTime=executionTime;
  }
 else {
    Actor executing=_currentlyExecuting.peek();
    Time lasttime=_lastTimeScheduled.get(executing);
    Time timePassed=currentPlatformTime.subtract(lasttime);
    remainingTime=_remainingTimes.get(executing).subtract(timePassed);
    if (remainingTime.getDoubleValue() < 0) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    _remainingTimes.put(executing,remainingTime);
    if (!_currentlyExecuting.contains(actor) && executing != actor) {
      int executingPriority=_getPriority(executing);
      int newActorPriority=_getPriority(actor);
      if (newActorPriority < executingPriority) {
        remainingTime=executionTime;
        event(executing,currentPlatformTime.getDoubleValue(),ExecutionEventType.PREEMPTED);
        scheduleNewActor(actor,currentPlatformTime,executionTime);
      }
    }
    for (    Actor preemptedActor : _currentlyExecuting) {
      _lastTimeScheduled.put(preemptedActor,currentPlatformTime);
    }
  }
  if (remainingTime.getDoubleValue() == 0.0 && _currentlyExecuting.peek() == actor) {
    event(_currentlyExecuting.peek(),currentPlatformTime.getDoubleValue(),ExecutionEventType.STOP);
    _remainingTimes.put(_currentlyExecuting.peek(),null);
    _currentlyExecuting.pop();
    if (_currentlyExecuting.size() > 0) {
      remainingTime=_remainingTimes.get(_currentlyExecuting.peek());
      event(_currentlyExecuting.peek(),currentPlatformTime.getDoubleValue(),ExecutionEventType.START);
    }
    _lastActorFinished=true;
  }
  return remainingTime;
}"
73145,"/** 
 * Calculate the delay offset for each input port.  The delay offset is used in the safe-to-process analysis to know when no future events can occur at a sensor or network  receiver port that can result in an event arriving at an input port with an earlier timestamp than the event currently there.
 * @exception IllegalActionException If cannot set 'delayOffset' parameterfor an input port.
 */
protected void _calculateDelayOffsets() throws IllegalActionException {
  for (  TypedIOPort port : _inputPorts) {
    if (port instanceof SensorPort || port instanceof NetworkReceiverPort) {
      continue;
    }
    double delayOffset=Double.POSITIVE_INFINITY;
    for (    TypedIOPort inputPort : _inputPorts) {
      if (!(inputPort instanceof SensorPort || inputPort instanceof NetworkReceiverPort)) {
        continue;
      }
      double deviceDelayBound=_getDoubleParameterValue(inputPort,""String_Node_Str"");
      if (inputPort instanceof NetworkReceiverPort) {
        deviceDelayBound+=_getDoubleParameterValue(inputPort,""String_Node_Str"");
        deviceDelayBound+=_getDoubleParameterValue(inputPort,""String_Node_Str"");
      }
      SuperdenseDependency minDelay=SuperdenseDependency.OPLUS_IDENTITY;
      for (      TypedIOPort groupPort : _inputPortGroups.get(port)) {
        minDelay=(SuperdenseDependency)minDelay.oPlus(_getSuperdenseDependencyPair(inputPort,groupPort));
      }
      double thisDelayOffset=minDelay.timeValue() - deviceDelayBound;
      if (thisDelayOffset < delayOffset) {
        delayOffset=thisDelayOffset;
      }
    }
    _setDelayOffset(port,delayOffset - ((DoubleToken)clockSynchronizationErrorBound.getToken()).doubleValue());
  }
  for (  Object entity : ((CompositeActor)getContainer()).entityList()) {
    if (entity instanceof TimeDelay) {
      _setDelayOffset((NamedObj)entity,((DoubleToken)((TimeDelay)entity).minimumDelay.getToken()).doubleValue());
    }
  }
}","/** 
 * Calculate the delay offset for each input port.  The delay offset is used in the safe-to-process analysis to know when no future events can occur at a sensor or network  receiver port that can result in an event arriving at an input port with an earlier timestamp than the event currently there.
 * @exception IllegalActionException If cannot set 'delayOffset' parameterfor an input port.
 */
protected void _calculateDelayOffsets() throws IllegalActionException {
  for (  TypedIOPort port : _inputPorts) {
    if (port instanceof SensorPort || port instanceof NetworkReceiverPort) {
      continue;
    }
    double delayOffset=Double.POSITIVE_INFINITY;
    for (    TypedIOPort inputPort : _inputPorts) {
      if (!(inputPort instanceof SensorPort || inputPort instanceof NetworkReceiverPort)) {
        continue;
      }
      double deviceDelayBound=_getDoubleParameterValue(inputPort,""String_Node_Str"");
      if (inputPort instanceof NetworkReceiverPort) {
        deviceDelayBound+=_getDoubleParameterValue(inputPort,""String_Node_Str"");
        deviceDelayBound+=_getDoubleParameterValue(inputPort,""String_Node_Str"");
      }
      SuperdenseDependency minDelay=SuperdenseDependency.OPLUS_IDENTITY;
      for (      TypedIOPort groupPort : _inputPortGroups.get(port)) {
        minDelay=(SuperdenseDependency)minDelay.oPlus(_getSuperdenseDependencyPair(inputPort,groupPort));
      }
      double thisDelayOffset=minDelay.timeValue() - deviceDelayBound;
      if (thisDelayOffset < delayOffset) {
        delayOffset=thisDelayOffset;
      }
    }
    _setDelayOffset(port,delayOffset - ((DoubleToken)clockSynchronizationErrorBound.getToken()).doubleValue());
  }
  for (  Object entity : ((CompositeActor)getContainer()).entityList()) {
    if (entity instanceof TimeDelay) {
      _setDelayOffset((NamedObj)entity,((DoubleToken)((TimeDelay)entity).minimumDelay.getToken()).doubleValue());
    }
    if (entity instanceof Source) {
      Double delayOffset=_getDoubleParameterValue((NamedObj)entity,""String_Node_Str"");
      if (delayOffset != null && delayOffset.doubleValue() > 0.0) {
        Actor actor=((Source)entity);
        for (        Object object : actor.outputPortList()) {
          IOPort port=((IOPort)object);
          for (          Object sink : port.sinkPortList()) {
            _setDelayOffset((NamedObj)sink,delayOffset);
          }
        }
      }
    }
  }
}"
73146,"/** 
 * Return the actor to fire in this iteration, or null if no actor should be fired. Since _checkForNextEvent() always returns true, this method will keep being called until it returns null.  
 * @exception IllegalActionException If _isSafeToProcess() throws it.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  for (  PtidesEvent event : _pureEvents) {
    if (_isSafeToProcess(event)) {
      Time time=scheduleActor(event.actor());
      Boolean finished=actorFinished(event.actor());
      if (time != null && time.getDoubleValue() > 0.0) {
        fireContainerAt(getEnvironmentTime().add(time));
      }
      if (time == null || finished) {
        _currentLogicalTime=event.timeStamp();
        _pureEvents.poll();
        return event.actor();
      }
    }
  }
  for (  Object event : _eventQueue.toArray()) {
    if (_isSafeToProcess((PtidesEvent)event)) {
      Time time=scheduleActor(((PtidesEvent)event).actor());
      Boolean finished=actorFinished(((PtidesEvent)event).actor());
      if (time != null && time.getDoubleValue() > 0.0) {
        fireContainerAt(getEnvironmentTime().add(time));
      }
      if (time == null || finished) {
        _currentLogicalTime=((PtidesEvent)event).timeStamp();
        _removeEventsFromQueue((PtidesEvent)event);
        return ((PtidesEvent)event).actor();
      }
    }
  }
  _currentLogicalTime=null;
  return null;
}","/** 
 * Return the actor to fire in this iteration, or null if no actor should be fired. Since _checkForNextEvent() always returns true, this method will keep being called until it returns null.  
 * @exception IllegalActionException If _isSafeToProcess() throws it.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  for (  PtidesEvent event : _pureEvents) {
    if (_isSafeToProcess(event)) {
      Time time=scheduleActor(event.actor());
      Boolean finished=actorFinished(event.actor());
      if (time != null && time.getDoubleValue() > 0.0) {
        fireContainerAt(getEnvironmentTime().add(time));
      }
      if (time == null || finished) {
        _currentLogicalTime=event.timeStamp();
        _pureEvents.remove(event);
        return event.actor();
      }
    }
  }
  for (  Object event : _eventQueue.toArray()) {
    if (_isSafeToProcess((PtidesEvent)event)) {
      Time time=scheduleActor(((PtidesEvent)event).actor());
      Boolean finished=actorFinished(((PtidesEvent)event).actor());
      if (time != null && time.getDoubleValue() > 0.0) {
        fireContainerAt(getEnvironmentTime().add(time));
      }
      if (time == null || finished) {
        _currentLogicalTime=((PtidesEvent)event).timeStamp();
        _removeEventsFromQueue((PtidesEvent)event);
        return ((PtidesEvent)event).actor();
      }
    }
  }
  _currentLogicalTime=null;
  return null;
}"
73147,"/** 
 * Transfer data from an input port of the container to the ports it is connected to on the inside. This method extracts tokens from a record token if the  associated port is a network port. 
 * @exception IllegalActionException Not thrown in this base class.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 */
public boolean transferInputs(IOPort port) throws IllegalActionException {
  boolean result=false;
  for (int channelIndex=0; channelIndex < port.getWidth(); channelIndex++) {
    try {
      if (port.isKnown(channelIndex)) {
        if (port.hasToken(channelIndex)) {
          Token t=port.get(channelIndex);
          if (_debugging) {
            _debug(getName(),""String_Node_Str"" + port.getName());
          }
          PtidesDirector director=(PtidesDirector)_getEmbeddedPtidesDirector();
          Port associatedPort=((MirrorPort)port).getAssociatedPort();
          if (associatedPort instanceof NetworkReceiverPort) {
            NetworkReceiverPort networkReceiverPort=(NetworkReceiverPort)associatedPort;
            if (!(t instanceof RecordToken) || ((RecordToken)t).labelSet().size() != 3) {
              throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
            }
            RecordToken record=(RecordToken)t;
            Time recordTimeStamp=new Time(director,((DoubleToken)(record.get(PtidesNetworkType.timestamp))).doubleValue());
            int recordMicrostep=((IntToken)(record.get(PtidesNetworkType.microstep))).intValue();
            Receiver[][] farReceivers=networkReceiverPort.deepGetReceivers();
            if (farReceivers.length > 0) {
              for (int i=0; i < farReceivers[channelIndex].length; i++) {
                director.addInputEvent(new PtidesEvent(networkReceiverPort,channelIndex,recordTimeStamp,recordMicrostep,-1,(Token)record.get(PtidesNetworkType.payload),farReceivers[channelIndex][i]),PtidesDirector._getDoubleParameterValue(networkReceiverPort,""String_Node_Str""));
              }
            }
          }
 else           if (associatedPort instanceof SensorPort) {
            SensorPort sensorPort=(SensorPort)associatedPort;
            Receiver[][] farReceivers=sensorPort.deepGetReceivers();
            if (farReceivers.length > 0) {
              for (int i=0; i < farReceivers[channelIndex].length; i++) {
                director.addInputEvent(new PtidesEvent(sensorPort,channelIndex,getModelTime(),1,-1,t,farReceivers[channelIndex][i]),PtidesDirector._getDoubleParameterValue(sensorPort,""String_Node_Str""));
              }
            }
          }
 else {
            ((MirrorPort)port).getAssociatedPort().sendInside(channelIndex,t);
          }
          result=true;
        }
      }
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(this,ex,null);
    }
  }
  return result;
}","/** 
 * Transfer data from an input port of the container to the ports it is connected to on the inside. This method extracts tokens from a record token if the  associated port is a network port. 
 * @exception IllegalActionException Not thrown in this base class.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 */
public boolean transferInputs(IOPort port) throws IllegalActionException {
  boolean result=false;
  PtidesDirector director=(PtidesDirector)_getEmbeddedPtidesDirector();
  for (int channelIndex=0; channelIndex < port.getWidth(); channelIndex++) {
    try {
      if (port.isKnown(channelIndex)) {
        if (port.hasToken(channelIndex)) {
          Token t=port.get(channelIndex);
          if (_debugging) {
            _debug(getName(),""String_Node_Str"" + port.getName());
          }
          Port associatedPort=((MirrorPort)port).getAssociatedPort();
          if (associatedPort instanceof NetworkReceiverPort) {
            NetworkReceiverPort networkReceiverPort=(NetworkReceiverPort)associatedPort;
            if (!(t instanceof RecordToken) || ((RecordToken)t).labelSet().size() != 3) {
              throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
            }
            RecordToken record=(RecordToken)t;
            Time recordTimeStamp=new Time(director,((DoubleToken)(record.get(PtidesNetworkType.timestamp))).doubleValue());
            int recordMicrostep=((IntToken)(record.get(PtidesNetworkType.microstep))).intValue();
            Receiver[][] farReceivers=networkReceiverPort.deepGetReceivers();
            if (farReceivers.length > 0) {
              for (int i=0; i < farReceivers[channelIndex].length; i++) {
                director.addInputEvent(new PtidesEvent(networkReceiverPort,channelIndex,recordTimeStamp,recordMicrostep,-1,(Token)record.get(PtidesNetworkType.payload),farReceivers[channelIndex][i]),PtidesDirector._getDoubleParameterValue(networkReceiverPort,""String_Node_Str""));
              }
            }
          }
 else           if (associatedPort instanceof SensorPort) {
            SensorPort sensorPort=(SensorPort)associatedPort;
            Receiver[][] farReceivers=sensorPort.deepGetReceivers();
            if (farReceivers.length > 0) {
              for (int i=0; i < farReceivers[channelIndex].length; i++) {
                director.addInputEvent(new PtidesEvent(sensorPort,channelIndex,director.getModelTime(),1,-1,t,farReceivers[channelIndex][i]),PtidesDirector._getDoubleParameterValue(sensorPort,""String_Node_Str""));
              }
            }
          }
 else {
            ((MirrorPort)port).getAssociatedPort().sendInside(channelIndex,t);
          }
          result=true;
        }
      }
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(this,ex,null);
    }
  }
  return result;
}"
73148,"/** 
 * Offset the locations of top level objects that are created by the change request. If a BasicGraphFrame can be found, then the position of the mouse is used to determine the offsite.  Otherwise, a small offset is  used.
 * @param parser The parser
 */
protected void _postParse(MoMLParser parser){
  double[] minimumLocation=new double[]{Double.MAX_VALUE,Double.MAX_VALUE};
  Iterator topObjects=parser.topObjectsCreated().iterator();
  while (topObjects.hasNext()) {
    NamedObj topObject=(NamedObj)topObjects.next();
    Iterator locations=topObject.attributeList(Locatable.class).iterator();
    while (locations.hasNext()) {
      Locatable location=(Locatable)locations.next();
      double[] locationValue=location.getLocation();
      for (int i=0; i < locationValue.length && i < minimumLocation.length; i++) {
        if (locationValue[i] < minimumLocation[i]) {
          minimumLocation[i]=locationValue[i];
        }
      }
    }
  }
  double xOffset=_PASTE_OFFSET;
  double yOffset=_PASTE_OFFSET;
  double scale=1.0;
  GraphController controller=null;
  SelectionModel selectionModel=null;
  BasicGraphFrame basicGraphFrame=BasicGraphFrame.getBasicGraphFrame(_context);
  if (basicGraphFrame != null) {
    controller=basicGraphFrame.getJGraph().getGraphPane().getGraphController();
    Point componentLocation=basicGraphFrame.getJGraph().getGraphPane().getCanvas().getLocationOnScreen();
    AffineTransform current=basicGraphFrame.getJGraph().getCanvasPane().getTransformContext().getTransform();
    scale=current.getScaleX();
    Rectangle2D visibleCanvas=basicGraphFrame.getVisibleCanvasRectangle();
    Point mouseLocation=MouseInfo.getPointerInfo().getLocation();
    xOffset=mouseLocation.x - componentLocation.x + visibleCanvas.getX() - minimumLocation[0];
    yOffset=mouseLocation.y - componentLocation.y + visibleCanvas.getY() - minimumLocation[1];
  }
  NamedObj container=null;
  final Set _topObjects=new HashSet<NamedObj>();
  topObjects=parser.topObjectsCreated().iterator();
  while (topObjects.hasNext()) {
    NamedObj topObject=(NamedObj)topObjects.next();
    _topObjects.add(topObject);
    if (container == null) {
      container=topObject.getContainer();
    }
    try {
      Iterator locations=topObject.attributeList(Locatable.class).iterator();
      while (locations.hasNext()) {
        Locatable location=(Locatable)locations.next();
        double[] locationValue=location.getLocation();
        for (int i=0; i < locationValue.length; i++) {
          if (i == 0) {
            locationValue[i]+=xOffset;
          }
 else           if (i == 1) {
            locationValue[i]+=yOffset;
          }
 else {
            locationValue[i]+=_PASTE_OFFSET;
          }
          location.setLocation(locationValue);
        }
      }
    }
 catch (    IllegalActionException e) {
      MessageHandler.error(""String_Node_Str"",e);
    }
  }
  if (controller != null) {
    final GraphController controllerFinal=controller;
    final NamedObj containerFinal=container;
    Runnable doHelloWorld=new Runnable(){
      public void run(){
        Interactor interactor=null;
        try {
          interactor=controllerFinal.getEdgeController(new Object()).getEdgeInteractor();
        }
 catch (        Exception ex) {
          interactor=controllerFinal.getNodeController(null).getNodeInteractor();
        }
        SelectionInteractor selectionInteractor=(SelectionInteractor)interactor;
        SelectionRenderer defaultSelectionRenderer=selectionInteractor.getSelectionRenderer();
        SelectionModel selectionModel=controllerFinal.getSelectionModel();
        selectionModel.clearSelection();
        AbstractBasicGraphModel graphModel=(AbstractBasicGraphModel)controllerFinal.getGraphModel();
        Iterator nodes=graphModel.nodes(containerFinal);
        while (nodes.hasNext()) {
          Location node=(Location)nodes.next();
          NamedObj entity=(NamedObj)graphModel.getSemanticObject(node);
          if (_topObjects.contains(entity)) {
            Figure figure=controllerFinal.getFigure(node);
            selectionModel.addSelection(figure);
          }
        }
      }
    }
;
    SwingUtilities.invokeLater(doHelloWorld);
  }
  parser.clearTopObjectsList();
}","/** 
 * Offset the locations of top level objects that are created by the change request. If a BasicGraphFrame can be found, then the position of the mouse is used to determine the offsite.  Otherwise, a small offset is  used.
 * @param parser The parser
 */
protected void _postParse(MoMLParser parser){
  double[] minimumLocation=new double[]{Double.MAX_VALUE,Double.MAX_VALUE};
  Iterator topObjects=parser.topObjectsCreated().iterator();
  while (topObjects.hasNext()) {
    NamedObj topObject=(NamedObj)topObjects.next();
    Iterator locations=topObject.attributeList(Locatable.class).iterator();
    while (locations.hasNext()) {
      Locatable location=(Locatable)locations.next();
      double[] locationValue=location.getLocation();
      for (int i=0; i < locationValue.length && i < minimumLocation.length; i++) {
        if (locationValue[i] < minimumLocation[i]) {
          minimumLocation[i]=locationValue[i];
        }
      }
    }
  }
  double xOffset=_PASTE_OFFSET;
  double yOffset=_PASTE_OFFSET;
  double scale=1.0;
  GraphController controller=null;
  SelectionModel selectionModel=null;
  BasicGraphFrame basicGraphFrame=BasicGraphFrame.getBasicGraphFrame(_context);
  if (basicGraphFrame != null) {
    controller=basicGraphFrame.getJGraph().getGraphPane().getGraphController();
    Point componentLocation=basicGraphFrame.getJGraph().getGraphPane().getCanvas().getLocationOnScreen();
    AffineTransform current=basicGraphFrame.getJGraph().getCanvasPane().getTransformContext().getTransform();
    scale=current.getScaleX();
    Rectangle2D visibleCanvas=basicGraphFrame.getVisibleCanvasRectangle();
    Point mouseLocation=MouseInfo.getPointerInfo().getLocation();
    xOffset=(mouseLocation.x - componentLocation.x) / scale + visibleCanvas.getX() - minimumLocation[0];
    yOffset=(mouseLocation.y - componentLocation.y) / scale + visibleCanvas.getY() - minimumLocation[1];
  }
  NamedObj container=null;
  final Set _topObjects=new HashSet<NamedObj>();
  topObjects=parser.topObjectsCreated().iterator();
  while (topObjects.hasNext()) {
    NamedObj topObject=(NamedObj)topObjects.next();
    _topObjects.add(topObject);
    if (container == null) {
      container=topObject.getContainer();
    }
    try {
      Iterator locations=topObject.attributeList(Locatable.class).iterator();
      while (locations.hasNext()) {
        Locatable location=(Locatable)locations.next();
        double[] locationValue=location.getLocation();
        for (int i=0; i < locationValue.length; i++) {
          if (i == 0) {
            locationValue[i]+=xOffset;
          }
 else           if (i == 1) {
            locationValue[i]+=yOffset;
          }
 else {
            locationValue[i]+=_PASTE_OFFSET;
          }
          location.setLocation(locationValue);
        }
      }
    }
 catch (    IllegalActionException e) {
      MessageHandler.error(""String_Node_Str"",e);
    }
  }
  if (controller != null) {
    final GraphController controllerFinal=controller;
    final NamedObj containerFinal=container;
    Runnable doHelloWorld=new Runnable(){
      public void run(){
        Interactor interactor=null;
        try {
          interactor=controllerFinal.getEdgeController(new Object()).getEdgeInteractor();
        }
 catch (        Exception ex) {
          interactor=controllerFinal.getNodeController(null).getNodeInteractor();
        }
        SelectionInteractor selectionInteractor=(SelectionInteractor)interactor;
        SelectionRenderer defaultSelectionRenderer=selectionInteractor.getSelectionRenderer();
        SelectionModel selectionModel=controllerFinal.getSelectionModel();
        selectionModel.clearSelection();
        AbstractBasicGraphModel graphModel=(AbstractBasicGraphModel)controllerFinal.getGraphModel();
        Iterator nodes=graphModel.nodes(containerFinal);
        while (nodes.hasNext()) {
          Location node=(Location)nodes.next();
          NamedObj entity=(NamedObj)graphModel.getSemanticObject(node);
          if (_topObjects.contains(entity)) {
            Figure figure=controllerFinal.getFigure(node);
            selectionModel.addSelection(figure);
          }
        }
      }
    }
;
    SwingUtilities.invokeLater(doHelloWorld);
  }
  parser.clearTopObjectsList();
}"
73149,"/** 
 * Return the number of iterations. <p>The number of iterations returned depends on the value of the <i>iterations</i> parameter and whether the container of the director is at the top level.  See the   {@link #interations} documentation for details.</p><p>Code that uses SDFDirector should call getIterations() instead of directly referring to the value of the <i>iterations</i> parameter.
 * @return the number of iterations
 * @exception If thrown while getting the value of theiterations parameter.
 */
public int getIterations() throws IllegalActionException {
  int iterationsValue=((IntToken)(iterations.getToken())).intValue();
  if (iterationsValue > 0) {
    return iterationsValue;
  }
  if (!isEmbedded()) {
    if (iterations.equals(_auto)) {
      return 1;
    }
  }
  return 0;
}","/** 
 * Return the number of iterations. <p>The number of iterations returned depends on the value of the <i>iterations</i> parameter and whether the container of the director is at the top level.  See the   {@link #interations} documentation for details.</p><p>Code that uses SDFDirector should call getIterations() instead of directly referring to the value of the <i>iterations</i> parameter.
 * @return the number of iterations
 * @exception If thrown while getting the value of theiterations parameter.
 */
public int getIterations() throws IllegalActionException {
  int iterationsValue=((IntToken)(iterations.getToken())).intValue();
  if (iterationsValue > 0) {
    return iterationsValue;
  }
  if (!isEmbedded()) {
    if (iterations.getToken().equals(_auto)) {
      return 1;
    }
  }
  return 0;
}"
73150,"/** 
 * Find resource scheduler for actor and request scheduling. TODO: This method could be moved to the Director class such that all other MoCs can do resource usage simulation.
 * @param actor The actor to be scheduled.
 * @return Time until next scheduling action or 0.0 if actor can start execution.
 * @throws IllegalActionException
 */
public Time scheduleActor(Actor actor) throws IllegalActionException {
  if (_schedulerForActor == null) {
    _schedulerForActor=new HashMap();
  }
  Object object=_schedulerForActor.get(actor);
  if (!_schedulerForActor.containsKey(actor)) {
    if (object == null) {
      List attributeList=((NamedObj)actor).attributeList();
      if (attributeList.size() > 0) {
        for (int i=0; i < attributeList.size(); i++) {
          Object attr=attributeList.get(i);
          if (attr instanceof Parameter) {
            Token paramToken=((Parameter)attr).getToken();
            if (paramToken instanceof ObjectToken) {
              Object paramObject=((ObjectToken)paramToken).getValue();
              if (paramObject instanceof ResourceScheduler) {
                ResourceScheduler scheduler=(ResourceScheduler)paramObject;
                _schedulerForActor.put(actor,scheduler);
                object=scheduler;
                break;
              }
            }
          }
        }
        if (!_schedulerForActor.containsKey(actor)) {
          _schedulerForActor.put(actor,null);
        }
      }
    }
  }
  if (object != null) {
    return ((ResourceScheduler)object).schedule(actor,getEnvironmentTime());
  }
 else {
    return null;
  }
}","/** 
 * Find resource scheduler for actor and request scheduling. TODO: This method could be moved to the Director class such that all other MoCs can do resource usage simulation.
 * @param actor The actor to be scheduled.
 * @return Time until next scheduling action or 0.0 if actor can start execution.
 * @throws IllegalActionException
 */
public Time scheduleActor(Actor actor) throws IllegalActionException {
  if (_schedulerForActor == null) {
    _schedulerForActor=new HashMap();
  }
  Object object=_schedulerForActor.get(actor);
  if (!_schedulerForActor.containsKey(actor)) {
    if (object == null) {
      List attributeList=((NamedObj)actor).attributeList();
      if (attributeList.size() > 0) {
        for (int i=0; i < attributeList.size(); i++) {
          Object attr=attributeList.get(i);
          if (attr instanceof Parameter) {
            Token paramToken=((Parameter)attr).getToken();
            if (paramToken instanceof ObjectToken) {
              Object paramObject=((ObjectToken)paramToken).getValue();
              if (paramObject instanceof ResourceScheduler) {
                ResourceScheduler scheduler=(ResourceScheduler)paramObject;
                if (_resourceSchedulers.contains(scheduler)) {
                  _schedulerForActor.put(actor,scheduler);
                  object=scheduler;
                  break;
                }
              }
            }
          }
        }
        if (!_schedulerForActor.containsKey(actor)) {
          _schedulerForActor.put(actor,null);
        }
      }
    }
  }
  if (object != null) {
    return ((ResourceScheduler)object).schedule(actor,getEnvironmentTime());
  }
 else {
    return null;
  }
}"
73151,"/** 
 * Initialize all the actors and variables. Perform static analysis on  superdense dependencies between input ports in the topology.
 * @exception IllegalActionException If any of the methods containedin initialize() throw it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _calculateSuperdenseDependenices();
  _calculateDelayOffsets();
  for (  Object entity : ((CompositeActor)getContainer()).entityList()) {
    if (entity instanceof ResourceScheduler) {
      if (_resourceSchedulers == null) {
        _resourceSchedulers=new ArrayList();
      }
      _resourceSchedulers.add((ResourceScheduler)entity);
    }
  }
}","/** 
 * Initialize all the actors and variables. Perform static analysis on  superdense dependencies between input ports in the topology.
 * @exception IllegalActionException If any of the methods containedin initialize() throw it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _calculateSuperdenseDependenices();
  _calculateDelayOffsets();
  _resourceSchedulers=new ArrayList();
  _schedulerForActor=null;
  for (  Object entity : ((CompositeActor)getContainer()).entityList()) {
    if (entity instanceof ResourceScheduler) {
      _resourceSchedulers.add((ResourceScheduler)entity);
    }
  }
}"
73152,"/** 
 * Construct a JSONToToken actor with the given container and name.
 * @param container
 * @param name
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JSONToToken(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  input.setTypeEquals(BaseType.STRING);
}","/** 
 * Construct a JSONToToken actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JSONToToken(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  input.setTypeEquals(BaseType.STRING);
}"
73153,"/** 
 * Construct a TokenToJSON actor with the given container and name.
 * @param container
 * @param name
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public TokenToJSON(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output.setTypeEquals(BaseType.STRING);
}","/** 
 * Construct a TokenToJSON actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public TokenToJSON(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output.setTypeEquals(BaseType.STRING);
}"
73154,"/** 
 * If this port has parameters whose values are tokens that contain an object implementing   {@link QuantityManager}, then wrap the receiver specified in the argument using those quantity managers. If there are no such parameters, then simply return the specified receiver. If there is one such parameter, then use the quantity manager to wrap the specified receiver in a new receiver, and return that receiver. If there are two such parameters, then use the second quantity manager to create a receiver that wraps that created by the first quantity manager. Etc.
 * @see QuantityManager
 * @param receiver The receiver to wrap.
 * @param channel Channel id used to determine the source port.
 * @return Either a new receiver wrapping the specified receiver,or the specified receiver.
 * @exception IllegalActionException If any parameter of the portcannot be evaluated.
 */
protected Receiver _wrapReceiver(Receiver receiver,int channel) throws IllegalActionException {
  Receiver result=receiver;
  List qmList=getQuantityManagers();
  if (isInput()) {
    for (int i=qmList.size() - 1; i >= 0; i--) {
      Object object=qmList.get(i);
      if (object instanceof QuantityManager) {
        result=((QuantityManager)object).getReceiver(result);
      }
 else       if (object instanceof IOPort) {
        result=((QuantityManager)((IOPort)object).getContainer()).getReceiver(result,((IOPort)object));
      }
    }
    if (result instanceof IntermediateReceiver) {
      IntermediateReceiver intermediateReceiver=(IntermediateReceiver)result;
      intermediateReceiver.source=(Actor)((IOPort)this.sourcePortList().get(channel)).getContainer();
    }
  }
 else {
    for (int i=0; i < qmList.size(); i++) {
      Object object=qmList.get(i);
      if (object instanceof QuantityManager) {
        result=((QuantityManager)object).getReceiver(result);
      }
 else       if (object instanceof IOPort) {
        IntermediateReceiver ir=(IntermediateReceiver)((QuantityManager)((IOPort)object).getContainer()).getReceiver(result,((IOPort)object));
        _farReceiver=ir;
      }
    }
  }
  return result;
}","/** 
 * If this port has parameters whose values are tokens that contain an object implementing   {@link QuantityManager}, then wrap the receiver specified in the argument using those quantity managers. If there are no such parameters, then simply return the specified receiver. If there is one such parameter, then use the quantity manager to wrap the specified receiver in a new receiver, and return that receiver. If there are two such parameters, then use the second quantity manager to create a receiver that wraps that created by the first quantity manager. Etc.
 * @see QuantityManager
 * @param receiver The receiver to wrap.
 * @param channel Channel id used to determine the source port.
 * @return Either a new receiver wrapping the specified receiver,or the specified receiver.
 * @exception IllegalActionException If any parameter of the portcannot be evaluated.
 */
protected Receiver _wrapReceiver(Receiver receiver,int channel) throws IllegalActionException {
  Receiver result=receiver;
  List qmList=getQuantityManagers();
  if (isInput()) {
    for (int i=qmList.size() - 1; i >= 0; i--) {
      Object object=qmList.get(i);
      if (object instanceof QuantityManager) {
        result=((QuantityManager)object).getReceiver(result);
      }
 else       if (object instanceof IOPort) {
        result=((QuantityManager)((IOPort)object).getContainer()).getReceiver(result,((IOPort)object));
      }
    }
    if (result instanceof IntermediateReceiver) {
      IntermediateReceiver intermediateReceiver=(IntermediateReceiver)result;
      intermediateReceiver.source=(Actor)((IOPort)this.sourcePortList().get(channel)).getContainer();
    }
  }
 else {
    for (int i=0; i < qmList.size(); i++) {
      Object object=qmList.get(i);
      if (object instanceof QuantityManager) {
        result=((QuantityManager)object).getReceiver(result);
      }
 else       if (object instanceof IOPort) {
        IntermediateReceiver ir=(IntermediateReceiver)((QuantityManager)((IOPort)object).getContainer()).getReceiver(result,((IOPort)object));
        _intermediateFarReceiver=ir;
      }
    }
  }
  return result;
}"
73155,"/** 
 * Return the scheduling sequence. If the schedule exist in the cache (schedules are identified by the rate signatures of ports), then return the corresponding schedule in the cache. Otherwise, compute the schedule and return it.
 * @return A schedule of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If the super class throws it.
 * @exception IllegalActionException If the super class throws it.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  Schedule schedule;
  if ((_inputPortList == null) || (_workspaceVersion != workspace().getVersion())) {
    _inputPortList=_getInputPortList();
  }
  if ((_outputPortList == null) || (_workspaceVersion != workspace().getVersion())) {
    _outputPortList=_getOutputPortList();
  }
  _workspaceVersion=workspace().getVersion();
  StringBuffer rates=new StringBuffer();
  Iterator inputPorts=_inputPortList.iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    int rate=DFUtilities.getTokenConsumptionRate(inputPort);
    rates.append(rate);
  }
  Iterator outputPorts=_outputPortList.iterator();
  while (outputPorts.hasNext()) {
    IOPort outputPort=(IOPort)outputPorts.next();
    int rate=DFUtilities.getTokenProductionRate(outputPort);
    rates.append(rate);
    DFUtilities.getTokenInitProduction(outputPort);
    rates.append(rate);
  }
  String rateKey=rates.toString();
  if (_scheduleCache.containsKey(rateKey)) {
    schedule=(Schedule)_scheduleCache.get(rateKey);
    if (!rateKey.equals(_mostRecentRates)) {
      _mostRecentRates=rateKey;
      if (_cacheSize > 0) {
        _scheduleKeyList.remove(rateKey);
        _scheduleKeyList.add(0,rateKey);
      }
      Map externalRates=(Map)_externalRatesCache.get(rateKey);
      _saveContainerRates(externalRates);
    }
  }
 else {
    _mostRecentRates=rateKey;
    if (_cacheSize > 0) {
      while (_scheduleKeyList.size() >= _cacheSize) {
        Object key=_scheduleKeyList.get(_cacheSize - 1);
        _scheduleKeyList.remove(_cacheSize - 1);
        _scheduleCache.remove(key);
        _externalRatesCache.remove(key);
      }
      _scheduleKeyList.add(0,rateKey);
    }
    schedule=super._getSchedule();
    _scheduleCache.put(rateKey,schedule);
    Map externalRates=getExternalRates();
    _externalRatesCache.put(rateKey,externalRates);
  }
  setValid(true);
  return schedule;
}","/** 
 * Return the scheduling sequence. If the schedule exist in the cache (schedules are identified by the rate signatures of ports), then return the corresponding schedule in the cache. Otherwise, compute the schedule and return it.
 * @return A schedule of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If the super class throws it.
 * @exception IllegalActionException If the super class throws it.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  Schedule schedule;
  if ((_inputPortList == null) || (_workspaceVersion != workspace().getVersion())) {
    _inputPortList=_getInputPortList();
  }
  if ((_outputPortList == null) || (_workspaceVersion != workspace().getVersion())) {
    _outputPortList=_getOutputPortList();
  }
  _workspaceVersion=workspace().getVersion();
  StringBuffer rates=new StringBuffer();
  Iterator inputPorts=_inputPortList.iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    int rate=DFUtilities.getTokenConsumptionRate(inputPort);
    rates.append(rate);
  }
  Iterator outputPorts=_outputPortList.iterator();
  while (outputPorts.hasNext()) {
    IOPort outputPort=(IOPort)outputPorts.next();
    int rate=DFUtilities.getTokenProductionRate(outputPort);
    rates.append(rate);
    int initRate=DFUtilities.getTokenInitProduction(outputPort);
    rates.append(""String_Node_Str"");
    rates.append(initRate);
  }
  String rateKey=rates.toString();
  if (_scheduleCache.containsKey(rateKey)) {
    schedule=(Schedule)_scheduleCache.get(rateKey);
    if (!rateKey.equals(_mostRecentRates)) {
      _mostRecentRates=rateKey;
      if (_cacheSize > 0) {
        _scheduleKeyList.remove(rateKey);
        _scheduleKeyList.add(0,rateKey);
      }
      Map externalRates=(Map)_externalRatesCache.get(rateKey);
      _saveContainerRates(externalRates);
    }
  }
 else {
    _mostRecentRates=rateKey;
    if (_cacheSize > 0) {
      while (_scheduleKeyList.size() >= _cacheSize) {
        Object key=_scheduleKeyList.get(_cacheSize - 1);
        _scheduleKeyList.remove(_cacheSize - 1);
        _scheduleCache.remove(key);
        _externalRatesCache.remove(key);
      }
      _scheduleKeyList.add(0,rateKey);
    }
    schedule=super._getSchedule();
    _scheduleCache.put(rateKey,schedule);
    Map externalRates=getExternalRates();
    _externalRatesCache.put(rateKey,externalRates);
  }
  setValid(true);
  return schedule;
}"
73156,"/** 
 * Override the base class to wait until the inside thread terminates and then call super.wrapup().
 * @exception IllegalActionException If the wrapup() method ofone of the associated actors throws it.
 */
public void wrapup() throws IllegalActionException {
  Time environmentTime=ThreadedComposite.this.getExecutiveDirector().getModelTime();
  if (ThreadedComposite.this._debugging) {
    ThreadedComposite.this._debug(""String_Node_Str"",""String_Node_Str"" + environmentTime);
  }
synchronized (this) {
    _inputFrames.add(new TokenFrame(environmentTime,null,TokenFrame.STOP));
    notifyAll();
  }
  if (_exception != null) {
    throw new IllegalActionException(ThreadedComposite.this,_exception,""String_Node_Str"");
  }
  if (_thread != null && _thread.isAlive()) {
    try {
      if (ThreadedComposite.this._debugging) {
        ThreadedComposite.this._debug(""String_Node_Str"");
      }
      _thread.join();
      if (ThreadedComposite.this._debugging) {
        ThreadedComposite.this._debug(""String_Node_Str"");
      }
    }
 catch (    InterruptedException e) {
    }
  }
  super.wrapup();
}","/** 
 * Override the base class to wait until the inside thread terminates and then call super.wrapup().
 * @exception IllegalActionException If the wrapup() method ofone of the associated actors throws it.
 */
public void wrapup() throws IllegalActionException {
  Time environmentTime=ThreadedComposite.this.getExecutiveDirector().getModelTime();
  if (ThreadedComposite.this._debugging) {
    ThreadedComposite.this._debug(""String_Node_Str"",""String_Node_Str"" + environmentTime);
  }
synchronized (this) {
    _inputFrames.add(new TokenFrame(environmentTime,null,TokenFrame.STOP));
    notifyAll();
  }
  if (_exception != null) {
    throw new IllegalActionException(ThreadedComposite.this,_exception,""String_Node_Str"");
  }
  if (_thread != null && _thread.isAlive()) {
    try {
      if (ThreadedComposite.this._debugging) {
        ThreadedComposite.this._debug(""String_Node_Str"");
      }
      _thread.join();
      if (ThreadedComposite.this._debugging) {
        ThreadedComposite.this._debug(""String_Node_Str"");
      }
      if (_exception != null) {
        throw new IllegalActionException(ThreadedComposite.this,_exception,""String_Node_Str"");
      }
    }
 catch (    InterruptedException e) {
    }
  }
  super.wrapup();
}"
73157,"private Object _leastElementShared(Set<Object> subset){
  if (subset.size() == 1) {
    Object obj=subset.iterator().next();
    if (containsNodeWeight(obj)) {
      return obj;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else   if (subset.size() == 2) {
    Iterator<Object> itr=subset.iterator();
    Object o1=itr.next();
    Object o2=itr.next();
    int i1=nodeLabel(o1);
    int i2=nodeLabel(o1);
    int result=_compareNodeId(i1,i2);
    if ((result == LOWER) || (result == SAME)) {
      return o1;
    }
 else     if (result == HIGHER) {
      return o2;
    }
 else {
      return null;
    }
  }
 else {
    int[] ids=new int[subset.size()];
    int i=0;
    for (    Object obj : subset) {
      ids[i]=nodeLabel(obj);
      i++;
    }
    return _leastElementNodeId(ids);
  }
}","private Object _leastElementShared(Set<Object> subset){
  if (subset.size() == 1) {
    Object obj=subset.iterator().next();
    if (containsNodeWeight(obj)) {
      return obj;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else   if (subset.size() == 2) {
    Iterator<Object> itr=subset.iterator();
    Object o1=itr.next();
    Object o2=itr.next();
    int i1=nodeLabel(o1);
    int i2=nodeLabel(o2);
    int result=_compareNodeId(i1,i2);
    if ((result == LOWER) || (result == SAME)) {
      return o1;
    }
 else     if (result == HIGHER) {
      return o2;
    }
 else {
      return null;
    }
  }
 else {
    int[] ids=new int[subset.size()];
    int i=0;
    for (    Object obj : subset) {
      ids[i]=nodeLabel(obj);
      i++;
    }
    return _leastElementNodeId(ids);
  }
}"
73158,"/** 
 * Override the base class to wait until the inside thread terminates and then call super.wrapup().
 * @exception IllegalActionException If the wrapup() method ofone of the associated actors throws it.
 */
public void wrapup() throws IllegalActionException {
  Time environmentTime=ThreadedComposite.this.getExecutiveDirector().getModelTime();
  if (ThreadedComposite.this._debugging) {
    ThreadedComposite.this._debug(""String_Node_Str"",""String_Node_Str"" + environmentTime);
  }
  _inputFrames.add(new TokenFrame(environmentTime,null,TokenFrame.STOP));
  if (_exception != null) {
    throw new IllegalActionException(ThreadedComposite.this,_exception,""String_Node_Str"");
  }
  if (_thread != null && _thread.isAlive()) {
    try {
      if (ThreadedComposite.this._debugging) {
        ThreadedComposite.this._debug(""String_Node_Str"");
      }
      _thread.join();
      if (ThreadedComposite.this._debugging) {
        ThreadedComposite.this._debug(""String_Node_Str"");
      }
      if (_exception != null) {
        throw new IllegalActionException(ThreadedComposite.this,_exception,""String_Node_Str"");
      }
    }
 catch (    InterruptedException e) {
    }
  }
  super.wrapup();
}","/** 
 * Override the base class to wait until the inside thread terminates and then call super.wrapup().
 * @exception IllegalActionException If the wrapup() method ofone of the associated actors throws it.
 */
public void wrapup() throws IllegalActionException {
  Time environmentTime=ThreadedComposite.this.getExecutiveDirector().getModelTime();
  if (ThreadedComposite.this._debugging) {
    ThreadedComposite.this._debug(""String_Node_Str"",""String_Node_Str"" + environmentTime);
  }
synchronized (this) {
    _inputFrames.add(new TokenFrame(environmentTime,null,TokenFrame.STOP));
    notifyAll();
  }
  if (_exception != null) {
    throw new IllegalActionException(ThreadedComposite.this,_exception,""String_Node_Str"");
  }
  if (_thread != null && _thread.isAlive()) {
    try {
      if (ThreadedComposite.this._debugging) {
        ThreadedComposite.this._debug(""String_Node_Str"");
      }
      _thread.join();
      if (ThreadedComposite.this._debugging) {
        ThreadedComposite.this._debug(""String_Node_Str"");
      }
      if (_exception != null) {
        throw new IllegalActionException(ThreadedComposite.this,_exception,""String_Node_Str"");
      }
    }
 catch (    InterruptedException e) {
    }
  }
  super.wrapup();
}"
73159,"public void run(){
  while (!_stopRequested) {
    try {
      if (ThreadedComposite.this._debugging) {
        ThreadedComposite.this._debug(""String_Node_Str"");
      }
      TokenFrame frame=_inputFrames.take();
      if (frame.type == TokenFrame.STOP) {
        if (ThreadedComposite.this._debugging) {
          ThreadedComposite.this._debug(""String_Node_Str"");
        }
        break;
      }
      if (ThreadedComposite.this._debugging) {
        ThreadedComposite.this._debug(""String_Node_Str"" + frame.time + ""String_Node_Str""+ frame.tokens);
      }
      setModelTime(frame.time);
      if (_synchronizeToRealTime) {
        long currentRealTime=System.currentTimeMillis();
        if (_realStartTime < 0L) {
          _realStartTime=currentRealTime;
        }
        long realTimeMillis=currentRealTime - _realStartTime;
        long modelTimeMillis=Math.round(getModelTime().getDoubleValue() * 1000.0);
        if (realTimeMillis < modelTimeMillis) {
          try {
            Thread.sleep(modelTimeMillis - realTimeMillis);
          }
 catch (          InterruptedException e) {
          }
        }
      }
      for (      QueuedToken token : frame.tokens) {
        if (token.channel < token.port.getWidthInside()) {
          token.port.sendInside(token.channel,token.token);
        }
      }
      if (!iterateContainedActors()) {
        break;
      }
      List<QueuedToken> outputTokens=new LinkedList<QueuedToken>();
      Iterator ports=outputPortList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        for (int i=0; i < port.getWidth(); i++) {
          if (port.isKnownInside(i) && port.hasTokenInside(i)) {
            Token token=port.getInside(i);
            QueuedToken tokenBundle=new QueuedToken(port,i,token);
            outputTokens.add(tokenBundle);
            if (ThreadedComposite.this._debugging) {
              ThreadedComposite.this._debug(""String_Node_Str"" + token + ""String_Node_Str""+ port.getName());
            }
          }
        }
      }
      Time responseTime=getModelTime().add(_delayValue);
synchronized (ThreadedDirector.this) {
        if (_delayValue < 0.0) {
          if (_synchronizeToRealTime) {
            long realTimeMillis=System.currentTimeMillis() - _realStartTime;
            Time realTime=new Time(ThreadedDirector.this,realTimeMillis * 0.001);
            responseTime=ThreadedDirector.this.fireAt(ThreadedComposite.this,realTime);
          }
 else {
            responseTime=ThreadedDirector.this.fireAt(ThreadedComposite.this,getModelTime());
          }
          _outputTimes.add(responseTime);
        }
        TokenFrame outputFrame=new TokenFrame(responseTime,outputTokens,TokenFrame.EVENT);
        _outputFrames.add(outputFrame);
        if (ThreadedComposite.this._debugging) {
          ThreadedComposite.this._debug(""String_Node_Str"");
        }
        ThreadedDirector.this.notifyAll();
        Thread.yield();
      }
    }
 catch (    InterruptedException e) {
      TokenFrame stopFrame=new TokenFrame(getModelTime(),null,TokenFrame.STOP);
synchronized (ThreadedDirector.this) {
        _outputFrames.add(stopFrame);
        ThreadedDirector.this.notifyAll();
      }
      break;
    }
catch (    IllegalActionException ex) {
synchronized (ThreadedDirector.this) {
        _exception=ex;
        TokenFrame stopFrame=new TokenFrame(getModelTime(),null,TokenFrame.STOP);
        _outputFrames.add(stopFrame);
        ThreadedDirector.this.notifyAll();
      }
      break;
    }
  }
}","public void run(){
  while (!_stopRequested) {
    try {
      if (ThreadedComposite.this._debugging) {
        ThreadedComposite.this._debug(""String_Node_Str"");
      }
      TokenFrame frame=null;
synchronized (ThreadedDirector.this) {
        while (_inputFrames.isEmpty() && !_stopRequested) {
          ThreadedDirector.this.wait(1000L);
        }
        if (_stopRequested) {
          break;
        }
        frame=_inputFrames.poll();
      }
      if (frame.type == TokenFrame.STOP) {
        if (ThreadedComposite.this._debugging) {
          ThreadedComposite.this._debug(""String_Node_Str"");
        }
        break;
      }
      if (ThreadedComposite.this._debugging) {
        ThreadedComposite.this._debug(""String_Node_Str"" + frame.time + ""String_Node_Str""+ frame.tokens);
      }
      setModelTime(frame.time);
      if (_synchronizeToRealTime) {
        long currentRealTime=System.currentTimeMillis();
        if (_realStartTime < 0L) {
          _realStartTime=currentRealTime;
        }
        long realTimeMillis=currentRealTime - _realStartTime;
        long modelTimeMillis=Math.round(getModelTime().getDoubleValue() * 1000.0);
        if (realTimeMillis < modelTimeMillis) {
          try {
            Thread.sleep(modelTimeMillis - realTimeMillis);
          }
 catch (          InterruptedException e) {
          }
        }
      }
      for (      QueuedToken token : frame.tokens) {
        if (token.channel < token.port.getWidthInside()) {
          token.port.sendInside(token.channel,token.token);
        }
      }
      if (!iterateContainedActors()) {
        break;
      }
      List<QueuedToken> outputTokens=new LinkedList<QueuedToken>();
      Iterator ports=outputPortList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        for (int i=0; i < port.getWidth(); i++) {
          if (port.isKnownInside(i) && port.hasTokenInside(i)) {
            Token token=port.getInside(i);
            QueuedToken tokenBundle=new QueuedToken(port,i,token);
            outputTokens.add(tokenBundle);
            if (ThreadedComposite.this._debugging) {
              ThreadedComposite.this._debug(""String_Node_Str"" + token + ""String_Node_Str""+ port.getName());
            }
          }
        }
      }
      Time responseTime=getModelTime().add(_delayValue);
synchronized (ThreadedDirector.this) {
        if (_delayValue < 0.0) {
          if (_synchronizeToRealTime) {
            long realTimeMillis=System.currentTimeMillis() - _realStartTime;
            Time realTime=new Time(ThreadedDirector.this,realTimeMillis * 0.001);
            responseTime=ThreadedDirector.this.fireAt(ThreadedComposite.this,realTime);
          }
 else {
            responseTime=ThreadedDirector.this.fireAt(ThreadedComposite.this,getModelTime());
          }
          _outputTimes.add(responseTime);
        }
        TokenFrame outputFrame=new TokenFrame(responseTime,outputTokens,TokenFrame.EVENT);
        _outputFrames.add(outputFrame);
        if (ThreadedComposite.this._debugging) {
          ThreadedComposite.this._debug(""String_Node_Str"");
        }
        ThreadedDirector.this.notifyAll();
        Thread.yield();
      }
    }
 catch (    InterruptedException e) {
      TokenFrame stopFrame=new TokenFrame(getModelTime(),null,TokenFrame.STOP);
synchronized (ThreadedDirector.this) {
        _outputFrames.add(stopFrame);
        ThreadedDirector.this.notifyAll();
      }
      break;
    }
catch (    IllegalActionException ex) {
synchronized (ThreadedDirector.this) {
        _exception=ex;
        TokenFrame stopFrame=new TokenFrame(getModelTime(),null,TokenFrame.STOP);
        _outputFrames.add(stopFrame);
        ThreadedDirector.this.notifyAll();
      }
      break;
    }
  }
}"
73160,"/** 
 * Consume inputs (if any) and post a frame on the queue for the inside thread to consume. A frame will be posted even if there are no inputs if a refiring request has been made for the current time.
 * @return True if the inside thread is still alive.
 */
public boolean postfire() throws IllegalActionException {
  Time environmentTime=ThreadedComposite.this.getExecutiveDirector().getModelTime();
  if (ThreadedComposite.this._debugging) {
    ThreadedComposite.this._debug(""String_Node_Str"" + environmentTime);
  }
  boolean refireRequested=_fireAtTimes.remove(environmentTime);
  if (refireRequested || !_inputTokens.isEmpty()) {
    if (ThreadedComposite.this._debugging) {
      ThreadedComposite.this._debug(""String_Node_Str"" + _inputTokens.toString() + ""String_Node_Str""+ environmentTime);
    }
    _inputFrames.add(new TokenFrame(environmentTime,_inputTokens,TokenFrame.EVENT));
    if (_delayValue >= 0.0) {
      Time responseTime=environmentTime.add(_delayValue);
      Time response=ThreadedComposite.this.getExecutiveDirector().fireAt(ThreadedComposite.this,responseTime);
      if (!response.equals(responseTime)) {
        throw new IllegalActionException(this,""String_Node_Str"" + responseTime + ""String_Node_Str""+ response);
      }
synchronized (this) {
        _outputTimes.add(responseTime);
      }
    }
    Thread.yield();
  }
  return _thread.isAlive();
}","/** 
 * Consume inputs (if any) and post a frame on the queue for the inside thread to consume. A frame will be posted even if there are no inputs if a refiring request has been made for the current time.
 * @return True if the inside thread is still alive.
 */
public boolean postfire() throws IllegalActionException {
  Time environmentTime=ThreadedComposite.this.getExecutiveDirector().getModelTime();
  if (ThreadedComposite.this._debugging) {
    ThreadedComposite.this._debug(""String_Node_Str"" + environmentTime);
  }
  boolean refireRequested=_fireAtTimes.remove(environmentTime);
  if (refireRequested || !_inputTokens.isEmpty()) {
    if (ThreadedComposite.this._debugging) {
      ThreadedComposite.this._debug(""String_Node_Str"" + _inputTokens.toString() + ""String_Node_Str""+ environmentTime);
    }
synchronized (this) {
      _inputFrames.add(new TokenFrame(environmentTime,_inputTokens,TokenFrame.EVENT));
      notifyAll();
      if (_delayValue >= 0.0) {
        Time responseTime=environmentTime.add(_delayValue);
        Time response=ThreadedComposite.this.getExecutiveDirector().fireAt(ThreadedComposite.this,responseTime);
        if (!response.equals(responseTime)) {
          throw new IllegalActionException(this,""String_Node_Str"" + responseTime + ""String_Node_Str""+ response);
        }
        _outputTimes.add(responseTime);
      }
    }
    Thread.yield();
  }
  return _thread.isAlive();
}"
73161,"/** 
 * Override the base class to post a ""stop frame"" on the queue for the inside thread to stop.
 */
public void stop(){
  super.stop();
  Time environmentTime=ThreadedComposite.this.getExecutiveDirector().getModelTime();
  if (ThreadedComposite.this._debugging) {
    ThreadedComposite.this._debug(""String_Node_Str"" + environmentTime);
  }
  _inputFrames.add(new TokenFrame(environmentTime,null,TokenFrame.STOP));
synchronized (this) {
    notifyAll();
  }
}","/** 
 * Override the base class to post a ""stop frame"" on the queue for the inside thread to stop.
 */
public void stop(){
  super.stop();
  Time environmentTime=ThreadedComposite.this.getExecutiveDirector().getModelTime();
  if (ThreadedComposite.this._debugging) {
    ThreadedComposite.this._debug(""String_Node_Str"" + environmentTime);
  }
synchronized (this) {
    _inputFrames.add(new TokenFrame(environmentTime,null,TokenFrame.STOP));
    notifyAll();
  }
}"
73162,"/** 
 * Clone the director into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new director.
 * @exception CloneNotSupportedException If a derived class hashas an attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ThreadedDirector newObject=(ThreadedDirector)super.clone(workspace);
  newObject._exception=null;
  newObject._inputTokens=null;
  newObject._thread=null;
  newObject._outputTimes=new LinkedList<Time>();
  newObject._fireAtTimes=Collections.synchronizedSet(new HashSet<Time>());
  newObject._inputFrames=new LinkedBlockingQueue<TokenFrame>();
  newObject._outputFrames=new LinkedList<TokenFrame>();
  return newObject;
}","/** 
 * Clone the director into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new director.
 * @exception CloneNotSupportedException If a derived class hashas an attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ThreadedDirector newObject=(ThreadedDirector)super.clone(workspace);
  newObject._exception=null;
  newObject._inputTokens=null;
  newObject._thread=null;
  newObject._outputTimes=new LinkedList<Time>();
  newObject._fireAtTimes=Collections.synchronizedSet(new HashSet<Time>());
  newObject._inputFrames=new LinkedList<TokenFrame>();
  newObject._outputFrames=new LinkedList<TokenFrame>();
  return newObject;
}"
73163,"/** 
 * Start the inside thread.
 * @exception IllegalActionException If the initialize() method ofone of the inside actors throws it.
 */
public void initialize() throws IllegalActionException {
  _fireAtTimes.clear();
  _outputFrames.clear();
  _outputTimes.clear();
  _inputFrames.clear();
  _exception=null;
  super.initialize();
  _realStartTime=-1L;
  _inputFrames.clear();
  _outputFrames.clear();
  _synchronizeToRealTime=((BooleanToken)synchronizeToRealTime.getToken()).booleanValue();
  _thread=new CompositeThread();
  _thread.setPriority(Thread.MAX_PRIORITY);
  _thread.start();
}","/** 
 * Start the inside thread.
 * @exception IllegalActionException If the initialize() method ofone of the inside actors throws it.
 */
public synchronized void initialize() throws IllegalActionException {
  _fireAtTimes.clear();
  _outputFrames.clear();
  _outputTimes.clear();
  _inputFrames.clear();
  _exception=null;
  super.initialize();
  _realStartTime=-1L;
  _inputFrames.clear();
  _outputFrames.clear();
  _synchronizeToRealTime=((BooleanToken)synchronizeToRealTime.getToken()).booleanValue();
  _thread=new CompositeThread();
  _thread.setPriority(Thread.MAX_PRIORITY);
  _thread.start();
}"
73164,"/** 
 * Create an instance of the actor.
 * @param container The container
 * @param name The name.
 * @throws IllegalActionException If the superclass throws it.
 * @throws NameDuplicationException If the super
 */
public HttpActor(CompositeActor container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  path=new StringParameter(this,""String_Node_Str"");
  path.setExpression(""String_Node_Str"");
  response=new TypedIOPort(this,""String_Node_Str"",true,false);
  response.setTypeEquals(BaseType.STRING);
  response.setMultiport(true);
  cookies=new TypedIOPort(this,""String_Node_Str"",false,true);
  new Parameter(cookies,""String_Node_Str"").setExpression(""String_Node_Str"");
  getRequestURI=new TypedIOPort(this,""String_Node_Str"",false,true);
  getRequestURI.setTypeEquals(BaseType.STRING);
  new Parameter(getRequestURI,""String_Node_Str"").setExpression(""String_Node_Str"");
  getParameters=new TypedIOPort(this,""String_Node_Str"",false,true);
  new Parameter(getParameters,""String_Node_Str"").setExpression(""String_Node_Str"");
  postRequestURI=new TypedIOPort(this,""String_Node_Str"",false,true);
  postRequestURI.setTypeEquals(BaseType.STRING);
  new Parameter(postRequestURI,""String_Node_Str"").setExpression(""String_Node_Str"");
  postParameters=new TypedIOPort(this,""String_Node_Str"",false,true);
  new Parameter(postParameters,""String_Node_Str"").setExpression(""String_Node_Str"");
  setCookies=new TypedIOPort(this,""String_Node_Str"",true,false);
  new Parameter(setCookies,""String_Node_Str"").setExpression(""String_Node_Str"");
  timeout=new Parameter(this,""String_Node_Str"");
  timeout.setExpression(""String_Node_Str"");
  timeout.setTypeEquals(BaseType.LONG);
  cookiesCollection=new Parameter(this,""String_Node_Str"");
  pathCookies=new Parameter(this,""String_Node_Str"");
  pathCookies.setExpression(""String_Node_Str"");
  _cookiesCollectionList=new LinkedList<RecordToken>();
}","/** 
 * Create an instance of the actor.
 * @param container The container
 * @param name The name.
 * @throws IllegalActionException If the superclass throws it.
 * @throws NameDuplicationException If the super
 */
public HttpActor(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  path=new StringParameter(this,""String_Node_Str"");
  path.setExpression(""String_Node_Str"");
  response=new TypedIOPort(this,""String_Node_Str"",true,false);
  response.setTypeEquals(BaseType.STRING);
  response.setMultiport(true);
  cookies=new TypedIOPort(this,""String_Node_Str"",false,true);
  new Parameter(cookies,""String_Node_Str"").setExpression(""String_Node_Str"");
  getRequestURI=new TypedIOPort(this,""String_Node_Str"",false,true);
  getRequestURI.setTypeEquals(BaseType.STRING);
  new Parameter(getRequestURI,""String_Node_Str"").setExpression(""String_Node_Str"");
  getParameters=new TypedIOPort(this,""String_Node_Str"",false,true);
  new Parameter(getParameters,""String_Node_Str"").setExpression(""String_Node_Str"");
  postRequestURI=new TypedIOPort(this,""String_Node_Str"",false,true);
  postRequestURI.setTypeEquals(BaseType.STRING);
  new Parameter(postRequestURI,""String_Node_Str"").setExpression(""String_Node_Str"");
  postParameters=new TypedIOPort(this,""String_Node_Str"",false,true);
  new Parameter(postParameters,""String_Node_Str"").setExpression(""String_Node_Str"");
  setCookies=new TypedIOPort(this,""String_Node_Str"",true,false);
  new Parameter(setCookies,""String_Node_Str"").setExpression(""String_Node_Str"");
  timeout=new Parameter(this,""String_Node_Str"");
  timeout.setExpression(""String_Node_Str"");
  timeout.setTypeEquals(BaseType.LONG);
  cookiesCollection=new Parameter(this,""String_Node_Str"");
  pathCookies=new Parameter(this,""String_Node_Str"");
  pathCookies.setExpression(""String_Node_Str"");
  _cookiesCollectionList=new LinkedList<RecordToken>();
}"
73165,"/** 
 * Construct an instance of the attribute.
 * @param container The container.
 * @param name The name.
 * @throws IllegalActionException If the superclass throws it.
 * @throws NameDuplicationException If the superclass throws it.
 */
public WebServer(CompositeActor container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  port=new Parameter(this,""String_Node_Str"");
  port.setTypeEquals(BaseType.INT);
  port.setExpression(""String_Node_Str"");
  applicationPath=new StringParameter(this,""String_Node_Str"");
  applicationPath.setExpression(""String_Node_Str"");
  resourcePath=new StringParameter(this,""String_Node_Str"");
  resourcePath.setExpression(""String_Node_Str"");
  resourceLocation=new FileParameter(this,""String_Node_Str"");
  URI modelURI=URIAttribute.getModelURI(this);
  String path=modelURI.getPath().toString();
  int slash=path.lastIndexOf(""String_Node_Str"");
  if (slash != -1) {
    path=path.substring(0,slash);
  }
  resourceLocation.setExpression(path);
  temporaryFileLocation=new FileParameter(this,""String_Node_Str"");
  temporaryFileLocation.setExpression(""String_Node_Str"");
}","/** 
 * Construct an instance of the attribute.
 * @param container The container.
 * @param name The name.
 * @throws IllegalActionException If the superclass throws it.
 * @throws NameDuplicationException If the superclass throws it.
 */
public WebServer(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  port=new Parameter(this,""String_Node_Str"");
  port.setTypeEquals(BaseType.INT);
  port.setExpression(""String_Node_Str"");
  applicationPath=new StringParameter(this,""String_Node_Str"");
  applicationPath.setExpression(""String_Node_Str"");
  resourcePath=new StringParameter(this,""String_Node_Str"");
  resourcePath.setExpression(""String_Node_Str"");
  resourceLocation=new FileParameter(this,""String_Node_Str"");
  URI modelURI=URIAttribute.getModelURI(this);
  String path;
  if (modelURI != null && modelURI.getPath() != null && !modelURI.getPath().isEmpty()) {
    path=modelURI.getPath().toString();
    int slash=path.lastIndexOf(""String_Node_Str"");
    if (slash != -1) {
      path=path.substring(0,slash);
    }
  }
 else {
    path=""String_Node_Str"";
  }
  resourceLocation.setExpression(path);
  temporaryFileLocation=new FileParameter(this,""String_Node_Str"");
  temporaryFileLocation.setExpression(""String_Node_Str"");
}"
73166,"/** 
 * Clone the object into the specified workspace. This overrides the base class to set the association with iterationCount.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  PtidesPlatform result=(PtidesPlatform)super.clone(workspace);
  try {
    List<PtidesPlatform> platformDirectors=result.attributeList(PtidesPlatformDirector.class);
    PtidesPlatform oldplatformDirector=platformDirectors.get(0);
    String platformDirectorName=oldplatformDirector.getName();
    oldplatformDirector.setContainer(null);
    PtidesPlatformDirector platformDirector=result.new PtidesPlatformDirector(workspace);
    platformDirector.setContainer(result);
    platformDirector.setName(platformDirectorName);
  }
 catch (  Throwable throwable) {
    new CloneNotSupportedException(""String_Node_Str"" + throwable);
  }
  return result;
}","/** 
 * Clone the object into the specified workspace. This overrides the base class to set the association with iterationCount.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  PtidesPlatform result=(PtidesPlatform)super.clone(workspace);
  try {
    List<PtidesPlatformDirector> platformDirectors=result.attributeList(PtidesPlatformDirector.class);
    PtidesPlatformDirector oldplatformDirector=platformDirectors.get(0);
    String platformDirectorName=oldplatformDirector.getName();
    oldplatformDirector.setContainer(null);
    PtidesPlatformDirector platformDirector=result.new PtidesPlatformDirector(workspace);
    platformDirector.setContainer(result);
    platformDirector.setName(platformDirectorName);
  }
 catch (  Throwable throwable) {
    new CloneNotSupportedException(""String_Node_Str"" + throwable);
  }
  return result;
}"
73167,"/** 
 * Get the corresponding type in code generation from the given Ptolemy type.
 * @param type The given Ptolemy type.
 * @return The code generation type.
 * @exception IllegalActionException If the given ptolemy cannotbe resolved.
 */
public String codeGenType(Type type){
  String result=type == BaseType.INT ? ""String_Node_Str"" : type == BaseType.LONG ? ""String_Node_Str"" : type == BaseType.STRING ? ""String_Node_Str"" : type == BaseType.DOUBLE ? ""String_Node_Str"" : type == BaseType.BOOLEAN ? ""String_Node_Str"" : type == BaseType.UNSIGNED_BYTE ? ""String_Node_Str"" : type == PointerToken.POINTER ? ""String_Node_Str"" : type == BaseType.COMPLEX ? ""String_Node_Str"" : type.equals(BaseType.OBJECT) ? ""String_Node_Str"" : null;
  if (result == null) {
    if (type instanceof ArrayType) {
      result=""String_Node_Str"";
    }
 else     if (type instanceof MatrixType) {
      result=""String_Node_Str"";
    }
  }
  if (result == null || result.length() == 0) {
    if (type == BaseType.UNKNOWN) {
      System.out.println(""String_Node_Str"" + type + ""String_Node_Str"");
    }
 else {
      throw new InternalErrorException(""String_Node_Str"" + type + ""String_Node_Str"");
    }
  }
  if (result == null) {
    return null;
  }
  return result.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
}","/** 
 * Get the corresponding type in code generation from the given Ptolemy type.
 * @param type The given Ptolemy type.
 * @return The code generation type.
 * @exception IllegalActionException If the given ptolemy cannotbe resolved.
 */
public String codeGenType(Type type){
  String result=type == BaseType.INT ? ""String_Node_Str"" : type == BaseType.LONG ? ""String_Node_Str"" : type == BaseType.STRING ? ""String_Node_Str"" : type == BaseType.DOUBLE ? ""String_Node_Str"" : type == BaseType.BOOLEAN ? ""String_Node_Str"" : type == BaseType.UNSIGNED_BYTE ? ""String_Node_Str"" : type == PointerToken.POINTER ? ""String_Node_Str"" : type == BaseType.COMPLEX ? ""String_Node_Str"" : type.equals(BaseType.OBJECT) ? ""String_Node_Str"" : null;
  if (result == null) {
    if (type instanceof ArrayType) {
      result=""String_Node_Str"";
    }
 else     if (type instanceof MatrixType) {
      result=""String_Node_Str"";
    }
  }
  if (result == null || result.length() == 0) {
    System.out.println(""String_Node_Str"" + type + ""String_Node_Str"");
  }
  if (result == null) {
    return null;
  }
  return result.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
}"
73168,"/** 
 * Clone the object into the specified workspace. This overrides the base class to set up the associations in the mirror ports and to set a flag indicating that cloning is complete.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MirrorComposite result=(MirrorComposite)super.clone(workspace);
  Iterator entities=result.entityList().iterator();
  while (entities.hasNext()) {
    Entity insideEntity=(Entity)entities.next();
    Iterator ports=result.portList().iterator();
    while (ports.hasNext()) {
      MirrorPort port=(MirrorPort)ports.next();
      Port insidePort=insideEntity.getPort(port.getName());
      if (insidePort instanceof MirrorPort) {
        port.setAssociatedPort((MirrorPort)insidePort);
      }
    }
  }
  return result;
}","/** 
 * Clone the object into the specified workspace. This overrides the base class to set up the associations in the mirror ports and to set a flag indicating that cloning is complete.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MirrorComposite result=(MirrorComposite)super.clone(workspace);
  Iterator entities=result.entityList().iterator();
  while (entities.hasNext()) {
    Entity insideEntity=(Entity)entities.next();
    Iterator ports=result.portList().iterator();
    while (ports.hasNext()) {
      IOPort port=(IOPort)ports.next();
      Port insidePort=insideEntity.getPort(port.getName());
      if (insidePort instanceof MirrorPort) {
        ((MirrorPort)port).setAssociatedPort((MirrorPort)insidePort);
      }
 else       if (insidePort instanceof ParameterMirrorPort) {
        ((ParameterMirrorPort)port).setAssociatedPort((ParameterMirrorPort)insidePort);
      }
    }
  }
  return result;
}"
73169,"/** 
 * Report that an execution error has occurred.  This method is called by the specified manager.
 * @param manager The manager calling this method.
 * @param throwable The throwable being reported.
 */
public void executionError(Manager manager,Throwable throwable){
  getFrame().report(throwable);
  if (throwable instanceof KernelException) {
    highlightError(((KernelException)throwable).getNameable1());
    highlightError(((KernelException)throwable).getNameable2());
    if (throwable instanceof TypeConflictException) {
      Iterator<?> inequalities=((TypeConflictException)throwable).inequalityList().iterator();
      while (inequalities.hasNext()) {
        Object item=inequalities.next();
        if (item instanceof InequalityTerm) {
          Object object=((InequalityTerm)item).getAssociatedObject();
          if (object instanceof Nameable) {
            highlightError((Nameable)object);
          }
        }
 else         if (item instanceof Inequality) {
          Inequality inequality=(Inequality)inequalities.next();
          InequalityTerm term=inequality.getGreaterTerm();
          if (term != null) {
            Object object=term.getAssociatedObject();
            if (object instanceof Nameable) {
              highlightError((Nameable)object);
            }
          }
          term=inequality.getLesserTerm();
          if (term != null) {
            Object object=term.getAssociatedObject();
            if (object instanceof Nameable) {
              highlightError((Nameable)object);
            }
          }
        }
      }
    }
  }
 else   if (throwable instanceof KernelRuntimeException) {
    Iterator<?> causes=((KernelRuntimeException)throwable).getNameables().iterator();
    while (causes.hasNext()) {
      highlightError((Nameable)causes.next());
    }
  }
}","/** 
 * Report that an execution error has occurred.  This method is called by the specified manager.
 * @param manager The manager calling this method.
 * @param throwable The throwable being reported.
 */
public void executionError(Manager manager,Throwable throwable){
  getFrame().report(throwable);
  if (throwable instanceof KernelException) {
    highlightError(((KernelException)throwable).getNameable1());
    highlightError(((KernelException)throwable).getNameable2());
    if (throwable instanceof TypeConflictException) {
      Iterator<?> inequalities=((TypeConflictException)throwable).inequalityList().iterator();
      while (inequalities.hasNext()) {
        Object item=inequalities.next();
        if (item instanceof InequalityTerm) {
          Object object=((InequalityTerm)item).getAssociatedObject();
          if (object instanceof Nameable) {
            highlightError((Nameable)object);
          }
        }
 else         if (item instanceof Inequality) {
          Inequality inequality=(Inequality)item;
          InequalityTerm term=inequality.getGreaterTerm();
          if (term != null) {
            Object object=term.getAssociatedObject();
            if (object instanceof Nameable) {
              highlightError((Nameable)object);
            }
          }
          term=inequality.getLesserTerm();
          if (term != null) {
            Object object=term.getAssociatedObject();
            if (object instanceof Nameable) {
              highlightError((Nameable)object);
            }
          }
        }
      }
    }
  }
 else   if (throwable instanceof KernelRuntimeException) {
    Iterator<?> causes=((KernelRuntimeException)throwable).getNameables().iterator();
    while (causes.hasNext()) {
      highlightError((Nameable)causes.next());
    }
  }
}"
73170,"/** 
 * Construct a configurer for the specified object.  This stores the current values of any Settable attributes of the given object, and then defers to any editor pane factories contained by the given object to populate this panel with widgets that edit the attributes of the given object.  If there are no editor pane factories, then a default editor pane is created.
 * @param object The object to configure.
 */
public Configurer(final NamedObj object){
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  _object=object;
  _originalValues=new HashMap<Settable,String>();
  Set<Settable> parameters=_getVisibleSettables(object,true);
  for (  Settable parameter : parameters) {
    _originalValues.put(parameter,parameter.getExpression());
  }
  boolean foundOne=false;
  Iterator<?> editors=object.attributeList(EditorPaneFactory.class).iterator();
  while (editors.hasNext()) {
    foundOne=true;
    EditorPaneFactory editor=(EditorPaneFactory)editors.next();
    Component pane=editor.createEditorPane();
    add(pane);
    pane.setBackground(null);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
  if (!foundOne) {
    Component pane=EditorPaneFactory.createEditorPane(object);
    add(pane);
    pane.setBackground(null);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
}","/** 
 * Construct a configurer for the specified object.  This stores the current values of any Settable attributes of the given object, and then defers to any editor pane factories contained by the given object to populate this panel with widgets that edit the attributes of the given object.  If there are no editor pane factories, then a default editor pane is created.
 * @param object The object to configure.
 */
public Configurer(final NamedObj object){
  setLayout(new BorderLayout());
  _object=object;
  _originalValues=new HashMap<Settable,String>();
  Set<Settable> parameters=_getVisibleSettables(object,true);
  for (  Settable parameter : parameters) {
    _originalValues.put(parameter,parameter.getExpression());
  }
  boolean foundOne=false;
  Iterator<?> editors=object.attributeList(EditorPaneFactory.class).iterator();
  while (editors.hasNext()) {
    foundOne=true;
    EditorPaneFactory editor=(EditorPaneFactory)editors.next();
    Component pane=editor.createEditorPane();
    add(pane);
    pane.setBackground(null);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
  if (!foundOne) {
    Component pane=EditorPaneFactory.createEditorPane(object);
    add(pane,BorderLayout.CENTER);
    pane.setBackground(null);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
}"
73171,"/** 
 * Set the local director for execution of this CompositeActor. This should not be called be directly.  Instead, call setContainer() on the director.  This method removes any previous director from this container, and caches a local reference to the director so that this composite does not need to search its attributes each time the director is accessed.
 * @param director The Director responsible for execution.
 * @exception IllegalActionException If removing the old directorcauses this to be thrown. Should not be thrown.
 * @exception NameDuplicationException If removing the old directorcauses this to be thrown. Should not be thrown.
 */
protected void _setDirector(Director director) throws IllegalActionException, NameDuplicationException {
  Director oldDirector=getDirector();
  if (director != oldDirector) {
    if (oldDirector != null) {
      oldDirector.invalidateSchedule();
      oldDirector.invalidateResolvedTypes();
    }
    if (director == null || oldDirector == null) {
      _notifyHierarchyListenersBeforeChange();
    }
    _director=director;
    try {
      if (director != null) {
        director.invalidateSchedule();
        director.invalidateResolvedTypes();
      }
 else {
        Director executiveDirector=getExecutiveDirector();
        if (executiveDirector != null) {
          executiveDirector.invalidateSchedule();
        }
      }
    }
  finally {
      if (director == null || oldDirector == null) {
        _notifyHierarchyListenersBeforeChange();
      }
    }
  }
}","/** 
 * Set the local director for execution of this CompositeActor. This should not be called be directly.  Instead, call setContainer() on the director.  This method removes any previous director from this container, and caches a local reference to the director so that this composite does not need to search its attributes each time the director is accessed.
 * @param director The Director responsible for execution.
 * @exception IllegalActionException If removing the old directorcauses this to be thrown. Should not be thrown.
 * @exception NameDuplicationException If removing the old directorcauses this to be thrown. Should not be thrown.
 */
protected void _setDirector(Director director) throws IllegalActionException, NameDuplicationException {
  Director oldDirector=getDirector();
  if (director != oldDirector) {
    if (oldDirector != null) {
      oldDirector.invalidateSchedule();
      oldDirector.invalidateResolvedTypes();
    }
  }
  if (director != _director) {
    if (director == null || oldDirector == null) {
      _notifyHierarchyListenersBeforeChange();
    }
  }
  Director previousLocalDirector=_director;
  try {
    if (director != oldDirector) {
      _director=director;
      if (director != null) {
        director.invalidateSchedule();
        director.invalidateResolvedTypes();
      }
 else {
        Director executiveDirector=getExecutiveDirector();
        if (executiveDirector != null) {
          executiveDirector.invalidateSchedule();
        }
      }
    }
  }
  finally {
    if (director == null || previousLocalDirector == null) {
      _notifyHierarchyListenersAfterChange();
    }
  }
}"
73172,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIAffineTransform(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  affineMatrix=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(_initialMatrix));
  interpolationType=new StringAttribute(this,""String_Node_Str"");
  interpolationType.setExpression(""String_Node_Str"");
  _interpolationType=_BILINEAR;
  subSampleBits=new Parameter(this,""String_Node_Str"",new IntToken(8));
  input.setTypeEquals(BaseType.OBJECT);
  output.setTypeEquals(BaseType.OBJECT);
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIAffineTransform(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  double[][] initialMatrix={{1.0F,0.0F,0.0F},{0.0F,1.0F,0.0F}};
  affineMatrix=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(initialMatrix));
  interpolationType=new StringAttribute(this,""String_Node_Str"");
  interpolationType.setExpression(""String_Node_Str"");
  _interpolationType=_BILINEAR;
  subSampleBits=new Parameter(this,""String_Node_Str"",new IntToken(8));
  input.setTypeEquals(BaseType.OBJECT);
  output.setTypeEquals(BaseType.OBJECT);
}"
73173,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIBandCombine(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  matrix=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(_initialMatrix));
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIBandCombine(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  double[][] initialMatrix={{1.0D,0.0D,0.0D,0.0D},{0.0D,1.0D,0.0D,0.0D},{0.0D,0.0D,1.0D,0.0D}};
  matrix=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(initialMatrix));
}"
73174,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIEdgeDetection(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  input.setTypeEquals(BaseType.OBJECT);
  output.setTypeEquals(BaseType.OBJECT);
  firstMask=new StringAttribute(this,""String_Node_Str"");
  firstMask.setExpression(""String_Node_Str"");
  _firstMask=_SOBEL_HORIZONTAL;
  secondMask=new StringAttribute(this,""String_Node_Str"");
  secondMask.setExpression(""String_Node_Str"");
  _secondMask=_SOBEL_VERTICAL;
  userSpecifiedFirstMask=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(_initialMatrix));
  userSpecifiedSecondMask=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(_initialMatrix));
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIEdgeDetection(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  input.setTypeEquals(BaseType.OBJECT);
  output.setTypeEquals(BaseType.OBJECT);
  firstMask=new StringAttribute(this,""String_Node_Str"");
  firstMask.setExpression(""String_Node_Str"");
  _firstMask=_SOBEL_HORIZONTAL;
  secondMask=new StringAttribute(this,""String_Node_Str"");
  secondMask.setExpression(""String_Node_Str"");
  _secondMask=_SOBEL_VERTICAL;
  double[][] initialMatrix={{0.0F,0.0F,0.0F},{0.0F,0.707F,0.0F},{0.0F,0.0F,0.0F}};
  userSpecifiedFirstMask=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(initialMatrix));
  userSpecifiedSecondMask=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(initialMatrix));
}"
73175,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIPNGWriter(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  adam7Interlacing=new Parameter(this,""String_Node_Str"");
  adam7Interlacing.setTypeEquals(BaseType.BOOLEAN);
  adam7Interlacing.setToken(BooleanToken.TRUE);
  bitDepth=new Parameter(this,""String_Node_Str"",new IntToken(8));
  fileName.setExpression(""String_Node_Str"");
  setGamma=new Parameter(this,""String_Node_Str"");
  setGamma.setTypeEquals(BaseType.BOOLEAN);
  setGamma.setToken(BooleanToken.FALSE);
  gamma=new Parameter(this,""String_Node_Str"",new DoubleToken(0.455F));
  setBackground=new Parameter(this,""String_Node_Str"");
  setBackground.setTypeEquals(BaseType.BOOLEAN);
  setBackground.setToken(BooleanToken.FALSE);
  background=new Parameter(this,""String_Node_Str"",new ArrayToken(BaseType.INT,_initialArray));
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIPNGWriter(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  adam7Interlacing=new Parameter(this,""String_Node_Str"");
  adam7Interlacing.setTypeEquals(BaseType.BOOLEAN);
  adam7Interlacing.setToken(BooleanToken.TRUE);
  bitDepth=new Parameter(this,""String_Node_Str"",new IntToken(8));
  fileName.setExpression(""String_Node_Str"");
  setGamma=new Parameter(this,""String_Node_Str"");
  setGamma.setTypeEquals(BaseType.BOOLEAN);
  setGamma.setToken(BooleanToken.FALSE);
  gamma=new Parameter(this,""String_Node_Str"",new DoubleToken(0.455F));
  setBackground=new Parameter(this,""String_Node_Str"");
  setBackground.setTypeEquals(BaseType.BOOLEAN);
  setBackground.setToken(BooleanToken.FALSE);
  IntToken[] initialArray={new IntToken(0),new IntToken(0),new IntToken(0)};
  background=new Parameter(this,""String_Node_Str"",new ArrayToken(BaseType.INT,initialArray));
}"
73176,"/** 
 * Accept an ObjectToken containing a DataSource, and set it up for playing.
 * @exception IllegalActionException If there is no director,if the file cannot be opened, or if the Java Media Framework throws an exception.
 * @return super.postfire()
 */
public boolean postfire() throws IllegalActionException {
  ObjectToken objectToken=(ObjectToken)input.get(0);
  DataSource input=(DataSource)objectToken.getValue();
  if (_player != null) {
    _player.removeControllerListener(this);
  }
  try {
    _player=Manager.createRealizedPlayer(input);
    _player.addControllerListener(this);
    _player.prefetch();
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,""String_Node_Str"" + ex.toString());
  }
catch (  MediaException ex) {
    throw new IllegalActionException(this,""String_Node_Str"" + ex.toString());
  }
  _player.setMediaTime(_startTime);
  _frame=new JFrame();
  _container=_frame.getContentPane();
  Component controlPanel=_player.getControlPanelComponent();
  _container.add(controlPanel);
  _frame.pack();
  _frame.setVisible(true);
  return super.postfire();
}","/** 
 * Accept an ObjectToken containing a DataSource, and set it up for playing.
 * @exception IllegalActionException If there is no director,if the file cannot be opened, or if the Java Media Framework throws an exception.
 * @return super.postfire()
 */
public boolean postfire() throws IllegalActionException {
  ObjectToken objectToken=(ObjectToken)input.get(0);
  DataSource input=(DataSource)objectToken.getValue();
  if (_player != null) {
    _player.removeControllerListener(this);
  }
  try {
    _player=Manager.createRealizedPlayer(input);
    _player.addControllerListener(this);
    _player.prefetch();
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,""String_Node_Str"" + ex.toString());
  }
catch (  MediaException ex) {
    throw new IllegalActionException(this,""String_Node_Str"" + ex.toString());
  }
  Time _startTime=new Time(0.0);
  _player.setMediaTime(_startTime);
  _frame=new JFrame();
  _container=_frame.getContentPane();
  Component controlPanel=_player.getControlPanelComponent();
  _container.add(controlPanel);
  _frame.pack();
  _frame.setVisible(true);
  return super.postfire();
}"
73177,"/** 
 * Create a schedule for a set of actors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param externalRates Map from external port to an Integerrepresenting the number of tokens produced or consumed from that port during the course of an iteration.
 * @param actorList The actors that need to be scheduled.
 * @param container The container.
 * @return An instance of the Schedule class, indicating the orderin which actors should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
@SuppressWarnings(""String_Node_Str"") private Schedule _scheduleConnectedActors(Map externalRates,List actorList,CompositeActor container) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  Schedule newSchedule=new Schedule();
  Map firingsRemainingVector=new HashMap();
  firingsRemainingVector.putAll(_firingVector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator actorsIterator=actorList.iterator();
    while (actorsIterator.hasNext()) {
      Actor actor=(Actor)actorsIterator.next();
      Iterator inputPorts=actor.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort inputPort=(IOPort)inputPorts.next();
        Receiver[][] receivers=inputPort.getReceivers();
        if (receivers != null) {
          for (int m=0; m < receivers.length; m++) {
            for (int n=0; n < receivers[m].length; n++) {
              ((SDFReceiver)receivers[m][n])._waitingTokens=0;
            }
          }
        }
      }
    }
    Iterator externalOutputPorts=container.outputPortList().iterator();
    while (externalOutputPorts.hasNext()) {
      IOPort outputPort=(IOPort)externalOutputPorts.next();
      Receiver[][] receivers=outputPort.getInsideReceivers();
      if (receivers != null) {
        for (int m=0; m < receivers.length; m++) {
          for (int n=0; n < receivers[m].length; n++) {
            ((SDFReceiver)receivers[m][n])._waitingTokens=0;
          }
        }
      }
    }
    Iterator actors=actorList.iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      int firingsRemaining=((Integer)firingsRemainingVector.get(actor)).intValue();
      if (firingsRemaining == 0) {
        unscheduledActorList.remove(actor);
        continue;
      }
      int inputCount=_countUnfulfilledInputs(actor,actorList,true);
      if (inputCount == 0) {
        readyToScheduleActorList.addFirst(actor);
      }
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + ((ComponentEntity)actor).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
      }
    }
    actors=actorList.iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      Iterator outputPorts=actor.outputPortList().iterator();
      while (outputPorts.hasNext()) {
        IOPort outputPort=(IOPort)outputPorts.next();
        int count=DFUtilities.getTokenInitProduction(outputPort);
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"" + count + ""String_Node_Str""+ outputPort);
        }
        if (count > 0) {
          _simulateTokensCreated(outputPort,count,actorList,readyToScheduleActorList);
        }
      }
    }
    for (Iterator inputPorts=container.inputPortList().iterator(); inputPorts.hasNext(); ) {
      IOPort port=(IOPort)inputPorts.next();
      int count=((Integer)externalRates.get(port)).intValue();
      if (count > 0) {
        _simulateExternalInputs(port,count,actorList,readyToScheduleActorList);
      }
    }
    while (readyToScheduleActorList.size() > 0) {
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"");
        for (Iterator readyActors=readyToScheduleActorList.iterator(); readyActors.hasNext(); ) {
          Entity readyActor=(Entity)readyActors.next();
          _debug(readyActor.getFullName());
        }
        _debug(""String_Node_Str"");
        for (Iterator remainingActors=unscheduledActorList.iterator(); remainingActors.hasNext(); ) {
          Entity remainingActor=(Entity)remainingActors.next();
          _debug(remainingActor.getFullName());
        }
      }
      Actor currentActor=(Actor)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor)) {
      }
      int numberOfFirings=_computeMaximumFirings(currentActor);
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      if (numberOfFirings > firingsRemaining) {
        numberOfFirings=firingsRemaining;
      }
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + currentActor.getName() + ""String_Node_Str""+ numberOfFirings+ ""String_Node_Str"");
      }
      firingsRemaining-=numberOfFirings;
      firingsRemainingVector.put(currentActor,Integer.valueOf(firingsRemaining));
      if (_debugging && VERBOSE) {
        _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      }
      _simulateInputConsumption(currentActor,numberOfFirings);
      Firing firing=new Firing();
      firing.setActor(currentActor);
      firing.setIterationCount(numberOfFirings);
      newSchedule.add(firing);
      for (Iterator outputPorts=(currentActor).outputPortList().iterator(); outputPorts.hasNext(); ) {
        IOPort outputPort=(IOPort)outputPorts.next();
        int count=DFUtilities.getTokenProductionRate(outputPort);
        _simulateTokensCreated(outputPort,count * numberOfFirings,unscheduledActorList,readyToScheduleActorList);
      }
      if (firingsRemaining < 0) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      if (firingsRemaining == 0) {
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"" + currentActor + ""String_Node_Str"");
        }
        while (unscheduledActorList.remove(currentActor)) {
          ;
        }
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"");
          for (Iterator readyActors=readyToScheduleActorList.iterator(); readyActors.hasNext(); ) {
            Entity entity=(Entity)readyActors.next();
            _debug(entity.getFullName());
          }
        }
      }
 else {
        int inputCount=_countUnfulfilledInputs(currentActor,unscheduledActorList,false);
        if ((inputCount <= 0) && unscheduledActorList.contains(currentActor)) {
          readyToScheduleActorList.addFirst(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(this,ex,""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    StringBuffer message=new StringBuffer(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    int count=0;
    for (Iterator actors=unscheduledActorList.iterator(); actors.hasNext() && count < 100; count++) {
      Entity entity=(Entity)actors.next();
      message.append(entity.getFullName() + ""String_Node_Str"");
    }
    if (count >= 99) {
      message.append(""String_Node_Str"");
    }
    message.append(""String_Node_Str"");
    List scheduledActorList=new LinkedList();
    scheduledActorList.addAll(actorList);
    scheduledActorList.removeAll(unscheduledActorList);
    count=0;
    for (Iterator actors=scheduledActorList.iterator(); actors.hasNext() && count < 100; count++) {
      Entity entity=(Entity)actors.next();
      message.append(entity.getFullName() + ""String_Node_Str"");
    }
    if (count >= 99) {
      message.append(""String_Node_Str"");
    }
    throw new NotSchedulableException(this,message.toString());
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(newSchedule.toString());
  }
  return newSchedule;
}","/** 
 * Create a schedule for a set of actors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param externalRates Map from external port to an Integerrepresenting the number of tokens produced or consumed from that port during the course of an iteration.
 * @param actorList The actors that need to be scheduled.
 * @param container The container.
 * @return An instance of the Schedule class, indicating the orderin which actors should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
@SuppressWarnings(""String_Node_Str"") private Schedule _scheduleConnectedActors(Map externalRates,List actorList,CompositeActor container) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  Schedule newSchedule=new Schedule();
  Map firingsRemainingVector=new HashMap();
  firingsRemainingVector.putAll(_firingVector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator actorsIterator=actorList.iterator();
    while (actorsIterator.hasNext()) {
      Actor actor=(Actor)actorsIterator.next();
      Iterator inputPorts=actor.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort inputPort=(IOPort)inputPorts.next();
        Receiver[][] receivers=inputPort.getReceivers();
        if (receivers != null) {
          for (int m=0; m < receivers.length; m++) {
            for (int n=0; n < receivers[m].length; n++) {
              ((SDFReceiver)receivers[m][n])._waitingTokens=0;
            }
          }
        }
      }
    }
    Iterator externalOutputPorts=container.outputPortList().iterator();
    while (externalOutputPorts.hasNext()) {
      IOPort outputPort=(IOPort)externalOutputPorts.next();
      Receiver[][] receivers=outputPort.getInsideReceivers();
      if (receivers != null) {
        for (int m=0; m < receivers.length; m++) {
          for (int n=0; n < receivers[m].length; n++) {
            ((SDFReceiver)receivers[m][n])._waitingTokens=0;
          }
        }
      }
    }
    Iterator actors=actorList.iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      int firingsRemaining=((Integer)firingsRemainingVector.get(actor)).intValue();
      if (firingsRemaining == 0) {
        unscheduledActorList.remove(actor);
        continue;
      }
      int inputCount=_countUnfulfilledInputs(actor,actorList,true);
      if (inputCount == 0) {
        readyToScheduleActorList.addFirst(actor);
      }
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + ((ComponentEntity)actor).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
      }
    }
    actors=actorList.iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      Iterator outputPorts=actor.outputPortList().iterator();
      while (outputPorts.hasNext()) {
        IOPort outputPort=(IOPort)outputPorts.next();
        int count=DFUtilities.getTokenInitProduction(outputPort);
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"" + count + ""String_Node_Str""+ outputPort);
        }
        if (count > 0) {
          _simulateTokensCreated(outputPort,count,actorList,readyToScheduleActorList);
        }
      }
    }
    for (Iterator inputPorts=container.inputPortList().iterator(); inputPorts.hasNext(); ) {
      IOPort port=(IOPort)inputPorts.next();
      int count=((Integer)externalRates.get(port)).intValue();
      if (count > 0) {
        _simulateExternalInputs(port,count,actorList,readyToScheduleActorList);
      }
    }
    while (readyToScheduleActorList.size() > 0) {
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"");
        for (Iterator readyActors=readyToScheduleActorList.iterator(); readyActors.hasNext(); ) {
          Entity readyActor=(Entity)readyActors.next();
          _debug(readyActor.getFullName());
        }
        _debug(""String_Node_Str"");
        for (Iterator remainingActors=unscheduledActorList.iterator(); remainingActors.hasNext(); ) {
          Entity remainingActor=(Entity)remainingActors.next();
          _debug(remainingActor.getFullName());
        }
      }
      Actor currentActor=(Actor)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor)) {
      }
      int numberOfFirings=_computeMaximumFirings(currentActor);
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      if (numberOfFirings > firingsRemaining) {
        numberOfFirings=firingsRemaining;
      }
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + currentActor.getName() + ""String_Node_Str""+ numberOfFirings+ ""String_Node_Str"");
      }
      firingsRemaining-=numberOfFirings;
      firingsRemainingVector.put(currentActor,Integer.valueOf(firingsRemaining));
      if (_debugging && VERBOSE) {
        _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      }
      _simulateInputConsumption(currentActor,numberOfFirings);
      Firing firing=new Firing();
      firing.setActor(currentActor);
      firing.setIterationCount(numberOfFirings);
      newSchedule.add(firing);
      for (Iterator outputPorts=(currentActor).outputPortList().iterator(); outputPorts.hasNext(); ) {
        IOPort outputPort=(IOPort)outputPorts.next();
        int count=DFUtilities.getTokenProductionRate(outputPort);
        _simulateTokensCreated(outputPort,count * numberOfFirings,unscheduledActorList,readyToScheduleActorList);
      }
      if (firingsRemaining < 0) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      if (firingsRemaining == 0) {
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"" + currentActor + ""String_Node_Str"");
        }
        while (unscheduledActorList.remove(currentActor)) {
          ;
        }
        if (_debugging && VERBOSE) {
          _debug(""String_Node_Str"");
          for (Iterator readyActors=readyToScheduleActorList.iterator(); readyActors.hasNext(); ) {
            Entity entity=(Entity)readyActors.next();
            _debug(entity.getFullName());
          }
        }
      }
 else {
        int inputCount=_countUnfulfilledInputs(currentActor,unscheduledActorList,false);
        if ((inputCount <= 0) && unscheduledActorList.contains(currentActor)) {
          readyToScheduleActorList.addFirst(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(this,ex,""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    StringBuffer message=new StringBuffer(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    int count=0;
    for (Iterator actors=unscheduledActorList.iterator(); actors.hasNext() && count < 100; count++) {
      Entity entity=(Entity)actors.next();
      message.append(entity.getFullName() + ""String_Node_Str"");
    }
    if (count >= 99) {
      message.append(""String_Node_Str"");
    }
    message.append(""String_Node_Str"");
    List scheduledActorList=new LinkedList();
    scheduledActorList.addAll(actorList);
    scheduledActorList.removeAll(unscheduledActorList);
    count=0;
    for (Iterator actors=scheduledActorList.iterator(); actors.hasNext() && count < 100; count++) {
      Entity entity=(Entity)actors.next();
      message.append(entity.getFullName() + ""String_Node_Str"");
    }
    if (count >= 99) {
      message.append(""String_Node_Str"");
    }
    throw new NotSchedulableException(this,message.toString());
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(newSchedule.toString());
  }
  return newSchedule;
}"
73178,"/** 
 * Create the first tableau for the given effigy, using the tableau factory.  This is called after an effigy is first opened, or when a new effigy is created.  If the method fails to create a tableau, then it removes the effigy from the directory. This prevents us from having lingering effigies that have no user interface.
 * @return A tableau for the specified effigy, or null if nonecan be opened.
 * @param effigy The effigy for which to create a tableau.
 */
public Tableau createPrimaryTableau(final Effigy effigy){
  TableauFactory factory=null;
  if (effigy instanceof PtolemyEffigy) {
    NamedObj model=((PtolemyEffigy)effigy).getModel();
    if (model != null) {
      Iterator factories=model.attributeList(TableauFactory.class).iterator();
      while (factories.hasNext() && (factory == null)) {
        factory=(TableauFactory)factories.next();
        try {
          Tableau tableau=factory.createTableau(effigy);
          if (tableau != null) {
            if (effigy.masterEffigy() == effigy) {
              tableau.setMaster(true);
            }
            tableau.setEditable(effigy.isModifiable());
            tableau.show();
            return tableau;
          }
        }
 catch (        Exception ex) {
          factory=null;
        }
      }
    }
  }
  factory=(TableauFactory)getAttribute(""String_Node_Str"");
  if (factory != null) {
    try {
      Tableau tableau=factory.createTableau(effigy);
      if (tableau == null) {
        throw new Exception(""String_Node_Str"");
      }
      if (effigy.getContainer() instanceof ModelDirectory) {
        tableau.setMaster(true);
      }
      tableau.setEditable(effigy.isModifiable());
      tableau.show();
      return tableau;
    }
 catch (    Exception ex) {
      boolean calledMessageHandler=false;
      try {
        if (effigy.getContainer() instanceof ModelDirectory) {
          if (effigy instanceof PtolemyEffigy) {
            if (((PtolemyEffigy)effigy).getModel() != null) {
              MessageHandler.error(""String_Node_Str"" + ((PtolemyEffigy)effigy).getModel().getFullName(),ex);
            }
 else {
              MessageHandler.error(""String_Node_Str"" + effigy,ex);
            }
            calledMessageHandler=true;
          }
 else {
            MessageHandler.error(""String_Node_Str"" + effigy.identifier.getExpression(),ex);
            calledMessageHandler=true;
          }
        }
        effigy.setContainer(null);
      }
 catch (      Throwable throwable) {
        calledMessageHandler=false;
        throw new InternalErrorException(this,throwable,null);
      }
      if (effigy instanceof PtolemyEffigy) {
        NamedObj object=((PtolemyEffigy)effigy).getModel();
        String filename=StringUtilities.objectToSourceFileName(object);
        try {
          URL toRead=getClass().getClassLoader().getResource(filename);
          if (toRead == null) {
            toRead=ClassUtilities.sourceResource(filename);
          }
          if (toRead != null) {
            return openModel(null,toRead,toRead.toExternalForm());
          }
 else {
            MessageHandler.error(""String_Node_Str"" + object.getFullName());
          }
        }
 catch (        Exception exception) {
          MessageHandler.error(""String_Node_Str"" + object.getFullName(),exception);
        }
      }
      if (!calledMessageHandler) {
        MessageHandler.error(""String_Node_Str"" + effigy.identifier.getExpression(),ex);
      }
    }
  }
  return null;
}","/** 
 * Create the first tableau for the given effigy, using the tableau factory.  This is called after an effigy is first opened, or when a new effigy is created.  If the method fails to create a tableau, then it removes the effigy from the directory. This prevents us from having lingering effigies that have no user interface.
 * @return A tableau for the specified effigy, or null if nonecan be opened.
 * @param effigy The effigy for which to create a tableau.
 */
public Tableau createPrimaryTableau(final Effigy effigy){
  TableauFactory factory=null;
  if (effigy instanceof PtolemyEffigy) {
    NamedObj model=((PtolemyEffigy)effigy).getModel();
    if (model != null) {
      Iterator factories=model.attributeList(TableauFactory.class).iterator();
      while (factories.hasNext() && (factory == null)) {
        factory=(TableauFactory)factories.next();
        try {
          Tableau tableau=factory.createTableau(effigy);
          if (tableau != null) {
            if (effigy.masterEffigy() == effigy) {
              tableau.setMaster(true);
            }
            tableau.setEditable(effigy.isModifiable());
            tableau.show();
            return tableau;
          }
        }
 catch (        Exception ex) {
          factory=null;
        }
      }
    }
  }
  factory=(TableauFactory)getAttribute(""String_Node_Str"");
  if (factory != null) {
    try {
      Tableau tableau=factory.createTableau(effigy);
      if (tableau == null) {
        throw new Exception(""String_Node_Str"");
      }
      if (effigy.getContainer() instanceof ModelDirectory) {
        tableau.setMaster(true);
      }
      tableau.setEditable(effigy.isModifiable());
      tableau.show();
      return tableau;
    }
 catch (    Exception ex) {
      boolean calledMessageHandler=false;
      try {
        if (effigy.getContainer() instanceof ModelDirectory) {
          if (effigy instanceof PtolemyEffigy) {
            if (((PtolemyEffigy)effigy).getModel() != null) {
              MessageHandler.error(""String_Node_Str"" + ((PtolemyEffigy)effigy).getModel().getFullName(),ex);
            }
 else {
              MessageHandler.error(""String_Node_Str"" + effigy,ex);
            }
            calledMessageHandler=true;
          }
 else {
            MessageHandler.error(""String_Node_Str"" + effigy.identifier.getExpression(),ex);
            calledMessageHandler=true;
          }
        }
        effigy.setContainer(null);
      }
 catch (      Throwable throwable) {
        calledMessageHandler=false;
        throw new InternalErrorException(this,throwable,null);
      }
      if (effigy instanceof PtolemyEffigy) {
        NamedObj object=((PtolemyEffigy)effigy).getModel();
        String filename=StringUtilities.objectToSourceFileName(object);
        try {
          URL toRead=getClass().getClassLoader().getResource(filename);
          if (toRead == null) {
            toRead=ClassUtilities.sourceResource(filename);
            System.out.println(""String_Node_Str"" + filename + ""String_Node_Str""+ toRead);
          }
          if (toRead != null) {
            return openModel(null,toRead,toRead.toExternalForm());
          }
 else {
            MessageHandler.error(""String_Node_Str"" + object.getFullName());
          }
        }
 catch (        Exception exception) {
          MessageHandler.error(""String_Node_Str"" + object.getFullName(),exception);
        }
      }
      if (!calledMessageHandler) {
        MessageHandler.error(""String_Node_Str"" + effigy.identifier.getExpression(),ex);
      }
    }
  }
  return null;
}"
73179,"/** 
 * Check that clone(Workspace) method properly sets the fields. In a cloned Director, Attribute or Actor, all private fields should either point to null or to distinct objects.
 * @param namedObj The NamedObj, usually a Director, Attributeor actor to be checked.
 * @param namedObjClone the clone of the namedObj, created withclone(new Workspace())
 * @param field The field to be checked.
 * @return A string containing an error message if there is a problem,otherwise return the empty string.
 * @exception CloneNotSupportedException If namedObj does not supportclone(Workspace).
 * @exception IllegalAccessException If there is a problem gettinga field.
 * @exception ClassNotFoundException If a class cannot be found.
 */
private static String _checkCloneField(NamedObj namedObj,NamedObj namedObjClone,Field field) throws CloneNotSupportedException, IllegalAccessException, ClassNotFoundException {
  Class namedObjClass=namedObj.getClass();
  StringBuffer results=new StringBuffer();
  field.setAccessible(true);
  Class fieldType=field.getType();
  if (!fieldType.isPrimitive() && field.get(namedObj) != null && !Modifier.isStatic(field.getModifiers()) && !fieldType.toString().equals(""String_Node_Str"") && !field.getName().equals(""String_Node_Str"") && !(field.getName().indexOf(""String_Node_Str"") != -1) && !(field.getName().indexOf(""String_Node_Str"") != -1) && !(field.getName().indexOf(""String_Node_Str"") != -1) && !(field.getName().indexOf(""String_Node_Str"") != -1) && !fieldType.equals(java.net.InetAddress.class) && !fieldType.equals(java.util.regex.Pattern.class) && !fieldType.equals(Boolean.class) && !fieldType.equals(Class.class) && !fieldType.equals(String.class) && !fieldType.equals(Token.class) && !fieldType.equals(ptolemy.data.type.Type.class) && !fieldType.equals(Settable.Visibility.class)) {
    if ((field.get(namedObj)).equals(field.get(namedObjClone)) && (System.identityHashCode(field.get(namedObj)) == System.identityHashCode(field.get(namedObjClone)))) {
      String message=""String_Node_Str"";
      if (Class.forName(""String_Node_Str"").isAssignableFrom(fieldType)) {
        NamedObj fieldNamedObj=(NamedObj)Class.forName(""String_Node_Str"").cast(field.get(namedObj));
        NamedObj cloneNamedObj=(NamedObj)Class.forName(""String_Node_Str"").cast(field.get(namedObjClone));
        message=""String_Node_Str"" + fieldNamedObj.workspace().getName() + ""String_Node_Str""+ cloneNamedObj.workspace().getName();
      }
      String assignment=field.getName();
      if (Class.forName(""String_Node_Str"").isAssignableFrom(fieldType)) {
        assignment=""String_Node_Str"" + assignment + ""String_Node_Str"";
      }
 else       if (Class.forName(""String_Node_Str"").isAssignableFrom(fieldType)) {
        Attribute fieldAttribute=(Attribute)field.get(namedObjClone);
        if (fieldAttribute.getContainer() != namedObjClone) {
          assignment=""String_Node_Str"" + fieldAttribute.getContainer().getName() + ""String_Node_Str""+ fieldAttribute.getName()+ ""String_Node_Str"";
        }
 else {
          assignment=""String_Node_Str"" + assignment + ""String_Node_Str"";
        }
      }
 else {
        assignment=""String_Node_Str"" + ""String_Node_Str"" + assignment;
      }
      String shortClassName=field.getType().getName().substring(field.getType().getName().lastIndexOf(""String_Node_Str"") + 1);
      results.append(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getType().getName()+ ""String_Node_Str""+ ""String_Node_Str""+ namedObjClass.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ shortClassName+ ""String_Node_Str""+ assignment+ ""String_Node_Str""+ message);
    }
  }
  return results.toString();
}","/** 
 * Check that clone(Workspace) method properly sets the fields. In a cloned Director, Attribute or Actor, all private fields should either point to null or to distinct objects.
 * @param namedObj The NamedObj, usually a Director, Attributeor actor to be checked.
 * @param namedObjClone the clone of the namedObj, created withclone(new Workspace())
 * @param field The field to be checked.
 * @return A string containing an error message if there is a problem,otherwise return the empty string.
 * @exception CloneNotSupportedException If namedObj does not supportclone(Workspace).
 * @exception IllegalAccessException If there is a problem gettinga field.
 * @exception ClassNotFoundException If a class cannot be found.
 */
private static String _checkCloneField(NamedObj namedObj,NamedObj namedObjClone,Field field) throws CloneNotSupportedException, IllegalAccessException, ClassNotFoundException {
  Class namedObjClass=namedObj.getClass();
  StringBuffer results=new StringBuffer();
  field.setAccessible(true);
  Class fieldType=field.getType();
  if (!fieldType.isPrimitive() && field.get(namedObj) != null && !Modifier.isStatic(field.getModifiers()) && !Modifier.isStatic(fieldType.getModifiers()) && !fieldType.toString().equals(""String_Node_Str"") && !field.getName().equals(""String_Node_Str"") && !(field.getName().indexOf(""String_Node_Str"") != -1) && !(field.getName().indexOf(""String_Node_Str"") != -1) && !(field.getName().indexOf(""String_Node_Str"") != -1) && !(field.getName().indexOf(""String_Node_Str"") != -1) && !fieldType.equals(java.net.InetAddress.class) && !fieldType.equals(java.util.regex.Pattern.class) && !fieldType.equals(Boolean.class) && !fieldType.equals(Class.class) && !fieldType.equals(String.class) && !fieldType.equals(Token.class) && !fieldType.equals(ptolemy.data.type.Type.class) && !fieldType.equals(Settable.Visibility.class)) {
    if ((field.get(namedObj)).equals(field.get(namedObjClone)) && (System.identityHashCode(field.get(namedObj)) == System.identityHashCode(field.get(namedObjClone)))) {
      String message=""String_Node_Str"";
      if (Class.forName(""String_Node_Str"").isAssignableFrom(fieldType)) {
        NamedObj fieldNamedObj=(NamedObj)Class.forName(""String_Node_Str"").cast(field.get(namedObj));
        NamedObj cloneNamedObj=(NamedObj)Class.forName(""String_Node_Str"").cast(field.get(namedObjClone));
        message=""String_Node_Str"" + fieldNamedObj.workspace().getName() + ""String_Node_Str""+ cloneNamedObj.workspace().getName();
      }
      String assignment=field.getName();
      if (Class.forName(""String_Node_Str"").isAssignableFrom(fieldType)) {
        assignment=""String_Node_Str"" + assignment + ""String_Node_Str"";
      }
 else       if (Class.forName(""String_Node_Str"").isAssignableFrom(fieldType)) {
        Attribute fieldAttribute=(Attribute)field.get(namedObjClone);
        if (fieldAttribute.getContainer() != namedObjClone) {
          assignment=""String_Node_Str"" + fieldAttribute.getContainer().getName() + ""String_Node_Str""+ fieldAttribute.getName()+ ""String_Node_Str"";
        }
 else {
          assignment=""String_Node_Str"" + assignment + ""String_Node_Str"";
        }
      }
 else {
        assignment=""String_Node_Str"" + ""String_Node_Str"" + assignment;
      }
      String shortClassName=field.getType().getName().substring(field.getType().getName().lastIndexOf(""String_Node_Str"") + 1);
      results.append(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getType().getName()+ ""String_Node_Str""+ ""String_Node_Str""+ namedObjClass.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ shortClassName+ ""String_Node_Str""+ assignment+ ""String_Node_Str""+ message);
    }
  }
  return results.toString();
}"
73180,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIBandSelect(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  bandIndices=new Parameter(this,""String_Node_Str"",new ArrayToken(BaseType.INT,_initialArray));
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIBandSelect(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  IntToken[] initialArray={new IntToken(0),new IntToken(1),new IntToken(2)};
  bandIndices=new Parameter(this,""String_Node_Str"",new ArrayToken(BaseType.INT,initialArray));
}"
73181,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIBorder(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  leftPadding=new Parameter(this,""String_Node_Str"",new IntToken(0));
  rightPadding=new Parameter(this,""String_Node_Str"",new IntToken(0));
  topPadding=new Parameter(this,""String_Node_Str"",new IntToken(0));
  bottomPadding=new Parameter(this,""String_Node_Str"",new IntToken(0));
  borderType=new StringAttribute(this,""String_Node_Str"");
  borderType.setExpression(""String_Node_Str"");
  _borderType=_BORDER_ZERO;
  constants=new Parameter(this,""String_Node_Str"",new ArrayToken(BaseType.DOUBLE,_initialArray));
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIBorder(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  leftPadding=new Parameter(this,""String_Node_Str"",new IntToken(0));
  rightPadding=new Parameter(this,""String_Node_Str"",new IntToken(0));
  topPadding=new Parameter(this,""String_Node_Str"",new IntToken(0));
  bottomPadding=new Parameter(this,""String_Node_Str"",new IntToken(0));
  borderType=new StringAttribute(this,""String_Node_Str"");
  borderType.setExpression(""String_Node_Str"");
  _borderType=_BORDER_ZERO;
  DoubleToken[] initialArray={new DoubleToken(0)};
  constants=new Parameter(this,""String_Node_Str"",new ArrayToken(BaseType.DOUBLE,initialArray));
}"
73182,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIConstant(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  output.setTypeEquals(BaseType.OBJECT);
  width=new Parameter(this,""String_Node_Str"",new IntToken(0));
  height=new Parameter(this,""String_Node_Str"",new IntToken(0));
  bandValues=new Parameter(this,""String_Node_Str"",new ArrayToken(BaseType.INT,_defaultValues));
  _values=((ArrayToken)bandValues.getToken()).arrayValue();
  dataFormat=new StringAttribute(this,""String_Node_Str"");
  dataFormat.setExpression(""String_Node_Str"");
  _dataFormat=_BYTE;
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIConstant(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  output.setTypeEquals(BaseType.OBJECT);
  width=new Parameter(this,""String_Node_Str"",new IntToken(0));
  height=new Parameter(this,""String_Node_Str"",new IntToken(0));
  IntToken[] defaultValues={IntToken.ZERO};
  bandValues=new Parameter(this,""String_Node_Str"",new ArrayToken(BaseType.INT,defaultValues));
  _values=((ArrayToken)bandValues.getToken()).arrayValue();
  dataFormat=new StringAttribute(this,""String_Node_Str"");
  dataFormat.setExpression(""String_Node_Str"");
  _dataFormat=_BYTE;
}"
73183,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIConvolve(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  input.setTypeEquals(BaseType.OBJECT);
  output.setTypeEquals(BaseType.OBJECT);
  filter=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(_initialMatrix));
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public JAIConvolve(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  input.setTypeEquals(BaseType.OBJECT);
  output.setTypeEquals(BaseType.OBJECT);
  double[][] initialMatrix={{0.0F,0.0F,0.0F},{0.0F,1.0F,0.0F},{0.0F,0.0F,0.0F}};
  filter=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(initialMatrix));
}"
73184,"/** 
 * Report that a manager state has changed. This method is called by the specified manager.
 * @param manager The manager calling this method.
 */
public void managerStateChanged(Manager manager){
  Manager.State newState=manager.getState();
  if (newState != _previousState) {
    String statusMessage=manager.getStatusMessage();
    if (statusMessage == _previousStatusMessage) {
      _previousStatusMessage=statusMessage;
      statusMessage=""String_Node_Str"";
    }
 else {
      _previousStatusMessage=statusMessage;
    }
    if (!statusMessage.isEmpty()) {
      statusMessage=""String_Node_Str"" + statusMessage;
    }
 else {
      statusMessage=""String_Node_Str"";
    }
    report(manager.getState().getDescription() + statusMessage);
    _previousState=newState;
  }
}","/** 
 * Report that a manager state has changed. This method is called by the specified manager.
 * @param manager The manager calling this method.
 */
public void managerStateChanged(Manager manager){
  Manager.State newState=manager.getState();
  if (newState != _previousState) {
    String statusMessage=manager.getStatusMessage();
    if (statusMessage.equals(_previousStatusMessage)) {
      _previousStatusMessage=statusMessage;
      statusMessage=""String_Node_Str"";
    }
 else {
      _previousStatusMessage=statusMessage;
    }
    if (!statusMessage.isEmpty()) {
      statusMessage=""String_Node_Str"" + statusMessage;
    }
 else {
      statusMessage=""String_Node_Str"";
    }
    report(manager.getState().getDescription() + statusMessage);
    _previousState=newState;
  }
}"
73185,"/** 
 * Report that a manager state has changed. This method is called by the specified manager.
 * @param manager The manager calling this method.
 */
public void managerStateChanged(Manager manager){
  Manager.State newState=manager.getState();
  if (newState != _previousState) {
    if (newState == Manager.IDLE || _areThereActiveErrorHighlights()) {
      ChangeRequest request=_getClearAllErrorHighlightsChangeRequest();
      manager.requestChange(request);
    }
    String statusMessage=manager.getStatusMessage();
    if (statusMessage == _previousStatusMessage) {
      _previousStatusMessage=statusMessage;
      statusMessage=""String_Node_Str"";
    }
 else {
      _previousStatusMessage=statusMessage;
    }
    if (!statusMessage.isEmpty()) {
      statusMessage=""String_Node_Str"" + statusMessage;
    }
 else {
      statusMessage=""String_Node_Str"";
    }
    getFrame().report(manager.getState().getDescription() + statusMessage);
    _previousState=newState;
    if (newState == Manager.INITIALIZING || newState == Manager.ITERATING || newState == Manager.PREINITIALIZING || newState == Manager.RESOLVING_TYPES || newState == Manager.WRAPPING_UP || newState == Manager.EXITING) {
      ((ButtonFigureAction)_runModelAction).setSelected(true);
      ((ButtonFigureAction)_pauseModelAction).setSelected(false);
      ((ButtonFigureAction)_stopModelAction).setSelected(false);
    }
 else     if (newState == Manager.PAUSED) {
      ((ButtonFigureAction)_runModelAction).setSelected(false);
      ((ButtonFigureAction)_pauseModelAction).setSelected(true);
      ((ButtonFigureAction)_stopModelAction).setSelected(false);
    }
 else {
      ((ButtonFigureAction)_runModelAction).setSelected(false);
      ((ButtonFigureAction)_pauseModelAction).setSelected(false);
      ((ButtonFigureAction)_stopModelAction).setSelected(true);
    }
  }
}","/** 
 * Report that a manager state has changed. This method is called by the specified manager.
 * @param manager The manager calling this method.
 */
public void managerStateChanged(Manager manager){
  Manager.State newState=manager.getState();
  if (newState != _previousState) {
    if (newState == Manager.IDLE || _areThereActiveErrorHighlights()) {
      ChangeRequest request=_getClearAllErrorHighlightsChangeRequest();
      manager.requestChange(request);
    }
    String statusMessage=manager.getStatusMessage();
    if (statusMessage.equals(_previousStatusMessage)) {
      _previousStatusMessage=statusMessage;
      statusMessage=""String_Node_Str"";
    }
 else {
      _previousStatusMessage=statusMessage;
    }
    if (!statusMessage.isEmpty()) {
      statusMessage=""String_Node_Str"" + statusMessage;
    }
 else {
      statusMessage=""String_Node_Str"";
    }
    getFrame().report(manager.getState().getDescription() + statusMessage);
    _previousState=newState;
    if (newState == Manager.INITIALIZING || newState == Manager.ITERATING || newState == Manager.PREINITIALIZING || newState == Manager.RESOLVING_TYPES || newState == Manager.WRAPPING_UP || newState == Manager.EXITING) {
      ((ButtonFigureAction)_runModelAction).setSelected(true);
      ((ButtonFigureAction)_pauseModelAction).setSelected(false);
      ((ButtonFigureAction)_stopModelAction).setSelected(false);
    }
 else     if (newState == Manager.PAUSED) {
      ((ButtonFigureAction)_runModelAction).setSelected(false);
      ((ButtonFigureAction)_pauseModelAction).setSelected(true);
      ((ButtonFigureAction)_stopModelAction).setSelected(false);
    }
 else {
      ((ButtonFigureAction)_runModelAction).setSelected(false);
      ((ButtonFigureAction)_pauseModelAction).setSelected(false);
      ((ButtonFigureAction)_stopModelAction).setSelected(true);
    }
  }
}"
73186,"/** 
 * Configure the object with data from the specified input source (a URL) and/or textual data, assumed to be in PlotML format. If this is called before the plotter has been created (by calling place() or initialize()), then the configuration is deferred until the plotter is created.
 * @param base The base relative to which references within the inputare found, or null if this is not known, or there is none.
 * @param source The input source, which specifies a URL.
 * @param text Configuration information given as text.
 * @exception Exception If the configuration source cannot be reador if the configuration information is incorrect.
 */
public void configure(URL base,String source,String text) throws Exception {
  _base=base;
  _source=source;
  _text=text;
  if (plot instanceof PlotInterface) {
    PlotMLParser parser=new PlotMLParser((PlotInterface)plot);
    if ((source != null) && !source.trim().equals(""String_Node_Str"")) {
      URL xmlFile=new URL(base,source);
      InputStream stream=xmlFile.openStream();
      parser.parse(base,stream);
      stream.close();
      _configureSource=source;
    }
    if ((text != null) && !text.equals(""String_Node_Str"")) {
      String trimmed=text.trim();
      if (trimmed.startsWith(""String_Node_Str"") && trimmed.endsWith(""String_Node_Str"")) {
        trimmed=trimmed.substring(2,trimmed.length() - 2).trim();
        if (trimmed.startsWith(""String_Node_Str"")) {
          trimmed=trimmed.substring(6).trim();
          parser.parse(base,trimmed);
        }
      }
 else {
        parser.parse(base,text);
      }
    }
  }
 else {
    if (_configureBases == null) {
      _configureBases=new LinkedList<URL>();
      _configureSources=new LinkedList<String>();
      _configureTexts=new LinkedList<String>();
    }
    _configureBases.add(base);
    _configureSources.add(source);
    _configureTexts.add(text);
  }
}","/** 
 * Configure the object with data from the specified input source (a URL) and/or textual data, assumed to be in PlotML format. If this is called before the plotter has been created (by calling place() or initialize()), then the configuration is deferred until the plotter is created.
 * @param base The base relative to which references within the inputare found, or null if this is not known, or there is none.
 * @param source The input source, which specifies a URL.
 * @param text Configuration information given as text.
 * @exception Exception If the configuration source cannot be reador if the configuration information is incorrect.
 */
public void configure(URL base,String source,String text) throws Exception {
  _base=base;
  _source=source;
  _text=text;
  if (plot instanceof PlotInterface) {
    PlotMLParser parser=new PlotMLParser((PlotInterface)plot);
    if ((source != null) && !source.trim().equals(""String_Node_Str"")) {
      URL xmlFile=new URL(base,source);
      InputStream stream=xmlFile.openStream();
      parser.parse(base,stream);
      stream.close();
      _configureSource=source;
    }
    if (text != null) {
      String trimmed=text.trim();
      if ((trimmed != null) && !trimmed.equals(""String_Node_Str"")) {
        if (trimmed.startsWith(""String_Node_Str"") && trimmed.endsWith(""String_Node_Str"")) {
          trimmed=trimmed.substring(2,trimmed.length() - 2).trim();
          if (trimmed.startsWith(""String_Node_Str"")) {
            trimmed=trimmed.substring(6).trim();
            parser.parse(base,trimmed);
          }
        }
 else {
          parser.parse(base,trimmed);
        }
      }
    }
  }
 else {
    if (_configureBases == null) {
      _configureBases=new LinkedList<URL>();
      _configureSources=new LinkedList<String>();
      _configureTexts=new LinkedList<String>();
    }
    _configureBases.add(base);
    _configureSources.add(source);
    _configureTexts.add(text);
  }
}"
73187,"/** 
 * If configurations have been deferred, implement them now. Also, configure the plot legends, if appropriate.
 */
protected void _implementDeferredConfigurations(){
  if (_configureSources != null) {
    Iterator<String> sources=_configureSources.iterator();
    Iterator<String> texts=_configureTexts.iterator();
    Iterator<URL> bases=_configureBases.iterator();
    while (sources.hasNext()) {
      URL base=bases.next();
      String source=sources.next();
      String text=texts.next();
      try {
        configure(base,source,text);
      }
 catch (      Exception ex) {
        getManager().notifyListenersOfException(ex);
      }
    }
    _configureSources=null;
    _configureTexts=null;
    _configureBases=null;
  }
  try {
    attributeChanged(legend);
  }
 catch (  IllegalActionException ex) {
  }
}","/** 
 * If configurations have been deferred, implement them now. Also, configure the plot legends, if appropriate.
 */
protected void _implementDeferredConfigurations(){
  if (_configureSources != null) {
    Iterator<String> sources=_configureSources.iterator();
    Iterator<String> texts=_configureTexts.iterator();
    Iterator<URL> bases=_configureBases.iterator();
    while (sources.hasNext()) {
      URL base=bases.next();
      String source=sources.next();
      String text=texts.next();
      try {
        configure(base,source,text);
      }
 catch (      Exception ex) {
        System.out.println(""String_Node_Str"" + base + ""String_Node_Str""+ source+ ""String_Node_Str""+ text+ ""String_Node_Str"");
        getManager().notifyListenersOfException(ex);
      }
    }
    _configureSources=null;
    _configureTexts=null;
    _configureBases=null;
  }
  try {
    attributeChanged(legend);
  }
 catch (  IllegalActionException ex) {
  }
}"
73188,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class has anattribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  PlotterBase newObject=(PlotterBase)super.clone(workspace);
  newObject.plot=null;
  newObject._implementation=null;
  try {
    newObject._getImplementation().initWindowAndSizeProperties();
    newObject.configure(_base,_source,_text);
  }
 catch (  Exception e) {
    throw new CloneNotSupportedException(""String_Node_Str"" + e);
  }
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class has anattribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  PlotterBase newObject=(PlotterBase)super.clone(workspace);
  newObject._configureBases=null;
  newObject._configureSources=null;
  newObject._configureTexts=null;
  newObject._implementation=null;
  newObject.plot=null;
  try {
    if (_base != null) {
      newObject._base=new URL(_base.toString());
    }
    newObject.configure(newObject._base,_source,_text);
    if (PtolemyInjector.getInjector() == null) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      ActorModuleInitializer.initializeInjector();
    }
    newObject._implementation=PtolemyInjector.getInjector().getInstance(PlotterBaseInterface.class);
    newObject._implementation.init(newObject);
    newObject._implementation.initWindowAndSizeProperties();
  }
 catch (  Exception e) {
    throw new CloneNotSupportedException(""String_Node_Str"" + e);
  }
  return newObject;
}"
73189,"/** 
 * Initialize the class. 
 */
private void _init() throws IllegalActionException, NameDuplicationException {
  setClassName(""String_Node_Str"");
  new IterateDirector(this,uniqueName(""String_Node_Str""));
  _iterationCount=new Variable(this,""String_Node_Str"",new IntToken(0));
  _iterationCount.setTypeEquals(BaseType.INT);
}","/** 
 * Initialize the class. 
 */
private void _init() throws IllegalActionException, NameDuplicationException {
  setClassName(""String_Node_Str"");
  IterateDirector iterateDirector=this.new IterateDirector(workspace());
  iterateDirector.setContainer(this);
  iterateDirector.setName(uniqueName(""String_Node_Str""));
  _iterationCount=new Variable(this,""String_Node_Str"",new IntToken(0));
  _iterationCount.setTypeEquals(BaseType.INT);
}"
73190,"/** 
 * Create a new instance of the director for IterateOverArray.
 * @param container The container for the director.
 * @param name The name of the director.
 * @exception IllegalActionException Not thrown in this base class.
 * @exception NameDuplicationException Not thrown in this base class.
 */
public IterateDirector(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  setPersistent(false);
}","/** 
 * Construct an IterateDirector in the specified workspace with no container and an empty string as a name. You can then change the name with setName(). If the workspace argument is null, then use the default workspace.  You should set the local director or executive director before attempting to send data to the actor or to execute it. Add the actor to the workspace directory. Increment the version number of the workspace.
 * @param workspace The workspace that will list the actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public IterateDirector(Workspace workspace) throws IllegalActionException, NameDuplicationException {
  super(workspace);
  setPersistent(false);
}"
73191,"/** 
 * Clone the object into the specified workspace. This overrides the base class to set the association with iterationCount.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  IterateOverArray result=(IterateOverArray)super.clone(workspace);
  try {
    result.new IterateDirector(result,uniqueName(""String_Node_Str""));
  }
 catch (  Throwable throwable) {
    new CloneNotSupportedException(""String_Node_Str"" + throwable);
  }
  result._iterationCount=(Variable)result.getAttribute(""String_Node_Str"");
  return result;
}","/** 
 * Clone the object into the specified workspace. This overrides the base class to set the association with iterationCount.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  IterateOverArray result=(IterateOverArray)super.clone(workspace);
  try {
    List iterateDirectors=result.attributeList(IterateDirector.class);
    IterateDirector oldIterateDirector=(IterateDirector)iterateDirectors.get(0);
    String iterateDirectorName=oldIterateDirector.getName();
    oldIterateDirector.setContainer(null);
    IterateDirector iterateDirector=result.new IterateDirector(workspace);
    iterateDirector.setContainer(result);
    iterateDirector.setName(iterateDirectorName);
  }
 catch (  Throwable throwable) {
    new CloneNotSupportedException(""String_Node_Str"" + throwable);
  }
  result._iterationCount=(Variable)result.getAttribute(""String_Node_Str"");
  return result;
}"
73192,"/** 
 * Create a new instance of the director for ThreadedComposite.
 * @param container The container for the director.
 * @param name The name of the director.
 * @exception IllegalActionException Not thrown in this base class.
 * @exception NameDuplicationException Not thrown in this base class.
 */
public ThreadedDirector(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  setPersistent(false);
}","/** 
 * Construct a new instance of the director for ThreadedComposite. The director is created in the specified workspace with no container and an empty string as a name. You can then change the name with setName(). If the workspace argument is null, then use the default workspace.  You should set the local director or executive director before attempting to send data to the actor or to execute it. Add the actor to the workspace directory. Increment the version number of the workspace.
 * @param workspace The workspace that will list the actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public ThreadedDirector(Workspace workspace) throws IllegalActionException, NameDuplicationException {
  super(workspace);
  setPersistent(false);
}"
73193,"/** 
 * Create an actor with a name and a container. The container argument must not be null, or a NullPointerException will be thrown.  This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container The container actor.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public ThreadedComposite(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name,false);
  setClassName(""String_Node_Str"");
  new ThreadedDirector(this,""String_Node_Str"");
  Parameter UNDEFINED=new Parameter(this,""String_Node_Str"");
  UNDEFINED.setVisibility(Settable.EXPERT);
  UNDEFINED.setPersistent(false);
  UNDEFINED.setExpression(""String_Node_Str"");
  delay=new Parameter(this,""String_Node_Str"");
  delay.setTypeEquals(BaseType.DOUBLE);
  delay.setExpression(""String_Node_Str"");
  synchronizeToRealTime=new Parameter(this,""String_Node_Str"");
  synchronizeToRealTime.setTypeEquals(BaseType.BOOLEAN);
  synchronizeToRealTime.setExpression(""String_Node_Str"");
}","/** 
 * Create an actor with a name and a container. The container argument must not be null, or a NullPointerException will be thrown.  This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container The container actor.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public ThreadedComposite(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name,false);
  setClassName(""String_Node_Str"");
  ThreadedDirector threadedDirector=this.new ThreadedDirector(workspace());
  threadedDirector.setContainer(this);
  threadedDirector.setName(uniqueName(""String_Node_Str""));
  Parameter UNDEFINED=new Parameter(this,""String_Node_Str"");
  UNDEFINED.setVisibility(Settable.EXPERT);
  UNDEFINED.setPersistent(false);
  UNDEFINED.setExpression(""String_Node_Str"");
  delay=new Parameter(this,""String_Node_Str"");
  delay.setTypeEquals(BaseType.DOUBLE);
  delay.setExpression(""String_Node_Str"");
  synchronizeToRealTime=new Parameter(this,""String_Node_Str"");
  synchronizeToRealTime.setTypeEquals(BaseType.BOOLEAN);
  synchronizeToRealTime.setExpression(""String_Node_Str"");
}"
73194,"/** 
 * Check the clone(Workspace) method of the IterateOverArray class. Instantiate an IterateOverArray actor and get the Workspace of the inner IterateDirector.  Then clone the actor into a  new Workspace and get the Workspace of the inner IterateDirector of the *clone*.  The Workspaces should be different. <p>To run:</p> <code> java -classpath $PTII ptolemy.actor.lib.hoc.test.IterateOverArrayCloneTest </code>
 * @param args Ignored
 * @exception Throwable If there is a problem with the test.
 */
public static void main(String args[]) throws Throwable {
  Workspace workspace=new Workspace(""String_Node_Str"");
  TypedCompositeActor container=new TypedCompositeActor(workspace);
  IterateOverArray iterateOverArray=new IterateOverArray(container,""String_Node_Str"");
  Class iterateDirectorClass=Class.forName(""String_Node_Str"");
  List iterateDirectors=iterateOverArray.attributeList(iterateDirectorClass);
  Object iterateDirector=iterateDirectors.get(0);
  Field thisZeroField=iterateDirectorClass.getDeclaredField(""String_Node_Str"");
  thisZeroField.setAccessible(true);
  IterateOverArray outerIterateOverArray=(IterateOverArray)thisZeroField.get(iterateDirectorClass.cast(iterateDirector));
  Workspace outerIterateOverArrayWorkspace=outerIterateOverArray.workspace();
  System.out.println(""String_Node_Str"" + outerIterateOverArrayWorkspace.getName());
  Workspace cloneWorkspace=new Workspace(""String_Node_Str"");
  IterateOverArray clonedIterateOverArray=(IterateOverArray)iterateOverArray.clone(cloneWorkspace);
  List clonedIterateDirectors=clonedIterateOverArray.attributeList(iterateDirectorClass);
  Object clonedIterateDirector=clonedIterateDirectors.get(0);
  IterateOverArray clonedOuterIterateOverArray=(IterateOverArray)thisZeroField.get(iterateDirectorClass.cast(clonedIterateDirector));
  Workspace clonedOuterIterateOverArrayWorkspace=clonedOuterIterateOverArray.workspace();
  System.out.println(""String_Node_Str"" + clonedOuterIterateOverArrayWorkspace.getName());
  if (outerIterateOverArrayWorkspace.equals(clonedOuterIterateOverArrayWorkspace)) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
 else {
    System.err.println(""String_Node_Str"");
  }
}","/** 
 * Check the clone(Workspace) method of the IterateOverArray class. Instantiate an IterateOverArray actor and get the Workspace of the inner IterateDirector.  Then clone the actor into a  new Workspace and get the Workspace of the inner IterateDirector of the *clone*.  The Workspaces should be different. <p>To run:</p> <code> java -classpath $PTII ptolemy.actor.lib.hoc.test.IterateOverArrayCloneTest </code>
 * @param args Ignored
 * @exception Throwable If there is a problem with the test.
 */
public static void main(String args[]) throws Throwable {
  Workspace workspace=new Workspace(""String_Node_Str"");
  TypedCompositeActor container=new TypedCompositeActor(workspace);
  IterateOverArray iterateOverArray=new IterateOverArray(container,""String_Node_Str"");
  Class iterateDirectorClass=Class.forName(""String_Node_Str"");
  List iterateDirectors=iterateOverArray.attributeList(iterateDirectorClass);
  Object iterateDirector=iterateDirectors.get(0);
  Field thisZeroField=iterateDirectorClass.getDeclaredField(""String_Node_Str"");
  thisZeroField.setAccessible(true);
  IterateOverArray outerIterateOverArray=(IterateOverArray)thisZeroField.get(iterateDirectorClass.cast(iterateDirector));
  Workspace outerIterateOverArrayWorkspace=outerIterateOverArray.workspace();
  System.out.println(""String_Node_Str"" + outerIterateOverArrayWorkspace.getName());
  Workspace cloneWorkspace=new Workspace(""String_Node_Str"");
  IterateOverArray clonedIterateOverArray=(IterateOverArray)iterateOverArray.clone(cloneWorkspace);
  List clonedIterateDirectors=clonedIterateOverArray.attributeList(iterateDirectorClass);
  Object clonedIterateDirector=clonedIterateDirectors.get(0);
  IterateOverArray clonedOuterIterateOverArray=(IterateOverArray)thisZeroField.get(iterateDirectorClass.cast(clonedIterateDirector));
  Workspace clonedOuterIterateOverArrayWorkspace=clonedOuterIterateOverArray.workspace();
  System.out.println(""String_Node_Str"" + clonedOuterIterateOverArrayWorkspace.getName());
  if (outerIterateOverArray.equals(clonedOuterIterateOverArray)) {
    System.err.println(""String_Node_Str"");
  }
 else {
    System.err.println(""String_Node_Str"");
  }
  if (outerIterateOverArrayWorkspace.equals(clonedOuterIterateOverArrayWorkspace)) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
 else {
    System.err.println(""String_Node_Str"");
  }
}"
73195,"/** 
 * Clone this actor into the specified workspace. The new actor is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new actor with the same ports as the original, but no connections and no container.  A container must be set before much can be done with this actor.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return A new ComponentEntity.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  AtomicActor newObject=(AtomicActor)super.clone(workspace);
  newObject._inputPortsVersion=-1;
  newObject._outputPortsVersion=-1;
  newObject._causalityInterface=null;
  newObject._causalityInterfaceDirector=null;
  newObject._receiversVersion=-1L;
  return newObject;
}","/** 
 * Clone this actor into the specified workspace. The new actor is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new actor with the same ports as the original, but no connections and no container.  A container must be set before much can be done with this actor.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return A new ComponentEntity.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  AtomicActor newObject=(AtomicActor)super.clone(workspace);
  newObject._initializables=null;
  newObject._inputPortsVersion=-1;
  newObject._outputPortsVersion=-1;
  newObject._cachedInputPorts=null;
  newObject._cachedOutputPorts=null;
  newObject._causalityInterface=null;
  newObject._causalityInterfaceDirector=null;
  newObject._receiversVersion=-1L;
  return newObject;
}"
73196,"/** 
 * Clone the object into the specified workspace. This overrides the base class to set the association with iterationCount.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  IterateOverArray result=(IterateOverArray)super.clone(workspace);
  try {
    List iterateDirectors=result.attributeList(IterateDirector.class);
    IterateDirector oldIterateDirector=(IterateDirector)iterateDirectors.get(0);
    String iterateDirectorName=oldIterateDirector.getName();
    oldIterateDirector.setContainer(null);
    IterateDirector iterateDirector=result.new IterateDirector(workspace);
    iterateDirector.setContainer(result);
    iterateDirector.setName(iterateDirectorName);
  }
 catch (  Throwable throwable) {
    new CloneNotSupportedException(""String_Node_Str"" + throwable);
  }
  result._iterationCount=(Variable)result.getAttribute(""String_Node_Str"");
  return result;
}","/** 
 * Clone the object into the specified workspace. This overrides the base class to instantiate a new IterateDirector and to set the association with iterationCount.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  IterateOverArray result=(IterateOverArray)super.clone(workspace);
  try {
    String iterateDirectorName=null;
    Iterator iterateDirectors=result.attributeList(IterateDirector.class).iterator();
    while (iterateDirectors.hasNext()) {
      IterateDirector oldIterateDirector=(IterateDirector)iterateDirectors.next();
      if (iterateDirectorName == null) {
        iterateDirectorName=oldIterateDirector.getName();
      }
      oldIterateDirector.setContainer(null);
    }
    IterateDirector iterateDirector=result.new IterateDirector(workspace);
    iterateDirector.setContainer(result);
    iterateDirector.setName(iterateDirectorName);
  }
 catch (  Throwable throwable) {
    new CloneNotSupportedException(""String_Node_Str"" + throwable);
  }
  result._iterationCount=(Variable)result.getAttribute(""String_Node_Str"");
  return result;
}"
73197,"/** 
 * Create a new instance of the director for RealTimeComposite.
 * @param container The container for the director.
 * @param name The name of the director.
 * @exception IllegalActionException Not thrown in this base class.
 * @exception NameDuplicationException Not thrown in this base class.
 */
public RealTimeDirector(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  setPersistent(false);
}","/** 
 * Construct a RealTimeDirector in the specified workspace with no container and an empty string as a name. You can then change the name with setName(). If the workspace argument is null, then use the default workspace.  You should set the local director or executive director before attempting to send data to the actor or to execute it. Add the actor to the workspace directory. Increment the version number of the workspace.
 * @param workspace The workspace that will list the actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public RealTimeDirector(Workspace workspace) throws IllegalActionException, NameDuplicationException {
  super(workspace);
  setPersistent(false);
}"
73198,"public MergeDirector(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
}","/** 
 * Construct an MergeDirector in the specified workspace with no container and an empty string as a name. You can then change the name with setName(). If the workspace argument is null, then use the default workspace.  You should set the local director or executive director before attempting to send data to the actor or to execute it. Add the actor to the workspace directory. Increment the version number of the workspace.
 * @param workspace The workspace that will list the actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public MergeDirector(Workspace workspace) throws IllegalActionException, NameDuplicationException {
  super(workspace);
  setPersistent(false);
}"
73199,"/** 
 * Construct a NondeterministicMerge. 
 */
private void _constructor() throws NameDuplicationException, IllegalActionException {
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  input.setMultiport(true);
  output.setTypeAtLeast(input);
  channel=new TypedIOPort(this,""String_Node_Str"");
  channel.setOutput(true);
  channel.setTypeEquals(BaseType.INT);
  StringAttribute channelCardinal=new StringAttribute(channel,""String_Node_Str"");
  channelCardinal.setExpression(""String_Node_Str"");
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  new MergeDirector(this,""String_Node_Str"");
}","/** 
 * Construct a NondeterministicMerge. 
 */
private void _constructor() throws NameDuplicationException, IllegalActionException {
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  input.setMultiport(true);
  output.setTypeAtLeast(input);
  channel=new TypedIOPort(this,""String_Node_Str"");
  channel.setOutput(true);
  channel.setTypeEquals(BaseType.INT);
  StringAttribute channelCardinal=new StringAttribute(channel,""String_Node_Str"");
  channelCardinal.setExpression(""String_Node_Str"");
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  PNDirector director=new MergeDirector(workspace());
  director.setContainer(this);
  director.setName(""String_Node_Str"");
}"
73200,"/** 
 * Return the least Upper bound of this type with the specified type. The specified type must be a UnionType, otherwise an exception will be thrown.
 * @param type a UnionType.
 * @return a UnionType.
 * @exception IllegalArgumentException If the specified type isnot a UnionType.
 */
protected StructuredType _leastUpperBound(StructuredType type){
  if (!(type instanceof UnionType)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  UnionType unionType=(UnionType)type;
  Set unionSet=new HashSet();
  Set myLabelSet=_fields.keySet();
  Set argLabelSet=unionType._fields.keySet();
  unionSet.addAll(myLabelSet);
  unionSet.addAll(argLabelSet);
  Object[] labelArray=unionSet.toArray();
  int size=labelArray.length;
  String[] labels=new String[size];
  Type[] types=new Type[size];
  for (int i=0; i < size; i++) {
    labels[i]=(String)labelArray[i];
    Type type1=this.get(labels[i]);
    Type type2=unionType.get(labels[i]);
    if (type1 == null) {
      types[i]=type2;
    }
 else     if (type2 == null) {
      types[i]=type1;
    }
 else {
      types[i]=(Type)TypeLattice.lattice().greatestLowerBound(type1,type2);
    }
  }
  return new UnionType(labels,types);
}","/** 
 * Return the least Upper bound of this type with the specified type. The specified type must be a UnionType, otherwise an exception will be thrown.
 * @param type a UnionType.
 * @return a UnionType.
 * @exception IllegalArgumentException If the specified type isnot a UnionType.
 */
protected StructuredType _leastUpperBound(StructuredType type){
  if (!(type instanceof UnionType)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  UnionType unionType=(UnionType)type;
  Set unionSet=new HashSet();
  Set myLabelSet=_fields.keySet();
  Set argLabelSet=unionType._fields.keySet();
  unionSet.addAll(myLabelSet);
  unionSet.addAll(argLabelSet);
  Object[] labelArray=unionSet.toArray();
  int size=labelArray.length;
  String[] labels=new String[size];
  Type[] types=new Type[size];
  for (int i=0; i < size; i++) {
    labels[i]=(String)labelArray[i];
    Type type1=this.get(labels[i]);
    Type type2=unionType.get(labels[i]);
    if (type1 == null) {
      types[i]=type2;
    }
 else     if (type2 == null) {
      types[i]=type1;
    }
 else {
      types[i]=(Type)TypeLattice.lattice().leastUpperBound(type1,type2);
    }
  }
  return new UnionType(labels,types);
}"
73201,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new object.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  GTIngredientsAttribute newObject=(GTIngredientsAttribute)super.clone(workspace);
  newObject._ingredientList=null;
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new object.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  GTIngredientsAttribute newObject=(GTIngredientsAttribute)super.clone(workspace);
  try {
    newObject._parse();
  }
 catch (  MalformedStringException ex) {
    throw new CloneNotSupportedException(""String_Node_Str"" + ex);
  }
  return newObject;
}"
73202,"/** 
 * Clone the object into the specified workspace. This overrides the base class to set the association with iterationCount.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  IterateOverArray result=(IterateOverArray)super.clone(workspace);
  result._iterationCount=(Variable)result.getAttribute(""String_Node_Str"");
  return result;
}","/** 
 * Clone the object into the specified workspace. This overrides the base class to set the association with iterationCount.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  IterateOverArray result=(IterateOverArray)super.clone(workspace);
  try {
    new IterateDirector(result,uniqueName(""String_Node_Str""));
  }
 catch (  Throwable throwable) {
    new CloneNotSupportedException(""String_Node_Str"" + throwable);
  }
  result._iterationCount=(Variable)result.getAttribute(""String_Node_Str"");
  return result;
}"
73203,"/** 
 * Clone the director into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (It must be added by the user if he wants it to be there). The result is a new director with no container, no pending mutations, and no topology listeners. The count of active processes is zero.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If one of the attributescannot be cloned.
 * @return The new PNDirector.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  PNDirector newObject=(PNDirector)super.clone(workspace);
  newObject._readBlockedQueues=new HashMap();
  newObject._receivers=new LinkedList();
  newObject._writeBlockedQueues=new HashMap();
  return newObject;
}","/** 
 * Clone the director into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (It must be added by the user if he wants it to be there). The result is a new director with no container, no pending mutations, and no topology listeners. The count of active processes is zero.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If one of the attributescannot be cloned.
 * @return The new PNDirector.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  PNDirector newObject=(PNDirector)super.clone(workspace);
  newObject._processListeners=new LinkedList();
  newObject._readBlockedQueues=new HashMap();
  newObject._receivers=new LinkedList();
  newObject._writeBlockedQueues=new HashMap();
  return newObject;
}"
73204,"/** 
 * Check the configuration for common style problems.
 * @return HTML describing the problems
 * @exception Exception If there is a problem cloning the configuration.
 */
public String check() throws Exception {
  StringBuffer results=new StringBuffer();
  Configuration cloneConfiguration=(Configuration)clone();
  Iterator containedObjects=containedObjectsIterator();
  while (containedObjects.hasNext()) {
    NamedObj containedObject=(NamedObj)containedObjects.next();
    if (containedObject instanceof TypedAtomicActor || containedObject instanceof Attribute) {
      try {
        results.append(_checkCloneFields(containedObject));
      }
 catch (      Throwable throwable) {
        throw new InternalErrorException(containedObject,null,throwable,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  List entityList=allAtomicEntityList();
  Iterator entities=entityList.iterator();
  while (entities.hasNext()) {
    Object entity=entities.next();
    if (entity instanceof TypedAtomicActor) {
      try {
        results.append(_checkCloneFields((TypedAtomicActor)entity));
      }
 catch (      Throwable throwable) {
        throw new InternalErrorException((TypedAtomicActor)entity,null,throwable,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      TypedAtomicActor actor=(TypedAtomicActor)entity;
      String fullName=actor.getName(this);
      TypedAtomicActor clone=(TypedAtomicActor)cloneConfiguration.getEntity(fullName);
      if (clone == null) {
        results.append(""String_Node_Str"" + fullName + ""String_Node_Str"");
      }
 else {
        Set<Inequality> constraints=actor.typeConstraints();
        Set<Inequality> cloneConstraints=clone.typeConstraints();
        if (constraints.size() != cloneConstraints.size()) {
          results.append(actor.getFullName() + ""String_Node_Str"" + constraints.size()+ ""String_Node_Str""+ ""String_Node_Str""+ cloneConstraints.size()+ ""String_Node_Str""+ ""String_Node_Str"");
          Iterator constraintIterator=constraints.iterator();
          while (constraintIterator.hasNext()) {
            Inequality constraint=(Inequality)constraintIterator.next();
            results.append(constraint.toString() + ""String_Node_Str"");
          }
          results.append(""String_Node_Str"");
          Iterator cloneConstraintIterator=cloneConstraints.iterator();
          while (cloneConstraintIterator.hasNext()) {
            Inequality constraint=(Inequality)cloneConstraintIterator.next();
            results.append(constraint.toString() + ""String_Node_Str"");
          }
        }
        HashSet<String> constraintsDescription=new HashSet<String>();
        try {
          Iterator constraintIterator=constraints.iterator();
          while (constraintIterator.hasNext()) {
            Inequality constraint=(Inequality)constraintIterator.next();
            constraintsDescription.add(constraint.toString());
          }
        }
 catch (        Throwable throwable) {
          throw new IllegalActionException(actor,throwable,""String_Node_Str"");
        }
        Iterator cloneConstraintIterator=cloneConstraints.iterator();
        while (cloneConstraintIterator.hasNext()) {
          Inequality constraint=(Inequality)cloneConstraintIterator.next();
          if (!constraintsDescription.contains(constraint.toString())) {
            results.append(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str""+ constraint.toString()+ ""String_Node_Str"");
          }
        }
        HashSet<String> cloneConstraintsDescription=new HashSet<String>();
        try {
          Iterator constraintIterator=cloneConstraints.iterator();
          while (constraintIterator.hasNext()) {
            Inequality constraint=(Inequality)constraintIterator.next();
            cloneConstraintsDescription.add(constraint.toString());
          }
        }
 catch (        Throwable throwable) {
          throw new IllegalActionException(actor,throwable,""String_Node_Str"");
        }
        Iterator constraintIterator=constraints.iterator();
        while (constraintIterator.hasNext()) {
          Inequality constraint=(Inequality)constraintIterator.next();
          if (!cloneConstraintsDescription.contains(constraint.toString())) {
            results.append(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str""+ constraint.toString()+ ""String_Node_Str"");
          }
        }
        cloneConstraintIterator=cloneConstraints.iterator();
        while (cloneConstraintIterator.hasNext()) {
          Inequality constraint=(Inequality)cloneConstraintIterator.next();
          InequalityTerm greaterTerm=constraint.getGreaterTerm();
          InequalityTerm lesserTerm=constraint.getLesserTerm();
          Object greaterAssociatedObject=greaterTerm.getAssociatedObject();
          Object lesserAssociatedObject=lesserTerm.getAssociatedObject();
          if (greaterAssociatedObject instanceof NamedObj && lesserAssociatedObject instanceof NamedObj) {
            NamedObj greaterNamedObj=(NamedObj)greaterAssociatedObject;
            NamedObj lesserNamedObj=(NamedObj)lesserAssociatedObject;
            if (greaterNamedObj != null && lesserNamedObj != null && (greaterNamedObj.getContainer() != lesserNamedObj.getContainer())) {
              results.append(clone.getFullName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ greaterNamedObj.getFullName()+ ""String_Node_Str""+ greaterNamedObj.getContainer()+ ""String_Node_Str""+ lesserNamedObj.getFullName()+ ""String_Node_Str""+ lesserNamedObj.getContainer()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            }
          }
        }
      }
    }
  }
  return results.toString();
}","/** 
 * Check the configuration for common style problems.
 * @return HTML describing the problems
 * @exception Exception If there is a problem cloning the configuration.
 */
public String check() throws Exception {
  StringBuffer results=new StringBuffer();
  Configuration cloneConfiguration=(Configuration)clone();
  Iterator containedObjects=deepNamedObjList().iterator();
  while (containedObjects.hasNext()) {
    NamedObj containedObject=(NamedObj)containedObjects.next();
    if (containedObject instanceof TypedAtomicActor || containedObject instanceof Attribute) {
      try {
        results.append(checkCloneFields(containedObject));
      }
 catch (      Throwable throwable) {
        throw new InternalErrorException(containedObject,null,throwable,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  containedObjects=deepCompositeEntityList().iterator();
  for (  CompositeEntity composite : deepCompositeEntityList()) {
    Iterator attributes=composite.attributeList().iterator();
    while (attributes.hasNext()) {
      Attribute attribute=(Attribute)attributes.next();
      try {
        results.append(checkCloneFields(attribute));
      }
 catch (      Throwable throwable) {
        throw new InternalErrorException(attribute,null,throwable,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  List entityList=allAtomicEntityList();
  Iterator entities=entityList.iterator();
  while (entities.hasNext()) {
    Object entity=entities.next();
    if (entity instanceof TypedAtomicActor) {
      try {
        results.append(checkCloneFields((TypedAtomicActor)entity));
      }
 catch (      Throwable throwable) {
        throw new InternalErrorException((TypedAtomicActor)entity,null,throwable,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      TypedAtomicActor actor=(TypedAtomicActor)entity;
      String fullName=actor.getName(this);
      TypedAtomicActor clone=(TypedAtomicActor)cloneConfiguration.getEntity(fullName);
      if (clone == null) {
        results.append(""String_Node_Str"" + fullName + ""String_Node_Str"");
      }
 else {
        Set<Inequality> constraints=actor.typeConstraints();
        Set<Inequality> cloneConstraints=clone.typeConstraints();
        if (constraints.size() != cloneConstraints.size()) {
          results.append(actor.getFullName() + ""String_Node_Str"" + constraints.size()+ ""String_Node_Str""+ ""String_Node_Str""+ cloneConstraints.size()+ ""String_Node_Str""+ ""String_Node_Str"");
          Iterator constraintIterator=constraints.iterator();
          while (constraintIterator.hasNext()) {
            Inequality constraint=(Inequality)constraintIterator.next();
            results.append(constraint.toString() + ""String_Node_Str"");
          }
          results.append(""String_Node_Str"");
          Iterator cloneConstraintIterator=cloneConstraints.iterator();
          while (cloneConstraintIterator.hasNext()) {
            Inequality constraint=(Inequality)cloneConstraintIterator.next();
            results.append(constraint.toString() + ""String_Node_Str"");
          }
        }
        HashSet<String> constraintsDescription=new HashSet<String>();
        try {
          Iterator constraintIterator=constraints.iterator();
          while (constraintIterator.hasNext()) {
            Inequality constraint=(Inequality)constraintIterator.next();
            constraintsDescription.add(constraint.toString());
          }
        }
 catch (        Throwable throwable) {
          throw new IllegalActionException(actor,throwable,""String_Node_Str"");
        }
        Iterator cloneConstraintIterator=cloneConstraints.iterator();
        while (cloneConstraintIterator.hasNext()) {
          Inequality constraint=(Inequality)cloneConstraintIterator.next();
          if (!constraintsDescription.contains(constraint.toString())) {
            results.append(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str""+ constraint.toString()+ ""String_Node_Str"");
          }
        }
        HashSet<String> cloneConstraintsDescription=new HashSet<String>();
        try {
          Iterator constraintIterator=cloneConstraints.iterator();
          while (constraintIterator.hasNext()) {
            Inequality constraint=(Inequality)constraintIterator.next();
            cloneConstraintsDescription.add(constraint.toString());
          }
        }
 catch (        Throwable throwable) {
          throw new IllegalActionException(actor,throwable,""String_Node_Str"");
        }
        Iterator constraintIterator=constraints.iterator();
        while (constraintIterator.hasNext()) {
          Inequality constraint=(Inequality)constraintIterator.next();
          if (!cloneConstraintsDescription.contains(constraint.toString())) {
            results.append(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str""+ constraint.toString()+ ""String_Node_Str"");
          }
        }
        cloneConstraintIterator=cloneConstraints.iterator();
        while (cloneConstraintIterator.hasNext()) {
          Inequality constraint=(Inequality)cloneConstraintIterator.next();
          InequalityTerm greaterTerm=constraint.getGreaterTerm();
          InequalityTerm lesserTerm=constraint.getLesserTerm();
          Object greaterAssociatedObject=greaterTerm.getAssociatedObject();
          Object lesserAssociatedObject=lesserTerm.getAssociatedObject();
          if (greaterAssociatedObject instanceof NamedObj && lesserAssociatedObject instanceof NamedObj) {
            NamedObj greaterNamedObj=(NamedObj)greaterAssociatedObject;
            NamedObj lesserNamedObj=(NamedObj)lesserAssociatedObject;
            if (greaterNamedObj != null && lesserNamedObj != null && (greaterNamedObj.getContainer() != lesserNamedObj.getContainer())) {
              results.append(clone.getFullName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ greaterNamedObj.getFullName()+ ""String_Node_Str""+ greaterNamedObj.getContainer()+ ""String_Node_Str""+ lesserNamedObj.getFullName()+ ""String_Node_Str""+ lesserNamedObj.getContainer()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            }
          }
        }
      }
    }
  }
  return results.toString();
}"
73205,"private static String printMemory(Pointer pointer,int size){
  final int BYTES_PER_ROW=4;
  String LS=System.getProperty(""String_Node_Str"");
  byte[] buf=pointer.getByteArray(0,size);
  StringBuffer contents=new StringBuffer(LS);
  for (int i=0; i < buf.length; i++) {
    if ((i % BYTES_PER_ROW) == 0) {
      contents.append(""String_Node_Str"");
    }
    if (buf[i] >= 0 && buf[i] < 16) {
      contents.append(""String_Node_Str"");
    }
    contents.append(Integer.toHexString(buf[i] & 0xFF));
    if ((i % BYTES_PER_ROW) == BYTES_PER_ROW - 1 && i < buf.length - 1) {
      contents.append(""String_Node_Str"" + LS);
    }
  }
  contents.append(""String_Node_Str"");
  for (int i=0; i < buf.length; i++) {
    if ((i % BYTES_PER_ROW) == 0) {
      contents.append(""String_Node_Str"");
    }
    contents.append(new Character((char)(buf[i] & 0xff)));
    if ((i % BYTES_PER_ROW) == BYTES_PER_ROW - 1 && i < buf.length - 1) {
      contents.append(""String_Node_Str"" + LS);
    }
  }
  contents.append(""String_Node_Str"");
  return contents.toString();
}","private static String printMemory(Pointer pointer,int size){
  final int BYTES_PER_ROW=4;
  String LS=System.getProperty(""String_Node_Str"");
  byte[] buf=pointer.getByteArray(0,size);
  StringBuffer contents=new StringBuffer(LS);
  for (int i=0; i < buf.length; i++) {
    if ((i % BYTES_PER_ROW) == 0) {
      contents.append(""String_Node_Str"");
    }
    if (buf[i] >= 0 && buf[i] < 16) {
      contents.append(""String_Node_Str"");
    }
    contents.append(Integer.toHexString(buf[i] & 0xFF));
    if ((i % BYTES_PER_ROW) == BYTES_PER_ROW - 1 && i < buf.length - 1) {
      contents.append(""String_Node_Str"" + LS);
    }
  }
  contents.append(""String_Node_Str"");
  for (int i=0; i < buf.length; i++) {
    if ((i % BYTES_PER_ROW) == 0) {
      contents.append(""String_Node_Str"");
    }
    contents.append(Character.valueOf((char)(buf[i] & 0xff)));
    if ((i % BYTES_PER_ROW) == BYTES_PER_ROW - 1 && i < buf.length - 1) {
      contents.append(""String_Node_Str"" + LS);
    }
  }
  contents.append(""String_Node_Str"");
  return contents.toString();
}"
73206,"/** 
 * Add a new entry to this query that represents the given attribute. The name of the entry will be set to the name of the attribute, and the attribute will be attached to the entry, so that if the attribute is updated, then the entry is updated. If the attribute contains an instance of ParameterEditorStyle, then defer to the style to create the entry, otherwise just create a default entry. The style used in a default entry depends on the class of the attribute and on its declared type, but defaults to a one-line entry if there is no obviously better style. Only the first style that is found is used to create an entry.
 * @param attribute The attribute to create an entry for.
 */
public void addStyledEntry(Settable attribute){
  boolean foundStyle=false;
  try {
    _addingStyledEntryFor=attribute;
    if (attribute instanceof NamedObj) {
      Iterator<?> styles=((NamedObj)attribute).attributeList(ParameterEditorStyle.class).iterator();
      while (styles.hasNext() && !foundStyle) {
        ParameterEditorStyle style=(ParameterEditorStyle)styles.next();
        try {
          style.addEntry(this);
          foundStyle=true;
        }
 catch (        IllegalActionException ex) {
        }
      }
    }
    if (!foundStyle) {
      String name=attribute.getName();
      String displayName=attribute.getDisplayName();
      try {
        JComponent component=null;
        if (attribute instanceof IntRangeParameter) {
          int current=((IntRangeParameter)attribute).getCurrentValue();
          int min=((IntRangeParameter)attribute).getMinValue();
          int max=((IntRangeParameter)attribute).getMaxValue();
          component=addSlider(name,displayName,current,min,max);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof DoubleRangeParameter) {
          double current=((DoubleToken)((DoubleRangeParameter)attribute).getToken()).doubleValue();
          double max=((DoubleToken)((DoubleRangeParameter)attribute).max.getToken()).doubleValue();
          double min=((DoubleToken)((DoubleRangeParameter)attribute).min.getToken()).doubleValue();
          int precision=((IntToken)((DoubleRangeParameter)attribute).precision.getToken()).intValue();
          int quantized=((int)Math.round(((current - min) * precision) / (max - min)));
          component=addSlider(name,displayName,quantized,0,precision);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof ColorAttribute) {
          component=addColorChooser(name,displayName,attribute.getExpression());
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof CustomQueryBoxParameter) {
          JLabel label=new JLabel(displayName + ""String_Node_Str"");
          label.setBackground(_background);
          component=((CustomQueryBoxParameter)attribute).createQueryBox(this,attribute);
          _addPair(name,label,component,component);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof FileParameter || attribute instanceof FilePortParameter) {
          URI modelURI=URIAttribute.getModelURI((NamedObj)attribute);
          File directory=null;
          if (modelURI != null) {
            if (modelURI.getScheme().equals(""String_Node_Str"")) {
              File modelFile=new File(modelURI);
              directory=modelFile.getParentFile();
            }
          }
          URI base=null;
          if (directory != null) {
            base=directory.toURI();
          }
          boolean allowFiles=true;
          boolean allowDirectories=false;
          Parameter marker=(Parameter)((NamedObj)attribute).getAttribute(""String_Node_Str"",Parameter.class);
          if (marker != null) {
            Token value=marker.getToken();
            if (value instanceof BooleanToken) {
              allowFiles=((BooleanToken)value).booleanValue();
            }
          }
          marker=(Parameter)((NamedObj)attribute).getAttribute(""String_Node_Str"",Parameter.class);
          if (marker != null) {
            Token value=marker.getToken();
            if (value instanceof BooleanToken) {
              allowDirectories=((BooleanToken)value).booleanValue();
            }
          }
          if (!allowFiles && !allowDirectories) {
            return;
          }
          boolean isOutput=false;
          if (attribute instanceof FileParameter && ((FileParameter)attribute).isOutput()) {
            isOutput=true;
          }
          component=addFileChooser(name,displayName,attribute.getExpression(),base,directory,allowFiles,allowDirectories,isOutput,preferredBackgroundColor(attribute),preferredForegroundColor(attribute));
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof PasswordAttribute) {
          component=addPassword(name,displayName,""String_Node_Str"");
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof Parameter && (((Parameter)attribute).getChoices() != null)) {
          Parameter castAttribute=(Parameter)attribute;
          component=addChoice(name,displayName,castAttribute.getChoices(),castAttribute.getExpression(),true,preferredBackgroundColor(attribute),preferredForegroundColor(attribute));
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if ((attribute instanceof NamedObj) && ((((NamedObj)attribute).getAttribute(""String_Node_Str"") != null) || ((NamedObj)attribute).getAttribute(""String_Node_Str"") != null)) {
          int widthValue=30;
          int heightValue=10;
          Attribute widthAttribute=((NamedObj)attribute).getAttribute(""String_Node_Str"");
          if (widthAttribute instanceof Variable) {
            Token token=((Variable)widthAttribute).getToken();
            if (token instanceof IntToken) {
              widthValue=((IntToken)token).intValue();
            }
          }
          Attribute heightAttribute=((NamedObj)attribute).getAttribute(""String_Node_Str"");
          if (heightAttribute instanceof Variable) {
            Token token=((Variable)heightAttribute).getToken();
            if (token instanceof IntToken) {
              heightValue=((IntToken)token).intValue();
            }
          }
          component=addTextArea(name,displayName,attribute.getExpression(),preferredBackgroundColor(attribute),preferredForegroundColor(attribute),heightValue,widthValue);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof Variable) {
          Type declaredType=((Variable)attribute).getDeclaredType();
          Token current=((Variable)attribute).getToken();
          if (declaredType == BaseType.BOOLEAN) {
            if (attribute.getExpression().equals(""String_Node_Str"") || attribute.getExpression().equals(""String_Node_Str"")) {
              component=addCheckBox(name,displayName,((BooleanToken)current).booleanValue());
              attachParameter(attribute,name);
              foundStyle=true;
            }
          }
        }
        if (attribute.getVisibility() == Settable.NOT_EDITABLE) {
          if (component == null) {
            String defaultValue=attribute.getExpression();
            component=addDisplay(name,displayName,defaultValue);
            attachParameter(attribute,name);
            foundStyle=true;
          }
 else           if (component instanceof JTextComponent) {
            component.setBackground(_background);
            ((JTextComponent)component).setEditable(false);
          }
 else {
            component.setEnabled(false);
          }
        }
      }
 catch (      IllegalActionException ex) {
      }
    }
    String defaultValue=attribute.getExpression();
    if (defaultValue == null) {
      defaultValue=""String_Node_Str"";
    }
    if (!(foundStyle)) {
      JTextArea area=addTextArea(attribute.getName(),attribute.getDisplayName(),defaultValue,preferredBackgroundColor(attribute),preferredForegroundColor(attribute),1,DEFAULT_ENTRY_WIDTH);
      area.setRows(Math.min(5,area.getLineCount()));
      attachParameter(attribute,attribute.getName());
    }
  }
  finally {
    _addingStyledEntryFor=null;
  }
}","/** 
 * Add a new entry to this query that represents the given attribute. The name of the entry will be set to the name of the attribute, and the attribute will be attached to the entry, so that if the attribute is updated, then the entry is updated. If the attribute contains an instance of ParameterEditorStyle, then defer to the style to create the entry, otherwise just create a default entry. The style used in a default entry depends on the class of the attribute and on its declared type, but defaults to a one-line entry if there is no obviously better style. Only the first style that is found is used to create an entry.
 * @param attribute The attribute to create an entry for.
 */
public void addStyledEntry(Settable attribute){
  boolean foundStyle=false;
  try {
    _addingStyledEntryFor=attribute;
    if (attribute instanceof NamedObj) {
      Iterator<?> styles=((NamedObj)attribute).attributeList(ParameterEditorStyle.class).iterator();
      while (styles.hasNext() && !foundStyle) {
        ParameterEditorStyle style=(ParameterEditorStyle)styles.next();
        try {
          style.addEntry(this);
          foundStyle=true;
        }
 catch (        IllegalActionException ex) {
        }
      }
    }
    if (!foundStyle) {
      String name=attribute.getName();
      String displayName=attribute.getDisplayName();
      try {
        JComponent component=null;
        if (attribute instanceof IntRangeParameter) {
          int current=((IntRangeParameter)attribute).getCurrentValue();
          int min=((IntRangeParameter)attribute).getMinValue();
          int max=((IntRangeParameter)attribute).getMaxValue();
          component=addSlider(name,displayName,current,min,max);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof DoubleRangeParameter) {
          double current=((DoubleToken)((DoubleRangeParameter)attribute).getToken()).doubleValue();
          double max=((DoubleToken)((DoubleRangeParameter)attribute).max.getToken()).doubleValue();
          double min=((DoubleToken)((DoubleRangeParameter)attribute).min.getToken()).doubleValue();
          int precision=((IntToken)((DoubleRangeParameter)attribute).precision.getToken()).intValue();
          int quantized=((int)Math.round(((current - min) * precision) / (max - min)));
          component=addSlider(name,displayName,quantized,0,precision);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof ColorAttribute) {
          component=addColorChooser(name,displayName,attribute.getExpression());
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof CustomQueryBoxParameter) {
          JLabel label=new JLabel(displayName + ""String_Node_Str"");
          label.setBackground(_background);
          component=((CustomQueryBoxParameter)attribute).createQueryBox(this,attribute);
          _addPair(name,label,component,component);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof FileParameter || attribute instanceof FilePortParameter) {
          URI modelURI=URIAttribute.getModelURI((NamedObj)attribute);
          File directory=null;
          if (modelURI != null) {
            if (modelURI.getScheme().equals(""String_Node_Str"")) {
              File modelFile=new File(modelURI);
              directory=modelFile.getParentFile();
            }
          }
          URI base=null;
          if (directory != null) {
            base=directory.toURI();
          }
          boolean allowFiles=true;
          boolean allowDirectories=false;
          Parameter marker=(Parameter)((NamedObj)attribute).getAttribute(""String_Node_Str"",Parameter.class);
          if (marker != null) {
            Token value=marker.getToken();
            if (value instanceof BooleanToken) {
              allowFiles=((BooleanToken)value).booleanValue();
            }
          }
          marker=(Parameter)((NamedObj)attribute).getAttribute(""String_Node_Str"",Parameter.class);
          if (marker != null) {
            Token value=marker.getToken();
            if (value instanceof BooleanToken) {
              allowDirectories=((BooleanToken)value).booleanValue();
            }
          }
          if (!allowFiles && !allowDirectories) {
            return;
          }
          boolean isOutput=false;
          if (attribute instanceof FileParameter && ((FileParameter)attribute).isOutput()) {
            isOutput=true;
          }
          component=addFileChooser(name,displayName,attribute.getExpression(),base,directory,allowFiles,allowDirectories,isOutput,preferredBackgroundColor(attribute),preferredForegroundColor(attribute));
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof PasswordAttribute) {
          component=addPassword(name,displayName,""String_Node_Str"");
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof Parameter && (((Parameter)attribute).getChoices() != null)) {
          Parameter castAttribute=(Parameter)attribute;
          component=addChoice(name,displayName,castAttribute.getChoices(),castAttribute.getExpression(),true,preferredBackgroundColor(attribute),preferredForegroundColor(attribute));
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if ((attribute instanceof NamedObj) && ((((NamedObj)attribute).getAttribute(""String_Node_Str"") != null) || ((NamedObj)attribute).getAttribute(""String_Node_Str"") != null)) {
          int widthValue=30;
          int heightValue=10;
          Attribute widthAttribute=((NamedObj)attribute).getAttribute(""String_Node_Str"");
          if (widthAttribute instanceof Variable) {
            Token token=((Variable)widthAttribute).getToken();
            if (token instanceof IntToken) {
              widthValue=((IntToken)token).intValue();
            }
          }
          Attribute heightAttribute=((NamedObj)attribute).getAttribute(""String_Node_Str"");
          if (heightAttribute instanceof Variable) {
            Token token=((Variable)heightAttribute).getToken();
            if (token instanceof IntToken) {
              heightValue=((IntToken)token).intValue();
            }
          }
          component=addTextArea(name,displayName,attribute.getExpression(),preferredBackgroundColor(attribute),preferredForegroundColor(attribute),heightValue,widthValue);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof Variable) {
          Type declaredType=((Variable)attribute).getDeclaredType();
          Token current=((Variable)attribute).getToken();
          if (declaredType == BaseType.BOOLEAN) {
            if (attribute.getExpression().equals(""String_Node_Str"") || attribute.getExpression().equals(""String_Node_Str"")) {
              component=addCheckBox(name,displayName,((BooleanToken)current).booleanValue());
              attachParameter(attribute,name);
              foundStyle=true;
            }
          }
        }
        if (attribute.getVisibility() == Settable.NOT_EDITABLE) {
          if (component == null) {
            String defaultValue=attribute.getExpression();
            component=addDisplay(name,displayName,defaultValue);
            attachParameter(attribute,name);
            foundStyle=true;
          }
 else           if (component instanceof JTextComponent) {
            component.setBackground(_background);
            ((JTextComponent)component).setEditable(false);
          }
 else {
            component.setEnabled(false);
          }
        }
      }
 catch (      IllegalActionException ex) {
      }
    }
    String defaultValue=attribute.getExpression();
    if (defaultValue == null) {
      defaultValue=""String_Node_Str"";
    }
    if (!(foundStyle)) {
      final JTextArea area=addTextArea(attribute.getName(),attribute.getDisplayName(),defaultValue,preferredBackgroundColor(attribute),preferredForegroundColor(attribute),1,DEFAULT_ENTRY_WIDTH);
      area.setRows(Math.min(5,area.getLineCount()));
      area.addKeyListener(new KeyAdapter(){
        public void keyPressed(        KeyEvent e){
          int code=e.getKeyCode();
          if (code == KeyEvent.VK_TAB) {
            area.getRootPane().transferFocusDownCycle();
            e.consume();
          }
 else           if (code == KeyEvent.VK_ENTER && !e.isShiftDown()) {
            e.consume();
          }
 else           if (code == KeyEvent.VK_ENTER && e.isShiftDown()) {
            area.append(""String_Node_Str"");
            e.consume();
          }
        }
      }
);
      attachParameter(attribute,attribute.getName());
    }
  }
  finally {
    _addingStyledEntryFor=null;
  }
}"
73207,"/** 
 * Import a FMUFile.
 * @param originator The originator of the change request.
 * @param fmuFileName The .fmuFile
 * @param context The context in which the FMU actor is created.
 * @param x The x-axis value of the actor to be created.
 * @param y The y-axis value of the actor to be created.
 * @exception IllegalActionException If there is a problem instantiating the actor.
 * @exception IOException If there is a problem parsing the fmu file.
 */
public static void importFMU(Object originator,String fmuFileName,NamedObj context,double x,double y) throws IllegalActionException, IOException {
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  String source=""String_Node_Str"";
  if (fmuFileName.startsWith(""String_Node_Str"")) {
    source=""String_Node_Str"" + fmuFileName.trim() + ""String_Node_Str"";
  }
  String rootName=new File(fmuFileName).getName();
  int index=rootName.lastIndexOf('.');
  if (index != -1) {
    rootName=rootName.substring(0,index);
  }
  int maximumNumberOfPortsToDisplay=20;
  int modelVariablesLength=fmiModelDescription.modelVariables.size();
  String hide=""String_Node_Str"";
  if (modelVariablesLength > maximumNumberOfPortsToDisplay) {
    MessageHandler.message(""String_Node_Str"" + fmuFileName + ""String_Node_Str""+ modelVariablesLength+ ""String_Node_Str""+ ""String_Node_Str"");
    hide=""String_Node_Str"" + ""String_Node_Str"";
  }
  int portCount=0;
  StringBuffer parameterMoML=new StringBuffer();
  StringBuffer portMoML=new StringBuffer();
  for (  FMIScalarVariable scalar : fmiModelDescription.modelVariables) {
    if (scalar.variability == FMIScalarVariable.Variability.parameter) {
      parameterMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ scalar.type+ ""String_Node_Str"");
    }
 else {
      String causality=""String_Node_Str"";
switch (scalar.causality) {
case internal:
        System.out.println(""String_Node_Str"" + fmuFileName + ""String_Node_Str""+ scalar.causality+ ""String_Node_Str""+ scalar.name);
      continue;
case input:
    causality=""String_Node_Str"";
  break;
case output:
case none:
causality=""String_Node_Str"";
break;
}
portMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ ""String_Node_Str""+ causality+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _fmiType2PtolemyType(scalar.type)+ ""String_Node_Str""+ (portCount++ > maximumNumberOfPortsToDisplay ? hide : ""String_Node_Str"")+ ""String_Node_Str"");
}
}
String moml=""String_Node_Str"" + ""String_Node_Str"" + rootName + ""String_Node_Str""+ source+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fmuFileName+ ""String_Node_Str""+ parameterMoML+ portMoML+ ""String_Node_Str"";
MoMLChangeRequest request=new MoMLChangeRequest(originator,context,moml);
context.requestChange(request);
}","/** 
 * Import a FMUFile.
 * @param originator The originator of the change request.
 * @param fmuFileName The .fmuFile
 * @param context The context in which the FMU actor is created.
 * @param x The x-axis value of the actor to be created.
 * @param y The y-axis value of the actor to be created.
 * @exception IllegalActionException If there is a problem instantiating the actor.
 * @exception IOException If there is a problem parsing the fmu file.
 */
public static void importFMU(Object originator,String fmuFileName,NamedObj context,double x,double y) throws IllegalActionException, IOException {
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  String source=""String_Node_Str"";
  if (fmuFileName.startsWith(""String_Node_Str"")) {
    source=""String_Node_Str"" + fmuFileName.trim() + ""String_Node_Str"";
  }
  String rootName=new File(fmuFileName).getName();
  int index=rootName.lastIndexOf('.');
  if (index != -1) {
    rootName=rootName.substring(0,index);
  }
  int maximumNumberOfPortsToDisplay=20;
  int modelVariablesLength=fmiModelDescription.modelVariables.size();
  String hide=""String_Node_Str"";
  if (modelVariablesLength > maximumNumberOfPortsToDisplay) {
    MessageHandler.message(""String_Node_Str"" + fmuFileName + ""String_Node_Str""+ modelVariablesLength+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  int portCount=0;
  StringBuffer parameterMoML=new StringBuffer();
  StringBuffer portMoML=new StringBuffer();
  for (  FMIScalarVariable scalar : fmiModelDescription.modelVariables) {
    if (scalar.variability == FMIScalarVariable.Variability.parameter) {
      parameterMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ scalar.type+ ""String_Node_Str"");
    }
 else {
      String internalHide=""String_Node_Str"";
      String causality=""String_Node_Str"";
switch (scalar.causality) {
case input:
        causality=""String_Node_Str"";
      break;
case none:
    continue;
case output:
case internal:
  causality=""String_Node_Str"";
break;
}
portMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ ""String_Node_Str""+ causality+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _fmiType2PtolemyType(scalar.type)+ ""String_Node_Str""+ (portCount++ > maximumNumberOfPortsToDisplay || scalar.causality == Causality.internal ? hide : ""String_Node_Str"")+ ""String_Node_Str"");
}
}
String moml=""String_Node_Str"" + ""String_Node_Str"" + rootName + ""String_Node_Str""+ source+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fmuFileName+ ""String_Node_Str""+ ""String_Node_Str""+ parameterMoML+ portMoML+ ""String_Node_Str"";
MoMLChangeRequest request=new MoMLChangeRequest(originator,context,moml);
context.requestChange(request);
}"
73208,"/** 
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  double time=getDirector().getModelTime().getDoubleValue();
  double stepSize=((ptolemy.domains.sdf.kernel.SDFDirector)getDirector()).periodValue();
  if (_debugging) {
    _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str"");
  }
  int fmiFlag=((Integer)_fmiDoStep.invokeInt(new Object[]{_fmiComponent,time,stepSize,(byte)1})).intValue();
  if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
    throw new IllegalActionException(this,""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str""+ fmiFlag);
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
  }
  for (  FMIScalarVariable scalarVariable : _fmiModelDescription.modelVariables) {
    if (_debugging) {
      _debug(""String_Node_Str"" + scalarVariable.name);
    }
    if (scalarVariable.alias != null && scalarVariable.alias != Alias.noAlias) {
      continue;
    }
    Token token=null;
    if (scalarVariable.variability != FMIScalarVariable.Variability.parameter) {
      if (scalarVariable.type instanceof FMIBooleanType) {
        boolean result=scalarVariable.getBoolean(_fmiComponent);
        token=new BooleanToken(result);
      }
 else       if (scalarVariable.type instanceof FMIIntegerType) {
        int result=scalarVariable.getInt(_fmiComponent);
        token=new IntToken(result);
      }
 else       if (scalarVariable.type instanceof FMIRealType) {
        double result=scalarVariable.getDouble(_fmiComponent);
        token=new DoubleToken(result);
      }
 else       if (scalarVariable.type instanceof FMIStringType) {
        String result=scalarVariable.getString(_fmiComponent);
        token=new StringToken(result);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + scalarVariable.type + ""String_Node_Str"");
      }
      TypedIOPort port=(TypedIOPort)getPort(scalarVariable.name);
      if (_debugging) {
        _debug(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token+ ""String_Node_Str""+ scalarVariable.causality+ ""String_Node_Str""+ Causality.output);
      }
switch (scalarVariable.causality) {
case internal:
        break;
case input:
      token=port.get(0);
    break;
case output:
case none:
  port.send(0,token);
break;
}
}
}
}","/** 
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  double time=getDirector().getModelTime().getDoubleValue();
  double stepSize=((ptolemy.domains.sdf.kernel.SDFDirector)getDirector()).periodValue();
  if (_debugging) {
    _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str"");
  }
  int fmiFlag=((Integer)_fmiDoStep.invokeInt(new Object[]{_fmiComponent,time,stepSize,(byte)1})).intValue();
  if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
    throw new IllegalActionException(this,""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str""+ fmiFlag);
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
  }
  for (  FMIScalarVariable scalarVariable : _fmiModelDescription.modelVariables) {
    if (_debugging) {
      _debug(""String_Node_Str"" + scalarVariable.name);
    }
    if (scalarVariable.alias != null && scalarVariable.alias != Alias.noAlias) {
      continue;
    }
    Token token=null;
    if (scalarVariable.variability != FMIScalarVariable.Variability.parameter) {
      if (scalarVariable.type instanceof FMIBooleanType) {
        boolean result=scalarVariable.getBoolean(_fmiComponent);
        token=new BooleanToken(result);
      }
 else       if (scalarVariable.type instanceof FMIIntegerType) {
        int result=scalarVariable.getInt(_fmiComponent);
        token=new IntToken(result);
      }
 else       if (scalarVariable.type instanceof FMIRealType) {
        double result=scalarVariable.getDouble(_fmiComponent);
        token=new DoubleToken(result);
      }
 else       if (scalarVariable.type instanceof FMIStringType) {
        String result=scalarVariable.getString(_fmiComponent);
        token=new StringToken(result);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + scalarVariable.type + ""String_Node_Str"");
      }
      TypedIOPort port=(TypedIOPort)getPort(scalarVariable.name);
      if (_debugging) {
        _debug(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token+ ""String_Node_Str""+ scalarVariable.causality+ ""String_Node_Str""+ Causality.output);
      }
switch (scalarVariable.causality) {
case none:
        break;
case input:
      token=port.get(0);
    break;
case output:
case internal:
  port.send(0,token);
break;
}
}
}
}"
73209,"/** 
 * Read in a .fmu file and parse the modelDescription.xml file.
 * @param fmuFileName the .fmu file
 * @return An object that represents the structure of themodelDescriptionFile.xml file.
 * @exception IOException If the file cannot be unzipped or themodelDescription.xml file contained by the fmuFileName zip file cannot be parsed.
 */
public static FMIModelDescription parseFMUFile(String fmuFileName) throws IOException {
  List<File> files=null;
  try {
    files=_unzip(fmuFileName);
  }
 catch (  IOException ex) {
    throw new IOException(""String_Node_Str"" + fmuFileName + ""String_Node_Str"",ex);
  }
  File modelDescriptionFile=null;
  for (  File file : files) {
    if (file.getName().endsWith(""String_Node_Str"")) {
      modelDescriptionFile=file;
      break;
    }
  }
  if (modelDescriptionFile == null) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + fmuFileName + ""String_Node_Str"");
  }
  Document document=null;
  try {
    DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
    DocumentBuilder db=dbf.newDocumentBuilder();
    document=db.parse(modelDescriptionFile.getCanonicalPath());
  }
 catch (  Exception ex) {
    throw new IOException(""String_Node_Str"" + modelDescriptionFile + ""String_Node_Str"",ex);
  }
  Element root=document.getDocumentElement();
  FMIModelDescription fmiModelDescription=new FMIModelDescription();
  fmiModelDescription.files=files;
  if (root.hasAttribute(""String_Node_Str"")) {
    fmiModelDescription.fmiVersion=root.getAttribute(""String_Node_Str"");
  }
  if (root.hasAttribute(""String_Node_Str"")) {
    fmiModelDescription.modelIdentifier=root.getAttribute(""String_Node_Str"");
  }
  if (root.hasAttribute(""String_Node_Str"")) {
    fmiModelDescription.modelName=root.getAttribute(""String_Node_Str"");
  }
  if (root.hasAttribute(""String_Node_Str"")) {
    fmiModelDescription.guid=root.getAttribute(""String_Node_Str"");
  }
  NodeList types=document.getElementsByTagName(""String_Node_Str"");
  for (int i=0; i < types.getLength(); i++) {
    Element element=(Element)types.item(i);
    String elementTypeName=element.getAttribute(""String_Node_Str"");
    NodeList children=element.getChildNodes();
    for (i=0; i < children.getLength(); i++) {
      Node child=element.getChildNodes().item(i);
      if (child instanceof Element) {
        Element childElement=(Element)child;
        String childTypeName=childElement.getNodeName();
        fmiModelDescription.typeDefinitions.put(elementTypeName,childTypeName);
      }
    }
  }
  String sharedLibrary=FMUFile.fmuSharedLibrary(fmiModelDescription);
  try {
    fmiModelDescription.nativeLibrary=NativeLibrary.getInstance(sharedLibrary);
  }
 catch (  Throwable throwable) {
    List<String> binariesFiles=new LinkedList<String>();
    for (    File file : fmiModelDescription.files) {
      if (file.toString().indexOf(""String_Node_Str"") != -1) {
        binariesFiles.add(file.toString() + ""String_Node_Str"");
      }
    }
    String message=""String_Node_Str"" + sharedLibrary + ""String_Node_Str""+ ""String_Node_Str""+ fmuFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ binariesFiles;
    System.out.println(message + ""String_Node_Str"" + throwable);
    throw new IOException(message,throwable);
  }
  NodeList scalarVariables=document.getElementsByTagName(""String_Node_Str"");
  for (int i=0; i < scalarVariables.getLength(); i++) {
    Element element=(Element)scalarVariables.item(i);
    fmiModelDescription.modelVariables.add(new FMIScalarVariable(fmiModelDescription,element));
  }
  return fmiModelDescription;
}","/** 
 * Read in a .fmu file and parse the modelDescription.xml file.
 * @param fmuFileName the .fmu file
 * @return An object that represents the structure of themodelDescriptionFile.xml file.
 * @exception IOException If the file cannot be unzipped or themodelDescription.xml file contained by the fmuFileName zip file cannot be parsed.
 */
public static FMIModelDescription parseFMUFile(String fmuFileName) throws IOException {
  List<File> files=null;
  try {
    files=_unzip(fmuFileName);
  }
 catch (  IOException ex) {
    throw new IOException(""String_Node_Str"" + fmuFileName + ""String_Node_Str"",ex);
  }
  File modelDescriptionFile=null;
  for (  File file : files) {
    if (file.getName().endsWith(""String_Node_Str"")) {
      modelDescriptionFile=file;
      break;
    }
  }
  if (modelDescriptionFile == null) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + fmuFileName + ""String_Node_Str"");
  }
  Document document=null;
  try {
    DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
    DocumentBuilder db=dbf.newDocumentBuilder();
    document=db.parse(modelDescriptionFile.getCanonicalPath());
  }
 catch (  Exception ex) {
    throw new IOException(""String_Node_Str"" + modelDescriptionFile + ""String_Node_Str"",ex);
  }
  Element root=document.getDocumentElement();
  FMIModelDescription fmiModelDescription=new FMIModelDescription();
  fmiModelDescription.files=files;
  if (root.hasAttribute(""String_Node_Str"")) {
    fmiModelDescription.fmiVersion=root.getAttribute(""String_Node_Str"");
  }
  if (root.hasAttribute(""String_Node_Str"")) {
    fmiModelDescription.modelIdentifier=root.getAttribute(""String_Node_Str"");
  }
  if (root.hasAttribute(""String_Node_Str"")) {
    fmiModelDescription.modelName=root.getAttribute(""String_Node_Str"");
  }
  if (root.hasAttribute(""String_Node_Str"")) {
    fmiModelDescription.guid=root.getAttribute(""String_Node_Str"");
  }
  NodeList types=document.getElementsByTagName(""String_Node_Str"");
  int length=types.getLength();
  for (int i=0; i < length; i++) {
    Element element=(Element)types.item(i);
    String elementTypeName=element.getAttribute(""String_Node_Str"");
    NodeList children=element.getChildNodes();
    for (int j=0; j < children.getLength(); j++) {
      Node child=element.getChildNodes().item(j);
      if (child instanceof Element) {
        Element childElement=(Element)child;
        String childTypeName=childElement.getNodeName();
        fmiModelDescription.typeDefinitions.put(elementTypeName,childTypeName);
      }
    }
  }
  String sharedLibrary=FMUFile.fmuSharedLibrary(fmiModelDescription);
  try {
    fmiModelDescription.nativeLibrary=NativeLibrary.getInstance(sharedLibrary);
  }
 catch (  Throwable throwable) {
    List<String> binariesFiles=new LinkedList<String>();
    for (    File file : fmiModelDescription.files) {
      if (file.toString().indexOf(""String_Node_Str"") != -1) {
        binariesFiles.add(file.toString() + ""String_Node_Str"");
      }
    }
    String message=""String_Node_Str"" + sharedLibrary + ""String_Node_Str""+ ""String_Node_Str""+ fmuFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ binariesFiles;
    System.out.println(message + ""String_Node_Str"" + throwable);
    throw new IOException(message,throwable);
  }
  NodeList scalarVariables=document.getElementsByTagName(""String_Node_Str"");
  for (int i=0; i < scalarVariables.getLength(); i++) {
    Element element=(Element)scalarVariables.item(i);
    fmiModelDescription.modelVariables.add(new FMIScalarVariable(fmiModelDescription,element));
  }
  return fmiModelDescription;
}"
73210,"/** 
 * Send Token inside. Tokens received on this port are recordTokens. Only the payload of the RecordToken should be sent inside. 
 * @param channelIndex Channel token is sent to.
 * @param token Token to be sent.
 * @throws IllegalActionException If received token is not a record token with the fields timestamp, microstep and payload.
 */
public void sendInside(int channelIndex,Token token) throws IllegalActionException, NoRoomException {
  PtidesDirector director=(PtidesDirector)((CompositeActor)getContainer()).getDirector();
  if (!(token instanceof RecordToken) || ((RecordToken)token).labelSet().size() != 3) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  RecordToken record=(RecordToken)token;
  Time recordTimeStamp=new Time(director,((DoubleToken)(record.get(timestamp))).doubleValue());
  int recordMicrostep=((IntToken)(record.get(microstep))).intValue();
  Receiver[][] farReceivers=deepGetReceivers();
  for (int i=0; i < farReceivers[channelIndex].length; i++) {
    director.addInputEvent(new PtidesEvent(this,channelIndex,recordTimeStamp,recordMicrostep,-1,(Token)record.get(payload),farReceivers[channelIndex][i]));
  }
}","/** 
 * Send Token inside. Tokens received on this port are recordTokens. Only the payload of the RecordToken should be sent inside. 
 * @param channelIndex Channel token is sent to.
 * @param token Token to be sent.
 * @throws IllegalActionException If received token is not a record token with the fields timestamp, microstep and payload.
 */
public void sendInside(int channelIndex,Token token) throws IllegalActionException, NoRoomException {
  PtidesDirector director=(PtidesDirector)((CompositeActor)getContainer()).getDirector();
  if (!(token instanceof RecordToken) || ((RecordToken)token).labelSet().size() != 3) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  RecordToken record=(RecordToken)token;
  Time recordTimeStamp=new Time(director,((DoubleToken)(record.get(timestamp))).doubleValue());
  int recordMicrostep=((IntToken)(record.get(microstep))).intValue();
  Receiver[][] farReceivers=deepGetReceivers();
  for (int i=0; i < farReceivers[channelIndex].length; i++) {
    director.addInputEvent(new PtidesEvent(this,channelIndex,recordTimeStamp,recordMicrostep,-1,(Token)record.get(payload),farReceivers[channelIndex][i]),0);
  }
}"
73211,"/** 
 * Consume at most one token from the <i>input</i> port and output the PID control. If there has been no previous iteration, only proportional output is generated. If there is no input, then produce no output.
 * @exception IllegalActionException If addition, multiplication,subtraction, or division is not supported by the supplied tokens.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (input.hasToken(0)) {
    Time currentTime=getDirector().getModelTime();
    DoubleToken currentToken=(DoubleToken)input.get(0);
    _currentInput=new TimedEvent(currentTime,currentToken);
    DoubleToken currentOutput=(DoubleToken)currentToken.multiply(Kp.getToken());
    if (_lastInput != null) {
      DoubleToken lastToken=(DoubleToken)_lastInput.contents;
      Time lastTime=_lastInput.timeStamp;
      DoubleToken timeGap=new DoubleToken(currentTime.subtract(lastTime).getDoubleValue());
      if (timeGap.isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue()) {
        if (!((DoubleToken)Kd.getToken()).isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue() && !currentToken.equals(lastToken)) {
          throw new IllegalActionException(""String_Node_Str"");
        }
      }
 else {
        if (!((DoubleToken)Ki.getToken()).isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue()) {
          _accumulated=(DoubleToken)_accumulated.add(currentToken.add(lastToken).multiply(timeGap).multiply(new DoubleToken(0.5)));
          currentOutput=(DoubleToken)currentOutput.add(_accumulated.multiply(Ki.getToken()));
        }
        if (!((DoubleToken)Kd.getToken()).isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue()) {
          currentOutput=(DoubleToken)currentOutput.add(currentToken.subtract(lastToken).divide(timeGap).multiply(Kd.getToken()));
        }
      }
    }
    output.broadcast(currentOutput);
  }
}","/** 
 * Consume at most one token from the <i>input</i> port and output the PID control. If there has been no previous iteration, only proportional output is generated. If there is no input, then produce no output.
 * @exception IllegalActionException If addition, multiplication,subtraction, or division is not supported by the supplied tokens.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (input.hasToken(0)) {
    Time currentTime=getDirector().getModelTime();
    DoubleToken currentToken=(DoubleToken)input.get(0);
    _currentInput=new TimedEvent(currentTime,currentToken);
    DoubleToken currentOutput=(DoubleToken)currentToken.multiply(Kp.getToken());
    if (_lastInput != null) {
      DoubleToken lastToken=(DoubleToken)_lastInput.contents;
      Time lastTime=_lastInput.timeStamp;
      DoubleToken timeGap=new DoubleToken(currentTime.subtract(lastTime).getDoubleValue());
      if (timeGap.isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue()) {
        if (!((DoubleToken)Kd.getToken()).isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue() && !currentToken.equals(lastToken)) {
          throw new IllegalActionException(this,""String_Node_Str"");
        }
      }
 else {
        if (!((DoubleToken)Ki.getToken()).isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue()) {
          _accumulated=(DoubleToken)_accumulated.add(currentToken.add(lastToken).multiply(timeGap).multiply(new DoubleToken(0.5)));
          currentOutput=(DoubleToken)currentOutput.add(_accumulated.multiply(Ki.getToken()));
        }
        if (!((DoubleToken)Kd.getToken()).isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue()) {
          currentOutput=(DoubleToken)currentOutput.add(currentToken.subtract(lastToken).divide(timeGap).multiply(Kd.getToken()));
        }
      }
    }
    output.broadcast(currentOutput);
  }
}"
73212,"/** 
 * If the attribute is <i>seed</i> or <i>useThisSeed</i>  then create the base random number generator.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == seed) {
    long seedValue=((LongToken)(seed.getToken())).longValue();
    if (seedValue != _generatorSeed) {
      _needNewGenerator=true;
    }
  }
 else   if (attribute == privateSeed) {
    Token token=privateSeed.getToken();
    if (token != null) {
      long seedValue=((LongToken)token).longValue();
      if (seedValue != _generatorSeed) {
        _needNewGenerator=true;
      }
    }
 else {
      long seedValue=((LongToken)(seed.getToken())).longValue();
      if (seedValue != _generatorSeed) {
        _needNewGenerator=true;
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If the attribute is <i>seed</i> or <i>useThisSeed</i>  then create the base random number generator.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == seed || attribute == privateSeed) {
    long seedValue;
    Token privateSeedToken=privateSeed.getToken();
    if (privateSeedToken != null) {
      seedValue=((LongToken)privateSeedToken).longValue();
    }
 else {
      seedValue=((LongToken)seed.getToken()).longValue();
    }
    if (seedValue != _generatorSeed) {
      _needNewGenerator=true;
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
73213,"/** 
 * Create the random number generator using current parameter values.
 * @exception IllegalActionException If thrown while reading theseed Token.
 */
protected void _createGenerator() throws IllegalActionException {
  long seedValue=((LongToken)(seed.getToken())).longValue();
  Token token=privateSeed.getToken();
  if (token != null) {
    seedValue=((LongToken)token).longValue();
    _generatorSeed=seedValue;
  }
 else {
    _generatorSeed=seedValue;
    if (seedValue == 0L) {
      seedValue=System.currentTimeMillis() + hashCode();
    }
 else {
      seedValue=seedValue + getFullName().hashCode();
    }
  }
  _random=new Random(seedValue);
  _needNewGenerator=false;
  _needNew=true;
}","/** 
 * Create the random number generator using current parameter values.
 * @exception IllegalActionException If thrown while reading theseed Token.
 */
protected void _createGenerator() throws IllegalActionException {
  long seedValue;
  Token privateSeedToken=privateSeed.getToken();
  if (privateSeedToken != null) {
    seedValue=((LongToken)privateSeedToken).longValue();
    _generatorSeed=seedValue;
  }
 else {
    seedValue=((LongToken)seed.getToken()).longValue();
    _generatorSeed=seedValue;
    if (seedValue == 0L) {
      seedValue=System.currentTimeMillis() + hashCode();
    }
 else {
      seedValue=seedValue + getFullName().hashCode();
    }
  }
  _random=new Random(seedValue);
  _needNewGenerator=false;
  _needNew=true;
}"
73214,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class has anattribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  PlotterBase newObject=(PlotterBase)super.clone(workspace);
  newObject.plot=null;
  newObject._implementation=null;
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class has anattribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  PlotterBase newObject=(PlotterBase)super.clone(workspace);
  newObject.plot=null;
  newObject._implementation=null;
  try {
    newObject._getImplementation().initWindowAndSizeProperties();
  }
 catch (  KernelException e) {
    throw new CloneNotSupportedException(""String_Node_Str"" + e);
  }
  return newObject;
}"
73215,"/** 
 * Initialize the effigy of the plotter.
 * @exception IllegalActionException If there is a problem initializing the effigy
 */
public void initWindowAndSizeProperties() throws IllegalActionException, NameDuplicationException {
  _windowProperties=new WindowPropertiesAttribute(_plotterBase,""String_Node_Str"");
  _windowProperties.setPersistent(true);
  _plotSize=new SizeAttribute(_plotterBase,""String_Node_Str"");
  _plotSize.setPersistent(true);
}","/** 
 * Initialize the effigy of the plotter.
 * @exception IllegalActionException If there is a problem initializing the effigy
 */
public void initWindowAndSizeProperties() throws IllegalActionException, NameDuplicationException {
  _windowProperties=(WindowPropertiesAttribute)_plotterBase.getAttribute(""String_Node_Str"",WindowPropertiesAttribute.class);
  if (_windowProperties == null) {
    _windowProperties=new WindowPropertiesAttribute(_plotterBase,""String_Node_Str"");
    _windowProperties.setPersistent(true);
  }
  _plotSize=(SizeAttribute)_plotterBase.getAttribute(""String_Node_Str"",SizeAttribute.class);
  if (_plotSize == null) {
    _plotSize=new SizeAttribute(_plotterBase,""String_Node_Str"");
    _plotSize.setPersistent(true);
  }
}"
73216,"private void _requestFiringAt(Time time) throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"",getContainer().getName(),""String_Node_Str"" + time);
  }
  fireContainerAt(time);
}","private void _requestFiringAt(Time time) throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"",getContainer().getName(),""String_Node_Str"" + time);
  }
  fireContainerAt(time,1);
}"
73217,"/** 
 * Get the location in some cartesian coordinate system. This method returns the absolute location of the object. If the relative location was previously attached to an object referenced in the   {@link #relativeTo} property and that objectis gone, then the internally stored location is updated so it contains the correct absolute location.
 * @return The location.
 * @see #setLocation(double[])
 */
@Override public double[] getLocation(){
  double[] offset=super.getLocation();
  String relativeToValue=relativeTo.getExpression();
  if (relativeToValue.equals(""String_Node_Str"") || offset == null) {
    return offset;
  }
  double[] relativeToLocation=_getRelativeToLocation(relativeToValue);
  if (relativeToLocation != null) {
    double[] result=new double[offset.length];
    for (int i=0; i < offset.length; i++) {
      result[i]=offset[i] + relativeToLocation[i];
    }
    return result;
  }
  if (_cachedReltoLoc != null) {
    for (int i=0; i < offset.length; i++) {
      offset[i]+=_cachedReltoLoc[i];
    }
    _cachedReltoLoc=null;
  }
  return offset;
}","/** 
 * Get the location in some cartesian coordinate system. This method returns the absolute location of the object. If the relative location was previously attached to an object referenced in the   {@link #relativeTo} property and that objectis gone, then the internally stored location is updated so it contains the correct absolute location.
 * @return The location.
 * @see #setLocation(double[])
 */
@Override public double[] getLocation(){
  double[] offset=super.getLocation();
  NamedObj relativeToObject=getRelativeToNamedObj();
  if (relativeToObject == null || offset == null) {
    return offset;
  }
  double[] relativeToLocation=_getRelativeToLocation(relativeToObject);
  if (relativeToLocation != null) {
    double[] result=new double[offset.length];
    for (int i=0; i < offset.length; i++) {
      result[i]=offset[i] + relativeToLocation[i];
    }
    return result;
  }
  if (_cachedReltoLoc != null) {
    for (int i=0; i < offset.length; i++) {
      offset[i]+=_cachedReltoLoc[i];
    }
    _cachedReltoLoc=null;
  }
  return offset;
}"
73218,"/** 
 * Set the location in some cartesian coordinate system, and notify the container and any value listeners of the new location. Setting the location involves maintaining a local copy of the passed parameter. No notification is done if the location is the same as before. This method propagates the value to any derived objects. If the relative location is attached to an object referenced in the  {@link #relativeTo} property, then only the relative location isstored internally.
 * @param location The location.
 * @exception IllegalActionException Thrown when attributeChanged() is called.
 * @see #getLocation()
 */
@Override public void setLocation(double[] location) throws IllegalActionException {
  String relativeToValue=relativeTo.getExpression();
  if (relativeToValue.equals(""String_Node_Str"")) {
    super.setLocation(location);
  }
  double[] relativeToLocation=_getRelativeToLocation(relativeToValue);
  if (relativeToLocation != null) {
    double[] result=new double[location.length];
    for (int i=0; i < location.length; i++) {
      result[i]=location[i] - relativeToLocation[i];
    }
    super.setLocation(result);
    return;
  }
  _cachedReltoLoc=null;
  super.setLocation(location);
}","/** 
 * Set the location in some cartesian coordinate system, and notify the container and any value listeners of the new location. Setting the location involves maintaining a local copy of the passed parameter. No notification is done if the location is the same as before. This method propagates the value to any derived objects. If the relative location is attached to an object referenced in the  {@link #relativeTo} property, then only the relative location isstored internally.
 * @param location The location.
 * @exception IllegalActionException Thrown when attributeChanged() is called.
 * @see #getLocation()
 */
@Override public void setLocation(double[] location) throws IllegalActionException {
  NamedObj relativeToObject=getRelativeToNamedObj();
  if (relativeToObject == null) {
    super.setLocation(location);
    return;
  }
  double[] relativeToLocation=_getRelativeToLocation(relativeToObject);
  if (relativeToLocation != null) {
    double[] result=new double[location.length];
    for (int i=0; i < location.length; i++) {
      result[i]=location[i] - relativeToLocation[i];
    }
    super.setLocation(result);
    return;
  }
  _cachedReltoLoc=null;
  super.setLocation(location);
}"
73219,"/** 
 * If the <i>relativeTo</i> object exists, return its location. Otherwise, return null.
 * @param relativeToName The name of the relativeTo object.
 * @return The location of the relativeTo object, or null if itdoes not exist.
 */
private double[] _getRelativeToLocation(String relativeToName){
  NamedObj container=getContainer();
  if (container != null) {
    NamedObj containersContainer=container.getContainer();
    if (containersContainer instanceof CompositeEntity) {
      CompositeEntity composite=(CompositeEntity)containersContainer;
      String elementName=relativeToElementName.getExpression();
      NamedObj relativeToNamedObj;
      if (elementName.equals(""String_Node_Str"")) {
        relativeToNamedObj=composite.getAttribute(relativeToName);
      }
 else       if (elementName.equals(""String_Node_Str"")) {
        relativeToNamedObj=composite.getPort(relativeToName);
      }
 else       if (elementName.equals(""String_Node_Str"")) {
        relativeToNamedObj=composite.getRelation(relativeToName);
      }
 else {
        relativeToNamedObj=composite.getEntity(relativeToName);
      }
      if (relativeToNamedObj != null) {
        List<Locatable> locatables=relativeToNamedObj.attributeList(Locatable.class);
        if (locatables.size() > 0) {
          _cachedReltoLoc=locatables.get(0).getLocation();
          return _cachedReltoLoc;
        }
      }
    }
  }
  try {
    relativeTo.setExpression(""String_Node_Str"");
    relativeToElementName.setExpression(""String_Node_Str"");
  }
 catch (  IllegalActionException exception) {
    throw new InternalErrorException(exception);
  }
  return null;
}","/** 
 * If the <i>relativeTo</i> object exists, return its location. Otherwise, return null.
 * @param relativeToObject The relativeTo object.
 * @return The location of the relativeTo object, or null if itdoes not exist.
 */
private double[] _getRelativeToLocation(NamedObj relativeToObject){
  List<Locatable> locatables=relativeToObject.attributeList(Locatable.class);
  if (locatables.size() > 0) {
    _cachedReltoLoc=locatables.get(0).getLocation();
    return _cachedReltoLoc;
  }
  return null;
}"
73220,"/** 
 * Add a new entry to this query that represents the given attribute. The name of the entry will be set to the name of the attribute, and the attribute will be attached to the entry, so that if the attribute is updated, then the entry is updated. If the attribute contains an instance of ParameterEditorStyle, then defer to the style to create the entry, otherwise just create a default entry. The style used in a default entry depends on the class of the attribute and on its declared type, but defaults to a one-line entry if there is no obviously better style. Only the first style that is found is used to create an entry.
 * @param attribute The attribute to create an entry for.
 */
public void addStyledEntry(Settable attribute){
  boolean foundStyle=false;
  try {
    _addingStyledEntryFor=attribute;
    if (attribute instanceof NamedObj) {
      Iterator<?> styles=((NamedObj)attribute).attributeList(ParameterEditorStyle.class).iterator();
      while (styles.hasNext() && !foundStyle) {
        ParameterEditorStyle style=(ParameterEditorStyle)styles.next();
        try {
          style.addEntry(this);
          foundStyle=true;
        }
 catch (        IllegalActionException ex) {
        }
      }
    }
    if (!foundStyle) {
      String name=attribute.getName();
      String displayName=attribute.getDisplayName();
      try {
        JComponent component=null;
        if (attribute instanceof IntRangeParameter) {
          int current=((IntRangeParameter)attribute).getCurrentValue();
          int min=((IntRangeParameter)attribute).getMinValue();
          int max=((IntRangeParameter)attribute).getMaxValue();
          component=addSlider(name,displayName,current,min,max);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof DoubleRangeParameter) {
          double current=((DoubleToken)((DoubleRangeParameter)attribute).getToken()).doubleValue();
          double max=((DoubleToken)((DoubleRangeParameter)attribute).max.getToken()).doubleValue();
          double min=((DoubleToken)((DoubleRangeParameter)attribute).min.getToken()).doubleValue();
          int precision=((IntToken)((DoubleRangeParameter)attribute).precision.getToken()).intValue();
          int quantized=((int)Math.round(((current - min) * precision) / (max - min)));
          component=addSlider(name,displayName,quantized,0,precision);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof ColorAttribute) {
          component=addColorChooser(name,displayName,attribute.getExpression());
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof CustomQueryBoxParameter) {
          JLabel label=new JLabel(displayName + ""String_Node_Str"");
          label.setBackground(_background);
          component=((CustomQueryBoxParameter)attribute).createQueryBox(this,attribute);
          _addPair(name,label,component,component);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof FileParameter || attribute instanceof FilePortParameter) {
          URI modelURI=URIAttribute.getModelURI((NamedObj)attribute);
          File directory=null;
          if (modelURI != null) {
            if (modelURI.getScheme().equals(""String_Node_Str"")) {
              File modelFile=new File(modelURI);
              directory=modelFile.getParentFile();
            }
          }
          URI base=null;
          if (directory != null) {
            base=directory.toURI();
          }
          boolean allowFiles=true;
          boolean allowDirectories=false;
          Parameter marker=(Parameter)((NamedObj)attribute).getAttribute(""String_Node_Str"",Parameter.class);
          if (marker != null) {
            Token value=marker.getToken();
            if (value instanceof BooleanToken) {
              allowFiles=((BooleanToken)value).booleanValue();
            }
          }
          marker=(Parameter)((NamedObj)attribute).getAttribute(""String_Node_Str"",Parameter.class);
          if (marker != null) {
            Token value=marker.getToken();
            if (value instanceof BooleanToken) {
              allowDirectories=((BooleanToken)value).booleanValue();
            }
          }
          if (!allowFiles && !allowDirectories) {
            return;
          }
          boolean isOutput=false;
          if (attribute instanceof FileParameter && ((FileParameter)attribute).isOutput()) {
            isOutput=true;
          }
          component=addFileChooser(name,displayName,attribute.getExpression(),base,directory,allowFiles,allowDirectories,isOutput,preferredBackgroundColor(attribute),preferredForegroundColor(attribute));
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof PasswordAttribute) {
          component=addPassword(name,displayName,""String_Node_Str"");
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof Parameter && (((Parameter)attribute).getChoices() != null)) {
          Parameter castAttribute=(Parameter)attribute;
          component=addChoice(name,displayName,castAttribute.getChoices(),castAttribute.getExpression(),true,preferredBackgroundColor(attribute),preferredForegroundColor(attribute));
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if ((attribute instanceof NamedObj) && ((((NamedObj)attribute).getAttribute(""String_Node_Str"") != null) || ((NamedObj)attribute).getAttribute(""String_Node_Str"") != null)) {
          int widthValue=30;
          int heightValue=10;
          Attribute widthAttribute=((NamedObj)attribute).getAttribute(""String_Node_Str"");
          if (widthAttribute instanceof Variable) {
            Token token=((Variable)widthAttribute).getToken();
            if (token instanceof IntToken) {
              widthValue=((IntToken)token).intValue();
            }
          }
          Attribute heightAttribute=((NamedObj)attribute).getAttribute(""String_Node_Str"");
          if (heightAttribute instanceof Variable) {
            Token token=((Variable)heightAttribute).getToken();
            if (token instanceof IntToken) {
              heightValue=((IntToken)token).intValue();
            }
          }
          component=addTextArea(name,displayName,attribute.getExpression(),preferredBackgroundColor(attribute),preferredForegroundColor(attribute),heightValue,widthValue);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof Variable) {
          Type declaredType=((Variable)attribute).getDeclaredType();
          Token current=((Variable)attribute).getToken();
          if (declaredType == BaseType.BOOLEAN) {
            if (attribute.getExpression().equals(""String_Node_Str"") || attribute.getExpression().equals(""String_Node_Str"")) {
              component=addCheckBox(name,displayName,((BooleanToken)current).booleanValue());
              attachParameter(attribute,name);
              foundStyle=true;
            }
          }
        }
        if (attribute.getVisibility() == Settable.NOT_EDITABLE) {
          if (component == null) {
            String defaultValue=attribute.getExpression();
            component=addDisplay(name,displayName,defaultValue);
            attachParameter(attribute,name);
            foundStyle=true;
          }
 else           if (component instanceof JTextComponent) {
            component.setBackground(_background);
            ((JTextComponent)component).setEditable(false);
          }
 else {
            component.setEnabled(false);
          }
        }
      }
 catch (      IllegalActionException ex) {
      }
    }
    String defaultValue=attribute.getExpression();
    if (defaultValue == null) {
      defaultValue=""String_Node_Str"";
    }
    if (!(foundStyle)) {
      addTextArea(attribute.getName(),attribute.getDisplayName(),defaultValue,preferredBackgroundColor(attribute),preferredForegroundColor(attribute),2,DEFAULT_ENTRY_WIDTH);
      attachParameter(attribute,attribute.getName());
    }
  }
  finally {
    _addingStyledEntryFor=null;
  }
}","/** 
 * Add a new entry to this query that represents the given attribute. The name of the entry will be set to the name of the attribute, and the attribute will be attached to the entry, so that if the attribute is updated, then the entry is updated. If the attribute contains an instance of ParameterEditorStyle, then defer to the style to create the entry, otherwise just create a default entry. The style used in a default entry depends on the class of the attribute and on its declared type, but defaults to a one-line entry if there is no obviously better style. Only the first style that is found is used to create an entry.
 * @param attribute The attribute to create an entry for.
 */
public void addStyledEntry(Settable attribute){
  boolean foundStyle=false;
  try {
    _addingStyledEntryFor=attribute;
    if (attribute instanceof NamedObj) {
      Iterator<?> styles=((NamedObj)attribute).attributeList(ParameterEditorStyle.class).iterator();
      while (styles.hasNext() && !foundStyle) {
        ParameterEditorStyle style=(ParameterEditorStyle)styles.next();
        try {
          style.addEntry(this);
          foundStyle=true;
        }
 catch (        IllegalActionException ex) {
        }
      }
    }
    if (!foundStyle) {
      String name=attribute.getName();
      String displayName=attribute.getDisplayName();
      try {
        JComponent component=null;
        if (attribute instanceof IntRangeParameter) {
          int current=((IntRangeParameter)attribute).getCurrentValue();
          int min=((IntRangeParameter)attribute).getMinValue();
          int max=((IntRangeParameter)attribute).getMaxValue();
          component=addSlider(name,displayName,current,min,max);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof DoubleRangeParameter) {
          double current=((DoubleToken)((DoubleRangeParameter)attribute).getToken()).doubleValue();
          double max=((DoubleToken)((DoubleRangeParameter)attribute).max.getToken()).doubleValue();
          double min=((DoubleToken)((DoubleRangeParameter)attribute).min.getToken()).doubleValue();
          int precision=((IntToken)((DoubleRangeParameter)attribute).precision.getToken()).intValue();
          int quantized=((int)Math.round(((current - min) * precision) / (max - min)));
          component=addSlider(name,displayName,quantized,0,precision);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof ColorAttribute) {
          component=addColorChooser(name,displayName,attribute.getExpression());
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof CustomQueryBoxParameter) {
          JLabel label=new JLabel(displayName + ""String_Node_Str"");
          label.setBackground(_background);
          component=((CustomQueryBoxParameter)attribute).createQueryBox(this,attribute);
          _addPair(name,label,component,component);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof FileParameter || attribute instanceof FilePortParameter) {
          URI modelURI=URIAttribute.getModelURI((NamedObj)attribute);
          File directory=null;
          if (modelURI != null) {
            if (modelURI.getScheme().equals(""String_Node_Str"")) {
              File modelFile=new File(modelURI);
              directory=modelFile.getParentFile();
            }
          }
          URI base=null;
          if (directory != null) {
            base=directory.toURI();
          }
          boolean allowFiles=true;
          boolean allowDirectories=false;
          Parameter marker=(Parameter)((NamedObj)attribute).getAttribute(""String_Node_Str"",Parameter.class);
          if (marker != null) {
            Token value=marker.getToken();
            if (value instanceof BooleanToken) {
              allowFiles=((BooleanToken)value).booleanValue();
            }
          }
          marker=(Parameter)((NamedObj)attribute).getAttribute(""String_Node_Str"",Parameter.class);
          if (marker != null) {
            Token value=marker.getToken();
            if (value instanceof BooleanToken) {
              allowDirectories=((BooleanToken)value).booleanValue();
            }
          }
          if (!allowFiles && !allowDirectories) {
            return;
          }
          boolean isOutput=false;
          if (attribute instanceof FileParameter && ((FileParameter)attribute).isOutput()) {
            isOutput=true;
          }
          component=addFileChooser(name,displayName,attribute.getExpression(),base,directory,allowFiles,allowDirectories,isOutput,preferredBackgroundColor(attribute),preferredForegroundColor(attribute));
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof PasswordAttribute) {
          component=addPassword(name,displayName,""String_Node_Str"");
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof Parameter && (((Parameter)attribute).getChoices() != null)) {
          Parameter castAttribute=(Parameter)attribute;
          component=addChoice(name,displayName,castAttribute.getChoices(),castAttribute.getExpression(),true,preferredBackgroundColor(attribute),preferredForegroundColor(attribute));
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if ((attribute instanceof NamedObj) && ((((NamedObj)attribute).getAttribute(""String_Node_Str"") != null) || ((NamedObj)attribute).getAttribute(""String_Node_Str"") != null)) {
          int widthValue=30;
          int heightValue=10;
          Attribute widthAttribute=((NamedObj)attribute).getAttribute(""String_Node_Str"");
          if (widthAttribute instanceof Variable) {
            Token token=((Variable)widthAttribute).getToken();
            if (token instanceof IntToken) {
              widthValue=((IntToken)token).intValue();
            }
          }
          Attribute heightAttribute=((NamedObj)attribute).getAttribute(""String_Node_Str"");
          if (heightAttribute instanceof Variable) {
            Token token=((Variable)heightAttribute).getToken();
            if (token instanceof IntToken) {
              heightValue=((IntToken)token).intValue();
            }
          }
          component=addTextArea(name,displayName,attribute.getExpression(),preferredBackgroundColor(attribute),preferredForegroundColor(attribute),heightValue,widthValue);
          attachParameter(attribute,name);
          foundStyle=true;
        }
 else         if (attribute instanceof Variable) {
          Type declaredType=((Variable)attribute).getDeclaredType();
          Token current=((Variable)attribute).getToken();
          if (declaredType == BaseType.BOOLEAN) {
            if (attribute.getExpression().equals(""String_Node_Str"") || attribute.getExpression().equals(""String_Node_Str"")) {
              component=addCheckBox(name,displayName,((BooleanToken)current).booleanValue());
              attachParameter(attribute,name);
              foundStyle=true;
            }
          }
        }
        if (attribute.getVisibility() == Settable.NOT_EDITABLE) {
          if (component == null) {
            String defaultValue=attribute.getExpression();
            component=addDisplay(name,displayName,defaultValue);
            attachParameter(attribute,name);
            foundStyle=true;
          }
 else           if (component instanceof JTextComponent) {
            component.setBackground(_background);
            ((JTextComponent)component).setEditable(false);
          }
 else {
            component.setEnabled(false);
          }
        }
      }
 catch (      IllegalActionException ex) {
      }
    }
    String defaultValue=attribute.getExpression();
    if (defaultValue == null) {
      defaultValue=""String_Node_Str"";
    }
    if (!(foundStyle)) {
      JTextArea area=addTextArea(attribute.getName(),attribute.getDisplayName(),defaultValue,preferredBackgroundColor(attribute),preferredForegroundColor(attribute),1,DEFAULT_ENTRY_WIDTH);
      area.setRows(Math.min(5,area.getLineCount()));
      attachParameter(attribute,attribute.getName());
    }
  }
  finally {
    _addingStyledEntryFor=null;
  }
}"
73221,"/** 
 * Create a text area with the specified height and width (in characters).
 * @param name The name used to identify the entry (when calling get).
 * @param label The label to attach to the entry.
 * @param theValue The value of this text area.
 * @param background The background color.
 * @param foreground The foreground color.
 * @param height The height.
 * @param width The width.
 * @return The text area.
 */
public JTextArea addTextArea(String name,String label,String theValue,Color background,Color foreground,int height,int width){
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  lbl.setBackground(_background);
  JTextArea textArea=new JTextArea(theValue,height,width);
  textArea.setRows(Math.min(5,textArea.getLineCount()));
  textArea.setEditable(true);
  textArea.setBackground(background);
  textArea.setForeground(foreground);
  QueryScrollPane textPane=new QueryScrollPane(textArea);
  _addPair(name,lbl,textPane,textPane);
  textArea.addFocusListener(new QueryFocusListener(this,name));
  return textArea;
}","/** 
 * Create a text area with the specified height and width (in characters).
 * @param name The name used to identify the entry (when calling get).
 * @param label The label to attach to the entry.
 * @param theValue The value of this text area.
 * @param background The background color.
 * @param foreground The foreground color.
 * @param height The height.
 * @param width The width.
 * @return The text area.
 */
public JTextArea addTextArea(String name,String label,String theValue,Color background,Color foreground,int height,int width){
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  lbl.setBackground(_background);
  JTextArea textArea=new JTextArea(theValue,height,width);
  textArea.setEditable(true);
  textArea.setBackground(background);
  textArea.setForeground(foreground);
  QueryScrollPane textPane=new QueryScrollPane(textArea);
  _addPair(name,lbl,textPane,textPane);
  textArea.addFocusListener(new QueryFocusListener(this,name));
  return textArea;
}"
73222,"/** 
 * Create a receiver to mediate a communication via the specified receiver. This receiver is linked to a specific port of the quantity manager.
 * @param receiver Receiver whose communication is to be mediated.
 * @param port Port of the quantity manager.
 * @return A new receiver.
 * @exception IllegalActionException If the receiver cannot be created.
 */
public IntermediateReceiver getReceiver(Receiver receiver,IOPort port) throws IllegalActionException {
  IntermediateReceiver intermediateReceiver=new IntermediateReceiver(this,receiver,port);
  if (((IOPort)receiver.getContainer()).isOutput()) {
    Receiver[][] result=new Receiver[1][1];
    List<Receiver[][]> occurrences=new LinkedList<Receiver[][]>();
    occurrences.add(result);
    HashMap<IORelation,List<Receiver[][]>> map=new HashMap<IORelation,List<Receiver[][]>>();
    map.put(new IORelation(),occurrences);
    ((IOPort)receiver.getContainer()).setLocalReceiversTable(map);
  }
 else {
    List<Receiver> list=_outputMappings.get(port);
    if (list == null) {
      list=new ArrayList();
    }
    if (!list.contains(receiver)) {
      list.add(receiver);
    }
    _outputMappings.put(port,list);
  }
  return intermediateReceiver;
}","/** 
 * Create a receiver to mediate a communication via the specified receiver. This receiver is linked to a specific port of the quantity manager.
 * @param receiver Receiver whose communication is to be mediated.
 * @param port Port of the quantity manager.
 * @return A new receiver.
 * @exception IllegalActionException If the receiver cannot be created.
 */
public IntermediateReceiver getReceiver(Receiver receiver,IOPort port) throws IllegalActionException {
  System.out.println(receiver + ""String_Node_Str"" + port+ ""String_Node_Str""+ _outputMappings);
  if (_receiversInvalid) {
    _outputMappings.clear();
    _receiversInvalid=false;
  }
  IntermediateReceiver intermediateReceiver=new IntermediateReceiver(this,receiver,port);
  if (((IOPort)receiver.getContainer()).isOutput()) {
    Receiver[][] result=new Receiver[1][1];
    List<Receiver[][]> occurrences=new LinkedList<Receiver[][]>();
    occurrences.add(result);
    HashMap<IORelation,List<Receiver[][]>> map=new HashMap<IORelation,List<Receiver[][]>>();
    map.put(new IORelation(),occurrences);
    ((IOPort)receiver.getContainer()).setLocalReceiversTable(map);
  }
 else {
    List<Receiver> list=_outputMappings.get(port);
    if (list == null) {
      list=new ArrayList();
    }
 else {
      List<Receiver> copy=new ArrayList<Receiver>(list);
      for (      Receiver listReceiver : copy) {
        if (listReceiver.getContainer() == null) {
          list.remove(listReceiver);
        }
      }
    }
    if (!list.contains(receiver)) {
      list.add(receiver);
    }
    _outputMappings.put(port,list);
  }
  return intermediateReceiver;
}"
73223,"/** 
 * Close any open displays by calling place(null).
 */
private void _closeDisplays(){
  if (_model != null) {
    Iterator atomicEntities=_model.allAtomicEntityList().iterator();
    while (atomicEntities.hasNext()) {
      Object object=atomicEntities.next();
      if (object instanceof Placeable) {
        ((Placeable)object).place(null);
      }
    }
  }
}","/** 
 * Close any open displays by calling place(null).
 */
private void _closeDisplays(){
  if (_model != null) {
    Iterator atomicEntities=_model.allAtomicEntityList().iterator();
    while (atomicEntities.hasNext()) {
      Object object=atomicEntities.next();
      if (object instanceof Placeable) {
        ((Placeable)object).place(null);
      }
 else       if (object instanceof PortablePlaceable) {
        ((PortablePlaceable)object).place(null);
      }
    }
  }
}"
73224,"/** 
 * Place the visual representation of the actor into the specified container.
 * @param container The container in which to place the object
 */
public void place(PortableContainer container){
  _textfield=new JTextField();
  _textfield.setText(""String_Node_Str"");
  container.add(_textfield);
  _textfield.setEditable(false);
}","/** 
 * Place the visual representation of the actor into the specified container.
 * @param container The container in which to place the object
 */
public void place(PortableContainer container){
  _textfield=new JTextField();
  _textfield.setText(""String_Node_Str"");
  if (container != null) {
    container.add(_textfield);
  }
  _textfield.setEditable(false);
}"
73225,"/** 
 * Set default constraints between the given object and a list of objects based on the given constraintType.  The given object is the sink and the list of objects are the sources.
 * @see ConstraintType
 * @param constraintType The given ConstraintType to be used for the default constraints
 * @param source The given object that represents the sink for the default constraints
 * @param sinkList The list of objects passed in as a {@linkplain List} thatrepresents the sources for the default constraints
 * @exception IllegalActionException If an exception is thrown
 */
protected void _constrainObject(ConstraintType constraintType,Object source,List sinkList) throws IllegalActionException {
  if (constraintType == null)   constraintType=ConstraintType.SOURCE_GE_SINK;
  for (  Object sink : sinkList) {
switch (constraintType) {
case NONE:
      break;
case EQUALS:
    setSameAs(source,sink);
  break;
case SINK_GE_SOURCE:
case SOURCE_GE_SINK:
setAtLeast(source,sink);
break;
}
}
}","/** 
 * Set default constraints between the given object and a list of objects based on the given constraintType.  The given object is the sink and the list of objects are the sources.
 * @see ConstraintType
 * @param constraintType The given ConstraintType to be used for the default constraints
 * @param sink The given object that represents the sink for the default constraints
 * @param sourceList The list of objects passed in as a {@linkplain List} thatrepresents the sources for the default constraints
 * @exception IllegalActionException If an exception is thrown
 */
protected void _constrainObject(ConstraintType constraintType,Object sink,List sourceList) throws IllegalActionException {
  if (constraintType == null)   constraintType=ConstraintType.SOURCE_GE_SINK;
  for (  Object source : sourceList) {
switch (constraintType) {
case NONE:
      break;
case EQUALS:
    setSameAs(source,sink);
  break;
case SINK_GE_SOURCE:
case SOURCE_GE_SINK:
setAtLeast(sink,source);
break;
}
}
}"
73226,"/** 
 * Add default constraints for the actor referred to by this OntologyAdapter based on the given ConstraintType.
 * @see ConstraintType
 * @param actorConstraintType The given ConstraintType for the default constraintsfor the actor referred to by this OntologyAdapter
 * @exception IllegalActionException If an exception is thrown
 */
protected void _addDefaultConstraints(ConstraintType actorConstraintType) throws IllegalActionException {
  if (!_useDefaultConstraints || !AtomicActor.class.isInstance(getComponent())) {
    return;
  }
  boolean constraintSource=actorConstraintType == ConstraintType.SOURCE_GE_SINK;
  List<IOPort> portList1=constraintSource ? ((AtomicActor)getComponent()).inputPortList() : ((AtomicActor)getComponent()).outputPortList();
  List<IOPort> portList2=constraintSource ? ((AtomicActor)getComponent()).outputPortList() : ((AtomicActor)getComponent()).inputPortList();
  Iterator<IOPort> ports=portList1.iterator();
  while (ports.hasNext()) {
    IOPort port=(IOPort)ports.next();
    _constrainObject(actorConstraintType,port,portList2);
  }
  boolean constrainPortConnectionSources=isConstraintSource();
  for (  TypedIOPort port : (List<TypedIOPort>)_getConstrainedPorts(constrainPortConnectionSources)) {
    if ((port).isMultiport() && (port).getWidth() > 1) {
      _constrainObject(interconnectConstraintType,port,_getConstraintingPorts(constrainPortConnectionSources,port));
    }
  }
}","/** 
 * Add default constraints for the actor referred to by this OntologyAdapter based on the given ConstraintType.
 * @see ConstraintType
 * @param actorConstraintType The given ConstraintType for the default constraintsfor the actor referred to by this OntologyAdapter
 * @exception IllegalActionException If an exception is thrown
 */
protected void _addDefaultConstraints(ConstraintType actorConstraintType) throws IllegalActionException {
  if (!_useDefaultConstraints || !AtomicActor.class.isInstance(getComponent())) {
    return;
  }
  if (interconnectConstraintType == null) {
    interconnectConstraintType=actorConstraintType;
  }
  List<IOPort> inputPorts=((AtomicActor)getComponent()).inputPortList();
  List<IOPort> outputPorts=((AtomicActor)getComponent()).outputPortList();
  _constrainObjectLists(actorConstraintType,inputPorts,outputPorts);
  for (  IOPort inputSink : inputPorts) {
    List<IOPort> previousOutputs=_getSourcePortList(inputSink);
    for (    IOPort source : previousOutputs) {
      _constrainSingleObject(interconnectConstraintType,source,inputSink);
    }
  }
}"
73227,"/** 
 * Initialize the solver:  Reset the solver (superclass) and then collect all of the initial constraints from the model.
 * @exception IllegalActionException If an exception occurs whencollecting the constraints.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  NamedObj toplevel=_toplevel();
  LatticeOntologyAdapter toplevelAdapter=(LatticeOntologyAdapter)getAdapter(toplevel);
  toplevelAdapter.reinitialize();
  toplevelAdapter._addDefaultConstraints(_getConstraintType());
  toplevelAdapter._setConnectionConstraintType(_getConstraintType());
  _initialConstraintList=toplevelAdapter.constraintList();
}","/** 
 * Initialize the solver:  Reset the solver (superclass) and then collect all of the initial constraints from the model.
 * @exception IllegalActionException If an exception occurs whencollecting the constraints.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  NamedObj toplevel=_toplevel();
  LatticeOntologyAdapter toplevelAdapter=(LatticeOntologyAdapter)getAdapter(toplevel);
  toplevelAdapter.reinitialize();
  toplevelAdapter._setConnectionConstraintType(_getConstraintType());
  toplevelAdapter._addDefaultConstraints(_getConstraintType());
  _initialConstraintList=toplevelAdapter.constraintList();
}"
73228,"/** 
 * Update the base component units map with the set of base units from another derived units' base component units map.
 * @param baseUnitsMap The base component units map to be updated.
 * @param baseUnitsMapFromDerivedUnit The base component units map from anotherderived unit concept to be added to the baseUnitsMap.
 */
private static void _addDerivedUnit(Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseUnitsMap,Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseUnitsMapFromDerivedUnit){
  for (  Map.Entry<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseUnitsMapEntry : baseUnitsMapFromDerivedUnit.entrySet()) {
    BaseDimensionRepresentativeConcept baseDimension=baseUnitsMapEntry.getKey();
    List<BaseUnitConcept>[] arrayOfBaseUnitsListsFromDerivedUnit=baseUnitsMapEntry.getValue();
    List<BaseUnitConcept>[] arrayOfBaseUnitsLists=baseUnitsMap.get(baseDimension);
    if (arrayOfBaseUnitsLists == null) {
      arrayOfBaseUnitsLists=arrayOfBaseUnitsListsFromDerivedUnit;
    }
 else {
      arrayOfBaseUnitsLists[POSITIVE_EXPONENT_INDEX].addAll(arrayOfBaseUnitsListsFromDerivedUnit[POSITIVE_EXPONENT_INDEX]);
      arrayOfBaseUnitsLists[NEGATIVE_EXPONENT_INDEX].addAll(arrayOfBaseUnitsListsFromDerivedUnit[NEGATIVE_EXPONENT_INDEX]);
    }
    baseUnitsMap.put(baseDimension,arrayOfBaseUnitsLists);
  }
}","/** 
 * Update the base component units map with the set of base units from another derived units' base component units map.
 * @param baseUnitsMap The base component units map to be updated.
 * @param baseUnitsMapFromDerivedUnit The base component units map from anotherderived unit concept to be added to the baseUnitsMap.
 * @param derivedDimensionExponent The exponent of the derived dimension.
 * @exception IllegalActionException Thrown if the derivedDimensionExponentis zero, which should never be the case if this method is called.
 */
private static void _addDerivedUnit(Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseUnitsMap,Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseUnitsMapFromDerivedUnit,int derivedDimensionExponent) throws IllegalActionException {
  for (  Map.Entry<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseUnitsMapEntry : baseUnitsMapFromDerivedUnit.entrySet()) {
    BaseDimensionRepresentativeConcept baseDimension=baseUnitsMapEntry.getKey();
    List<BaseUnitConcept>[] arrayOfBaseUnitsListsFromDerivedUnit=baseUnitsMapEntry.getValue();
    List<BaseUnitConcept>[] arrayOfBaseUnitsLists=baseUnitsMap.get(baseDimension);
    if (derivedDimensionExponent > 0) {
      if (arrayOfBaseUnitsLists == null) {
        arrayOfBaseUnitsLists=arrayOfBaseUnitsListsFromDerivedUnit;
      }
 else {
        arrayOfBaseUnitsLists[POSITIVE_EXPONENT_INDEX].addAll(arrayOfBaseUnitsListsFromDerivedUnit[POSITIVE_EXPONENT_INDEX]);
        arrayOfBaseUnitsLists[NEGATIVE_EXPONENT_INDEX].addAll(arrayOfBaseUnitsListsFromDerivedUnit[NEGATIVE_EXPONENT_INDEX]);
      }
    }
 else     if (derivedDimensionExponent < 0) {
      if (arrayOfBaseUnitsLists == null) {
        arrayOfBaseUnitsLists=arrayOfBaseUnitsListsFromDerivedUnit;
        List<BaseUnitConcept> tempList=new ArrayList<BaseUnitConcept>(arrayOfBaseUnitsLists[NEGATIVE_EXPONENT_INDEX]);
        arrayOfBaseUnitsLists[NEGATIVE_EXPONENT_INDEX]=arrayOfBaseUnitsLists[POSITIVE_EXPONENT_INDEX];
        arrayOfBaseUnitsLists[POSITIVE_EXPONENT_INDEX]=tempList;
      }
 else {
        arrayOfBaseUnitsLists[NEGATIVE_EXPONENT_INDEX].addAll(arrayOfBaseUnitsListsFromDerivedUnit[POSITIVE_EXPONENT_INDEX]);
        arrayOfBaseUnitsLists[POSITIVE_EXPONENT_INDEX].addAll(arrayOfBaseUnitsListsFromDerivedUnit[NEGATIVE_EXPONENT_INDEX]);
      }
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    baseUnitsMap.put(baseDimension,arrayOfBaseUnitsLists);
  }
}"
73229,"/** 
 * Recursively construct the base component units map for the given component units map and return it. Each value in the map is a two-element array of lists of BaseUnitConcepts that indicate the positive and negative exponent units for the base dimension.
 * @param componentUnitsMap The component units map from which to derivethe base component units map.
 * @param dimensionMap The dimension map for the component units map.
 * @param baseDimensionMap The already calculated base dimension map forthe dimension map input.
 * @return The base component units map with separate lists ofpositive and negative exponent units.
 * @exception IllegalActionException Thrown if unit concepts that areneither BaseUnitConcepts or DerivedUnitConcepts are found.
 */
private static Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> _deriveComponentBaseUnitsSeparateExponentsMap(Map<DimensionRepresentativeConcept,List<UnitConcept>> componentUnitsMap,Map<DimensionRepresentativeConcept,Integer> dimensionMap,Map<BaseDimensionRepresentativeConcept,Integer> baseDimensionMap) throws IllegalActionException {
  Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseComponentUnitsSeparateExponents=new HashMap<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]>();
  for (  Map.Entry<DimensionRepresentativeConcept,List<UnitConcept>> componentUnitsMapEntry : componentUnitsMap.entrySet()) {
    DimensionRepresentativeConcept dimension=componentUnitsMapEntry.getKey();
    List<UnitConcept> unitsList=componentUnitsMapEntry.getValue();
    int exponent=dimensionMap.get(dimension).intValue();
    for (    UnitConcept unit : unitsList) {
      if (unit instanceof BaseUnitConcept) {
        Integer baseExponentInteger=baseDimensionMap.get(dimension);
        int baseDimensionMapExponent=0;
        if (baseExponentInteger != null) {
          baseDimensionMapExponent=baseExponentInteger;
        }
        _addBaseUnit(baseComponentUnitsSeparateExponents,(BaseUnitConcept)unit,exponent,baseDimensionMapExponent);
      }
 else       if (unit instanceof DerivedUnitConcept) {
        DerivedDimensionRepresentativeConcept unitDimension=(DerivedDimensionRepresentativeConcept)unit.getDimension();
        Map<DimensionRepresentativeConcept,Integer> unitDimensionMap=unitDimension.getComponentDimensions();
        Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> derivedUnitBaseComponentSeparateExponents=_deriveComponentBaseUnitsSeparateExponentsMap(((DerivedUnitConcept)unit).getComponentUnits(),unitDimensionMap,DerivedDimensionRepresentativeConcept.deriveComponentBaseDimensionsMap(unitDimensionMap));
        _addDerivedUnit(baseComponentUnitsSeparateExponents,derivedUnitBaseComponentSeparateExponents);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  return baseComponentUnitsSeparateExponents;
}","/** 
 * Recursively construct the base component units map for the given component units map and return it. Each value in the map is a two-element array of lists of BaseUnitConcepts that indicate the positive and negative exponent units for the base dimension.
 * @param componentUnitsMap The component units map from which to derivethe base component units map.
 * @param dimensionMap The dimension map for the component units map.
 * @param baseDimensionMap The already calculated base dimension map forthe dimension map input.
 * @return The base component units map with separate lists ofpositive and negative exponent units.
 * @exception IllegalActionException Thrown if unit concepts that areneither BaseUnitConcepts or DerivedUnitConcepts are found.
 */
private static Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> _deriveComponentBaseUnitsSeparateExponentsMap(Map<DimensionRepresentativeConcept,List<UnitConcept>> componentUnitsMap,Map<DimensionRepresentativeConcept,Integer> dimensionMap,Map<BaseDimensionRepresentativeConcept,Integer> baseDimensionMap) throws IllegalActionException {
  Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseComponentUnitsSeparateExponents=new HashMap<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]>();
  for (  Map.Entry<DimensionRepresentativeConcept,List<UnitConcept>> componentUnitsMapEntry : componentUnitsMap.entrySet()) {
    DimensionRepresentativeConcept dimension=componentUnitsMapEntry.getKey();
    List<UnitConcept> unitsList=componentUnitsMapEntry.getValue();
    int exponent=dimensionMap.get(dimension).intValue();
    for (    UnitConcept unit : unitsList) {
      if (unit instanceof BaseUnitConcept) {
        Integer baseExponentInteger=baseDimensionMap.get(dimension);
        int baseDimensionMapExponent=0;
        if (baseExponentInteger != null) {
          baseDimensionMapExponent=baseExponentInteger;
        }
        _addBaseUnit(baseComponentUnitsSeparateExponents,(BaseUnitConcept)unit,exponent,baseDimensionMapExponent);
      }
 else       if (unit instanceof DerivedUnitConcept) {
        DerivedDimensionRepresentativeConcept unitDimension=(DerivedDimensionRepresentativeConcept)unit.getDimension();
        Map<DimensionRepresentativeConcept,Integer> unitDimensionMap=unitDimension.getComponentDimensions();
        Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> derivedUnitBaseComponentSeparateExponents=_deriveComponentBaseUnitsSeparateExponentsMap(((DerivedUnitConcept)unit).getComponentUnits(),unitDimensionMap,DerivedDimensionRepresentativeConcept.deriveComponentBaseDimensionsMap(unitDimensionMap));
        _addDerivedUnit(baseComponentUnitsSeparateExponents,derivedUnitBaseComponentSeparateExponents,exponent);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  return baseComponentUnitsSeparateExponents;
}"
73230,"/** 
 * Check whether the event is safe to process. If the platform time has passed the timestamp of the event minus the delayOffset, then no later events arriving at a sensor/network port can reach the input port group of the event with an earlier timestamp, and the event may be safe-to-process. In multicore, an additional check is required since a currently processing event MAY causally affect the event  (the processing event may eventually cause an event to arrive at the  input port group of the event with an earlier timestamp). A subclass may improve this check (make less conservative) by knowing more about operation of actors and/or tokens of events.
 * @param event Event being checked if it is safe-to-process.
 * @return True if the event is safe-to-process, false otherwise.
 * @exception IllegalActionException If can't get delayOffset for a port.
 */
protected boolean _safeToProcess(PtidesEvent event) throws IllegalActionException {
  double delayOffset;
  if (event.isPureEvent()) {
    delayOffset=Double.POSITIVE_INFINITY;
  }
 else {
    delayOffset=_getDelayOffset((TypedIOPort)event.ioPort());
  }
  Time waitUntilPhysicalTime=event.timeStamp().subtract(delayOffset);
  Tag platformPhysicalTag=getPlatformPhysicalTag(platformTimeClock);
  int compare=platformPhysicalTag.timestamp.compareTo(waitUntilPhysicalTime);
  int microstep=platformPhysicalTag.microstep;
  if ((compare < 0) || compare == 0 && (microstep < event.microstep())) {
    if (_nextRunScheduler == null) {
      _nextRunScheduler=waitUntilPhysicalTime;
    }
 else     if (waitUntilPhysicalTime.compareTo(_nextRunScheduler) < 0) {
      _nextRunScheduler=waitUntilPhysicalTime;
    }
    return false;
  }
  for (  Stack<ProcessingPtidesEvents> coreStack : _currentlyProcessingEvents) {
    for (    ProcessingPtidesEvents processingEvents : coreStack) {
      PtidesEvent processingEvent=processingEvents.events.get(0);
      for (      TypedIOPort groupPort : _inputPortGroups.get((TypedIOPort)event.ioPort())) {
        if (_getSuperdenseDependencyPair((TypedIOPort)processingEvent.ioPort(),groupPort,true) != SuperdenseDependency.OPLUS_IDENTITY) {
          return false;
        }
      }
    }
  }
  return true;
}","/** 
 * Check whether the event is safe to process. If the platform time has passed the timestamp of the event minus the delayOffset, then no later events arriving at a sensor/network port can reach the input port group of the event with an earlier timestamp, and the event may be safe-to-process. In multicore, an additional check is required since a currently processing event MAY causally affect the event  (the processing event may eventually cause an event to arrive at the  input port group of the event with an earlier timestamp). A subclass may improve this check (make less conservative) by knowing more about operation of actors and/or tokens of events.
 * @param event Event being checked if it is safe-to-process.
 * @return True if the event is safe-to-process, false otherwise.
 * @exception IllegalActionException If can't get delayOffset for a port.
 */
protected boolean _safeToProcess(PtidesEvent event) throws IllegalActionException {
  double delayOffset;
  if (event.isPureEvent()) {
    delayOffset=Double.POSITIVE_INFINITY;
  }
 else {
    delayOffset=_getDelayOffset((TypedIOPort)event.ioPort());
  }
  Time waitUntilPhysicalTime=event.timeStamp().subtract(delayOffset);
  Tag platformPhysicalTag=getPlatformPhysicalTag(platformTimeClock);
  int compare=platformPhysicalTag.timestamp.compareTo(waitUntilPhysicalTime);
  int microstep=platformPhysicalTag.microstep;
  if ((compare < 0) || compare == 0 && (microstep < event.microstep())) {
    if (_nextRunScheduler == null) {
      _nextRunScheduler=waitUntilPhysicalTime;
    }
 else     if (waitUntilPhysicalTime.compareTo(_nextRunScheduler) < 0) {
      _nextRunScheduler=waitUntilPhysicalTime;
    }
    return false;
  }
  for (  Stack<ProcessingPtidesEvents> coreStack : _currentlyProcessingEvents) {
    for (    ProcessingPtidesEvents processingEvents : coreStack) {
      PtidesEvent processingEvent=processingEvents.events.get(0);
      if (!_dependencyCheck(processingEvent,event)) {
        return false;
      }
    }
  }
  if (!((BooleanToken)considerTriggerPorts.getToken()).booleanValue()) {
    return true;
  }
  List<PtidesEvent> EDF=new ArrayList<PtidesEvent>(_eventQueue.size());
  for (int i=0; i < _eventQueue.size(); i++) {
    EDF.add(((PtidesListEventQueue)_eventQueue).get(i));
  }
  Collections.sort(EDF,new EDFComparator());
  for (  PtidesEvent earlierEvent : EDF) {
    if (earlierEvent.equals(event)) {
      return true;
    }
    if (!_dependencyCheck(earlierEvent,event)) {
      return false;
    }
  }
  return true;
}"
73231,"/** 
 * Initialize parameters to default values. 
 */
private void _initParameters(){
  try {
    coresForEventProcessing=new Parameter(this,""String_Node_Str"");
    coresForEventProcessing.setExpression(""String_Node_Str"");
    coresForEventProcessing.setTypeEquals(BaseType.INT);
    considerTriggerPorts=new Parameter(this,""String_Node_Str"");
    considerTriggerPorts.setExpression(""String_Node_Str"");
    considerTriggerPorts.setTypeEquals(BaseType.BOOLEAN);
  }
 catch (  KernelException e) {
    throw new InternalErrorException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Initialize parameters to default values. 
 */
private void _initParameters(){
  try {
    coresForEventProcessing=new Parameter(this,""String_Node_Str"");
    coresForEventProcessing.setExpression(""String_Node_Str"");
    coresForEventProcessing.setTypeEquals(BaseType.INT);
    binaryDependencyCheck=new Parameter(this,""String_Node_Str"");
    binaryDependencyCheck.setExpression(""String_Node_Str"");
    binaryDependencyCheck.setTypeEquals(BaseType.BOOLEAN);
    considerTriggerPorts=new Parameter(this,""String_Node_Str"");
    considerTriggerPorts.setExpression(""String_Node_Str"");
    considerTriggerPorts.setTypeEquals(BaseType.BOOLEAN);
  }
 catch (  KernelException e) {
    throw new InternalErrorException(""String_Node_Str"" + e.getMessage());
  }
}"
73232,"/** 
 * For the specified effigy, define the relevant href, target, and class area attributes if the effigy has any open tableaux, and those have frames that implement either HTMLExportable or ImageExportable. As a side effect, this may generate HTML files in the specified directory.
 * @param exporter The exporter.
 * @param effigy The effigy.
 * @param object The Ptolemy II object.
 * @param directory The directory into which to write any HTML.
 * @exception IOException If unable to create required HTML files.
 * @exception PrinterException If unable to create required HTML files.
 * @throws IllegalActionException If something goes wrong.
 */
private void _linkTo(WebExporter exporter,PtolemyEffigy effigy,NamedObj object,File directory) throws IOException, PrinterException, IllegalActionException {
  File gifFile;
  List<Tableau> tableaux=effigy.entityList(Tableau.class);
  if (tableaux.size() > 0) {
    String name=object.getName();
    Frame frame=tableaux.get(0).getFrame();
    if (frame instanceof HTMLExportable) {
      File subDirectory=new File(directory,name);
      if (subDirectory.exists()) {
        if (!subDirectory.isDirectory()) {
          File backupFile=new File(directory,name + ""String_Node_Str"");
          if (!subDirectory.renameTo(backupFile)) {
            throw new IOException(""String_Node_Str"" + subDirectory + ""String_Node_Str""+ backupFile+ ""String_Node_Str"");
          }
        }
      }
 else       if (!subDirectory.mkdir()) {
        throw new IOException(""String_Node_Str"" + subDirectory);
      }
      ((HTMLExportable)frame).writeHTML(subDirectory);
      exporter.defineAreaAttribute(object,""String_Node_Str"",name + ""String_Node_Str"",true);
      boolean usePtWebsite=Boolean.valueOf(StringUtilities.getProperty(""String_Node_Str""));
      if (usePtWebsite) {
        exporter.addContent(""String_Node_Str"",false,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ ExportHTMLAction._getTitleText(object)+ ""String_Node_Str"");
      }
    }
 else     if (frame instanceof ImageExportable) {
      gifFile=new File(directory,name + ""String_Node_Str"");
      OutputStream gifOut=new FileOutputStream(gifFile);
      try {
        ((ImageExportable)frame).writeImage(gifOut,""String_Node_Str"");
      }
  finally {
        gifOut.close();
      }
      exporter.defineAreaAttribute(object,""String_Node_Str"",name + ""String_Node_Str"",true);
      exporter.defineAreaAttribute(object,""String_Node_Str"",""String_Node_Str"",true);
    }
  }
}","/** 
 * For the specified effigy, define the relevant href, target, and class area attributes if the effigy has any open tableaux, and those have frames that implement either HTMLExportable or ImageExportable. As a side effect, this may generate HTML files in the specified directory.
 * @param exporter The exporter.
 * @param effigy The effigy.
 * @param sourceObject The source Ptolemy II object (link from).
 * @param destinationObject The destination object (link to, same as sourceObject,or alternatively, a class definition for sourceObject).
 * @param directory The directory into which to write any HTML.
 * @exception IOException If unable to create required HTML files.
 * @exception PrinterException If unable to create required HTML files.
 * @throws IllegalActionException If something goes wrong.
 */
private void _linkTo(WebExporter exporter,PtolemyEffigy effigy,NamedObj sourceObject,NamedObj destinationObject,File directory) throws IOException, PrinterException, IllegalActionException {
  File gifFile;
  List<Tableau> tableaux=effigy.entityList(Tableau.class);
  if (tableaux.size() > 0) {
    String name=destinationObject.getName();
    Frame frame=tableaux.get(0).getFrame();
    if (frame instanceof HTMLExportable) {
      File subDirectory=new File(directory,name);
      if (subDirectory.exists()) {
        if (!subDirectory.isDirectory()) {
          File backupFile=new File(directory,name + ""String_Node_Str"");
          if (!subDirectory.renameTo(backupFile)) {
            throw new IOException(""String_Node_Str"" + subDirectory + ""String_Node_Str""+ backupFile+ ""String_Node_Str"");
          }
        }
      }
 else       if (!subDirectory.mkdir()) {
        throw new IOException(""String_Node_Str"" + subDirectory);
      }
      ((HTMLExportable)frame).writeHTML(subDirectory);
      exporter.defineAreaAttribute(sourceObject,""String_Node_Str"",name + ""String_Node_Str"",true);
      boolean usePtWebsite=Boolean.valueOf(StringUtilities.getProperty(""String_Node_Str""));
      if (usePtWebsite) {
        exporter.addContent(""String_Node_Str"",false,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ ExportHTMLAction._getTitleText(destinationObject)+ ""String_Node_Str"");
      }
    }
 else     if (frame instanceof ImageExportable) {
      gifFile=new File(directory,name + ""String_Node_Str"");
      OutputStream gifOut=new FileOutputStream(gifFile);
      try {
        ((ImageExportable)frame).writeImage(gifOut,""String_Node_Str"");
      }
  finally {
        gifOut.close();
      }
      exporter.defineAreaAttribute(sourceObject,""String_Node_Str"",name + ""String_Node_Str"",true);
      exporter.defineAreaAttribute(sourceObject,""String_Node_Str"",""String_Node_Str"",true);
    }
  }
}"
73233,"/** 
 * Override the base class to generate a web page or an image file for the specified object, if appropriate, and to provide the href, target, and class attributes to the area attribute associated with the object.
 * @param exporter The exporter.
 * @param object The Ptolemy II object.
 * @throws IllegalActionException If evaluating parameters fails.
 */
protected void _provideOutsideContent(WebExporter exporter,NamedObj object) throws IllegalActionException {
  Map<NamedObj,PtolemyEffigy> openEffigies=new HashMap<NamedObj,PtolemyEffigy>();
  Tableau myTableau=exporter.getFrame().getTableau();
  Effigy myEffigy=(Effigy)myTableau.getContainer();
  List<PtolemyEffigy> effigies=myEffigy.entityList(PtolemyEffigy.class);
  for (  PtolemyEffigy effigy : effigies) {
    openEffigies.put(effigy.getModel(),effigy);
  }
  PtolemyEffigy effigy=openEffigies.get(object);
  if (effigy == null) {
    Effigy candidate=Configuration.findEffigy(object);
    if (candidate instanceof PtolemyEffigy) {
      effigy=(PtolemyEffigy)candidate;
    }
  }
  try {
    if (effigy != null) {
      _linkTo(exporter,effigy,object,exporter.getExportDirectory());
    }
 else {
      if (object instanceof State) {
        try {
          TypedActor[] refinements=((State)object).getRefinement();
          if (refinements != null && refinements.length > 0) {
            effigy=openEffigies.get((NamedObj)refinements[0]);
            if (effigy != null) {
              _linkTo(exporter,effigy,(NamedObj)refinements[0],exporter.getExportDirectory());
            }
          }
        }
 catch (        IllegalActionException e) {
        }
      }
 else       if (object instanceof Instantiable) {
        Instantiable parent=((Instantiable)object).getParent();
        if (parent instanceof NamedObj) {
          Effigy classEffigy=Configuration.findEffigy((NamedObj)parent);
          if (classEffigy instanceof PtolemyEffigy) {
            _linkTo(exporter,(PtolemyEffigy)classEffigy,(NamedObj)parent,exporter.getExportDirectory());
          }
        }
      }
    }
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(this,throwable,""String_Node_Str"");
  }
}","/** 
 * Override the base class to generate a web page or an image file for the specified object, if appropriate, and to provide the href, target, and class attributes to the area attribute associated with the object.
 * @param exporter The exporter.
 * @param object The Ptolemy II object.
 * @throws IllegalActionException If evaluating parameters fails.
 */
protected void _provideOutsideContent(WebExporter exporter,NamedObj object) throws IllegalActionException {
  Map<NamedObj,PtolemyEffigy> openEffigies=new HashMap<NamedObj,PtolemyEffigy>();
  Tableau myTableau=exporter.getFrame().getTableau();
  Effigy myEffigy=(Effigy)myTableau.getContainer();
  List<PtolemyEffigy> effigies=myEffigy.entityList(PtolemyEffigy.class);
  for (  PtolemyEffigy effigy : effigies) {
    openEffigies.put(effigy.getModel(),effigy);
  }
  PtolemyEffigy effigy=openEffigies.get(object);
  if (effigy == null) {
    Effigy candidate=Configuration.findEffigy(object);
    if (candidate instanceof PtolemyEffigy) {
      effigy=(PtolemyEffigy)candidate;
    }
  }
  try {
    if (effigy != null) {
      _linkTo(exporter,effigy,object,object,exporter.getExportDirectory());
    }
 else {
      if (object instanceof State) {
        try {
          TypedActor[] refinements=((State)object).getRefinement();
          if (refinements != null && refinements.length > 0) {
            effigy=openEffigies.get((NamedObj)refinements[0]);
            if (effigy != null) {
              _linkTo(exporter,effigy,(NamedObj)refinements[0],(NamedObj)refinements[0],exporter.getExportDirectory());
            }
          }
        }
 catch (        IllegalActionException e) {
        }
      }
 else       if (object instanceof Instantiable) {
        Instantiable parent=((Instantiable)object).getParent();
        if (parent instanceof NamedObj) {
          if (_exportedClassDefinitions.contains(parent)) {
            exporter.defineAreaAttribute(object,""String_Node_Str"",parent.getName() + ""String_Node_Str"",true);
          }
 else {
            _exportedClassDefinitions.add((NamedObj)parent);
            Effigy classEffigy=Configuration.findEffigy((NamedObj)parent);
            if (classEffigy instanceof PtolemyEffigy) {
              _linkTo(exporter,(PtolemyEffigy)classEffigy,object,(NamedObj)parent,exporter.getExportDirectory());
            }
          }
        }
      }
    }
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(this,throwable,""String_Node_Str"");
  }
}"
73234,"/** 
 * Copy the required files.
 * @throws IllegalActionException If a subclass throws it.
 */
public void provideContent(WebExporter exporter) throws IllegalActionException {
  boolean usePtWebsite=Boolean.valueOf(StringUtilities.getProperty(""String_Node_Str""));
  if (usePtWebsite == true) {
    return;
  }
  String jsDirectoryName=""String_Node_Str"";
  File jsDirectory=FileUtilities.nameToFile(jsDirectoryName,null);
  if (jsDirectory.isDirectory()) {
    File directory=exporter.getExportDirectory();
    File jsTargetDirectory=new File(directory,""String_Node_Str"");
    if (jsTargetDirectory.exists() && !jsTargetDirectory.isDirectory()) {
      jsTargetDirectory.renameTo(new File(directory,""String_Node_Str""));
    }
    if (!jsTargetDirectory.exists() && !jsTargetDirectory.mkdir()) {
      MessageHandler.message(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      for (      String filename : ExportHTMLAction.FILENAMES) {
        try {
          URL lightboxFile=FileUtilities.nameToURL(jsDirectoryName + filename,null,null);
          FileUtilities.binaryCopyURLToFile(lightboxFile,new File(jsTargetDirectory,filename));
        }
 catch (        IOException e) {
          throw new IllegalActionException(this,e,""String_Node_Str"");
        }
      }
    }
  }
}","/** 
 * Copy the required files.
 * @throws IllegalActionException If a subclass throws it.
 */
public void provideContent(WebExporter exporter) throws IllegalActionException {
  boolean usePtWebsite=Boolean.valueOf(StringUtilities.getProperty(""String_Node_Str""));
  if (usePtWebsite == true) {
    return;
  }
  String jsDirectoryName=""String_Node_Str"";
  File jsDirectory=FileUtilities.nameToFile(jsDirectoryName,null);
  if (jsDirectory.isDirectory()) {
    File directory=exporter.getExportDirectory();
    File jsTargetDirectory=new File(directory,""String_Node_Str"");
    if (jsTargetDirectory.exists() && !jsTargetDirectory.isDirectory()) {
      File jsBackupDirectory=new File(directory,""String_Node_Str"");
      if (!jsTargetDirectory.renameTo(jsBackupDirectory)) {
        System.out.println(""String_Node_Str"" + jsTargetDirectory + ""String_Node_Str""+ jsBackupDirectory+ ""String_Node_Str"");
      }
    }
    if (!jsTargetDirectory.exists() && !jsTargetDirectory.mkdir()) {
      MessageHandler.message(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      for (      String filename : ExportHTMLAction.FILENAMES) {
        try {
          URL lightboxFile=FileUtilities.nameToURL(jsDirectoryName + filename,null,null);
          FileUtilities.binaryCopyURLToFile(lightboxFile,new File(jsTargetDirectory,filename));
        }
 catch (        IOException e) {
          throw new IllegalActionException(this,e,""String_Node_Str"");
        }
      }
    }
  }
}"
73235,"/** 
 * Create the image map. As a side effect, this may create other HTML files or subdirectories.
 * @param directory The directory into which to write any HTMLthat is created as a side effect.
 * @throws PrinterException If writing to the toc file fails.
 * @throws IOException If IO fails.
 * @throws IllegalActionException If reading parameters fails.
 */
protected String _createImageMap(File directory) throws IllegalActionException, IOException, PrinterException {
  StringBuffer result=new StringBuffer();
  result.append(""String_Node_Str"");
  List<IconVisibleLocation> iconLocations=_getIconVisibleLocations();
  for (  IconVisibleLocation location : iconLocations) {
    StringBuffer attributeString=new StringBuffer();
    attributeString.append(""String_Node_Str"");
    HashMap<String,String> areaAttributes=_areaAttributes.get(location.object);
    if (areaAttributes != null) {
      for (      String key : areaAttributes.keySet()) {
        String value=areaAttributes.get(key);
        if (value != null && !value.trim().equals(""String_Node_Str"")) {
          attributeString.append(key);
          attributeString.append(""String_Node_Str"");
          attributeString.append(StringUtilities.escapeString(value));
          attributeString.append(""String_Node_Str"");
        }
      }
    }
    result.append(""String_Node_Str"" + (int)location.topLeftX + ""String_Node_Str""+ (int)location.topLeftY+ ""String_Node_Str""+ (int)location.bottomRightX+ ""String_Node_Str""+ (int)location.bottomRightY+ ""String_Node_Str""+ attributeString+ ""String_Node_Str"");
  }
  result.append(""String_Node_Str"");
  return result.toString();
}","/** 
 * Create the image map. As a side effect, this may create other HTML files or subdirectories.
 * @param directory The directory into which to write any HTMLthat is created as a side effect.
 * @throws PrinterException If writing to the toc file fails.
 * @throws IOException If IO fails.
 * @throws IllegalActionException If reading parameters fails.
 */
protected String _createImageMap(File directory) throws IllegalActionException, IOException, PrinterException {
  StringBuffer result=new StringBuffer();
  result.append(""String_Node_Str"");
  List<IconVisibleLocation> iconLocations=_getIconVisibleLocations();
  for (  IconVisibleLocation location : iconLocations) {
    StringBuffer attributeString=new StringBuffer();
    attributeString.append(""String_Node_Str"");
    HashMap<String,String> areaAttributes=_areaAttributes.get(location.object);
    if (areaAttributes != null) {
      for (      Map.Entry<String,String> entry : areaAttributes.entrySet()) {
        String key=entry.getKey();
        String value=entry.getValue();
        if (value != null && !value.trim().equals(""String_Node_Str"")) {
          attributeString.append(key);
          attributeString.append(""String_Node_Str"");
          attributeString.append(StringUtilities.escapeString(value));
          attributeString.append(""String_Node_Str"");
        }
      }
    }
    result.append(""String_Node_Str"" + (int)location.topLeftX + ""String_Node_Str""+ (int)location.topLeftY+ ""String_Node_Str""+ (int)location.bottomRightX+ ""String_Node_Str""+ (int)location.bottomRightY+ ""String_Node_Str""+ attributeString+ ""String_Node_Str"");
  }
  result.append(""String_Node_Str"");
  return result.toString();
}"
73236,"/** 
 * For the specified effigy, define the relevant href, target, and class area attributes if the effigy has any open tableaux, and those have frames that implement either HTMLExportable or ImageExportable. As a side effect, this may generate HTML files in the specified directory.
 * @param exporter The exporter.
 * @param effigy The effigy.
 * @param object The Ptolemy II object.
 * @param directory The directory into which to write any HTML.
 * @exception IOException If unable to create required HTML files.
 * @exception PrinterException If unable to create required HTML files.
 * @throws IllegalActionException If something goes wrong.
 */
private void _linkTo(WebExporter exporter,PtolemyEffigy effigy,NamedObj object,File directory) throws IOException, PrinterException, IllegalActionException {
  File gifFile;
  List<Tableau> tableaux=effigy.entityList(Tableau.class);
  if (tableaux.size() > 0) {
    String name=object.getName();
    Frame frame=tableaux.get(0).getFrame();
    if (frame instanceof HTMLExportable) {
      File subDirectory=new File(directory,name);
      if (subDirectory.exists()) {
        if (!subDirectory.isDirectory()) {
          File backupFile=new File(directory,name + ""String_Node_Str"");
          subDirectory.renameTo(backupFile);
        }
      }
 else       if (!subDirectory.mkdir()) {
        throw new IOException(""String_Node_Str"" + subDirectory);
      }
      ((HTMLExportable)frame).writeHTML(subDirectory);
      exporter.defineAreaAttribute(object,""String_Node_Str"",name + ""String_Node_Str"",true);
      boolean usePtWebsite=Boolean.valueOf(StringUtilities.getProperty(""String_Node_Str""));
      if (usePtWebsite) {
        exporter.addContent(""String_Node_Str"",false,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ ExportHTMLAction._getTitleText(object)+ ""String_Node_Str"");
      }
    }
 else     if (frame instanceof ImageExportable) {
      gifFile=new File(directory,name + ""String_Node_Str"");
      OutputStream gifOut=new FileOutputStream(gifFile);
      try {
        ((ImageExportable)frame).writeImage(gifOut,""String_Node_Str"");
      }
  finally {
        gifOut.close();
      }
      exporter.defineAreaAttribute(object,""String_Node_Str"",name + ""String_Node_Str"",true);
      exporter.defineAreaAttribute(object,""String_Node_Str"",""String_Node_Str"",true);
    }
  }
}","/** 
 * For the specified effigy, define the relevant href, target, and class area attributes if the effigy has any open tableaux, and those have frames that implement either HTMLExportable or ImageExportable. As a side effect, this may generate HTML files in the specified directory.
 * @param exporter The exporter.
 * @param effigy The effigy.
 * @param object The Ptolemy II object.
 * @param directory The directory into which to write any HTML.
 * @exception IOException If unable to create required HTML files.
 * @exception PrinterException If unable to create required HTML files.
 * @throws IllegalActionException If something goes wrong.
 */
private void _linkTo(WebExporter exporter,PtolemyEffigy effigy,NamedObj object,File directory) throws IOException, PrinterException, IllegalActionException {
  File gifFile;
  List<Tableau> tableaux=effigy.entityList(Tableau.class);
  if (tableaux.size() > 0) {
    String name=object.getName();
    Frame frame=tableaux.get(0).getFrame();
    if (frame instanceof HTMLExportable) {
      File subDirectory=new File(directory,name);
      if (subDirectory.exists()) {
        if (!subDirectory.isDirectory()) {
          File backupFile=new File(directory,name + ""String_Node_Str"");
          if (!subDirectory.renameTo(backupFile)) {
            throw new IOException(""String_Node_Str"" + subDirectory + ""String_Node_Str""+ backupFile+ ""String_Node_Str"");
          }
        }
      }
 else       if (!subDirectory.mkdir()) {
        throw new IOException(""String_Node_Str"" + subDirectory);
      }
      ((HTMLExportable)frame).writeHTML(subDirectory);
      exporter.defineAreaAttribute(object,""String_Node_Str"",name + ""String_Node_Str"",true);
      boolean usePtWebsite=Boolean.valueOf(StringUtilities.getProperty(""String_Node_Str""));
      if (usePtWebsite) {
        exporter.addContent(""String_Node_Str"",false,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ ExportHTMLAction._getTitleText(object)+ ""String_Node_Str"");
      }
    }
 else     if (frame instanceof ImageExportable) {
      gifFile=new File(directory,name + ""String_Node_Str"");
      OutputStream gifOut=new FileOutputStream(gifFile);
      try {
        ((ImageExportable)frame).writeImage(gifOut,""String_Node_Str"");
      }
  finally {
        gifOut.close();
      }
      exporter.defineAreaAttribute(object,""String_Node_Str"",name + ""String_Node_Str"",true);
      exporter.defineAreaAttribute(object,""String_Node_Str"",""String_Node_Str"",true);
    }
  }
}"
73237,"/** 
 * Override the base class to generate a web page or an image file for the specified object, if appropriate, and to provide the href, target, and class attributes to the area attribute associated with the object.
 * @param exporter The exporter.
 * @param object The Ptolemy II object.
 * @throws IllegalActionException If evaluating parameters fails.
 */
protected void _provideOutsideContent(WebExporter exporter,NamedObj object) throws IllegalActionException {
  Map<NamedObj,PtolemyEffigy> openEffigies=new HashMap<NamedObj,PtolemyEffigy>();
  Tableau myTableau=exporter.getFrame().getTableau();
  Effigy myEffigy=(Effigy)myTableau.getContainer();
  List<PtolemyEffigy> effigies=myEffigy.entityList(PtolemyEffigy.class);
  for (  PtolemyEffigy effigy : effigies) {
    openEffigies.put(effigy.getModel(),effigy);
  }
  PtolemyEffigy effigy=openEffigies.get(object);
  if (effigy == null) {
    Effigy candidate=Configuration.findEffigy(object);
    if (candidate instanceof PtolemyEffigy) {
      effigy=(PtolemyEffigy)candidate;
    }
  }
  try {
    if (effigy != null) {
      _linkTo(exporter,effigy,object,exporter.getExportDirectory());
    }
 else {
      if (object instanceof State) {
        try {
          TypedActor[] refinements=((State)object).getRefinement();
          if (refinements != null && refinements.length > 0) {
            effigy=openEffigies.get((NamedObj)refinements[0]);
            if (effigy != null) {
              _linkTo(exporter,effigy,(NamedObj)refinements[0],exporter.getExportDirectory());
            }
          }
        }
 catch (        IllegalActionException e) {
        }
      }
 else       if (object instanceof Instantiable) {
        Instantiable parent=((Instantiable)object).getParent();
        if (parent instanceof NamedObj) {
          Effigy classEffigy=Configuration.findEffigy((NamedObj)parent);
          if (classEffigy instanceof PtolemyEffigy) {
            _linkTo(exporter,(PtolemyEffigy)classEffigy,(NamedObj)parent,exporter.getExportDirectory());
          }
        }
      }
    }
  }
 catch (  Exception exception) {
    throw new IllegalActionException(this,exception,""String_Node_Str"");
  }
}","/** 
 * Override the base class to generate a web page or an image file for the specified object, if appropriate, and to provide the href, target, and class attributes to the area attribute associated with the object.
 * @param exporter The exporter.
 * @param object The Ptolemy II object.
 * @throws IllegalActionException If evaluating parameters fails.
 */
protected void _provideOutsideContent(WebExporter exporter,NamedObj object) throws IllegalActionException {
  Map<NamedObj,PtolemyEffigy> openEffigies=new HashMap<NamedObj,PtolemyEffigy>();
  Tableau myTableau=exporter.getFrame().getTableau();
  Effigy myEffigy=(Effigy)myTableau.getContainer();
  List<PtolemyEffigy> effigies=myEffigy.entityList(PtolemyEffigy.class);
  for (  PtolemyEffigy effigy : effigies) {
    openEffigies.put(effigy.getModel(),effigy);
  }
  PtolemyEffigy effigy=openEffigies.get(object);
  if (effigy == null) {
    Effigy candidate=Configuration.findEffigy(object);
    if (candidate instanceof PtolemyEffigy) {
      effigy=(PtolemyEffigy)candidate;
    }
  }
  try {
    if (effigy != null) {
      _linkTo(exporter,effigy,object,exporter.getExportDirectory());
    }
 else {
      if (object instanceof State) {
        try {
          TypedActor[] refinements=((State)object).getRefinement();
          if (refinements != null && refinements.length > 0) {
            effigy=openEffigies.get((NamedObj)refinements[0]);
            if (effigy != null) {
              _linkTo(exporter,effigy,(NamedObj)refinements[0],exporter.getExportDirectory());
            }
          }
        }
 catch (        IllegalActionException e) {
        }
      }
 else       if (object instanceof Instantiable) {
        Instantiable parent=((Instantiable)object).getParent();
        if (parent instanceof NamedObj) {
          Effigy classEffigy=Configuration.findEffigy((NamedObj)parent);
          if (classEffigy instanceof PtolemyEffigy) {
            _linkTo(exporter,(PtolemyEffigy)classEffigy,(NamedObj)parent,exporter.getExportDirectory());
          }
        }
      }
    }
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(this,throwable,""String_Node_Str"");
  }
}"
73238,"/** 
 * Provide default content to the specified web exporter to be included in a web page for the container of this object for objects that do not override onmouseover. This class provides an area attribute of type ""onmouseover"" that displays the parameter values of the object and one of type ""onmouseout"" that clears that display.
 * @param exporter The exporter to which to provide the content.
 * @param object The object which provides the content.
 * @throws IllegalActionException If evaluating the valueof this parameter fails.
 */
public static void provideDefaultOutsideContent(WebExporter exporter,NamedObj object) throws IllegalActionException {
  if (object == null) {
    return;
  }
  String command=""String_Node_Str"" + object.getName() + ""String_Node_Str""+ getParameterTable(object).toString()+ ""String_Node_Str"";
  if (exporter.defineAreaAttribute(object,""String_Node_Str"",command,false)) {
    String clear=""String_Node_Str"" + ""String_Node_Str"";
    exporter.defineAreaAttribute(object,""String_Node_Str"",clear,false);
    exporter.addContent(""String_Node_Str"",true,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    exporter.addContent(""String_Node_Str"",true,""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Provide default content to the specified web exporter to be included in a web page for the container of this object for objects that do not override onmouseover. This class provides an area attribute of type ""onmouseover"" that displays the parameter values of the object and one of type ""onmouseout"" that clears that display.
 * @param exporter The exporter to which to provide the content.
 * @param object The object which provides the content.
 * @throws IllegalActionException If evaluating the valueof this parameter fails.
 */
public static void provideDefaultOutsideContent(WebExporter exporter,NamedObj object) throws IllegalActionException {
  if (object == null) {
    return;
  }
  String command=""String_Node_Str"" + object.getName() + ""String_Node_Str""+ getParameterTable(object)+ ""String_Node_Str"";
  if (exporter.defineAreaAttribute(object,""String_Node_Str"",command,false)) {
    String clear=""String_Node_Str"" + ""String_Node_Str"";
    exporter.defineAreaAttribute(object,""String_Node_Str"",clear,false);
    exporter.addContent(""String_Node_Str"",true,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    exporter.addContent(""String_Node_Str"",true,""String_Node_Str"" + ""String_Node_Str"");
  }
}"
73239,"/** 
 * Return an event which is safe-to-process and should be processed next. If no such event exists, null is returned. In this implementation, the event that should be processed next is the safe-to-process event that is earliest in <absolute deadline, tag, microstep, depth> lexical  ordering. Note that this method does not modify the event queue.
 * @return Safe event to process.
 * @exception IllegalActionException 
 */
protected PtidesEvent _getNextSafeEvent() throws IllegalActionException {
  _nextRunScheduler=null;
  List<PtidesEvent> EDF=new ArrayList<PtidesEvent>(_eventQueue.size());
  for (int i=0; i < _eventQueue.size(); i++) {
    EDF.add(((PtidesListEventQueue)_eventQueue).get(i));
  }
  Collections.sort(EDF,new EDFComparator());
  for (  PtidesEvent event : EDF) {
    if (_safeToProcess(event)) {
      for (int i=0; i < _eventQueue.size(); i++) {
        if (((PtidesListEventQueue)_eventQueue).get(i).equals(event)) {
          _peekingIndex=i;
        }
      }
      return event;
    }
  }
  if (_nextRunScheduler != null) {
    _debug(""String_Node_Str"" + _nextRunScheduler);
    _fireAtPlatformTime(_nextRunScheduler,platformTimeClock);
  }
  return null;
}","/** 
 * Return an event which is safe-to-process and should be processed next. If no such event exists, null is returned. In this implementation, the event that should be processed next is the safe-to-process event that is earliest in <absolute deadline, tag, microstep, depth> lexical  ordering. Note that this method does not modify the event queue.
 * @return Safe event to process.
 * @exception IllegalActionException 
 */
protected PtidesEvent _getNextSafeEvent() throws IllegalActionException {
  _nextRunScheduler=null;
  List<PtidesEvent> EDF=new ArrayList<PtidesEvent>(_eventQueue.size());
  for (int i=0; i < _eventQueue.size(); i++) {
    EDF.add(((PtidesListEventQueue)_eventQueue).get(i));
  }
  Collections.sort(EDF,new EDFComparator());
  for (  PtidesEvent event : EDF) {
    if (_safeToProcess(event)) {
      for (int i=0; i < _eventQueue.size(); i++) {
        if (((PtidesListEventQueue)_eventQueue).get(i).equals(event)) {
          _peekingIndex=i;
          break;
        }
      }
      return event;
    }
  }
  if (_nextRunScheduler != null) {
    _debug(""String_Node_Str"" + _nextRunScheduler);
    _fireAtPlatformTime(_nextRunScheduler,platformTimeClock);
  }
  return null;
}"
73240,"/** 
 * Decide whether an event should begin processing at the provided execution time, and if so, what event and core. To process an  event, all events with the same tag and destination input port group are removed from the event queue, and added to the  _currentlyProcessingEvents stack for the core being processed on. This method is responsible for taking overhead execution times into account.
 * @param executionPhysicalTag Current execution physical time.
 * @exception IllegalActionException 
 */
protected void _runScheduler(Tag executionPhysicalTag) throws IllegalActionException {
  _debug(""String_Node_Str"" + executionPhysicalTag);
  PtidesEvent nextEvent=_getNextSafeEvent();
  _debug(""String_Node_Str"" + nextEvent);
  if (nextEvent == null) {
    return;
  }
  Stack<ProcessingPtidesEvents> coreToProcessOn=null;
  for (  Stack<ProcessingPtidesEvents> coreStack : _currentlyProcessingEvents) {
    if (coreStack.size() == 0) {
      coreToProcessOn=coreStack;
      break;
    }
  }
  if (coreToProcessOn == null) {
    return;
  }
  _debug(""String_Node_Str"" + nextEvent + ""String_Node_Str""+ _currentlyProcessingEvents.indexOf(coreToProcessOn));
  List<PtidesEvent> eventList=_takeAllSameTagEventsFromQueue(nextEvent);
  double executionTime=_getExecutionTime(nextEvent.ioPort(),nextEvent.actor());
  Time finishTime=executionPhysicalTag.timestamp;
  finishTime.add(executionTime);
  ProcessingPtidesEvents events=new ProcessingPtidesEvents(eventList,executionPhysicalTag,finishTime);
  coreToProcessOn.push(events);
}","/** 
 * Decide whether an event should begin processing at the provided execution time, and if so, what event and core. To process an  event, all events with the same tag and destination input port group are removed from the event queue, and added to the  _currentlyProcessingEvents stack for the core being processed on. This method is responsible for taking overhead execution times into account.
 * @param executionPhysicalTag Current execution physical time.
 * @exception IllegalActionException 
 */
protected void _runScheduler(Tag executionPhysicalTag) throws IllegalActionException {
  _debug(""String_Node_Str"" + executionPhysicalTag);
  PtidesEvent nextEvent=_getNextSafeEvent();
  while (nextEvent != null) {
    _debug(""String_Node_Str"" + nextEvent);
    Stack<ProcessingPtidesEvents> coreToProcessOn=null;
    for (    Stack<ProcessingPtidesEvents> coreStack : _currentlyProcessingEvents) {
      if (coreStack.size() == 0) {
        _debug(""String_Node_Str"");
        coreToProcessOn=coreStack;
        break;
      }
    }
    if (coreToProcessOn == null) {
      _debug(""String_Node_Str"");
      return;
    }
    _debug(""String_Node_Str"" + nextEvent.actor() + ""String_Node_Str""+ _currentlyProcessingEvents.indexOf(coreToProcessOn));
    List<PtidesEvent> eventList=_takeAllSameTagEventsFromQueue(nextEvent);
    Time executionTime=new Time(this,_getExecutionTime(nextEvent.ioPort(),nextEvent.actor()));
    Time finishTime=executionPhysicalTag.timestamp.add(executionTime);
    _debug(executionPhysicalTag.timestamp + ""String_Node_Str"" + executionTime+ ""String_Node_Str""+ finishTime);
    ProcessingPtidesEvents events=new ProcessingPtidesEvents(eventList,executionPhysicalTag,finishTime);
    coreToProcessOn.push(events);
    _sendExecutionTimeEvent(nextEvent.actor(),executionPhysicalTag.timestamp.getDoubleValue(),ExecutionEventType.START,_currentlyProcessingEvents.indexOf(coreToProcessOn));
    nextEvent=_getNextSafeEvent();
  }
}"
73241,"/** 
 * Calculate the superdense dependency (minimum model time delay) between a source input port and the input port group of a destination input  port. The Floyd-Warshall algorithm is used to calculate the minimum  model time delay paths.
 * @exception IllegalActionException If the container is not aTypedCompositeActor. 
 */
protected void _calculateSuperdenseDependenices() throws IllegalActionException {
  if (!(getContainer() instanceof TypedCompositeActor)) {
    throw new IllegalActionException(getContainer(),getContainer().getFullName() + ""String_Node_Str"");
  }
  _superdenseDependencyPair=new HashMap<TypedIOPort,Map<TypedIOPort,SuperdenseDependency>>();
  List<TypedIOPort> inputPorts=new ArrayList<TypedIOPort>();
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)getContainer()).deepEntityList()) {
    CausalityInterface actorCausality=actor.getCausalityInterface();
    for (    TypedIOPort inputPort : (List<TypedIOPort>)(actor.inputPortList())) {
      _superdenseDependencyPair.put(inputPort,new HashMap<TypedIOPort,SuperdenseDependency>());
      inputPorts.add(inputPort);
      _putSuperdenseDependencyPair(inputPort,inputPort,SuperdenseDependency.OTIMES_IDENTITY);
      for (      TypedIOPort outputPort : (List<TypedIOPort>)(actor.outputPortList())) {
        SuperdenseDependency minDelay=(SuperdenseDependency)actorCausality.getDependency(inputPort,outputPort);
        if (!minDelay.equals(SuperdenseDependency.OPLUS_IDENTITY)) {
          for (          TypedIOPort connectedPort : (List<TypedIOPort>)outputPort.connectedPortList()) {
            if (connectedPort.isInput()) {
              _putSuperdenseDependencyPair(inputPort,connectedPort,minDelay);
            }
          }
        }
 else {
        }
      }
    }
  }
  for (  TypedIOPort k : inputPorts) {
    for (    TypedIOPort i : inputPorts) {
      for (      TypedIOPort j : inputPorts) {
        SuperdenseDependency ij, ik, kj;
        ij=_getSuperdenseDependencyPair(i,j);
        ik=_getSuperdenseDependencyPair(i,k);
        kj=_getSuperdenseDependencyPair(k,j);
        if (ij.compareTo(ik.oTimes(kj)) == SuperdenseDependency.GREATER_THAN) {
          _putSuperdenseDependencyPair(i,j,(SuperdenseDependency)ik.oTimes(kj));
        }
      }
    }
  }
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)getContainer()).deepEntityList()) {
    CausalityInterface actorCausality=actor.getCausalityInterface();
    for (    TypedIOPort outputPort : (List<TypedIOPort>)(actor.outputPortList())) {
      Set<TypedIOPort> inputPortGroup=new HashSet<TypedIOPort>();
      for (      TypedIOPort inputPort : (List<TypedIOPort>)(actor.inputPortList())) {
        SuperdenseDependency minDelay=(SuperdenseDependency)actorCausality.getDependency(inputPort,outputPort);
        if (!minDelay.equals(SuperdenseDependency.OPLUS_IDENTITY)) {
          inputPortGroup.add(inputPort);
        }
      }
      for (      TypedIOPort srcPort : inputPorts) {
        SuperdenseDependency min=SuperdenseDependency.OPLUS_IDENTITY;
        for (        TypedIOPort destPort : inputPortGroup) {
          min=(SuperdenseDependency)min.oPlus(_getSuperdenseDependencyPair(srcPort,destPort));
        }
        if (!min.equals(SuperdenseDependency.OPLUS_IDENTITY)) {
          for (          TypedIOPort destPort : inputPortGroup) {
            _putSuperdenseDependencyPair(srcPort,destPort,min);
          }
        }
      }
    }
  }
  if (_debugging) {
    StringBuffer buf=new StringBuffer();
    buf.append(""String_Node_Str"");
    for (    TypedIOPort srcPort : inputPorts) {
      buf.append(srcPort.getName(getContainer()) + ""String_Node_Str"");
    }
    _debug(buf.toString());
    for (    TypedIOPort srcPort : inputPorts) {
      buf=new StringBuffer();
      buf.append(srcPort.getName(getContainer()) + ""String_Node_Str"");
      for (      TypedIOPort destPort : inputPorts) {
        buf.append(_getSuperdenseDependencyPair(srcPort,destPort).timeValue() + ""String_Node_Str"" + _getSuperdenseDependencyPair(srcPort,destPort).indexValue()+ ""String_Node_Str"");
      }
      _debug(buf.toString());
    }
  }
}","/** 
 * Calculate the superdense dependency (minimum model time delay) between a source input port and the input port group of a destination input  port. The Floyd-Warshall algorithm is used to calculate the minimum  model time delay paths.
 * @exception IllegalActionException If the container is not aTypedCompositeActor. 
 */
protected void _calculateSuperdenseDependenices() throws IllegalActionException {
  if (!(getContainer() instanceof TypedCompositeActor)) {
    throw new IllegalActionException(getContainer(),getContainer().getFullName() + ""String_Node_Str"");
  }
  _superdenseDependencyPair=new HashMap<TypedIOPort,Map<TypedIOPort,SuperdenseDependency>>();
  List<TypedIOPort> inputPorts=new ArrayList<TypedIOPort>();
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)getContainer()).deepEntityList()) {
    CausalityInterface actorCausality=actor.getCausalityInterface();
    for (    TypedIOPort inputPort : (List<TypedIOPort>)(actor.inputPortList())) {
      if (!inputPort.isOutsideConnected()) {
        continue;
      }
      _superdenseDependencyPair.put(inputPort,new HashMap<TypedIOPort,SuperdenseDependency>());
      inputPorts.add(inputPort);
      _putSuperdenseDependencyPair(inputPort,inputPort,SuperdenseDependency.OTIMES_IDENTITY);
      for (      TypedIOPort outputPort : (List<TypedIOPort>)(actor.outputPortList())) {
        SuperdenseDependency minDelay=(SuperdenseDependency)actorCausality.getDependency(inputPort,outputPort);
        if (!minDelay.equals(SuperdenseDependency.OPLUS_IDENTITY)) {
          for (          TypedIOPort connectedPort : (List<TypedIOPort>)outputPort.deepConnectedPortList()) {
            if (connectedPort.isInput()) {
              _putSuperdenseDependencyPair(inputPort,connectedPort,minDelay);
            }
          }
        }
 else {
        }
      }
    }
  }
  for (  TypedIOPort k : inputPorts) {
    for (    TypedIOPort i : inputPorts) {
      for (      TypedIOPort j : inputPorts) {
        SuperdenseDependency ij, ik, kj;
        ij=_getSuperdenseDependencyPair(i,j);
        ik=_getSuperdenseDependencyPair(i,k);
        kj=_getSuperdenseDependencyPair(k,j);
        if (ij.compareTo(ik.oTimes(kj)) == SuperdenseDependency.GREATER_THAN) {
          _putSuperdenseDependencyPair(i,j,(SuperdenseDependency)ik.oTimes(kj));
        }
      }
    }
  }
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)getContainer()).deepEntityList()) {
    CausalityInterface actorCausality=actor.getCausalityInterface();
    for (    TypedIOPort outputPort : (List<TypedIOPort>)(actor.outputPortList())) {
      Set<TypedIOPort> inputPortGroup=new HashSet<TypedIOPort>();
      for (      TypedIOPort inputPort : (List<TypedIOPort>)(actor.inputPortList())) {
        SuperdenseDependency minDelay=(SuperdenseDependency)actorCausality.getDependency(inputPort,outputPort);
        if (!minDelay.equals(SuperdenseDependency.OPLUS_IDENTITY)) {
          inputPortGroup.add(inputPort);
        }
      }
      for (      TypedIOPort srcPort : inputPorts) {
        SuperdenseDependency min=SuperdenseDependency.OPLUS_IDENTITY;
        for (        TypedIOPort destPort : inputPortGroup) {
          min=(SuperdenseDependency)min.oPlus(_getSuperdenseDependencyPair(srcPort,destPort));
        }
        if (!min.equals(SuperdenseDependency.OPLUS_IDENTITY)) {
          for (          TypedIOPort destPort : inputPortGroup) {
            _putSuperdenseDependencyPair(srcPort,destPort,min);
          }
        }
      }
    }
  }
  if (_debugging) {
    StringBuffer buf=new StringBuffer();
    buf.append(""String_Node_Str"");
    for (    TypedIOPort srcPort : inputPorts) {
      buf.append(srcPort.getName(getContainer()) + ""String_Node_Str"");
    }
    _debug(buf.toString());
    for (    TypedIOPort srcPort : inputPorts) {
      buf=new StringBuffer();
      buf.append(srcPort.getName(getContainer()) + ""String_Node_Str"");
      for (      TypedIOPort destPort : inputPorts) {
        buf.append(_getSuperdenseDependencyPair(srcPort,destPort).timeValue() + ""String_Node_Str"" + _getSuperdenseDependencyPair(srcPort,destPort).indexValue()+ ""String_Node_Str"");
      }
      _debug(buf.toString());
    }
  }
}"
73242,"/** 
 * Return the actor to fire in this iteration, or null if no actor should be fired. To simulate execution time, an event may be marked as being processed, but the actor is only fired when execution time expires. This is based on the assumption that an actor only produces events when it is done firing, not during firing. Since _checkForNextEvent() always returns true, this method will keep being called until it returns null.  
 * @exception IllegalActionException If getPlatformPhysicalTag() throws it.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  Tag executionPhysicalTag=getPlatformPhysicalTag(executionTimeClock);
  _runScheduler(executionPhysicalTag);
  Time nextFinishTime=null;
  for (  Stack<ProcessingPtidesEvents> coreStack : _currentlyProcessingEvents) {
    if (coreStack.size() != 0) {
      ProcessingPtidesEvents processingEvent=coreStack.peek();
      int compare=processingEvent.finishTime.compareTo(executionPhysicalTag.timestamp);
      if (compare == 0) {
        PtidesEvent eventToFire=processingEvent.events.get(0);
        setTag(eventToFire.timeStamp(),eventToFire.microstep());
        coreStack.pop();
        _saveEventInformation(processingEvent.events);
        _lastActorFired=eventToFire.actor();
        _lastExecutionTime=executionPhysicalTag.timestamp;
        return eventToFire.actor();
      }
 else       if (compare < 0) {
        throw new IllegalActionException(this,""String_Node_Str"" + processingEvent);
      }
 else {
        if (nextFinishTime == null) {
          nextFinishTime=processingEvent.finishTime;
        }
 else         if (processingEvent.finishTime.compareTo(nextFinishTime) < 0) {
          nextFinishTime=processingEvent.finishTime;
        }
      }
    }
  }
  if (nextFinishTime != null) {
    _fireAtPlatformTime(nextFinishTime,executionTimeClock);
  }
  return null;
}","/** 
 * Return the actor to fire in this iteration, or null if no actor should be fired. To simulate execution time, an event may be marked as being processed, but the actor is only fired when execution time expires. This is based on the assumption that an actor only produces events when it is done firing, not during firing. Since _checkForNextEvent() always returns true, this method will keep being called until it returns null.  
 * @exception IllegalActionException If getPlatformPhysicalTag() throws it.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  Tag executionPhysicalTag=getPlatformPhysicalTag(executionTimeClock);
  _runScheduler(executionPhysicalTag);
  Time nextFinishTime=null;
  for (int i=0; i < _currentlyProcessingEvents.size(); i++) {
    Stack<ProcessingPtidesEvents> coreStack=_currentlyProcessingEvents.get(i);
    if (coreStack.size() != 0) {
      ProcessingPtidesEvents processingEvent=coreStack.peek();
      int compare=processingEvent.finishTime.compareTo(executionPhysicalTag.timestamp);
      if (compare == 0) {
        PtidesEvent eventToFire=processingEvent.events.get(0);
        setTag(eventToFire.timeStamp(),eventToFire.microstep());
        coreStack.pop();
        _sendExecutionTimeEvent(eventToFire.actor(),executionPhysicalTag.timestamp.getDoubleValue(),ExecutionEventType.STOP,i);
        _saveEventInformation(processingEvent.events);
        _lastActorFired=eventToFire.actor();
        _lastExecutionTime=executionPhysicalTag.timestamp;
        return eventToFire.actor();
      }
 else       if (compare < 0) {
        throw new IllegalActionException(this,""String_Node_Str"" + processingEvent);
      }
 else {
        if (nextFinishTime == null) {
          nextFinishTime=processingEvent.finishTime;
        }
 else         if (processingEvent.finishTime.compareTo(nextFinishTime) < 0) {
          nextFinishTime=processingEvent.finishTime;
        }
      }
    }
  }
  if (nextFinishTime != null) {
    _debug(""String_Node_Str"" + nextFinishTime);
    _fireAtPlatformTime(nextFinishTime,executionTimeClock);
  }
  return null;
}"
73243,"/** 
 * Return an enabled transition among the given list of transitions for which both the guard expression and the output actions can be evaluated (the inputs referred by these are known). If there is only one transition enabled, return that transition. In case there are multiple enabled transitions, if any of them is not marked nondeterministic, throw an exception. Otherwise, randomly choose one from the enabled transitions and return it if the output actions can be evaluated. Execute the output actions contained by the returned transition before returning. Also, fire the transition refinements, if any. <p> After calling this method, you can call foundUnknown() to determine whether any guard expressions or output value expressions on a transition whose guard evaluates to true were found in the specified transition list that referred to input ports that are not currently known.
 * @param currentState The state from which transitions are examined.
 * @param transitionList A list of transitions.
 * @param immediateOnly True to consider only immediate transitions.
 * @return An enabled transition, or null if none is enabled.
 * @exception IllegalActionException If there is more than onetransition enabled and not all of them are nondeterministic.
 */
protected Transition _chooseTransition(State currentState,List transitionList,boolean immediateOnly) throws IllegalActionException {
  List<Transition> enabledTransitions=enabledTransitions(transitionList,immediateOnly);
  int numberOfEnabledTransitions=enabledTransitions.size();
  Transition chosenTransition=null;
  if (numberOfEnabledTransitions == 1) {
    chosenTransition=(Transition)enabledTransitions.get(0);
  }
 else   if (numberOfEnabledTransitions > 1) {
    for (    Transition enabledTransition : enabledTransitions) {
      if (!enabledTransition.isNondeterministic()) {
        throw new MultipleEnabledTransitionsException(currentState,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + enabledTransition.getName() + ""String_Node_Str"");
      }
    }
    if (_transitionsPreviouslyChosenInIteration.size() > 0) {
      for (      Transition previouslyChosenTransition : _transitionsPreviouslyChosenInIteration) {
        if (enabledTransitions.contains(previouslyChosenTransition)) {
          chosenTransition=previouslyChosenTransition;
        }
      }
    }
    if (chosenTransition == null) {
      while (enabledTransitions.size() > 0) {
        int randomChoice=(int)Math.floor(Math.random() * numberOfEnabledTransitions);
        if (randomChoice == numberOfEnabledTransitions) {
          randomChoice--;
        }
        chosenTransition=(Transition)enabledTransitions.get(randomChoice);
        if (_referencedInputPortsByOutputKnown(chosenTransition)) {
          _foundUnknown=true;
          break;
        }
 else {
          enabledTransitions.remove(chosenTransition);
          chosenTransition=null;
        }
      }
      _transitionsPreviouslyChosenInIteration.add(chosenTransition);
    }
  }
  if (chosenTransition != null) {
    if (_debugging) {
      _debug(""String_Node_Str"",chosenTransition.getFullName());
    }
    Iterator actions=chosenTransition.choiceActionList().iterator();
    while (actions.hasNext()) {
      Action action=(Action)actions.next();
      action.execute();
    }
    Actor[] transitionRefinements=chosenTransition.getRefinement();
    if (transitionRefinements != null) {
      for (int i=0; i < transitionRefinements.length; ++i) {
        if (_stopRequested || _disabledRefinements.contains(transitionRefinements[i])) {
          break;
        }
        if (_debugging) {
          _debug(""String_Node_Str"",transitionRefinements[i].getName());
        }
        if (transitionRefinements[i].prefire()) {
          transitionRefinements[i].fire();
          _transitionRefinementsToPostfire.add(transitionRefinements[i]);
        }
      }
    }
    if (_areAllImmediateTransitionsDisabled(chosenTransition.destinationState()) && currentState.getRefinement() == null) {
      List<IOPort> outputs=outputPortList();
      for (      IOPort port : outputs) {
        for (int channel=0; channel < port.getWidth(); channel++) {
          if (!port.isKnown(channel)) {
            port.send(channel,null);
          }
        }
      }
    }
    _lastChosenTransitions.put(currentState,chosenTransition);
  }
  return chosenTransition;
}","/** 
 * Return an enabled transition among the given list of transitions for which both the guard expression and the output actions can be evaluated (the inputs referred by these are known). If there is only one transition enabled, return that transition. In case there are multiple enabled transitions, if any of them is not marked nondeterministic, throw an exception. Otherwise, randomly choose one from the enabled transitions and return it if the output actions can be evaluated. Execute the output actions contained by the returned transition before returning. Also, fire the transition refinements, if any. <p> After calling this method, you can call foundUnknown() to determine whether any guard expressions or output value expressions on a transition whose guard evaluates to true were found in the specified transition list that referred to input ports that are not currently known.
 * @param currentState The state from which transitions are examined.
 * @param transitionList A list of transitions.
 * @param immediateOnly True to consider only immediate transitions.
 * @return An enabled transition, or null if none is enabled.
 * @exception IllegalActionException If there is more than onetransition enabled and not all of them are nondeterministic.
 */
protected Transition _chooseTransition(State currentState,List transitionList,boolean immediateOnly) throws IllegalActionException {
  List<Transition> enabledTransitions=enabledTransitions(transitionList,immediateOnly);
  int numberOfEnabledTransitions=enabledTransitions.size();
  Transition chosenTransition=null;
  if (numberOfEnabledTransitions == 1) {
    chosenTransition=(Transition)enabledTransitions.get(0);
    _transitionsPreviouslyChosenInIteration.add(chosenTransition);
  }
 else   if (numberOfEnabledTransitions > 1) {
    for (    Transition enabledTransition : enabledTransitions) {
      if (!enabledTransition.isNondeterministic()) {
        throw new MultipleEnabledTransitionsException(currentState,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + enabledTransition.getName() + ""String_Node_Str"");
      }
    }
    if (_transitionsPreviouslyChosenInIteration.size() > 0) {
      for (      Transition previouslyChosenTransition : _transitionsPreviouslyChosenInIteration) {
        if (enabledTransitions.contains(previouslyChosenTransition)) {
          chosenTransition=previouslyChosenTransition;
        }
      }
    }
    if (chosenTransition == null) {
      while (enabledTransitions.size() > 0) {
        int randomChoice=(int)Math.floor(Math.random() * numberOfEnabledTransitions);
        if (randomChoice == numberOfEnabledTransitions) {
          randomChoice--;
        }
        chosenTransition=(Transition)enabledTransitions.get(randomChoice);
        if (_referencedInputPortsByOutputKnown(chosenTransition)) {
          _foundUnknown=true;
          break;
        }
 else {
          enabledTransitions.remove(chosenTransition);
          chosenTransition=null;
        }
      }
      _transitionsPreviouslyChosenInIteration.add(chosenTransition);
    }
  }
  if (chosenTransition != null) {
    if (_debugging) {
      _debug(""String_Node_Str"",chosenTransition.getFullName());
    }
    Iterator actions=chosenTransition.choiceActionList().iterator();
    while (actions.hasNext()) {
      Action action=(Action)actions.next();
      action.execute();
    }
    Actor[] transitionRefinements=chosenTransition.getRefinement();
    if (transitionRefinements != null) {
      for (int i=0; i < transitionRefinements.length; ++i) {
        if (_stopRequested || _disabledRefinements.contains(transitionRefinements[i])) {
          break;
        }
        if (_debugging) {
          _debug(""String_Node_Str"",transitionRefinements[i].getName());
        }
        if (transitionRefinements[i].prefire()) {
          transitionRefinements[i].fire();
          _transitionRefinementsToPostfire.add(transitionRefinements[i]);
        }
      }
    }
    if (_areAllImmediateTransitionsDisabled(chosenTransition.destinationState()) && currentState.getRefinement() == null) {
      List<IOPort> outputs=outputPortList();
      for (      IOPort port : outputs) {
        for (int channel=0; channel < port.getWidth(); channel++) {
          if (!port.isKnown(channel)) {
            port.send(channel,null);
          }
        }
      }
    }
    _lastChosenTransitions.put(currentState,chosenTransition);
  }
  return chosenTransition;
}"
73244,"/** 
 * Set the values of input variables. Choose the enabled transition among the outgoing transitions of the current state. Throw an exception if there is more than one transition enabled. Otherwise, execute the output actions contained by the chosen transition.
 * @exception IllegalActionException If there is more than onetransition enabled.
 */
public void fire() throws IllegalActionException {
  Time environmentTime=_getEnvironmentTime();
  Director director=getDirector();
  boolean inModalModel=false;
  if (director instanceof FSMDirector) {
    inModalModel=true;
    director.setModelTime(environmentTime);
  }
  readInputs();
  _lastChosenTransitions.clear();
  _transitionRefinementsToPostfire.clear();
  _stateRefinementsToPostfire.clear();
  List<Transition> transitionList=_currentState.preemptiveTransitionList();
  _chooseTransitions(transitionList,false);
  if (_lastChosenTransitions.size() > 0) {
    if (inModalModel) {
      director.setModelTime(environmentTime);
    }
    TypedActor[] refinements=_currentState.getRefinement();
    if (refinements != null) {
      for (      Actor refinementActor : refinements) {
        if (refinementActor instanceof CompositeActor) {
          CompositeActor refinement=(CompositeActor)refinementActor;
          for (          IOPort refinementPort : ((List<IOPort>)refinement.outputPortList())) {
            if (!refinementPort.isKnown()) {
              refinementPort.sendClear(0);
            }
          }
        }
      }
    }
    readOutputsFromRefinement();
  }
 else {
    if (!foundUnknown()) {
      Actor[] stateRefinements=_currentState.getRefinement();
      if (stateRefinements != null) {
        for (int i=0; i < stateRefinements.length; ++i) {
          if (_stopRequested || _disabledRefinements.contains(stateRefinements[i])) {
            break;
          }
          _setTimeForRefinement(stateRefinements[i]);
          if (stateRefinements[i].prefire()) {
            if (_debugging) {
              _debug(""String_Node_Str"",stateRefinements[i].getName());
            }
            stateRefinements[i].fire();
            _stateRefinementsToPostfire.add(stateRefinements[i]);
          }
        }
      }
      if (inModalModel) {
        director.setModelTime(environmentTime);
      }
      readOutputsFromRefinement();
      transitionList=_currentState.nonpreemptiveTransitionList();
      _chooseTransitions(transitionList,false);
    }
  }
  _assertAbsentOutputs(this);
}","/** 
 * Set the values of input variables. Choose the enabled transition among the outgoing transitions of the current state. Throw an exception if there is more than one transition enabled. Otherwise, execute the output actions contained by the chosen transition.
 * @exception IllegalActionException If there is more than onetransition enabled.
 */
public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Time environmentTime=_getEnvironmentTime();
  Director director=getDirector();
  boolean inModalModel=false;
  if (director instanceof FSMDirector) {
    inModalModel=true;
    director.setModelTime(environmentTime);
  }
  readInputs();
  _lastChosenTransitions.clear();
  _transitionRefinementsToPostfire.clear();
  _stateRefinementsToPostfire.clear();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  List<Transition> transitionList=_currentState.preemptiveTransitionList();
  _chooseTransitions(transitionList,false);
  if (_lastChosenTransitions.size() > 0) {
    if (inModalModel) {
      director.setModelTime(environmentTime);
    }
    TypedActor[] refinements=_currentState.getRefinement();
    if (refinements != null) {
      for (      Actor refinementActor : refinements) {
        if (refinementActor instanceof CompositeActor) {
          CompositeActor refinement=(CompositeActor)refinementActor;
          for (          IOPort refinementPort : ((List<IOPort>)refinement.outputPortList())) {
            for (int i=0; i < refinementPort.getWidth(); i++) {
              if (!refinementPort.isKnown(i)) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + refinementPort.getName() + ""String_Node_Str""+ i);
                }
                refinementPort.sendClear(i);
              }
            }
          }
        }
      }
    }
    readOutputsFromRefinement();
  }
 else {
    if (!foundUnknown()) {
      Actor[] stateRefinements=_currentState.getRefinement();
      if (stateRefinements != null) {
        for (int i=0; i < stateRefinements.length; ++i) {
          if (_stopRequested || _disabledRefinements.contains(stateRefinements[i])) {
            break;
          }
          _setTimeForRefinement(stateRefinements[i]);
          if (stateRefinements[i].prefire()) {
            if (_debugging) {
              _debug(""String_Node_Str"",stateRefinements[i].getName());
            }
            stateRefinements[i].fire();
            _stateRefinementsToPostfire.add(stateRefinements[i]);
          }
        }
      }
      if (inModalModel) {
        director.setModelTime(environmentTime);
      }
      readOutputsFromRefinement();
      transitionList=_currentState.nonpreemptiveTransitionList();
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      _chooseTransitions(transitionList,false);
    }
  }
  _assertAbsentOutputs(this);
}"
73245,"/** 
 * For the given controller FSM, set all outputs that are currently unknown to absent if it can be determined to be absent given the current state and possibly partial information about the inputs (some of the inputs may be unknown). If the current state has any refinements that are not FSMs, then return false. It is not safe to assert absent outputs because we have no visibility into what those refinements do with the outputs. This method first explores any FSM refinements of the current state. If those refinements are all FSMs and they are all able to assert that an output is absent, then explore this FSM to determine whether it also can assert that the output is absent. If all the refinements and the specified FSM agree that an output is absent, then this method sets it to absent. Otherwise, it leaves it unknown.
 * @param controller The controller FSM.
 * @return True if after this method is called, any output port is absent.
 * @exception IllegalActionException If something goes wrong.
 */
private boolean _assertAbsentOutputs(FSMActor controller) throws IllegalActionException {
  TypedActor[] refinements=controller._currentState.getRefinement();
  if (refinements != null) {
    for (    Actor refinementActor : refinements) {
      Director refinementDirector=refinementActor.getDirector();
      if (refinementDirector instanceof FSMDirector && refinementDirector != getDirector()) {
        FSMActor refinementController=((FSMDirector)refinementDirector).getController();
        if (!_assertAbsentOutputs(refinementController)) {
          return false;
        }
      }
 else {
        return false;
      }
    }
  }
  Director director=getDirector();
  boolean foundAbsentOutputs=false;
  if (director instanceof FSMDirector) {
    Actor container=(Actor)getContainer();
    List<IOPort> outputs=container.outputPortList();
    if (outputs.size() == 0) {
      return true;
    }
    for (    IOPort port : outputs) {
      IOPort[] refinementPorts=null;
      if (refinements != null) {
        refinementPorts=new IOPort[refinements.length];
        int i=0;
        for (        TypedActor refinement : refinements) {
          refinementPorts[i++]=(IOPort)((Entity)refinement).getPort(port.getName());
        }
      }
      for (int channel=0; channel < port.getWidthInside(); channel++) {
        if (!port.isKnownInside(channel)) {
          boolean channelIsAbsent=true;
          if (refinementPorts != null) {
            for (int i=0; i < refinementPorts.length; i++) {
              if (refinementPorts[i] != null && channel < refinementPorts[i].getWidthInside() && (!refinementPorts[i].isKnownInside(channel) || refinementPorts[i].hasTokenInside(channel))) {
                channelIsAbsent=false;
                break;
              }
            }
          }
          if (!channelIsAbsent) {
            break;
          }
          IOPort controllerPort=(IOPort)controller.getPort(port.getName());
          if (controllerPort != null) {
            channelIsAbsent=controller._isSafeToClear(controllerPort,channel,controller._currentState,false,null);
            if (channelIsAbsent) {
              foundAbsentOutputs=true;
              controllerPort.send(channel,null);
              _debug(""String_Node_Str"" + port.getName());
            }
          }
        }
 else {
          if (!port.hasTokenInside(channel)) {
            foundAbsentOutputs=true;
          }
        }
      }
    }
  }
 else {
    List<IOPort> outputs=outputPortList();
    for (    IOPort port : outputs) {
      for (int channel=0; channel < port.getWidth(); channel++) {
        if (_isSafeToClear(port,channel,_currentState,false,null)) {
          port.send(channel,null);
          foundAbsentOutputs=true;
        }
      }
    }
  }
  return foundAbsentOutputs;
}","/** 
 * For the given controller FSM, set all outputs that are currently unknown to absent if it can be determined to be absent given the current state and possibly partial information about the inputs (some of the inputs may be unknown). If the current state has any refinements that are not FSMs, then return false. It is not safe to assert absent outputs because we have no visibility into what those refinements do with the outputs. This method first explores any FSM refinements of the current state. If those refinements are all FSMs and they are all able to assert that an output is absent, then explore this FSM to determine whether it also can assert that the output is absent. If all the refinements and the specified FSM agree that an output is absent, then this method sets it to absent. Otherwise, it leaves it unknown.
 * @param controller The controller FSM.
 * @return True if after this method is called, any output port is absent.
 * @exception IllegalActionException If something goes wrong.
 */
private boolean _assertAbsentOutputs(FSMActor controller) throws IllegalActionException {
  TypedActor[] refinements=controller._currentState.getRefinement();
  if (refinements != null) {
    for (    Actor refinementActor : refinements) {
      Director refinementDirector=refinementActor.getDirector();
      if (refinementDirector instanceof FSMDirector && refinementDirector != getDirector()) {
        FSMActor refinementController=((FSMDirector)refinementDirector).getController();
        if (!_assertAbsentOutputs(refinementController)) {
          return false;
        }
      }
 else {
        return false;
      }
    }
  }
  Director director=getDirector();
  boolean foundAbsentOutputs=false;
  if (director instanceof FSMDirector) {
    Actor container=(Actor)getContainer();
    List<IOPort> outputs=container.outputPortList();
    if (outputs.size() == 0) {
      return true;
    }
    for (    IOPort port : outputs) {
      IOPort[] refinementPorts=null;
      if (refinements != null) {
        refinementPorts=new IOPort[refinements.length];
        int i=0;
        for (        TypedActor refinement : refinements) {
          refinementPorts[i++]=(IOPort)((Entity)refinement).getPort(port.getName());
        }
      }
      for (int channel=0; channel < port.getWidthInside(); channel++) {
        if (!port.isKnownInside(channel)) {
          boolean channelIsAbsent=true;
          if (refinementPorts != null) {
            for (int i=0; i < refinementPorts.length; i++) {
              if (refinementPorts[i] != null && channel < refinementPorts[i].getWidthInside() && (!refinementPorts[i].isKnownInside(channel) || refinementPorts[i].hasTokenInside(channel))) {
                channelIsAbsent=false;
                break;
              }
            }
          }
          if (!channelIsAbsent) {
            break;
          }
          IOPort controllerPort=(IOPort)controller.getPort(port.getName());
          if (controllerPort != null) {
            channelIsAbsent=controller._isSafeToClear(controllerPort,channel,controller._currentState,false,null);
            if (channelIsAbsent) {
              foundAbsentOutputs=true;
              controllerPort.send(channel,null);
              if (_debugging) {
                _debug(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ channel);
              }
            }
          }
        }
 else {
          if (!port.hasTokenInside(channel)) {
            foundAbsentOutputs=true;
          }
        }
      }
    }
  }
 else {
    List<IOPort> outputs=outputPortList();
    for (    IOPort port : outputs) {
      for (int channel=0; channel < port.getWidth(); channel++) {
        if (_isSafeToClear(port,channel,_currentState,false,null)) {
          if (_debugging) {
            _debug(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ channel);
          }
          port.send(channel,null);
          foundAbsentOutputs=true;
        }
      }
    }
  }
  return foundAbsentOutputs;
}"
73246,"/** 
 * Choose zero or more transitions enabled in the current state from the list of specified transitions. This method follows chains of immediate transitions, if there are any. As a side effect, the controller's _lastChosenTransitions protected variable will contain the chosen transitions.
 * @param transitionList The candidate transitions.
 * @param immediateOnly If true, look only at immediatetransitions from the current state.
 * @throws IllegalActionException If something goes wrong.
 */
protected void _chooseTransitions(List<Transition> transitionList,boolean immediateOnly) throws IllegalActionException {
  Transition chosenTransition=_chooseTransition(_currentState,transitionList,immediateOnly);
  if (chosenTransition != null && chosenTransition.isImmediate() && chosenTransition.destinationState() == _currentState) {
    throw new IllegalActionException(_currentState,this,""String_Node_Str"");
  }
  HashSet<State> visitedStates=new HashSet<State>();
  while (chosenTransition != null) {
    State nextState=chosenTransition.destinationState();
    if (visitedStates.contains(nextState)) {
      throw new IllegalActionException(nextState,this,""String_Node_Str"");
    }
    visitedStates.add(nextState);
    transitionList=nextState.outgoingPort.linkedRelationList();
    chosenTransition=_chooseTransition(nextState,transitionList,true);
  }
}","/** 
 * Choose zero or more transitions enabled in the current state from the list of specified transitions. This method follows chains of immediate transitions, if there are any. As a side effect, the controller's _lastChosenTransitions protected variable will contain the chosen transitions.
 * @param transitionList The candidate transitions.
 * @param immediateOnly If true, look only at immediatetransitions from the current state.
 * @throws IllegalActionException If something goes wrong.
 */
protected void _chooseTransitions(List<Transition> transitionList,boolean immediateOnly) throws IllegalActionException {
  Transition chosenTransition=_chooseTransition(_currentState,transitionList,immediateOnly);
  if (chosenTransition != null && chosenTransition.isImmediate() && chosenTransition.destinationState() == _currentState) {
    throw new IllegalActionException(_currentState,this,""String_Node_Str"");
  }
  HashSet<State> visitedStates=new HashSet<State>();
  while (chosenTransition != null) {
    State nextState=chosenTransition.destinationState();
    if (visitedStates.contains(nextState)) {
      throw new IllegalActionException(nextState,this,""String_Node_Str"");
    }
    visitedStates.add(nextState);
    transitionList=nextState.outgoingPort.linkedRelationList();
    if (_debugging) {
      _debug(""String_Node_Str"" + nextState.getName());
    }
    chosenTransition=_chooseTransition(nextState,transitionList,true);
  }
}"
73247,"/** 
 * Execute actions on the last chosen transition. Change state to the destination state of the last chosen transition.
 * @return True, unless stop() has been called, in which case, false.
 * @exception IllegalActionException If any action throws it.
 */
public boolean postfire() throws IllegalActionException {
  Director director=getDirector();
  boolean inModalModel=false;
  if (director instanceof FSMDirector) {
    inModalModel=true;
  }
  Time environmentTime=_getEnvironmentTime();
  for (  Actor stateRefinement : _stateRefinementsToPostfire) {
    if (_debugging) {
      _debug(""String_Node_Str"",stateRefinement.getName());
    }
    _setTimeForRefinement(stateRefinement);
    if (!stateRefinement.postfire()) {
      _disabledRefinements.add(stateRefinement);
    }
    if (inModalModel) {
      director.setModelTime(environmentTime);
    }
  }
  Actor[] refinements=_currentState.getRefinement();
  if (refinements != null) {
    for (    Actor stateRefinement : refinements) {
      if (_lastChosenTransitions.size() != 0 && stateRefinement instanceof Suspendable) {
        ((Suspendable)stateRefinement).suspend(environmentTime);
      }
    }
  }
  if (_lastChosenTransitions.size() != 0) {
    State destinationState=_destinationState();
    if (destinationState != null) {
      TypedActor[] destinationRefinements=destinationState.getRefinement();
      if (destinationRefinements != null) {
        for (        TypedActor destinationRefinement : destinationRefinements) {
          if (destinationRefinement instanceof Suspendable) {
            ((Suspendable)destinationRefinement).resume(environmentTime);
          }
        }
      }
    }
  }
  _transitionsPreviouslyChosenInIteration.clear();
  _commitLastChosenTransition();
  for (  Actor transitionRefinement : _transitionRefinementsToPostfire) {
    if (_debugging) {
      _debug(""String_Node_Str"",transitionRefinement.getName());
    }
    if (!transitionRefinement.postfire()) {
      _disabledRefinements.add(transitionRefinement);
    }
  }
  return !_reachedFinalState && !_stopRequested;
}","/** 
 * Execute actions on the last chosen transition. Change state to the destination state of the last chosen transition.
 * @return True, unless stop() has been called, in which case, false.
 * @exception IllegalActionException If any action throws it.
 */
public boolean postfire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Director director=getDirector();
  boolean inModalModel=false;
  if (director instanceof FSMDirector) {
    inModalModel=true;
  }
  Time environmentTime=_getEnvironmentTime();
  for (  Actor stateRefinement : _stateRefinementsToPostfire) {
    if (_debugging) {
      _debug(""String_Node_Str"",stateRefinement.getName());
    }
    _setTimeForRefinement(stateRefinement);
    if (!stateRefinement.postfire()) {
      _disabledRefinements.add(stateRefinement);
    }
    if (inModalModel) {
      director.setModelTime(environmentTime);
    }
  }
  Actor[] refinements=_currentState.getRefinement();
  if (refinements != null) {
    for (    Actor stateRefinement : refinements) {
      if (_lastChosenTransitions.size() != 0 && stateRefinement instanceof Suspendable) {
        ((Suspendable)stateRefinement).suspend(environmentTime);
      }
    }
  }
  if (_lastChosenTransitions.size() != 0) {
    State destinationState=_destinationState();
    if (destinationState != null) {
      TypedActor[] destinationRefinements=destinationState.getRefinement();
      if (destinationRefinements != null) {
        for (        TypedActor destinationRefinement : destinationRefinements) {
          if (destinationRefinement instanceof Suspendable) {
            ((Suspendable)destinationRefinement).resume(environmentTime);
          }
        }
      }
    }
  }
  _transitionsPreviouslyChosenInIteration.clear();
  _commitLastChosenTransition();
  for (  Actor transitionRefinement : _transitionRefinementsToPostfire) {
    if (_debugging) {
      _debug(""String_Node_Str"",transitionRefinement.getName());
    }
    if (!transitionRefinement.postfire()) {
      _disabledRefinements.add(transitionRefinement);
    }
  }
  return !_reachedFinalState && !_stopRequested;
}"
73248,"/** 
 * Initialize this actor by setting the current state to the initial state.
 * @exception IllegalActionException If a derived class throws it.
 */
public void initialize() throws IllegalActionException {
  if (_initializables != null) {
    for (    Initializable initializable : _initializables) {
      initializable.initialize();
    }
  }
  _reachedFinalState=false;
  _newIteration=true;
  reset();
  _transitionsPreviouslyChosenInIteration.clear();
  _lastChosenTransitions.clear();
  _disabledRefinements.clear();
  if (_currentState != null) {
    List transitionList=_currentState.outgoingPort.linkedRelationList();
    _chooseTransitions(transitionList,true);
    _commitLastChosenTransition();
    _transitionsPreviouslyChosenInIteration.clear();
    List enabledTransitions=enabledTransitions(transitionList,false);
    if (enabledTransitions.size() > 0) {
      if (_debugging) {
        _debug(""String_Node_Str"" + getDirector().getModelTime());
      }
      getDirector().fireAtCurrentTime(this);
    }
  }
}","/** 
 * Initialize this actor by setting the current state to the initial state.
 * @exception IllegalActionException If a derived class throws it.
 */
public void initialize() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (_initializables != null) {
    for (    Initializable initializable : _initializables) {
      initializable.initialize();
    }
  }
  _reachedFinalState=false;
  _newIteration=true;
  reset();
  _transitionsPreviouslyChosenInIteration.clear();
  _lastChosenTransitions.clear();
  _disabledRefinements.clear();
  if (_currentState != null) {
    List transitionList=_currentState.outgoingPort.linkedRelationList();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    _chooseTransitions(transitionList,true);
    _commitLastChosenTransition();
    _transitionsPreviouslyChosenInIteration.clear();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    List enabledTransitions=enabledTransitions(transitionList,false);
    if (enabledTransitions.size() > 0) {
      if (_debugging) {
        _debug(""String_Node_Str"" + getDirector().getModelTime());
      }
      getDirector().fireAtCurrentTime(this);
    }
  }
}"
73249,"/** 
 * Create a new NamedObj tree for dragging and dropping into the scene.
 */
public NamedObjectTree(){
  setBorder(new TitledBorder(null,""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,null,null));
  setLayout(new BorderLayout());
  setSize(500,200);
  setPreferredSize(new Dimension(250,10));
  _search.setToolTipText(""String_Node_Str"");
  _search.setFocusable(true);
  _search.requestFocus();
  _search.addKeyListener(new KeyAdapter(){
    public void keyReleased(    KeyEvent e){
      AttributeTreeModel treeModel=(AttributeTreeModel)_tree.getModel();
      if ((_search.getText() != null) && (_search.getText().length() > 0)) {
        treeModel.applyFilter(_search.getText());
        for (int i=0; i < _tree.getRowCount(); i++) {
          _tree.expandRow(i);
        }
      }
 else {
        for (int i=0; i < _tree.getRowCount(); i++) {
          _tree.collapseRow(i);
        }
      }
    }
  }
);
  _tree=new PTree(new AttributeTreeModel(null));
  _tree.setRootVisible(false);
  _tree.setShowsRootHandles(true);
  _tree.setScrollsOnExpand(true);
  _tree.setCellRenderer(new PtolemyTreeCellRenderer(){
    @Override public Component getTreeCellRendererComponent(    JTree tree,    Object value,    boolean sel,    boolean expanded,    boolean leaf,    int row,    boolean hasFocus){
      super.getTreeCellRendererComponent(tree,value,sel,expanded,leaf,row,hasFocus);
      setText(((Nameable)value).getName());
      if ((_search.getText() != null) && (_search.getText().length() > 0)) {
        if ((!((Nameable)value).getFullName().toLowerCase().contains(_search.getText().toLowerCase()))) {
          setEnabled(false);
        }
      }
      return this;
    }
  }
);
  add(_search,BorderLayout.NORTH);
  add(new JScrollPane(_tree),BorderLayout.CENTER);
  JButton button=new JButton(""String_Node_Str"");
  button.setUI(new BasicButtonUI());
  button.setTransferHandler(new TransferHandler(""String_Node_Str""));
  button.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JComponent c=(JComponent)e.getSource();
      TransferHandler handler=c.getTransferHandler();
      handler.exportAsDrag(c,e,TransferHandler.COPY);
    }
  }
);
  button.setFocusable(false);
  button.setBorder(BorderFactory.createEtchedBorder());
  button.setRolloverEnabled(true);
  add(button,BorderLayout.SOUTH);
}","/** 
 * Create a new NamedObj tree for dragging and dropping into the scene.
 */
public NamedObjectTree(){
  setBorder(new TitledBorder(null,""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,null,null));
  setLayout(new BorderLayout());
  setSize(500,200);
  setPreferredSize(new Dimension(250,10));
  _search.setToolTipText(""String_Node_Str"");
  _search.setFocusable(true);
  _search.requestFocus();
  _search.addKeyListener(new KeyAdapter(){
    public void keyReleased(    KeyEvent e){
      AttributeTreeModel treeModel=(AttributeTreeModel)_tree.getModel();
      if ((_search.getText() != null) && (_search.getText().length() > 0)) {
        treeModel.applyFilter(_search.getText());
        for (int i=0; i < _tree.getRowCount(); i++) {
          _tree.expandRow(i);
        }
      }
 else {
        for (int i=0; i < _tree.getRowCount(); i++) {
          treeModel.applyFilter(""String_Node_Str"");
          _tree.collapseRow(i);
        }
      }
    }
  }
);
  _tree=new PTree(new AttributeTreeModel(null));
  _tree.setRootVisible(false);
  _tree.setShowsRootHandles(true);
  _tree.setScrollsOnExpand(true);
  _tree.setCellRenderer(new PtolemyTreeCellRenderer(){
    @Override public Component getTreeCellRendererComponent(    JTree tree,    Object value,    boolean sel,    boolean expanded,    boolean leaf,    int row,    boolean hasFocus){
      super.getTreeCellRendererComponent(tree,value,sel,expanded,leaf,row,hasFocus);
      setText(((Nameable)value).getName());
      if ((_search.getText() != null) && (_search.getText().length() > 0)) {
        if ((!((Nameable)value).getFullName().toLowerCase().contains(_search.getText().toLowerCase()))) {
          setEnabled(false);
        }
      }
      return this;
    }
  }
);
  add(_search,BorderLayout.NORTH);
  add(new JScrollPane(_tree),BorderLayout.CENTER);
  JButton button=new JButton(""String_Node_Str"");
  button.setUI(new BasicButtonUI());
  button.setTransferHandler(new TransferHandler(""String_Node_Str""));
  button.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JComponent c=(JComponent)e.getSource();
      TransferHandler handler=c.getTransferHandler();
      handler.exportAsDrag(c,e,TransferHandler.COPY);
    }
  }
);
  button.setFocusable(false);
  button.setBorder(BorderFactory.createEtchedBorder());
  button.setRolloverEnabled(true);
  add(button,BorderLayout.SOUTH);
}"
73250,"public void keyReleased(KeyEvent e){
  AttributeTreeModel treeModel=(AttributeTreeModel)_tree.getModel();
  if ((_search.getText() != null) && (_search.getText().length() > 0)) {
    treeModel.applyFilter(_search.getText());
    for (int i=0; i < _tree.getRowCount(); i++) {
      _tree.expandRow(i);
    }
  }
 else {
    for (int i=0; i < _tree.getRowCount(); i++) {
      _tree.collapseRow(i);
    }
  }
}","public void keyReleased(KeyEvent e){
  AttributeTreeModel treeModel=(AttributeTreeModel)_tree.getModel();
  if ((_search.getText() != null) && (_search.getText().length() > 0)) {
    treeModel.applyFilter(_search.getText());
    for (int i=0; i < _tree.getRowCount(); i++) {
      _tree.expandRow(i);
    }
  }
 else {
    for (int i=0; i < _tree.getRowCount(); i++) {
      treeModel.applyFilter(""String_Node_Str"");
      _tree.collapseRow(i);
    }
  }
}"
73251,"/** 
 * Return the current state if it has a refinement. Otherwise, make state transitions until a state with a refinement is found. Set that non-transient state to be the current state and return it.
 * @return The non-transient state.
 * @exception IllegalActionException If a transient state is reachedwhile no further transition is enabled.
 */
private State _getNonTransientState() throws IllegalActionException {
  FSMActor controller=getController();
  State currentState=controller.currentState();
  TypedActor[] currentRefinements=currentState.getRefinement();
  while (currentRefinements == null) {
    chooseTransition(currentState);
    controller._commitLastChosenTransition();
    currentState=controller.currentState();
    Map<State,Transition> lastChosenTransitions=_getLastChosenTransition();
    controller._lastChosenTransition.clear();
    if (lastChosenTransitions.size() == 0) {
      throw new IllegalActionException(currentState,""String_Node_Str"" + ""String_Node_Str"");
    }
    currentRefinements=currentState.getRefinement();
  }
  return currentState;
}","/** 
 * Return the current state if it has a refinement. Otherwise, make state transitions until a state with a refinement is found. Set that non-transient state to be the current state and return it.
 * @return The non-transient state.
 * @exception IllegalActionException If a transient state is reachedwhile no further transition is enabled.
 */
private State _getNonTransientState() throws IllegalActionException {
  FSMActor controller=getController();
  State currentState=controller.currentState();
  TypedActor[] currentRefinements=currentState.getRefinement();
  while (currentRefinements == null) {
    chooseTransition(currentState);
    controller._commitLastChosenTransition();
    currentState=controller.currentState();
    Map<State,Transition> lastChosenTransitions=_getLastChosenTransition();
    controller._lastChosenTransitions.clear();
    if (lastChosenTransitions.size() == 0) {
      throw new IllegalActionException(currentState,""String_Node_Str"" + ""String_Node_Str"");
    }
    currentRefinements=currentState.getRefinement();
  }
  return currentState;
}"
73252,"/** 
 * Close the model along with all its connection.
 */
public void close(){
  _pingPongExecutor.shutdownNow();
  if (_pingPongFuture != null) {
    _pingPongFuture.cancel(true);
  }
  _tokenPublisher.cancel();
  _executor.shutdownNow();
  if (_mqttClient != null) {
    try {
      _mqttClient.disconnect();
    }
 catch (    MqttException e) {
      fireModelException(null,e);
    }
 finally {
      _mqttClient.terminate();
    }
  }
}","/** 
 * Close the model along with all its connection.
 */
public void close(){
  _pingPongExecutor.shutdownNow();
  if (_pingPongFuture != null) {
    _pingPongFuture.cancel(true);
  }
  _executor.shutdownNow();
  _tokenPublisher.cancel();
  if (_mqttClient != null) {
    try {
      _mqttClient.disconnect();
    }
 catch (    MqttException e) {
      fireModelException(null,e);
    }
 finally {
      _mqttClient.terminate();
    }
  }
}"
73253,"/** 
 * Cancel the publisher's timer used for sending batch of tokens.
 */
public void cancel(){
  if (_executor != null) {
    _executor.shutdownNow();
    if (_publisherFuture != null) {
      _publisherFuture.cancel(true);
    }
  }
}","/** 
 * Cancel the publisher's timer used for sending batch of tokens.
 */
public synchronized void cancel(){
  try {
    if (_tokenCount != 0) {
      _sendBatch();
      Thread.sleep(_period);
    }
  }
 catch (  Throwable e) {
    _proxyModelInfrastructure.fireModelException(""String_Node_Str"",e);
  }
  if (_executor != null) {
    _executor.shutdownNow();
    if (_publisherFuture != null) {
      _publisherFuture.cancel(true);
    }
  }
}"
73254,"/** 
 * React to the remote connection expiring.
 * @param remoteModel The remote model whose connection has expired.
 */
public void modelConnectionExpired(ProxyModelInfrastructure remoteModel){
  LOGGER.info(""String_Node_Str"" + remoteModel.getTicket());
  LOGGER.info(""String_Node_Str"" + remoteModel.getPingPongLatency() + ""String_Node_Str"");
  try {
    close(remoteModel.getTicket());
  }
 catch (  Throwable e) {
    String message=""String_Node_Str"" + remoteModel.getTicket().getTicketID() + ""String_Node_Str"";
    PtolemyServer.LOGGER.log(Level.SEVERE,message,e);
  }
}","/** 
 * React to the remote connection expiring.
 * @param remoteModel The remote model whose connection has expired.
 */
public void modelConnectionExpired(ProxyModelInfrastructure remoteModel){
  LOGGER.severe(""String_Node_Str"" + remoteModel.getTicket());
  LOGGER.severe(""String_Node_Str"" + remoteModel.getPingPongLatency() + ""String_Node_Str"");
  try {
    close(remoteModel.getTicket());
  }
 catch (  Throwable e) {
    String message=""String_Node_Str"" + remoteModel.getTicket().getTicketID() + ""String_Node_Str"";
    PtolemyServer.LOGGER.log(Level.SEVERE,message,e);
  }
}"
73255,"public void modelException(ProxyModelInfrastructure proxyModelInfrastructure,String message,Throwable exception){
  PtolemyServer.LOGGER.log(Level.INFO,""String_Node_Str"" + proxyModelInfrastructure.getTicket().getTicketID() + ""String_Node_Str"",exception);
  try {
    proxyModelInfrastructure.getTokenPublisher().sendToken(new RemoteEventToken(message,exception),null);
  }
 catch (  Throwable e) {
    PtolemyServer.LOGGER.log(Level.SEVERE,""String_Node_Str"" + proxyModelInfrastructure.getTicket().getTicketID(),exception);
  }
 finally {
    try {
      PtolemyServer.getInstance().close(proxyModelInfrastructure.getTicket());
    }
 catch (    Throwable e) {
      PtolemyServer.LOGGER.log(Level.SEVERE,""String_Node_Str"" + proxyModelInfrastructure.getTicket().getTicketID(),exception);
    }
  }
}","public void modelException(ProxyModelInfrastructure proxyModelInfrastructure,String message,Throwable exception){
  PtolemyServer.LOGGER.log(Level.SEVERE,""String_Node_Str"" + proxyModelInfrastructure.getTicket().getTicketID() + ""String_Node_Str"",exception);
  try {
    proxyModelInfrastructure.getTokenPublisher().sendToken(new RemoteEventToken(message,exception),null);
  }
 catch (  Throwable e) {
    PtolemyServer.LOGGER.log(Level.SEVERE,""String_Node_Str"" + proxyModelInfrastructure.getTicket().getTicketID(),exception);
  }
 finally {
    try {
      PtolemyServer.getInstance().close(proxyModelInfrastructure.getTicket());
    }
 catch (    Throwable e) {
      PtolemyServer.LOGGER.log(Level.SEVERE,""String_Node_Str"" + proxyModelInfrastructure.getTicket().getTicketID(),exception);
    }
  }
}"
73256,"/** 
 * Fire the modal model for one iteration. If there is a preemptive transition enabled, execute its choice actions (outputActions). Otherwise, fire the refinement of the current state.  After this firing, if there is a transition enabled, execute its choice actions. If any tokens are produced during this iteration, they are sent to both the output ports of the model model but also the input ports of the mode controller.
 * @exception IllegalActionException If there is more than onetransition enabled and nondeterminism is not permitted, or there is no controller, or it is thrown by any choice action.
 */
public void fire() throws IllegalActionException {
  Time environmentTime=_getEnvironmentTime();
  setModelTime(environmentTime);
  _stateRefinementsToPostfire.clear();
  _transitionRefinementsToPostfire.clear();
  FSMActor controller=getController();
  State currentState=controller.currentState();
  if (_debugging) {
    _debug(""String_Node_Str"" + getFullName(),""String_Node_Str"" + getModelTime());
    _debug(""String_Node_Str"",currentState.getName());
  }
  controller.readInputs();
  List<Transition> transitionList=currentState.preemptiveTransitionList();
  Transition chosenPreemptiveTransition=_chooseTransition(currentState,transitionList,false);
  while (chosenPreemptiveTransition != null) {
    State nextState=chosenPreemptiveTransition.destinationState();
    if (nextState == currentState) {
      break;
    }
    transitionList=nextState.outgoingPort.linkedRelationList();
    chosenPreemptiveTransition=_chooseTransition(nextState,transitionList,true);
  }
  if (controller._lastChosenTransition.size() > 0) {
    setModelTime(environmentTime);
    if (controller._currentState.getRefinement() != null) {
      TypedActor[] refinements=controller._currentState.getRefinement();
      for (      Actor refinementActor : refinements) {
        if (refinementActor instanceof CompositeActor) {
          CompositeActor refinement=(CompositeActor)refinementActor;
          for (          IOPort refinementPort : ((List<IOPort>)refinement.outputPortList())) {
            if (!refinementPort.isKnown()) {
              refinementPort.sendClear(0);
            }
          }
        }
      }
    }
    controller.readOutputsFromRefinement();
    return;
  }
  if (controller.foundUnknown()) {
    _assertAbsentOutputs(getController(),true);
    return;
  }
  Actor[] stateRefinements=currentState.getRefinement();
  if (stateRefinements != null) {
    for (int i=0; i < stateRefinements.length; ++i) {
      if (_stopRequested || _disabledActors.contains(stateRefinements[i])) {
        break;
      }
      _setTimeForRefinement(stateRefinements[i]);
      if (stateRefinements[i].prefire()) {
        if (_debugging) {
          _debug(""String_Node_Str"",stateRefinements[i].getName());
        }
        stateRefinements[i].fire();
        _stateRefinementsToPostfire.add(stateRefinements[i]);
      }
    }
  }
  setModelTime(environmentTime);
  controller.readOutputsFromRefinement();
  transitionList=currentState.nonpreemptiveTransitionList();
  Transition chosenNonpreemptiveTransition=_chooseTransition(currentState,transitionList,false);
  while (chosenNonpreemptiveTransition != null) {
    State nextState=chosenNonpreemptiveTransition.destinationState();
    if (nextState == currentState) {
      break;
    }
    transitionList=nextState.outgoingPort.linkedRelationList();
    chosenNonpreemptiveTransition=_chooseTransition(nextState,transitionList,true);
  }
  if (controller._lastChosenTransition.size() == 0) {
    _assertAbsentOutputs(controller,true);
  }
}","/** 
 * Fire the modal model for one iteration. If there is a preemptive transition enabled, execute its choice actions (outputActions). Otherwise, fire the refinement of the current state.  After this firing, if there is a transition enabled, execute its choice actions. If any tokens are produced during this iteration, they are sent to both the output ports of the model model but also the input ports of the mode controller.
 * @exception IllegalActionException If there is more than onetransition enabled and nondeterminism is not permitted, or there is no controller, or it is thrown by any choice action.
 */
public void fire() throws IllegalActionException {
  Time environmentTime=_getEnvironmentTime();
  setModelTime(environmentTime);
  _stateRefinementsToPostfire.clear();
  _transitionRefinementsToPostfire.clear();
  FSMActor controller=getController();
  controller._lastChosenTransition.clear();
  State currentState=controller.currentState();
  if (_debugging) {
    _debug(""String_Node_Str"" + getFullName(),""String_Node_Str"" + getModelTime());
    _debug(""String_Node_Str"",currentState.getName());
  }
  controller.readInputs();
  List<Transition> transitionList=currentState.preemptiveTransitionList();
  Transition chosenPreemptiveTransition=_chooseTransition(currentState,transitionList,false);
  while (chosenPreemptiveTransition != null) {
    State nextState=chosenPreemptiveTransition.destinationState();
    if (nextState == currentState) {
      break;
    }
    transitionList=nextState.outgoingPort.linkedRelationList();
    chosenPreemptiveTransition=_chooseTransition(nextState,transitionList,true);
  }
  if (controller._lastChosenTransition.size() > 0) {
    setModelTime(environmentTime);
    if (controller._currentState.getRefinement() != null) {
      TypedActor[] refinements=controller._currentState.getRefinement();
      for (      Actor refinementActor : refinements) {
        if (refinementActor instanceof CompositeActor) {
          CompositeActor refinement=(CompositeActor)refinementActor;
          for (          IOPort refinementPort : ((List<IOPort>)refinement.outputPortList())) {
            if (!refinementPort.isKnown()) {
              refinementPort.sendClear(0);
            }
          }
        }
      }
    }
    controller.readOutputsFromRefinement();
    return;
  }
  if (controller.foundUnknown()) {
    _assertAbsentOutputs(getController(),true);
    return;
  }
  Actor[] stateRefinements=currentState.getRefinement();
  if (stateRefinements != null) {
    for (int i=0; i < stateRefinements.length; ++i) {
      if (_stopRequested || _disabledActors.contains(stateRefinements[i])) {
        break;
      }
      _setTimeForRefinement(stateRefinements[i]);
      if (stateRefinements[i].prefire()) {
        if (_debugging) {
          _debug(""String_Node_Str"",stateRefinements[i].getName());
        }
        stateRefinements[i].fire();
        _stateRefinementsToPostfire.add(stateRefinements[i]);
      }
    }
  }
  setModelTime(environmentTime);
  controller.readOutputsFromRefinement();
  transitionList=currentState.nonpreemptiveTransitionList();
  Transition chosenNonpreemptiveTransition=_chooseTransition(currentState,transitionList,false);
  while (chosenNonpreemptiveTransition != null) {
    State nextState=chosenNonpreemptiveTransition.destinationState();
    if (nextState == currentState) {
      break;
    }
    transitionList=nextState.outgoingPort.linkedRelationList();
    chosenNonpreemptiveTransition=_chooseTransition(nextState,transitionList,true);
  }
  if (controller._lastChosenTransition.size() == 0) {
    _assertAbsentOutputs(controller,true);
  }
}"
73257,"/** 
 * Save the layout file.
 * @param layoutFile The target file for the ""Save As"" operation.
 */
public void saveLayoutAs(File layoutFile){
  LayoutFileOperations.saveAs(this,layoutFile);
}","/** 
 * Save the layout file.
 * @param layoutFile The target file for the ""Save As"" operation.
 */
public void saveLayoutAs(File layoutFile){
  try {
    _layoutURL=layoutFile.toURL();
  }
 catch (  MalformedURLException e) {
    MessageHandler.error(e.getMessage(),e);
  }
  LayoutFileOperations.saveAs(this,layoutFile);
}"
73258,"/** 
 * Get the current layout file URL.
 * @return The current layout file URL.
 */
public URL getLayoutURL(){
  if (_layoutURL == null) {
    return null;
  }
  try {
    if (!new File(_layoutURL.toURI()).canRead()) {
      return null;
    }
    return _layoutURL;
  }
 catch (  URISyntaxException e) {
    return null;
  }
}","/** 
 * Get the current layout file URL.
 * @return The current layout file URL.
 */
public URL getLayoutURL(){
  if (_layoutURL == null) {
    return null;
  }
  if (_layoutURL.getFile().equals(""String_Node_Str"")) {
    return null;
  }
  return _layoutURL;
}"
73259,"/** 
 * Process action on the save menu.
 * @param e The action event.
 */
private void _saveMenuActionPerformed(ActionEvent e){
  URL layoutURL=_mainFrame.getLayoutURL();
  if (layoutURL != null) {
    try {
      _mainFrame.saveLayoutAs(new File(layoutURL.toURI()));
    }
 catch (    URISyntaxException ex) {
      return;
    }
  }
 else {
    _saveAsMenuActionPerformed(e);
  }
}","/** 
 * Process action on the save menu.
 * @param e The action event.
 */
private void _saveMenuActionPerformed(ActionEvent e){
  URL layoutURL=_mainFrame.getLayoutURL();
  if (layoutURL != null) {
    _mainFrame.saveLayoutAs(new File(layoutURL.getPath()));
  }
 else {
    _saveAsMenuActionPerformed(e);
  }
}"
73260,"/** 
 * Return the PtolemyInjector.  Note that   {@link #createInjector(PtolemyModule)} must be called prior to using this method.
 * @return the PtolemyInjector that was created with the supplied modules.
 */
public static Injector getInjector(){
  return _instance;
}","/** 
 * Return the PtolemyInjector.  Note that   {@link #createInjector(PtolemyModule)} must be called prior to using this method.
 * @return the PtolemyInjector that was created with the supplied modules.
 */
public static Injector getInjector(){
  if (_instance == null) {
    ActorModuleInitializer.initializeInjector();
  }
  return _instance;
}"
73261,"/** 
 * Get the attributes with positions defined in the layout file.
 * @return All the attributes with locations parsed.
 * @exception IllegalActionException If the location information is invalidfor any of the attributes, or if the attribute is not Settable.
 */
public ArrayList<AttributeElement> getPositionableAttributes() throws IllegalActionException {
  ArrayList<AttributeElement> attributeDefinitions=new ArrayList<AttributeElement>();
  for (  EntityElement element : getPositionableEntities()) {
    _initPositionableAttributes(element.getElement(),attributeDefinitions);
  }
  _initPositionableAttributes(_topLevelActor,attributeDefinitions);
  return attributeDefinitions;
}","/** 
 * Get the attributes with positions defined in the layout file.
 * @return All the attributes with locations parsed.
 * @exception IllegalActionException If the location information is invalidfor any of the attributes, or if the attribute is not Settable.
 */
public ArrayList<AttributeElement> getPositionableAttributes() throws IllegalActionException {
  ArrayList<AttributeElement> attributeDefinitions=new ArrayList<AttributeElement>();
  List<ComponentEntity> entities=_topLevelActor.deepEntityList();
  for (  ComponentEntity entity : entities) {
    _initPositionableAttributes(entity,attributeDefinitions);
  }
  _initPositionableAttributes(_topLevelActor,attributeDefinitions);
  return attributeDefinitions;
}"
73262,"/** 
 * Set up model monitoring infrastructure.
 */
private void _setUpMonitoring(){
  setLastPongToken(new PongToken(System.currentTimeMillis()));
  _pingPongExecutor=Executors.newSingleThreadScheduledExecutor();
  _pingPongExecutor.scheduleAtFixedRate(new Runnable(){
    public void run(){
      try {
        long msTime=System.currentTimeMillis();
        _tokenPublisher.sendToken(new PingToken(msTime),null);
        _LOGGER.info(""String_Node_Str"");
        long latency=msTime - _getLastPongToken().getTimestamp();
        if (latency > _PING_PERIOD * 2) {
          _pingPonglatency=latency;
        }
        if (_timeoutPeriod > 0) {
          if (latency > _timeoutPeriod) {
            fireModelConnectionExpired();
          }
        }
      }
 catch (      Throwable e) {
        fireModelException(""String_Node_Str"",e);
      }
    }
  }
,0,_PING_PERIOD,TimeUnit.MILLISECONDS);
}","/** 
 * Set up model monitoring infrastructure.
 */
private void _setUpMonitoring(){
  setLastPongToken(new PongToken(System.currentTimeMillis()));
  _pingPongExecutor=Executors.newSingleThreadScheduledExecutor();
  _pingPongFuture=_pingPongExecutor.scheduleAtFixedRate(new Runnable(){
    public void run(){
      try {
        long msTime=System.currentTimeMillis();
        _tokenPublisher.sendToken(new PingToken(msTime),null);
        _LOGGER.info(""String_Node_Str"");
        long latency=msTime - _getLastPongToken().getTimestamp();
        if (latency > _PING_PERIOD * 2) {
          _pingPonglatency=latency;
        }
        if (_timeoutPeriod > 0) {
          if (latency > _timeoutPeriod) {
            fireModelConnectionExpired();
          }
        }
      }
 catch (      Throwable e) {
        fireModelException(""String_Node_Str"",e);
      }
    }
  }
,0,_PING_PERIOD,TimeUnit.MILLISECONDS);
}"
73263,"/** 
 * Close the model along with all its connection.
 */
public void close(){
  _pingPongExecutor.shutdown();
  _tokenPublisher.cancelTimer();
  _executor.shutdown();
  try {
    _mqttClient.disconnect();
  }
 catch (  MqttException e) {
    fireModelException(null,e);
  }
}","/** 
 * Close the model along with all its connection.
 */
public void close(){
  _pingPongExecutor.shutdownNow();
  if (_pingPongFuture != null) {
    _pingPongFuture.cancel(true);
  }
  _tokenPublisher.cancel();
  _executor.shutdownNow();
  if (_mqttClient != null) {
    try {
      _mqttClient.disconnect();
    }
 catch (    MqttException e) {
      fireModelException(null,e);
    }
 finally {
      _mqttClient.terminate();
    }
  }
}"
73264,"/** 
 * Callback method when a message from the topic is received.
 * @param topicName The name of the topic from which the message was received.
 * @param payload The MQTT message.
 * @param qos The Quality of Service at which the message was delivered by the broker.
 * @param retained indicates if this message is retained by the broker.
 * @see com.ibm.mqtt.MqttSimpleCallback#publishArrived(java.lang.String,byte[],int,boolean)
 * @exception Exception if there is a problem reading next token or setting attribute value
 */
public void publishArrived(String topicName,byte[] payload,int qos,boolean retained) throws Exception {
  Tokenizer tokenizer=new Tokenizer(payload);
  Token token=null;
  _LOGGER.fine(""String_Node_Str"" + _batchCount++);
  while ((token=tokenizer.getNextToken()) != null) {
    if (token instanceof CommunicationToken) {
      CommunicationToken communicationToken=(CommunicationToken)token;
      ProxySourceData data=_proxyModelInfrastructure.getProxySourceMap().get(communicationToken.getTargetActorName());
      data.getTokenQueue().add(communicationToken);
synchronized (data.getProxySource()) {
        data.getProxySource().notifyAll();
      }
    }
 else     if (token instanceof AttributeChangeToken) {
      AttributeChangeToken attributeChangeToken=(AttributeChangeToken)token;
      Settable remoteAttribute=_proxyModelInfrastructure.getRemoteAttributesMap().get(attributeChangeToken.getTargetSettableName());
      ProxyValueListener listener=_proxyModelInfrastructure.getRemoteAttributeListenersMap().get(attributeChangeToken.getTargetSettableName());
synchronized (listener) {
        try {
          listener.setEnabled(false);
          remoteAttribute.setExpression(attributeChangeToken.getExpression());
          remoteAttribute.validate();
        }
  finally {
          listener.setEnabled(true);
        }
      }
      _LOGGER.info(""String_Node_Str"");
    }
 else     if (token instanceof PingToken) {
      _proxyModelInfrastructure.getExecutor().execute(new PongTask(new PongToken(((PingToken)token).getTimestamp())));
      _LOGGER.info(""String_Node_Str"");
    }
 else     if (token instanceof PongToken) {
      _proxyModelInfrastructure.setLastPongToken((PongToken)token);
      _LOGGER.info(""String_Node_Str"");
    }
  }
}","/** 
 * Callback method when a message from the topic is received.
 * @param topicName The name of the topic from which the message was received.
 * @param payload The MQTT message.
 * @param qos The Quality of Service at which the message was delivered by the broker.
 * @param retained indicates if this message is retained by the broker.
 * @see com.ibm.mqtt.MqttSimpleCallback#publishArrived(java.lang.String,byte[],int,boolean)
 * @exception Exception if there is a problem reading next token or setting attribute value
 */
public void publishArrived(String topicName,byte[] payload,int qos,boolean retained) throws Exception {
  Tokenizer tokenizer=new Tokenizer(payload);
  Token token=null;
  _LOGGER.fine(""String_Node_Str"" + _batchCount++);
  while ((token=tokenizer.getNextToken()) != null) {
    if (token instanceof CommunicationToken) {
      CommunicationToken communicationToken=(CommunicationToken)token;
      ProxySourceData data=_proxyModelInfrastructure.getProxySourceMap().get(communicationToken.getTargetActorName());
      data.getTokenQueue().add(communicationToken);
synchronized (data.getProxySource()) {
        data.getProxySource().notifyAll();
      }
    }
 else     if (token instanceof AttributeChangeToken) {
      AttributeChangeToken attributeChangeToken=(AttributeChangeToken)token;
      Settable remoteAttribute=_proxyModelInfrastructure.getRemoteAttributesMap().get(attributeChangeToken.getTargetSettableName());
      ProxyValueListener listener=_proxyModelInfrastructure.getRemoteAttributeListenersMap().get(attributeChangeToken.getTargetSettableName());
synchronized (listener) {
        try {
          listener.setEnabled(false);
          remoteAttribute.setExpression(attributeChangeToken.getExpression());
          remoteAttribute.validate();
        }
  finally {
          listener.setEnabled(true);
        }
      }
      _LOGGER.info(""String_Node_Str"");
    }
 else     if (token instanceof PingToken) {
      _proxyModelInfrastructure.getExecutor().execute(new PongTask(new PongToken(((PingToken)token).getTimestamp())));
      _LOGGER.info(""String_Node_Str"");
    }
 else     if (token instanceof PongToken) {
      _proxyModelInfrastructure.setLastPongToken((PongToken)token);
      _LOGGER.info(""String_Node_Str"");
    }
 else     if (token instanceof RemoteEventToken) {
      _proxyModelInfrastructure.fireServerEvent((RemoteEventToken)token);
    }
  }
}"
73265,"/** 
 * Start the timer that sends token batches.
 * @param ticket Ticket on which to start the publishing timer.
 */
public void startTimer(Ticket ticket){
  _executor=Executors.newSingleThreadScheduledExecutor();
  _executor.scheduleAtFixedRate(new Runnable(){
    public void run(){
      try {
        _sendBatch();
      }
 catch (      Throwable e) {
        _proxyModelInfrastructure.fireModelException(""String_Node_Str"",e);
      }
    }
  }
,0,_period,TimeUnit.MILLISECONDS);
}","/** 
 * Start the timer that sends token batches.
 * @param ticket Ticket on which to start the publishing timer.
 */
public void startTimer(Ticket ticket){
  _executor=Executors.newSingleThreadScheduledExecutor();
  _publisherFuture=_executor.scheduleAtFixedRate(new Runnable(){
    public void run(){
      try {
        _sendBatch();
      }
 catch (      Throwable e) {
        _proxyModelInfrastructure.fireModelException(""String_Node_Str"",e);
      }
    }
  }
,0,_period,TimeUnit.MILLISECONDS);
}"
73266,"/** 
 * Generate the main entry point.
 * @return Return the definition of the main entry point for a program. InC, this would be defining main().
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateMainEntryCode() throws IllegalActionException {
  StringBuffer mainEntryCode=new StringBuffer();
  if (_isTopLevel()) {
    mainEntryCode.append(_eol + _eol + ""String_Node_Str""+ _eol+ _sanitizedModelName+ ""String_Node_Str""+ _sanitizedModelName+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
  }
 else {
    if ((getContainer() instanceof ModularCodeGenTypedCompositeActor) && ((Actor)getContainer()).outputPortList().size() > 0) {
      mainEntryCode.append(_eol + _eol + ""String_Node_Str""+ _eol);
    }
 else {
      mainEntryCode.append(_eol + _eol + ""String_Node_Str""+ _eol);
    }
    boolean addComma=false;
    Iterator<?> inputPorts=((Actor)getContainer()).inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
      if (inputPort.getWidth() > 0) {
        String type=codeGenType2(inputPort.getType());
        if (!type.equals(""String_Node_Str"") && !isPrimitive(codeGenType(inputPort.getType()))) {
          type=""String_Node_Str"";
        }
        for (int i=0; i < inputPort.getWidth(); i++) {
          if (addComma) {
            mainEntryCode.append(""String_Node_Str"");
          }
          if (DFUtilities.getTokenConsumptionRate(inputPort) > 1) {
            mainEntryCode.append(type + ""String_Node_Str"" + inputPort.getName()+ ""String_Node_Str""+ i);
          }
 else {
            mainEntryCode.append(type + ""String_Node_Str"" + inputPort.getName()+ ""String_Node_Str""+ i);
          }
          addComma=true;
        }
      }
    }
    mainEntryCode.append(""String_Node_Str"" + _eol);
  }
  return _processCode(mainEntryCode.toString());
}","/** 
 * Generate the main entry point.
 * @return Return the definition of the main entry point for a program. InC, this would be defining main().
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateMainEntryCode() throws IllegalActionException {
  StringBuffer mainEntryCode=new StringBuffer();
  if (_isTopLevel()) {
    mainEntryCode.append(_eol + _eol + ""String_Node_Str""+ _eol+ _sanitizedModelName+ ""String_Node_Str""+ _sanitizedModelName+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
  }
 else {
    boolean addComma=false;
    if ((getContainer() instanceof ModularCodeGenTypedCompositeActor) && ((Actor)getContainer()).outputPortList().size() > 0) {
      mainEntryCode.append(_eol + _eol + ""String_Node_Str""+ _eol);
      addComma=true;
    }
 else {
      mainEntryCode.append(_eol + _eol + ""String_Node_Str""+ _eol);
    }
    Iterator<?> inputPorts=((Actor)getContainer()).inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
      if (inputPort.getWidth() > 0) {
        String type=codeGenType2(inputPort.getType());
        if (!type.equals(""String_Node_Str"") && !isPrimitive(codeGenType(inputPort.getType()))) {
          type=""String_Node_Str"";
        }
        for (int i=0; i < inputPort.getWidth(); i++) {
          if (addComma) {
            mainEntryCode.append(""String_Node_Str"");
          }
          if (DFUtilities.getTokenConsumptionRate(inputPort) > 1) {
            mainEntryCode.append(type + ""String_Node_Str"" + inputPort.getName()+ ""String_Node_Str""+ i);
          }
 else {
            mainEntryCode.append(type + ""String_Node_Str"" + inputPort.getName()+ ""String_Node_Str""+ i);
          }
          addComma=true;
        }
      }
    }
    mainEntryCode.append(""String_Node_Str"" + _eol);
  }
  return _processCode(mainEntryCode.toString());
}"
73267,"/** 
 * Layout the given composite. Main entry point for the layout action. Create a KIELER KGraph data structure corresponding to the Ptolemy model, instantiate a KIELER layout algorithm (AbstractLayoutProvider) and run its doLayout() method on the KGraph. The KGraph is augmented with layout information (position and sizes of objects and bend points for connections). This information is then reapplied to the ptolemy model by stating MoMLChangeRequests with location attributes for nodes. Connection bend points are applied using   {@link LayoutHint}s.
 * @param composite the container of the diagram in terms of a GraphModel.
 */
@Override public void layout(Object composite){
  long overallTime=System.currentTimeMillis();
  _report(""String_Node_Str"");
  long graphOverhead=System.currentTimeMillis();
  KNode parentNode=KimlUtil.createInitializedNode();
  KShapeLayout parentLayout=parentNode.getData(KShapeLayout.class);
  Options._configureLayout(parentLayout,_layoutOptions,getLayoutTarget().getGraphModel());
  _createGraph(composite,parentNode);
  graphOverhead=System.currentTimeMillis() - graphOverhead;
  InstancePool<AbstractLayoutProvider> layouterPool=_getLayouterPool();
  AbstractLayoutProvider layoutProvider=layouterPool.fetch();
  IKielerProgressMonitor progressMonitor=new BasicProgressMonitor();
  layoutProvider.doLayout(parentNode,progressMonitor);
  if (DEBUG) {
    KielerGraphUtil._writeToFile(parentNode);
  }
  KVector offset=KielerGraphUtil._getUpperLeftCorner(parentNode);
  parentLayout.setXpos(parentLayout.getXpos() - (float)offset.x);
  parentLayout.setYpos(parentLayout.getYpos() - (float)offset.y);
  long momlRequestOverhead=System.currentTimeMillis();
  try {
    _applyLayout(parentNode);
    momlRequestOverhead=System.currentTimeMillis() - momlRequestOverhead;
    overallTime=System.currentTimeMillis() - overallTime;
    _report(""String_Node_Str"" + overallTime + ""String_Node_Str""+ graphOverhead+ ""String_Node_Str""+ Math.round(progressMonitor.getExecutionTime() * 1000)+ ""String_Node_Str""+ momlRequestOverhead+ ""String_Node_Str"");
    layouterPool.release(layoutProvider);
  }
 catch (  IllegalActionException e) {
    throw new GraphInvalidStateException(e,""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Layout the given composite. Main entry point for the layout action. Create a KIELER KGraph data structure corresponding to the Ptolemy model, instantiate a KIELER layout algorithm (AbstractLayoutProvider) and run its doLayout() method on the KGraph. The KGraph is augmented with layout information (position and sizes of objects and bend points for connections). This information is then reapplied to the ptolemy model by stating MoMLChangeRequests with location attributes for nodes. Connection bend points are applied using   {@link LayoutHint}s.
 * @param composite the container of the diagram in terms of a GraphModel.
 */
@Override public void layout(Object composite){
  long overallTime=System.currentTimeMillis();
  _report(""String_Node_Str"");
  long graphOverhead=overallTime;
  KNode parentNode=KimlUtil.createInitializedNode();
  KShapeLayout parentLayout=parentNode.getData(KShapeLayout.class);
  if (_top != null) {
    Dimension contentSize=_top.getContentSize();
    parentLayout.setWidth(contentSize.width);
    parentLayout.setHeight(contentSize.height);
  }
  Options._configureLayout(parentLayout,_layoutOptions,getLayoutTarget().getGraphModel());
  _createGraph(composite,parentNode);
  graphOverhead=System.currentTimeMillis() - graphOverhead;
  InstancePool<AbstractLayoutProvider> layouterPool=_getLayouterPool();
  AbstractLayoutProvider layoutProvider=layouterPool.fetch();
  IKielerProgressMonitor progressMonitor=new BasicProgressMonitor();
  layoutProvider.doLayout(parentNode,progressMonitor);
  if (DEBUG) {
    KielerGraphUtil._writeToFile(parentNode);
  }
  KVector offset=KielerGraphUtil._getUpperLeftCorner(parentNode);
  parentLayout.setXpos(parentLayout.getXpos() - (float)offset.x);
  parentLayout.setYpos(parentLayout.getYpos() - (float)offset.y);
  long momlRequestOverhead=System.currentTimeMillis();
  try {
    _applyLayout(parentNode);
    momlRequestOverhead=System.currentTimeMillis() - momlRequestOverhead;
    overallTime=System.currentTimeMillis() - overallTime;
    _report(""String_Node_Str"" + overallTime + ""String_Node_Str""+ graphOverhead+ ""String_Node_Str""+ Math.round(progressMonitor.getExecutionTime() * 1000)+ ""String_Node_Str""+ momlRequestOverhead+ ""String_Node_Str"");
    layouterPool.release(layoutProvider);
  }
 catch (  IllegalActionException e) {
    throw new GraphInvalidStateException(e,""String_Node_Str"" + e.getMessage());
  }
}"
73268,"/** 
 * Create a KIELER edge for a Ptolemy Diva edge object. The KEdge will be setup between either two ports or relation vertices or mixed. Hence the KEdge corresponds more likely to a Ptolemy link than a relation. Diva edges have no direction related to the flow of data in Ptolemy. However, KIELER uses a directed graph to perform layout and so a meaningful direction should be set in the KEdge. This direction will be approximated by doing a tree search beginning on both endpoints of the Diva edge. Whenever either of the endpoints is connected to a source port, this will be the source of the KEdge and determine its direction. The newly created edge is stored with the corresponding Diva edge in the global maps _ptolemyDiva2KielerEdges, _kieler2PtolemyDivaEdges, such that the   {@link #_applyLayout(KNode)} method will be able to reapply thelayout.
 * @param divaEdge The Ptolemy diva edge object for which to create a new KEdge.
 */
private void _createKEdge(Link divaEdge){
  KEdge kedge=KimlUtil.createInitializedEdge();
  Object source=_divaEdgeSource.get(divaEdge);
  if (source == null) {
    source=divaEdge.getTail();
  }
  Object target=_divaEdgeTarget.get(divaEdge);
  if (target == null) {
    target=divaEdge.getHead();
  }
  KPort kSourcePort=_getPort(source,PortType.OUTPUT,divaEdge.getRelation());
  if (kSourcePort != null) {
    kedge.setSourcePort(kSourcePort);
    kSourcePort.getEdges().add(kedge);
    kedge.setSource(kSourcePort.getNode());
  }
 else {
    kedge.setSource(_kieler2ptolemyDivaNodes.inverse().get(source));
  }
  KPort kTargetPort=_getPort(target,PortType.INPUT,divaEdge.getRelation());
  if (kTargetPort != null) {
    kedge.setTargetPort(kTargetPort);
    kTargetPort.getEdges().add(kedge);
    kedge.setTarget(kTargetPort.getNode());
  }
 else {
    kedge.setTarget(_kieler2ptolemyDivaNodes.inverse().get(target));
  }
  _edgeList.add(new Pair<KEdge,Link>(kedge,divaEdge));
  Object figure=getLayoutTarget().getVisualObject(divaEdge);
  if (figure instanceof AbstractConnector) {
    LabelFigure labelFigure=((AbstractConnector)figure).getLabelFigure();
    if (labelFigure != null) {
      KLabel label=KimlUtil.createInitializedLabel(kedge);
      label.setText(labelFigure.getString());
      KShapeLayout labelLayout=label.getData(KShapeLayout.class);
      labelLayout.setProperty(LayoutOptions.EDGE_LABEL_PLACEMENT,EdgeLabelPlacement.CENTER);
      Rectangle2D bounds=labelFigure.getBounds();
      labelLayout.setWidth((float)bounds.getWidth());
      labelLayout.setHeight((float)bounds.getHeight());
    }
  }
}","/** 
 * Create a KIELER edge for a Ptolemy Diva edge object. The KEdge will be setup between either two ports or relation vertices or mixed. Hence the KEdge corresponds more likely to a Ptolemy link than a relation. Diva edges have no direction related to the flow of data in Ptolemy. However, KIELER uses a directed graph to perform layout and so a meaningful direction should be set in the KEdge. This direction will be approximated by doing a tree search beginning on both endpoints of the Diva edge. Whenever either of the endpoints is connected to a source port, this will be the source of the KEdge and determine its direction. The newly created edge is stored with the corresponding Diva edge in the global maps _ptolemyDiva2KielerEdges, _kieler2PtolemyDivaEdges, such that the   {@link #_applyLayout(KNode)} method will be able to reapply thelayout.
 * @param divaEdge The Ptolemy diva edge object for which to create a new KEdge.
 */
private void _createKEdge(Link divaEdge){
  KEdge kedge=KimlUtil.createInitializedEdge();
  Object source=_divaEdgeSource.get(divaEdge);
  if (source == null) {
    source=divaEdge.getTail();
  }
  Object target=_divaEdgeTarget.get(divaEdge);
  if (target == null) {
    target=divaEdge.getHead();
  }
  KPort kSourcePort=_getPort(source,PortType.OUTPUT,divaEdge.getRelation());
  if (kSourcePort != null) {
    kedge.setSourcePort(kSourcePort);
    kSourcePort.getEdges().add(kedge);
    kedge.setSource(kSourcePort.getNode());
  }
 else {
    kedge.setSource(_kieler2ptolemyDivaNodes.inverse().get(source));
  }
  KPort kTargetPort=_getPort(target,PortType.INPUT,divaEdge.getRelation());
  if (kTargetPort != null) {
    kedge.setTargetPort(kTargetPort);
    kTargetPort.getEdges().add(kedge);
    kedge.setTarget(kTargetPort.getNode());
  }
 else {
    kedge.setTarget(_kieler2ptolemyDivaNodes.inverse().get(target));
  }
  KEdgeLayout edgeLayout=kedge.getData(KEdgeLayout.class);
  if (source instanceof Locatable) {
    double[] pos=((Locatable)source).getLocation();
    edgeLayout.getSourcePoint().setX((float)pos[0]);
    edgeLayout.getSourcePoint().setY((float)pos[1]);
  }
  if (target instanceof Locatable) {
    double[] pos=((Locatable)target).getLocation();
    edgeLayout.getTargetPoint().setX((float)pos[0]);
    edgeLayout.getTargetPoint().setY((float)pos[1]);
  }
  _edgeList.add(new Pair<KEdge,Link>(kedge,divaEdge));
  Object figure=getLayoutTarget().getVisualObject(divaEdge);
  if (figure instanceof AbstractConnector) {
    LabelFigure labelFigure=((AbstractConnector)figure).getLabelFigure();
    if (labelFigure != null) {
      KLabel label=KimlUtil.createInitializedLabel(kedge);
      label.setText(labelFigure.getString());
      KShapeLayout labelLayout=label.getData(KShapeLayout.class);
      labelLayout.setProperty(LayoutOptions.EDGE_LABEL_PLACEMENT,EdgeLabelPlacement.CENTER);
      Rectangle2D bounds=labelFigure.getBounds();
      labelLayout.setWidth((float)bounds.getWidth());
      labelLayout.setHeight((float)bounds.getHeight());
      labelLayout.setXpos((edgeLayout.getSourcePoint().getX() + edgeLayout.getTargetPoint().getX()) / 2);
      labelLayout.setYpos((edgeLayout.getSourcePoint().getY() + edgeLayout.getTargetPoint().getY()) / 2);
      kedge.getLabels().add(label);
    }
  }
}"
73269,"/** 
 * Creates a graph for the KIELER API from a Ptolemy model. Will traverse the low level GraphModel given by the composite and record all found elements in the mapping fields of this object that keep a mapping between Ptolemy/Diva objects and KIELER objects. New KIELER objects (KEdge, KNode, KPort) are created for their respective Ptolemy counterparts and initialized with the initial sizes and positions and are put in a composite KNode (the graph KIELER will perform the layout on later). To obtain the right mappings, multiple abstraction levels of Ptolemy are considered here: Diva, as this was the intended original way to do automatic layout (e.g. by GlobalAbstractLayout) and Ptolemy, since Diva lacks certain concepts that are relevant for a proper layout, such as exact port locations for considering port constraints in the model, which are supported by KIELER.
 * @param composite The GraphModel composite object to retrieve the modelinformation from
 * @param parentNode KIELER subgraph to receive all connectedmodel elements
 */
private void _createGraph(Object composite,KNode parentNode){
  _kieler2ptolemyDivaNodes=HashBiMap.create();
  _ptolemy2KielerPorts=LinkedListMultimap.create();
  _divaEdgeSource=Maps.newHashMap();
  _divaEdgeTarget=Maps.newHashMap();
  _edgeList=Lists.newLinkedList();
  boolean doBoxLayout=_layoutOptions.getProperty(Options.DECORATIONS);
  float globalX=Float.MAX_VALUE, globalY=Float.MAX_VALUE;
  GraphModel graphModel=getLayoutTarget().getGraphModel();
  ExternalPortModel externalPortModel=null;
  if (graphModel instanceof ActorGraphModel) {
    externalPortModel=((ActorGraphModel)graphModel).getExternalPortModel();
  }
  List<Link> unprocessedEdges=new LinkedList<Link>();
  List<NamedObj> unprocessedRelatives=new LinkedList<NamedObj>();
  for (Iterator iterator=graphModel.nodes(composite); iterator.hasNext(); ) {
    Object node=iterator.next();
    if (!(node instanceof Locatable)) {
      continue;
    }
    Iterator portIter=null;
    NamedObj semanticNode=(NamedObj)graphModel.getSemanticObject(node);
    if (doBoxLayout || PtolemyModelUtil._isConnected(semanticNode)) {
      KNode knode=null;
      if (semanticNode instanceof Actor || semanticNode instanceof Attribute) {
        knode=_createKNode(node,semanticNode);
        if (semanticNode instanceof Actor && semanticNode instanceof Entity) {
          Actor actor=(Actor)semanticNode;
          List<Port> inputs=actor.inputPortList();
          List<Port> outputs=actor.outputPortList();
          _createKPorts(knode,inputs,PortType.INPUT);
          _createKPorts(knode,outputs,PortType.OUTPUT);
          portIter=graphModel.nodes(node);
        }
 else         if (semanticNode instanceof RelativeLocatable) {
          unprocessedRelatives.add(semanticNode);
        }
      }
 else       if (semanticNode instanceof Relation) {
        knode=_createKNodeForVertex((Vertex)node);
        portIter=Iterators.singletonIterator(node);
      }
 else       if (semanticNode instanceof ComponentPort) {
        knode=_createKNodeForPort(node,(ComponentPort)semanticNode);
        portIter=Iterators.singletonIterator(node);
      }
 else       if (semanticNode instanceof State) {
        knode=_createKNodeForState(node,(State)semanticNode);
        portIter=Iterators.singletonIterator(node);
      }
      if (knode != null) {
        knode.setParent(parentNode);
        KShapeLayout layout=knode.getData(KShapeLayout.class);
        if (layout.getXpos() < globalX) {
          globalX=layout.getXpos();
        }
        if (layout.getYpos() < globalY) {
          globalY=layout.getYpos();
        }
        _kieler2ptolemyDivaNodes.put(knode,(Locatable)node);
      }
    }
    if (portIter != null) {
      while (portIter.hasNext()) {
        Object divaPort=portIter.next();
        Iterator edgeIterator;
        if (semanticNode instanceof Port && externalPortModel != null) {
          edgeIterator=externalPortModel.outEdges(divaPort);
        }
 else {
          edgeIterator=graphModel.outEdges(divaPort);
        }
        while (edgeIterator.hasNext()) {
          Object next=edgeIterator.next();
          if (next instanceof Link) {
            unprocessedEdges.add((Link)next);
          }
        }
      }
    }
  }
  if (graphModel instanceof ActorGraphModel) {
    _storeEndpoints(unprocessedEdges);
  }
  for (  Link divaEdge : unprocessedEdges) {
    _createKEdge(divaEdge);
  }
  for (  NamedObj relativeObj : unprocessedRelatives) {
    Locatable source=PtolemyModelUtil._getLocation(relativeObj);
    if (source instanceof RelativeLocation) {
      NamedObj referenceObj=PtolemyModelUtil._getReferencedObj((RelativeLocation)source);
      if (referenceObj != null) {
        Locatable target=PtolemyModelUtil._getLocation(referenceObj);
        _createKEdgeForAttribute(source,target);
      }
    }
  }
  KShapeLayout layout=parentNode.getData(KShapeLayout.class);
  layout.setXpos(globalX);
  layout.setYpos(globalY);
}","/** 
 * Creates a graph for the KIELER API from a Ptolemy model. Will traverse the low level GraphModel given by the composite and record all found elements in the mapping fields of this object that keep a mapping between Ptolemy/Diva objects and KIELER objects. New KIELER objects (KEdge, KNode, KPort) are created for their respective Ptolemy counterparts and initialized with the initial sizes and positions and are put in a composite KNode (the graph KIELER will perform the layout on later). To obtain the right mappings, multiple abstraction levels of Ptolemy are considered here: Diva, as this was the intended original way to do automatic layout (e.g. by GlobalAbstractLayout) and Ptolemy, since Diva lacks certain concepts that are relevant for a proper layout, such as exact port locations for considering port constraints in the model, which are supported by KIELER.
 * @param composite The GraphModel composite object to retrieve the modelinformation from
 * @param parentNode KIELER subgraph to receive all connectedmodel elements
 */
private void _createGraph(Object composite,KNode parentNode){
  _kieler2ptolemyDivaNodes=HashBiMap.create();
  _ptolemy2KielerPorts=LinkedListMultimap.create();
  _divaEdgeSource=Maps.newHashMap();
  _divaEdgeTarget=Maps.newHashMap();
  _edgeList=Lists.newLinkedList();
  boolean doBoxLayout=_layoutOptions.getProperty(Options.DECORATIONS);
  float globalX=Float.MAX_VALUE, globalY=Float.MAX_VALUE;
  GraphModel graphModel=getLayoutTarget().getGraphModel();
  ExternalPortModel externalPortModel=null;
  if (graphModel instanceof ActorGraphModel) {
    externalPortModel=((ActorGraphModel)graphModel).getExternalPortModel();
  }
  List<Link> unprocessedEdges=new LinkedList<Link>();
  List<NamedObj> unprocessedRelatives=new LinkedList<NamedObj>();
  for (Iterator iterator=graphModel.nodes(composite); iterator.hasNext(); ) {
    Object node=iterator.next();
    if (!(node instanceof Locatable)) {
      continue;
    }
    Iterator portIter=null;
    NamedObj semanticNode=(NamedObj)graphModel.getSemanticObject(node);
    if (doBoxLayout || PtolemyModelUtil._isConnected(semanticNode)) {
      KNode knode=null;
      if (semanticNode instanceof Actor || semanticNode instanceof Attribute) {
        knode=_createKNode(node,semanticNode);
        if (semanticNode instanceof Actor && semanticNode instanceof Entity) {
          Actor actor=(Actor)semanticNode;
          List<Port> inputs=actor.inputPortList();
          List<Port> outputs=actor.outputPortList();
          _createKPorts(knode,inputs,PortType.INPUT);
          _createKPorts(knode,outputs,PortType.OUTPUT);
          portIter=graphModel.nodes(node);
        }
 else         if (semanticNode instanceof RelativeLocatable) {
          unprocessedRelatives.add(semanticNode);
        }
      }
 else       if (semanticNode instanceof Relation) {
        knode=_createKNodeForVertex((Vertex)node);
        portIter=Iterators.singletonIterator(node);
      }
 else       if (semanticNode instanceof ComponentPort) {
        knode=_createKNodeForPort(node,(ComponentPort)semanticNode);
        portIter=Iterators.singletonIterator(node);
      }
 else       if (semanticNode instanceof State) {
        knode=_createKNodeForState(node,(State)semanticNode);
        portIter=Iterators.singletonIterator(node);
      }
      if (knode != null) {
        knode.setParent(parentNode);
        KShapeLayout layout=knode.getData(KShapeLayout.class);
        if (layout.getXpos() < globalX) {
          globalX=layout.getXpos();
        }
        if (layout.getYpos() < globalY) {
          globalY=layout.getYpos();
        }
        _kieler2ptolemyDivaNodes.put(knode,(Locatable)node);
      }
    }
    if (portIter != null) {
      while (portIter.hasNext()) {
        Object divaPort=portIter.next();
        Iterator edgeIterator;
        if (semanticNode instanceof Port && externalPortModel != null) {
          edgeIterator=externalPortModel.outEdges(divaPort);
        }
 else {
          edgeIterator=graphModel.outEdges(divaPort);
        }
        while (edgeIterator.hasNext()) {
          Object next=edgeIterator.next();
          if (next instanceof Link) {
            unprocessedEdges.add((Link)next);
          }
        }
      }
    }
  }
  if (graphModel instanceof ActorGraphModel) {
    _storeEndpoints(unprocessedEdges);
  }
  for (  Link divaEdge : unprocessedEdges) {
    _createKEdge(divaEdge);
  }
  for (  NamedObj relativeObj : unprocessedRelatives) {
    _createKEdgeForAttribute(relativeObj);
  }
  KShapeLayout layout=parentNode.getData(KShapeLayout.class);
  layout.setXpos(globalX);
  layout.setYpos(globalY);
}"
73270,"/** 
 * Create a dummy edge for an attribute that is relative locatable. The edge will only be used to indicate the association between the attribute and its reference object.
 * @param source the source locatable node
 * @param target the target locatable node
 */
private void _createKEdgeForAttribute(Locatable source,Locatable target){
  KNode sourceNode=_kieler2ptolemyDivaNodes.inverse().get(source);
  KNode targetNode=_kieler2ptolemyDivaNodes.inverse().get(target);
  if (sourceNode != null && targetNode != null) {
    KEdge newEdge=KimlUtil.createInitializedEdge();
    newEdge.setSource(sourceNode);
    newEdge.setTarget(targetNode);
    KEdgeLayout edgeLayout=newEdge.getData(KEdgeLayout.class);
    double[] sourcePos=source.getLocation();
    edgeLayout.getSourcePoint().setX((float)sourcePos[0]);
    edgeLayout.getSourcePoint().setY((float)sourcePos[1]);
    double[] targetPos=target.getLocation();
    edgeLayout.getTargetPoint().setX((float)targetPos[0]);
    edgeLayout.getTargetPoint().setY((float)targetPos[1]);
  }
}","/** 
 * Create a dummy edge for an attribute that is relative locatable. The edge will only be used to indicate the association between the attribute and its reference object.
 * @param attribute the attribute for which to create a dummy edge
 */
private void _createKEdgeForAttribute(NamedObj attribute){
  Locatable source=PtolemyModelUtil._getLocation(attribute);
  if (source instanceof RelativeLocation) {
    NamedObj referenceObj=PtolemyModelUtil._getReferencedObj((RelativeLocation)source);
    if (referenceObj != null) {
      Locatable target=PtolemyModelUtil._getLocation(referenceObj);
      KNode sourceNode=_kieler2ptolemyDivaNodes.inverse().get(source);
      KNode targetNode=_kieler2ptolemyDivaNodes.inverse().get(target);
      if (sourceNode != null && targetNode != null) {
        KEdge newEdge=KimlUtil.createInitializedEdge();
        newEdge.setSource(sourceNode);
        newEdge.setTarget(targetNode);
        KEdgeLayout edgeLayout=newEdge.getData(KEdgeLayout.class);
        double[] sourcePos=source.getLocation();
        edgeLayout.getSourcePoint().setX((float)sourcePos[0]);
        edgeLayout.getSourcePoint().setY((float)sourcePos[1]);
        double[] targetPos=target.getLocation();
        edgeLayout.getTargetPoint().setX((float)targetPos[0]);
        edgeLayout.getTargetPoint().setY((float)targetPos[1]);
      }
    }
  }
}"
73271,"/** 
 * Return the node controller appropriate for the given node.
 */
public NodeController getNodeController(Object object){
  NodeController result=super.getNodeController(object);
  if (result != null) {
    return result;
  }
  if (object instanceof Locatable) {
    Object semanticObject=getGraphModel().getSemanticObject(object);
    if (semanticObject instanceof Entity) {
      return _stateController;
    }
 else     if (semanticObject instanceof Attribute) {
      return _attributeController;
    }
 else     if (semanticObject instanceof Port) {
      return _portController;
    }
  }
  throw new RuntimeException(""String_Node_Str"" + object);
}","/** 
 * Return the node controller appropriate for the given node.
 */
public NodeController getNodeController(Object object){
  NodeController result=super.getNodeController(object);
  if (result != null) {
    return result;
  }
  if (object instanceof Locatable) {
    Object semanticObject=getGraphModel().getSemanticObject(object);
    if (semanticObject instanceof Entity) {
      return _stateController;
    }
 else     if (semanticObject instanceof Attribute) {
      return _attributeController;
    }
 else     if (semanticObject instanceof Port) {
      return _portController;
    }
 else {
      return _locatableController;
    }
  }
  throw new RuntimeException(""String_Node_Str"" + object);
}"
73272,"/** 
 * Create a new controller with default port, state, and transition controllers.
 */
public FSMViewerGraphController(){
  _createControllers();
}","/** 
 * Create a new controller with default port, state, and transition controllers.
 */
public FSMViewerGraphController(){
  _createControllers();
  _locatableController=new LocatableNodeController(this);
}"
73273,"/** 
 * Get the angle in radians from the origin to the other point.
 * @param origin the original point
 * @param other the other point
 * @return angle in radians
 */
private double _getNormal(Point2D origin,Point2D other){
  Point2D normalPoint=new Point2D.Double(other.getX() - origin.getX(),other.getY() - origin.getY());
  double theta=Math.atan2(-normalPoint.getY(),normalPoint.getX());
  return theta;
}","/** 
 * Get the angle in radians from the origin to the other point.
 * @param origin the original point
 * @param other the other point
 * @return angle in radians
 */
private double _getNormal(Point2D origin,Point2D other){
  double normalX=other.getX() - origin.getX();
  double normalY=other.getY() - origin.getY();
  double theta=Math.atan2(normalY,normalX);
  return theta;
}"
73274,"/** 
 * Get the center point of a Perimeter Site. Copied the idea from  {@link PerimeterSite#getPoint(double)}.
 * @param site the site
 * @return the center point of the shape that corresponds to the site
 */
private Point2D _getCenterPoint(Site site){
  try {
    Rectangle bounds=site.getFigure().getShape().getBounds();
    return new Point2D.Double(bounds.getCenterX(),bounds.getCenterY());
  }
 catch (  NullPointerException e) {
    return site.getPoint();
  }
}","/** 
 * Get the center point of a Perimeter Site. Copied the idea from  {@link PerimeterSite#getPoint(double)}.
 * @param site the site
 * @return the center point of the shape that corresponds to the site
 */
private Point2D _getCenterPoint(Site site){
  Figure figure=site.getFigure();
  if (figure == null) {
    return site.getPoint();
  }
  if (site instanceof PortConnectSite && figure.getParent() instanceof Figure) {
    figure=(Figure)figure.getParent();
  }
  Rectangle bounds=figure.getShape().getBounds();
  return new Point2D.Double(bounds.getCenterX(),bounds.getCenterY());
}"
73275,"/** 
 * Tell the connector to route itself between the current positions of the head and tail sites. If bend points are available, draw the line with these instead. Delete bend point information if modification detected (i.e., movement of one or the other end of a link).
 */
public void route(){
  repaint();
  List<Point2D> bendPointList=null;
  Object object=this.getUserObject();
  Link link=null;
  Relation relation=null;
  LayoutHintItem layoutHintItem=null;
  boolean considerBendPoints=false;
  if (object instanceof Link) {
    link=(Link)object;
    relation=link.getRelation();
    if (relation != null) {
      LayoutHint layoutHint=(LayoutHint)relation.getAttribute(""String_Node_Str"");
      if (layoutHint != null) {
        layoutHintItem=layoutHint.getLayoutHintItem(link.getHead(),link.getTail());
        if (layoutHintItem != null) {
          considerBendPoints=layoutHintItem.revalidate();
          if (!considerBendPoints) {
            layoutHint.removeLayoutHintItem(link.getHead(),link.getTail());
            if (layoutHint.isEmpty()) {
              layoutHint.removeLayoutHintProperty(relation);
            }
          }
 else {
            bendPointList=layoutHintItem.getBendPointList();
          }
        }
      }
    }
  }
  Polyline2D polyline=(Polyline2D)getRouter().route(this);
  int count=polyline.getVertexCount();
  if (count > 1) {
    _labelLocation=(new Point2D.Double((polyline.getX(count / 2) + polyline.getX((count / 2) - 1)) / 2,(polyline.getY(count / 2) + polyline.getY((count / 2) - 1)) / 2));
  }
 else {
    _labelLocation=new Point2D.Double(polyline.getX(0),polyline.getY(0));
  }
  if (_bendRadius == 0) {
    setShape(polyline);
  }
 else {
    GeneralPath path=new GeneralPath();
    if (considerBendPoints && bendPointList != null) {
      Point2D[] startEnd=_getHeadTailPoints(this,bendPointList);
      double startX=startEnd[0].getX();
      double startY=startEnd[0].getY();
      double previousX=startX;
      double previousY=startY;
      double endX=startEnd[1].getX();
      double endY=startEnd[1].getY();
      path.moveTo((float)startX,(float)startY);
      bendPointList.add(0,new Point2D.Double(startX,startY));
      bendPointList.add(new Point2D.Double(endX,endY));
      for (int i=1; i <= bendPointList.size() - 1; i++) {
        int i1=i;
        int i0=i - 1;
        if (i0 < 0) {
          i0=0;
        }
        if (i0 > bendPointList.size() - 1) {
          i0=bendPointList.size() - 1;
        }
        double x0=previousX;
        double y0=previousY;
        double x1=bendPointList.get(i0).getX();
        double y1=bendPointList.get(i0).getY();
        double x2=bendPointList.get(i1).getX();
        double y2=bendPointList.get(i1).getY();
        x2=(x1 + x2) / 2;
        y2=(y1 + y2) / 2;
        double d0=Math.sqrt(((x1 - x0) * (x1 - x0)) + ((y1 - y0) * (y1 - y0)));
        double d1=Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));
        double r=Math.min(_bendRadius,d0);
        r=Math.min(r,d1);
        if ((d0 == 0.0) || (d1 == 0.0)) {
          path.lineTo((float)x1,(float)y1);
        }
 else {
          double intX0=x1 + ((r / d0) * (x0 - x1));
          double intY0=y1 + ((r / d0) * (y0 - y1));
          double intX1=x1 + ((r / d1) * (x2 - x1));
          double intY1=y1 + ((r / d1) * (y2 - y1));
          path.lineTo((float)intX0,(float)intY0);
          path.curveTo((float)x1,(float)y1,(float)x1,(float)y1,(float)intX1,(float)intY1);
          previousX=x2;
          previousY=y2;
        }
      }
      path.lineTo((float)endX,(float)endY);
      setShape(path);
      repositionLabel();
      repaint();
    }
 else {
      super.route();
    }
  }
}","/** 
 * Tell the connector to route itself between the current positions of the head and tail sites. If bend points are available, draw the line with these instead. Delete bend point information if modification detected (i.e., movement of one or the other end of a link).
 */
public void route(){
  List<Point2D> bendPointList=null;
  Object object=this.getUserObject();
  Link link=null;
  Relation relation=null;
  LayoutHintItem layoutHintItem=null;
  boolean considerBendPoints=false;
  if (object instanceof Link) {
    link=(Link)object;
    relation=link.getRelation();
    if (relation != null) {
      LayoutHint layoutHint=(LayoutHint)relation.getAttribute(""String_Node_Str"");
      if (layoutHint != null) {
        layoutHintItem=layoutHint.getLayoutHintItem(link.getHead(),link.getTail());
        if (layoutHintItem != null) {
          considerBendPoints=layoutHintItem.revalidate();
          if (considerBendPoints) {
            bendPointList=layoutHintItem.getBendPointList();
          }
 else {
            layoutHint.removeLayoutHintItem(layoutHintItem);
          }
        }
      }
    }
  }
  if (considerBendPoints) {
    repaint();
    GeneralPath path=new GeneralPath();
    Point2D[] startEnd=_getHeadTailPoints(bendPointList);
    double startX=startEnd[0].getX();
    double startY=startEnd[0].getY();
    double previousX=startX;
    double previousY=startY;
    double endX=startEnd[1].getX();
    double endY=startEnd[1].getY();
    path.moveTo((float)startX,(float)startY);
    bendPointList.add(0,new Point2D.Double(startX,startY));
    bendPointList.add(new Point2D.Double(endX,endY));
    for (int i=1; i <= bendPointList.size() - 1; i++) {
      int i1=i;
      int i0=i - 1;
      if (i0 < 0) {
        i0=0;
      }
      if (i0 > bendPointList.size() - 1) {
        i0=bendPointList.size() - 1;
      }
      double x0=previousX;
      double y0=previousY;
      double x1=bendPointList.get(i0).getX();
      double y1=bendPointList.get(i0).getY();
      double x2=bendPointList.get(i1).getX();
      double y2=bendPointList.get(i1).getY();
      x2=(x1 + x2) / 2;
      y2=(y1 + y2) / 2;
      double d0=Math.sqrt(((x1 - x0) * (x1 - x0)) + ((y1 - y0) * (y1 - y0)));
      double d1=Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));
      double r=Math.min(_bendRadius,d0);
      r=Math.min(r,d1);
      if ((d0 == 0.0) || (d1 == 0.0)) {
        path.lineTo((float)x1,(float)y1);
      }
 else {
        double intX0=x1 + ((r / d0) * (x0 - x1));
        double intY0=y1 + ((r / d0) * (y0 - y1));
        double intX1=x1 + ((r / d1) * (x2 - x1));
        double intY1=y1 + ((r / d1) * (y2 - y1));
        path.lineTo((float)intX0,(float)intY0);
        path.curveTo((float)x1,(float)y1,(float)x1,(float)y1,(float)intX1,(float)intY1);
        previousX=x2;
        previousY=y2;
      }
    }
    path.lineTo((float)endX,(float)endY);
    setShape(path);
    int count=bendPointList.size();
    Point2D point1=bendPointList.get(count / 2 - 1);
    Point2D point2=bendPointList.get(count / 2);
    _labelLocation=(new Point2D.Double((point1.getX() + point2.getX()) / 2,(point1.getY() + point2.getY()) / 2));
    repositionLabel();
    repaint();
  }
 else {
    super.route();
  }
}"
73276,"/** 
 * Get the starting and ending points of a connector. Copied some code from  {@link BasicManhattanRouter#routeManhattan(diva.canvas.connector.ManhattanConnector)}.
 * @param c the corresponding connector
 * @param bendPoints a list of bendpoints to determine the anchor point on the site
 * @return the anchor points at the start and end of theconnection, i.e. a Point2D array of size 2
 */
private Point2D[] _getHeadTailPoints(Connector c,List<Point2D> bendPoints){
  TransformContext currentContext=c.getTransformContext();
  Point2D headPt, tailPt;
  Site headSite=c.getHeadSite();
  Site tailSite=c.getTailSite();
  if (currentContext != null) {
    headPt=_getCenterPoint(headSite);
    tailPt=_getCenterPoint(tailSite);
    Point2D headBend, tailBend;
    if (!bendPoints.isEmpty()) {
      headBend=bendPoints.get(0);
      tailBend=bendPoints.get(bendPoints.size() - 1);
    }
 else {
      headBend=tailPt;
      tailBend=headPt;
    }
    headSite.setNormal(_getNormal(headPt,headBend));
    tailSite.setNormal(_getNormal(tailPt,tailBend));
    headPt=headSite.getPoint(currentContext);
    tailPt=tailSite.getPoint(currentContext);
  }
 else {
    tailPt=tailSite.getPoint();
    headPt=headSite.getPoint();
  }
  Point2D[] result={headPt,tailPt};
  return result;
}","/** 
 * Get the starting and ending points of a connector. Copied some code from  {@link BasicManhattanRouter#routeManhattan(diva.canvas.connector.ManhattanConnector)}.
 * @param bendPoints a list of bendpoints to determine the anchor point on the site
 * @return the anchor points at the start and end of theconnection, i.e. a Point2D array of size 2
 */
private Point2D[] _getHeadTailPoints(List<Point2D> bendPoints){
  TransformContext currentContext=getTransformContext();
  Point2D headPt, tailPt;
  Site headSite=getHeadSite();
  Site tailSite=getTailSite();
  if (currentContext != null) {
    headPt=_getCenterPoint(headSite);
    tailPt=_getCenterPoint(tailSite);
    Point2D headBend, tailBend;
    if (!bendPoints.isEmpty()) {
      headBend=bendPoints.get(0);
      tailBend=bendPoints.get(bendPoints.size() - 1);
    }
 else {
      headBend=tailPt;
      tailBend=headPt;
    }
    headSite.setNormal(_getNormal(headPt,headBend));
    tailSite.setNormal(_getNormal(tailPt,tailBend));
    headPt=headSite.getPoint(currentContext);
    tailPt=tailSite.getPoint(currentContext);
  }
 else {
    tailPt=tailSite.getPoint();
    headPt=headSite.getPoint();
  }
  Point2D[] result={headPt,tailPt};
  return result;
}"
73277,"/** 
 * Read a token from each input port.  If the token from the <i>control</i> input is true, then output the token consumed from the <i>trueInput</i> port, otherwise output the token from the <i>falseInput</i> port.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (_control == null) {
    _control=((BooleanToken)control.get(0));
    _controlUsed=false;
  }
 else {
    if (_control.booleanValue()) {
      for (int i=0; i < trueInput.getWidth(); i++) {
        if (output.getWidth() > i) {
          output.send(i,trueInput.get(i));
        }
      }
    }
 else {
      for (int i=0; i < falseInput.getWidth(); i++) {
        if (output.getWidth() > i) {
          output.send(i,falseInput.get(i));
        }
      }
    }
    _controlUsed=true;
  }
}","/** 
 * Read a token from the control port or from the input designated by the previously read input from the control port.  In the latter case, send to the token read to the output. In the former case, send nothing to the output.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (_control == null) {
    _control=((BooleanToken)control.get(0));
    _controlUsed=false;
  }
 else {
    if (_control.booleanValue()) {
      for (int i=0; i < trueInput.getWidth(); i++) {
        if (output.getWidth() > i) {
          output.send(i,trueInput.get(i));
        }
      }
    }
 else {
      for (int i=0; i < falseInput.getWidth(); i++) {
        if (output.getWidth() > i) {
          output.send(i,falseInput.get(i));
        }
      }
    }
    _controlUsed=true;
  }
}"
73278,"/** 
 * Return 0.0 unless the <i>delay</i> port is connected, in which case, return the value of <i>minimumDelay</i>.
 * @return The minimum delay from the input to the output.
 * @throws IllegalActionException If the <i>minimumDelay</i>parameter cannot be evaluated.
 */
protected double _minimumDelay() throws IllegalActionException {
  double minimumDelayValue=0.0;
  if (delay.getPort().sourcePortList().size() > 0) {
    minimumDelayValue=((DoubleToken)(minimumDelay.getToken())).doubleValue();
  }
  return minimumDelayValue;
}","/** 
 * Return 0.0 unless the <i>delay</i> port is connected, in which case, return the value of <i>minimumDelay</i>.
 * @return The minimum delay from the input to the output.
 * @throws IllegalActionException If the <i>minimumDelay</i>parameter cannot be evaluated.
 */
protected double _minimumDelay() throws IllegalActionException {
  double minimumDelayValue=_minimumDelay;
  if (delay.getPort().sourcePortList().size() > 0) {
    minimumDelayValue=((DoubleToken)(minimumDelay.getToken())).doubleValue();
  }
  return minimumDelayValue;
}"
73279,"/** 
 * If the attribute is <i>delay</i>, then ensure that the value is non-negative. <p>NOTE: the newDelay may be 0.0, which may change the causality property of the model. We leave the model designers to decide whether the zero delay is really what they want.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the delay is negative.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == delay) {
    double newDelay=((DoubleToken)(delay.getToken())).doubleValue();
    double minimumDelayValue=_minimumDelay();
    if (newDelay < minimumDelayValue) {
      throw new IllegalActionException(this,""String_Node_Str"" + minimumDelayValue + ""String_Node_Str""+ newDelay);
    }
 else {
      _delay=newDelay;
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If the attribute is <i>delay</i>, then ensure that the value is non-negative. <p>NOTE: the newDelay may be 0.0, which may change the causality property of the model. We leave the model designers to decide whether the zero delay is really what they want.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the delay is negative.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == delay) {
    double newDelay=((DoubleToken)(delay.getToken())).doubleValue();
    double minimumDelayValue=_minimumDelay();
    if (newDelay < minimumDelayValue) {
      throw new IllegalActionException(this,""String_Node_Str"" + minimumDelayValue + ""String_Node_Str""+ newDelay);
    }
 else {
      _delay=newDelay;
    }
  }
 else   if (attribute == minimumDelay) {
    double newMinimumDelay=((DoubleToken)(minimumDelay.getToken())).doubleValue();
    if (newMinimumDelay > _delay) {
      throw new IllegalActionException(this,""String_Node_Str"" + _delay + ""String_Node_Str"");
    }
 else {
      _minimumDelay=newMinimumDelay;
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
73280,"/** 
 * Create an editor for configuring the specified object with the specified parent window.
 * @param object The object to configure.
 * @param parent The parent window, or null if there is none.
 */
public void createEditor(NamedObj object,Frame parent){
  try {
    Configuration configuration=((TableauFrame)parent).getConfiguration();
    NamedObj container=object.getContainer();
    plot=new Plot();
    plot.setTitle(""String_Node_Str"");
    plot.setButtons(true);
    plot.setMarksStyle(""String_Node_Str"");
    Effigy effigy=Configuration.findEffigy(toplevel());
    PlotEffigy schedulePlotterEffigy=new PlotEffigy(effigy,container.uniqueName(""String_Node_Str""));
    schedulePlotterEffigy.setPlot(plot);
    schedulePlotterEffigy.identifier.setExpression(""String_Node_Str"");
    configuration.createPrimaryTableau(schedulePlotterEffigy);
    plot.setVisible(true);
  }
 catch (  Throwable throwable) {
    throw new InternalErrorException(object,throwable,""String_Node_Str"");
  }
}","/** 
 * Create an editor for configuring the specified object with the specified parent window.
 * @param object The object to configure.
 * @param parent The parent window, or null if there is none.
 */
public void createEditor(NamedObj object,Frame parent){
  try {
    Configuration configuration=((TableauFrame)parent).getConfiguration();
    NamedObj container=object.getContainer();
    plot=new Plot();
    plot.setTitle(""String_Node_Str"");
    plot.setButtons(true);
    plot.setMarksStyle(""String_Node_Str"");
    Effigy effigy=Configuration.findEffigy(toplevel());
    PlotEffigy schedulePlotterEffigy=new PlotEffigy(effigy,container.uniqueName(""String_Node_Str""));
    schedulePlotterEffigy.setPlot(plot);
    schedulePlotterEffigy.setModel(this.getContainer());
    schedulePlotterEffigy.identifier.setExpression(""String_Node_Str"");
    configuration.createPrimaryTableau(schedulePlotterEffigy);
    plot.setVisible(true);
  }
 catch (  Throwable throwable) {
    throw new InternalErrorException(object,throwable,""String_Node_Str"");
  }
}"
73281,"/** 
 * Create an editor for configuring the specified object with the specified parent window.
 * @param object The object to configure.
 * @param parent The parent window, or null if there is none.
 */
public void createEditor(NamedObj object,Frame parent){
  try {
    Configuration configuration=((TableauFrame)parent).getConfiguration();
    NamedObj container=object.getContainer();
    plot=new Plot();
    plot.setTitle(""String_Node_Str"");
    plot.setButtons(true);
    plot.setMarksStyle(""String_Node_Str"");
    Effigy effigy=Configuration.findEffigy(toplevel());
    PlotEffigy schedulePlotterEffigy=new PlotEffigy(effigy,container.uniqueName(""String_Node_Str""));
    schedulePlotterEffigy.setPlot(plot);
    schedulePlotterEffigy.identifier.setExpression(""String_Node_Str"");
    configuration.createPrimaryTableau(schedulePlotterEffigy);
    plot.setVisible(true);
  }
 catch (  Throwable throwable) {
    throw new InternalErrorException(object,throwable,""String_Node_Str"");
  }
}","/** 
 * Create an editor for configuring the specified object with the specified parent window.
 * @param object The object to configure.
 * @param parent The parent window, or null if there is none.
 */
public void createEditor(NamedObj object,Frame parent){
  try {
    Configuration configuration=((TableauFrame)parent).getConfiguration();
    NamedObj container=object.getContainer();
    plot=new Plot();
    plot.setTitle(""String_Node_Str"");
    plot.setButtons(true);
    plot.setMarksStyle(""String_Node_Str"");
    Effigy effigy=Configuration.findEffigy(toplevel());
    PlotEffigy schedulePlotterEffigy=new PlotEffigy(effigy,container.uniqueName(""String_Node_Str""));
    schedulePlotterEffigy.setPlot(plot);
    schedulePlotterEffigy.setModel(this.getContainer());
    schedulePlotterEffigy.identifier.setExpression(""String_Node_Str"");
    configuration.createPrimaryTableau(schedulePlotterEffigy);
    plot.setVisible(true);
  }
 catch (  Throwable throwable) {
    throw new InternalErrorException(object,throwable,""String_Node_Str"");
  }
}"
73282,"/** 
 * Generate fire code. The method generates code that loops through each input [multi-ports] and combines (add or subtract) them.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.MultiplyDivide actor=(ptolemy.actor.lib.MultiplyDivide)getComponent();
  String outputType=getCodeGenerator().codeGenType(actor.output.getType());
  String multiplyType=getCodeGenerator().codeGenType(actor.multiply.getType());
  String divideType=getCodeGenerator().codeGenType(actor.divide.getType());
  boolean divideOnly=!actor.multiply.isOutsideConnected();
  ArrayList<String> args=new ArrayList<String>();
  ArrayList<String> initArgs=new ArrayList<String>();
  if (divideOnly) {
    initArgs.add(divideType);
  }
 else {
    initArgs.add(multiplyType);
    initArgs.add(outputType);
  }
  CodeStream codeStream=getTemplateParser().getCodeStream();
  codeStream.appendCodeBlock(divideOnly ? ""String_Node_Str"" : ""String_Node_Str"",initArgs);
  args.add(""String_Node_Str"");
  args.add(outputType);
  args.add(multiplyType);
  for (int i=1; i < actor.multiply.getWidth(); i++) {
    args.set(0,Integer.toString(i));
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
  for (int i=divideOnly ? 1 : 0; i < actor.divide.getWidth(); i++) {
    args.set(0,Integer.toString(i));
    args.set(2,divideType);
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
  codeStream.appendCodeBlock(""String_Node_Str"");
  return processCode(codeStream.toString());
}","/** 
 * Generate fire code. The method generates code that loops through each input [multi-ports] and combines (add or subtract) them.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.MultiplyDivide actor=(ptolemy.actor.lib.MultiplyDivide)getComponent();
  String outputType=getCodeGenerator().codeGenType(actor.output.getType());
  String multiplyType=getCodeGenerator().codeGenType(actor.multiply.getType());
  String divideType=getCodeGenerator().codeGenType(actor.divide.getType());
  boolean divideOnly=!actor.multiply.isOutsideConnected();
  ArrayList<String> args=new ArrayList<String>();
  ArrayList<String> initArgs=new ArrayList<String>();
  CodeStream codeStream=getTemplateParser().getCodeStream();
  codeStream.appendCodeBlock(divideOnly ? ""String_Node_Str"" : ""String_Node_Str"",initArgs);
  args.add(""String_Node_Str"");
  args.add(outputType);
  args.add(multiplyType);
  for (int i=1; i < actor.multiply.getWidth(); i++) {
    args.set(0,Integer.toString(i));
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
  for (int i=divideOnly ? 1 : 0; i < actor.divide.getWidth(); i++) {
    args.set(0,Integer.toString(i));
    args.set(2,divideType);
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
  codeStream.appendCodeBlock(""String_Node_Str"");
  return processCode(codeStream.toString());
}"
73283,"/** 
 * Create a java.awt.FileDialog and get the user input.  If  {@link ptolemy.gui.PtGUIUtilities#useFileDialog()} returnstrue, then  {@link #actionPerformed(ActionEvent)} uses this method.Otherwise,  {@link #_actionPerformedJFileChooser(ActionEvent)} is used.<p>Under Mac OS X, this method is preferred over _actionPerformedJFileChooser().</p> <p>Under Bash, to test this method, use:</p> <pre> export JAVAFLAGS=-Dptolemy.ptII.useFileDialog=true $PTII/bin/vergil ~/ptII/ptolemy/actor/lib/io/test/auto/FileReader.xml </pre>
 */
private void _actionPerformedFileDialog(ActionEvent e){
  FileDialog fileDialog=new FileDialog(JOptionPane.getFrameForComponent(Query.this),""String_Node_Str"",FileDialog.LOAD);
  if (_startingDirectory != null) {
    fileDialog.setDirectory(_startingDirectory.toString());
  }
  String fileName=getSelectedFileName().trim();
  if (!fileName.equals(""String_Node_Str"")) {
    fileDialog.setFile(fileName);
  }
  if (_allowDirectories) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  fileDialog.show();
  if (fileDialog.getFile() == null) {
    return;
  }
  File file=null;
  if (_startingDirectory != null) {
    file=new File(_startingDirectory,fileDialog.getFile());
  }
 else {
    String currentWorkingDirectory=null;
    try {
      currentWorkingDirectory=System.getProperty(""String_Node_Str"");
    }
 catch (    Throwable throwable) {
    }
    if (currentWorkingDirectory != null) {
      file=new File(currentWorkingDirectory,fileDialog.getFile());
    }
 else {
      file=new File(fileDialog.getFile());
    }
  }
  if (file.exists() && fileDialog.getMode() == FileDialog.SAVE) {
    String queryString=file.getName() + ""String_Node_Str"";
    int selected=JOptionPane.showOptionDialog(null,queryString,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
    if (selected == 1) {
      return;
    }
  }
  if (_base == null) {
    try {
      _entryBox.setText(new File(fileDialog.getFile()).getCanonicalPath());
    }
 catch (    IOException ex) {
      _entryBox.setText(fileDialog.getFile());
    }
  }
 else {
    File selectedFile=new File(fileDialog.getDirectory(),fileDialog.getFile());
    try {
      selectedFile=selectedFile.getCanonicalFile();
    }
 catch (    IOException ex) {
    }
    URI relativeURI=_base.relativize(selectedFile.toURI());
    if (relativeURI != null && relativeURI.getScheme() != null && relativeURI.getScheme().equals(""String_Node_Str"")) {
      String pathName=relativeURI.getPath();
      file=new File(pathName.replace(""String_Node_Str"",""String_Node_Str""));
      try {
        _entryBox.setText(file.getCanonicalPath().replace('\\','/'));
      }
 catch (      IOException ex) {
        _entryBox.setText(file.toString());
      }
    }
 else {
      _entryBox.setText(relativeURI.toString());
    }
  }
  _owner._notifyListeners(_name);
}","/** 
 * Create a java.awt.FileDialog and get the user input.  If  {@link ptolemy.gui.PtGUIUtilities#useFileDialog()} returnstrue, then  {@link #actionPerformed(ActionEvent)} uses this method.Otherwise,  {@link #_actionPerformedJFileChooser(ActionEvent)} is used.<p>Under Mac OS X, this method is preferred over _actionPerformedJFileChooser().</p> <p>Under Bash, to test this method, use:</p> <pre> export JAVAFLAGS=-Dptolemy.ptII.useFileDialog=true $PTII/bin/vergil ~/ptII/ptolemy/actor/lib/io/test/auto/FileReader.xml </pre>
 */
private void _actionPerformedFileDialog(ActionEvent e){
  FileDialog fileDialog=new FileDialog(JOptionPane.getFrameForComponent(Query.this),""String_Node_Str"",FileDialog.LOAD);
  if (_startingDirectory != null) {
    fileDialog.setDirectory(_startingDirectory.toString());
  }
  String fileName=getSelectedFileName().trim();
  if (!fileName.equals(""String_Node_Str"")) {
    fileDialog.setFile(fileName);
  }
  if (_allowDirectories) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  fileDialog.show();
  if (fileDialog.getFile() == null) {
    return;
  }
  File file=null;
  _startingDirectory=new File(fileDialog.getDirectory());
  if (_startingDirectory != null) {
    file=new File(_startingDirectory,fileDialog.getFile());
  }
 else {
    String currentWorkingDirectory=null;
    try {
      currentWorkingDirectory=System.getProperty(""String_Node_Str"");
    }
 catch (    Throwable throwable) {
    }
    if (currentWorkingDirectory != null) {
      file=new File(currentWorkingDirectory,fileDialog.getFile());
    }
 else {
      file=new File(fileDialog.getFile());
    }
  }
  if (file.exists() && fileDialog.getMode() == FileDialog.SAVE) {
    String queryString=file.getName() + ""String_Node_Str"";
    int selected=JOptionPane.showOptionDialog(null,queryString,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
    if (selected == 1) {
      return;
    }
  }
  if (_base == null) {
    try {
      _entryBox.setText(new File(fileDialog.getDirectory(),fileDialog.getFile()).getCanonicalPath());
    }
 catch (    IOException ex) {
      _entryBox.setText(fileDialog.getFile());
    }
  }
 else {
    File selectedFile=new File(fileDialog.getDirectory(),fileDialog.getFile());
    try {
      selectedFile=selectedFile.getCanonicalFile();
    }
 catch (    IOException ex) {
    }
    URI relativeURI=_base.relativize(selectedFile.toURI());
    if (relativeURI != null && relativeURI.getScheme() != null && relativeURI.getScheme().equals(""String_Node_Str"")) {
      String pathName=relativeURI.getPath();
      file=new File(pathName.replace(""String_Node_Str"",""String_Node_Str""));
      try {
        _entryBox.setText(file.getCanonicalPath().replace('\\','/'));
      }
 catch (      IOException ex) {
        _entryBox.setText(file.toString());
      }
    }
 else {
      _entryBox.setText(relativeURI.toString());
    }
  }
  _owner._notifyListeners(_name);
}"
73284,"/** 
 * This method, which is required by the ImageObserver interface, is called if something has changed in a background loading of the image.
 * @param image The image being observed.
 * @param infoflags The bitwise inclusive OR of the following flags:WIDTH, HEIGHT, PROPERTIES, SOMEBITS, FRAMEBITS, ALLBITS, ERROR, ABORT.
 * @param x The x coordinate of the image.
 * @param y The y coordinate of the image.
 * @param width The width of the image.
 * @param height The height of the image.
 * @return False if the infoflags indicate that the image iscompletely loaded; true otherwise.
 */
public boolean imageUpdate(Image image,int infoflags,int x,int y,int width,int height){
  if ((infoflags & (ImageObserver.HEIGHT | ImageObserver.WIDTH)) != 0) {
    _height=height;
    _width=width;
    _image.getWidth(this);
    _image.getHeight(this);
    return true;
  }
  if ((infoflags & ImageObserver.ALLBITS) != 0) {
    scaleImage(_scalePercentage);
    Runnable doRepaint=new Runnable(){
      public void run(){
        Iterator figures=_liveFigureIterator();
        while (figures.hasNext()) {
          Object figure=figures.next();
          ((ImageFigure)figure).repaint();
        }
      }
    }
;
    SwingUtilities.invokeLater(doRepaint);
    return false;
  }
  if ((infoflags & (ImageObserver.ERROR | ImageObserver.ABORT)) != 0) {
    return false;
  }
  _image.getWidth(this);
  _image.getHeight(this);
  return true;
}","/** 
 * This method, which is required by the ImageObserver interface, is called if something has changed in a background loading of the image.
 * @param image The image being observed.
 * @param infoflags The bitwise inclusive OR of the following flags:WIDTH, HEIGHT, PROPERTIES, SOMEBITS, FRAMEBITS, ALLBITS, ERROR, ABORT.
 * @param x The x coordinate of the image.
 * @param y The y coordinate of the image.
 * @param width The width of the image.
 * @param height The height of the image.
 * @return False if the infoflags indicate that the image iscompletely loaded; true otherwise.
 */
public synchronized boolean imageUpdate(Image image,int infoflags,int x,int y,int width,int height){
  if ((infoflags & ImageObserver.ALLBITS) != 0) {
    if (_scalePercentage != 0.0 && _scalePercentage != _scalePercentageImplemented) {
      scaleImage(_scalePercentage);
      return true;
    }
    _updateFigures();
    return false;
  }
  if ((infoflags & (ImageObserver.ERROR | ImageObserver.ABORT)) != 0) {
    URL url=getClass().getResource(""String_Node_Str"");
    Toolkit tk=Toolkit.getDefaultToolkit();
    Image errorImage=tk.getImage(url);
synchronized (this) {
      _image=errorImage;
      _scaledImage=errorImage;
    }
    if (tk.prepareImage(_image,-1,-1,this)) {
      _updateFigures();
    }
    return true;
  }
  return true;
}"
73285,"/** 
 * Create a new default background figure, which is the shape set by setShape, if it has been called, or a small box if not. This must be called in the Swing thread, or a concurrent modification exception could occur.
 * @return A figure representing the specified shape.
 */
public Figure createBackgroundFigure(){
  if (_scaledImage == null) {
    try {
      URL url=FileUtilities.nameToURL(""String_Node_Str"",null,getClass().getClassLoader());
      Toolkit tk=Toolkit.getDefaultToolkit();
      setImage(tk.getImage(url));
    }
 catch (    IOException ex) {
    }
  }
  Figure newFigure=new ImageFigure(_scaledImage);
  _addLiveFigure(newFigure);
  return newFigure;
}","/** 
 * Create a new default background figure, which is scaled image, if it has been set, or a default image if not. This must be called in the Swing thread, or a concurrent modification exception could occur.
 * @return A figure representing the specified shape.
 */
public Figure createBackgroundFigure(){
  Toolkit tk=Toolkit.getDefaultToolkit();
  if (_scaledImage == null) {
    try {
      URL url=FileUtilities.nameToURL(""String_Node_Str"",null,getClass().getClassLoader());
      _scaledImage=_image=tk.getImage(url);
      setImage(_scaledImage);
      tk.prepareImage(_scaledImage,-1,-1,this);
    }
 catch (    IOException ex) {
    }
  }
  ImageFigure newFigure=null;
  if (_scalePercentage == _scalePercentageImplemented && (tk.checkImage(_scaledImage,43,33,this) & ImageObserver.ALLBITS) != 0) {
    newFigure=new ImageFigure(_scaledImage);
  }
 else {
    newFigure=new ImageFigure(null);
  }
  newFigure.setCentered(false);
  _addLiveFigure(newFigure);
  return newFigure;
}"
73286,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ImageIcon newObject=(ImageIcon)super.clone(workspace);
  newObject._image=null;
  newObject._scaledImage=null;
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ImageIcon newObject=(ImageIcon)super.clone(workspace);
  newObject._image=null;
  newObject._scaledImage=null;
  newObject._scalePercentage=0.0;
  newObject._scalePercentageImplemented=-1.0;
  return newObject;
}"
73287,"/** 
 * Specify a scaling for the image as a percentage.
 * @param percentage The scaling percentage.
 */
public void scaleImage(double percentage){
  if (percentage == _scalePercentage) {
    return;
  }
  _scalePercentage=percentage;
  Runnable doScale=new Runnable(){
    public void run(){
      if (_image == null) {
        return;
      }
      int width=_image.getWidth(ImageIcon.this);
      int height=_image.getHeight(ImageIcon.this);
      if ((width < 0) || (height < 0)) {
        width=_width;
        height=_height;
      }
      if ((width > 0) && (height > 0)) {
        int newWidth=(int)Math.round((width * _scalePercentage) / 100.0);
        int newHeight=(int)Math.round((height * _scalePercentage) / 100.0);
        _scaledImage=_image.getScaledInstance(newWidth,newHeight,Image.SCALE_SMOOTH);
        _scaledImage.getWidth(ImageIcon.this);
        _scaledImage.getHeight(ImageIcon.this);
        Iterator figures=_liveFigureIterator();
        while (figures.hasNext()) {
          Object figure=figures.next();
          ((ImageFigure)figure).setCentered(false);
          ((ImageFigure)figure).setImage(_scaledImage);
        }
      }
    }
  }
;
  SwingUtilities.invokeLater(doScale);
}","/** 
 * Specify a scaling for the image as a percentage.
 * @param percentage The scaling percentage.
 */
public synchronized void scaleImage(double percentage){
  _scalePercentage=percentage;
  _scalePercentageImplemented=-1.0;
  if (_image == null) {
    return;
  }
  Runnable doScale=new Runnable(){
    public void run(){
synchronized (ImageIcon.this) {
        Toolkit tk=Toolkit.getDefaultToolkit();
        int width=_image.getWidth(ImageIcon.this);
        int height=_image.getHeight(ImageIcon.this);
        if (width < 0 || height < 0) {
          return;
        }
        int newWidth=(int)Math.round((width * _scalePercentage) / 100.0);
        int newHeight=(int)Math.round((height * _scalePercentage) / 100.0);
        _scaledImage=_image.getScaledInstance(newWidth,newHeight,Image.SCALE_SMOOTH);
        _scalePercentageImplemented=_scalePercentage;
        if (tk.prepareImage(_scaledImage,width,height,ImageIcon.this)) {
          _updateFigures();
        }
      }
    }
  }
;
  SwingUtilities.invokeLater(doScale);
}"
73288,"public void run(){
  Iterator figures=_liveFigureIterator();
  while (figures.hasNext()) {
    Object figure=figures.next();
    ((ImageFigure)figure).setImage(_scaledImage);
    if (_scalePercentage != 100.0) {
      scaleImage(_scalePercentage);
    }
  }
}","public void run(){
synchronized (ImageIcon.this) {
    Toolkit tk=Toolkit.getDefaultToolkit();
    int width=_image.getWidth(ImageIcon.this);
    int height=_image.getHeight(ImageIcon.this);
    if (width < 0 || height < 0) {
      return;
    }
    int newWidth=(int)Math.round((width * _scalePercentage) / 100.0);
    int newHeight=(int)Math.round((height * _scalePercentage) / 100.0);
    _scaledImage=_image.getScaledInstance(newWidth,newHeight,Image.SCALE_SMOOTH);
    _scalePercentageImplemented=_scalePercentage;
    if (tk.prepareImage(_scaledImage,width,height,ImageIcon.this)) {
      _updateFigures();
    }
  }
}"
73289,"/** 
 * Specify an image to display.  This is deferred and executed in the Swing thread.
 * @param image The image to display.
 */
public void setImage(Image image){
  _image=image;
  _scaledImage=image;
  _image.getWidth(this);
  _image.getHeight(this);
  Runnable doSet=new Runnable(){
    public void run(){
      Iterator figures=_liveFigureIterator();
      while (figures.hasNext()) {
        Object figure=figures.next();
        ((ImageFigure)figure).setImage(_scaledImage);
        if (_scalePercentage != 100.0) {
          scaleImage(_scalePercentage);
        }
      }
    }
  }
;
  SwingUtilities.invokeLater(doSet);
}","/** 
 * Specify an image to display. Note that this does not actually result in the image displaying. You must call scaleImage().
 * @param image The image to display.
 */
public synchronized void setImage(Image image){
  _image=image;
  _scaledImage=image;
  if (_scalePercentage != _scalePercentageImplemented) {
    scaleImage(_scalePercentage);
    return;
  }
}"
73290,"/** 
 * Send the token back via the model's publisher.
 * @see java.lang.Runnable#run()
 */
public void run(){
  try {
    _remoteModel.getTokenPublisher().sendToken(_token);
  }
 catch (  IllegalActionException e) {
  }
}","/** 
 * Send the token back via the model's publisher.
 * @see java.lang.Runnable#run()
 */
@Override public void run(){
  try {
    _remoteModel.getTokenPublisher().sendToken(_token);
  }
 catch (  IllegalActionException e) {
  }
}"
73291,"/** 
 * Parent constructor that replaces either targetEntity if replaceTargetEntity is true or otherwise all entities connected to it with a proxy instance (RemoteSink or RemoteSource).  The proxy actor is named the same as the original with addition of ""_remote"" suffix.  All links of the targetEntity are removed. The proxy actor dynamically adds ports that were present in the targetEntity (with the same port name) or and connects them to the targetEntity's relations.
 * @param container The container
 * @param targetEntity the targetEntity to be replaced by a proxy
 * @param replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
public RemoteActor(CompositeEntity container,ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,String> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  this(container,targetEntity.getName() + ""String_Node_Str"");
  setTargetEntityName(targetEntity.getFullName());
  _targetEntityName.setExpression(getTargetEntityName());
  if (replaceTargetEntity) {
    _replaceTargetEntity(targetEntity,portTypes);
  }
 else {
    _replaceConnectingEntities(targetEntity,portTypes);
  }
}","/** 
 * Parent constructor that replaces either targetEntity if replaceTargetEntity is true or otherwise all entities connected to it with a proxy instance (RemoteSink or RemoteSource).  The proxy actor is named the same as the original with addition of ""_remote"" suffix.  All links of the targetEntity are removed. The proxy actor dynamically adds ports that were present in the targetEntity (with the same port name) or and connects them to the targetEntity's relations.
 * @param container The container
 * @param targetEntity the targetEntity to be replaced by a proxy
 * @param replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
public RemoteActor(CompositeEntity container,ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,Type> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  this(container,targetEntity.getName() + ""String_Node_Str"");
  setTargetEntityName(targetEntity.getFullName());
  _targetEntityName.setExpression(getTargetEntityName());
  if (replaceTargetEntity) {
    _replaceTargetEntity(targetEntity,portTypes);
  }
 else {
    _replaceConnectingEntities(targetEntity,portTypes);
  }
}"
73292,"/** 
 * Replace all entities connected to the targetEntity with one RemoteSource or RemoteSink.  Essentially instead of all entities connected to it, RemoteSink or RemoteSource would be used that would redirect all links from those entities to itself and connect them to dynamically added ports derived from the connected entities. This configuration would allow running of sources and sinks disconnected from the actors in between remotely by passing respective input and output via CommunicationToken.
 * @param targetEntity the entity to which actors that arereplaced are connected
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
private void _replaceConnectingEntities(ComponentEntity targetEntity,HashMap<String,String> portTypes) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      List<Port> linkedPortList=relation.linkedPortList(port);
      IOPort remotePort=null;
      for (      Port connectingPort : linkedPortList) {
        if (connectingPort instanceof IOPort && _isValidConnectingPort((IOPort)connectingPort)) {
          remotePort=(IOPort)port.clone(port.workspace());
          remotePort.setInput(!port.isInput());
          remotePort.setOutput(!port.isOutput());
          remotePort.setPersistent(true);
          remotePort.setContainer(this);
          remotePort.setMultiport(false);
          if (remotePort instanceof TypedIOPort) {
            Type type=BaseType.forName(portTypes.get(port.getFullName()));
            ((TypedIOPort)remotePort).setTypeEquals(type);
            StringAttribute targetPortName=new StringAttribute(remotePort,""String_Node_Str"");
            targetPortName.setExpression(port.getFullName());
          }
          break;
        }
      }
      relation.unlinkAll();
      if (remotePort != null) {
        port.link(relation);
        remotePort.link(relation);
      }
    }
  }
}","/** 
 * Replace all entities connected to the targetEntity with one RemoteSource or RemoteSink.  Essentially instead of all entities connected to it, RemoteSink or RemoteSource would be used that would redirect all links from those entities to itself and connect them to dynamically added ports derived from the connected entities. This configuration would allow running of sources and sinks disconnected from the actors in between remotely by passing respective input and output via CommunicationToken.
 * @param targetEntity the entity to which actors that arereplaced are connected
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
private void _replaceConnectingEntities(ComponentEntity targetEntity,HashMap<String,Type> portTypes) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      List<Port> linkedPortList=relation.linkedPortList(port);
      IOPort remotePort=null;
      for (      Port connectingPort : linkedPortList) {
        if (connectingPort instanceof IOPort && _isValidConnectingPort((IOPort)connectingPort)) {
          remotePort=(IOPort)port.clone(port.workspace());
          remotePort.setInput(!port.isInput());
          remotePort.setOutput(!port.isOutput());
          remotePort.setPersistent(true);
          remotePort.setContainer(this);
          remotePort.setMultiport(false);
          if (remotePort instanceof TypedIOPort) {
            Type type=portTypes.get(port.getFullName());
            ((TypedIOPort)remotePort).setTypeEquals(type);
            StringAttribute targetPortName=new StringAttribute(remotePort,""String_Node_Str"");
            targetPortName.setExpression(port.getFullName());
          }
          break;
        }
      }
      relation.unlinkAll();
      if (remotePort != null) {
        port.link(relation);
        remotePort.link(relation);
      }
    }
  }
}"
73293,"/** 
 * Replace the targetEntity with the proxy.  This configuration would allow execution of the model where sinks or sources run remotely and proxies execute instead of them and pass information to/from them.
 * @param targetEntity The target entity that is replaced with the proxy
 * @param portTypes The map of ports and their resolved types
 * @exception CloneNotSupportedException
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
private void _replaceTargetEntity(ComponentEntity targetEntity,HashMap<String,String> portTypes) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  ArrayList<Attribute> attributes=new ArrayList<Attribute>(targetEntity.attributeList());
  for (  Attribute attribute : attributes) {
    attribute.setContainer(this);
  }
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    IOPort remotePort=(IOPort)port.clone(port.workspace());
    remotePort.setName(port.getName());
    remotePort.setContainer(this);
    remotePort.setPersistent(true);
    if (remotePort instanceof TypedIOPort) {
      Type type=BaseType.forName(portTypes.get(port.getFullName()));
      ((TypedIOPort)remotePort).setTypeEquals(type);
      StringAttribute targetPortName=new StringAttribute(remotePort,""String_Node_Str"");
      targetPortName.setExpression(port.getFullName());
    }
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      port.unlink(relation);
      remotePort.link(relation);
    }
    port.unlinkAll();
  }
  targetEntity.setContainer(null);
}","/** 
 * Replace the targetEntity with the proxy.  This configuration would allow execution of the model where sinks or sources run remotely and proxies execute instead of them and pass information to/from them.
 * @param targetEntity The target entity that is replaced with the proxy
 * @param portTypes The map of ports and their resolved types
 * @exception CloneNotSupportedException
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
private void _replaceTargetEntity(ComponentEntity targetEntity,HashMap<String,Type> portTypes) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  ArrayList<Attribute> attributes=new ArrayList<Attribute>(targetEntity.attributeList());
  for (  Attribute attribute : attributes) {
    attribute.setContainer(this);
  }
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    IOPort remotePort=(IOPort)port.clone(port.workspace());
    remotePort.setName(port.getName());
    remotePort.setContainer(this);
    remotePort.setPersistent(true);
    if (remotePort instanceof TypedIOPort) {
      Type type=portTypes.get(port.getFullName());
      ((TypedIOPort)remotePort).setTypeEquals(type);
      StringAttribute targetPortName=new StringAttribute(remotePort,""String_Node_Str"");
      targetPortName.setExpression(port.getFullName());
    }
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      port.unlink(relation);
      remotePort.link(relation);
    }
    port.unlinkAll();
  }
  targetEntity.setContainer(null);
}"
73294,"/** 
 * Replace the targetSink with the RemoteSink instance.
 * @param container The container
 * @param targetSink The target sink
 * @param replaceTargetEntity replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see RemoteActor
 */
public RemoteSink(CompositeEntity container,ComponentEntity targetSink,boolean replaceTargetEntity,HashMap<String,String> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  super(container,targetSink,replaceTargetEntity,portTypes);
}","/** 
 * Replace the targetSink with the RemoteSink instance.
 * @param container The container
 * @param targetSink The target sink
 * @param replaceTargetEntity replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see RemoteActor
 */
public RemoteSink(CompositeEntity container,ComponentEntity targetSink,boolean replaceTargetEntity,HashMap<String,Type> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  super(container,targetSink,replaceTargetEntity,portTypes);
}"
73295,"/** 
 * Replace the targetSource with the RemoteSource instance.
 * @param container The container
 * @param targetSource The target source
 * @param replaceTargetEntity replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see RemoteActor
 */
public RemoteSource(CompositeEntity container,ComponentEntity targetSource,boolean replaceTargetEntity,HashMap<String,String> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  super(container,targetSource,replaceTargetEntity,portTypes);
}","/** 
 * Replace the targetSource with the RemoteSource instance.
 * @param container The container
 * @param targetSource The target source
 * @param replaceTargetEntity replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see RemoteActor
 */
public RemoteSource(CompositeEntity container,ComponentEntity targetSource,boolean replaceTargetEntity,HashMap<String,Type> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  super(container,targetSource,replaceTargetEntity,portTypes);
}"
73296,"/** 
 * Load the model from the specified URL.
 * @param modelURL the model URL to be loaded
 * @exception Exception If there is a problem parsing the model,connecting to the mqtt broker or replacing actors.
 */
public void loadModel(URL modelURL) throws Exception {
  MoMLParser parser=_createMoMLParser();
  HashSet<ComponentEntity> unneededActors=new HashSet<ComponentEntity>();
  HashSet<ComponentEntity> sinks=new HashSet<ComponentEntity>();
  HashSet<ComponentEntity> sources=new HashSet<ComponentEntity>();
  setResolvedTypes(new HashMap<String,String>());
  _topLevelActor=(CompositeActor)parser.parse(null,modelURL);
  for (  Object obj : getTopLevelActor().deepEntityList()) {
    ComponentEntity actor=(ComponentEntity)obj;
    Attribute remoteAttribute=actor.getAttribute(""String_Node_Str"");
    boolean isSinkOrSource=false;
    if (remoteAttribute instanceof Parameter) {
      Parameter parameter=(Parameter)remoteAttribute;
      if (parameter.getExpression().equals(""String_Node_Str"")) {
        sources.add(actor);
        isSinkOrSource=true;
      }
 else       if (parameter.getExpression().equals(""String_Node_Str"")) {
        sinks.add(actor);
        isSinkOrSource=true;
      }
    }
    if (!isSinkOrSource && _modelType == RemoteModelType.CLIENT) {
      unneededActors.add(actor);
    }
    _initRemoteAttributes(actor);
  }
  _initRemoteAttributes(_topLevelActor);
  if (_topLevelActor instanceof TypedCompositeActor) {
    TypedCompositeActor typedActor=(TypedCompositeActor)_topLevelActor;
    TypedCompositeActor.resolveTypes(typedActor);
  }
  _captureModelTypes(sources,getResolvedTypes());
  _captureModelTypes(sinks,getResolvedTypes());
switch (_modelType) {
case SERVER:
    for (    ComponentEntity entity : sources) {
      _createSource(entity,true,getResolvedTypes());
    }
  for (  ComponentEntity entity : sinks) {
    _createSink(entity,true,getResolvedTypes());
  }
break;
case CLIENT:
for (ComponentEntity entity : sources) {
_createSink(entity,false,getResolvedTypes());
}
for (ComponentEntity entity : sinks) {
_createSource(entity,false,getResolvedTypes());
}
HashMap<NamedObj,StringAttribute> containerToDummyAttributeMap=new HashMap<NamedObj,StringAttribute>();
for (Settable settable : _settableAttributesMap.values()) {
Attribute attribute=(Attribute)settable;
NamedObj container=attribute.getContainer();
Attribute lastAttribute=attribute;
while (container != _topLevelActor) {
StringAttribute dummyAttribute=containerToDummyAttributeMap.get(container);
if (dummyAttribute == null) {
dummyAttribute=new StringAttribute(container.getContainer(),container.getContainer().uniqueName(""String_Node_Str""));
dummyAttribute.setPersistent(true);
containerToDummyAttributeMap.put(container,dummyAttribute);
}
container=container.getContainer();
lastAttribute.setContainer(dummyAttribute);
lastAttribute=dummyAttribute;
}
}
for (ComponentEntity componentEntity : unneededActors) {
componentEntity.setContainer(null);
}
for (Entry<NamedObj,StringAttribute> entry : containerToDummyAttributeMap.entrySet()) {
entry.getValue().setName(entry.getKey().getName());
}
break;
}
}","/** 
 * Load the model from the specified URL.
 * @param modelURL the model URL to be loaded
 * @exception Exception If there is a problem parsing the model,connecting to the mqtt broker or replacing actors.
 */
public void loadModel(URL modelURL) throws Exception {
  MoMLParser parser=_createMoMLParser();
  HashSet<ComponentEntity> unneededActors=new HashSet<ComponentEntity>();
  HashSet<ComponentEntity> sinks=new HashSet<ComponentEntity>();
  HashSet<ComponentEntity> sources=new HashSet<ComponentEntity>();
  _resolvedTypes=new HashMap<String,Type>();
  _topLevelActor=(CompositeActor)parser.parse(null,modelURL);
  for (  Object obj : getTopLevelActor().deepEntityList()) {
    ComponentEntity actor=(ComponentEntity)obj;
    Attribute remoteAttribute=actor.getAttribute(""String_Node_Str"");
    boolean isSinkOrSource=false;
    if (remoteAttribute instanceof Parameter) {
      Parameter parameter=(Parameter)remoteAttribute;
      if (parameter.getExpression().equals(""String_Node_Str"")) {
        sources.add(actor);
        isSinkOrSource=true;
      }
 else       if (parameter.getExpression().equals(""String_Node_Str"")) {
        sinks.add(actor);
        isSinkOrSource=true;
      }
    }
    if (!isSinkOrSource && _modelType == RemoteModelType.CLIENT) {
      unneededActors.add(actor);
    }
    _initRemoteAttributes(actor);
  }
  _initRemoteAttributes(_topLevelActor);
  if (_topLevelActor instanceof TypedCompositeActor) {
    TypedCompositeActor typedActor=(TypedCompositeActor)_topLevelActor;
    TypedCompositeActor.resolveTypes(typedActor);
  }
  _captureModelTypes(sources,getResolvedTypes());
  _captureModelTypes(sinks,getResolvedTypes());
switch (_modelType) {
case SERVER:
    for (    ComponentEntity entity : sources) {
      _createSource(entity,true,getResolvedTypes());
    }
  for (  ComponentEntity entity : sinks) {
    _createSink(entity,true,getResolvedTypes());
  }
break;
case CLIENT:
for (ComponentEntity entity : sources) {
_createSink(entity,false,getResolvedTypes());
}
for (ComponentEntity entity : sinks) {
_createSource(entity,false,getResolvedTypes());
}
HashMap<NamedObj,StringAttribute> containerToDummyAttributeMap=new HashMap<NamedObj,StringAttribute>();
for (Settable settable : _settableAttributesMap.values()) {
Attribute attribute=(Attribute)settable;
NamedObj container=attribute.getContainer();
Attribute lastAttribute=attribute;
while (container != _topLevelActor) {
StringAttribute dummyAttribute=containerToDummyAttributeMap.get(container);
if (dummyAttribute == null) {
dummyAttribute=new StringAttribute(container.getContainer(),container.getContainer().uniqueName(""String_Node_Str""));
dummyAttribute.setPersistent(true);
containerToDummyAttributeMap.put(container,dummyAttribute);
}
container=container.getContainer();
lastAttribute.setContainer(dummyAttribute);
lastAttribute=dummyAttribute;
}
}
for (ComponentEntity componentEntity : unneededActors) {
componentEntity.setContainer(null);
}
for (Entry<NamedObj,StringAttribute> entry : containerToDummyAttributeMap.entrySet()) {
entry.getValue().setName(entry.getKey().getName());
}
break;
}
}"
73297,"/** 
 * Create a new instance of the RemoteSink either by replacing the targetEntity or by replacing all entities connected to it.
 * @param targetEntity The target entity to be processed
 * @param replaceTargetEntity replaceTargetEntity true to replacethe target entity with the proxy, otherwise replace all entities connecting to it with one proxy
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see ptserver.actor.RemoteSink
 */
private void _createSink(ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,String> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  RemoteSink remoteSink=new RemoteSink((CompositeEntity)targetEntity.getContainer(),targetEntity,replaceTargetEntity,portTypes);
  remoteSink.setTokenPublisher(_tokenPublisher);
  _remoteSinkMap.put(remoteSink.getTargetEntityName(),remoteSink);
}","/** 
 * Create a new instance of the RemoteSink either by replacing the targetEntity or by replacing all entities connected to it.
 * @param targetEntity The target entity to be processed
 * @param replaceTargetEntity replaceTargetEntity true to replacethe target entity with the proxy, otherwise replace all entities connecting to it with one proxy
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see ptserver.actor.RemoteSink
 */
private void _createSink(ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,Type> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  RemoteSink remoteSink=new RemoteSink((CompositeEntity)targetEntity.getContainer(),targetEntity,replaceTargetEntity,portTypes);
  remoteSink.setTokenPublisher(_tokenPublisher);
  _remoteSinkMap.put(remoteSink.getTargetEntityName(),remoteSink);
}"
73298,"/** 
 * Capture inferred types of the entities.
 * @param entities The entities whose inferred types are captured
 * @param portTypes The mapping that stores the types
 * @exception IllegalActionException If there is a probleminferring type of Typeable.
 */
private void _captureModelTypes(HashSet<ComponentEntity> entities,HashMap<String,String> portTypes) throws IllegalActionException {
  for (  ComponentEntity entity : entities) {
    for (    Object portObject : entity.portList()) {
      Port port=(Port)portObject;
      if (port instanceof IOPort) {
        if (port instanceof TypedIOPort) {
          portTypes.put(port.getFullName(),((TypedIOPort)port).getType().toString());
        }
        IOPort ioPort=(IOPort)port;
        for (        Object relationObject : ioPort.linkedRelationList()) {
          Relation relation=(Relation)relationObject;
          List<Port> portList=relation.linkedPortList(port);
          for (          Port connectingPort : portList) {
            if (connectingPort instanceof TypedIOPort) {
              portTypes.put(connectingPort.getFullName(),((TypedIOPort)connectingPort).getType().toString());
            }
          }
        }
      }
    }
    for (    Typeable attribute : entity.attributeList(Typeable.class)) {
      portTypes.put(((Nameable)attribute).getFullName(),attribute.getType().toString());
    }
  }
}","/** 
 * Capture inferred types of the entities.
 * @param entities The entities whose inferred types are captured
 * @param portTypes The mapping that stores the types
 * @exception IllegalActionException If there is a probleminferring type of Typeable.
 */
private void _captureModelTypes(HashSet<ComponentEntity> entities,HashMap<String,Type> portTypes) throws IllegalActionException {
  for (  ComponentEntity entity : entities) {
    for (    Object portObject : entity.portList()) {
      Port port=(Port)portObject;
      if (port instanceof IOPort) {
        if (port instanceof TypedIOPort) {
          portTypes.put(port.getFullName(),((TypedIOPort)port).getType());
        }
        IOPort ioPort=(IOPort)port;
        for (        Object relationObject : ioPort.linkedRelationList()) {
          Relation relation=(Relation)relationObject;
          List<Port> portList=relation.linkedPortList(port);
          for (          Port connectingPort : portList) {
            if (connectingPort instanceof TypedIOPort) {
              portTypes.put(connectingPort.getFullName(),((TypedIOPort)connectingPort).getType());
            }
          }
        }
      }
    }
    for (    Typeable attribute : entity.attributeList(Typeable.class)) {
      portTypes.put(((Nameable)attribute).getFullName(),attribute.getType());
    }
  }
}"
73299,"/** 
 * Initialize the model that already has RemoteSinks/Sources from the supplied xml string and set appropriate model types from the inferred model mapping. <p>This method is indented to be used on the Android to avoid loading unneeded actors.</p>
 * @param modelXML The modelXML file containing or
 * @param modelTypes The map of ports and their resolved types
 * @exception Exception If there is a problem parsing the modelXML.
 */
public void initModel(String modelXML,HashMap<String,String> modelTypes) throws Exception {
  MoMLParser parser=_createMoMLParser();
  _topLevelActor=(CompositeActor)parser.parse(modelXML);
  for (  Object obj : getTopLevelActor().deepEntityList()) {
    ComponentEntity actor=(ComponentEntity)obj;
    if (actor instanceof RemoteSink) {
      RemoteSink remoteSink=(RemoteSink)actor;
      remoteSink.setTokenPublisher(_tokenPublisher);
      _remoteSinkMap.put(remoteSink.getTargetEntityName(),remoteSink);
    }
 else     if (actor instanceof RemoteSource) {
      RemoteSource remoteSource=(RemoteSource)actor;
      RemoteSourceData remoteSourceData=new RemoteSourceData(remoteSource,this);
      remoteSource.setRemoteSourceData(remoteSourceData);
      getRemoteSourceMap().put(remoteSource.getTargetEntityName(),remoteSourceData);
    }
    Type type;
    for (    Object portObject : actor.portList()) {
      if (portObject instanceof TypedIOPort) {
        TypedIOPort port=(TypedIOPort)portObject;
        StringAttribute targetPortName=(StringAttribute)port.getAttribute(""String_Node_Str"");
        if (targetPortName != null) {
          type=BaseType.forName(modelTypes.get(targetPortName.getExpression()));
          if (type != null) {
            port.setTypeEquals(type);
          }
          port.typeConstraints().clear();
        }
 else         if ((type=BaseType.forName(modelTypes.get(port.getFullName()))) != null) {
          port.setTypeEquals(type);
          port.typeConstraints().clear();
        }
 else {
          throw new IllegalActionException(port,""String_Node_Str"");
        }
      }
    }
    for (    Typeable attribute : actor.attributeList(Typeable.class)) {
      if ((type=BaseType.forName(modelTypes.get(((Nameable)attribute).getFullName()))) != null) {
        attribute.setTypeEquals(type);
        attribute.typeConstraints().clear();
      }
    }
  }
  _initRemoteAttributes(_topLevelActor);
}","/** 
 * Initialize the model that already has RemoteSinks/Sources from the supplied xml string and set appropriate model types from the inferred model mapping. <p>This method is indented to be used on the Android to avoid loading unneeded actors.</p>
 * @param modelXML The modelXML file containing or
 * @param modelTypes The map of ports and their resolved types
 * @exception Exception If there is a problem parsing the modelXML.
 */
public void initModel(String modelXML,HashMap<String,Type> modelTypes) throws Exception {
  MoMLParser parser=_createMoMLParser();
  _topLevelActor=(CompositeActor)parser.parse(modelXML);
  for (  Entry<String,Type> entry : modelTypes.entrySet()) {
    if (entry.getValue() instanceof BaseType) {
      BaseType type=(BaseType)entry.getValue();
      Type staticTypeInstance=BaseType.forName(type.toString());
      entry.setValue(staticTypeInstance);
    }
  }
  for (  Object obj : getTopLevelActor().deepEntityList()) {
    ComponentEntity actor=(ComponentEntity)obj;
    if (actor instanceof RemoteSink) {
      RemoteSink remoteSink=(RemoteSink)actor;
      remoteSink.setTokenPublisher(_tokenPublisher);
      _remoteSinkMap.put(remoteSink.getTargetEntityName(),remoteSink);
    }
 else     if (actor instanceof RemoteSource) {
      RemoteSource remoteSource=(RemoteSource)actor;
      RemoteSourceData remoteSourceData=new RemoteSourceData(remoteSource,this);
      remoteSource.setRemoteSourceData(remoteSourceData);
      getRemoteSourceMap().put(remoteSource.getTargetEntityName(),remoteSourceData);
    }
    Type type;
    for (    Object portObject : actor.portList()) {
      if (portObject instanceof TypedIOPort) {
        TypedIOPort port=(TypedIOPort)portObject;
        StringAttribute targetPortName=(StringAttribute)port.getAttribute(""String_Node_Str"");
        if (targetPortName != null) {
          type=modelTypes.get(targetPortName.getExpression());
          if (type != null) {
            port.setTypeEquals(type);
          }
          port.typeConstraints().clear();
        }
 else         if ((type=modelTypes.get(port.getFullName())) != null) {
          port.setTypeEquals(type);
          port.typeConstraints().clear();
        }
 else {
          throw new IllegalActionException(port,""String_Node_Str"");
        }
      }
    }
    for (    Typeable attribute : actor.attributeList(Typeable.class)) {
      if ((type=modelTypes.get(((Nameable)attribute).getFullName())) != null) {
        attribute.setTypeEquals(type);
        attribute.typeConstraints().clear();
      }
    }
  }
  _initRemoteAttributes(_topLevelActor);
}"
73300,"/** 
 * Create a new instance of the RemoteSource either by replacing the targetEntity or by replacing all entities connected to it.
 * @param targetEntity The target entity to be processed
 * @param replaceTargetEntity replaceTargetEntity true to replacethe target entity with the proxy, otherwise replace all entities connecting to it with one proxy
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see ptserver.actor.RemoteSource
 */
private void _createSource(ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,String> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  RemoteSource remoteSource=new RemoteSource((CompositeEntity)targetEntity.getContainer(),targetEntity,replaceTargetEntity,portTypes);
  RemoteSourceData data=new RemoteSourceData(remoteSource,this);
  getRemoteSourceMap().put(remoteSource.getTargetEntityName(),data);
}","/** 
 * Create a new instance of the RemoteSource either by replacing the targetEntity or by replacing all entities connected to it.
 * @param targetEntity The target entity to be processed
 * @param replaceTargetEntity replaceTargetEntity true to replacethe target entity with the proxy, otherwise replace all entities connecting to it with one proxy
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see ptserver.actor.RemoteSource
 */
private void _createSource(ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,Type> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  RemoteSource remoteSource=new RemoteSource((CompositeEntity)targetEntity.getContainer(),targetEntity,replaceTargetEntity,portTypes);
  RemoteSourceData data=new RemoteSourceData(remoteSource,this);
  getRemoteSourceMap().put(remoteSource.getTargetEntityName(),data);
}"
73301,"/** 
 * Get the map from the Typeable's full name to its type.
 * @return The map from the Typeable's full name to its type.
 * @see #setResolvedTypes(HashMap)
 */
public HashMap<String,String> getResolvedTypes(){
  return _resolvedTypes;
}","/** 
 * Get the map from the Typeable's full name to its type.
 * @return The map from the Typeable's full name to its type.
 * @see #setResolvedTypes(HashMap)
 */
public HashMap<String,Type> getResolvedTypes(){
  return _resolvedTypes;
}"
73302,"/** 
 * Get the map from the model's Typeable objects to its inferred type. <p>This map contains only types for the sinks and sources intended to run on Android.</p>
 * @return the map from the Typeable to its inferred type.
 * @see #setModelTypes(HashMap)
 */
public HashMap<String,String> getModelTypes(){
  return _modelTypes;
}","/** 
 * Get the map from the model's Typeable objects to its inferred type. <p>This map contains only types for the sinks and sources intended to run on Android.</p>
 * @return the map from the Typeable to its inferred type.
 * @see #setModelTypes(HashMap)
 */
public HashMap<String,Type> getModelTypes(){
  return _modelTypes;
}"
73303,"/** 
 * Set the map from the model's Typeable objects to its inferred type.
 * @param modelTypes The map from the Typeable to its inferred type.
 * @see #getModelTypes()
 */
public void setModelTypes(HashMap<String,String> modelTypes){
  _modelTypes=modelTypes;
}","/** 
 * Set the map from the model's Typeable objects to its inferred type.
 * @param modelTypes The map from the Typeable to its inferred type.
 * @see #getModelTypes()
 */
public void setModelTypes(HashMap<String,Type> modelTypes){
  _modelTypes=modelTypes;
}"
73304,"/** 
 * Open a model with the provided model URL and wait for the user to request the execution of the simulation.
 * @param modelUrl The path to the model file
 * @param layoutUrl The path to a model's layout file
 * @exception IllegalActionException  If the model fails to load from the provided URL.
 * @return The user's reference to the simulation task
 */
public synchronized RemoteModelResponse open(String modelUrl,String layoutUrl) throws IllegalActionException {
  RemoteModelResponse response=null;
  Ticket ticket=null;
  try {
    ticket=Ticket.generateTicket(modelUrl,layoutUrl);
    while (_requests.contains(ticket)) {
      ticket=Ticket.generateTicket(modelUrl,layoutUrl);
    }
    RemoteModel clientModel=new RemoteModel(RemoteModelType.CLIENT);
    SimulationTask simulationTask=new SimulationTask(ticket);
    simulationTask.getRemoteModel().addRemoteModelListener(_remoteModelListener);
    String modelXML=new String(downloadModel(ticket.getLayoutUrl()));
    HashMap<String,String> resolvedTypes=simulationTask.getRemoteModel().getResolvedTypes();
    String brokerUrl=""String_Node_Str"" + InetAddress.getLocalHost().getHostAddress() + ""String_Node_Str""+ getBrokerPort();
    clientModel.initModel(modelXML,resolvedTypes);
    simulationTask.getRemoteModel().createRemoteAttributes(clientModel.getSettableAttributesMap().keySet());
    simulationTask.getRemoteModel().setUpInfrastructure(ticket,brokerUrl);
    response=new RemoteModelResponse();
    response.setTicket(ticket);
    response.setModelTypes(resolvedTypes);
    response.setModelXML(modelXML);
    response.setBrokerUrl(brokerUrl);
    _requests.put(ticket,simulationTask);
  }
 catch (  Exception e) {
    _handleException((ticket != null ? ticket.getTicketID() : null) + ""String_Node_Str"" + e.getMessage(),e);
  }
  return response;
}","/** 
 * Open a model with the provided model URL and wait for the user to request the execution of the simulation.
 * @param modelUrl The path to the model file
 * @param layoutUrl The path to a model's layout file
 * @exception IllegalActionException  If the model fails to load from the provided URL.
 * @return The user's reference to the simulation task
 */
public synchronized RemoteModelResponse open(String modelUrl,String layoutUrl) throws IllegalActionException {
  RemoteModelResponse response=null;
  Ticket ticket=null;
  try {
    ticket=Ticket.generateTicket(modelUrl,layoutUrl);
    while (_requests.contains(ticket)) {
      ticket=Ticket.generateTicket(modelUrl,layoutUrl);
    }
    RemoteModel clientModel=new RemoteModel(RemoteModelType.CLIENT);
    SimulationTask simulationTask=new SimulationTask(ticket);
    simulationTask.getRemoteModel().addRemoteModelListener(_remoteModelListener);
    String modelXML=new String(downloadModel(ticket.getLayoutUrl()));
    HashMap<String,Type> resolvedTypes=simulationTask.getRemoteModel().getResolvedTypes();
    String brokerUrl=""String_Node_Str"" + InetAddress.getLocalHost().getHostAddress() + ""String_Node_Str""+ getBrokerPort();
    clientModel.initModel(modelXML,resolvedTypes);
    simulationTask.getRemoteModel().createRemoteAttributes(clientModel.getSettableAttributesMap().keySet());
    simulationTask.getRemoteModel().setUpInfrastructure(ticket,brokerUrl);
    response=new RemoteModelResponse();
    response.setTicket(ticket);
    response.setModelTypes(resolvedTypes);
    response.setModelXML(modelXML);
    response.setBrokerUrl(brokerUrl);
    _requests.put(ticket,simulationTask);
  }
 catch (  Exception e) {
    _handleException((ticket != null ? ticket.getTicketID() : null) + ""String_Node_Str"" + e.getMessage(),e);
  }
  return response;
}"
73305,"/** 
 * Parent constructor that replaces either targetEntity if replaceTargetEntity is true or otherwise all entities connected to it with a proxy instance (RemoteSink or RemoteSource).  The proxy actor is named the same as the original with addition of ""_remote"" suffix.  All links of the targetEntity are removed. The proxy actor dynamically adds ports that were present in the targetEntity (with the same port name) or and connects them to the targetEntity's relations.
 * @param container The container
 * @param targetEntity the targetEntity to be replaced by a proxy
 * @param replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
public RemoteActor(CompositeEntity container,ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,Type> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  this(container,targetEntity.getName() + ""String_Node_Str"");
  setTargetEntityName(targetEntity.getFullName());
  _targetEntityName.setExpression(getTargetEntityName());
  if (replaceTargetEntity) {
    _replaceTargetEntity(targetEntity,portTypes);
  }
 else {
    _replaceConnectingEntities(targetEntity,portTypes);
  }
}","/** 
 * Parent constructor that replaces either targetEntity if replaceTargetEntity is true or otherwise all entities connected to it with a proxy instance (RemoteSink or RemoteSource).  The proxy actor is named the same as the original with addition of ""_remote"" suffix.  All links of the targetEntity are removed. The proxy actor dynamically adds ports that were present in the targetEntity (with the same port name) or and connects them to the targetEntity's relations.
 * @param container The container
 * @param targetEntity the targetEntity to be replaced by a proxy
 * @param replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
public RemoteActor(CompositeEntity container,ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,String> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  this(container,targetEntity.getName() + ""String_Node_Str"");
  setTargetEntityName(targetEntity.getFullName());
  _targetEntityName.setExpression(getTargetEntityName());
  if (replaceTargetEntity) {
    _replaceTargetEntity(targetEntity,portTypes);
  }
 else {
    _replaceConnectingEntities(targetEntity,portTypes);
  }
}"
73306,"/** 
 * Replace all entities connected to the targetEntity with one RemoteSource or RemoteSink.  Essentially instead of all entities connected to it, RemoteSink or RemoteSource would be used that would redirect all links from those entities to itself and connect them to dynamically added ports derived from the connected entities. This configuration would allow running of sources and sinks disconnected from the actors in between remotely by passing respective input and output via CommunicationToken.
 * @param targetEntity the entity to which actors that arereplaced are connected
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
private void _replaceConnectingEntities(ComponentEntity targetEntity,HashMap<String,Type> portTypes) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  for (  Object attributeObject : targetEntity.attributeList()) {
    Attribute attribute=(Attribute)attributeObject;
    Attribute clonedAttribute=(Attribute)attribute.clone(attribute.workspace());
    clonedAttribute.setContainer(this);
    clonedAttribute.setPersistent(true);
  }
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      List<Port> linkedPortList=relation.linkedPortList(port);
      IOPort remotePort=null;
      for (      Port connectingPort : linkedPortList) {
        if (connectingPort instanceof IOPort && _isValidConnectingPort((IOPort)connectingPort)) {
          remotePort=(IOPort)port.clone(port.workspace());
          remotePort.setInput(!port.isInput());
          remotePort.setOutput(!port.isOutput());
          remotePort.setPersistent(true);
          remotePort.setContainer(this);
          remotePort.setMultiport(false);
          if (remotePort instanceof TypedIOPort) {
            Type type=portTypes.get(port.getFullName());
            ((TypedIOPort)remotePort).setTypeEquals(type);
            StringAttribute targetPortName=new StringAttribute(remotePort,""String_Node_Str"");
            targetPortName.setExpression(port.getFullName());
          }
          break;
        }
      }
      relation.unlinkAll();
      if (remotePort != null) {
        port.link(relation);
        remotePort.link(relation);
      }
    }
  }
}","/** 
 * Replace all entities connected to the targetEntity with one RemoteSource or RemoteSink.  Essentially instead of all entities connected to it, RemoteSink or RemoteSource would be used that would redirect all links from those entities to itself and connect them to dynamically added ports derived from the connected entities. This configuration would allow running of sources and sinks disconnected from the actors in between remotely by passing respective input and output via CommunicationToken.
 * @param targetEntity the entity to which actors that arereplaced are connected
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
private void _replaceConnectingEntities(ComponentEntity targetEntity,HashMap<String,String> portTypes) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  for (  Object attributeObject : targetEntity.attributeList()) {
    Attribute attribute=(Attribute)attributeObject;
    Attribute clonedAttribute=(Attribute)attribute.clone(attribute.workspace());
    clonedAttribute.setContainer(this);
    clonedAttribute.setPersistent(true);
  }
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      List<Port> linkedPortList=relation.linkedPortList(port);
      IOPort remotePort=null;
      for (      Port connectingPort : linkedPortList) {
        if (connectingPort instanceof IOPort && _isValidConnectingPort((IOPort)connectingPort)) {
          remotePort=(IOPort)port.clone(port.workspace());
          remotePort.setInput(!port.isInput());
          remotePort.setOutput(!port.isOutput());
          remotePort.setPersistent(true);
          remotePort.setContainer(this);
          remotePort.setMultiport(false);
          if (remotePort instanceof TypedIOPort) {
            Type type=TypeParser.parse(portTypes.get(port.getFullName()));
            ((TypedIOPort)remotePort).setTypeEquals(type);
            StringAttribute targetPortName=new StringAttribute(remotePort,""String_Node_Str"");
            targetPortName.setExpression(port.getFullName());
          }
          break;
        }
      }
      relation.unlinkAll();
      if (remotePort != null) {
        port.link(relation);
        remotePort.link(relation);
      }
    }
  }
}"
73307,"/** 
 * Replace the targetEntity with the proxy.  This configuration would allow execution of the model where sinks or sources run remotely and proxies execute instead of them and pass information to/from them.
 * @param targetEntity The target entity that is replaced with the proxy
 * @param portTypes The map of ports and their resolved types
 * @exception CloneNotSupportedException
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
private void _replaceTargetEntity(ComponentEntity targetEntity,HashMap<String,Type> portTypes) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  ArrayList<Attribute> attributes=new ArrayList<Attribute>(targetEntity.attributeList());
  for (  Attribute attribute : attributes) {
    attribute.setContainer(this);
  }
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    IOPort remotePort=(IOPort)port.clone(port.workspace());
    remotePort.setName(port.getName());
    remotePort.setContainer(this);
    remotePort.setPersistent(true);
    if (remotePort instanceof TypedIOPort) {
      Type type=portTypes.get(port.getFullName());
      ((TypedIOPort)remotePort).setTypeEquals(type);
      StringAttribute targetPortName=new StringAttribute(remotePort,""String_Node_Str"");
      targetPortName.setExpression(port.getFullName());
    }
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      port.unlink(relation);
      remotePort.link(relation);
    }
    port.unlinkAll();
  }
  targetEntity.setContainer(null);
}","/** 
 * Replace the targetEntity with the proxy.  This configuration would allow execution of the model where sinks or sources run remotely and proxies execute instead of them and pass information to/from them.
 * @param targetEntity The target entity that is replaced with the proxy
 * @param portTypes The map of ports and their resolved types
 * @exception CloneNotSupportedException
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
private void _replaceTargetEntity(ComponentEntity targetEntity,HashMap<String,String> portTypes) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  ArrayList<Attribute> attributes=new ArrayList<Attribute>(targetEntity.attributeList());
  for (  Attribute attribute : attributes) {
    attribute.setContainer(this);
  }
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    IOPort remotePort=(IOPort)port.clone(port.workspace());
    remotePort.setName(port.getName());
    remotePort.setContainer(this);
    remotePort.setPersistent(true);
    if (remotePort instanceof TypedIOPort) {
      Type type=TypeParser.parse(portTypes.get(port.getFullName()));
      ((TypedIOPort)remotePort).setTypeEquals(type);
      StringAttribute targetPortName=new StringAttribute(remotePort,""String_Node_Str"");
      targetPortName.setExpression(port.getFullName());
    }
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      port.unlink(relation);
      remotePort.link(relation);
    }
    port.unlinkAll();
  }
  targetEntity.setContainer(null);
}"
73308,"/** 
 * Replace the targetSink with the RemoteSink instance.
 * @param container The container
 * @param targetSink The target sink
 * @param replaceTargetEntity replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see RemoteActor
 */
public RemoteSink(CompositeEntity container,ComponentEntity targetSink,boolean replaceTargetEntity,HashMap<String,Type> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  super(container,targetSink,replaceTargetEntity,portTypes);
}","/** 
 * Replace the targetSink with the RemoteSink instance.
 * @param container The container
 * @param targetSink The target sink
 * @param replaceTargetEntity replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see RemoteActor
 */
public RemoteSink(CompositeEntity container,ComponentEntity targetSink,boolean replaceTargetEntity,HashMap<String,String> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  super(container,targetSink,replaceTargetEntity,portTypes);
}"
73309,"/** 
 * Replace the targetSource with the RemoteSource instance.
 * @param container The container
 * @param targetSource The target source
 * @param replaceTargetEntity replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see RemoteActor
 */
public RemoteSource(CompositeEntity container,ComponentEntity targetSource,boolean replaceTargetEntity,HashMap<String,Type> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  super(container,targetSource,replaceTargetEntity,portTypes);
}","/** 
 * Replace the targetSource with the RemoteSource instance.
 * @param container The container
 * @param targetSource The target source
 * @param replaceTargetEntity replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see RemoteActor
 */
public RemoteSource(CompositeEntity container,ComponentEntity targetSource,boolean replaceTargetEntity,HashMap<String,String> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  super(container,targetSource,replaceTargetEntity,portTypes);
}"
73310,"/** 
 * Load the model from the specified URL.
 * @param modelURL the model URL to be loaded
 * @exception Exception If there is a problem parsing the model,connecting to the mqtt broker or replacing actors.
 */
public void loadModel(URL modelURL) throws Exception {
  MoMLParser parser=_createMoMLParser();
  HashSet<ComponentEntity> unneededActors=new HashSet<ComponentEntity>();
  HashSet<ComponentEntity> sinks=new HashSet<ComponentEntity>();
  HashSet<ComponentEntity> sources=new HashSet<ComponentEntity>();
  _resolvedTypes=new HashMap<String,Type>();
  _topLevelActor=(CompositeActor)parser.parse(null,modelURL);
  for (  Object obj : getTopLevelActor().deepEntityList()) {
    ComponentEntity actor=(ComponentEntity)obj;
    Attribute remoteAttribute=actor.getAttribute(""String_Node_Str"");
    boolean isSinkOrSource=false;
    if (remoteAttribute instanceof Parameter) {
      Parameter parameter=(Parameter)remoteAttribute;
      if (parameter.getExpression().equals(""String_Node_Str"")) {
        sources.add(actor);
        isSinkOrSource=true;
      }
 else       if (parameter.getExpression().equals(""String_Node_Str"")) {
        sinks.add(actor);
        isSinkOrSource=true;
      }
    }
    if (!isSinkOrSource && _modelType == RemoteModelType.CLIENT) {
      unneededActors.add(actor);
    }
    _initRemoteAttributes(actor);
  }
  _initRemoteAttributes(_topLevelActor);
  if (_topLevelActor instanceof TypedCompositeActor) {
    TypedCompositeActor typedActor=(TypedCompositeActor)_topLevelActor;
    TypedCompositeActor.resolveTypes(typedActor);
  }
  _captureModelTypes(sources,getResolvedTypes());
  _captureModelTypes(sinks,getResolvedTypes());
switch (_modelType) {
case SERVER:
    for (    ComponentEntity entity : sources) {
      _createSource(entity,true,getResolvedTypes());
    }
  for (  ComponentEntity entity : sinks) {
    _createSink(entity,true,getResolvedTypes());
  }
break;
case CLIENT:
for (ComponentEntity entity : sources) {
_createSink(entity,false,getResolvedTypes());
}
for (ComponentEntity entity : sinks) {
_createSource(entity,false,getResolvedTypes());
}
HashMap<NamedObj,StringAttribute> containerToDummyAttributeMap=new HashMap<NamedObj,StringAttribute>();
for (Settable settable : _settableAttributesMap.values()) {
Attribute attribute=(Attribute)settable;
NamedObj container=attribute.getContainer();
Attribute lastAttribute=attribute;
while (container != _topLevelActor) {
StringAttribute dummyAttribute=containerToDummyAttributeMap.get(container);
if (dummyAttribute == null) {
dummyAttribute=new StringAttribute(container.getContainer(),container.getContainer().uniqueName(""String_Node_Str""));
dummyAttribute.setPersistent(true);
containerToDummyAttributeMap.put(container,dummyAttribute);
}
container=container.getContainer();
lastAttribute.setContainer(dummyAttribute);
lastAttribute=dummyAttribute;
}
}
for (ComponentEntity componentEntity : unneededActors) {
componentEntity.setContainer(null);
}
for (Entry<NamedObj,StringAttribute> entry : containerToDummyAttributeMap.entrySet()) {
entry.getValue().setName(entry.getKey().getName());
}
break;
}
}","/** 
 * Load the model from the specified URL.
 * @param modelURL the model URL to be loaded
 * @exception Exception If there is a problem parsing the model,connecting to the mqtt broker or replacing actors.
 */
public void loadModel(URL modelURL) throws Exception {
  MoMLParser parser=_createMoMLParser();
  HashSet<ComponentEntity> unneededActors=new HashSet<ComponentEntity>();
  HashSet<ComponentEntity> sinks=new HashSet<ComponentEntity>();
  HashSet<ComponentEntity> sources=new HashSet<ComponentEntity>();
  _resolvedTypes=new HashMap<String,String>();
  _topLevelActor=(CompositeActor)parser.parse(null,modelURL);
  for (  Object obj : getTopLevelActor().deepEntityList()) {
    ComponentEntity actor=(ComponentEntity)obj;
    Attribute remoteAttribute=actor.getAttribute(""String_Node_Str"");
    boolean isSinkOrSource=false;
    if (remoteAttribute instanceof Parameter) {
      Parameter parameter=(Parameter)remoteAttribute;
      if (parameter.getExpression().equals(""String_Node_Str"")) {
        sources.add(actor);
        isSinkOrSource=true;
      }
 else       if (parameter.getExpression().equals(""String_Node_Str"")) {
        sinks.add(actor);
        isSinkOrSource=true;
      }
    }
    if (!isSinkOrSource && _modelType == RemoteModelType.CLIENT) {
      unneededActors.add(actor);
    }
    _initRemoteAttributes(actor);
  }
  _initRemoteAttributes(_topLevelActor);
  if (_topLevelActor instanceof TypedCompositeActor) {
    TypedCompositeActor typedActor=(TypedCompositeActor)_topLevelActor;
    TypedCompositeActor.resolveTypes(typedActor);
  }
  _captureModelTypes(sources,getResolvedTypes());
  _captureModelTypes(sinks,getResolvedTypes());
switch (_modelType) {
case SERVER:
    for (    ComponentEntity entity : sources) {
      _createSource(entity,true,getResolvedTypes());
    }
  for (  ComponentEntity entity : sinks) {
    _createSink(entity,true,getResolvedTypes());
  }
break;
case CLIENT:
for (ComponentEntity entity : sources) {
_createSink(entity,false,getResolvedTypes());
}
for (ComponentEntity entity : sinks) {
_createSource(entity,false,getResolvedTypes());
}
HashMap<NamedObj,StringAttribute> containerToDummyAttributeMap=new HashMap<NamedObj,StringAttribute>();
for (Settable settable : _settableAttributesMap.values()) {
Attribute attribute=(Attribute)settable;
NamedObj container=attribute.getContainer();
Attribute lastAttribute=attribute;
while (container != _topLevelActor) {
StringAttribute dummyAttribute=containerToDummyAttributeMap.get(container);
if (dummyAttribute == null) {
dummyAttribute=new StringAttribute(container.getContainer(),container.getContainer().uniqueName(""String_Node_Str""));
dummyAttribute.setPersistent(true);
containerToDummyAttributeMap.put(container,dummyAttribute);
}
container=container.getContainer();
lastAttribute.setContainer(dummyAttribute);
lastAttribute=dummyAttribute;
}
}
for (ComponentEntity componentEntity : unneededActors) {
componentEntity.setContainer(null);
}
for (Entry<NamedObj,StringAttribute> entry : containerToDummyAttributeMap.entrySet()) {
entry.getValue().setName(entry.getKey().getName());
}
break;
}
}"
73311,"/** 
 * Create a new instance of the RemoteSink either by replacing the targetEntity or by replacing all entities connected to it.
 * @param targetEntity The target entity to be processed
 * @param replaceTargetEntity replaceTargetEntity true to replacethe target entity with the proxy, otherwise replace all entities connecting to it with one proxy
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see ptserver.actor.RemoteSink
 */
private void _createSink(ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,Type> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  RemoteSink remoteSink=new RemoteSink((CompositeEntity)targetEntity.getContainer(),targetEntity,replaceTargetEntity,portTypes);
  remoteSink.setTokenPublisher(_tokenPublisher);
  _remoteSinkMap.put(remoteSink.getTargetEntityName(),remoteSink);
}","/** 
 * Create a new instance of the RemoteSink either by replacing the targetEntity or by replacing all entities connected to it.
 * @param targetEntity The target entity to be processed
 * @param replaceTargetEntity replaceTargetEntity true to replacethe target entity with the proxy, otherwise replace all entities connecting to it with one proxy
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see ptserver.actor.RemoteSink
 */
private void _createSink(ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,String> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  RemoteSink remoteSink=new RemoteSink((CompositeEntity)targetEntity.getContainer(),targetEntity,replaceTargetEntity,portTypes);
  remoteSink.setTokenPublisher(_tokenPublisher);
  _remoteSinkMap.put(remoteSink.getTargetEntityName(),remoteSink);
}"
73312,"/** 
 * Capture inferred types of the entities.
 * @param entities The entities whose inferred types are captured
 * @param portTypes The mapping that stores the types
 * @exception IllegalActionException If there is a probleminferring type of Typeable.
 */
private void _captureModelTypes(HashSet<ComponentEntity> entities,HashMap<String,Type> portTypes) throws IllegalActionException {
  for (  ComponentEntity entity : entities) {
    for (    Object portObject : entity.portList()) {
      Port port=(Port)portObject;
      if (port instanceof IOPort) {
        if (port instanceof TypedIOPort) {
          portTypes.put(port.getFullName(),((TypedIOPort)port).getType());
        }
        IOPort ioPort=(IOPort)port;
        for (        Object relationObject : ioPort.linkedRelationList()) {
          Relation relation=(Relation)relationObject;
          List<Port> portList=relation.linkedPortList(port);
          for (          Port connectingPort : portList) {
            if (connectingPort instanceof TypedIOPort) {
              portTypes.put(connectingPort.getFullName(),((TypedIOPort)connectingPort).getType());
            }
          }
        }
      }
    }
    for (    Typeable attribute : entity.attributeList(Typeable.class)) {
      portTypes.put(((Nameable)attribute).getFullName(),attribute.getType());
    }
  }
}","/** 
 * Capture inferred types of the entities.
 * @param entities The entities whose inferred types are captured
 * @param portTypes The mapping that stores the types
 * @exception IllegalActionException If there is a probleminferring type of Typeable.
 */
private void _captureModelTypes(HashSet<ComponentEntity> entities,HashMap<String,String> portTypes) throws IllegalActionException {
  for (  ComponentEntity entity : entities) {
    for (    Object portObject : entity.portList()) {
      Port port=(Port)portObject;
      if (port instanceof IOPort) {
        if (port instanceof TypedIOPort) {
          portTypes.put(port.getFullName(),((TypedIOPort)port).getType().toString());
        }
        IOPort ioPort=(IOPort)port;
        for (        Object relationObject : ioPort.linkedRelationList()) {
          Relation relation=(Relation)relationObject;
          List<Port> portList=relation.linkedPortList(port);
          for (          Port connectingPort : portList) {
            if (connectingPort instanceof TypedIOPort) {
              portTypes.put(connectingPort.getFullName(),((TypedIOPort)connectingPort).getType().toString());
            }
          }
        }
      }
    }
    for (    Typeable attribute : entity.attributeList(Typeable.class)) {
      portTypes.put(((Nameable)attribute).getFullName(),attribute.getType().toString());
    }
  }
}"
73313,"/** 
 * Initialize the model that already has RemoteSinks/Sources from the supplied xml string and set appropriate model types from the inferred model mapping. <p>This method is indented to be used on the Android to avoid loading unneeded actors.</p>
 * @param modelXML The modelXML file containing or
 * @param modelTypes The map of ports and their resolved types
 * @exception Exception If there is a problem parsing the modelXML.
 */
public void initModel(String modelXML,HashMap<String,Type> modelTypes) throws Exception {
  MoMLParser parser=_createMoMLParser();
  _topLevelActor=(CompositeActor)parser.parse(modelXML);
  for (  Entry<String,Type> entry : modelTypes.entrySet()) {
    if (entry.getValue() instanceof BaseType) {
      BaseType type=(BaseType)entry.getValue();
      Type staticTypeInstance=BaseType.forName(type.toString());
      entry.setValue(staticTypeInstance);
    }
  }
  for (  Object obj : getTopLevelActor().deepEntityList()) {
    ComponentEntity actor=(ComponentEntity)obj;
    if (actor instanceof RemoteSink) {
      RemoteSink remoteSink=(RemoteSink)actor;
      remoteSink.setTokenPublisher(_tokenPublisher);
      _remoteSinkMap.put(remoteSink.getTargetEntityName(),remoteSink);
    }
 else     if (actor instanceof RemoteSource) {
      RemoteSource remoteSource=(RemoteSource)actor;
      RemoteSourceData remoteSourceData=new RemoteSourceData(remoteSource,this);
      remoteSource.setRemoteSourceData(remoteSourceData);
      getRemoteSourceMap().put(remoteSource.getTargetEntityName(),remoteSourceData);
    }
    Type type;
    for (    Object portObject : actor.portList()) {
      if (portObject instanceof TypedIOPort) {
        TypedIOPort port=(TypedIOPort)portObject;
        StringAttribute targetPortName=(StringAttribute)port.getAttribute(""String_Node_Str"");
        if (targetPortName != null) {
          type=modelTypes.get(targetPortName.getExpression());
          if (type != null) {
            port.setTypeEquals(type);
          }
          port.typeConstraints().clear();
        }
 else         if ((type=modelTypes.get(port.getFullName())) != null) {
          port.setTypeEquals(type);
          port.typeConstraints().clear();
        }
 else {
          throw new IllegalActionException(port,""String_Node_Str"");
        }
      }
    }
    for (    Typeable attribute : actor.attributeList(Typeable.class)) {
      if ((type=modelTypes.get(((Nameable)attribute).getFullName())) != null) {
        attribute.setTypeEquals(type);
        attribute.typeConstraints().clear();
      }
    }
  }
  _initRemoteAttributes(_topLevelActor);
}","/** 
 * Initialize the model that already has RemoteSinks/Sources from the supplied xml string and set appropriate model types from the inferred model mapping. <p>This method is indented to be used on the Android to avoid loading unneeded actors.</p>
 * @param modelXML The modelXML file containing or
 * @param modelTypes The map of ports and their resolved types
 * @exception Exception If there is a problem parsing the modelXML.
 */
public void initModel(String modelXML,HashMap<String,String> modelTypes) throws Exception {
  MoMLParser parser=_createMoMLParser();
  _topLevelActor=(CompositeActor)parser.parse(modelXML);
  for (  Object obj : getTopLevelActor().deepEntityList()) {
    ComponentEntity actor=(ComponentEntity)obj;
    if (actor instanceof RemoteSink) {
      RemoteSink remoteSink=(RemoteSink)actor;
      remoteSink.setTokenPublisher(_tokenPublisher);
      _remoteSinkMap.put(remoteSink.getTargetEntityName(),remoteSink);
    }
 else     if (actor instanceof RemoteSource) {
      RemoteSource remoteSource=(RemoteSource)actor;
      RemoteSourceData remoteSourceData=new RemoteSourceData(remoteSource,this);
      remoteSource.setRemoteSourceData(remoteSourceData);
      getRemoteSourceMap().put(remoteSource.getTargetEntityName(),remoteSourceData);
    }
    Type type;
    for (    Object portObject : actor.portList()) {
      if (portObject instanceof TypedIOPort) {
        TypedIOPort port=(TypedIOPort)portObject;
        StringAttribute targetPortName=(StringAttribute)port.getAttribute(""String_Node_Str"");
        if (targetPortName != null) {
          type=TypeParser.parse(modelTypes.get(targetPortName.getExpression()));
          if (type != null) {
            port.setTypeEquals(type);
          }
          port.typeConstraints().clear();
        }
 else         if ((type=TypeParser.parse(modelTypes.get(port.getFullName()))) != null) {
          port.setTypeEquals(type);
          port.typeConstraints().clear();
        }
 else {
          throw new IllegalActionException(port,""String_Node_Str"");
        }
      }
    }
    for (    Typeable attribute : actor.attributeList(Typeable.class)) {
      if ((type=TypeParser.parse(modelTypes.get(((Nameable)attribute).getFullName()))) != null) {
        attribute.setTypeEquals(type);
        attribute.typeConstraints().clear();
      }
    }
  }
  _initRemoteAttributes(_topLevelActor);
}"
73314,"/** 
 * Create a new instance of the RemoteSource either by replacing the targetEntity or by replacing all entities connected to it.
 * @param targetEntity The target entity to be processed
 * @param replaceTargetEntity replaceTargetEntity true to replacethe target entity with the proxy, otherwise replace all entities connecting to it with one proxy
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see ptserver.actor.RemoteSource
 */
private void _createSource(ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,Type> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  RemoteSource remoteSource=new RemoteSource((CompositeEntity)targetEntity.getContainer(),targetEntity,replaceTargetEntity,portTypes);
  RemoteSourceData data=new RemoteSourceData(remoteSource,this);
  getRemoteSourceMap().put(remoteSource.getTargetEntityName(),data);
}","/** 
 * Create a new instance of the RemoteSource either by replacing the targetEntity or by replacing all entities connected to it.
 * @param targetEntity The target entity to be processed
 * @param replaceTargetEntity replaceTargetEntity true to replacethe target entity with the proxy, otherwise replace all entities connecting to it with one proxy
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 * @see ptserver.actor.RemoteSource
 */
private void _createSource(ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,String> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  RemoteSource remoteSource=new RemoteSource((CompositeEntity)targetEntity.getContainer(),targetEntity,replaceTargetEntity,portTypes);
  RemoteSourceData data=new RemoteSourceData(remoteSource,this);
  getRemoteSourceMap().put(remoteSource.getTargetEntityName(),data);
}"
73315,"/** 
 * Get the map from the Typeable's full name to its type.
 * @return The map from the Typeable's full name to its type.
 * @see #setResolvedTypes(HashMap)
 */
public HashMap<String,Type> getResolvedTypes(){
  return _resolvedTypes;
}","/** 
 * Get the map from the Typeable's full name to its type.
 * @return The map from the Typeable's full name to its type.
 * @see #setResolvedTypes(HashMap)
 */
public HashMap<String,String> getResolvedTypes(){
  return _resolvedTypes;
}"
73316,"/** 
 * Get the map from the model's Typeable objects to its inferred type. <p>This map contains only types for the sinks and sources intended to run on Android.</p>
 * @return the map from the Typeable to its inferred type.
 * @see #setModelTypes(HashMap)
 */
public HashMap<String,Type> getModelTypes(){
  return _modelTypes;
}","/** 
 * Get the map from the model's Typeable objects to its inferred type. <p>This map contains only types for the sinks and sources intended to run on Android.</p>
 * @return the map from the Typeable to its inferred type.
 * @see #setModelTypes(HashMap)
 */
public HashMap<String,String> getModelTypes(){
  return _modelTypes;
}"
73317,"/** 
 * Set the map from the model's Typeable objects to its inferred type.
 * @param modelTypes The map from the Typeable to its inferred type.
 * @see #getModelTypes()
 */
public void setModelTypes(HashMap<String,Type> modelTypes){
  _modelTypes=modelTypes;
}","/** 
 * Set the map from the model's Typeable objects to its inferred type.
 * @param modelTypes The map from the Typeable to its inferred type.
 * @see #getModelTypes()
 */
public void setModelTypes(HashMap<String,String> modelTypes){
  _modelTypes=modelTypes;
}"
73318,"/** 
 * Open a model with the provided model URL and wait for the user to request the execution of the simulation.
 * @param modelUrl The path to the model file
 * @param layoutUrl The path to a model's layout file
 * @exception IllegalActionException  If the model fails to load from the provided URL.
 * @return The user's reference to the simulation task
 */
public synchronized RemoteModelResponse open(String modelUrl,String layoutUrl) throws IllegalActionException {
  RemoteModelResponse response=null;
  Ticket ticket=null;
  try {
    ticket=Ticket.generateTicket(modelUrl,layoutUrl);
    while (_requests.contains(ticket)) {
      ticket=Ticket.generateTicket(modelUrl,layoutUrl);
    }
    RemoteModel clientModel=new RemoteModel(RemoteModelType.CLIENT);
    SimulationTask simulationTask=new SimulationTask(ticket);
    simulationTask.getRemoteModel().addRemoteModelListener(_remoteModelListener);
    String modelXML=new String(downloadModel(ticket.getLayoutUrl()));
    HashMap<String,Type> resolvedTypes=simulationTask.getRemoteModel().getResolvedTypes();
    String brokerUrl=""String_Node_Str"" + InetAddress.getLocalHost().getHostAddress() + ""String_Node_Str""+ getBrokerPort();
    clientModel.initModel(modelXML,resolvedTypes);
    simulationTask.getRemoteModel().createRemoteAttributes(clientModel.getSettableAttributesMap().keySet());
    simulationTask.getRemoteModel().setUpInfrastructure(ticket,brokerUrl);
    response=new RemoteModelResponse();
    response.setTicket(ticket);
    response.setModelTypes(resolvedTypes);
    response.setModelXML(modelXML);
    response.setBrokerUrl(brokerUrl);
    _requests.put(ticket,simulationTask);
  }
 catch (  Exception e) {
    _handleException((ticket != null ? ticket.getTicketID() : null) + ""String_Node_Str"" + e.getMessage(),e);
  }
  return response;
}","/** 
 * Open a model with the provided model URL and wait for the user to request the execution of the simulation.
 * @param modelUrl The path to the model file
 * @param layoutUrl The path to a model's layout file
 * @exception IllegalActionException  If the model fails to load from the provided URL.
 * @return The user's reference to the simulation task
 */
public synchronized RemoteModelResponse open(String modelUrl,String layoutUrl) throws IllegalActionException {
  RemoteModelResponse response=null;
  Ticket ticket=null;
  try {
    ticket=Ticket.generateTicket(modelUrl,layoutUrl);
    while (_requests.contains(ticket)) {
      ticket=Ticket.generateTicket(modelUrl,layoutUrl);
    }
    RemoteModel clientModel=new RemoteModel(RemoteModelType.CLIENT);
    SimulationTask simulationTask=new SimulationTask(ticket);
    simulationTask.getRemoteModel().addRemoteModelListener(_remoteModelListener);
    String modelXML=new String(downloadModel(ticket.getLayoutUrl()));
    HashMap<String,String> resolvedTypes=simulationTask.getRemoteModel().getResolvedTypes();
    String brokerUrl=""String_Node_Str"" + InetAddress.getLocalHost().getHostAddress() + ""String_Node_Str""+ getBrokerPort();
    clientModel.initModel(modelXML,resolvedTypes);
    simulationTask.getRemoteModel().createRemoteAttributes(clientModel.getSettableAttributesMap().keySet());
    simulationTask.getRemoteModel().setUpInfrastructure(ticket,brokerUrl);
    response=new RemoteModelResponse();
    response.setTicket(ticket);
    response.setModelTypes(resolvedTypes);
    response.setModelXML(modelXML);
    response.setBrokerUrl(brokerUrl);
    _requests.put(ticket,simulationTask);
  }
 catch (  Exception e) {
    _handleException((ticket != null ? ticket.getTicketID() : null) + ""String_Node_Str"" + e.getMessage(),e);
  }
  return response;
}"
73319,"/** 
 * Replace all entities connected to the targetEntity with one RemoteSource or RemoteSink.  Essentially instead of all entities connected to it, RemoteSink or RemoteSource would be used that would redirect all links from those entities to itself and connect them to dynamically added ports derived from the connected entities. This configuration would allow running of sources and sinks disconnected from the actors in between remotely by passing respective input and output via CommunicationToken.
 * @param targetEntity the entity to which actors that arereplaced are connected
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
private void _replaceConnectingEntities(ComponentEntity targetEntity,HashMap<String,String> portTypes) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      List<Port> linkedPortList=relation.linkedPortList(port);
      IOPort remotePort=null;
      for (      Port connectingPort : linkedPortList) {
        if (connectingPort instanceof IOPort && isValidConnectingPort((IOPort)connectingPort)) {
          remotePort=(IOPort)connectingPort.clone(port.workspace());
          remotePort.setPersistent(true);
          remotePort.setName(port.getName());
          remotePort.setContainer(this);
          if (remotePort instanceof TypedIOPort) {
            Type type=BaseType.forName(portTypes.get(connectingPort.getFullName()));
            ((TypedIOPort)remotePort).setTypeEquals(type);
            StringAttribute targetPortName=new StringAttribute(remotePort,""String_Node_Str"");
            targetPortName.setExpression(connectingPort.getFullName());
          }
          break;
        }
      }
      relation.unlinkAll();
      if (remotePort != null) {
        port.link(relation);
        remotePort.link(relation);
      }
    }
  }
}","/** 
 * Replace all entities connected to the targetEntity with one RemoteSource or RemoteSink.  Essentially instead of all entities connected to it, RemoteSink or RemoteSource would be used that would redirect all links from those entities to itself and connect them to dynamically added ports derived from the connected entities. This configuration would allow running of sources and sinks disconnected from the actors in between remotely by passing respective input and output via CommunicationToken.
 * @param targetEntity the entity to which actors that arereplaced are connected
 * @param portTypes The map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
private void _replaceConnectingEntities(ComponentEntity targetEntity,HashMap<String,String> portTypes) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      List<Port> linkedPortList=relation.linkedPortList(port);
      IOPort remotePort=null;
      for (      Port connectingPort : linkedPortList) {
        if (connectingPort instanceof IOPort && isValidConnectingPort((IOPort)connectingPort)) {
          remotePort=(IOPort)port.clone(port.workspace());
          remotePort.setInput(!port.isInput());
          remotePort.setOutput(!port.isOutput());
          remotePort.setPersistent(true);
          remotePort.setContainer(this);
          remotePort.setMultiport(false);
          if (remotePort instanceof TypedIOPort) {
            Type type=BaseType.forName(portTypes.get(port.getFullName()));
            ((TypedIOPort)remotePort).setTypeEquals(type);
            StringAttribute targetPortName=new StringAttribute(remotePort,""String_Node_Str"");
            targetPortName.setExpression(port.getFullName());
          }
          break;
        }
      }
      relation.unlinkAll();
      if (remotePort != null) {
        port.link(relation);
        remotePort.link(relation);
      }
    }
  }
}"
73320,"/** 
 * <p>This private constructor loads mappings from a token class to its TokenHandler from TokenHandlers.properties file which is located in ptserver/data directory.</p> <p>This constructor is private because the TokenParser is singleton which makes it easy to locate the instance without passing it around.</p>
 * @exception IllegalActionException if there is a problem loading the mapping from TokenHandlers.properties file.
 */
private TokenParser() throws IllegalActionException {
  Enumeration<String> keys=_tokenHandlersBundle.getKeys();
  while (keys.hasMoreElements()) {
    String key=keys.nextElement();
    String value=_tokenHandlersBundle.getString(key);
    try {
      ClassLoader classLoader=getClass().getClassLoader();
      Class<Token> tokenClass=(Class<Token>)classLoader.loadClass(key);
      TokenHandler<Token> tokenHandler=(TokenHandler<Token>)classLoader.loadClass(value).newInstance();
      HandlerData<Token> data=new HandlerData<Token>(tokenHandler,tokenClass,(short)_handlerList.size());
      _handlerMap.put(tokenClass,data);
      _handlerList.add(data);
    }
 catch (    ClassNotFoundException e) {
      throw new IllegalActionException(null,e,""String_Node_Str"" + key + ""String_Node_Str""+ value);
    }
catch (    InstantiationException e) {
      throw new IllegalActionException(null,e,""String_Node_Str"" + value);
    }
catch (    IllegalAccessException e) {
      throw new IllegalActionException(null,e,""String_Node_Str"" + value);
    }
  }
}","/** 
 * <p>This private constructor loads mappings from a token class to its TokenHandler from TokenHandlers.properties file which is located in ptserver/data directory.</p> <p>This constructor is private because the TokenParser is singleton which makes it easy to locate the instance without passing it around.</p>
 * @exception IllegalActionException if there is a problem loading the mapping from TokenHandlers.properties file.
 */
private TokenParser() throws IllegalActionException {
  LinkedHashMap<String,String> tokenHandlerMap=new LinkedHashMap<String,String>();
  Enumeration<String> keys=_tokenHandlersBundle.getKeys();
  while (keys.hasMoreElements()) {
    String key=keys.nextElement();
    tokenHandlerMap.put(key,_tokenHandlersBundle.getString(key));
  }
  setTokenHandlers(tokenHandlerMap);
}"
73321,"/** 
 * Entry point to the Ptolemy MQTT Client which is used for testing purposes.
 * @param args The first argument is file path to the model
 */
public static void main(String[] args){
  try {
    RemoteModel model=new RemoteModel(RemoteModelType.CLIENT);
    URL resource=PtolemyTestClient.class.getResource(""String_Node_Str"");
    model.loadModel(resource);
    Manager manager=model.setUpInfrastructure(Ticket.generateTicket(null,null),""String_Node_Str"");
    CompositeActor topLevelActor=model.getTopLevelActor();
    topLevelActor.getDirector().setContainer(null);
    topLevelActor.setDirector(new PNDirector(topLevelActor,""String_Node_Str""));
    System.out.println(topLevelActor.exportMoML());
    manager.execute();
  }
 catch (  Throwable throwable) {
    throwable.printStackTrace();
  }
}","/** 
 * Entry point to the Ptolemy MQTT Client which is used for testing purposes.
 * @param args The first argument is file path to the model
 */
public static void main(String[] args){
  try {
    RemoteModel model=new RemoteModel(RemoteModelType.CLIENT);
    URL resource=PtolemyTestClient.class.getResource(""String_Node_Str"");
    model.loadModel(resource);
    CompositeActor topLevelActor=model.getTopLevelActor();
    System.out.println(topLevelActor.exportMoML());
  }
 catch (  Throwable throwable) {
    throwable.printStackTrace();
  }
}"
73322,"/** 
 * Generate the preinitialization method body. <p>Typically, the preinitialize code consists of variable declarations.  However, AutoAdapter generates method calls that instantiate wrapper TypedCompositeActors, so we need to invoke those method calls.</p>
 * @return a string for the preinitialization method body.  Inthis base class, return the empty string.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generatePreinitializeMethodBodyCode() throws IllegalActionException {
  String actorClassName=getComponent().getClass().getName();
  StringBuffer containmentCode=new StringBuffer();
  NamedObj parentContainer=getComponent().getContainer();
  NamedObj grandparentContainer=parentContainer.getContainer();
  if (grandparentContainer == null) {
    containmentCode.append(""String_Node_Str"" + getComponent().getContainer().getClass().getName() + ""String_Node_Str""+ getComponent().getName()+ ""String_Node_Str""+ _eol);
  }
 else {
    while (parentContainer != null) {
      containmentCode.insert(0,""String_Node_Str"" + parentContainer.getName() + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ parentContainer.getClass().getName()+ ""String_Node_Str""+ parentContainer.getName()+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
      parentContainer=parentContainer.getContainer();
    }
    NamedObj container=grandparentContainer;
    containmentCode.insert(0,""String_Node_Str"" + _eol + getCodeGenerator().comment(getComponent().getFullName())+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ container.getName()+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ container.getClass().getName()+ ""String_Node_Str""+ container.getName()+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
    containmentCode.append(""String_Node_Str"" + getComponent().getContainer().getClass().getName() + ""String_Node_Str""+ getComponent().getName()+ ""String_Node_Str""+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
  }
  StringBuffer code=new StringBuffer();
  Iterator entityPorts=((Entity)getComponent()).portList().iterator();
  while (entityPorts.hasNext()) {
    ComponentPort insidePort=(ComponentPort)entityPorts.next();
    if (insidePort instanceof TypedIOPort) {
      TypedIOPort castPort=(TypedIOPort)insidePort;
      String name=TemplateParser.escapePortName(castPort.getName());
      if (!castPort.isMultiport() && castPort.isOutsideConnected()) {
        code.append(_generatePortInstantiation(name,castPort.getName(),castPort,0));
      }
 else {
        TypedIOPort actorPort=null;
        try {
          Field foundPortField=_findFieldByPortName(castPort.getName());
          actorPort=(TypedIOPort)foundPortField.get(getComponent());
          code.append(""String_Node_Str"" + getComponent().getClass().getName() + ""String_Node_Str""+ foundPortField.getName()+ ""String_Node_Str""+ _typeToBaseType(actorPort.getType())+ ""String_Node_Str""+ _eol);
        }
 catch (        Throwable throwable) {
          actorPort=(TypedIOPort)((Entity)getComponent()).getPort(castPort.getName());
          code.append(""String_Node_Str"" + actorPort.getName().replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ actorPort.isInput()+ ""String_Node_Str""+ actorPort.isOutput()+ ""String_Node_Str""+ _eol);
        }
        int sources=actorPort.numberOfSources();
        for (int i=0; i < sources; i++) {
          code.append(_generatePortInstantiation(name,name + ""String_Node_Str"" + i,actorPort,i));
        }
        int sinks=actorPort.numberOfSinks();
        for (int i=0; i < sinks; i++) {
          code.append(_generatePortInstantiation(name,name + ""String_Node_Str"" + i,actorPort,i));
        }
      }
      List<TypeAttribute> typeAttributes=insidePort.attributeList(TypeAttribute.class);
      if (typeAttributes.size() > 0) {
        if (typeAttributes.size() > 1) {
          new Exception(""String_Node_Str"" + insidePort.getFullName() + ""String_Node_Str"").printStackTrace();
        }
        TypeAttribute typeAttribute=typeAttributes.get(0);
        code.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ insidePort.getName().replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ typeAttribute.getExpression()+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
  }
  String[] splitInitializeConnectionCode=getCodeGenerator()._splitBody(""String_Node_Str"",code.toString());
  String result=getCodeGenerator().comment(""String_Node_Str"") + ""String_Node_Str"" + _eol+ ""String_Node_Str""+ getComponent().toplevel().getName()+ ""String_Node_Str""+ _eol+ containmentCode+ ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ getComponent().getName()+ ""String_Node_Str""+ _eol+ splitInitializeConnectionCode[0]+ splitInitializeConnectionCode[1]+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol;
  return processCode(result);
}","/** 
 * Generate the preinitialization method body. <p>Typically, the preinitialize code consists of variable declarations.  However, AutoAdapter generates method calls that instantiate wrapper TypedCompositeActors, so we need to invoke those method calls.</p>
 * @return a string for the preinitialization method body.  Inthis base class, return the empty string.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generatePreinitializeMethodBodyCode() throws IllegalActionException {
  String actorClassName=getComponent().getClass().getName();
  StringBuffer containmentCode=new StringBuffer();
  NamedObj parentContainer=getComponent().getContainer();
  NamedObj grandparentContainer=parentContainer.getContainer();
  if (grandparentContainer == null) {
    containmentCode.append(""String_Node_Str"" + getComponent().getContainer().getClass().getName() + ""String_Node_Str""+ getComponent().getName()+ ""String_Node_Str""+ _eol);
  }
 else {
    while (parentContainer != null && parentContainer.getContainer() != null) {
      containmentCode.insert(0,""String_Node_Str"" + parentContainer.getName() + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ parentContainer.getClass().getName()+ ""String_Node_Str""+ parentContainer.getName()+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
      parentContainer=parentContainer.getContainer();
    }
    NamedObj container=grandparentContainer;
    containmentCode.insert(0,""String_Node_Str"" + _eol + getCodeGenerator().comment(getComponent().getFullName())+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
    containmentCode.append(""String_Node_Str"" + getComponent().getContainer().getClass().getName() + ""String_Node_Str""+ getComponent().getName()+ ""String_Node_Str""+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
  }
  StringBuffer code=new StringBuffer();
  Iterator entityPorts=((Entity)getComponent()).portList().iterator();
  while (entityPorts.hasNext()) {
    ComponentPort insidePort=(ComponentPort)entityPorts.next();
    if (insidePort instanceof TypedIOPort) {
      TypedIOPort castPort=(TypedIOPort)insidePort;
      String name=TemplateParser.escapePortName(castPort.getName());
      if (!castPort.isMultiport() && castPort.isOutsideConnected()) {
        code.append(_generatePortInstantiation(name,castPort.getName(),castPort,0));
      }
 else {
        TypedIOPort actorPort=null;
        try {
          Field foundPortField=_findFieldByPortName(castPort.getName());
          actorPort=(TypedIOPort)foundPortField.get(getComponent());
          code.append(""String_Node_Str"" + getComponent().getClass().getName() + ""String_Node_Str""+ foundPortField.getName()+ ""String_Node_Str""+ _typeToBaseType(actorPort.getType())+ ""String_Node_Str""+ _eol);
        }
 catch (        Throwable throwable) {
          actorPort=(TypedIOPort)((Entity)getComponent()).getPort(castPort.getName());
          code.append(""String_Node_Str"" + actorPort.getName().replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ actorPort.isInput()+ ""String_Node_Str""+ actorPort.isOutput()+ ""String_Node_Str""+ _eol);
        }
        int sources=actorPort.numberOfSources();
        for (int i=0; i < sources; i++) {
          code.append(_generatePortInstantiation(name,name + ""String_Node_Str"" + i,actorPort,i));
        }
        int sinks=actorPort.numberOfSinks();
        for (int i=0; i < sinks; i++) {
          code.append(_generatePortInstantiation(name,name + ""String_Node_Str"" + i,actorPort,i));
        }
      }
      List<TypeAttribute> typeAttributes=insidePort.attributeList(TypeAttribute.class);
      if (typeAttributes.size() > 0) {
        if (typeAttributes.size() > 1) {
          new Exception(""String_Node_Str"" + insidePort.getFullName() + ""String_Node_Str"").printStackTrace();
        }
        TypeAttribute typeAttribute=typeAttributes.get(0);
        code.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ insidePort.getName().replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ typeAttribute.getExpression()+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
  }
  code.append(generateParameterCode());
  String[] splitInitializeConnectionCode=getCodeGenerator()._splitBody(""String_Node_Str"",code.toString());
  String result=getCodeGenerator().comment(""String_Node_Str"") + ""String_Node_Str"" + _eol+ ""String_Node_Str""+ getComponent().toplevel().getName()+ ""String_Node_Str""+ _eol+ containmentCode+ ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ getComponent().getName()+ ""String_Node_Str""+ _eol+ splitInitializeConnectionCode[0]+ splitInitializeConnectionCode[1]+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol;
  return processCode(result);
}"
73323,"/** 
 * Return the code that creates temporary variables that hold the values to be read.  We need to do this so as to avoid reading from the same Ptolemy receiver twice, which would happen if we have an automatically generated actor with a regular non-multiport that feeds its output to two actors.
 * @param actorPortName The name of the Actor port from whichdata will be read.
 * @param codegenPortName The name of the port on the codegen side.For non-multiports, actorPortName and codegenPortName are the same. For multiports, codegenPortName will vary according to channel number while actorPortName will remain the same.
 * @param type The type of the port.
 * @param channel The channel number.For non-multiports, the channel number will be 0.
 */
private String _generateGetInsideDeclarations(String actorPortName,String codegenPortName,Type type,int channel){
  actorPortName=TemplateParser.escapePortName(actorPortName);
  codegenPortName=TemplateParser.escapePortName(codegenPortName);
  String portData=actorPortName + ""String_Node_Str"" + (channel == 0 ? ""String_Node_Str"" : channel);
  if (type instanceof ArrayType) {
    ArrayType array=(ArrayType)type;
    String codeGenElementType=getCodeGenerator().codeGenType(array.getDeclaredElementType()).replace(""String_Node_Str"",""String_Node_Str"");
    String targetElementType=getCodeGenerator().targetType(array.getDeclaredElementType());
    String ptolemyData=""String_Node_Str"" + actorPortName + ""String_Node_Str"";
    return type.getTokenClass().getName() + ""String_Node_Str"" + ptolemyData+ ""String_Node_Str""+ type.getTokenClass().getName()+ ""String_Node_Str""+ codegenPortName+ ""String_Node_Str""+ (channel == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + channel)+ ""String_Node_Str""+ _eol+ _eol+ getCodeGenerator().comment(""String_Node_Str"")+ ""String_Node_Str""+ portData+ ""String_Node_Str""+ ""String_Node_Str""+ ptolemyData+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ ptolemyData+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ portData+ ""String_Node_Str""+ getCodeGenerator().codeGenType(array.getDeclaredElementType())+ ""String_Node_Str""+ codeGenElementType+ ""String_Node_Str""+ ptolemyData+ ""String_Node_Str""+ targetElementType+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol;
  }
 else   if (type == BaseType.COMPLEX) {
    return ""String_Node_Str"" + actorPortName + ""String_Node_Str""+ portData+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ type.getTokenClass().getName()+ ""String_Node_Str""+ ""String_Node_Str""+ codegenPortName+ ""String_Node_Str""+ ""String_Node_Str""+ type.toString().toLowerCase()+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ portData+ ""String_Node_Str""+ _eol;
  }
 else {
    return ""String_Node_Str"" + actorPortName + ""String_Node_Str""+ portData+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ portData+ ""String_Node_Str""+ ""String_Node_Str""+ type.getTokenClass().getName()+ ""String_Node_Str""+ ""String_Node_Str""+ codegenPortName+ ""String_Node_Str""+ ""String_Node_Str""+ type.toString().toLowerCase()+ ""String_Node_Str""+ _eol;
  }
}","/** 
 * Return the code that creates temporary variables that hold the values to be read.  We need to do this so as to avoid reading from the same Ptolemy receiver twice, which would happen if we have an automatically generated actor with a regular non-multiport that feeds its output to two actors.
 * @param actorPortName The name of the Actor port from whichdata will be read.
 * @param codegenPortName The name of the port on the codegen side.For non-multiports, actorPortName and codegenPortName are the same. For multiports, codegenPortName will vary according to channel number while actorPortName will remain the same.
 * @param type The type of the port.
 * @param channel The channel number.For non-multiports, the channel number will be 0.
 */
private String _generateGetInsideDeclarations(String actorPortName,String codegenPortName,Type type,int channel){
  actorPortName=TemplateParser.escapePortName(actorPortName);
  codegenPortName=TemplateParser.escapePortName(codegenPortName);
  String portData=actorPortName + ""String_Node_Str"" + (channel == 0 ? ""String_Node_Str"" : channel);
  if (type instanceof ArrayType) {
    ArrayType array=(ArrayType)type;
    String codeGenElementType=getCodeGenerator().codeGenType(array.getDeclaredElementType()).replace(""String_Node_Str"",""String_Node_Str"");
    String targetElementType=getCodeGenerator().targetType(array.getDeclaredElementType());
    String ptolemyData=""String_Node_Str"" + actorPortName + ""String_Node_Str"";
    return type.getTokenClass().getName() + ""String_Node_Str"" + ptolemyData+ ""String_Node_Str""+ type.getTokenClass().getName()+ ""String_Node_Str""+ codegenPortName+ ""String_Node_Str""+ (channel == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + channel)+ ""String_Node_Str""+ _eol+ _eol+ getCodeGenerator().comment(""String_Node_Str"")+ ""String_Node_Str""+ portData+ ""String_Node_Str""+ ""String_Node_Str""+ ptolemyData+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ ptolemyData+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ portData+ ""String_Node_Str""+ getCodeGenerator().codeGenType(array.getDeclaredElementType())+ ""String_Node_Str""+ codeGenElementType+ ""String_Node_Str""+ ptolemyData+ ""String_Node_Str""+ targetElementType+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ _generateGetInside(actorPortName,codegenPortName,type,channel);
  }
 else   if (type == BaseType.COMPLEX) {
    return ""String_Node_Str"" + actorPortName + ""String_Node_Str""+ portData+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ type.getTokenClass().getName()+ ""String_Node_Str""+ ""String_Node_Str""+ codegenPortName+ ""String_Node_Str""+ ""String_Node_Str""+ type.toString().toLowerCase()+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ portData+ ""String_Node_Str""+ _eol+ _generateGetInside(actorPortName,codegenPortName,type,channel);
  }
 else {
    return ""String_Node_Str"" + actorPortName + ""String_Node_Str""+ portData+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ codegenPortName+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ portData+ ""String_Node_Str""+ ""String_Node_Str""+ type.getTokenClass().getName()+ ""String_Node_Str""+ ""String_Node_Str""+ codegenPortName+ ""String_Node_Str""+ ""String_Node_Str""+ type.toString().toLowerCase()+ ""String_Node_Str""+ _eol+ _generateGetInside(actorPortName,codegenPortName,type,channel)+ _eol+ ""String_Node_Str""+ _eol;
  }
}"
73324,"/** 
 * Generate the initialize code. <p>Generate code that creates the container, actor and ports. <p>Generate code that connects the ports of the inner actor to the ports of the outer actor.
 * @return The initialize code of the containing composite actor.
 * @exception IllegalActionException If thrown while appending to thethe block or processing the macros.
 */
public String generateInitializeCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  String actorClassName=getComponent().getClass().getName();
  Iterator parameters=getComponent().attributeList(Settable.class).iterator();
  while (parameters.hasNext()) {
    Settable parameter=(Settable)parameters.next();
    if (!ptolemy.actor.gui.Configurer.isVisible(getComponent(),parameter)) {
      continue;
    }
    String parameterName=StringUtilities.sanitizeName(parameter.getName()).replaceAll(""String_Node_Str"",""String_Node_Str"");
    if (parameterName.equals(""String_Node_Str"")) {
      continue;
    }
    String parameterValue=""String_Node_Str"";
    if (parameter instanceof Variable && ((Variable)parameter).getToken() != null) {
      parameterValue=((Variable)parameter).getToken().toString();
      if (((Variable)parameter).isStringMode()) {
        if (parameterValue.startsWith(""String_Node_Str"") && parameterValue.endsWith(""String_Node_Str"")) {
          parameterValue=parameterValue.substring(1,parameterValue.length() - 1);
        }
      }
    }
 else {
      parameterValue=parameter.getExpression();
    }
    parameterValue=parameterValue.replaceAll(""String_Node_Str"",""String_Node_Str"");
    boolean privateParameter=false;
    try {
      getComponent().getClass().getField(parameterName);
    }
 catch (    NoSuchFieldException ex) {
      privateParameter=true;
      code.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ parameterName+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ parameter.getName()+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ parameterValue+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
    }
catch (    SecurityException ex2) {
      throw new IllegalActionException(getComponent(),ex2,""String_Node_Str"" + parameterName + ""String_Node_Str"");
    }
    if (!privateParameter) {
      String setParameter=""String_Node_Str"";
      if (parameter instanceof Parameter) {
        setParameter=""String_Node_Str"" + parameterName + ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ parameterName+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ parameterName+ ""String_Node_Str""+ parameterValue+ ""String_Node_Str""+ _eol;
      }
 else {
        if (parameter instanceof ptolemy.kernel.util.StringAttribute) {
          setParameter=""String_Node_Str"" + parameterName + ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ parameterName+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ parameterName+ ""String_Node_Str""+ parameterValue+ ""String_Node_Str""+ _eol;
        }
      }
      code.append(""String_Node_Str"" + _eol + setParameter+ ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ parameterName+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
    }
  }
  String[] splitInitializeParameterCode=getCodeGenerator()._splitBody(""String_Node_Str"",code.toString());
  String result=""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ splitInitializeParameterCode[0]+ splitInitializeParameterCode[1]+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol;
  return processCode(result);
}","/** 
 * Generate the initialize code. <p>Generate code that creates the container, actor and ports. <p>Generate code that connects the ports of the inner actor to the ports of the outer actor.
 * @return The initialize code of the containing composite actor.
 * @exception IllegalActionException If thrown while appending to thethe block or processing the macros.
 */
public String generateInitializeCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  String actorClassName=getComponent().getClass().getName();
  String[] splitInitializeParameterCode=getCodeGenerator()._splitBody(""String_Node_Str"",code.toString());
  String result=""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ splitInitializeParameterCode[0]+ splitInitializeParameterCode[1]+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol;
  return processCode(result);
}"
73325,"/** 
 * Generate the fire code.  <p>Generate code that creates tokens, sends them to the input(s) of inner Ptolemy actor, calls fire() on the actor and reads the outputs.
 * @return The generated code.
 * @exception IllegalActionException Not thrown in this base class.
 */
protected String _generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer(getCodeGenerator().comment(""String_Node_Str""));
  Iterator inputPorts=((Actor)getComponent()).inputPortList().iterator();
  while (inputPorts.hasNext()) {
    TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
    String name=inputPort.getName();
    Type type=inputPort.getType();
    if (!inputPort.isMultiport() && inputPort.isOutsideConnected() && ((inputPort instanceof ParameterPort) || inputPort.numLinks() > 0)) {
      code.append(_generateSendInside(name,name,type,0));
    }
 else {
      int sources=inputPort.numberOfSources();
      for (int i=0; i < sources; i++) {
        code.append(_generateSendInside(name,name + ""String_Node_Str"" + i,type,i));
      }
      int sinks=inputPort.numberOfSinks();
      int width=inputPort.getWidth();
      if (width < sinks) {
        sinks=width;
      }
      for (int i=0; i < sinks; i++) {
        code.append(_generateSendInside(name,name + ""String_Node_Str"" + i,type,i));
      }
    }
  }
  code.append(""String_Node_Str"" + _eol);
  Iterator outputPorts=((Actor)getComponent()).outputPortList().iterator();
  while (outputPorts.hasNext()) {
    TypedIOPort outputPort=(TypedIOPort)outputPorts.next();
    String name=outputPort.getName();
    Type type=outputPort.getType();
    if (!outputPort.isMultiport()) {
      if (outputPort.isOutsideConnected()) {
        code.append(""String_Node_Str"" + _eol + _generateGetInsideDeclarations(name,name,type,0)+ _generateGetInside(name,name,type,0)+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
 else {
      int sources=outputPort.numberOfSources();
      for (int i=0; i < sources; i++) {
        code.append(""String_Node_Str"" + _eol + _generateGetInsideDeclarations(name,name + ""String_Node_Str"" + i,type,i)+ _generateGetInside(name,name + ""String_Node_Str"" + i,type,i)+ _eol+ ""String_Node_Str""+ _eol);
      }
      int sinks=outputPort.numberOfSinks();
      for (int i=0; i < sinks; i++) {
        code.append(""String_Node_Str"" + _eol + _generateGetInsideDeclarations(name,name + ""String_Node_Str"" + i,type,i)+ _generateGetInside(name,name + ""String_Node_Str"" + i,type,i)+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
  }
  String[] splitFireCode=getCodeGenerator()._splitBody(""String_Node_Str"",code.toString());
  return ""String_Node_Str"" + _eol + splitFireCode[0]+ _eol+ splitFireCode[1]+ _eol+ ""String_Node_Str""+ _eol;
}","/** 
 * Generate the fire code.  <p>Generate code that creates tokens, sends them to the input(s) of inner Ptolemy actor, calls fire() on the actor and reads the outputs.
 * @return The generated code.
 * @exception IllegalActionException Not thrown in this base class.
 */
protected String _generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer(getCodeGenerator().comment(""String_Node_Str""));
  Iterator inputPorts=((Actor)getComponent()).inputPortList().iterator();
  while (inputPorts.hasNext()) {
    TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
    String name=inputPort.getName();
    Type type=inputPort.getType();
    if (!inputPort.isMultiport() && inputPort.isOutsideConnected() && ((inputPort instanceof ParameterPort) || inputPort.numLinks() > 0)) {
      code.append(_generateSendInside(name,name,type,0));
    }
 else {
      int sources=inputPort.numberOfSources();
      for (int i=0; i < sources; i++) {
        code.append(_generateSendInside(name,name + ""String_Node_Str"" + i,type,i));
      }
      int sinks=inputPort.numberOfSinks();
      int width=inputPort.getWidth();
      if (width < sinks) {
        sinks=width;
      }
      for (int i=0; i < sinks; i++) {
        code.append(_generateSendInside(name,name + ""String_Node_Str"" + i,type,i));
      }
    }
  }
  code.append(""String_Node_Str"" + _eol);
  Iterator outputPorts=((Actor)getComponent()).outputPortList().iterator();
  while (outputPorts.hasNext()) {
    TypedIOPort outputPort=(TypedIOPort)outputPorts.next();
    String name=outputPort.getName();
    Type type=outputPort.getType();
    if (!outputPort.isMultiport()) {
      if (outputPort.isOutsideConnected()) {
        code.append(""String_Node_Str"" + _eol + _generateGetInsideDeclarations(name,name,type,0)+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
 else {
      int sources=outputPort.numberOfSources();
      for (int i=0; i < sources; i++) {
        code.append(""String_Node_Str"" + _eol + _generateGetInsideDeclarations(name,name + ""String_Node_Str"" + i,type,i)+ _eol+ ""String_Node_Str""+ _eol);
      }
      int sinks=outputPort.numberOfSinks();
      for (int i=0; i < sinks; i++) {
        code.append(""String_Node_Str"" + _eol + _generateGetInsideDeclarations(name,name + ""String_Node_Str"" + i,type,i)+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
  }
  String[] splitFireCode=getCodeGenerator()._splitBody(""String_Node_Str"",code.toString());
  return ""String_Node_Str"" + _eol + splitFireCode[0]+ _eol+ splitFireCode[1]+ _eol+ ""String_Node_Str""+ _eol;
}"
73326,"/** 
 * Convert the Ping or Pong token to the by stream.
 * @param token the token to be converted
 * @param outputStream the outputStream holding stream of bytes
 * @see ptserver.data.handler.TokenHandler#convertToBytes(ptolemy.data.Token,java.io.DataOutputStream)
 * @exception IOException if there is a problem with the outputStream
 * @exception IllegalActionException if there is the state becomes inconsistent
 */
public void convertToBytes(Token token,DataOutputStream outputStream) throws IOException, IllegalActionException {
  if (token.getClass() == PingToken.class) {
    outputStream.writeLong(((PingToken)token).getTimestamp());
  }
 else   if (token.getClass() == PongToken.class) {
    outputStream.writeLong(((PongToken)token).getTimestamp());
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
}","/** 
 * Convert the Ping or Pong token to the by stream.
 * @param token the token to be converted
 * @param outputStream the outputStream holding stream of bytes
 * @see ptserver.data.handler.TokenHandler#convertToBytes(ptolemy.data.Token,java.io.DataOutputStream)
 * @exception IOException if there is a problem with the outputStream
 * @exception IllegalActionException if there is the state becomes inconsistent
 */
public void convertToBytes(Token token,DataOutputStream outputStream) throws IOException, IllegalActionException {
  if (token instanceof PingToken) {
    outputStream.writeLong(((PingToken)token).getTimestamp());
  }
 else   if (token instanceof PongToken) {
    outputStream.writeLong(((PongToken)token).getTimestamp());
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
}"
73327,"/** 
 * Create and return a file dialog for the ""Save As"" command. This overrides the base class to add options to the dialog. If   {@link ptolemy.gui.PtGUIUtilities#useFileDialog()} returns truethen  {@link ptolemy.gui.Top#_saveAs()} uses this method.  Otherwise, {@link #_saveAsJFileChooserComponent()} is used.
 * @return A file dialog for save as.
 */
protected FileDialog _saveAsFileDialogComponent(){
  FileDialog fileDialog=super._saveAsFileDialogComponent();
  if ((_model != null) && (_model.getContainer() != null)) {
    _query=new Query();
    _query.addCheckBox(""String_Node_Str"",""String_Node_Str"",false);
    new ComponentDialog(this,""String_Node_Str"",_query);
  }
  return fileDialog;
}","/** 
 * Create and return a file dialog for the ""Save As"" command. This overrides the base class to add options to the dialog. If   {@link ptolemy.gui.PtGUIUtilities#useFileDialog()} returns truethen  {@link ptolemy.gui.Top#_saveAs()} uses this method.  Otherwise, {@link #_saveAsJFileChooserComponent()} is used.
 * @return A file dialog for save as.
 */
protected FileDialog _saveAsFileDialogComponent(){
  FileDialog fileDialog=super._saveAsFileDialogComponent();
  if ((_model != null) && (_model.getContainer() != null)) {
    _query=new Query();
    _query.addCheckBox(""String_Node_Str"",""String_Node_Str"",false);
    ComponentDialog dialog=new ComponentDialog(this,""String_Node_Str"",_query);
    String button=dialog.buttonPressed();
    if (button.equals(""String_Node_Str"")) {
      return null;
    }
  }
  return fileDialog;
}"
73328,"/** 
 * Query the user for a filename, save the model to that file, and open a new window to view the model.  This method uses java.awt.FileDialog and is usually used under Mac OS X.
 * @param extension If non-null, then the extension that isappended to the file name if there is no extension.
 * @return URL of the saved file if the save succeeds, null if save fails.
 */
private URL _saveAsHelperFileDialog(String extension){
  URL newURL=null;
  FileDialog fileDialog=_saveAsFileDialogComponent();
  if (_initialSaveAsFileName != null) {
    fileDialog.setFile(new File(fileDialog.getDirectory(),_initialSaveAsFileName).toString());
  }
  fileDialog.show();
  String selectedFile=fileDialog.getFile();
  if (selectedFile != null) {
    File file=null;
    if (selectedFile.startsWith(""String_Node_Str"")) {
      file=new File(selectedFile.replace(':','/'));
    }
 else {
      file=new File(_directory,selectedFile);
    }
    if (extension != null && file.getName().indexOf(""String_Node_Str"") == -1) {
      file=new File(file.getAbsolutePath() + extension);
    }
    try {
      if (!_confirmFile(null,file)) {
        return null;
      }
      newURL=file.toURI().toURL();
      String newKey=newURL.toExternalForm();
      _directory=new File(fileDialog.getDirectory());
      _writeFile(file);
      Tableau newTableau=getConfiguration().openModel(newURL,newURL,newKey);
      newTableau.getFrame().setTitle(StringUtilities.abbreviate(new File(_directory,file.getName()).toString()));
      Effigy effigy=getEffigy();
      if (effigy != null) {
        String id=effigy.identifier.getExpression();
        if (id.equals(""String_Node_Str"")) {
          effigy.setContainer(null);
        }
      }
      dispose();
      return newURL;
    }
 catch (    Exception ex) {
      report(""String_Node_Str"",ex);
      return null;
    }
  }
  return null;
}","/** 
 * Query the user for a filename, save the model to that file, and open a new window to view the model.  This method uses java.awt.FileDialog and is usually used under Mac OS X.
 * @param extension If non-null, then the extension that isappended to the file name if there is no extension.
 * @return URL of the saved file if the save succeeds, null if save fails.
 */
private URL _saveAsHelperFileDialog(String extension){
  FileDialog fileDialog=_saveAsFileDialogComponent();
  if (fileDialog == null) {
    return null;
  }
  if (_initialSaveAsFileName != null) {
    fileDialog.setFile(new File(fileDialog.getDirectory(),_initialSaveAsFileName).toString());
  }
  fileDialog.show();
  String selectedFile=fileDialog.getFile();
  if (selectedFile != null) {
    File file=null;
    if (selectedFile.startsWith(""String_Node_Str"")) {
      file=new File(selectedFile.replace(':','/'));
    }
 else {
      file=new File(_directory,selectedFile);
    }
    if (extension != null && file.getName().indexOf(""String_Node_Str"") == -1) {
      file=new File(file.getAbsolutePath() + extension);
    }
    try {
      if (!_confirmFile(null,file)) {
        return null;
      }
      URL newURL=file.toURI().toURL();
      String newKey=newURL.toExternalForm();
      _directory=new File(fileDialog.getDirectory());
      _writeFile(file);
      Tableau newTableau=getConfiguration().openModel(newURL,newURL,newKey);
      newTableau.getFrame().setTitle(StringUtilities.abbreviate(new File(_directory,file.getName()).toString()));
      Effigy effigy=getEffigy();
      if (effigy != null) {
        String id=effigy.identifier.getExpression();
        if (id.equals(""String_Node_Str"")) {
          effigy.setContainer(null);
        }
      }
      dispose();
      return newURL;
    }
 catch (    Exception ex) {
      report(""String_Node_Str"",ex);
      return null;
    }
  }
  return null;
}"
73329,"/** 
 * Query the user for a filename and save the model to that file.
 * @return True if the save succeeds.
 */
private boolean _saveAsFileDialogImplementation(){
  FileDialog fileDialog=_saveAsFileDialogComponent();
  fileDialog.show();
  _directory=new File(fileDialog.getDirectory());
  _file=new File(_directory,fileDialog.getFile());
  if (_file.exists()) {
    String query=""String_Node_Str"" + _file.getName() + ""String_Node_Str"";
    int selected=JOptionPane.showOptionDialog(this,query,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
    if (selected == 1) {
      return false;
    }
  }
  setTitle(StringUtilities.abbreviate(_getName()));
  return _save();
}","/** 
 * Query the user for a filename and save the model to that file.
 * @return True if the save succeeds.
 */
private boolean _saveAsFileDialogImplementation(){
  FileDialog fileDialog=_saveAsFileDialogComponent();
  if (fileDialog == null) {
    return false;
  }
  fileDialog.show();
  _directory=new File(fileDialog.getDirectory());
  _file=new File(_directory,fileDialog.getFile());
  if (_file.exists()) {
    String query=""String_Node_Str"" + _file.getName() + ""String_Node_Str"";
    int selected=JOptionPane.showOptionDialog(this,query,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
    if (selected == 1) {
      return false;
    }
  }
  setTitle(StringUtilities.abbreviate(_getName()));
  return _save();
}"
73330,"/** 
 * Resume the execution of the selected simulation.
 * @param ticket  The ticket reference to the simulation request.
 * @exception IllegalActionException  If the server was unable to resume the execution of thesimulation.
 */
public void resume(Ticket ticket) throws IllegalActionException {
  try {
    if ((ticket == null) || (!_requests.containsKey(ticket))) {
      throw new Exception(""String_Node_Str"" + ticket.getTicketID());
    }
    _requests.get(ticket).getManager().resume();
  }
 catch (  Exception e) {
    _handleException(ticket.getTicketID() + ""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Resume the execution of the selected simulation.
 * @param ticket  The ticket reference to the simulation request.
 * @exception IllegalActionException  If the server was unable to resume the execution of thesimulation.
 */
public void resume(Ticket ticket) throws IllegalActionException {
  try {
    if (ticket == null) {
      throw new IllegalStateException(""String_Node_Str"" + null);
    }
    if (!_requests.containsKey(ticket)) {
      throw new IllegalStateException(""String_Node_Str"" + ticket.getTicketID());
    }
    _requests.get(ticket).getManager().resume();
  }
 catch (  Exception e) {
    _handleException((ticket != null ? ticket.getTicketID() : null) + ""String_Node_Str"" + e.getMessage(),e);
  }
}"
73331,"/** 
 * Start the execution of the selected simulation.
 * @param ticket  The ticket reference to the simulation request.
 * @exception IllegalActionException If the server was unable to start the simulation.
 */
public void start(Ticket ticket) throws IllegalActionException {
  try {
    if ((ticket == null) || (!_requests.containsKey(ticket))) {
      throw new Exception(""String_Node_Str"" + ticket.getTicketID());
    }
    _executor.execute(_requests.get(ticket));
  }
 catch (  Exception e) {
    _handleException(ticket.getTicketID() + ""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Start the execution of the selected simulation.
 * @param ticket  The ticket reference to the simulation request.
 * @exception IllegalActionException If the server was unable to start the simulation.
 */
public void start(Ticket ticket) throws IllegalActionException {
  try {
    if (ticket == null) {
      throw new IllegalStateException(""String_Node_Str"" + null);
    }
    if (!_requests.containsKey(ticket)) {
      throw new IllegalStateException(""String_Node_Str"" + ticket.getTicketID());
    }
    _executor.execute(_requests.get(ticket));
  }
 catch (  Exception e) {
    _handleException((ticket != null ? ticket.getTicketID() : null) + ""String_Node_Str"" + e.getMessage(),e);
  }
}"
73332,"/** 
 * Initialize the server, launch the broker and servlet processes, and wait from simulation requests. The following optional command line switches may be used with their accompanying value: -servlet_path, -servlet_port, -broker_path, and -broker_port. The port numbers must integers, the broker path must be the path to the MQTT broker executable on the local machine, and the servlet path is the virtual directory (including the preceding slash) that the Ptolemy servlet will run at. For example: java -classpath ptserver.PtolemyServer -broker_path /usr/sbin/mosquitto -broker_port 1883
 * @param args  Optional command line arguments.
 * @exception IllegalActionException If the server could not be launched.
 */
public static void main(String[] args) throws IllegalActionException {
  try {
    _instance=new PtolemyServer();
    for (int i=0; i < args.length; i++) {
      if ((args[i].startsWith(""String_Node_Str"")) && (i + 1 < args.length)) {
        if (args[i].toLowerCase() == ""String_Node_Str"") {
          _instance._setServletPath(args[i + 1]);
        }
 else         if (args[i].toLowerCase() == ""String_Node_Str"") {
          _instance._setServletPort(Integer.parseInt(args[i + 1]));
        }
 else         if (args[i].toLowerCase() == ""String_Node_Str"") {
          _instance._setBrokerPath(args[i + 1]);
        }
 else         if (args[i].toLowerCase() == ""String_Node_Str"") {
          _instance._setBrokerPort(Integer.parseInt(args[i + 1]));
        }
      }
    }
    _instance.startup();
  }
 catch (  NumberFormatException e) {
    String message=""String_Node_Str"";
    PtolemyServer.LOGGER.log(Level.SEVERE,message,e);
    throw new IllegalActionException(null,e,message);
  }
catch (  Exception e) {
    String message=""String_Node_Str"";
    PtolemyServer.LOGGER.log(Level.SEVERE,message,e);
    throw new IllegalActionException(null,e,message);
  }
}","/** 
 * Initialize the server, launch the broker and servlet processes, and wait from simulation requests. The following optional command line switches may be used with their accompanying value: -servlet_path, -servlet_port, -broker_path, and -broker_port. The port numbers must integers, the broker path must be the path to the MQTT broker executable on the local machine, and the servlet path is the virtual directory (including the preceding slash) that the Ptolemy servlet will run at. For example: java -classpath ptserver.PtolemyServer -broker_path /usr/sbin/mosquitto -broker_port 1883
 * @param args  Optional command line arguments.
 * @exception IllegalActionException If the server could not be launched.
 */
public static void main(String[] args) throws IllegalActionException {
  try {
    _instance=new PtolemyServer();
    for (int i=0; i < args.length; i++) {
      if ((args[i].startsWith(""String_Node_Str"")) && (i + 1 < args.length)) {
        if (args[i].toLowerCase().equals(""String_Node_Str"")) {
          _instance._setServletPath(args[i + 1]);
        }
 else         if (args[i].toLowerCase().equals(""String_Node_Str"")) {
          _instance._setServletPort(Integer.parseInt(args[i + 1]));
        }
 else         if (args[i].toLowerCase().equals(""String_Node_Str"")) {
          _instance._setBrokerPath(args[i + 1]);
        }
 else         if (args[i].toLowerCase().equals(""String_Node_Str"")) {
          _instance._setBrokerPort(Integer.parseInt(args[i + 1]));
        }
      }
    }
    _instance.startup();
  }
 catch (  NumberFormatException e) {
    String message=""String_Node_Str"";
    PtolemyServer.LOGGER.log(Level.SEVERE,message,e);
    throw new IllegalActionException(null,e,message);
  }
catch (  Exception e) {
    String message=""String_Node_Str"";
    PtolemyServer.LOGGER.log(Level.SEVERE,message,e);
    throw new IllegalActionException(null,e,message);
  }
}"
73333,"/** 
 * Pause the execution of the selected simulation.
 * @param ticket  The ticket reference to the simulation request.
 * @exception IllegalActionException If the server was unable to pause the running simulation.
 */
public void pause(Ticket ticket) throws IllegalActionException {
  try {
    if ((ticket == null) || (!_requests.containsKey(ticket))) {
      throw new Exception(""String_Node_Str"" + ticket.getTicketID());
    }
    _requests.get(ticket).getManager().pause();
  }
 catch (  Exception e) {
    _handleException(ticket.getTicketID() + ""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Pause the execution of the selected simulation.
 * @param ticket  The ticket reference to the simulation request.
 * @exception IllegalActionException If the server was unable to pause the running simulation.
 */
public void pause(Ticket ticket) throws IllegalActionException {
  try {
    if (ticket == null) {
      throw new IllegalStateException(""String_Node_Str"" + null);
    }
    if (!_requests.containsKey(ticket)) {
      throw new IllegalStateException(""String_Node_Str"" + ticket.getTicketID());
    }
    _requests.get(ticket).getManager().pause();
  }
 catch (  Exception e) {
    _handleException((ticket != null ? ticket.getTicketID() : null) + ""String_Node_Str"" + e.getMessage(),e);
  }
}"
73334,"/** 
 * Stop the execution of the selected simulation.
 * @param ticket  The ticket reference to the simulation request.
 * @exception IllegalActionException If the server was unable to stop the simulation.
 */
public void stop(Ticket ticket) throws IllegalActionException {
  try {
    if ((ticket == null) || (!_requests.containsKey(ticket))) {
      throw new Exception(""String_Node_Str"" + ticket.getTicketID());
    }
    _requests.get(ticket).getManager().stop();
  }
 catch (  Exception e) {
    _handleException(ticket.getTicketID() + ""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Stop the execution of the selected simulation.
 * @param ticket  The ticket reference to the simulation request.
 * @exception IllegalActionException If the server was unable to stop the simulation.
 */
public void stop(Ticket ticket) throws IllegalActionException {
  try {
    if (ticket == null) {
      throw new IllegalStateException(""String_Node_Str"" + null);
    }
    if (!_requests.containsKey(ticket)) {
      throw new IllegalStateException(""String_Node_Str"" + ticket.getTicketID());
    }
    _requests.get(ticket).getManager().stop();
  }
 catch (  Exception e) {
    _handleException((ticket != null ? ticket.getTicketID() : null) + ""String_Node_Str"" + e.getMessage(),e);
  }
}"
73335,"/** 
 * Shut down the thread associated with the user's ticket.
 * @param ticket  Ticket reference to the simulation request.
 * @exception IllegalActionException If the server was unable to destroy the simulation thread.
 */
public void close(Ticket ticket) throws IllegalActionException {
  try {
    if ((ticket == null) || (!_requests.containsKey(ticket))) {
      throw new Exception(""String_Node_Str"" + ticket.getTicketID());
    }
    _requests.get(ticket).getManager().finish();
    _requests.remove(ticket);
  }
 catch (  Exception e) {
    _handleException(ticket.getTicketID() + ""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Shut down the thread associated with the user's ticket.
 * @param ticket  Ticket reference to the simulation request.
 * @exception IllegalActionException If the server was unable to destroy the simulation thread.
 */
public void close(Ticket ticket) throws IllegalActionException {
  try {
    if (ticket == null) {
      throw new IllegalStateException(""String_Node_Str"" + null);
    }
    if (!_requests.containsKey(ticket)) {
      throw new IllegalStateException(""String_Node_Str"" + ticket.getTicketID());
    }
    _requests.get(ticket).getManager().finish();
    _requests.remove(ticket);
  }
 catch (  Exception e) {
    _handleException((ticket != null ? ticket.getTicketID() : null) + ""String_Node_Str"" + e.getMessage(),e);
  }
}"
73336,"/** 
 * Open a model with the provided model URL and wait for the user to request the execution of the simulation.
 * @param url  The path to the model file
 * @exception IllegalActionException  If the model fails to load from the provided URL.
 * @return The user's reference to the simulation task
 */
public RemoteModelResponse open(String url) throws IllegalActionException {
  Ticket ticket=null;
  try {
    ticket=Ticket.generateTicket(url);
    while (_requests.contains(ticket)) {
      ticket=Ticket.generateTicket(url);
    }
    SimulationTask simulationTask=new SimulationTask(ticket);
    RemoteModel clientModel=new RemoteModel(null,null,RemoteModelType.CLIENT);
    clientModel.loadModel(new URL(url));
    RemoteModelResponse response=new RemoteModelResponse();
    response.setTicket(ticket);
    response.setModelTypes(clientModel.getResolvedTypes());
    response.setModelXML(clientModel.getTopLevelActor().exportMoML());
    _requests.put(ticket,simulationTask);
    return response;
  }
 catch (  Exception e) {
    _handleException(ticket.getTicketID() + ""String_Node_Str"" + e.getMessage(),e);
  }
  return null;
}","/** 
 * Open a model with the provided model URL and wait for the user to request the execution of the simulation.
 * @param url  The path to the model file
 * @exception IllegalActionException  If the model fails to load from the provided URL.
 * @return The user's reference to the simulation task
 */
public RemoteModelResponse open(String url) throws IllegalActionException {
  Ticket ticket=null;
  try {
    ticket=Ticket.generateTicket(url);
    while (_requests.contains(ticket)) {
      ticket=Ticket.generateTicket(url);
    }
    SimulationTask simulationTask=new SimulationTask(ticket);
    RemoteModel clientModel=new RemoteModel(null,null,RemoteModelType.CLIENT);
    clientModel.loadModel(new URL(url));
    RemoteModelResponse response=new RemoteModelResponse();
    response.setTicket(ticket);
    response.setModelTypes(clientModel.getResolvedTypes());
    response.setModelXML(clientModel.getTopLevelActor().exportMoML());
    _requests.put(ticket,simulationTask);
    return response;
  }
 catch (  Exception e) {
    _handleException((ticket != null ? ticket.getTicketID() : null) + ""String_Node_Str"" + e.getMessage(),e);
  }
  return null;
}"
73337,"@Override public void getToken(Token token){
  if (counter < 10) {
    assertEquals(((IntToken)token).intValue() / 2,counter);
    counter++;
  }
 else {
    isWaiting=false;
  }
}","public void getToken(Token token){
  if (counter < 10) {
    assertEquals(((IntToken)token).intValue() / 2,counter);
    counter++;
  }
 else {
    isWaiting=false;
  }
}"
73338,"/** 
 * Start the server and client
 * @exception Exception If the the setup or shutdown of the simulation fails.
 */
@Test(timeout=2000) public void initialize() throws Exception {
  String servletUrl=String.format(""String_Node_Str"",""String_Node_Str"",CONFIG.getString(""String_Node_Str""),CONFIG.getString(""String_Node_Str""));
  String brokerUrl=String.format(""String_Node_Str"",""String_Node_Str"",CONFIG.getString(""String_Node_Str""));
  PtolemyServer server=PtolemyServer.getInstance();
  IServerManager serverManager=(IServerManager)new HessianProxyFactory().create(IServerManager.class,servletUrl);
  RemoteModelResponse response=serverManager.open(IServerManager.class.getResource(""String_Node_Str"").toString());
  Ticket ticket=response.getTicket();
  RemoteModel model=new RemoteModel(ticket.getTicketID() + ""String_Node_Str"",ticket.getTicketID() + ""String_Node_Str"",RemoteModelType.CLIENT);
  IMqttClient mqttClient=MqttClient.createMqttClient(brokerUrl,null);
  mqttClient.connect(""String_Node_Str"" + new Random().nextInt(1000),true,(short)10);
  model.setMqttClient(mqttClient);
  model.initModel(response.getModelXML(),response.getModelTypes());
  model.setUpInfrastructure();
  CompositeActor topLevelActor=model.getTopLevelActor();
  topLevelActor.setDirector(new PNDirector(topLevelActor,""String_Node_Str""));
  SysOutActor actor=(SysOutActor)topLevelActor.getEntity(""String_Node_Str"");
  actor.setDelegator(new TokenDelegator(){
    @Override public void getToken(    Token token){
      if (counter < 10) {
        assertEquals(((IntToken)token).intValue() / 2,counter);
        counter++;
      }
 else {
        isWaiting=false;
      }
    }
  }
);
  serverManager.start(ticket);
  model.getManager().startRun();
  while (isWaiting) {
  }
  serverManager.stop(ticket);
  model.getManager().stop();
  server.shutdown();
  server=null;
}","/** 
 * Start the server and client
 * @exception Exception If the the setup or shutdown of the simulation fails.
 */
@Test(timeout=2000) public void initialize() throws Exception {
  String servletUrl=String.format(""String_Node_Str"",""String_Node_Str"",CONFIG.getString(""String_Node_Str""),CONFIG.getString(""String_Node_Str""));
  String brokerUrl=String.format(""String_Node_Str"",""String_Node_Str"",CONFIG.getString(""String_Node_Str""));
  PtolemyServer server=PtolemyServer.getInstance();
  IServerManager serverManager=(IServerManager)new HessianProxyFactory().create(IServerManager.class,servletUrl);
  RemoteModelResponse response=serverManager.open(IServerManager.class.getResource(""String_Node_Str"").toString());
  Ticket ticket=response.getTicket();
  RemoteModel model=new RemoteModel(ticket.getTicketID() + ""String_Node_Str"",ticket.getTicketID() + ""String_Node_Str"",RemoteModelType.CLIENT);
  IMqttClient mqttClient=MqttClient.createMqttClient(brokerUrl,null);
  mqttClient.connect(""String_Node_Str"" + new Random().nextInt(1000),true,(short)10);
  model.setMqttClient(mqttClient);
  model.initModel(response.getModelXML(),response.getModelTypes());
  model.setUpInfrastructure();
  CompositeActor topLevelActor=model.getTopLevelActor();
  topLevelActor.setDirector(new PNDirector(topLevelActor,""String_Node_Str""));
  SysOutActor actor=(SysOutActor)topLevelActor.getEntity(""String_Node_Str"");
  actor.setDelegator(new TokenDelegator(){
    public void getToken(    Token token){
      if (counter < 10) {
        assertEquals(((IntToken)token).intValue() / 2,counter);
        counter++;
      }
 else {
        isWaiting=false;
      }
    }
  }
);
  serverManager.start(ticket);
  model.getManager().startRun();
  while (isWaiting) {
  }
  serverManager.stop(ticket);
  model.getManager().stop();
  server.shutdown();
  server=null;
}"
73339,"/** 
 * Set the token publisher that would be used to send AttributeChange tokens.
 * @param tokenPublisher the token publisher used to send attribute change messages.
 * @see #getTokenPublisher()
 */
public void setTokenPublisher(TokenPublisher tokenPublisher){
  tokenPublisher=tokenPublisher;
}","/** 
 * Set the token publisher that would be used to send AttributeChange tokens.
 * @param tokenPublisher the token publisher used to send attribute change messages.
 * @see #getTokenPublisher()
 */
public void setTokenPublisher(TokenPublisher tokenPublisher){
  _tokenPublisher=tokenPublisher;
}"
73340,"/** 
 * Return TokenPublisher that would be used to publish AttributeChange tokens produced by this actor on value change.
 * @return TokenPublisher the token publisher
 * @see #setTokenPublisher(TokenPublisher)
 */
public TokenPublisher getTokenPublisher(){
  return tokenPublisher;
}","/** 
 * Return TokenPublisher that would be used to publish AttributeChange tokens produced by this actor on value change.
 * @return TokenPublisher the token publisher
 * @see #setTokenPublisher(TokenPublisher)
 */
public TokenPublisher getTokenPublisher(){
  return _tokenPublisher;
}"
73341,"/** 
 * Open a model with the provided model URL and wait for the user to request the execution of the simulation.
 * @param url The path to the model file
 * @exception IllegalActionException If the model fails to loadfrom the provided URL.
 * @return The user's reference to the simulation task
 */
public Ticket open(String url) throws IllegalActionException {
  Ticket ticket=null;
  try {
    ticket=Ticket.generateTicket(url);
    while (_requests.contains(ticket)) {
      ticket=Ticket.generateTicket(url);
    }
    _requests.put(ticket,new SimulationTask(ticket));
  }
 catch (  Exception e) {
    _handleException(ticket.getTicketID() + ""String_Node_Str"" + e.getMessage(),e);
  }
  return ticket;
}","/** 
 * Open a model with the provided model URL and wait for the user to request the execution of the simulation.
 * @param url The path to the model file
 * @exception IllegalActionException If the model fails to loadfrom the provided URL.
 * @return The user's reference to the simulation task
 */
public RemoteModelResponse open(String url) throws IllegalActionException {
  Ticket ticket=null;
  try {
    ticket=Ticket.generateTicket(url);
    while (_requests.contains(ticket)) {
      ticket=Ticket.generateTicket(url);
    }
    SimulationTask simulationTask=new SimulationTask(ticket);
    RemoteModel clientModel=new RemoteModel(null,null,RemoteModelType.CLIENT);
    clientModel.loadModel(new URL(url));
    RemoteModelResponse response=new RemoteModelResponse();
    response.setTicket(ticket);
    response.setPortTypes(clientModel.getResolvedTypes());
    response.setModelXML(clientModel.getTopLevelActor().exportMoML());
    _requests.put(ticket,simulationTask);
    return response;
  }
 catch (  Exception e) {
    _handleException(ticket.getTicketID() + ""String_Node_Str"" + e.getMessage(),e);
  }
  return null;
}"
73342,"/** 
 * Create an instance of the simulation task to be run by the Ptolemy server application.
 * @param ticket Reference to the simulation request.
 * @exception Exception If the simulation encounters a problem settingthe director or getting workspace access.
 */
public SimulationTask(Ticket ticket) throws Exception {
  _owner=PtolemyServer.getInstance();
  _ticket=ticket;
  _remoteModel=new RemoteModel(_ticket.getTicketID() + ""String_Node_Str"",_ticket.getTicketID() + ""String_Node_Str"",RemoteModelType.SERVER);
  IMqttClient mqttClient=MqttClient.createMqttClient(""String_Node_Str"" + Integer.toString(_owner.getBrokerPort()),null);
  mqttClient.connect(_ticket.getTicketID(),true,(short)10);
  if (mqttClient != null) {
    _remoteModel.setMqttClient(mqttClient);
  }
  _remoteModel.loadModel(new URL(_ticket.getUrl()));
}","/** 
 * Create an instance of the simulation task to be run by the Ptolemy server application.
 * @param ticket Reference to the simulation request.
 * @exception Exception If the simulation encounters a problem settingthe director or getting workspace access.
 */
public SimulationTask(Ticket ticket) throws Exception {
  _owner=PtolemyServer.getInstance();
  _ticket=ticket;
  _remoteModel=new RemoteModel(_ticket.getTicketID() + ""String_Node_Str"",_ticket.getTicketID() + ""String_Node_Str"",RemoteModelType.SERVER);
  IMqttClient mqttClient=MqttClient.createMqttClient(""String_Node_Str"" + Integer.toString(_owner.getBrokerPort()),null);
  mqttClient.connect(_ticket.getTicketID(),true,(short)10);
  if (mqttClient != null) {
    _remoteModel.setMqttClient(mqttClient);
  }
  _remoteModel.loadModel(new URL(_ticket.getUrl()));
  _remoteModel.setUpInfrastructure();
}"
73343,"/** 
 * Parent constructor that replaces either targetEntity if replaceTargetEntity is true or otherwise all entities connected to it with a proxy instance (RemoteSink or RemoteSource). The proxy actor is named the same as the original with addition of ""_remote"" suffix. All links of the targetEntity are removed. The proxy actor dynamically adds ports that were present in the targetEntity (with the same port name) or  and connects them to the targetEntity's relations.
 * @param container The container
 * @param targetEntity the targetEntity to be replaced by a proxy
 * @param replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
public RemoteActor(CompositeEntity container,ComponentEntity targetEntity,boolean replaceTargetEntity) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  super(container,targetEntity.getName() + ""String_Node_Str"");
  if (replaceTargetEntity) {
    replaceTargetEntity(targetEntity);
  }
 else {
    replaceConnectingEntities(targetEntity);
  }
  setTargetEntityName(targetEntity.getName());
}","/** 
 * Parent constructor that replaces either targetEntity if replaceTargetEntity is true or otherwise all entities connected to it with a proxy instance (RemoteSink or RemoteSource). The proxy actor is named the same as the original with addition of ""_remote"" suffix. All links of the targetEntity are removed. The proxy actor dynamically adds ports that were present in the targetEntity (with the same port name) or  and connects them to the targetEntity's relations.
 * @param container The container
 * @param targetEntity the targetEntity to be replaced by a proxy
 * @param replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
public RemoteActor(CompositeEntity container,ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,Type> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  this(container,targetEntity.getName() + ""String_Node_Str"");
  setTargetEntityName(targetEntity.getFullName());
  _targetEntityName.setExpression(getTargetEntityName());
  if (replaceTargetEntity) {
    replaceTargetEntity(targetEntity,portTypes);
  }
 else {
    replaceConnectingEntities(targetEntity,portTypes);
  }
}"
73344,"/** 
 * Replace all entities connected to the targetEntity with one RemoteSource or RemoteSink. Essentially instead of all entities connected to it, RemoteSink or RemoteSource would be used that would redirect all links from those entities to itself and connect them to dynamically added ports derived from the connected entities. This configuration would allow running of sources and sinks disconnected from the actors in between remotely by passing respective input and output via CommunicationToken.
 * @param targetEntity the entity to which actors that are replaced are connected
 * @exception CloneNotSupportedException
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
private void replaceConnectingEntities(ComponentEntity targetEntity) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      List<Port> linkedPortList=relation.linkedPortList(port);
      IOPort remotePort=null;
      for (      Port connectingPort : linkedPortList) {
        if (connectingPort instanceof IOPort && isValidConnectingPort((IOPort)connectingPort)) {
          remotePort=clonePort((IOPort)connectingPort);
          remotePort.setName(port.getName());
          remotePort.setContainer(this);
          break;
        }
      }
      relation.unlinkAll();
      if (remotePort != null) {
        port.link(relation);
        remotePort.link(relation);
      }
    }
  }
}","/** 
 * Replace all entities connected to the targetEntity with one RemoteSource or RemoteSink. Essentially instead of all entities connected to it, RemoteSink or RemoteSource would be used that would redirect all links from those entities to itself and connect them to dynamically added ports derived from the connected entities. This configuration would allow running of sources and sinks disconnected from the actors in between remotely by passing respective input and output via CommunicationToken.
 * @param targetEntity the entity to which actors that are replaced are connected
 * @param portTypes The map of ports and their resolved types
 * @exception CloneNotSupportedException
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
private void replaceConnectingEntities(ComponentEntity targetEntity,HashMap<String,Type> portTypes) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      List<Port> linkedPortList=relation.linkedPortList(port);
      IOPort remotePort=null;
      for (      Port connectingPort : linkedPortList) {
        if (connectingPort instanceof IOPort && isValidConnectingPort((IOPort)connectingPort)) {
          remotePort=(IOPort)connectingPort.clone(port.workspace());
          remotePort.setPersistent(true);
          remotePort.setName(port.getName());
          remotePort.setContainer(this);
          if (remotePort instanceof TypedIOPort) {
            Type type=portTypes.get(connectingPort.getFullName());
            ((TypedIOPort)remotePort).setTypeEquals(type);
            StringAttribute targetPortName=new StringAttribute(remotePort,""String_Node_Str"");
            targetPortName.setExpression(connectingPort.getFullName());
          }
          break;
        }
      }
      relation.unlinkAll();
      if (remotePort != null) {
        port.link(relation);
        remotePort.link(relation);
      }
    }
  }
}"
73345,"/** 
 * Return the name of the target entity.
 * @return the targetEntityName
 * @see #setTargetActorName(String)
 */
public String getTargetEntityName(){
  return _targetEntityName;
}","/** 
 * Return the full name of the target entity.
 * @return the targetEntityName
 * @see #setTargetActorName(String)
 */
public String getTargetEntityName(){
  return _targetEntityName.getExpression();
}"
73346,"/** 
 * Replace the targetEntity with the proxy. This configuration would allow execution of the model where sinks or sources run remotely and proxies execute instead of them and pass information to/from them.
 * @param targetEntity The target entity that is replaced with the proxy
 * @exception CloneNotSupportedException
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
private void replaceTargetEntity(ComponentEntity targetEntity) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  ArrayList<Attribute> attributes=new ArrayList<Attribute>(targetEntity.attributeList());
  for (  Attribute attribute : attributes) {
    attribute.setContainer(this);
  }
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    IOPort remotePort=clonePort(port);
    remotePort.setName(port.getName());
    remotePort.setContainer(this);
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      port.unlink(relation);
      remotePort.link(relation);
    }
    port.unlinkAll();
  }
  targetEntity.setContainer(null);
}","/** 
 * Replace the targetEntity with the proxy. This configuration would allow execution of the model where sinks or sources run remotely and proxies execute instead of them and pass information to/from them.
 * @param targetEntity The target entity that is replaced with the proxy
 * @param portTypes The map of ports and their resolved types
 * @exception CloneNotSupportedException
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
private void replaceTargetEntity(ComponentEntity targetEntity,HashMap<String,Type> portTypes) throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  ArrayList<Attribute> attributes=new ArrayList<Attribute>(targetEntity.attributeList());
  for (  Attribute attribute : attributes) {
    attribute.setContainer(this);
  }
  for (  Object portObject : targetEntity.portList()) {
    if (!(portObject instanceof IOPort)) {
      continue;
    }
    IOPort port=(IOPort)portObject;
    IOPort remotePort=(IOPort)port.clone(port.workspace());
    remotePort.setName(port.getName());
    remotePort.setContainer(this);
    remotePort.setPersistent(true);
    if (remotePort instanceof TypedIOPort) {
      Type type=portTypes.get(port.getFullName());
      ((TypedIOPort)remotePort).setTypeEquals(type);
      StringAttribute targetPortName=new StringAttribute(remotePort,""String_Node_Str"");
      targetPortName.setExpression(port.getFullName());
    }
    for (    Object relationObject : port.linkedRelationList()) {
      Relation relation=(Relation)relationObject;
      port.unlink(relation);
      remotePort.link(relation);
    }
    port.unlinkAll();
  }
  targetEntity.setContainer(null);
}"
73347,"/** 
 * Set the name of the target entity.
 * @param targetEntityName the target entity name
 * @see #getTargetActorName()
 */
public void setTargetEntityName(String targetEntityName){
  this._targetEntityName=targetEntityName;
}","/** 
 * Set the full name of the target entity.
 * @param targetEntityName the target entity name
 * @throws IllegalActionException If the change is not acceptable to the container.
 * @see #getTargetActorName()
 */
public void setTargetEntityName(String targetEntityName) throws IllegalActionException {
  _targetEntityName.setExpression(targetEntityName);
}"
73348,"/** 
 * Replace the targetSink with the RemoteSink instance.
 * @see RemoteActor
 * @param container The container
 * @param targetSink The target sink
 * @param replaceTargetEntity replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
public RemoteSink(CompositeEntity container,ComponentEntity targetSink,boolean replaceTargetEntity) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  super(container,targetSink,replaceTargetEntity);
}","/** 
 * Replace the targetSink with the RemoteSink instance.
 * @see RemoteActor
 * @param container The container
 * @param targetSink The target sink
 * @param replaceTargetEntity replaceTargetEntity true to replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
public RemoteSink(CompositeEntity container,ComponentEntity targetSink,boolean replaceTargetEntity,HashMap<String,Type> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  super(container,targetSink,replaceTargetEntity,portTypes);
}"
73349,"/** 
 * Return the MoML string that will change the boolean value of the isAcceptable parameter in a Concept to its opposite value (false to true, and true to false).
 * @param isAcceptableParameter The isAcceptable parameter.
 * @return The MoML string that will execute the change.
 * @throws IllegalActionException Thrown if there is a problem gettingthe current value of the isAcceptable parameter.
 */
private String _getToggleAcceptabilityMoML(Parameter isAcceptableParameter) throws IllegalActionException {
  BooleanToken value=(BooleanToken)isAcceptableParameter.getToken();
  value=value.not();
  return new String(""String_Node_Str"" + isAcceptableParameter.getName() + ""String_Node_Str""+ value.toString()+ ""String_Node_Str"");
}","/** 
 * Return the MoML string that will change the boolean value of the isAcceptable parameter in a Concept to its opposite value (false to true, and true to false).
 * @param isAcceptableParameter The isAcceptable parameter.
 * @return The MoML string that will execute the change.
 * @throws IllegalActionException Thrown if there is a problem gettingthe current value of the isAcceptable parameter.
 */
private String _getToggleAcceptabilityMoML(Parameter isAcceptableParameter) throws IllegalActionException {
  BooleanToken value=(BooleanToken)isAcceptableParameter.getToken();
  value=value.not();
  return ""String_Node_Str"" + isAcceptableParameter.getName() + ""String_Node_Str""+ value.toString()+ ""String_Node_Str"";
}"
73350,"/** 
 * Return a MoML String that will delete the given node from the Ontology model. This assumes that the context is the container of the concept.
 * @param node The node to be deleted.
 * @return A valid MoML string.
 */
public String getDeleteNodeMoML(Object node){
  NamedObj deleteObj=((Locatable)node).getContainer();
  NamedObj container=deleteObj.getContainer();
  return new String(""String_Node_Str"" + deleteObj.getName(container) + ""String_Node_Str"");
}","/** 
 * Return a MoML String that will delete the given node from the Ontology model. This assumes that the context is the container of the concept.
 * @param node The node to be deleted.
 * @return A valid MoML string.
 */
public String getDeleteNodeMoML(Object node){
  NamedObj deleteObj=((Locatable)node).getContainer();
  NamedObj container=deleteObj.getContainer();
  return ""String_Node_Str"" + deleteObj.getName(container) + ""String_Node_Str"";
}"
73351,"/** 
 * Return a MoML String that will delete the given node from the ontology solver model. This assumes that the context is the container of the ontology.
 * @param node The node to be deleted.
 * @return A valid MoML string.
 */
public String getDeleteNodeMoML(Object node){
  NamedObj deleteObj=((Locatable)node).getContainer();
  NamedObj container=deleteObj.getContainer();
  return new String(""String_Node_Str"" + deleteObj.getName(container) + ""String_Node_Str"");
}","/** 
 * Return a MoML String that will delete the given node from the ontology solver model. This assumes that the context is the container of the ontology.
 * @param node The node to be deleted.
 * @return A valid MoML string.
 */
public String getDeleteNodeMoML(Object node){
  NamedObj deleteObj=((Locatable)node).getContainer();
  NamedObj container=deleteObj.getContainer();
  return ""String_Node_Str"" + deleteObj.getName(container) + ""String_Node_Str"";
}"
73352,"/** 
 * For all deeply contained actors, if annotateModelDelay is true, and if the actor has a dependency that is not equal to the OTimesIdentity or OPlusIdentity, then this actor is annotated with a certain color. This process is repeated recursively. If annotateModelDelay is false, then instead of highlighting actors, the highlighting is cleared.
 * @param compositeActor actor to highlight model delays.
 * @param highlightModelDelay Whether to highlight model delay.
 * @exception IllegalActionException If causality interface cannotbe evaluated, dependency cannot be evaluated, or finite dependent ports cannot be evaluated.
 */
private void _highlightModelDelays(CompositeActor compositeActor,boolean highlightModelDelay) throws IllegalActionException {
  for (  Actor actor : (List<Actor>)(compositeActor.deepEntityList())) {
    if (!highlightModelDelay) {
      _clearHighlight(actor,true);
    }
    boolean annotateThisActor=false;
    CausalityInterface causalityInterface=actor.getCausalityInterface();
    for (    IOPort input : (List<IOPort>)actor.inputPortList()) {
      for (      IOPort output : (Collection<IOPort>)_finiteDependentPorts(input)) {
        Dependency dependency=causalityInterface.getDependency(input,output);
        if (!dependency.equals(dependency.oTimesIdentity()) && !dependency.equals(dependency.oPlusIdentity())) {
          annotateThisActor=true;
          break;
        }
      }
      if (annotateThisActor) {
        break;
      }
    }
    if (annotateThisActor && highlightModelDelay) {
      _highlightActor(actor,""String_Node_Str"",true);
    }
    if (actor instanceof CompositeActor) {
      _highlightModelDelays((CompositeActor)actor,highlightModelDelay);
    }
  }
}","/** 
 * For all deeply contained actors, if annotateModelDelay is true, and if the actor has a dependency that is not equal to the OTimesIdentity or OPlusIdentity, then this actor is annotated with a certain color. This process is repeated recursively. If annotateModelDelay is false, then instead of highlighting actors, the highlighting is cleared.
 * @param compositeActor actor to highlight model delays.
 * @param highlightModelDelay Whether to highlight model delay.
 * @exception IllegalActionException If causality interface cannotbe evaluated, dependency cannot be evaluated, or finite dependent ports cannot be evaluated.
 */
private void _highlightModelDelays(CompositeActor compositeActor,boolean highlightModelDelay) throws IllegalActionException {
  for (  Actor actor : (List<Actor>)(compositeActor.deepEntityList())) {
    boolean annotateThisActor=false;
    CausalityInterface causalityInterface=actor.getCausalityInterface();
    for (    IOPort input : (List<IOPort>)actor.inputPortList()) {
      for (      IOPort output : (Collection<IOPort>)_finiteDependentPorts(input)) {
        Dependency dependency=causalityInterface.getDependency(input,output);
        if (!dependency.equals(dependency.oTimesIdentity()) && !dependency.equals(dependency.oPlusIdentity())) {
          annotateThisActor=true;
          break;
        }
      }
      if (annotateThisActor) {
        break;
      }
 else {
        _clearHighlight(actor,true);
      }
    }
    if (annotateThisActor && highlightModelDelay) {
      _highlightActor(actor,""String_Node_Str"",true);
    }
    if (actor instanceof CompositeActor) {
      _highlightModelDelays((CompositeActor)actor,highlightModelDelay);
    }
  }
}"
73353,"/** 
 * Propagate existence of this object to the specified object. This overrides the base class to set the container.
 * @param container Object to contain the new object.
 * @exception IllegalActionException If the objectcannot be cloned.
 * @return A new object of the same class and nameas this one.
 */
protected NamedObj _propagateExistence(NamedObj container) throws IllegalActionException {
  try {
    ComponentEntity newObject=(ComponentEntity)super._propagateExistence(container);
    newObject.setContainer((CompositeEntity)container);
    return newObject;
  }
 catch (  NameDuplicationException e) {
    throw new InternalErrorException(e);
  }
}","/** 
 * Propagate existence of this object to the specified object. This overrides the base class to set the container.
 * @param container Object to contain the new object.
 * @exception IllegalActionException If the objectcannot be cloned.
 * @return A new object of the same class and nameas this one.
 */
protected NamedObj _propagateExistence(NamedObj container) throws IllegalActionException {
  try {
    ComponentEntity newObject=(ComponentEntity)super._propagateExistence(container);
    if (container instanceof CompositeEntity) {
      throw new InternalErrorException(container + ""String_Node_Str"");
    }
 else {
      newObject.setContainer((CompositeEntity)container);
    }
    return newObject;
  }
 catch (  NameDuplicationException e) {
    throw new InternalErrorException(e);
  }
}"
73354,"/** 
 * Propagate existence of this object to the specified object. This overrides the base class to set the container.
 * @param container Object to contain the new object.
 * @exception IllegalActionException If the objectcannot be cloned.
 * @return A new object of the same class and nameas this one.
 */
protected NamedObj _propagateExistence(NamedObj container) throws IllegalActionException {
  try {
    ComponentRelation newObject=(ComponentRelation)super._propagateExistence(container);
    newObject.setContainer((CompositeEntity)container);
    return newObject;
  }
 catch (  NameDuplicationException e) {
    throw new InternalErrorException(e);
  }
}","/** 
 * Propagate existence of this object to the specified object. This overrides the base class to set the container.
 * @param container Object to contain the new object.
 * @exception IllegalActionException If the objectcannot be cloned.
 * @return A new object of the same class and nameas this one.
 */
protected NamedObj _propagateExistence(NamedObj container) throws IllegalActionException {
  try {
    ComponentRelation newObject=(ComponentRelation)super._propagateExistence(container);
    if (container instanceof CompositeEntity) {
      throw new InternalErrorException(container + ""String_Node_Str"");
    }
 else {
      newObject.setContainer((CompositeEntity)container);
    }
    return newObject;
  }
 catch (  NameDuplicationException e) {
    throw new InternalErrorException(e);
  }
}"
73355,"/** 
 * Return a sequence of MoML link attributes that describe any link between objects (ports, entities, and relations) that are present in the <i>filter</i> argument.  Both ends of the link must be present in <i>filter</i> for MoML to be generated for that link.  The <i>filter</i> argument normally contains ports, relations, and entities that are contained by this composite entity. If it contains an entity, then that is equivalent to containing all the ports contained by that entity.  It is recommended to use a collection class (such as HashSet) for which the contains() method is efficient. <p> If the filter argument is null, then return all the links that this composite is responsible for (i.e., apply no filtering).  If the argument is an empty collection, then return none of the links.  The links that this entity is responsible for are the inside links of its ports, and links on ports contained by contained entities. <p> If any link is found where both ends of the link are inherited objects, then that link is not exported. It is assumed that the base class will export that link.  For this purpose, a port of a contained entity is deemed to be an inherited object if it is itself a class element <i>and</i> its container is an inherited object.
 * @param depth The depth below the MoML export in the hierarchy.
 * @param filter A collection of ports, parameters, and entities, ornull to apply no filtering.
 * @return A string that describes the links present in the<i>filter</i>.
 * @exception IOException If an I/O error occurs.
 */
public String exportLinks(int depth,Collection filter) throws IOException {
  StringBuffer result=new StringBuffer();
  Iterator ports=portList().iterator();
  while (ports.hasNext()) {
    ComponentPort port=(ComponentPort)ports.next();
    if (port != null && !port.isPersistent()) {
      continue;
    }
    Iterator relations=port.insideRelationList().iterator();
    int index=-1;
    boolean useIndex=false;
    while (relations.hasNext()) {
      index++;
      ComponentRelation relation=(ComponentRelation)relations.next();
      if (relation != null && !relation.isPersistent()) {
        continue;
      }
      if (relation == null) {
        useIndex=true;
        continue;
      }
      if (_commonImplier(relation,depth,port,depth)) {
        continue;
      }
      if ((filter == null) || (filter.contains(relation) && (filter.contains(port) || filter.contains(port.getContainer())))) {
        if (relation != null && !relation.isPersistent()) {
          continue;
        }
        String relationName;
        if (relation.getContainer() == this) {
          relationName=relation.getName();
        }
 else {
          if (deepContains(relation)) {
            relationName=relation.getName(this);
          }
 else {
            _recordLevelCrossingLink(port,relation,null,index);
            continue;
          }
        }
        String escapedPortName=StringUtilities.escapeForXML(port.getName());
        String escapedRelationName=StringUtilities.escapeForXML(relationName);
        if (useIndex) {
          useIndex=false;
          result.append(_getIndentPrefix(depth) + ""String_Node_Str"" + escapedPortName+ ""String_Node_Str""+ index+ ""String_Node_Str""+ escapedRelationName+ ""String_Node_Str"");
        }
 else {
          result.append(_getIndentPrefix(depth) + ""String_Node_Str"" + escapedPortName+ ""String_Node_Str""+ escapedRelationName+ ""String_Node_Str"");
        }
      }
    }
  }
  Iterator entities=entityList().iterator();
  while (entities.hasNext()) {
    ComponentEntity entity=(ComponentEntity)entities.next();
    if (entity != null && !entity.isPersistent()) {
      continue;
    }
    ports=entity.portList().iterator();
    while (ports.hasNext()) {
      ComponentPort port=(ComponentPort)ports.next();
      if (port != null && !port.isPersistent()) {
        continue;
      }
      Iterator relations=port.linkedRelationList().iterator();
      int index=-1;
      boolean useIndex=false;
      while (relations.hasNext()) {
        index++;
        ComponentRelation relation=(ComponentRelation)relations.next();
        if (relation != null && !relation.isPersistent()) {
          continue;
        }
        if (relation == null) {
          useIndex=true;
          continue;
        }
        if (port.getDerivedLevel() <= (depth + 1) && _commonImplier(relation,depth,port.getContainer(),depth)) {
          continue;
        }
        if ((filter == null) || (filter.contains(relation) && (filter.contains(port) || filter.contains(port.getContainer())))) {
          if (relation != null && !relation.isPersistent()) {
            continue;
          }
          String relationName;
          if (relation.getContainer() == this) {
            relationName=relation.getName();
          }
 else {
            if (deepContains(relation)) {
              relationName=relation.getName(this);
            }
 else {
              _recordLevelCrossingLink(port,relation,null,index);
              continue;
            }
          }
          String escapedName=StringUtilities.escapeForXML(entity.getName());
          String escapedPortName=StringUtilities.escapeForXML(port.getName());
          String escapedRelationName=StringUtilities.escapeForXML(relationName);
          if (useIndex) {
            useIndex=false;
            result.append(_getIndentPrefix(depth) + ""String_Node_Str"" + escapedName+ ""String_Node_Str""+ escapedPortName+ ""String_Node_Str""+ index+ ""String_Node_Str""+ escapedRelationName+ ""String_Node_Str"");
          }
 else {
            result.append(_getIndentPrefix(depth) + ""String_Node_Str"" + escapedName+ ""String_Node_Str""+ escapedPortName+ ""String_Node_Str""+ escapedRelationName+ ""String_Node_Str"");
          }
        }
      }
    }
  }
  Set visitedRelations=new HashSet();
  Iterator relations=relationList().iterator();
  while (relations.hasNext()) {
    ComponentRelation relation=(ComponentRelation)relations.next();
    visitedRelations.add(relation);
    if (relation != null && !relation.isPersistent()) {
      continue;
    }
    Iterator portsAndRelations=relation.linkedObjectsList().iterator();
    while (portsAndRelations.hasNext()) {
      Object portOrRelation=portsAndRelations.next();
      if (portOrRelation instanceof Relation) {
        Relation otherRelation=(Relation)portOrRelation;
        if (otherRelation != null && !otherRelation.isPersistent()) {
          continue;
        }
        if (visitedRelations.contains(otherRelation)) {
          continue;
        }
        if (_commonImplier(relation,depth,otherRelation,depth)) {
          continue;
        }
        if ((filter == null) || (filter.contains(relation) && filter.contains(otherRelation))) {
          String relationName;
          if (relation.getContainer() == this) {
            relationName=relation.getName();
          }
 else {
            if (deepContains(relation)) {
              relationName=relation.getName(this);
            }
 else {
              _recordLevelCrossingLink(null,relation,otherRelation,0);
              continue;
            }
          }
          String otherRelationName;
          if (otherRelation.getContainer() == this) {
            otherRelationName=otherRelation.getName();
          }
 else {
            _recordLevelCrossingLink(null,relation,otherRelation,0);
            continue;
          }
          result.append(_getIndentPrefix(depth) + ""String_Node_Str"" + relationName+ ""String_Node_Str""+ otherRelationName+ ""String_Node_Str"");
        }
      }
    }
  }
  return result.toString();
}","/** 
 * Return a sequence of MoML link attributes that describe any link between objects (ports, entities, and relations) that are present in the <i>filter</i> argument.  Both ends of the link must be present in <i>filter</i> for MoML to be generated for that link.  The <i>filter</i> argument normally contains ports, relations, and entities that are contained by this composite entity. If it contains an entity, then that is equivalent to containing all the ports contained by that entity.  It is recommended to use a collection class (such as HashSet) for which the contains() method is efficient. <p> If the filter argument is null, then return all the links that this composite is responsible for (i.e., apply no filtering).  If the argument is an empty collection, then return none of the links.  The links that this entity is responsible for are the inside links of its ports, and links on ports contained by contained entities. <p> If any link is found where both ends of the link are inherited objects, then that link is not exported. It is assumed that the base class will export that link.  For this purpose, a port of a contained entity is deemed to be an inherited object if it is itself a class element <i>and</i> its container is an inherited object.
 * @param depth The depth below the MoML export in the hierarchy.
 * @param filter A collection of ports, parameters, and entities, ornull to apply no filtering.
 * @return A string that describes the links present in the<i>filter</i>.
 * @exception IOException If an I/O error occurs.
 */
public String exportLinks(int depth,Collection filter) throws IOException {
  StringBuffer result=new StringBuffer();
  Iterator ports=portList().iterator();
  while (ports.hasNext()) {
    ComponentPort port=(ComponentPort)ports.next();
    if (port == null || !port.isPersistent()) {
      continue;
    }
    Iterator relations=port.insideRelationList().iterator();
    int index=-1;
    boolean useIndex=false;
    while (relations.hasNext()) {
      index++;
      ComponentRelation relation=(ComponentRelation)relations.next();
      if (relation != null && !relation.isPersistent()) {
        continue;
      }
      if (relation == null) {
        useIndex=true;
        continue;
      }
      if (_commonImplier(relation,depth,port,depth)) {
        continue;
      }
      if ((filter == null) || (filter.contains(relation) && (filter.contains(port) || filter.contains(port.getContainer())))) {
        if (relation != null && !relation.isPersistent()) {
          continue;
        }
        String relationName;
        if (relation.getContainer() == this) {
          relationName=relation.getName();
        }
 else {
          if (deepContains(relation)) {
            relationName=relation.getName(this);
          }
 else {
            _recordLevelCrossingLink(port,relation,null,index);
            continue;
          }
        }
        String escapedPortName=StringUtilities.escapeForXML(port.getName());
        String escapedRelationName=StringUtilities.escapeForXML(relationName);
        if (useIndex) {
          useIndex=false;
          result.append(_getIndentPrefix(depth) + ""String_Node_Str"" + escapedPortName+ ""String_Node_Str""+ index+ ""String_Node_Str""+ escapedRelationName+ ""String_Node_Str"");
        }
 else {
          result.append(_getIndentPrefix(depth) + ""String_Node_Str"" + escapedPortName+ ""String_Node_Str""+ escapedRelationName+ ""String_Node_Str"");
        }
      }
    }
  }
  Iterator entities=entityList().iterator();
  while (entities.hasNext()) {
    ComponentEntity entity=(ComponentEntity)entities.next();
    if (entity == null || !entity.isPersistent()) {
      continue;
    }
    ports=entity.portList().iterator();
    while (ports.hasNext()) {
      ComponentPort port=(ComponentPort)ports.next();
      if (port == null || !port.isPersistent()) {
        continue;
      }
      Iterator relations=port.linkedRelationList().iterator();
      int index=-1;
      boolean useIndex=false;
      while (relations.hasNext()) {
        index++;
        ComponentRelation relation=(ComponentRelation)relations.next();
        if (relation != null && !relation.isPersistent()) {
          continue;
        }
        if (relation == null) {
          useIndex=true;
          continue;
        }
        if (port.getDerivedLevel() <= (depth + 1) && _commonImplier(relation,depth,port.getContainer(),depth)) {
          continue;
        }
        if ((filter == null) || (filter.contains(relation) && (filter.contains(port) || filter.contains(port.getContainer())))) {
          if (relation == null || !relation.isPersistent()) {
            continue;
          }
          String relationName;
          if (relation.getContainer() == this) {
            relationName=relation.getName();
          }
 else {
            if (deepContains(relation)) {
              relationName=relation.getName(this);
            }
 else {
              _recordLevelCrossingLink(port,relation,null,index);
              continue;
            }
          }
          String escapedName=StringUtilities.escapeForXML(entity.getName());
          String escapedPortName=StringUtilities.escapeForXML(port.getName());
          String escapedRelationName=StringUtilities.escapeForXML(relationName);
          if (useIndex) {
            useIndex=false;
            result.append(_getIndentPrefix(depth) + ""String_Node_Str"" + escapedName+ ""String_Node_Str""+ escapedPortName+ ""String_Node_Str""+ index+ ""String_Node_Str""+ escapedRelationName+ ""String_Node_Str"");
          }
 else {
            result.append(_getIndentPrefix(depth) + ""String_Node_Str"" + escapedName+ ""String_Node_Str""+ escapedPortName+ ""String_Node_Str""+ escapedRelationName+ ""String_Node_Str"");
          }
        }
      }
    }
  }
  Set visitedRelations=new HashSet();
  Iterator relations=relationList().iterator();
  while (relations.hasNext()) {
    ComponentRelation relation=(ComponentRelation)relations.next();
    visitedRelations.add(relation);
    if (relation == null || !relation.isPersistent()) {
      continue;
    }
    Iterator portsAndRelations=relation.linkedObjectsList().iterator();
    while (portsAndRelations.hasNext()) {
      Object portOrRelation=portsAndRelations.next();
      if (portOrRelation instanceof Relation) {
        Relation otherRelation=(Relation)portOrRelation;
        if (otherRelation == null || !otherRelation.isPersistent()) {
          continue;
        }
        if (visitedRelations.contains(otherRelation)) {
          continue;
        }
        if (_commonImplier(relation,depth,otherRelation,depth)) {
          continue;
        }
        if ((filter == null) || (filter.contains(relation) && filter.contains(otherRelation))) {
          String relationName;
          if (relation.getContainer() == this) {
            relationName=relation.getName();
          }
 else {
            if (deepContains(relation)) {
              relationName=relation.getName(this);
            }
 else {
              _recordLevelCrossingLink(null,relation,otherRelation,0);
              continue;
            }
          }
          String otherRelationName;
          if (otherRelation.getContainer() == this) {
            otherRelationName=otherRelation.getName();
          }
 else {
            _recordLevelCrossingLink(null,relation,otherRelation,0);
            continue;
          }
          result.append(_getIndentPrefix(depth) + ""String_Node_Str"" + relationName+ ""String_Node_Str""+ otherRelationName+ ""String_Node_Str"");
        }
      }
    }
  }
  return result.toString();
}"
73356,"/** 
 * Add an attribute.  This method should not be used directly. Instead, call setContainer() on the attribute. Derived classes may further constrain the class of the attribute. To do this, they should override this method to throw an exception when the argument is not an instance of the expected class. This method is write-synchronized on the workspace and increments its version number.
 * @param p The attribute to be added.
 * @exception NameDuplicationException If this object alreadyhas an attribute with the same name.
 * @exception IllegalActionException If the attribute is not anan instance of the expect class (in derived classes).
 */
protected void _addAttribute(Attribute p) throws NameDuplicationException, IllegalActionException {
  if (_decorator == null) {
    if (p.getName().equals(""String_Node_Str"")) {
      _decoratorPath=(StringAttribute)p;
      _decoratorPath.setVisibility(Settable.NONE);
    }
  }
  super._addAttribute(p);
}","/** 
 * Add an attribute.  This method should not be used directly. Instead, call setContainer() on the attribute. Derived classes may further constrain the class of the attribute. To do this, they should override this method to throw an exception when the argument is not an instance of the expected class. This method is write-synchronized on the workspace and increments its version number.
 * @param p The attribute to be added.
 * @exception NameDuplicationException If this object alreadyhas an attribute with the same name.
 * @exception IllegalActionException If the attribute is not anan instance of the expect class (in derived classes).
 */
protected void _addAttribute(Attribute p) throws NameDuplicationException, IllegalActionException {
  if (_decorator == null) {
    if (p.getName().equals(""String_Node_Str"") && p instanceof StringAttribute) {
      _decoratorPath=(StringAttribute)p;
      _decoratorPath.setVisibility(Settable.NONE);
    }
  }
  super._addAttribute(p);
}"
73357,"/** 
 * The remove() method is not supported because is is not supported in NamedObj.ContainedObjectsIterator.remove().
 */
public void remove(){
  super.remove();
}","/** 
 * The remove() method is not supported because is is not supported in NamedObj.ContainedObjectsIterator.remove().
 */
public void remove(){
  throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}"
73358,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new entity with clones of the ports of the original entity.  The ports are set to the ports of the new entity. This method gets read access on the workspace associated with this object.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return The new Entity.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  try {
    workspace().getReadAccess();
    Entity newEntity=(Entity)super.clone(workspace);
    newEntity._portList=new NamedList(newEntity);
    Iterator ports=portList().iterator();
    while (ports.hasNext()) {
      Port port=(Port)ports.next();
      Port newPort=(Port)port.clone(workspace);
      try {
        newPort.setContainer(newEntity);
      }
 catch (      KernelException ex) {
        workspace.remove(newEntity);
        throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
      }
    }
    Class myClass=getClass();
    Field[] fields=myClass.getFields();
    for (int i=0; i < fields.length; i++) {
      try {
        if (fields[i].get(newEntity) instanceof Port) {
          String portName=((Port)fields[i].get(this)).getName();
          Port port=newEntity.getPort(portName);
          if (port == null) {
            throw new IllegalActionException(this,""String_Node_Str"" + portName + ""String_Node_Str"");
          }
          fields[i].set(newEntity,port);
        }
      }
 catch (      Exception ex) {
        CloneNotSupportedException cloneException=new CloneNotSupportedException(""String_Node_Str"" + fields[i].getName() + ""String_Node_Str"");
        cloneException.initCause(ex);
        throw cloneException;
      }
    }
    _cloneFixAttributeFields(newEntity);
    return newEntity;
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new entity with clones of the ports of the original entity.  The ports are set to the ports of the new entity. This method gets read access on the workspace associated with this object.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return The new Entity.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  try {
    workspace().getReadAccess();
    Entity newEntity=(Entity)super.clone(workspace);
    newEntity._portList=new NamedList(newEntity);
    Iterator ports=portList().iterator();
    while (ports.hasNext()) {
      Port port=(Port)ports.next();
      Port newPort=(Port)port.clone(workspace);
      try {
        newPort.setContainer(newEntity);
      }
 catch (      KernelException ex) {
        workspace.remove(newEntity);
        throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
      }
    }
    Class myClass=getClass();
    Field[] fields=myClass.getFields();
    for (int i=0; i < fields.length; i++) {
      try {
        if (fields[i].get(newEntity) instanceof Port) {
          String portName=((Port)fields[i].get(this)).getName();
          Port port=newEntity.getPort(portName);
          if (port == null) {
            throw new IllegalActionException(this,""String_Node_Str"" + portName + ""String_Node_Str"");
          }
          fields[i].set(newEntity,port);
        }
      }
 catch (      Throwable throwable) {
        CloneNotSupportedException cloneException=new CloneNotSupportedException(""String_Node_Str"" + fields[i].getName() + ""String_Node_Str"");
        cloneException.initCause(throwable);
        throw cloneException;
      }
    }
    _cloneFixAttributeFields(newEntity);
    return newEntity;
  }
  finally {
    workspace().doneReading();
  }
}"
73359,"/** 
 * Propagate existence of this object to the specified object. This overrides the base class to set the container.
 * @param container Object to contain the new object.
 * @exception IllegalActionException If the objectcannot be cloned.
 * @return A new object of the same class and nameas this one.
 */
protected NamedObj _propagateExistence(NamedObj container) throws IllegalActionException {
  try {
    Port newObject=(Port)super._propagateExistence(container);
    newObject.setContainer((Entity)container);
    return newObject;
  }
 catch (  NameDuplicationException e) {
    throw new InternalErrorException(e);
  }
}","/** 
 * Propagate existence of this object to the specified object. This overrides the base class to set the container.
 * @param container Object to contain the new object.
 * @exception IllegalActionException If the objectcannot be cloned.
 * @return A new object of the same class and nameas this one.
 */
protected NamedObj _propagateExistence(NamedObj container) throws IllegalActionException {
  try {
    Port newObject=(Port)super._propagateExistence(container);
    if (container instanceof CompositeEntity) {
      throw new InternalErrorException(container + ""String_Node_Str"");
    }
 else {
      newObject.setContainer((Entity)container);
    }
    return newObject;
  }
 catch (  NameDuplicationException e) {
    throw new InternalErrorException(e);
  }
}"
73360,"private long _createMxArray(String name,Token t) throws IllegalActionException {
  long ma=0;
  if (t instanceof ArrayToken) {
    Token[] ta=((ArrayToken)t).arrayValue();
    if (!(ta[0] instanceof StringToken)) {
      ma=ptmatlabCreateCellMatrix(name,1,ta.length);
      if (ma == 0) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + name);
      }
      for (int n=0; n < ta.length; n++) {
        long fma=_createMxArray(""String_Node_Str"" + n + ""String_Node_Str"",ta[n]);
        if (fma == 0) {
          throw new IllegalActionException(""String_Node_Str"" + n + ""String_Node_Str""+ name);
        }
        ptmatlabSetCell(name,ma,0,n,fma);
      }
    }
 else {
      String s=((StringToken)ta[0]).stringValue();
      ma=ptmatlabCreateString(name,s,ta.length,s.length());
      for (int n=1; n < ta.length; n++) {
        s=((StringToken)ta[n]).stringValue();
        ptmatlabSetString(name,ma,n,s,s.length());
      }
    }
  }
 else   if (t instanceof RecordToken) {
    Object[] fieldNames=(((RecordToken)t).labelSet()).toArray();
    ma=ptmatlabCreateStructMatrix(name,fieldNames,1,1);
    if (ma == 0) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + name);
    }
    for (int n=0; n < fieldNames.length; n++) {
      Token f=((RecordToken)t).get((String)fieldNames[n]);
      long fma=_createMxArray((String)fieldNames[n],f);
      if (fma == 0) {
        throw new IllegalActionException(""String_Node_Str"" + fieldNames[n] + ""String_Node_Str""+ name);
      }
      ptmatlabSetStructField(name,ma,(String)fieldNames[n],0,0,fma);
    }
  }
 else   if (t instanceof StringToken) {
    String s=((StringToken)t).stringValue();
    ma=ptmatlabCreateString(name,s,1,s.length());
  }
 else   if (t instanceof ComplexMatrixToken) {
    Complex[][] a=((ComplexMatrixToken)t).complexMatrix();
    ma=ptmatlabCreateComplexMatrix(name,a,a.length,a[0].length);
  }
 else   if (t instanceof MatrixToken) {
    double[][] a=((MatrixToken)t).doubleMatrix();
    ma=ptmatlabCreateDoubleMatrix(name,a,a.length,a[0].length);
  }
 else   if (t instanceof ComplexToken) {
    Complex[] a={((ComplexToken)t).complexValue()};
    ma=ptmatlabCreateComplexMatrixOneDim(name,a,a.length);
  }
 else {
    double[] a=new double[1];
    if (t instanceof BooleanToken) {
      a[0]=((BooleanToken)t).booleanValue() ? 1.0 : 0.0;
    }
 else {
      a[0]=((ScalarToken)t).doubleValue();
    }
    ma=ptmatlabCreateDoubleMatrixOneDim(name,a,1);
  }
  if (ma == 0) {
    throw new IllegalActionException(""String_Node_Str"" + name);
  }
  return ma;
}","private long _createMxArray(String name,Token t) throws IllegalActionException {
  long ma=0;
  if (t instanceof ArrayToken) {
    Token[] ta=((ArrayToken)t).arrayValue();
    if (!(ta[0] instanceof StringToken)) {
      ma=ptmatlabCreateCellMatrix(name,1,ta.length);
      if (ma == 0) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + name);
      }
      for (int n=0; n < ta.length; n++) {
        long fma=_createMxArray(""String_Node_Str"" + n + ""String_Node_Str"",ta[n]);
        if (fma == 0) {
          throw new IllegalActionException(""String_Node_Str"" + n + ""String_Node_Str""+ name);
        }
        ptmatlabSetCell(name,ma,0,n,fma);
      }
    }
 else {
      String s=((StringToken)ta[0]).stringValue();
      ma=ptmatlabCreateString(name,s,ta.length,s.length());
      for (int n=1; n < ta.length; n++) {
        s=((StringToken)ta[n]).stringValue();
        ptmatlabSetString(name,ma,n,s,s.length());
      }
    }
  }
 else   if (t instanceof RecordToken) {
    Object[] fieldNames=(((RecordToken)t).labelSet()).toArray();
    ma=ptmatlabCreateStructMatrix(name,fieldNames,1,1);
    if (ma == 0) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + name);
    }
    for (int n=0; n < fieldNames.length; n++) {
      Token f=((RecordToken)t).get((String)fieldNames[n]);
      long fma=_createMxArray((String)fieldNames[n],f);
      if (fma == 0) {
        throw new IllegalActionException(""String_Node_Str"" + fieldNames[n] + ""String_Node_Str""+ name);
      }
      ptmatlabSetStructField(name,ma,(String)fieldNames[n],0,0,fma);
    }
  }
 else   if (t instanceof StringToken) {
    String s=((StringToken)t).stringValue();
    ma=ptmatlabCreateString(name,s,1,s.length());
  }
 else   if (t instanceof ComplexMatrixToken) {
    Complex[][] a=((ComplexMatrixToken)t).complexMatrix();
    ma=ptmatlabCreateComplexMatrix(name,a,a.length,a[0].length);
  }
 else   if (t instanceof MatrixToken) {
    double[][] a=((MatrixToken)t).doubleMatrix();
    ma=ptmatlabCreateDoubleMatrix(name,a,a.length,a[0].length);
  }
 else   if (t instanceof ComplexToken) {
    Complex[] a={((ComplexToken)t).complexValue()};
    ma=ptmatlabCreateComplexMatrixOneDim(name,a,a.length);
  }
 else {
    double[] a=new double[1];
    if (t instanceof BooleanToken) {
      a[0]=((BooleanToken)t).booleanValue() ? 1.0 : 0.0;
    }
 else     if (t instanceof BooleanToken) {
      a[0]=((ScalarToken)t).doubleValue();
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + t + ""String_Node_Str""+ t.getType());
    }
    ma=ptmatlabCreateDoubleMatrixOneDim(name,a,1);
  }
  if (ma == 0) {
    throw new IllegalActionException(""String_Node_Str"" + name);
  }
  return ma;
}"
73361,"/** 
 * Check for problems in the moml to be copied.  If there are missing variables references, search for the variables and return MoML definitions for any found variables.
 * @param momlToBeChecked The MoML string to be checked.
 * @param container The container in which the string is to be checked.
 * @param hideVariables If true, add MoML that will make all the foundvariables hidden from the user interface when they are copied.
 * @return MoML to be inserted before the momlToBeChecked
 * @exception IllegalActionException If there is a problem parsingthe string, or validating a variable.
 */
public String checkCopy(String momlToBeChecked,NamedObj container,boolean hideVariables) throws IllegalActionException {
  _variableBuffer=new StringWriter();
  Workspace workspace=new Workspace(""String_Node_Str"");
  MoMLParser parser=new MoMLParser(workspace);
  TypedCompositeActor parsedContainer=null;
  boolean doParse=true;
  while (doParse) {
    ErrorHandler handler=MoMLParser.getErrorHandler();
    MoMLParser.setErrorHandler(null);
    try {
      parsedContainer=(TypedCompositeActor)parser.parse(""String_Node_Str"" + _variableBuffer.toString() + momlToBeChecked+ ""String_Node_Str"");
      doParse=false;
    }
 catch (    MissingClassException ex1) {
      try {
        doParse=_findMissingClass(ex1,container,parsedContainer);
      }
 catch (      Exception ex1a) {
        return _variableBuffer.toString();
      }
    }
catch (    IllegalActionException ex2) {
      try {
        doParse=_findUndefinedConstantsOrIdentifiers(ex2,container,parsedContainer,hideVariables);
      }
 catch (      Exception ex2a) {
        return _variableBuffer.toString();
      }
    }
catch (    Exception ex3) {
      throw new IllegalActionException(container,ex3,""String_Node_Str"");
    }
 finally {
      MoMLParser.setErrorHandler(handler);
    }
  }
  if (parsedContainer != null) {
    Iterator entities=parsedContainer.deepEntityList().iterator();
    while (entities.hasNext()) {
      Entity entity=(Entity)entities.next();
      List<Attribute> entityAttributes=new LinkedList<Attribute>(entity.attributeList());
      for (      Attribute attribute : entityAttributes) {
        _recursiveFindUndefinedConstantsOrIdentifiesInAttribute(attribute,container,parsedContainer,hideVariables);
      }
    }
    List<Attribute> allAttributes=new LinkedList<Attribute>(parsedContainer.attributeList());
    for (    Attribute attribute : allAttributes) {
      _recursiveFindUndefinedConstantsOrIdentifiesInAttribute(attribute,container,parsedContainer,hideVariables);
    }
  }
  return _variableBuffer.toString();
}","/** 
 * Check for problems in the moml to be copied.  If there are missing variables references, search for the variables and return MoML definitions for any found variables.
 * @param momlToBeChecked The MoML string to be checked.
 * @param container The container in which the string is to be checked.
 * @param hideVariables If true, add MoML that will make all the foundvariables hidden from the user interface when they are copied.
 * @return MoML to be inserted before the momlToBeChecked
 * @exception IllegalActionException If there is a problem parsingthe string, or validating a variable.
 */
public String checkCopy(String momlToBeChecked,NamedObj container,boolean hideVariables) throws IllegalActionException {
  _variableBuffer=new StringWriter();
  Workspace workspace=new Workspace(""String_Node_Str"");
  MoMLParser parser=new MoMLParser(workspace);
  TypedCompositeActor parsedContainer=null;
  boolean doParse=true;
  while (doParse) {
    ErrorHandler handler=MoMLParser.getErrorHandler();
    MoMLParser.setErrorHandler(null);
    try {
      parsedContainer=(TypedCompositeActor)parser.parse(""String_Node_Str"" + _variableBuffer.toString() + momlToBeChecked+ ""String_Node_Str"");
      doParse=false;
    }
 catch (    MissingClassException ex1) {
      try {
        doParse=_findMissingClass(ex1,container,parsedContainer);
      }
 catch (      Exception ex1a) {
        return _variableBuffer.toString();
      }
    }
catch (    IllegalActionException ex2) {
      try {
        doParse=_findUndefinedConstantsOrIdentifiers(ex2,container,parsedContainer,hideVariables);
      }
 catch (      Throwable throwable) {
        return _variableBuffer.toString();
      }
    }
catch (    Exception ex3) {
      throw new IllegalActionException(container,ex3,""String_Node_Str"");
    }
 finally {
      MoMLParser.setErrorHandler(handler);
    }
  }
  if (parsedContainer != null) {
    Iterator entities=parsedContainer.deepEntityList().iterator();
    while (entities.hasNext()) {
      Entity entity=(Entity)entities.next();
      List<Attribute> entityAttributes=new LinkedList<Attribute>(entity.attributeList());
      for (      Attribute attribute : entityAttributes) {
        _recursiveFindUndefinedConstantsOrIdentifiesInAttribute(attribute,container,parsedContainer,hideVariables);
      }
    }
    List<Attribute> allAttributes=new LinkedList<Attribute>(parsedContainer.attributeList());
    for (    Attribute attribute : allAttributes) {
      _recursiveFindUndefinedConstantsOrIdentifiesInAttribute(attribute,container,parsedContainer,hideVariables);
    }
  }
  return _variableBuffer.toString();
}"
73362,"/** 
 * Recursively search through an attribute and its contained attributes to find any unresolved references to other attributes.
 * @param attribute The attribute to be traversed.
 * @param container The original container of the attribute.
 * @param parsedContainer The temporary container from which the new copiedunresolved attributes will be generated.
 * @param hideVariables If true, add MoML that will make all the foundvariables hidden from the user interface when they are copied.
 * @exception IllegalActionException If there is a problem parsingan attribute, or validating a variable.
 */
private void _recursiveFindUndefinedConstantsOrIdentifiesInAttribute(Attribute attribute,NamedObj container,TypedCompositeActor parsedContainer,boolean hideVariables) throws IllegalActionException {
  if (attribute instanceof Variable) {
    Variable variable=(Variable)attribute;
    boolean doGetToken=true;
    while (doGetToken) {
      doGetToken=false;
      try {
        variable.getToken();
      }
 catch (      IllegalActionException ex) {
        doGetToken=_findUndefinedConstantsOrIdentifiers(ex,container,parsedContainer,hideVariables);
      }
    }
    ;
  }
  if (attribute instanceof AbstractSettableAttribute) {
    AbstractSettableAttribute settable=(AbstractSettableAttribute)attribute;
    PtParser ptParser=new PtParser();
    ASTPtRootNode parseTree=null;
    try {
      parseTree=ptParser.generateParseTree(settable.getExpression());
    }
 catch (    Exception ex) {
    }
    if (parseTree != null) {
      ParseTreeFreeVariableCollector variableCollector=new ParseTreeFreeVariableCollector();
      Set set=variableCollector.collectFreeVariables(parseTree,null);
      for (Iterator elements=set.iterator(); elements.hasNext(); ) {
        String name=(String)elements.next();
        if (parsedContainer.getAttribute(name) == null) {
          _findUndefinedConstantsOrIdentifiers(name,name,container,parsedContainer,hideVariables);
        }
      }
    }
  }
  List<Attribute> containedAttributes=attribute.attributeList();
  for (  Attribute containedAttribute : containedAttributes) {
    _recursiveFindUndefinedConstantsOrIdentifiesInAttribute(containedAttribute,container,parsedContainer,hideVariables);
  }
}","/** 
 * Recursively search through an attribute and its contained attributes to find any unresolved references to other attributes.
 * @param attribute The attribute to be traversed.
 * @param container The original container of the attribute.
 * @param parsedContainer The temporary container from which the new copiedunresolved attributes will be generated.
 * @param hideVariables If true, add MoML that will make all the foundvariables hidden from the user interface when they are copied.
 * @exception IllegalActionException If there is a problem parsingan attribute, or validating a variable.
 */
private void _recursiveFindUndefinedConstantsOrIdentifiesInAttribute(Attribute attribute,NamedObj container,TypedCompositeActor parsedContainer,boolean hideVariables) throws IllegalActionException {
  if (attribute instanceof Variable) {
    Variable variable=(Variable)attribute;
    boolean doGetToken=true;
    while (doGetToken) {
      doGetToken=false;
      try {
        variable.getToken();
      }
 catch (      IllegalActionException ex) {
        doGetToken=_findUndefinedConstantsOrIdentifiers(ex,container,parsedContainer,hideVariables);
      }
    }
    ;
  }
  if (attribute instanceof AbstractSettableAttribute) {
    AbstractSettableAttribute settable=(AbstractSettableAttribute)attribute;
    PtParser ptParser=new PtParser();
    ASTPtRootNode parseTree=null;
    try {
      parseTree=ptParser.generateParseTree(settable.getExpression());
    }
 catch (    Throwable throwable) {
    }
    if (parseTree != null) {
      ParseTreeFreeVariableCollector variableCollector=new ParseTreeFreeVariableCollector();
      Set set=variableCollector.collectFreeVariables(parseTree,null);
      for (Iterator elements=set.iterator(); elements.hasNext(); ) {
        String name=(String)elements.next();
        if (parsedContainer.getAttribute(name) == null) {
          _findUndefinedConstantsOrIdentifiers(name,name,container,parsedContainer,hideVariables);
        }
      }
    }
  }
  List<Attribute> containedAttributes=attribute.attributeList();
  for (  Attribute containedAttribute : containedAttributes) {
    _recursiveFindUndefinedConstantsOrIdentifiesInAttribute(containedAttribute,container,parsedContainer,hideVariables);
  }
}"
73363,"/** 
 * Generate the index files.
 * @param classesFileName The name of the file that contains thedot separated class names - one class per line. This file is usually called allActors.txt, which is generated by running the $PTII/doc/doclets/PtDoc doclet.  For example, see $PTII/doc/codeDoc/allActors.txt
 * @param modelsFileName The name of the file that contains theurls that point to the models to be parsed, one model per line.  This file is usually called models.txt and is generated by running ptolemy.actor.gui.HTMLAbout.
 * @param outputDirectory Directory in which to write index files.The files generated have the name <i>actorName<i>idx.htm, where <i>actorName</i> is the name of the actor.  Typically, the value for this parameter is doc/codeDoc.
 * @exception Exception If there is a problem reading or writinga file.
 */
public static void generateActorIndex(String classesFileName,String modelsFileName,String outputDirectory) throws Exception {
  HashMap classesToBeIndexed=new HashMap();
  BufferedReader classesReader=null;
  BufferedReader modelReader=null;
  try {
    classesReader=new BufferedReader(new FileReader(classesFileName));
    String className;
    while ((className=classesReader.readLine()) != null) {
      System.out.println(""String_Node_Str"" + className);
      classesToBeIndexed.put(className,new HashSet());
    }
    modelReader=new BufferedReader(new FileReader(modelsFileName));
    String modelName;
    MoMLParser parser=new MoMLParser();
    MoMLParser.setMoMLFilters(BackwardCompatibility.allFilters());
    NamedObjClassesSeen namedObjClassesSeen=new NamedObjClassesSeen(classesToBeIndexed);
    MoMLParser.addMoMLFilter(namedObjClassesSeen);
    RemoveGraphicalClasses removeGraphicalClasses=new RemoveGraphicalClasses();
    removeGraphicalClasses.setRemoveGR(true);
    MoMLParser.addMoMLFilter(removeGraphicalClasses);
    while ((modelName=modelReader.readLine()) != null) {
      namedObjClassesSeen.reset(modelName);
      try {
        URL modelURL=FileUtilities.nameToURL(modelName,null,null);
        System.out.println(""String_Node_Str"" + modelURL);
        parser.reset();
        parser.parse(null,modelURL);
      }
 catch (      Exception ex) {
        System.err.println(""String_Node_Str"" + modelName);
        ex.printStackTrace();
      }
    }
  }
  finally {
    if (classesReader != null) {
      try {
        classesReader.close();
      }
 catch (      Exception ex) {
      }
    }
    if (modelReader != null) {
      try {
        modelReader.close();
      }
 catch (      Exception ex) {
      }
    }
  }
  Iterator classes=classesToBeIndexed.entrySet().iterator();
  while (classes.hasNext()) {
    Map.Entry entry=(Map.Entry)classes.next();
    String actorClassName=(String)entry.getKey();
    if (((Set)entry.getValue()).size() == 0) {
      continue;
    }
    BufferedWriter writer=null;
    try {
      String outputFileName=outputDirectory + File.separator + actorClassName.replace('.',File.separatorChar)+ ""String_Node_Str"";
      String canonicalOutputFileName=new File(outputFileName).getCanonicalPath().replace('\\','/');
      String ptII=null;
      try {
        ptII=new URI(StringUtilities.getProperty(""String_Node_Str"")).normalize().getPath();
        ptII=new File(ptII).getCanonicalPath().replace('\\','/');
      }
 catch (      URISyntaxException ex) {
        throw new InternalErrorException(null,ex,""String_Node_Str"" + ptII);
      }
      if (ptII.length() == 0) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
      String relativePath=""String_Node_Str"";
      if (canonicalOutputFileName.startsWith(ptII)) {
        String relativeOutputFileName=StringUtilities.substitute(canonicalOutputFileName,ptII,""String_Node_Str"");
        StringBuffer relativePathBuffer=new StringBuffer();
        int index=0;
        while (relativeOutputFileName.indexOf('/',index) != -1) {
          index=relativeOutputFileName.indexOf('/',index) + 1;
          relativePathBuffer.append(""String_Node_Str"");
        }
        relativePath=relativePathBuffer.toString();
        relativePath=relativePath.substring(0,relativePath.length() - 3);
      }
      File outputDirectoryFile=new File(new File(outputFileName).getParent());
      if (!outputDirectoryFile.exists()) {
        System.out.println(""String_Node_Str"" + outputDirectoryFile);
        if (!outputDirectoryFile.mkdirs()) {
          throw new IOException(""String_Node_Str"" + outputDirectoryFile + ""String_Node_Str"");
        }
      }
      System.out.println(""String_Node_Str"" + outputFileName);
      writer=new BufferedWriter(new FileWriter(outputFileName));
      writer.write(""String_Node_Str"" + actorClassName + ""String_Node_Str""+ ""String_Node_Str""+ relativePath+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ ""String_Node_Str""+ actorClassName+ ""String_Node_Str"");
      Iterator models=((Set)entry.getValue()).iterator();
      while (models.hasNext()) {
        String model=(String)models.next();
        if (model.startsWith(""String_Node_Str"")) {
          model=model.substring(11);
        }
        writer.write(""String_Node_Str"" + relativePath + model+ ""String_Node_Str""+ model+ ""String_Node_Str"");
      }
      writer.write(""String_Node_Str"");
    }
  finally {
      if (writer != null) {
        writer.close();
      }
    }
  }
}","/** 
 * Generate the index files.
 * @param classesFileName The name of the file that contains thedot separated class names - one class per line. This file is usually called allActors.txt, which is generated by running the $PTII/doc/doclets/PtDoc doclet.  For example, see $PTII/doc/codeDoc/allActors.txt
 * @param modelsFileName The name of the file that contains theurls that point to the models to be parsed, one model per line.  This file is usually called models.txt and is generated by running ptolemy.actor.gui.HTMLAbout.
 * @param outputDirectory Directory in which to write index files.The files generated have the name <i>actorName<i>idx.htm, where <i>actorName</i> is the name of the actor.  Typically, the value for this parameter is doc/codeDoc.
 * @exception Exception If there is a problem reading or writinga file.
 */
public static void generateActorIndex(String classesFileName,String modelsFileName,String outputDirectory) throws Exception {
  HashMap classesToBeIndexed=new HashMap();
  BufferedReader classesReader=null;
  BufferedReader modelReader=null;
  try {
    classesReader=new BufferedReader(new FileReader(classesFileName));
    String className;
    while ((className=classesReader.readLine()) != null) {
      System.out.println(""String_Node_Str"" + className);
      classesToBeIndexed.put(className,new HashSet());
    }
    modelReader=new BufferedReader(new FileReader(modelsFileName));
    String modelName;
    MoMLParser parser=new MoMLParser();
    MoMLParser.setMoMLFilters(BackwardCompatibility.allFilters());
    NamedObjClassesSeen namedObjClassesSeen=new NamedObjClassesSeen(classesToBeIndexed);
    MoMLParser.addMoMLFilter(namedObjClassesSeen);
    RemoveGraphicalClasses removeGraphicalClasses=new RemoveGraphicalClasses();
    removeGraphicalClasses.setRemoveGR(true);
    MoMLParser.addMoMLFilter(removeGraphicalClasses);
    while ((modelName=modelReader.readLine()) != null) {
      namedObjClassesSeen.reset(modelName);
      try {
        URL modelURL=FileUtilities.nameToURL(modelName,null,null);
        System.out.println(""String_Node_Str"" + modelURL);
        parser.reset();
        parser.parse(null,modelURL);
      }
 catch (      Exception ex) {
        System.err.println(""String_Node_Str"" + modelName);
        ex.printStackTrace();
      }
    }
  }
  finally {
    if (classesReader != null) {
      try {
        classesReader.close();
      }
 catch (      IOException ex) {
        System.out.println(""String_Node_Str"" + classesReader + ""String_Node_Str""+ ex);
      }
    }
    if (modelReader != null) {
      try {
        modelReader.close();
      }
 catch (      IOException ex) {
        System.out.println(""String_Node_Str"" + modelReader + ""String_Node_Str""+ ex);
      }
    }
  }
  Iterator classes=classesToBeIndexed.entrySet().iterator();
  while (classes.hasNext()) {
    Map.Entry entry=(Map.Entry)classes.next();
    String actorClassName=(String)entry.getKey();
    if (((Set)entry.getValue()).size() == 0) {
      continue;
    }
    BufferedWriter writer=null;
    try {
      String outputFileName=outputDirectory + File.separator + actorClassName.replace('.',File.separatorChar)+ ""String_Node_Str"";
      String canonicalOutputFileName=new File(outputFileName).getCanonicalPath().replace('\\','/');
      String ptII=null;
      try {
        ptII=new URI(StringUtilities.getProperty(""String_Node_Str"")).normalize().getPath();
        ptII=new File(ptII).getCanonicalPath().replace('\\','/');
      }
 catch (      URISyntaxException ex) {
        throw new InternalErrorException(null,ex,""String_Node_Str"" + ptII);
      }
      if (ptII == null || ptII.length() == 0) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
      String relativePath=""String_Node_Str"";
      if (canonicalOutputFileName.startsWith(ptII)) {
        String relativeOutputFileName=StringUtilities.substitute(canonicalOutputFileName,ptII,""String_Node_Str"");
        StringBuffer relativePathBuffer=new StringBuffer();
        int index=0;
        while (relativeOutputFileName.indexOf('/',index) != -1) {
          index=relativeOutputFileName.indexOf('/',index) + 1;
          relativePathBuffer.append(""String_Node_Str"");
        }
        relativePath=relativePathBuffer.toString();
        relativePath=relativePath.substring(0,relativePath.length() - 3);
      }
      File outputDirectoryFile=new File(new File(outputFileName).getParent());
      if (!outputDirectoryFile.exists()) {
        System.out.println(""String_Node_Str"" + outputDirectoryFile);
        if (!outputDirectoryFile.mkdirs()) {
          throw new IOException(""String_Node_Str"" + outputDirectoryFile + ""String_Node_Str"");
        }
      }
      System.out.println(""String_Node_Str"" + outputFileName);
      writer=new BufferedWriter(new FileWriter(outputFileName));
      writer.write(""String_Node_Str"" + actorClassName + ""String_Node_Str""+ ""String_Node_Str""+ relativePath+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ ""String_Node_Str""+ actorClassName+ ""String_Node_Str"");
      Iterator models=((Set)entry.getValue()).iterator();
      while (models.hasNext()) {
        String model=(String)models.next();
        if (model.startsWith(""String_Node_Str"")) {
          model=model.substring(11);
        }
        writer.write(""String_Node_Str"" + relativePath + model+ ""String_Node_Str""+ model+ ""String_Node_Str"");
      }
      writer.write(""String_Node_Str"");
    }
  finally {
      if (writer != null) {
        writer.close();
      }
    }
  }
}"
73364,"/** 
 * Make modifications to the specified container, which is defined in a MoML element with the specified name. This method is called when an end element in MoML is encountered. A typical use of this method is to make some modification to the object (the container) that was constructed. <p> If an implementor makes changes to the specified container, then it should call MoMLParser.setModified(true) which indicates that the model was modified so that the user can optionally save the modified model.
 * @param container The object defined by the element that thisis the end of.
 * @param elementName The element name.
 * @param currentCharData The character data, which appearsonly in the doc and configure elements
 * @param xmlFile The file currently being parsed.
 * @exception Exception If there is a problem modifying thespecified container.
 */
public void filterEndElement(NamedObj container,String elementName,StringBuffer currentCharData,String xmlFile) throws Exception {
  if (container instanceof VersionAttribute) {
    VersionAttribute version=(VersionAttribute)container;
    try {
      if (xmlFile != null) {
        _changesNeededForXmlFile.put(xmlFile,version != null && version.isLessThan(new VersionAttribute(""String_Node_Str"")));
      }
    }
 catch (    IllegalActionException e) {
      throw new IllegalStateException(e);
    }
  }
 else   if (container instanceof IORelation) {
    if (_currentlyProcessingRelation && !_currentlyProcessingWidth) {
      if (_changedNeeded(container,xmlFile)) {
        IORelation relation=(IORelation)container;
        relation.setWidth(1);
        relation.width.propagateValue();
        MoMLParser.setModified(true);
      }
    }
    _currentlyProcessingRelation=false;
    _currentlyProcessingWidth=false;
  }
}","/** 
 * Make modifications to the specified container, which is defined in a MoML element with the specified name. This method is called when an end element in MoML is encountered. A typical use of this method is to make some modification to the object (the container) that was constructed. <p> If an implementor makes changes to the specified container, then it should call MoMLParser.setModified(true) which indicates that the model was modified so that the user can optionally save the modified model.
 * @param container The object defined by the element that thisis the end of.
 * @param elementName The element name.
 * @param currentCharData The character data, which appearsonly in the doc and configure elements
 * @param xmlFile The file currently being parsed.
 * @exception Exception If there is a problem modifying thespecified container.
 */
public void filterEndElement(NamedObj container,String elementName,StringBuffer currentCharData,String xmlFile) throws Exception {
  if (container instanceof VersionAttribute) {
    VersionAttribute version=(VersionAttribute)container;
    try {
      if (xmlFile != null) {
        _changesNeededForXmlFile.put(xmlFile,version.isLessThan(new VersionAttribute(""String_Node_Str"")));
      }
    }
 catch (    IllegalActionException e) {
      throw new IllegalStateException(e);
    }
  }
 else   if (container instanceof IORelation) {
    if (_currentlyProcessingRelation && !_currentlyProcessingWidth) {
      if (_changedNeeded(container,xmlFile)) {
        IORelation relation=(IORelation)container;
        relation.setWidth(1);
        relation.width.propagateValue();
        MoMLParser.setModified(true);
      }
    }
    _currentlyProcessingRelation=false;
    _currentlyProcessingWidth=false;
  }
}"
73365,"/** 
 * Propagate existence of this object to the specified object. This overrides the base class to set the container.
 * @param container Object to contain the new object.
 * @exception IllegalActionException If the objectcannot be cloned.
 * @return A new object of the same class and nameas this one.
 */
protected NamedObj _propagateExistence(NamedObj container) throws IllegalActionException {
  try {
    Port newObject=(Port)super._propagateExistence(container);
    if (!(container instanceof CompositeEntity)) {
      throw new InternalErrorException(container + ""String_Node_Str"");
    }
 else {
      newObject.setContainer((Entity)container);
    }
    return newObject;
  }
 catch (  NameDuplicationException e) {
    throw new InternalErrorException(e);
  }
}","/** 
 * Propagate existence of this object to the specified object. This overrides the base class to set the container.
 * @param container Object to contain the new object.
 * @exception IllegalActionException If the objectcannot be cloned.
 * @return A new object of the same class and nameas this one.
 */
protected NamedObj _propagateExistence(NamedObj container) throws IllegalActionException {
  try {
    Port newObject=(Port)super._propagateExistence(container);
    if (!(container instanceof Entity)) {
      throw new InternalErrorException(container + ""String_Node_Str"");
    }
 else {
      newObject.setContainer((Entity)container);
    }
    return newObject;
  }
 catch (  NameDuplicationException e) {
    throw new InternalErrorException(e);
  }
}"
73366,"/** 
 * Return a default Configuration, or null to do without one. This configuration will be created before any command-line arguments are processed.  If there are no command-line arguments, then the default configuration is given by _createEmptyConfiguration() instead.  This method merges the compile-time configuration file values from   {@link ptolemy.util.StringUtilities#mergePropertiesFile()}. Subclasses should call  {@link ptolemy.actor.gui.PtolemyPreferences#setDefaultPreferences(Configuration)}.
 * @return null
 * @exception Exception Thrown in derived classes if the defaultconfiguration cannot be opened.
 */
protected Configuration _createDefaultConfiguration() throws Exception {
  try {
    StringUtilities.mergePropertiesFile();
  }
 catch (  Exception ex) {
  }
  return null;
}","/** 
 * Return a default Configuration, or null to do without one. This configuration will be created before any command-line arguments are processed.  If there are no command-line arguments, then the default configuration is given by _createEmptyConfiguration() instead.  This method merges the compile-time configuration file values from   {@link ptolemy.util.StringUtilities#mergePropertiesFile()}. Subclasses should call  {@link ptolemy.actor.gui.PtolemyPreferences#setDefaultPreferences(Configuration)}.
 * @return null
 * @exception Exception Thrown in derived classes if the defaultconfiguration cannot be opened.
 */
protected Configuration _createDefaultConfiguration() throws Exception {
  try {
    StringUtilities.mergePropertiesFile();
  }
 catch (  Throwable throwable) {
  }
  return null;
}"
73367,"/** 
 * Throw an exception that includes the elements of the args parameter.
 * @param cause The throwable that caused the problem.
 * @param args An array of Strings.
 * @exception Exception Always thrown
 */
public static void throwArgsException(Throwable cause,String[] args) throws Exception {
  StringBuffer argsStringBuffer=new StringBuffer();
  try {
    for (int i=0; i < args.length; i++) {
      if (argsStringBuffer.length() > 0) {
        argsStringBuffer.append(""String_Node_Str"");
      }
      argsStringBuffer.append(args[i]);
    }
  }
 catch (  Exception ex2) {
  }
  throw new Exception(""String_Node_Str"" + argsStringBuffer.toString() + ""String_Node_Str"",cause);
}","/** 
 * Throw an exception that includes the elements of the args parameter.
 * @param cause The throwable that caused the problem.
 * @param args An array of Strings.
 * @exception Exception Always thrown
 */
public static void throwArgsException(Throwable cause,String[] args) throws Exception {
  StringBuffer argsStringBuffer=new StringBuffer();
  try {
    for (int i=0; i < args.length; i++) {
      if (argsStringBuffer.length() > 0) {
        argsStringBuffer.append(""String_Node_Str"");
      }
      argsStringBuffer.append(args[i]);
    }
  }
 catch (  Throwable throwable) {
  }
  throw new Exception(""String_Node_Str"" + argsStringBuffer.toString() + ""String_Node_Str"",cause);
}"
73368,"/** 
 * Given the name of a file or a URL, convert it to a URL. This first attempts to do that directly by invoking a URL constructor. If that fails, then it tries to interpret the spec as a file name on the local file system.  If that fails, then it tries to interpret the spec as a resource accessible to the class loader, which uses the classpath to find the resource.  If that fails, then it throws an exception.  The specification can give a file name relative to current working directory, or the directory in which this application is started up.
 * @param spec The specification.
 * @return the URL.
 * @exception IOException If it cannot convert the specification toa URL.
 */
public static URL specToURL(String spec) throws IOException {
  URL specURL=null;
  try {
    specURL=new URL(null,spec);
    InputStream urlStream=specURL.openStream();
    urlStream.close();
    return specURL;
  }
 catch (  Exception ex) {
    try {
      File file=new File(spec);
      File absoluteFile=file.getAbsoluteFile();
      try {
        if (!absoluteFile.exists()) {
          throw new IOException(""String_Node_Str"" + absoluteFile + ""String_Node_Str"");
        }
      }
 catch (      java.security.AccessControlException accessControl) {
        IOException exception=new IOException(""String_Node_Str"" + ""String_Node_Str"" + absoluteFile + ""String_Node_Str"");
        exception.initCause(accessControl);
        throw exception;
      }
      specURL=absoluteFile.getCanonicalFile().toURI().toURL();
      return specURL;
    }
 catch (    Exception ex2) {
      try {
        specURL=Thread.currentThread().getContextClassLoader().getResource(spec);
        if (specURL == null) {
          throw new Exception(""String_Node_Str"" + spec + ""String_Node_Str"");
        }
 else {
          specURL=JNLPUtilities.canonicalizeJarURL(specURL);
          InputStream urlStream=specURL.openStream();
          urlStream.close();
          return specURL;
        }
      }
 catch (      Exception ex3) {
        IOException exception=new IOException(""String_Node_Str"" + spec + ""String_Node_Str""+ ex+ ""String_Node_Str""+ ex2+ ""String_Node_Str""+ ex3);
        exception.initCause(ex3);
        throw exception;
      }
    }
  }
}","/** 
 * Given the name of a file or a URL, convert it to a URL. This first attempts to do that directly by invoking a URL constructor. If that fails, then it tries to interpret the spec as a file name on the local file system.  If that fails, then it tries to interpret the spec as a resource accessible to the class loader, which uses the classpath to find the resource.  If that fails, then it throws an exception.  The specification can give a file name relative to current working directory, or the directory in which this application is started up.
 * @param spec The specification.
 * @return the URL.
 * @exception IOException If it cannot convert the specification toa URL.
 */
public static URL specToURL(String spec) throws IOException {
  URL specURL=null;
  try {
    specURL=new URL(null,spec);
    InputStream urlStream=specURL.openStream();
    urlStream.close();
    return specURL;
  }
 catch (  Exception ex) {
    try {
      File file=new File(spec);
      File absoluteFile=file.getAbsoluteFile();
      try {
        if (!absoluteFile.exists()) {
          throw new IOException(""String_Node_Str"" + absoluteFile + ""String_Node_Str"");
        }
      }
 catch (      java.security.AccessControlException accessControl) {
        IOException exception=new IOException(""String_Node_Str"" + ""String_Node_Str"" + absoluteFile + ""String_Node_Str"");
        exception.initCause(accessControl);
        throw exception;
      }
      specURL=absoluteFile.getCanonicalFile().toURI().toURL();
      return specURL;
    }
 catch (    Throwable throwable) {
      try {
        specURL=Thread.currentThread().getContextClassLoader().getResource(spec);
        if (specURL == null) {
          throw new Exception(""String_Node_Str"" + spec + ""String_Node_Str"");
        }
 else {
          specURL=JNLPUtilities.canonicalizeJarURL(specURL);
          InputStream urlStream=specURL.openStream();
          urlStream.close();
          return specURL;
        }
      }
 catch (      Exception ex3) {
        IOException exception=new IOException(""String_Node_Str"" + spec + ""String_Node_Str""+ ex+ ""String_Node_Str""+ throwable+ ""String_Node_Str""+ ex3);
        exception.initCause(ex3);
        throw exception;
      }
    }
  }
}"
73369,"/** 
 * Return true if the specified file names a directory that contains a file named configuration.xml and a file named intro.htm
 * @param directory the directory in which the potentialdirectory was found.
 * @param name the name of the directory or file.
 * @return true if the file is a directory thatcontains a file called configuration.xml
 */
public boolean accept(File directory,String name){
  try {
    File configurationDirectory=new File(directory,name);
    if (!configurationDirectory.isDirectory()) {
      return false;
    }
    File configurationFile=new File(configurationDirectory,""String_Node_Str"");
    File introFile=new File(configurationDirectory,""String_Node_Str"");
    if (configurationFile.isFile() && introFile.isFile()) {
      return true;
    }
  }
 catch (  Exception ex) {
    return false;
  }
  return false;
}","/** 
 * Return true if the specified file names a directory that contains a file named configuration.xml and a file named intro.htm
 * @param directory the directory in which the potentialdirectory was found.
 * @param name the name of the directory or file.
 * @return true if the file is a directory thatcontains a file called configuration.xml
 */
public boolean accept(File directory,String name){
  try {
    File configurationDirectory=new File(directory,name);
    if (!configurationDirectory.isDirectory()) {
      return false;
    }
    File configurationFile=new File(configurationDirectory,""String_Node_Str"");
    File introFile=new File(configurationDirectory,""String_Node_Str"");
    if (configurationFile.isFile() && introFile.isFile()) {
      return true;
    }
  }
 catch (  Throwable throwable) {
    return false;
  }
  return false;
}"
73370,"/** 
 * Parse a command-line argument.
 * @param arg The command-line argument to be parsed.
 * @return True if the argument is understood, false otherwise.
 * @exception Exception If something goes wrong.
 */
protected boolean _parseArg(String arg) throws Exception {
  if (arg.equals(""String_Node_Str"")) {
    _expectingClass=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _exit=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    System.out.println(_usage());
    StringUtilities.exit(0);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _printPDF=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _run=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _run=true;
    _exit=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _run=true;
    _run20x=true;
    _exit=true;
    Manager.minimumStatisticsTime=1;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _statistics=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _test=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + VersionAttribute.CURRENT_VERSION.getExpression() + ""String_Node_Str"");
    StringUtilities.exit(0);
  }
 else   if (arg.equals(""String_Node_Str"")) {
  }
 else {
    if (_expectingClass) {
      _expectingClass=false;
      Class newClass=Class.forName(arg);
      Workspace workspace=new Workspace();
      Class[] argTypes=new Class[1];
      argTypes[0]=workspace.getClass();
      Constructor constructor=newClass.getConstructor(argTypes);
      Object[] args=new Object[1];
      args[0]=workspace;
      NamedObj newModel=(NamedObj)constructor.newInstance(args);
      System.out.println(""String_Node_Str"" + _configuration);
      if (_configuration != null) {
        _openModel(newModel);
      }
 else {
        System.err.println(""String_Node_Str"");
        throw new IllegalActionException(newModel,""String_Node_Str"");
      }
    }
 else {
      if (!arg.startsWith(""String_Node_Str"")) {
        URL inURL;
        try {
          inURL=specToURL(arg);
        }
 catch (        Exception ex) {
          try {
            File inFile=new File(arg);
            inURL=inFile.toURI().toURL();
          }
 catch (          Exception ex2) {
            if (StringUtilities.inApplet()) {
              inURL=new URL(arg);
            }
 else {
              inURL=new URL(new URL(""String_Node_Str""),arg);
            }
          }
        }
        URL base=inURL;
        if (_configuration != null) {
          ModelDirectory directory=(ModelDirectory)_configuration.getEntity(""String_Node_Str"");
          if (directory == null) {
            throw new InternalErrorException(""String_Node_Str"");
          }
          String key=inURL.toExternalForm();
          _openModel(base,inURL,key);
        }
 else {
          _parser.reset();
          try {
            System.out.println(""String_Node_Str"");
            _configuration=readConfiguration(inURL);
          }
 catch (          Exception ex) {
            String detailMessage=""String_Node_Str"";
            try {
              if ((inURL.toString().indexOf(""String_Node_Str"") != -1) && (inURL.toString().indexOf(""String_Node_Str"") != -1)) {
                detailMessage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
              }
            }
 catch (            Exception ex2) {
            }
            throw new Exception(""String_Node_Str"" + inURL + ""String_Node_Str""+ detailMessage,ex);
          }
        }
      }
 else {
        return false;
      }
    }
  }
  return true;
}","/** 
 * Parse a command-line argument.
 * @param arg The command-line argument to be parsed.
 * @return True if the argument is understood, false otherwise.
 * @exception Exception If something goes wrong.
 */
protected boolean _parseArg(String arg) throws Exception {
  if (arg.equals(""String_Node_Str"")) {
    _expectingClass=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _exit=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    System.out.println(_usage());
    StringUtilities.exit(0);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _printPDF=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _run=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _run=true;
    _exit=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _run=true;
    _run20x=true;
    _exit=true;
    Manager.minimumStatisticsTime=1;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _statistics=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _test=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + VersionAttribute.CURRENT_VERSION.getExpression() + ""String_Node_Str"");
    StringUtilities.exit(0);
  }
 else   if (arg.equals(""String_Node_Str"")) {
  }
 else {
    if (_expectingClass) {
      _expectingClass=false;
      Class newClass=Class.forName(arg);
      Workspace workspace=new Workspace();
      Class[] argTypes=new Class[1];
      argTypes[0]=workspace.getClass();
      Constructor constructor=newClass.getConstructor(argTypes);
      Object[] args=new Object[1];
      args[0]=workspace;
      NamedObj newModel=(NamedObj)constructor.newInstance(args);
      System.out.println(""String_Node_Str"" + _configuration);
      if (_configuration != null) {
        _openModel(newModel);
      }
 else {
        System.err.println(""String_Node_Str"");
        throw new IllegalActionException(newModel,""String_Node_Str"");
      }
    }
 else {
      if (!arg.startsWith(""String_Node_Str"")) {
        URL inURL;
        try {
          inURL=specToURL(arg);
        }
 catch (        IOException ex) {
          try {
            File inFile=new File(arg);
            inURL=inFile.toURI().toURL();
          }
 catch (          Throwable throwable) {
            if (StringUtilities.inApplet()) {
              inURL=new URL(arg);
            }
 else {
              inURL=new URL(new URL(""String_Node_Str""),arg);
            }
          }
        }
        URL base=inURL;
        if (_configuration != null) {
          ModelDirectory directory=(ModelDirectory)_configuration.getEntity(""String_Node_Str"");
          if (directory == null) {
            throw new InternalErrorException(""String_Node_Str"");
          }
          String key=inURL.toExternalForm();
          _openModel(base,inURL,key);
        }
 else {
          _parser.reset();
          try {
            System.out.println(""String_Node_Str"");
            _configuration=readConfiguration(inURL);
          }
 catch (          Exception ex) {
            String detailMessage=""String_Node_Str"";
            try {
              if ((inURL.toString().indexOf(""String_Node_Str"") != -1) && (inURL.toString().indexOf(""String_Node_Str"") != -1)) {
                detailMessage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
              }
            }
 catch (            Throwable throwable) {
            }
            throw new Exception(""String_Node_Str"" + inURL + ""String_Node_Str""+ detailMessage,ex);
          }
        }
      }
 else {
        return false;
      }
    }
  }
  return true;
}"
73371,"/** 
 * Show the SyntacticGraph in a Tableau. 
 */
protected void _showGraph(){
  try {
    Configuration config=(Configuration)Configuration.configurations().get(0);
    _syntaxTableau=config.openInstance(_syntaxGraph);
    _syntaxTableau.show();
  }
 catch (  Exception ex) {
  }
}","/** 
 * Show the SyntacticGraph in a Tableau.
 * @exception IllegalActionException Thrown if there is a problemgetting the configuration, opening the instance of the syntactic graph or showing the tableau.
 */
protected void _showGraph() throws IllegalActionException {
  try {
    Configuration config=(Configuration)Configuration.configurations().get(0);
    _syntaxTableau=config.openInstance(_syntaxGraph);
    _syntaxTableau.show();
  }
 catch (  Exception ex) {
    throw new IllegalActionException(getComponent(),ex,""String_Node_Str"" + ""String_Node_Str"");
  }
}"
73372,"/** 
 * Get the normal of the site.
 */
public double getNormal(){
switch (_side) {
case SwingConstants.NORTH:
    return -Math.PI / 2;
case SwingConstants.SOUTH:
  return Math.PI / 2;
case SwingConstants.EAST:
return 0.0;
case SwingConstants.WEST:
return Math.PI;
}
return 0.0;
}","/** 
 * Get the normal of the site.
 */
public double getNormal(){
switch (_side) {
case SwingConstants.NORTH:
    return -Math.PI / 2;
case SwingConstants.SOUTH:
  return Math.PI / 2;
case SwingConstants.WEST:
return Math.PI;
case SwingConstants.EAST:
default :
return 0.0;
}
}"
73373,"/** 
 * Get the angle of the normal to this site, in radians between zero and 2pi.
 */
public double getNormal(){
switch (_id) {
case SwingConstants.EAST:
    return 0.0;
case SwingConstants.NORTH_EAST:
  return piOver4 * 7;
case SwingConstants.NORTH:
return piOver4 * 6;
case SwingConstants.NORTH_WEST:
return piOver4 * 5;
case SwingConstants.WEST:
return piOver4 * 4;
case SwingConstants.SOUTH_WEST:
return piOver4 * 3;
case SwingConstants.SOUTH:
return piOver4 * 2;
case SwingConstants.SOUTH_EAST:
return piOver4 * 1;
}
return 0.0;
}","/** 
 * Get the angle of the normal to this site, in radians between zero and 2pi.
 */
public double getNormal(){
switch (_id) {
case SwingConstants.NORTH_EAST:
    return piOver4 * 7;
case SwingConstants.NORTH:
  return piOver4 * 6;
case SwingConstants.NORTH_WEST:
return piOver4 * 5;
case SwingConstants.WEST:
return piOver4 * 4;
case SwingConstants.SOUTH_WEST:
return piOver4 * 3;
case SwingConstants.SOUTH:
return piOver4 * 2;
case SwingConstants.SOUTH_EAST:
return piOver4 * 1;
case SwingConstants.EAST:
default :
return 0.0;
}
}"
73374,"/** 
 * Output an Ipl image.
 * @exception IllegalActionException If thrown while writing to the port.   
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    ObjectToken inputToken=(ObjectToken)input.get(0);
    Image inputObject=(Image)inputToken.getValue();
    if (!(inputObject instanceof Image)) {
      throw new IllegalActionException(this,""String_Node_Str"" + inputObject.getClass());
    }
    _frame=new IplImage();
    output.send(0,new ObjectToken(_frame));
  }
}","/** 
 * Output an Ipl image.
 * @exception IllegalActionException If thrown while writing to the port.   
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    ObjectToken inputToken=(ObjectToken)input.get(0);
    Image inputObject=(Image)inputToken.getValue();
    _frame=new IplImage();
    output.send(0,new ObjectToken(_frame));
  }
}"
73375,"/** 
 * Output a frame.
 * @exception IllegalActionException If thrown while writing to the port.   
 */
public void fire() throws IllegalActionException {
  _frame=cvQueryFrame(_capture);
  if (Platform.isWindows() && highgui.libname.indexOf(""String_Node_Str"") > 0) {
    _frame.origin=IPL_ORIGIN_TL;
    cvFlip(_frame,_frame,0);
  }
  output.send(0,new ObjectToken(_frame));
}","/** 
 * Output a frame.
 * @exception IllegalActionException If thrown while writing to the port.   
 */
public void fire() throws IllegalActionException {
  _frame=cvQueryFrame(_capture);
  if (Platform.isWindows() && highgui.libname.indexOf(""String_Node_Str"") >= 0) {
    _frame.origin=IPL_ORIGIN_TL;
    cvFlip(_frame,_frame,0);
  }
  output.send(0,new ObjectToken(_frame));
}"
73376,"public static void main(String[] args) throws Exception {
  IplImage src_img=cvLoadImage(""String_Node_Str"",1);
  IplImage src_gray=cvCreateImage(cvGetSize(src_img),IPL_DEPTH_8U,1);
  cvCvtColor(src_img,src_gray,CV_BGR2GRAY);
  cvEqualizeHist(src_gray,src_gray);
  String libname=cv.libname;
  String version=""String_Node_Str"";
  System.out.println(libname);
  if (libname.indexOf(version) > 0) {
    System.out.println(""String_Node_Str"");
  }
  String cascade_name=""String_Node_Str"";
  CvHaarClassifierCascade cascade=new CvHaarClassifierCascade(cvLoad(cascade_name,null,null,null));
  CvMemStorage storage=cvCreateMemStorage(0);
  cvClearMemStorage(storage);
  CvSize size=new CvSize(40,40);
  CvSeq faces=cvHaarDetectObjects(src_gray,cascade,storage,1.11,4,0,size.byValue());
  int i=0;
  int faceTotal=0;
  if (faces != null)   faceTotal=faces.total;
  CvScalar.ByValue[] colors={CvScalar.RED,CvScalar.BLUE,CvScalar.GREEN,CvScalar.CYAN,CvScalar.YELLOW,CvScalar.MAGENTA,CvScalar.WHITE,CvScalar.GRAY};
  for (i=0; i < faceTotal; i++) {
    Pointer r=cvGetSeqElem(faces,i);
    CvRect rect=new CvRect(r);
    CvPoint center=new CvPoint(0,0);
    int radius;
    center.x=(int)round(rect.x + rect.width * 0.5);
    center.y=(int)round(rect.y + rect.height * 0.5);
    radius=(int)round((rect.width + rect.height) * 0.25);
    cvCircle(src_img,center.byValue(),radius,colors[i % 8],3,8,0);
  }
  cvSaveImage(""String_Node_Str"",src_img);
  cvReleaseImage(src_img.pointerByReference());
  cvReleaseImage(src_gray.pointerByReference());
  cvReleaseMemStorage(storage.pointerByReference());
  System.out.println(""String_Node_Str"");
}","public static void main(String[] args) throws Exception {
  IplImage src_img=cvLoadImage(""String_Node_Str"",1);
  IplImage src_gray=cvCreateImage(cvGetSize(src_img),IPL_DEPTH_8U,1);
  cvCvtColor(src_img,src_gray,CV_BGR2GRAY);
  cvEqualizeHist(src_gray,src_gray);
  String libname=cv.libname;
  String version=""String_Node_Str"";
  System.out.println(libname);
  if (libname.indexOf(version) >= 0) {
    System.out.println(""String_Node_Str"");
  }
  String cascade_name=""String_Node_Str"";
  CvHaarClassifierCascade cascade=new CvHaarClassifierCascade(cvLoad(cascade_name,null,null,null));
  CvMemStorage storage=cvCreateMemStorage(0);
  cvClearMemStorage(storage);
  CvSize size=new CvSize(40,40);
  CvSeq faces=cvHaarDetectObjects(src_gray,cascade,storage,1.11,4,0,size.byValue());
  int i=0;
  int faceTotal=0;
  if (faces != null)   faceTotal=faces.total;
  CvScalar.ByValue[] colors={CvScalar.RED,CvScalar.BLUE,CvScalar.GREEN,CvScalar.CYAN,CvScalar.YELLOW,CvScalar.MAGENTA,CvScalar.WHITE,CvScalar.GRAY};
  for (i=0; i < faceTotal; i++) {
    Pointer r=cvGetSeqElem(faces,i);
    CvRect rect=new CvRect(r);
    CvPoint center=new CvPoint(0,0);
    int radius;
    center.x=(int)round(rect.x + rect.width * 0.5);
    center.y=(int)round(rect.y + rect.height * 0.5);
    radius=(int)round((rect.width + rect.height) * 0.25);
    cvCircle(src_img,center.byValue(),radius,colors[i % 8],3,8,0);
  }
  cvSaveImage(""String_Node_Str"",src_img);
  cvReleaseImage(src_img.pointerByReference());
  cvReleaseImage(src_gray.pointerByReference());
  cvReleaseMemStorage(storage.pointerByReference());
  System.out.println(""String_Node_Str"");
}"
73377,"private boolean evaluateStatement(AST ast) throws IllegalActionException, NameDuplicationException {
switch (ast.getType()) {
case PtalonTokenTypes.DANGLING_PORTS_OKAY:
    break;
case PtalonTokenTypes.ATTACH_DANGLING_PORTS:
  break;
case PtalonTokenTypes.PORT:
return addPort(ast);
case PtalonTokenTypes.MULTIPORT:
return addMultiPort(ast);
case PtalonTokenTypes.INPORT:
return addInPort(ast);
case PtalonTokenTypes.MULTIINPORT:
return addMultiInPort(ast);
case PtalonTokenTypes.OUTPORT:
return addOutPort(ast);
case PtalonTokenTypes.MULTIOUTPORT:
return addMultiOutPort(ast);
case PtalonTokenTypes.PARAMETER:
return addParameter(ast);
case PtalonTokenTypes.PARAM_EQUALS:
break;
case PtalonTokenTypes.ACTOR:
break;
case PtalonTokenTypes.ACTOR_EQUALS:
return addActorDefinition(ast);
case PtalonTokenTypes.RELATION:
return addRelation(ast);
case PtalonTokenTypes.TRANSPARENT:
return addTransparentRelation(ast);
case PtalonTokenTypes.ACTOR_DECLARATION:
return addActorDeclaration(ast);
case PtalonTokenTypes.IF:
break;
case PtalonTokenTypes.FOR:
return addForLoop(ast);
}
return false;
}","private boolean evaluateStatement(AST ast) throws IllegalActionException, NameDuplicationException {
switch (ast.getType()) {
case PtalonTokenTypes.DANGLING_PORTS_OKAY:
case PtalonTokenTypes.ATTACH_DANGLING_PORTS:
case PtalonTokenTypes.PARAM_EQUALS:
case PtalonTokenTypes.ACTOR:
case PtalonTokenTypes.IF:
    break;
case PtalonTokenTypes.PORT:
  return addPort(ast);
case PtalonTokenTypes.MULTIPORT:
return addMultiPort(ast);
case PtalonTokenTypes.INPORT:
return addInPort(ast);
case PtalonTokenTypes.MULTIINPORT:
return addMultiInPort(ast);
case PtalonTokenTypes.OUTPORT:
return addOutPort(ast);
case PtalonTokenTypes.MULTIOUTPORT:
return addMultiOutPort(ast);
case PtalonTokenTypes.PARAMETER:
return addParameter(ast);
case PtalonTokenTypes.ACTOR_EQUALS:
return addActorDefinition(ast);
case PtalonTokenTypes.RELATION:
return addRelation(ast);
case PtalonTokenTypes.TRANSPARENT:
return addTransparentRelation(ast);
case PtalonTokenTypes.ACTOR_DECLARATION:
return addActorDeclaration(ast);
case PtalonTokenTypes.FOR:
return addForLoop(ast);
}
return false;
}"
73378,"/** 
 * Generate code for putting tokens into the receiver.
 * @param sourcePort The port for which to generate the send code.
 * @param offset The offset in the array representation of the port.
 * @param token The token to be sent.
 * @return generate type conversion as well as put code.
 * @exception IllegalActionException If the receiver adapter isnot found or it encounters an error while generating the send code.
 */
public String generatePutCode(IOPort sourcePort,String offset,String token) throws IllegalActionException {
  TypedIOPort sinkPort=(TypedIOPort)getComponent().getContainer();
  if (sinkPort.isOutput()) {
    StringBuffer code=new StringBuffer();
    ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.actor.IOPort portAdapter=(ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.actor.IOPort)getAdapter(sinkPort);
    for (int channel=0; channel < sinkPort.getWidth(); channel++) {
      code.append(portAdapter.generatePutCode(Integer.toString(channel),offset,token));
    }
    return code.toString();
  }
  int sinkChannel=sinkPort.getChannelForReceiver(getComponent());
  Channel source=new Channel(sourcePort,0);
  Channel sink=new Channel(sinkPort,sinkChannel);
  token=((NamedProgramCodeGeneratorAdapter)getAdapter(getComponent().getContainer().getContainer())).getTemplateParser().generateTypeConvertStatement(source,sink,0,token);
  token=_removeSink(token);
  Actor actor=(Actor)sinkPort.getContainer();
  Director director=actor.getDirector();
  String depth=Integer.toString(((CausalityInterfaceForComposites)director.getCausalityInterface()).getDepthOfActor(actor));
  Parameter relativeDeadline=(Parameter)sinkPort.getAttribute(""String_Node_Str"");
  String deadlineSecsString=null;
  String deadlineNsecsString=null;
  if (relativeDeadline != null) {
    double value=((DoubleToken)relativeDeadline.getToken()).doubleValue();
    int intPart=(int)value;
    int fracPart=(int)((value - intPart) * 1000000000.0);
    deadlineSecsString=Integer.toString(intPart);
    deadlineNsecsString=Integer.toString(fracPart);
  }
 else {
    deadlineSecsString=new String(""String_Node_Str"");
    deadlineNsecsString=new String(""String_Node_Str"");
  }
  Parameter offsetTime=(Parameter)sinkPort.getAttribute(""String_Node_Str"");
  String offsetSecsString=null;
  String offsetNsecsString=null;
  if (offsetTime != null) {
    double value=((DoubleToken)((ArrayToken)offsetTime.getToken()).arrayValue()[sinkChannel]).doubleValue();
    int intPart=(int)value;
    int fracPart=(int)((value - intPart) * 1000000000.0);
    offsetSecsString=Integer.toString(intPart);
    offsetNsecsString=Integer.toString(fracPart);
  }
 else {
    throw new IllegalActionException(sinkPort,""String_Node_Str"");
  }
  String sinkName=NamedProgramCodeGeneratorAdapter.generateName(sinkPort.getContainer());
  List args=new ArrayList();
  args.add(sinkPort.getType().toString());
  args.add(token);
  args.add(sinkName);
  args.add(""String_Node_Str"" + sinkName + ""String_Node_Str""+ sinkPort.getName()+ ""String_Node_Str""+ sinkPort.getChannelForReceiver(getComponent())+ ""String_Node_Str"");
  args.add(depth);
  args.add(deadlineSecsString);
  args.add(deadlineNsecsString);
  args.add(offsetSecsString);
  args.add(offsetNsecsString);
  return _templateParser.generateBlockCode(""String_Node_Str"",args);
}","/** 
 * Generate code for putting tokens into the receiver.
 * @param sourcePort The port for which to generate the send code.
 * @param offset The offset in the array representation of the port.
 * @param token The token to be sent.
 * @return generate type conversion as well as put code.
 * @exception IllegalActionException If the receiver adapter isnot found or it encounters an error while generating the send code.
 */
public String generatePutCode(IOPort sourcePort,String offset,String token) throws IllegalActionException {
  TypedIOPort sinkPort=(TypedIOPort)getComponent().getContainer();
  if (sinkPort.isOutput()) {
    StringBuffer code=new StringBuffer();
    ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.actor.IOPort portAdapter=(ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.actor.IOPort)getAdapter(sinkPort);
    for (int channel=0; channel < sinkPort.getWidth(); channel++) {
      code.append(portAdapter.generatePutCode(Integer.toString(channel),offset,token));
    }
    return code.toString();
  }
  int sinkChannel=sinkPort.getChannelForReceiver(getComponent());
  Channel source=new Channel(sourcePort,0);
  Channel sink=new Channel(sinkPort,sinkChannel);
  token=((NamedProgramCodeGeneratorAdapter)getAdapter(getComponent().getContainer().getContainer())).getTemplateParser().generateTypeConvertStatement(source,sink,0,token);
  token=_removeSink(token);
  Actor actor=(Actor)sinkPort.getContainer();
  Director director=actor.getDirector();
  String depth=Integer.toString(((CausalityInterfaceForComposites)director.getCausalityInterface()).getDepthOfActor(actor));
  Parameter relativeDeadline=(Parameter)sinkPort.getAttribute(""String_Node_Str"");
  String deadlineSecsString=null;
  String deadlineNsecsString=null;
  if (relativeDeadline != null) {
    double value=((DoubleToken)relativeDeadline.getToken()).doubleValue();
    int intPart=(int)value;
    int fracPart=(int)((value - intPart) * 1000000000.0);
    deadlineSecsString=Integer.toString(intPart);
    deadlineNsecsString=Integer.toString(fracPart);
  }
 else {
    deadlineSecsString=""String_Node_Str"";
    deadlineNsecsString=""String_Node_Str"";
  }
  Parameter offsetTime=(Parameter)sinkPort.getAttribute(""String_Node_Str"");
  String offsetSecsString=null;
  String offsetNsecsString=null;
  if (offsetTime != null) {
    double value=((DoubleToken)((ArrayToken)offsetTime.getToken()).arrayValue()[sinkChannel]).doubleValue();
    int intPart=(int)value;
    int fracPart=(int)((value - intPart) * 1000000000.0);
    offsetSecsString=Integer.toString(intPart);
    offsetNsecsString=Integer.toString(fracPart);
  }
 else {
    throw new IllegalActionException(sinkPort,""String_Node_Str"");
  }
  String sinkName=NamedProgramCodeGeneratorAdapter.generateName(sinkPort.getContainer());
  List args=new ArrayList();
  args.add(sinkPort.getType().toString());
  args.add(token);
  args.add(sinkName);
  args.add(""String_Node_Str"" + sinkName + ""String_Node_Str""+ sinkPort.getName()+ ""String_Node_Str""+ sinkPort.getChannelForReceiver(getComponent())+ ""String_Node_Str"");
  args.add(depth);
  args.add(deadlineSecsString);
  args.add(deadlineNsecsString);
  args.add(offsetSecsString);
  args.add(offsetNsecsString);
  return _templateParser.generateBlockCode(""String_Node_Str"",args);
}"
73379,"/** 
 * Traverse all the entities in the model and place them in the sensors and actuators variables.
 */
protected void _modelStaticAnalysis(){
  int actuatorIndex=0;
  int sensorIndex=0;
  for (  Actor actor : (List<Actor>)((CompositeActor)_director.getContainer()).deepEntityList()) {
    if (actor instanceof ActuatorSetup) {
      actuators.put(actor,new Integer(actuatorIndex));
      actuatorIndex++;
    }
    if (actor instanceof SensorHandler) {
      sensors.put(actor,new Integer(sensorIndex));
      sensorIndex++;
    }
  }
}","/** 
 * Traverse all the entities in the model and place them in the sensors and actuators variables.
 */
protected void _modelStaticAnalysis(){
  int actuatorIndex=0;
  int sensorIndex=0;
  for (  Actor actor : (List<Actor>)((CompositeActor)_director.getContainer()).deepEntityList()) {
    if (actor instanceof ActuatorSetup) {
      actuators.put(actor,Integer.valueOf(actuatorIndex));
      actuatorIndex++;
    }
    if (actor instanceof SensorHandler) {
      sensors.put(actor,Integer.valueOf(sensorIndex));
      sensorIndex++;
    }
  }
}"
73380,"/** 
 * Generate the assembly file associated for this PtidyOS program. Here we return an empty string, but the target specific adapter should overwrite it.
 * @return The generated assembly file code.
 * @exception IllegalActionException
 */
public StringBuffer generateAsseblyFile() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  if (((CompositeActor)getComponent().getContainer()).getExecutiveDirector() instanceof ptolemy.domains.ptides.kernel.PtidesBasicDirector) {
    return code;
  }
  Map devices=new HashMap<Actor,String>();
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)getComponent().getContainer()).deepEntityList()) {
    if (actor instanceof LuminarySensorHandler) {
      devices.put(actor,new String(""String_Node_Str"" + NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor)));
    }
  }
  List args=new LinkedList();
  StringBuffer externs=new StringBuffer();
  for (  Actor actor : (Set<Actor>)devices.keySet()) {
    externs.append(""String_Node_Str"" + devices.get(actor) + _eol);
  }
  args.add(externs.toString());
  int configurationSize=LuminarySensorHandler.numberOfSupportedInputDeviceConfigurations;
  String[] GPHandlers=new String[configurationSize];
  boolean foundConfig=false;
  for (  LuminarySensorHandler actor : (Set<LuminarySensorHandler>)devices.keySet()) {
    for (int i=0; i < actor.supportedConfigurations().size(); i++) {
      if (actor.configuration().compareTo(actor.supportedConfigurations().get(i)) == 0) {
        GPHandlers[i + Integer.parseInt(actor.startingConfiguration())]=(String)devices.get(actor);
        foundConfig=true;
        break;
      }
    }
    if (foundConfig == false) {
      throw new IllegalActionException(actor,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  for (int i=0; i < configurationSize; i++) {
    if (GPHandlers[i] == null) {
      args.add(""String_Node_Str"");
    }
 else {
      args.add(GPHandlers[i]);
    }
  }
  code.append(_templateParser.getCodeStream().getCodeBlock(""String_Node_Str"",args));
  return code;
}","/** 
 * Generate the assembly file associated for this PtidyOS program. Here we return an empty string, but the target specific adapter should overwrite it.
 * @return The generated assembly file code.
 * @exception IllegalActionException
 */
public StringBuffer generateAsseblyFile() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  if (((CompositeActor)getComponent().getContainer()).getExecutiveDirector() instanceof ptolemy.domains.ptides.kernel.PtidesBasicDirector) {
    return code;
  }
  Map<LuminarySensorHandler,String> devices=new HashMap<LuminarySensorHandler,String>();
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)getComponent().getContainer()).deepEntityList()) {
    if (actor instanceof LuminarySensorHandler) {
      devices.put((LuminarySensorHandler)actor,""String_Node_Str"" + NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor));
    }
  }
  List args=new LinkedList();
  StringBuffer externs=new StringBuffer();
  for (  LuminarySensorHandler actor : (Set<LuminarySensorHandler>)devices.keySet()) {
    externs.append(""String_Node_Str"" + devices.get(actor) + _eol);
  }
  args.add(externs.toString());
  int configurationSize=LuminarySensorHandler.numberOfSupportedInputDeviceConfigurations;
  String[] GPHandlers=new String[configurationSize];
  boolean foundConfig=false;
  for (  Map.Entry<LuminarySensorHandler,String> entry : devices.entrySet()) {
    LuminarySensorHandler actor=entry.getKey();
    String actorName=entry.getValue();
    for (int i=0; i < actor.supportedConfigurations().size(); i++) {
      if (actor.configuration().compareTo(actor.supportedConfigurations().get(i)) == 0) {
        GPHandlers[i + Integer.parseInt(actor.startingConfiguration())]=actorName;
        foundConfig=true;
        break;
      }
    }
    if (foundConfig == false) {
      throw new IllegalActionException(actor,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  for (int i=0; i < configurationSize; i++) {
    if (GPHandlers[i] == null) {
      args.add(""String_Node_Str"");
    }
 else {
      args.add(GPHandlers[i]);
    }
  }
  code.append(_templateParser.getCodeStream().getCodeBlock(""String_Node_Str"",args));
  return code;
}"
73381,"/** 
 * Generate The fire function code. This method is called when the firing code of each actor is not inlined. Each actor's firing code is in a function with the same name as that of the actor.
 * @return The fire function code.
 * @exception IllegalActionException If thrown while generating fire code.
 */
public String generateFireFunctionCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  Actor actor;
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)getComponent().getContainer();
  getCodeGenerator().getAdapter(container);
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    actor=(Actor)actors.next();
    getAdapter(actor);
    if (actor.getDisplayName().contains(""String_Node_Str"")) {
    }
  }
  return code.toString();
}","/** 
 * Generate The fire function code. This method is called when the firing code of each actor is not inlined. Each actor's firing code is in a function with the same name as that of the actor.
 * @return The fire function code.
 * @exception IllegalActionException If thrown while generating fire code.
 */
public String generateFireFunctionCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  Actor actor;
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)getComponent().getContainer();
  getCodeGenerator().getAdapter(container);
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    actor=(Actor)actors.next();
    getAdapter(actor);
  }
  return code.toString();
}"
73382,"/** 
 * Return the replacement string of the given macro. Subclass of GenericCodeGenerator may overriding this method to extend or support a different set of macros.
 * @param macro The given macro.
 * @param parameter The given parameter to the macro.
 * @return The replacement string of the given macro.
 * @exception IllegalActionException Thrown if the given macro orparameter is not valid.
 */
protected String _replaceMacro(String macro,String parameter) throws IllegalActionException {
  if (_codeGenerator == null) {
    throw new NullPointerException(""String_Node_Str"" + ""String_Node_Str"");
  }
  int indexOfDollarSign=macro.indexOf('$');
  if (indexOfDollarSign >= 0) {
    String result=""String_Node_Str"" + macro.substring(0,indexOfDollarSign);
    String innerMacro=macro.substring(indexOfDollarSign + 1,macro.length());
    result+=_replaceMacro(innerMacro,parameter);
    return result;
  }
  if (macro.equals(""String_Node_Str"")) {
    return _replaceGetMacro(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return _replacePutMacro(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return _replaceHasTokenMacro(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    CGException.throwException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return _replaceParameter(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    TypedIOPort port=getPort(parameter);
    if (port != null) {
      return _getCodeGenerator().targetType(port.getType());
    }
    Variable variable=_getVariable(parameter);
    if (variable != null) {
      return _getCodeGenerator().targetType(variable.getType());
    }
    CGException.throwException(parameter + ""String_Node_Str"");
  }
 else   if (macro.equals(""String_Node_Str"") || macro.equals(""String_Node_Str"")) {
    String type=""String_Node_Str"";
    if (macro.equals(""String_Node_Str"")) {
      type=""String_Node_Str"";
    }
    TypedIOPort port=getPort(parameter);
    if (port != null) {
      return type + _getCodeGenerator().codeGenType(port.getType());
    }
    Variable variable=_getVariable(parameter);
    if (variable != null) {
      return type + _getCodeGenerator().codeGenType(variable.getType());
    }
    CGException.throwException(parameter + ""String_Node_Str"");
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return getParameterValue(parameter,(NamedObj)_component);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return ""String_Node_Str"" + getSize(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    if (parameter.trim().length() == 0) {
      return _codeGenerator.generateVariableName(((NamedObj)_component));
    }
 else {
      return _codeGenerator.generateVariableName(((NamedObj)_component)) + ""String_Node_Str"" + processCode(parameter);
    }
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return ((NamedObj)_component).getClassName().replace('.','_') + ""String_Node_Str"" + processCode(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return getNewInvocation(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return getFunctionInvocation(parameter,false);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return getFunctionInvocation(parameter,true);
  }
 else {
    try {
      Method method=getClass().getMethod(macro,new Class[0]);
      return (String)method.invoke(this,new Object[0]);
    }
 catch (    Exception ex) {
    }
    Method handler=null;
    Method checker=null;
    Class<?> userMacro=null;
    try {
      userMacro=Class.forName(""String_Node_Str"" + macro);
      handler=userMacro.getMethod(""String_Node_Str"",new Class[]{List.class});
      checker=userMacro.getMethod(""String_Node_Str"",new Class[]{List.class});
    }
 catch (    Throwable throwable) {
      return null;
    }
    try {
      checker.invoke(userMacro,new Object[]{parseList(parameter)});
      return (String)handler.invoke(userMacro,new Object[]{parseList(parameter)});
    }
 catch (    Throwable throwable) {
      CGException.throwException(_component,throwable,""String_Node_Str"" + macro + ""String_Node_Str"");
    }
  }
  return ""String_Node_Str"";
}","/** 
 * Return the replacement string of the given macro. Subclass of GenericCodeGenerator may overriding this method to extend or support a different set of macros.
 * @param macro The given macro.
 * @param parameter The given parameter to the macro.
 * @return The replacement string of the given macro.
 * @exception IllegalActionException Thrown if the given macro orparameter is not valid.
 */
protected String _replaceMacro(String macro,String parameter) throws IllegalActionException {
  if (_codeGenerator == null) {
    throw new NullPointerException(""String_Node_Str"" + ""String_Node_Str"");
  }
  int indexOfDollarSign=macro.indexOf('$');
  if (indexOfDollarSign >= 0) {
    String result=""String_Node_Str"" + macro.substring(0,indexOfDollarSign);
    String innerMacro=macro.substring(indexOfDollarSign + 1,macro.length());
    result+=_replaceMacro(innerMacro,parameter);
    return result;
  }
  if (macro.equals(""String_Node_Str"")) {
    return _replaceGetMacro(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return _replacePutMacro(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return _replaceHasTokenMacro(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    CGException.throwException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return _replaceParameter(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    TypedIOPort port=getPort(parameter);
    if (port != null) {
      return _getCodeGenerator().targetType(port.getType());
    }
    Variable variable=_getVariable(parameter);
    if (variable != null) {
      return _getCodeGenerator().targetType(variable.getType());
    }
    CGException.throwException(parameter + ""String_Node_Str"");
  }
 else   if (macro.equals(""String_Node_Str"") || macro.equals(""String_Node_Str"")) {
    String type=""String_Node_Str"";
    if (macro.equals(""String_Node_Str"")) {
      type=""String_Node_Str"";
    }
    TypedIOPort port=getPort(parameter);
    if (port != null) {
      return type + _getCodeGenerator().codeGenType(port.getType());
    }
    Variable variable=_getVariable(parameter);
    if (variable != null) {
      return type + _getCodeGenerator().codeGenType(variable.getType());
    }
    CGException.throwException(parameter + ""String_Node_Str"");
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return getParameterValue(parameter,(NamedObj)_component);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return ""String_Node_Str"" + getSize(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    if (parameter.trim().length() == 0) {
      return _codeGenerator.generateVariableName(((NamedObj)_component));
    }
 else {
      return _codeGenerator.generateVariableName(((NamedObj)_component)) + ""String_Node_Str"" + processCode(parameter);
    }
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return ((NamedObj)_component).getClassName().replace('.','_') + ""String_Node_Str"" + processCode(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return getNewInvocation(parameter);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return getFunctionInvocation(parameter,false);
  }
 else   if (macro.equals(""String_Node_Str"")) {
    return getFunctionInvocation(parameter,true);
  }
 else {
    try {
      Method method=getClass().getMethod(macro,new Class[0]);
      return (String)method.invoke(this,new Object[0]);
    }
 catch (    Throwable throwable) {
    }
    Method handler=null;
    Method checker=null;
    Class<?> userMacro=null;
    try {
      userMacro=Class.forName(""String_Node_Str"" + macro);
      handler=userMacro.getMethod(""String_Node_Str"",new Class[]{List.class});
      checker=userMacro.getMethod(""String_Node_Str"",new Class[]{List.class});
    }
 catch (    Throwable throwable) {
      return null;
    }
    try {
      checker.invoke(userMacro,new Object[]{parseList(parameter)});
      return (String)handler.invoke(userMacro,new Object[]{parseList(parameter)});
    }
 catch (    Throwable throwable) {
      CGException.throwException(_component,throwable,""String_Node_Str"" + macro + ""String_Node_Str"");
    }
  }
  return ""String_Node_Str"";
}"
73383,"/** 
 * Return an unique label for the given port channel referenced by the given helper. By default, this delegates to the helper to generate the reference. Subclass may override this method to generate the desire label according to the given parameters.
 * @param port The given port.
 * @param channelAndOffset The given channel and offset.
 * @param forComposite Whether the given helper is associated witha CompositeActor
 * @param isWrite The type of the reference. True if this isa write reference; otherwise, this is a read reference.
 * @param helper The specified helper.
 * @return an unique reference label for the given port channel.
 * @exception IllegalActionException If the helper throws it whilegenerating the label.
 */
public String getReference(TypedIOPort port,String[] channelAndOffset,boolean forComposite,boolean isWrite,CodeGeneratorHelper helper) throws IllegalActionException {
  if (port.isOutput()) {
    if (channelAndOffset[0] == ""String_Node_Str"") {
      channelAndOffset[0]=""String_Node_Str"";
    }
    return CodeGeneratorHelper.generateName(port);
  }
 else {
    return super.getReference(port,channelAndOffset,forComposite,isWrite,helper);
  }
}","/** 
 * Return an unique label for the given port channel referenced by the given helper. By default, this delegates to the helper to generate the reference. Subclass may override this method to generate the desire label according to the given parameters.
 * @param port The given port.
 * @param channelAndOffset The given channel and offset.
 * @param forComposite Whether the given helper is associated witha CompositeActor
 * @param isWrite The type of the reference. True if this isa write reference; otherwise, this is a read reference.
 * @param helper The specified helper.
 * @return an unique reference label for the given port channel.
 * @exception IllegalActionException If the helper throws it whilegenerating the label.
 */
public String getReference(TypedIOPort port,String[] channelAndOffset,boolean forComposite,boolean isWrite,CodeGeneratorHelper helper) throws IllegalActionException {
  if (port.isOutput()) {
    if (channelAndOffset[0].equals(""String_Node_Str"")) {
      channelAndOffset[0]=""String_Node_Str"";
    }
    return CodeGeneratorHelper.generateName(port);
  }
 else {
    return super.getReference(port,channelAndOffset,forComposite,isWrite,helper);
  }
}"
73384,"/** 
 * Return a reference to the driver. This method is similar to the getReference() method however it it tailored  for use by a driver method.
 * @param port The port whose information is desired.
 * @param channelAndOffset The given channel and offset.
 * @param forComposite Whether the given helper is associated witha CompositeActor
 * @param isWrite The type of the reference. True if this isa write reference; otherwise, this is a read reference.
 * @param helper The specified helper.
 * @return an unique reference label for the given port channel.
 * @exception IllegalActionException If the helper throws it whilegenerating the label.
 */
public String getDriverReference(TypedIOPort port,String[] channelAndOffset,boolean forComposite,boolean isWrite,CodeGeneratorHelper helper) throws IllegalActionException {
  if (port.isOutput()) {
    if (channelAndOffset[0] == ""String_Node_Str"") {
      channelAndOffset[0]=""String_Node_Str"";
    }
    return CodeGeneratorHelper.generateName(port) + ""String_Node_Str"";
  }
 else {
    return super.getReference(port,channelAndOffset,forComposite,isWrite,helper);
  }
}","/** 
 * Return a reference to the driver. This method is similar to the getReference() method however it it tailored  for use by a driver method.
 * @param port The port whose information is desired.
 * @param channelAndOffset The given channel and offset.
 * @param forComposite Whether the given helper is associated witha CompositeActor
 * @param isWrite The type of the reference. True if this isa write reference; otherwise, this is a read reference.
 * @param helper The specified helper.
 * @return an unique reference label for the given port channel.
 * @exception IllegalActionException If the helper throws it whilegenerating the label.
 */
public String getDriverReference(TypedIOPort port,String[] channelAndOffset,boolean forComposite,boolean isWrite,CodeGeneratorHelper helper) throws IllegalActionException {
  if (port.isOutput()) {
    if (channelAndOffset[0].equals(""String_Node_Str"")) {
      channelAndOffset[0]=""String_Node_Str"";
    }
    return CodeGeneratorHelper.generateName(port) + ""String_Node_Str"";
  }
 else {
    return super.getReference(port,channelAndOffset,forComposite,isWrite,helper);
  }
}"
73385,"private String _generateActorsCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)_director.getContainer()).deepEntityList()) {
    System.out.println(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str""+ actor.getDirector().getFullName());
    CodeGeneratorHelper actorHelper=(CodeGeneratorHelper)_getHelper((NamedObj)actor);
    code.append(""String_Node_Str"");
    if (actor instanceof CompositeActor) {
      if (actor.getDirector() instanceof ptolemy.domains.sdf.kernel.SDFDirector) {
        for (        Actor actor1 : (List<Actor>)((TypedCompositeActor)actor.getDirector().getContainer()).deepEntityList()) {
          System.out.println(""String_Node_Str"" + actor1.getFullName());
          CodeGeneratorHelper actor1Helper=(CodeGeneratorHelper)_getHelper((NamedObj)actor1);
          code.append(actor1Helper.generateFireFunctionCode());
        }
      }
    }
    code.append(""String_Node_Str"");
    String actorFullName=_getActorName(actor);
    String methodSignature=_eol + ""String_Node_Str"" + actorFullName+ _getFireFunctionArguments()+ ""String_Node_Str""+ _eol;
    String srcReference;
    String sinkReference;
    Iterator<IOPort> inputPorts;
    inputPorts=actor.inputPortList().iterator();
    Director dir=actor.getDirector();
    if (actor instanceof CompositeActor) {
      if (dir == null) {
        code.append(methodSignature);
        while (inputPorts.hasNext()) {
          IOPort inputPort=inputPorts.next();
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          super.generateTransferInputsCode(inputPort,code);
          super.generateTransferOutputsCode(inputPort,code);
          code.append(_eol + ""String_Node_Str"" + _eol);
        }
        code.append(""String_Node_Str"" + _eol);
      }
 else       if ((dir.getClassName() == ""String_Node_Str"") || dir.getClassName() == ""String_Node_Str"") {
        if (actor.getClass().getName().contains(""String_Node_Str"")) {
          CodeGeneratorHelper myHelper;
          StringBuffer actorTransferCode=new StringBuffer(""String_Node_Str"");
          while (inputPorts.hasNext()) {
            IOPort sourcePort=(IOPort)inputPorts.next();
            String channelOffset[]={""String_Node_Str"",""String_Node_Str""};
            int i=sourcePort.getWidth();
            myHelper=(CodeGeneratorHelper)this._getHelper(sourcePort.getContainer());
            if (i > 1) {
              for (int j=0; j < i; j++) {
                actorTransferCode.append(""String_Node_Str"");
              }
            }
 else {
              channelOffset[0]=""String_Node_Str"";
              sinkReference=this.getReference((TypedIOPort)sourcePort,channelOffset,false,true,myHelper);
              srcReference=this.getDriverReference((TypedIOPort)sourcePort,channelOffset,false,true,myHelper);
              ArrayList args=new ArrayList();
              args.add(sinkReference);
              args.add(srcReference);
              actorTransferCode.append(_generateBlockCode(""String_Node_Str"",args));
            }
          }
          code.append(methodSignature);
          inputPorts=actor.inputPortList().iterator();
          String channelOffset[]={""String_Node_Str"",""String_Node_Str""};
          ArrayList args=new ArrayList();
          while (inputPorts.hasNext()) {
            IOPort source=inputPorts.next();
            myHelper=(CodeGeneratorHelper)this._getHelper(source.getContainer());
            IOPort sink;
            Iterator<IOPort> sinkPorts=source.deepInsidePortList().iterator();
            while (sinkPorts.hasNext()) {
              sink=sinkPorts.next();
              sinkReference=super.getReference((TypedIOPort)sink,channelOffset,false,true,myHelper);
              srcReference=super.getReference((TypedIOPort)source,channelOffset,false,true,myHelper);
              args.add(sinkReference);
              args.add(srcReference);
              actorTransferCode.append(_generateBlockCode(""String_Node_Str"",args));
            }
          }
          code.append(_eol + actorTransferCode.toString() + _eol);
          code.append(_getActorName(actor) + ""String_Node_Str"" + _eol);
          code.append(""String_Node_Str"" + _eol);
        }
 else {
          code.append(methodSignature);
          code.append(_eol + ""String_Node_Str"" + _eol);
          code.append(actorHelper.generateFireFunctionCode2());
          code.append(""String_Node_Str"" + _eol);
        }
      }
 else {
      }
    }
 else {
      code.append(methodSignature);
      code.append(_eol + ""String_Node_Str"" + _eol);
      String temp=actorHelper.generateFireFunctionCode2();
      if (temp.length() == 0) {
        code.append(actorHelper.generateFireCode());
      }
 else {
        code.append(temp);
      }
      code.append(""String_Node_Str"" + _eol);
    }
  }
  return code.toString();
}","private String _generateActorsCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)_director.getContainer()).deepEntityList()) {
    System.out.println(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str""+ actor.getDirector().getFullName());
    CodeGeneratorHelper actorHelper=(CodeGeneratorHelper)_getHelper((NamedObj)actor);
    code.append(""String_Node_Str"");
    if (actor instanceof CompositeActor) {
      if (actor.getDirector() instanceof ptolemy.domains.sdf.kernel.SDFDirector) {
        for (        Actor actor1 : (List<Actor>)((TypedCompositeActor)actor.getDirector().getContainer()).deepEntityList()) {
          System.out.println(""String_Node_Str"" + actor1.getFullName());
          CodeGeneratorHelper actor1Helper=(CodeGeneratorHelper)_getHelper((NamedObj)actor1);
          code.append(actor1Helper.generateFireFunctionCode());
        }
      }
    }
    code.append(""String_Node_Str"");
    String actorFullName=_getActorName(actor);
    String methodSignature=_eol + ""String_Node_Str"" + actorFullName+ _getFireFunctionArguments()+ ""String_Node_Str""+ _eol;
    String srcReference;
    String sinkReference;
    Iterator<IOPort> inputPorts;
    inputPorts=actor.inputPortList().iterator();
    Director dir=actor.getDirector();
    if (actor instanceof CompositeActor) {
      if (dir == null) {
        code.append(methodSignature);
        while (inputPorts.hasNext()) {
          IOPort inputPort=inputPorts.next();
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          super.generateTransferInputsCode(inputPort,code);
          super.generateTransferOutputsCode(inputPort,code);
          code.append(_eol + ""String_Node_Str"" + _eol);
        }
        code.append(""String_Node_Str"" + _eol);
      }
 else       if (dir.getClassName().equals(""String_Node_Str"") || dir.getClassName().equals(""String_Node_Str"")) {
        if (actor.getClass().getName().contains(""String_Node_Str"")) {
          CodeGeneratorHelper myHelper;
          StringBuffer actorTransferCode=new StringBuffer(""String_Node_Str"");
          while (inputPorts.hasNext()) {
            IOPort sourcePort=(IOPort)inputPorts.next();
            String channelOffset[]={""String_Node_Str"",""String_Node_Str""};
            int i=sourcePort.getWidth();
            myHelper=(CodeGeneratorHelper)this._getHelper(sourcePort.getContainer());
            if (i > 1) {
              for (int j=0; j < i; j++) {
                actorTransferCode.append(""String_Node_Str"");
              }
            }
 else {
              channelOffset[0]=""String_Node_Str"";
              sinkReference=this.getReference((TypedIOPort)sourcePort,channelOffset,false,true,myHelper);
              srcReference=this.getDriverReference((TypedIOPort)sourcePort,channelOffset,false,true,myHelper);
              ArrayList args=new ArrayList();
              args.add(sinkReference);
              args.add(srcReference);
              actorTransferCode.append(_generateBlockCode(""String_Node_Str"",args));
            }
          }
          code.append(methodSignature);
          inputPorts=actor.inputPortList().iterator();
          String channelOffset[]={""String_Node_Str"",""String_Node_Str""};
          ArrayList args=new ArrayList();
          while (inputPorts.hasNext()) {
            IOPort source=inputPorts.next();
            myHelper=(CodeGeneratorHelper)this._getHelper(source.getContainer());
            IOPort sink;
            Iterator<IOPort> sinkPorts=source.deepInsidePortList().iterator();
            while (sinkPorts.hasNext()) {
              sink=sinkPorts.next();
              sinkReference=super.getReference((TypedIOPort)sink,channelOffset,false,true,myHelper);
              srcReference=super.getReference((TypedIOPort)source,channelOffset,false,true,myHelper);
              args.add(sinkReference);
              args.add(srcReference);
              actorTransferCode.append(_generateBlockCode(""String_Node_Str"",args));
            }
          }
          code.append(_eol + actorTransferCode.toString() + _eol);
          code.append(_getActorName(actor) + ""String_Node_Str"" + _eol);
          code.append(""String_Node_Str"" + _eol);
        }
 else {
          code.append(methodSignature);
          code.append(_eol + ""String_Node_Str"" + _eol);
          code.append(actorHelper.generateFireFunctionCode2());
          code.append(""String_Node_Str"" + _eol);
        }
      }
 else {
      }
    }
 else {
      code.append(methodSignature);
      code.append(_eol + ""String_Node_Str"" + _eol);
      String temp=actorHelper.generateFireFunctionCode2();
      if (temp.length() == 0) {
        code.append(actorHelper.generateFireCode());
      }
 else {
        code.append(temp);
      }
      code.append(""String_Node_Str"" + _eol);
    }
  }
  return code.toString();
}"
73386,"public static void main(String[] args){
  int fps=DEFAULT_FPS;
  long period=(long)1000.0 / fps;
  System.out.println(""String_Node_Str"" + fps + ""String_Node_Str""+ period+ ""String_Node_Str"");
  new TourModelsGL(period * 1000000L);
}","public static void main(String[] args){
  try {
    Runnable doActions=new Runnable(){
      public void run(){
        try {
          int fps=DEFAULT_FPS;
          long period=(long)1000.0 / fps;
          System.out.println(""String_Node_Str"" + fps + ""String_Node_Str""+ period+ ""String_Node_Str"");
          new TourModelsGL(period * 1000000L);
        }
 catch (        Exception ex) {
          System.err.println(ex.toString());
          ex.printStackTrace();
        }
      }
    }
;
    SwingUtilities.invokeAndWait(doActions);
  }
 catch (  Exception ex) {
    System.err.println(ex.toString());
    ex.printStackTrace();
  }
}"
73387,"/** 
 * Main method that can be used for testing.
 * @param args An array of length 1 that names the portto be used
 * @exception Exception If anything goes wrong.
 */
public static void main(String[] args) throws Exception {
  int timOut=10000;
  Server[] ser=new Server[2];
  ser[0]=new Server(Integer.valueOf(args[0]),timOut);
  ser[1]=new Server(Integer.valueOf(args[0]) + 1,timOut);
  double[] dbl=new double[1];
  for (int i=0; i < dbl.length; i++) {
    dbl[i]=i;
  }
  int iLoo=0;
  while (true) {
    for (int iSer=0; iSer < 2; iSer++) {
      Thread.sleep(10);
      ser[iSer].read();
      ser[iSer].write(0,new Double(iLoo).doubleValue(),dbl);
      System.out.println(""String_Node_Str"" + iLoo);
    }
    iLoo++;
  }
}","/** 
 * Main method that can be used for testing.
 * @param args An array of length 1 that names the portto be used
 * @exception Exception If anything goes wrong.
 */
public static void main(String[] args) throws Exception {
  int timOut=10000;
  Server[] ser=new Server[2];
  ser[0]=new Server(Integer.valueOf(args[0]),timOut);
  ser[1]=new Server(Integer.valueOf(args[0]) + 1,timOut);
  double[] dbl=new double[1];
  for (int i=0; i < dbl.length; i++) {
    dbl[i]=i;
  }
  int iLoo=0;
  while (true) {
    for (int iSer=0; iSer < 2; iSer++) {
      Thread.sleep(10);
      ser[iSer].read();
      ser[iSer].write(0,Double.valueOf(iLoo).doubleValue(),dbl);
      System.out.println(""String_Node_Str"" + iLoo);
    }
    iLoo++;
  }
}"
73388,"/** 
 * Create an XML string representation of XMLDBAttribute object.
 * @return The XML string representation of XMLDBAttribute object.
 */
public String getAttributeXMLStringFormat(){
  String attributeNode=""String_Node_Str"" + _attributeId + ""String_Node_Str""+ ""String_Node_Str""+ _attributeName+ ""String_Node_Str""+ _attributeType+ ""String_Node_Str"";
  StringBuffer attributeBuffer=new StringBuffer(attributeNode);
  if (_attributeType.equalsIgnoreCase(XMLDBAttribute.ATTRIBUTE_TYPE_LIST)) {
    if (_attributeValues != null && _attributeValues.size() > 0) {
      for (int i=0; i < _attributeValues.size(); i++) {
        attributeBuffer.append(""String_Node_Str"" + _attributeValues.get(i).toString() + ""String_Node_Str"");
      }
    }
  }
  attributeBuffer.append(""String_Node_Str"");
  attributeNode=attributeBuffer.toString();
  return attributeNode;
}","/** 
 * Create an XML string representation of XMLDBAttribute object.
 * @return The XML string representation of XMLDBAttribute object.
 */
public String getAttributeXMLStringFormat(){
  String attributeNode=""String_Node_Str"" + _attributeId + ""String_Node_Str""+ ""String_Node_Str""+ _attributeName+ ""String_Node_Str""+ _attributeType+ ""String_Node_Str"";
  StringBuffer attributeBuffer=new StringBuffer(attributeNode);
  if (_attributeType.equalsIgnoreCase(XMLDBAttribute.ATTRIBUTE_TYPE_LIST)) {
    if (_attributeValues != null && _attributeValues.size() > 0) {
      for (int i=0; i < _attributeValues.size(); i++) {
        attributeBuffer.append(""String_Node_Str"" + _attributeValues.get(i) + ""String_Node_Str"");
      }
    }
  }
  attributeBuffer.append(""String_Node_Str"");
  attributeNode=attributeBuffer.toString();
  return attributeNode;
}"
73389,"/** 
 * Construct a SaveModelToDBFrame. Add swing Components to the frame. Add listeners for the ""Save"" and ""Cancel"" buttons.
 * @param model The model that is being saved to the database.
 * @param source The source frame.  Used to set modified to false uponsuccessful save.
 */
public SaveModelToDBFrame(NamedObj model,ActorGraphDBFrame source){
  super(""String_Node_Str"");
  setLayout(new BoxLayout(this.getContentPane(),BoxLayout.Y_AXIS));
  _source=source;
  _modelToSave=model;
  _initialModelName=model.getName();
  _orignialAttributes=new ArrayList();
  _attributesListPanel=new AttributesListPanel(_modelToSave);
  _tabbedPane=new JTabbedPane();
  try {
    if (!_isNew()) {
      _xmlModel=new XMLDBModel(_modelToSave.getName());
      _xmlModel.setModelId(Utilities.getIdFromModel(_modelToSave));
    }
  }
 catch (  NameDuplicationException e1) {
  }
catch (  IllegalActionException e1) {
  }
  for (  Object attribute : _modelToSave.attributeList()) {
    if (attribute instanceof StringParameter) {
      if (!((StringParameter)attribute).getName().equals(XMLDBModel.DB_REFERENCE_ATTR) && !((StringParameter)attribute).getName().equals(XMLDBModel.DB_MODEL_ID_ATTR) && _attributesListPanel.isDBAttribute(((StringParameter)attribute).getName())) {
        _orignialAttributes.add((StringParameter)attribute);
      }
    }
  }
  JPanel topPanel=new JPanel();
  JPanel bottomPanel=new JPanel();
  _attributesListPanel.setAlignmentX(LEFT_ALIGNMENT);
  _tabbedPane.setAlignmentX(LEFT_ALIGNMENT);
  topPanel.setAlignmentX(LEFT_ALIGNMENT);
  bottomPanel.setAlignmentX(LEFT_ALIGNMENT);
  _attributesListPanel.setAlignmentY(TOP_ALIGNMENT);
  _tabbedPane.setAlignmentY(TOP_ALIGNMENT);
  topPanel.setAlignmentY(TOP_ALIGNMENT);
  bottomPanel.setAlignmentY(TOP_ALIGNMENT);
  topPanel.setLayout(new BoxLayout(topPanel,BoxLayout.Y_AXIS));
  _tabbedPane.setLayout(new BoxLayout(_tabbedPane,BoxLayout.Y_AXIS));
  topPanel.setBorder(BorderFactory.createEmptyBorder());
  _tabbedPane.addTab(""String_Node_Str"",_attributesListPanel);
  _tabbedPane.setMnemonicAt(0,KeyEvent.VK_1);
  _tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);
  _saveButton=new JButton(""String_Node_Str"");
  _cancelButton=new JButton(""String_Node_Str"");
  _nextButton=new JButton(""String_Node_Str"");
  _saveButton.setMnemonic(KeyEvent.VK_ENTER);
  _cancelButton.setMnemonic(KeyEvent.VK_ESCAPE);
  _nextButton.setMnemonic(KeyEvent.VK_RIGHT);
  _saveButton.setActionCommand(""String_Node_Str"");
  _cancelButton.setActionCommand(""String_Node_Str"");
  _nextButton.setActionCommand(""String_Node_Str"");
  _saveButton.setHorizontalTextPosition(SwingConstants.CENTER);
  _cancelButton.setHorizontalTextPosition(SwingConstants.CENTER);
  _nextButton.setHorizontalTextPosition(SwingConstants.CENTER);
  for (  Object stringParameter : _modelToSave.attributeList()) {
    if (stringParameter instanceof StringParameter && ((StringParameter)stringParameter).getName() != XMLDBModel.DB_REFERENCE_ATTR && ((StringParameter)stringParameter).getName() != XMLDBModel.DB_MODEL_ID_ATTR && _attributesListPanel.isDBAttribute(((StringParameter)stringParameter).getName())) {
      _attributesListPanel.addAttribute((StringParameter)stringParameter);
    }
  }
  _saveButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      _save();
    }
  }
);
  _cancelButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      _rollbackModel();
      setVisible(false);
      if (_parentValidateFrame != null) {
        _parentValidateFrame.setVisible(false);
      }
    }
  }
);
  _nextButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (_parentValidateFrame == null) {
        _parentValidateFrame=new ParentValidateFrame(SaveModelToDBFrame.this);
      }
      _parentValidateFrame.pack();
      _parentValidateFrame.setLocationRelativeTo(SaveModelToDBFrame.this);
      _parentValidateFrame.setVisible(true);
      setVisible(false);
    }
  }
);
  _attributesListPanel.getNameTextField().addKeyListener(new KeyListener(){
    public void keyTyped(    KeyEvent e){
    }
    public void keyReleased(    KeyEvent e){
      if (!_attributesListPanel.getNameTextField().getText().equals(_initialModelName)) {
        _nextButton.setEnabled(false);
        _saveButton.setEnabled(true);
      }
 else {
        _setButtons();
      }
    }
    public void keyPressed(    KeyEvent e){
      if (e.getKeyCode() == KeyEvent.VK_ENTER) {
        if (_saveButton.isEnabled()) {
          _saveButton.getActionListeners()[0].actionPerformed(null);
        }
 else         if (_nextButton.isEnabled()) {
          _nextButton.getActionListeners()[0].actionPerformed(null);
        }
      }
    }
  }
);
  topPanel.add(_tabbedPane);
  bottomPanel.add(_saveButton);
  bottomPanel.add(_cancelButton);
  bottomPanel.add(_nextButton);
  add(topPanel);
  add(bottomPanel);
  validate();
  repaint();
  _setButtons();
  this.pack();
  _attributesListPanel.setModelNameFocus();
}","/** 
 * Construct a SaveModelToDBFrame. Add swing Components to the frame. Add listeners for the ""Save"" and ""Cancel"" buttons.
 * @param model The model that is being saved to the database.
 * @param source The source frame.  Used to set modified to false uponsuccessful save.
 */
public SaveModelToDBFrame(NamedObj model,ActorGraphDBFrame source){
  super(""String_Node_Str"");
  setLayout(new BoxLayout(this.getContentPane(),BoxLayout.Y_AXIS));
  _source=source;
  _modelToSave=model;
  _initialModelName=model.getName();
  _orignialAttributes=new ArrayList();
  _attributesListPanel=new AttributesListPanel(_modelToSave);
  _tabbedPane=new JTabbedPane();
  try {
    if (!_isNew()) {
      _xmlModel=new XMLDBModel(_modelToSave.getName());
      _xmlModel.setModelId(Utilities.getIdFromModel(_modelToSave));
    }
  }
 catch (  NameDuplicationException e1) {
  }
catch (  IllegalActionException e1) {
  }
  for (  Object attribute : _modelToSave.attributeList()) {
    if (attribute instanceof StringParameter) {
      if (!((StringParameter)attribute).getName().equals(XMLDBModel.DB_REFERENCE_ATTR) && !((StringParameter)attribute).getName().equals(XMLDBModel.DB_MODEL_ID_ATTR) && _attributesListPanel.isDBAttribute(((StringParameter)attribute).getName())) {
        _orignialAttributes.add((StringParameter)attribute);
      }
    }
  }
  JPanel topPanel=new JPanel();
  JPanel bottomPanel=new JPanel();
  _attributesListPanel.setAlignmentX(LEFT_ALIGNMENT);
  _tabbedPane.setAlignmentX(LEFT_ALIGNMENT);
  topPanel.setAlignmentX(LEFT_ALIGNMENT);
  bottomPanel.setAlignmentX(LEFT_ALIGNMENT);
  _attributesListPanel.setAlignmentY(TOP_ALIGNMENT);
  _tabbedPane.setAlignmentY(TOP_ALIGNMENT);
  topPanel.setAlignmentY(TOP_ALIGNMENT);
  bottomPanel.setAlignmentY(TOP_ALIGNMENT);
  topPanel.setLayout(new BoxLayout(topPanel,BoxLayout.Y_AXIS));
  _tabbedPane.setLayout(new BoxLayout(_tabbedPane,BoxLayout.Y_AXIS));
  topPanel.setBorder(BorderFactory.createEmptyBorder());
  _tabbedPane.addTab(""String_Node_Str"",_attributesListPanel);
  _tabbedPane.setMnemonicAt(0,KeyEvent.VK_1);
  _tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);
  _saveButton=new JButton(""String_Node_Str"");
  _cancelButton=new JButton(""String_Node_Str"");
  _nextButton=new JButton(""String_Node_Str"");
  _saveButton.setMnemonic(KeyEvent.VK_ENTER);
  _cancelButton.setMnemonic(KeyEvent.VK_ESCAPE);
  _nextButton.setMnemonic(KeyEvent.VK_RIGHT);
  _saveButton.setActionCommand(""String_Node_Str"");
  _cancelButton.setActionCommand(""String_Node_Str"");
  _nextButton.setActionCommand(""String_Node_Str"");
  _saveButton.setHorizontalTextPosition(SwingConstants.CENTER);
  _cancelButton.setHorizontalTextPosition(SwingConstants.CENTER);
  _nextButton.setHorizontalTextPosition(SwingConstants.CENTER);
  for (  Object stringParameter : _modelToSave.attributeList()) {
    if (stringParameter instanceof StringParameter && !((StringParameter)stringParameter).getName().equals(XMLDBModel.DB_REFERENCE_ATTR) && !((StringParameter)stringParameter).getName().equals(XMLDBModel.DB_MODEL_ID_ATTR)&& _attributesListPanel.isDBAttribute(((StringParameter)stringParameter).getName())) {
      _attributesListPanel.addAttribute((StringParameter)stringParameter);
    }
  }
  _saveButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      _save();
    }
  }
);
  _cancelButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      _rollbackModel();
      setVisible(false);
      if (_parentValidateFrame != null) {
        _parentValidateFrame.setVisible(false);
      }
    }
  }
);
  _nextButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (_parentValidateFrame == null) {
        _parentValidateFrame=new ParentValidateFrame(SaveModelToDBFrame.this);
      }
      _parentValidateFrame.pack();
      _parentValidateFrame.setLocationRelativeTo(SaveModelToDBFrame.this);
      _parentValidateFrame.setVisible(true);
      setVisible(false);
    }
  }
);
  _attributesListPanel.getNameTextField().addKeyListener(new KeyListener(){
    public void keyTyped(    KeyEvent e){
    }
    public void keyReleased(    KeyEvent e){
      if (!_attributesListPanel.getNameTextField().getText().equals(_initialModelName)) {
        _nextButton.setEnabled(false);
        _saveButton.setEnabled(true);
      }
 else {
        _setButtons();
      }
    }
    public void keyPressed(    KeyEvent e){
      if (e.getKeyCode() == KeyEvent.VK_ENTER) {
        if (_saveButton.isEnabled()) {
          _saveButton.getActionListeners()[0].actionPerformed(null);
        }
 else         if (_nextButton.isEnabled()) {
          _nextButton.getActionListeners()[0].actionPerformed(null);
        }
      }
    }
  }
);
  topPanel.add(_tabbedPane);
  bottomPanel.add(_saveButton);
  bottomPanel.add(_cancelButton);
  bottomPanel.add(_nextButton);
  add(topPanel);
  add(bottomPanel);
  validate();
  repaint();
  _setButtons();
  this.pack();
  _attributesListPanel.setModelNameFocus();
}"
73390,"/** 
 * Save the currently opened search criteria to a new location.
 */
protected void _saveAs(){
  try {
    _searchCriteria=new SearchCriteria();
    if (!_attributesListPanel.getModelName().trim().isEmpty()) {
      _searchCriteria.setModelName(_attributesListPanel.getModelName());
    }
    if (_attributesListPanel.getAttributeCount() > 0) {
      ArrayList<Attribute> attributesToSearch=_attributesListPanel.getAttributes();
      _searchCriteria.setAttributes(attributesToSearch);
    }
    if (_patternMatchframe != null && !_patternMatchframe.isPatternEmpty()) {
      _searchCriteria.setPattnerMoML(_patternMatchframe.getPatternMoML());
    }
    JFileChooser chooser=new JFileChooser();
    FileFilter filter=new SearchCriteriaFileFilter(""String_Node_Str"");
    chooser.setFileFilter(filter);
    chooser.setDialogTitle(""String_Node_Str"");
    if (_saveLocation != null) {
      chooser.setSelectedFile(new File(_saveLocation));
    }
    boolean saveComplete=false;
    while (!saveComplete) {
      if (chooser.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) {
        return;
      }
 else {
        File filename=chooser.getSelectedFile();
        String name=filename.getName();
        if (!name.endsWith(""String_Node_Str"")) {
          filename=new File(filename.getParent(),name + ""String_Node_Str"");
        }
        if (filename.exists() && !filename.getCanonicalFile().toString().equals(_saveLocation)) {
          Object[] options={""String_Node_Str"",""String_Node_Str""};
          int n=JOptionPane.showOptionDialog(this,filename.toString() + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE,null,options,options[1]);
          if (n == JOptionPane.YES_OPTION) {
            saveComplete=true;
          }
 else {
            saveComplete=false;
          }
        }
 else {
          saveComplete=true;
        }
        if (saveComplete) {
          try {
            SearchCriteriaManager.save(_searchCriteria,filename.getCanonicalPath().toString());
            _saveLocation=chooser.getSelectedFile().getCanonicalPath();
            setModified(false);
            JOptionPane.showMessageDialog(this,""String_Node_Str"");
          }
 catch (          IllegalActionException e) {
            MessageHandler.error(""String_Node_Str"",e);
          }
catch (          IOException e) {
            MessageHandler.error(""String_Node_Str"",e);
          }
        }
      }
    }
  }
 catch (  IOException e) {
    MessageHandler.error(""String_Node_Str"",e);
  }
catch (  IllegalActionException e) {
    MessageHandler.error(""String_Node_Str"",e);
  }
}","/** 
 * Save the currently opened search criteria to a new location.
 */
protected void _saveAs(){
  try {
    _searchCriteria=new SearchCriteria();
    if (!_attributesListPanel.getModelName().trim().isEmpty()) {
      _searchCriteria.setModelName(_attributesListPanel.getModelName());
    }
    if (_attributesListPanel.getAttributeCount() > 0) {
      ArrayList<Attribute> attributesToSearch=_attributesListPanel.getAttributes();
      _searchCriteria.setAttributes(attributesToSearch);
    }
    if (_patternMatchframe != null && !_patternMatchframe.isPatternEmpty()) {
      _searchCriteria.setPattnerMoML(_patternMatchframe.getPatternMoML());
    }
    JFileChooser chooser=new JFileChooser();
    FileFilter filter=new SearchCriteriaFileFilter(""String_Node_Str"");
    chooser.setFileFilter(filter);
    chooser.setDialogTitle(""String_Node_Str"");
    if (_saveLocation != null) {
      chooser.setSelectedFile(new File(_saveLocation));
    }
    boolean saveComplete=false;
    while (!saveComplete) {
      if (chooser.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) {
        return;
      }
 else {
        File filename=chooser.getSelectedFile();
        String name=filename.getName();
        if (!name.endsWith(""String_Node_Str"")) {
          filename=new File(filename.getParent(),name + ""String_Node_Str"");
        }
        if (filename.exists() && !filename.getCanonicalFile().toString().equals(_saveLocation)) {
          Object[] options={""String_Node_Str"",""String_Node_Str""};
          int n=JOptionPane.showOptionDialog(this,filename.toString() + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE,null,options,options[1]);
          if (n == JOptionPane.YES_OPTION) {
            saveComplete=true;
          }
 else {
            saveComplete=false;
          }
        }
 else {
          saveComplete=true;
        }
        if (saveComplete) {
          try {
            SearchCriteriaManager.save(_searchCriteria,filename.getCanonicalPath());
            _saveLocation=chooser.getSelectedFile().getCanonicalPath();
            setModified(false);
            JOptionPane.showMessageDialog(this,""String_Node_Str"");
          }
 catch (          IllegalActionException e) {
            MessageHandler.error(""String_Node_Str"",e);
          }
catch (          IOException e) {
            MessageHandler.error(""String_Node_Str"",e);
          }
        }
      }
    }
  }
 catch (  IOException e) {
    MessageHandler.error(""String_Node_Str"",e);
  }
catch (  IllegalActionException e) {
    MessageHandler.error(""String_Node_Str"",e);
  }
}"
73391,"/** 
 * Remove the DTD from the model content.
 * @param modelConetnet The model content.
 * @return The model content after the DTD part is removed.
 */
private String removeDTD(String modelConetnet){
  String newModelContent=""String_Node_Str"";
  newModelContent=modelConetnet;
  if (newModelContent.indexOf(""String_Node_Str"") == 0) {
    newModelContent=newModelContent.substring(newModelContent.indexOf(""String_Node_Str""));
    newModelContent=newModelContent.substring(newModelContent.indexOf(""String_Node_Str"") + 1);
    newModelContent=newModelContent.substring(newModelContent.indexOf(""String_Node_Str""));
    newModelContent.trim();
  }
  if (newModelContent.indexOf(""String_Node_Str"") == 0) {
    newModelContent=newModelContent.substring(newModelContent.indexOf(""String_Node_Str""));
    newModelContent=newModelContent.substring(newModelContent.indexOf(""String_Node_Str"") + 1);
    newModelContent=newModelContent.substring(newModelContent.indexOf(""String_Node_Str""));
    newModelContent.trim();
  }
  return newModelContent;
}","/** 
 * Remove the DTD from the model content.
 * @param modelConetnet The model content.
 * @return The model content after the DTD part is removed.
 */
private String removeDTD(String modelConetnet){
  String newModelContent=""String_Node_Str"";
  newModelContent=modelConetnet;
  if (newModelContent.indexOf(""String_Node_Str"") == 0) {
    newModelContent=newModelContent.substring(newModelContent.indexOf(""String_Node_Str""));
    newModelContent=newModelContent.substring(newModelContent.indexOf(""String_Node_Str"") + 1);
    newModelContent=newModelContent.substring(newModelContent.indexOf(""String_Node_Str""));
    newModelContent=newModelContent.trim();
  }
  if (newModelContent.indexOf(""String_Node_Str"") == 0) {
    newModelContent=newModelContent.substring(newModelContent.indexOf(""String_Node_Str""));
    newModelContent=newModelContent.substring(newModelContent.indexOf(""String_Node_Str"") + 1);
    newModelContent=newModelContent.substring(newModelContent.indexOf(""String_Node_Str""));
    newModelContent=newModelContent.trim();
  }
  return newModelContent;
}"
73392,"/** 
 * Execute the given task to fetch the first level parents for the given  model. First level parents are models that are immediate parents for the given  model.
 * @param task Task that contains the model for which the first level parents list needs to be fetched.
 * @return List of models that are the first-level parents of the given model.
 * @throws DBExecutionException If thrown while fetching the parents list from the database.
 */
public List<XMLDBModel> executeGetFirstLevelParents(GetFirstLevelParentsTask task) throws DBExecutionException {
  String references=""String_Node_Str"";
  ArrayList<XMLDBModel> parentsList=new ArrayList<XMLDBModel>();
  HashSet alreadyFetchedParents=new HashSet();
  XMLDBModel model=task.getModel();
  try {
    XmlQueryContext xmlContext=_xmlManager.createQueryContext();
    String query=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ model.getModelName()+ ""String_Node_Str"";
    XmlQueryExpression queryExpression=_xmlManager.prepare(query,xmlContext);
    XmlResults results=queryExpression.execute(xmlContext);
    if (results != null && results.size() > 0) {
      while (results.hasNext()) {
        XmlValue xmlValue=results.next();
        references+=xmlValue.asString();
      }
      references=""String_Node_Str"" + references + ""String_Node_Str"";
      Node entitiesNode=Utilities.parseXML(references);
      NodeList entityList=entitiesNode.getFirstChild().getChildNodes();
      for (int i=0; i < entityList.getLength(); i++) {
        Node entity=entityList.item(i);
        String parentName=Utilities.getValueForAttribute(entity,XMLDBModel.DB_MODEL_NAME);
        String parentId=Utilities.getValueForAttribute(entity,XMLDBModel.DB_MODEL_ID_ATTR);
        if (!alreadyFetchedParents.contains(parentName)) {
          parentsList.add(new XMLDBModel(parentName,parentId));
          alreadyFetchedParents.add(parentName);
        }
      }
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  XMLDBModelParsingException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
  return parentsList;
}","/** 
 * Execute the given task to fetch the first level parents for the given  model. First level parents are models that are immediate parents for the given  model.
 * @param task Task that contains the model for which the first level parents list needs to be fetched.
 * @return List of models that are the first-level parents of the given model.
 * @throws DBExecutionException If thrown while fetching the parents list from the database.
 */
public List<XMLDBModel> executeGetFirstLevelParents(GetFirstLevelParentsTask task) throws DBExecutionException {
  StringBuffer references=new StringBuffer(""String_Node_Str"");
  ArrayList<XMLDBModel> parentsList=new ArrayList<XMLDBModel>();
  HashSet alreadyFetchedParents=new HashSet();
  XMLDBModel model=task.getModel();
  try {
    XmlQueryContext xmlContext=_xmlManager.createQueryContext();
    String query=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ model.getModelName()+ ""String_Node_Str"";
    XmlQueryExpression queryExpression=_xmlManager.prepare(query,xmlContext);
    XmlResults results=queryExpression.execute(xmlContext);
    if (results != null && results.size() > 0) {
      while (results.hasNext()) {
        XmlValue xmlValue=results.next();
        references.append(xmlValue.asString());
      }
      Node entitiesNode=Utilities.parseXML(""String_Node_Str"" + references.toString() + ""String_Node_Str"");
      NodeList entityList=entitiesNode.getFirstChild().getChildNodes();
      for (int i=0; i < entityList.getLength(); i++) {
        Node entity=entityList.item(i);
        String parentName=Utilities.getValueForAttribute(entity,XMLDBModel.DB_MODEL_NAME);
        String parentId=Utilities.getValueForAttribute(entity,XMLDBModel.DB_MODEL_ID_ATTR);
        if (!alreadyFetchedParents.contains(parentName)) {
          parentsList.add(new XMLDBModel(parentName,parentId));
          alreadyFetchedParents.add(parentName);
        }
      }
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  XMLDBModelParsingException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
  return parentsList;
}"
73393,"/** 
 * Return an unique label for the given port channel referenced by the given helper.
 * @param port The given port.
 * @param channelAndOffset The given channel and offset.
 * @param forComposite Whether the given helper is associated witha CompositeActor
 * @param isWrite The type of the reference. True if this isa write reference; otherwise, this is a read reference.
 * @param helper The specified helper.
 * @return an unique reference label for the given port channel.
 * @exception IllegalActionException If the helper throws it whilegenerating the label.
 */
public String getReference(TypedIOPort port,String[] channelAndOffset,boolean forComposite,boolean isWrite,CodeGeneratorHelper helper) throws IllegalActionException {
  Actor actor=(Actor)port.getContainer();
  Director director=actor.getDirector();
  if (_debugging) {
    _debug(""String_Node_Str"" + port.getFullName() + ""String_Node_Str""+ actor.getFullName()+ ""String_Node_Str""+ director.getFullName());
  }
  if (port.isOutput() && forComposite == false && !director.getFullName().contains(""String_Node_Str"")) {
    if (channelAndOffset[0] == ""String_Node_Str"") {
      channelAndOffset[0]=""String_Node_Str"";
    }
    return CodeGeneratorHelper.generateName(port);
  }
 else {
    return super.getReference(port,channelAndOffset,forComposite,isWrite,helper);
  }
}","/** 
 * Return an unique label for the given port channel referenced by the given helper.
 * @param port The given port.
 * @param channelAndOffset The given channel and offset.
 * @param forComposite Whether the given helper is associated witha CompositeActor
 * @param isWrite The type of the reference. True if this isa write reference; otherwise, this is a read reference.
 * @param helper The specified helper.
 * @return an unique reference label for the given port channel.
 * @exception IllegalActionException If the helper throws it whilegenerating the label.
 */
public String getReference(TypedIOPort port,String[] channelAndOffset,boolean forComposite,boolean isWrite,CodeGeneratorHelper helper) throws IllegalActionException {
  Actor actor=(Actor)port.getContainer();
  Director director=actor.getDirector();
  if (_debugging) {
    _debug(""String_Node_Str"" + port.getFullName() + ""String_Node_Str""+ actor.getFullName()+ ""String_Node_Str""+ director.getFullName());
  }
  if (port.isOutput() && forComposite == false && !director.getFullName().contains(""String_Node_Str"")) {
    if (channelAndOffset[0].equals(""String_Node_Str"")) {
      channelAndOffset[0]=""String_Node_Str"";
    }
    return CodeGeneratorHelper.generateName(port);
  }
 else {
    return super.getReference(port,channelAndOffset,forComposite,isWrite,helper);
  }
}"
73394,"/** 
 * Consume at most one token from the <i>input</i> port and output the PID control. If there has been no previous iteration, only proportional output is generated. If there is no input, then produce no output.
 * @exception IllegalActionException If addition, multiplication,subtraction, or division is not supported by the supplied tokens.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (input.hasToken(0)) {
    Time currentTime=getDirector().getModelTime();
    DoubleToken currentToken=(DoubleToken)input.get(0);
    _currentInput=new TimedEvent(currentTime,currentToken);
    DoubleToken currentOutput=(DoubleToken)currentToken.multiply(Kp.getToken());
    if (_lastInput != null) {
      DoubleToken lastToken=(DoubleToken)_lastInput.contents;
      Time lastTime=_lastInput.timeStamp;
      DoubleToken timeGap=new DoubleToken(currentTime.subtract(lastTime).getDoubleValue());
      if (timeGap.isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue()) {
        if (!((DoubleToken)Kd.getToken()).isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue() && !currentToken.equals(lastToken)) {
          throw new IllegalActionException(""String_Node_Str"");
        }
      }
 else {
        if (!((DoubleToken)Ki.getToken()).isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue()) {
          _accumulated=(DoubleToken)_accumulated.add(currentToken.add(lastToken).multiply(timeGap).multiply(new DoubleToken(0.5)));
          currentOutput=(DoubleToken)currentOutput.add(_accumulated.multiply(Ki.getToken()));
        }
        if (!Kd.equals(0)) {
          currentOutput=(DoubleToken)currentOutput.add(currentToken.subtract(lastToken).divide(timeGap).multiply(Kd.getToken()));
        }
      }
    }
    output.broadcast(currentOutput);
  }
}","/** 
 * Consume at most one token from the <i>input</i> port and output the PID control. If there has been no previous iteration, only proportional output is generated. If there is no input, then produce no output.
 * @exception IllegalActionException If addition, multiplication,subtraction, or division is not supported by the supplied tokens.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (input.hasToken(0)) {
    Time currentTime=getDirector().getModelTime();
    DoubleToken currentToken=(DoubleToken)input.get(0);
    _currentInput=new TimedEvent(currentTime,currentToken);
    DoubleToken currentOutput=(DoubleToken)currentToken.multiply(Kp.getToken());
    if (_lastInput != null) {
      DoubleToken lastToken=(DoubleToken)_lastInput.contents;
      Time lastTime=_lastInput.timeStamp;
      DoubleToken timeGap=new DoubleToken(currentTime.subtract(lastTime).getDoubleValue());
      if (timeGap.isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue()) {
        if (!((DoubleToken)Kd.getToken()).isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue() && !currentToken.equals(lastToken)) {
          throw new IllegalActionException(""String_Node_Str"");
        }
      }
 else {
        if (!((DoubleToken)Ki.getToken()).isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue()) {
          _accumulated=(DoubleToken)_accumulated.add(currentToken.add(lastToken).multiply(timeGap).multiply(new DoubleToken(0.5)));
          currentOutput=(DoubleToken)currentOutput.add(_accumulated.multiply(Ki.getToken()));
        }
        if (!((DoubleToken)Kd.getToken()).isCloseTo(DoubleToken.ZERO,Complex.EPSILON).booleanValue()) {
          currentOutput=(DoubleToken)currentOutput.add(currentToken.subtract(lastToken).divide(timeGap).multiply(Kd.getToken()));
        }
      }
    }
    output.broadcast(currentOutput);
  }
}"
73395,"public static void main(String[] args){
  final int WINDOW_WIDTH=320;
  final int WINDOW_HEIGHT=240;
  final String WINDOW_TITLE=""String_Node_Str"";
  JFrame frame=new JFrame();
  final cubeTriangle joglMain=new cubeTriangle();
  frame.setContentPane(joglMain);
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      new Thread(){
        @Override public void run(){
          joglMain.animator.stop();
          System.exit(0);
        }
      }
.start();
    }
  }
);
  frame.setSize(WINDOW_WIDTH,WINDOW_HEIGHT);
  frame.setTitle(WINDOW_TITLE);
  frame.setVisible(true);
  joglMain.animator.start();
}","public static void main(String[] args){
  final int WINDOW_WIDTH=320;
  final int WINDOW_HEIGHT=240;
  final String WINDOW_TITLE=""String_Node_Str"";
  try {
    Runnable doActions=new Runnable(){
      public void run(){
        try {
          JFrame frame=new JFrame();
          final cubeTriangle joglMain=new cubeTriangle();
          frame.setContentPane(joglMain);
          frame.addWindowListener(new WindowAdapter(){
            @Override public void windowClosing(            WindowEvent e){
              new Thread(){
                @Override public void run(){
                  joglMain.animator.stop();
                  System.exit(0);
                }
              }
.start();
            }
          }
);
          frame.setSize(WINDOW_WIDTH,WINDOW_HEIGHT);
          frame.setTitle(WINDOW_TITLE);
          frame.setVisible(true);
          joglMain.animator.start();
        }
 catch (        Exception ex) {
          System.err.println(ex.toString());
          ex.printStackTrace();
        }
      }
    }
;
    SwingUtilities.invokeAndWait(doActions);
  }
 catch (  Exception ex) {
    System.err.println(ex.toString());
    ex.printStackTrace();
  }
}"
73396,"/** 
 * Set iteration number of the actor, which is the number of times internal entities are called.  and set corresponding attribute
 * @param repetition The number of times this actor is fired.
 */
public void setIterations(Integer[] repetition){
  String repetitionString=""String_Node_Str"";
  for (int i=0; i < repetition.length; i++) {
    repetitionString+=repetition[i];
    if (i < repetition.length - 1) {
      repetitionString+=""String_Node_Str"";
    }
  }
  repetitionString+=""String_Node_Str"";
  Attribute repetitions=getAttribute(PthalesCompositeActor._REPETITIONS);
  if (repetitions != null && repetitions instanceof Parameter) {
    ((Parameter)repetitions).setExpression(repetitionString);
  }
}","/** 
 * Set iteration number of the actor, which is the number of times internal entities are called.  and set corresponding attribute
 * @param repetition The number of times this actor is fired.
 */
public void setIterations(Integer[] repetition){
  StringBuffer repetitionStringBuffer=new StringBuffer(""String_Node_Str"");
  for (int i=0; i < repetition.length; i++) {
    repetitionStringBuffer.append(repetition[i]);
    if (i < repetition.length - 1) {
      repetitionStringBuffer.append(""String_Node_Str"");
    }
  }
  repetitionStringBuffer.append(""String_Node_Str"");
  Attribute repetitions=getAttribute(PthalesCompositeActor._REPETITIONS);
  if (repetitions != null && repetitions instanceof Parameter) {
    ((Parameter)repetitions).setExpression(repetitionStringBuffer.toString());
  }
}"
73397,"/** 
 * Modify th pattern of the specified port with dimensions (after propagate).
 * @param port associated port
 * @param dims dimension names
 * @param dimSizes dimension sizes
 */
public static void modifyPattern(IOPort port,String[] dims,int[] dimSizes){
  Attribute pattern=port.getAttribute(PATTERN);
  if (port.getAttribute(PATTERN) == null) {
    try {
      pattern=new Parameter(port,PATTERN);
    }
 catch (    IllegalActionException e) {
      e.printStackTrace();
    }
catch (    NameDuplicationException e) {
      e.printStackTrace();
    }
  }
  String s=""String_Node_Str"";
  if (pattern instanceof Parameter) {
    for (int i=0; i < dims.length; i++) {
      s+=dims[i] + ""String_Node_Str"" + dimSizes[i]+ ""String_Node_Str"";
      if (i < dims.length - 1) {
        s+=""String_Node_Str"";
      }
    }
  }
  s+=""String_Node_Str"";
  ((Parameter)pattern).setExpression(s);
}","/** 
 * Modify th pattern of the specified port with dimensions (after propagate).
 * @param port associated port
 * @param dims dimension names
 * @param dimSizes dimension sizes
 */
public static void modifyPattern(IOPort port,String[] dims,int[] dimSizes){
  Attribute pattern=port.getAttribute(PATTERN);
  if (port.getAttribute(PATTERN) == null) {
    try {
      pattern=new Parameter(port,PATTERN);
    }
 catch (    IllegalActionException e) {
      e.printStackTrace();
    }
catch (    NameDuplicationException e) {
      e.printStackTrace();
    }
  }
  StringBuffer s=new StringBuffer(""String_Node_Str"");
  if (pattern instanceof Parameter) {
    for (int i=0; i < dims.length; i++) {
      s.append(dims[i] + ""String_Node_Str"" + dimSizes[i]+ ""String_Node_Str"");
      if (i < dims.length - 1) {
        s.append(""String_Node_Str"");
      }
    }
  }
  s.append(""String_Node_Str"");
  ((Parameter)pattern).setExpression(s.toString());
}"
73398,"/** 
 * Return a string describing how many actors, parameters, ports, and relations are in this CompositeEntity. Entities whose instantiation is deferred are not included.
 * @param className If non-null and non-empty, then alsoinclude the number of objects with the give name.
 * @return a string describing the number of components.
 * @exception IllegalActionException If the class named byactorClassName cannot be found.
 */
public String statistics(String className) throws IllegalActionException {
  try {
    _workspace.getReadAccess();
    Class clazz=null;
    try {
      if (className != null && className.length() > 0) {
        clazz=Class.forName(className);
      }
    }
 catch (    Exception ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"" + className + ""String_Node_Str"");
    }
    List atomicEntities=lazyAllAtomicEntityList();
    int entityCount=atomicEntities.size();
    Map<String,Integer> actorMap=new HashMap<String,Integer>();
    Integer one=new Integer(1);
    int attributeCount=0, entityClassCount=0;
    Iterator entities=atomicEntities.iterator();
    while (entities.hasNext()) {
      ComponentEntity entity=(ComponentEntity)entities.next();
      List attributeList=entity.attributeList();
      attributeCount+=attributeList.size();
      Class entityClass=entity.getClass();
      String entityClassName=entityClass.getName();
      if (!actorMap.containsKey(entityClassName)) {
        actorMap.put(entityClassName,one);
      }
 else {
        actorMap.put(entityClassName,Integer.valueOf(actorMap.get(entityClassName) + 1));
      }
      if (clazz != null) {
        if (clazz.isAssignableFrom(entityClass)) {
          entityClassCount++;
        }
 else {
          Iterator attributes=attributeList.iterator();
          while (attributes.hasNext()) {
            Attribute attribute=(Attribute)attributes.next();
            if (clazz.isAssignableFrom(attribute.getClass())) {
              entityClassCount++;
            }
          }
        }
      }
    }
    ArrayList actorArrayList=new ArrayList(actorMap.entrySet());
    Collections.sort(actorArrayList,new CountComparator());
    StringBuffer actorNames=new StringBuffer();
    Iterator actors=actorArrayList.iterator();
    while (actors.hasNext()) {
      Map.Entry<String,Integer> actor=(Map.Entry)actors.next();
      actorNames.append(actor.getKey() + ""String_Node_Str"" + actor.getValue()+ ""String_Node_Str"");
    }
    int compositeEntityCount=0;
    int opaqueCompositeEntityCount=0;
    List relationList=lazyRelationList();
    int relationCount=relationList.size();
    if (clazz != null) {
      Iterator relations=relationList.iterator();
      while (relations.hasNext()) {
        Relation relation=(Relation)relations.next();
        if (clazz.isAssignableFrom(relation.getClass())) {
          entityClassCount++;
        }
      }
    }
    Map<Integer,Integer> compositeEntityDepthMap=new TreeMap<Integer,Integer>();
    entities=lazyAllCompositeTransparentAndOpaqueEntityList().iterator();
    while (entities.hasNext()) {
      Entity entity=(Entity)entities.next();
      if (entity instanceof CompositeEntity) {
        compositeEntityCount++;
        if (((CompositeEntity)entity).isOpaque()) {
          opaqueCompositeEntityCount++;
        }
        Integer depth=Integer.valueOf(entity.depthInHierarchy());
        if (!compositeEntityDepthMap.containsKey(depth)) {
          compositeEntityDepthMap.put(depth,one);
        }
 else {
          compositeEntityDepthMap.put(depth,Integer.valueOf(compositeEntityDepthMap.get(depth) + 1));
        }
        relationList=((CompositeEntity)entity).lazyRelationList();
        relationCount+=relationList.size();
        if (clazz != null) {
          if (clazz.isAssignableFrom(entity.getClass())) {
            entityClassCount++;
          }
 else {
            Iterator relations=relationList.iterator();
            while (relations.hasNext()) {
              Relation relation=(Relation)relations.next();
              if (clazz.isAssignableFrom(relation.getClass())) {
                entityClassCount++;
              }
            }
          }
        }
      }
    }
    StringBuffer compositeEntityDepths=new StringBuffer();
    for (    Map.Entry<Integer,Integer> depth : compositeEntityDepthMap.entrySet()) {
      compositeEntityDepths.append(""String_Node_Str"" + depth.getKey() + ""String_Node_Str""+ depth.getValue()+ ""String_Node_Str"");
    }
    return ""String_Node_Str"" + getFullName() + ""String_Node_Str""+ entityCount+ ""String_Node_Str""+ compositeEntityCount+ ""String_Node_Str""+ opaqueCompositeEntityCount+ ""String_Node_Str""+ relationCount+ ""String_Node_Str""+ attributeCount+ (clazz == null ? ""String_Node_Str"" : ""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ entityClassCount)+ ""String_Node_Str""+ actorNames+ ""String_Node_Str""+ compositeEntityDepths;
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Return a string describing how many actors, parameters, ports, and relations are in this CompositeEntity. Entities whose instantiation is deferred are not included.
 * @param className If non-null and non-empty, then alsoinclude the number of objects with the give name.
 * @return a string describing the number of components.
 * @exception IllegalActionException If the class named byactorClassName cannot be found.
 */
public String statistics(String className) throws IllegalActionException {
  try {
    _workspace.getReadAccess();
    Class clazz=null;
    try {
      if (className != null && className.length() > 0) {
        clazz=Class.forName(className);
      }
    }
 catch (    Exception ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"" + className + ""String_Node_Str"");
    }
    List atomicEntities=lazyAllAtomicEntityList();
    int entityCount=atomicEntities.size();
    Map<String,Integer> actorMap=new HashMap<String,Integer>();
    Integer one=Integer.valueOf(1);
    int attributeCount=0, entityClassCount=0;
    Iterator entities=atomicEntities.iterator();
    while (entities.hasNext()) {
      ComponentEntity entity=(ComponentEntity)entities.next();
      List attributeList=entity.attributeList();
      attributeCount+=attributeList.size();
      Class entityClass=entity.getClass();
      String entityClassName=entityClass.getName();
      if (!actorMap.containsKey(entityClassName)) {
        actorMap.put(entityClassName,one);
      }
 else {
        actorMap.put(entityClassName,Integer.valueOf(actorMap.get(entityClassName) + 1));
      }
      if (clazz != null) {
        if (clazz.isAssignableFrom(entityClass)) {
          entityClassCount++;
        }
 else {
          Iterator attributes=attributeList.iterator();
          while (attributes.hasNext()) {
            Attribute attribute=(Attribute)attributes.next();
            if (clazz.isAssignableFrom(attribute.getClass())) {
              entityClassCount++;
            }
          }
        }
      }
    }
    ArrayList actorArrayList=new ArrayList(actorMap.entrySet());
    Collections.sort(actorArrayList,new CountComparator());
    StringBuffer actorNames=new StringBuffer();
    Iterator actors=actorArrayList.iterator();
    while (actors.hasNext()) {
      Map.Entry<String,Integer> actor=(Map.Entry)actors.next();
      actorNames.append(actor.getKey() + ""String_Node_Str"" + actor.getValue()+ ""String_Node_Str"");
    }
    int compositeEntityCount=0;
    int opaqueCompositeEntityCount=0;
    List relationList=lazyRelationList();
    int relationCount=relationList.size();
    if (clazz != null) {
      Iterator relations=relationList.iterator();
      while (relations.hasNext()) {
        Relation relation=(Relation)relations.next();
        if (clazz.isAssignableFrom(relation.getClass())) {
          entityClassCount++;
        }
      }
    }
    Map<Integer,Integer> compositeEntityDepthMap=new TreeMap<Integer,Integer>();
    entities=lazyAllCompositeTransparentAndOpaqueEntityList().iterator();
    while (entities.hasNext()) {
      Entity entity=(Entity)entities.next();
      if (entity instanceof CompositeEntity) {
        compositeEntityCount++;
        if (((CompositeEntity)entity).isOpaque()) {
          opaqueCompositeEntityCount++;
        }
        Integer depth=Integer.valueOf(entity.depthInHierarchy());
        if (!compositeEntityDepthMap.containsKey(depth)) {
          compositeEntityDepthMap.put(depth,one);
        }
 else {
          compositeEntityDepthMap.put(depth,Integer.valueOf(compositeEntityDepthMap.get(depth) + 1));
        }
        relationList=((CompositeEntity)entity).lazyRelationList();
        relationCount+=relationList.size();
        if (clazz != null) {
          if (clazz.isAssignableFrom(entity.getClass())) {
            entityClassCount++;
          }
 else {
            Iterator relations=relationList.iterator();
            while (relations.hasNext()) {
              Relation relation=(Relation)relations.next();
              if (clazz.isAssignableFrom(relation.getClass())) {
                entityClassCount++;
              }
            }
          }
        }
      }
    }
    StringBuffer compositeEntityDepths=new StringBuffer();
    for (    Map.Entry<Integer,Integer> depth : compositeEntityDepthMap.entrySet()) {
      compositeEntityDepths.append(""String_Node_Str"" + depth.getKey() + ""String_Node_Str""+ depth.getValue()+ ""String_Node_Str"");
    }
    return ""String_Node_Str"" + getFullName() + ""String_Node_Str""+ entityCount+ ""String_Node_Str""+ compositeEntityCount+ ""String_Node_Str""+ opaqueCompositeEntityCount+ ""String_Node_Str""+ relationCount+ ""String_Node_Str""+ attributeCount+ (clazz == null ? ""String_Node_Str"" : ""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ entityClassCount)+ ""String_Node_Str""+ actorNames+ ""String_Node_Str""+ compositeEntityDepths;
  }
  finally {
    _workspace.doneReading();
  }
}"
73399,"/** 
 * Render a visual representation of the given node. If the StringAttribute _color of the node is set then use that color to render the node. If the StringAttribute _explanation of the node is set then use it to set the tooltip.
 * @see diva.graph.NodeRenderer#render(java.lang.Object)
 */
public Figure render(Object n){
  final Port port=(Port)n;
  if (_isPropertySet(port,""String_Node_Str"")) {
    return null;
  }
  boolean isInput=false;
  boolean isOutput=false;
  boolean isInputOutput=false;
  if (port instanceof IOPort) {
    isInput=((IOPort)port).isInput();
    isOutput=((IOPort)port).isOutput();
    isInputOutput=isInput && isOutput;
  }
  Shape shape;
  if (isInputOutput) {
    Polygon2D.Double polygon=new Polygon2D.Double();
    polygon.moveTo(0,-4);
    polygon.lineTo(-4,-4);
    polygon.lineTo(-2,0);
    polygon.lineTo(-4,4);
    polygon.lineTo(4,4);
    polygon.lineTo(2,0);
    polygon.lineTo(4,-4);
    polygon.lineTo(0,-4);
    polygon.closePath();
    shape=polygon;
  }
 else   if (isInput) {
    Polygon2D.Double polygon=new Polygon2D.Double();
    polygon.moveTo(-4,0);
    polygon.lineTo(-4,4);
    polygon.lineTo(4,0);
    polygon.lineTo(-4,-4);
    polygon.lineTo(-4,0);
    polygon.closePath();
    shape=polygon;
  }
 else   if (isOutput) {
    Polygon2D.Double polygon=new Polygon2D.Double();
    polygon.moveTo(4,0);
    polygon.lineTo(4,-4);
    polygon.lineTo(-4,0);
    polygon.lineTo(4,4);
    polygon.lineTo(4,0);
    polygon.closePath();
    shape=polygon;
  }
 else {
    shape=new Ellipse2D.Double(-4,-4,8,8);
  }
  Color fill;
  if (port instanceof ParameterPort) {
    fill=Color.lightGray;
  }
 else   if (port instanceof IOPort && ((IOPort)port).isMultiport()) {
    fill=Color.white;
  }
 else {
    fill=Color.black;
  }
  try {
    if (port instanceof IOPort) {
      List<MonitoredQuantityManager> qmList;
      List list=((IOPort)port).getQuantityManagers();
      if (list != null) {
        qmList=new ArrayList(list);
        if (qmList != _qmList && qmList.size() > 0) {
          _qmList=qmList;
          if (((IOPort)port).isOutput()) {
            fill=qmList.get(0).color.asColor();
          }
 else {
            fill=qmList.get(qmList.size() - 1).color.asColor();
          }
          StringAttribute info=(StringAttribute)port.getAttribute(""String_Node_Str"");
          String qmString=""String_Node_Str"";
          if (info == null) {
            info=new StringAttribute(port,""String_Node_Str"");
          }
          for (int j=0; j < qmList.size(); j++) {
            qmString=qmString + qmList.get(j).getName() + ""String_Node_Str"";
          }
          info.setExpression(""String_Node_Str"" + qmString.substring(0,qmString.length() - 2));
        }
      }
    }
  }
 catch (  IllegalActionException e1) {
    e1.printStackTrace();
  }
catch (  NameDuplicationException e) {
  }
  ColorAttribute colorAttribute;
  try {
    colorAttribute=(ColorAttribute)(port.getAttribute(""String_Node_Str"",ColorAttribute.class));
    if (colorAttribute != null) {
      Color color=colorAttribute.asColor();
      fill=color;
    }
  }
 catch (  IllegalActionException e1) {
    e1.printStackTrace();
  }
  int portRotation=_getCardinality(port);
  int direction=_getDirection(portRotation);
  double rotation=portRotation;
  AffineTransform transform=AffineTransform.getRotateInstance(Math.toRadians(rotation));
  shape=ShapeUtilities.transformModify(shape,transform);
  Figure figure=new BasicFigure(shape,fill,(float)1.5){
    public String getToolTipText(){
      String tipText=port.getName();
      String displayName=port.getDisplayName();
      if (!tipText.equals(displayName)) {
        tipText=displayName + ""String_Node_Str"" + tipText+ ""String_Node_Str"";
      }
      StringAttribute _explAttr=(StringAttribute)(port.getAttribute(""String_Node_Str""));
      if (_explAttr != null) {
        tipText=_explAttr.getExpression();
      }
 else       if (port instanceof Typeable) {
        try {
          tipText=tipText + ""String_Node_Str"" + ((Typeable)port).getType();
        }
 catch (        IllegalActionException ex) {
        }
      }
      return tipText;
    }
  }
;
  String tipText=port.getName();
  String displayName=port.getDisplayName();
  if (!tipText.equals(displayName)) {
    tipText=displayName + ""String_Node_Str"" + tipText+ ""String_Node_Str"";
  }
  figure.setToolTipText(tipText);
  double normal=CanvasUtilities.getNormal(direction);
  if (port instanceof IOPort) {
    IOPort ioPort=(IOPort)port;
    if (ioPort.isMultiport()) {
      int numberOfLinks=ioPort.linkedRelationList().size();
      if (numberOfLinks > 1) {
        CompositeFigure compositeFigure=new CompositeFigure(figure){
          public String getToolTipText(){
            String tipText=port.getName();
            String displayName=port.getDisplayName();
            if (!tipText.equals(displayName)) {
              tipText=displayName + ""String_Node_Str"" + tipText+ ""String_Node_Str"";
            }
            StringAttribute _explAttr=(StringAttribute)(port.getAttribute(""String_Node_Str""));
            if (_explAttr != null) {
              tipText=_explAttr.getExpression();
            }
 else             if (port instanceof Typeable) {
              try {
                tipText=tipText + ""String_Node_Str"" + ((Typeable)port).getType();
              }
 catch (              IllegalActionException ex) {
              }
            }
            return tipText;
          }
        }
;
        double startX;
        double startY;
        double endX;
        double endY;
        Rectangle2D bounds=figure.getShape().getBounds2D();
        double x=bounds.getX();
        double y=bounds.getY();
        double width=bounds.getWidth();
        double height=bounds.getHeight();
        int extent=numberOfLinks - 1;
        if (direction == SwingConstants.EAST) {
          startX=x + width;
          startY=y + (height / 2);
          endX=startX + (extent * MULTIPORT_CONNECTION_SPACING);
          endY=startY + (extent * MULTIPORT_CONNECTION_SPACING);
        }
 else         if (direction == SwingConstants.WEST) {
          startX=x;
          startY=y + (height / 2);
          endX=startX - (extent * MULTIPORT_CONNECTION_SPACING);
          endY=startY - (extent * MULTIPORT_CONNECTION_SPACING);
        }
 else         if (direction == SwingConstants.NORTH) {
          startX=x + (width / 2);
          startY=y;
          endX=startX - (extent * MULTIPORT_CONNECTION_SPACING);
          endY=startY - (extent * MULTIPORT_CONNECTION_SPACING);
        }
 else {
          startX=x + (width / 2);
          startY=y + height;
          endX=startX + (extent * MULTIPORT_CONNECTION_SPACING);
          endY=startY + (extent * MULTIPORT_CONNECTION_SPACING);
        }
        Line2D line=new Line2D.Double(startX,startY,endX,endY);
        Figure lineFigure=new BasicFigure(line,fill,(float)2.0);
        compositeFigure.add(lineFigure);
        figure=compositeFigure;
      }
    }
    figure=_decoratePortFigure(n,figure);
    figure=new PortTerminal(ioPort,figure,normal,false);
  }
 else {
    figure=_decoratePortFigure(n,figure);
    Site tsite=new PerimeterSite(figure,0);
    tsite.setNormal(normal);
    figure=new TerminalFigure(figure,tsite);
  }
  try {
    ColorAttribute highlightAttribute=(ColorAttribute)(port.getAttribute(""String_Node_Str"",ColorAttribute.class));
    if (highlightAttribute != null && !highlightAttribute.getExpression().trim().equals(""String_Node_Str"")) {
      Color color=highlightAttribute.asColor();
      AnimationRenderer animationRenderer=new AnimationRenderer(color);
      animationRenderer.renderSelected(figure);
    }
  }
 catch (  IllegalActionException e) {
  }
  return figure;
}","/** 
 * Render a visual representation of the given node. If the StringAttribute _color of the node is set then use that color to render the node. If the StringAttribute _explanation of the node is set then use it to set the tooltip.
 * @see diva.graph.NodeRenderer#render(java.lang.Object)
 */
public Figure render(Object n){
  final Port port=(Port)n;
  if (_isPropertySet(port,""String_Node_Str"")) {
    return null;
  }
  boolean isInput=false;
  boolean isOutput=false;
  boolean isInputOutput=false;
  if (port instanceof IOPort) {
    isInput=((IOPort)port).isInput();
    isOutput=((IOPort)port).isOutput();
    isInputOutput=isInput && isOutput;
  }
  Shape shape;
  if (isInputOutput) {
    Polygon2D.Double polygon=new Polygon2D.Double();
    polygon.moveTo(0,-4);
    polygon.lineTo(-4,-4);
    polygon.lineTo(-2,0);
    polygon.lineTo(-4,4);
    polygon.lineTo(4,4);
    polygon.lineTo(2,0);
    polygon.lineTo(4,-4);
    polygon.lineTo(0,-4);
    polygon.closePath();
    shape=polygon;
  }
 else   if (isInput) {
    Polygon2D.Double polygon=new Polygon2D.Double();
    polygon.moveTo(-4,0);
    polygon.lineTo(-4,4);
    polygon.lineTo(4,0);
    polygon.lineTo(-4,-4);
    polygon.lineTo(-4,0);
    polygon.closePath();
    shape=polygon;
  }
 else   if (isOutput) {
    Polygon2D.Double polygon=new Polygon2D.Double();
    polygon.moveTo(4,0);
    polygon.lineTo(4,-4);
    polygon.lineTo(-4,0);
    polygon.lineTo(4,4);
    polygon.lineTo(4,0);
    polygon.closePath();
    shape=polygon;
  }
 else {
    shape=new Ellipse2D.Double(-4,-4,8,8);
  }
  Color fill;
  if (port instanceof ParameterPort) {
    fill=Color.lightGray;
  }
 else   if (port instanceof IOPort && ((IOPort)port).isMultiport()) {
    fill=Color.white;
  }
 else {
    fill=Color.black;
  }
  try {
    if (port instanceof IOPort) {
      List<MonitoredQuantityManager> qmList;
      List list=((IOPort)port).getQuantityManagers();
      if (list != null) {
        qmList=new ArrayList(list);
        if (qmList != _qmList && qmList.size() > 0) {
          _qmList=qmList;
          if (((IOPort)port).isOutput()) {
            fill=qmList.get(0).color.asColor();
          }
 else {
            fill=qmList.get(qmList.size() - 1).color.asColor();
          }
          StringAttribute info=(StringAttribute)port.getAttribute(""String_Node_Str"");
          if (info == null) {
            info=new StringAttribute(port,""String_Node_Str"");
          }
          StringBuffer qmStringBuffer=new StringBuffer();
          for (int j=0; j < qmList.size(); j++) {
            if (qmStringBuffer.length() > 0) {
              qmStringBuffer.append(""String_Node_Str"");
            }
            qmStringBuffer.append(qmList.get(j).getName());
          }
          info.setExpression(""String_Node_Str"" + qmStringBuffer.toString());
        }
      }
    }
  }
 catch (  IllegalActionException e1) {
    e1.printStackTrace();
  }
catch (  NameDuplicationException e) {
  }
  ColorAttribute colorAttribute;
  try {
    colorAttribute=(ColorAttribute)(port.getAttribute(""String_Node_Str"",ColorAttribute.class));
    if (colorAttribute != null) {
      Color color=colorAttribute.asColor();
      fill=color;
    }
  }
 catch (  IllegalActionException e1) {
    e1.printStackTrace();
  }
  int portRotation=_getCardinality(port);
  int direction=_getDirection(portRotation);
  double rotation=portRotation;
  AffineTransform transform=AffineTransform.getRotateInstance(Math.toRadians(rotation));
  shape=ShapeUtilities.transformModify(shape,transform);
  Figure figure=new BasicFigure(shape,fill,(float)1.5){
    public String getToolTipText(){
      String tipText=port.getName();
      String displayName=port.getDisplayName();
      if (!tipText.equals(displayName)) {
        tipText=displayName + ""String_Node_Str"" + tipText+ ""String_Node_Str"";
      }
      StringAttribute _explAttr=(StringAttribute)(port.getAttribute(""String_Node_Str""));
      if (_explAttr != null) {
        tipText=_explAttr.getExpression();
      }
 else       if (port instanceof Typeable) {
        try {
          tipText=tipText + ""String_Node_Str"" + ((Typeable)port).getType();
        }
 catch (        IllegalActionException ex) {
        }
      }
      return tipText;
    }
  }
;
  String tipText=port.getName();
  String displayName=port.getDisplayName();
  if (!tipText.equals(displayName)) {
    tipText=displayName + ""String_Node_Str"" + tipText+ ""String_Node_Str"";
  }
  figure.setToolTipText(tipText);
  double normal=CanvasUtilities.getNormal(direction);
  if (port instanceof IOPort) {
    IOPort ioPort=(IOPort)port;
    if (ioPort.isMultiport()) {
      int numberOfLinks=ioPort.linkedRelationList().size();
      if (numberOfLinks > 1) {
        CompositeFigure compositeFigure=new CompositeFigure(figure){
          public String getToolTipText(){
            String tipText=port.getName();
            String displayName=port.getDisplayName();
            if (!tipText.equals(displayName)) {
              tipText=displayName + ""String_Node_Str"" + tipText+ ""String_Node_Str"";
            }
            StringAttribute _explAttr=(StringAttribute)(port.getAttribute(""String_Node_Str""));
            if (_explAttr != null) {
              tipText=_explAttr.getExpression();
            }
 else             if (port instanceof Typeable) {
              try {
                tipText=tipText + ""String_Node_Str"" + ((Typeable)port).getType();
              }
 catch (              IllegalActionException ex) {
              }
            }
            return tipText;
          }
        }
;
        double startX;
        double startY;
        double endX;
        double endY;
        Rectangle2D bounds=figure.getShape().getBounds2D();
        double x=bounds.getX();
        double y=bounds.getY();
        double width=bounds.getWidth();
        double height=bounds.getHeight();
        int extent=numberOfLinks - 1;
        if (direction == SwingConstants.EAST) {
          startX=x + width;
          startY=y + (height / 2);
          endX=startX + (extent * MULTIPORT_CONNECTION_SPACING);
          endY=startY + (extent * MULTIPORT_CONNECTION_SPACING);
        }
 else         if (direction == SwingConstants.WEST) {
          startX=x;
          startY=y + (height / 2);
          endX=startX - (extent * MULTIPORT_CONNECTION_SPACING);
          endY=startY - (extent * MULTIPORT_CONNECTION_SPACING);
        }
 else         if (direction == SwingConstants.NORTH) {
          startX=x + (width / 2);
          startY=y;
          endX=startX - (extent * MULTIPORT_CONNECTION_SPACING);
          endY=startY - (extent * MULTIPORT_CONNECTION_SPACING);
        }
 else {
          startX=x + (width / 2);
          startY=y + height;
          endX=startX + (extent * MULTIPORT_CONNECTION_SPACING);
          endY=startY + (extent * MULTIPORT_CONNECTION_SPACING);
        }
        Line2D line=new Line2D.Double(startX,startY,endX,endY);
        Figure lineFigure=new BasicFigure(line,fill,(float)2.0);
        compositeFigure.add(lineFigure);
        figure=compositeFigure;
      }
    }
    figure=_decoratePortFigure(n,figure);
    figure=new PortTerminal(ioPort,figure,normal,false);
  }
 else {
    figure=_decoratePortFigure(n,figure);
    Site tsite=new PerimeterSite(figure,0);
    tsite.setNormal(normal);
    figure=new TerminalFigure(figure,tsite);
  }
  try {
    ColorAttribute highlightAttribute=(ColorAttribute)(port.getAttribute(""String_Node_Str"",ColorAttribute.class));
    if (highlightAttribute != null && !highlightAttribute.getExpression().trim().equals(""String_Node_Str"")) {
      Color color=highlightAttribute.asColor();
      AnimationRenderer animationRenderer=new AnimationRenderer(color);
      animationRenderer.renderSelected(figure);
    }
  }
 catch (  IllegalActionException e) {
  }
  return figure;
}"
73400,"/** 
 * Find and show the tableau for a given DocAttribute.
 * @param docAttribute the attribute to show
 * @param target the target of the documentation viewing
 */
private void _showDocAttributeTableau(DocAttribute docAttribute,NamedObj target){
  ComponentEntity effigy=null;
  Effigy context=Configuration.findEffigy(target);
  if (_effigy == null) {
    NamedObj container=target.getContainer();
    while (container != null && context == null) {
      context=Configuration.findEffigy(container);
      container=container.getContainer();
    }
    if (context == null) {
      if (context == null) {
        MessageHandler.error(""String_Node_Str"" + target.getFullName());
        return;
      }
    }
    effigy=context.getEntity(""String_Node_Str"");
  }
 else {
    effigy=_effigy;
  }
  if (effigy == null) {
    try {
      effigy=new DocEffigy(context,""String_Node_Str"");
    }
 catch (    KernelException exception) {
      throw new InternalErrorException(exception);
    }
  }
  if (!(effigy instanceof DocEffigy)) {
    MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"");
  }
  ((DocEffigy)effigy).setDocAttribute(docAttribute);
  ComponentEntity tableau=((Effigy)effigy).getEntity(""String_Node_Str"");
  if (tableau == null) {
    try {
      tableau=new DocTableau((DocEffigy)effigy,""String_Node_Str"");
      ((DocTableau)tableau).setTitle(""String_Node_Str"" + target.getFullName());
    }
 catch (    KernelException exception) {
      throw new InternalErrorException(exception);
    }
  }
 else {
    if (_isMultipleDocumentationAllowed()) {
      try {
        tableau=new DocTableau((DocEffigy)effigy,effigy.uniqueName(""String_Node_Str""));
        ((DocTableau)tableau).setTitle(""String_Node_Str"" + target.getFullName());
      }
 catch (      KernelException exception) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"" + target.getFullName() + ""String_Node_Str"",exception);
      }
    }
  }
  if (!(tableau instanceof DocTableau)) {
    MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"");
  }
  ((DocTableau)tableau).show();
}","/** 
 * Find and show the tableau for a given DocAttribute.
 * @param docAttribute the attribute to show
 * @param target the target of the documentation viewing
 */
private void _showDocAttributeTableau(DocAttribute docAttribute,NamedObj target){
  ComponentEntity effigy=null;
  Effigy context=Configuration.findEffigy(target);
  if (_effigy == null) {
    NamedObj container=target.getContainer();
    while (container != null && context == null) {
      context=Configuration.findEffigy(container);
      container=container.getContainer();
    }
    if (context == null) {
      MessageHandler.error(""String_Node_Str"" + target.getFullName());
      return;
    }
    effigy=context.getEntity(""String_Node_Str"");
  }
 else {
    effigy=_effigy;
  }
  if (effigy == null) {
    try {
      effigy=new DocEffigy(context,""String_Node_Str"");
    }
 catch (    KernelException exception) {
      throw new InternalErrorException(exception);
    }
  }
  if (!(effigy instanceof DocEffigy)) {
    MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"");
  }
  ((DocEffigy)effigy).setDocAttribute(docAttribute);
  ComponentEntity tableau=((Effigy)effigy).getEntity(""String_Node_Str"");
  if (tableau == null) {
    try {
      tableau=new DocTableau((DocEffigy)effigy,""String_Node_Str"");
      ((DocTableau)tableau).setTitle(""String_Node_Str"" + target.getFullName());
    }
 catch (    KernelException exception) {
      throw new InternalErrorException(exception);
    }
  }
 else {
    if (_isMultipleDocumentationAllowed()) {
      try {
        tableau=new DocTableau((DocEffigy)effigy,effigy.uniqueName(""String_Node_Str""));
        ((DocTableau)tableau).setTitle(""String_Node_Str"" + target.getFullName());
      }
 catch (      KernelException exception) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"" + target.getFullName() + ""String_Node_Str"",exception);
      }
    }
  }
  if (!(tableau instanceof DocTableau)) {
    MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"");
  }
  ((DocTableau)tableau).show();
}"
73401,"/** 
 * Construct an actor with the specified container and name.
 * @param container The composite entity to contain this one.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public AbsoluteDelay(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  outputTime=new TypedIOPort(this,""String_Node_Str"",true,false);
  _zero=new Time(getDirector());
  Set<Port> dependentPorts=_causalityMarker.causalityMarker.get(0);
  dependentPorts.add(input);
  dependentPorts.add(outputTime);
  _causalityMarker.addDependentPortSet(dependentPorts);
}","/** 
 * Construct an actor with the specified container and name.
 * @param container The composite entity to contain this one.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public AbsoluteDelay(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  outputTime=new TypedIOPort(this,""String_Node_Str"",true,false);
  Set<Port> dependentPorts=_causalityMarker.causalityMarker.get(0);
  dependentPorts.add(input);
  dependentPorts.add(outputTime);
  _causalityMarker.addDependentPortSet(dependentPorts);
}"
73402,"/** 
 * Process the current input if it has not been processed. Schedule a firing to produce the earliest output token.
 * @exception IllegalActionException If scheduling to refire cannotbe performed or the superclass throws it.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  Time time=currentTime.subtract(_outputTime);
  if (time.compareTo(_zero) < 0) {
    _delay=-time.getDoubleValue();
  }
 else {
    _delay=0;
  }
  return super.postfire();
}","/** 
 * Process the current input if it has not been processed. Schedule a firing to produce the earliest output token.
 * @exception IllegalActionException If scheduling to refire cannotbe performed or the superclass throws it.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  Time time=currentTime.subtract(_outputTime);
  if (time.isNegative()) {
    _delay=-time.getDoubleValue();
  }
 else {
    _delay=0;
  }
  return super.postfire();
}"
73403,"/** 
 * Override the _transferOutputs() function. First, for tokens that are stored in the actuator event queue, send them to the outside of the platform if physical time has arrived. Second, compare current model time with simulated physical time. If physical time is smaller than current model time, then deadline has been missed. Throw an exception unless the port is annotated with ignoreDeadline. If the deadline has been missed and ignoreDeadline is true, or if the current model time is equal to the physical time, or if the port is annotated with transferImmediately, we send the tokens to the outside. If current model time has not arrived at the physical time, we put the token along with the destination port and channel into the actuator event queue, and call fireAt of the executive director so we could send it at a later physical time. <p> As described in the comment for this class, there are two versions of simulated physical time: oracle simulated physical time, and platform simulated physical time. The time at which an actuation event is sent to the output port uses the platform simulated physical time. </p>
 * @param port The port to transfer tokens to.
 * @return True if at least one data token is transferred.
 * @exception IllegalActionException If the port is not an opaqueinput port, if the super class throws it, if physical tag cannot be evaluated, or if the token cannot be sent to the inside.
 */
protected boolean _transferOutputs(IOPort port) throws IllegalActionException {
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  boolean result=false;
  Tag platformPhysicalTag=getPlatformPhysicalTag(platformTimeClock);
  int compare=0;
  while (true) {
    if (_realTimeOutputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent tokenEvent=(RealTimeEvent)_realTimeOutputEventQueue.peek();
    compare=tokenEvent.deliveryTag.compareTo(platformPhysicalTag);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      _realTimeOutputEventQueue.poll();
      tokenEvent.port.send(tokenEvent.channel,tokenEvent.token);
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + tokenEvent.token + ""String_Node_Str""+ tokenEvent.port.getName());
      }
      result=true;
    }
 else     if (compare < 0) {
      throw new IllegalActionException(tokenEvent.port,""String_Node_Str"" + tokenEvent.deliveryTag.timestamp + ""String_Node_Str""+ tokenEvent.deliveryTag.microstep+ ""String_Node_Str""+ platformPhysicalTag.timestamp+ ""String_Node_Str""+ platformPhysicalTag.microstep);
    }
  }
  Double actuatorDeviceDelay=_getDeviceDelay(port);
  Time deadline=_currentTime;
  if (actuatorDeviceDelay != null) {
    deadline=deadline.subtract(actuatorDeviceDelay);
  }
  compare=deadline.compareTo(platformPhysicalTag.timestamp);
  if (compare < 0 && !_ignoreDeadline(port)) {
    for (int i=0; i < port.getWidthInside(); i++) {
      if (port.hasTokenInside(i)) {
        throw new IllegalActionException(port,""String_Node_Str"" + _currentTime + ""String_Node_Str""+ platformPhysicalTag.timestamp);
      }
    }
  }
 else   if (compare == 0 || _transferImmediately(port) || (compare < 0 && _ignoreDeadline(port))) {
    while (true) {
      if (!super._transferOutputs(port)) {
        break;
      }
 else {
        result=true;
      }
    }
  }
 else {
    assert(compare > 0);
    for (int i=0; i < port.getWidthInside(); i++) {
      try {
        if (port.hasTokenInside(i)) {
          Token t=port.getInside(i);
          RealTimeEvent tokenEvent=new RealTimeEvent(port,i,t,new Tag(_currentTime,_microstep),null);
          _realTimeOutputEventQueue.add(tokenEvent);
          _fireAtPlatformTime(_currentTime,platformTimeClock);
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
  }
  return result;
}","/** 
 * Override the _transferOutputs() function. First, for tokens that are stored in the actuator event queue, send them to the outside of the platform if physical time has arrived. Second, compare current model time with simulated physical time. If physical time is smaller than current model time, then deadline has been missed. Throw an exception unless the port is annotated with ignoreDeadline. If the deadline has been missed and ignoreDeadline is true, or if the current model time is equal to the physical time, or if the port is annotated with transferImmediately, we send the tokens to the outside. If current model time has not arrived at the physical time, we put the token along with the destination port and channel into the actuator event queue, and call fireAt of the executive director so we could send it at a later physical time. <p> As described in the comment for this class, there are two versions of simulated physical time: oracle simulated physical time, and platform simulated physical time. The time at which an actuation event is sent to the output port uses the platform simulated physical time. </p>
 * @param port The port to transfer tokens to.
 * @return True if at least one data token is transferred.
 * @exception IllegalActionException If the port is not an opaqueinput port, if the super class throws it, if physical tag cannot be evaluated, or if the token cannot be sent to the inside.
 */
protected boolean _transferOutputs(IOPort port) throws IllegalActionException {
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  boolean result=false;
  Tag platformPhysicalTag=getPlatformPhysicalTag(platformTimeClock);
  int compare=0;
  while (true) {
    if (_realTimeOutputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent tokenEvent=(RealTimeEvent)_realTimeOutputEventQueue.peek();
    compare=tokenEvent.deliveryTag.compareTo(platformPhysicalTag);
    if (compare > 0) {
      if (tokenEvent.deliveryTag.timestamp.equals(platformPhysicalTag.timestamp)) {
        (((Actor)getContainer()).getExecutiveDirector()).fireAtCurrentTime((Actor)getContainer());
      }
      break;
    }
 else     if (compare == 0) {
      _realTimeOutputEventQueue.poll();
      tokenEvent.port.send(tokenEvent.channel,tokenEvent.token);
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + tokenEvent.token + ""String_Node_Str""+ tokenEvent.port.getName());
      }
      result=true;
    }
 else     if (compare < 0) {
      throw new IllegalActionException(tokenEvent.port,""String_Node_Str"" + tokenEvent.deliveryTag.timestamp + ""String_Node_Str""+ tokenEvent.deliveryTag.microstep+ ""String_Node_Str""+ platformPhysicalTag.timestamp+ ""String_Node_Str""+ platformPhysicalTag.microstep);
    }
  }
  Double actuatorDeviceDelay=_getDeviceDelay(port);
  Time deadline=_currentTime;
  if (actuatorDeviceDelay != null) {
    deadline=deadline.subtract(actuatorDeviceDelay);
  }
  compare=deadline.compareTo(platformPhysicalTag.timestamp);
  if (compare < 0 && !_ignoreDeadline(port)) {
    for (int i=0; i < port.getWidthInside(); i++) {
      if (port.hasTokenInside(i)) {
        throw new IllegalActionException(port,""String_Node_Str"" + _currentTime + ""String_Node_Str""+ platformPhysicalTag.timestamp);
      }
    }
  }
 else   if (compare == 0 || _transferImmediately(port) || (compare < 0 && _ignoreDeadline(port))) {
    while (true) {
      if (!super._transferOutputs(port)) {
        break;
      }
 else {
        result=true;
      }
    }
  }
 else {
    assert(compare > 0);
    for (int i=0; i < port.getWidthInside(); i++) {
      try {
        if (port.hasTokenInside(i)) {
          Token t=port.getInside(i);
          RealTimeEvent tokenEvent=new RealTimeEvent(port,i,t,new Tag(_currentTime,_microstep),null);
          _realTimeOutputEventQueue.add(tokenEvent);
          _fireAtPlatformTime(_currentTime,platformTimeClock);
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
  }
  return result;
}"
73404,"/** 
 * Generate code for replacing the get() macro. This delegates to the receiver adapter for the specified channel and asks it to generate the get code.
 * @param channel The channel for which to generate the get code.
 * @param offset The offset in the array representation of the port.
 * @return The code that gets data from the specified channel.
 * @exception IllegalActionException If the receiver adapter is not found or it encounters an error while generating the get code.
 */
public String generateGetCode(String channel,String offset) throws IllegalActionException {
  Receiver[][] receivers=getReceiverAdapters();
  int channelIndex=Integer.parseInt(channel);
  if (receivers.length != 0) {
    if (channelIndex >= receivers.length) {
      throw new IllegalActionException(getComponent(),""String_Node_Str"" + channelIndex + ""String_Node_Str""+ ""String_Node_Str""+ receivers.length+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ offset+ ""String_Node_Str"");
    }
    if (receivers[channelIndex].length > 1) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channelIndex].length > 0) {
      TypedIOPort port=(TypedIOPort)getComponent();
      try {
        if (port.getContainer() != null && ((Actor)port.getContainer()).getDirector() instanceof ptolemy.actor.sched.StaticSchedulingDirector) {
          return receivers[channelIndex][0].generateGetCode(offset);
        }
 else {
          String portName=StringUtilities.sanitizeName(port.getFullName());
          if (portName.startsWith(""String_Node_Str"")) {
            portName=portName.substring(1,portName.length());
          }
          portName=TemplateParser.escapePortName(portName);
          if (port.isMultiport()) {
            return portName + ""String_Node_Str"" + offset+ ""String_Node_Str"";
          }
 else {
            if (!((BooleanToken)getCodeGenerator().variablesAsArrays.getToken()).booleanValue()) {
              return portName;
            }
            return getCodeGenerator().generatePortName(port,portName,1);
          }
        }
      }
 catch (      Exception ex) {
        throw new IllegalActionException(getComponent(),ex,""String_Node_Str"" + receivers[channelIndex][0] + ""String_Node_Str""+ channelIndex);
      }
    }
  }
  TypedIOPort port=(TypedIOPort)getComponent();
  Type type=port.getType();
  if (port instanceof ParameterPort) {
    Parameter parameter=((ParameterPort)getComponent()).getParameter();
    if (port.numLinks() <= 0) {
      if (parameter.isStringMode()) {
        return ""String_Node_Str"" + parameter.getExpression().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
      }
 else {
        return parameter.getValueAsString();
      }
    }
 else {
      throw new InternalErrorException(port,null,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  String typeString=getCodeGenerator().codeGenType(type);
  System.err.println(""String_Node_Str"");
  return ""String_Node_Str"" + getCodeGenerator().codeGenType(BaseType.INT) + ""String_Node_Str""+ typeString+ ""String_Node_Str"";
}","/** 
 * Generate code for replacing the get() macro. This delegates to the receiver adapter for the specified channel and asks it to generate the get code.
 * @param channel The channel for which to generate the get code.
 * @param offset The offset in the array representation of the port.
 * @return The code that gets data from the specified channel.
 * @exception IllegalActionException If the receiver adapter is not found or it encounters an error while generating the get code.
 */
public String generateGetCode(String channel,String offset) throws IllegalActionException {
  Receiver[][] receivers=getReceiverAdapters();
  int channelIndex=Integer.parseInt(channel);
  if (receivers.length != 0) {
    if (channelIndex >= receivers.length) {
      throw new IllegalActionException(getComponent(),""String_Node_Str"" + channelIndex + ""String_Node_Str""+ ""String_Node_Str""+ receivers.length+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ offset+ ""String_Node_Str"");
    }
    if (receivers[channelIndex].length > 1) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channelIndex].length > 0) {
      TypedIOPort port=(TypedIOPort)getComponent();
      try {
        if (port.getContainer() != null && ((Actor)port.getContainer()).getDirector() instanceof ptolemy.actor.sched.StaticSchedulingDirector) {
          return receivers[channelIndex][0].generateGetCode(offset);
        }
 else {
          String portName=StringUtilities.sanitizeName(port.getFullName());
          if (portName.startsWith(""String_Node_Str"")) {
            portName=portName.substring(1,portName.length());
          }
          portName=TemplateParser.escapePortName(portName);
          if (port.isMultiport()) {
            return portName + ""String_Node_Str"" + offset+ ""String_Node_Str"";
          }
 else {
            if (!((BooleanToken)getCodeGenerator().variablesAsArrays.getToken()).booleanValue()) {
              return portName;
            }
            return getCodeGenerator().generatePortName(port,portName,1);
          }
        }
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(getComponent(),throwable,""String_Node_Str"" + receivers[channelIndex][0] + ""String_Node_Str""+ channelIndex);
      }
    }
  }
  TypedIOPort port=(TypedIOPort)getComponent();
  Type type=port.getType();
  if (port instanceof ParameterPort) {
    Parameter parameter=((ParameterPort)getComponent()).getParameter();
    if (port.numLinks() <= 0) {
      if (parameter.isStringMode()) {
        return ""String_Node_Str"" + parameter.getExpression().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
      }
 else {
        return parameter.getValueAsString();
      }
    }
 else {
      throw new InternalErrorException(port,null,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  String typeString=getCodeGenerator().codeGenType(type);
  System.err.println(""String_Node_Str"");
  return ""String_Node_Str"" + getCodeGenerator().codeGenType(BaseType.INT) + ""String_Node_Str""+ typeString+ ""String_Node_Str"";
}"
73405,"/** 
 * Generate the fire code of the associated composite actor. This method first generates code for transferring any data from the input ports of this composite to the ports connected on the inside by calling the generateTransferInputsCode() method of the local director adapter. It then invokes the generateFireCode() method of its local director adapter.  After the generateFireCode() method of the director adapter returns, generate code for transferring any output data created by calling the local director adapter's generateTransferOutputsCode() method.
 * @return The generated fire code.
 * @exception IllegalActionException If the adapter associatedwith an actor throws it while generating fire code for the actor, or the director adapter throws it while generating code for transferring data.
 */
@Override protected String _generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(getCodeGenerator().comment(2,""String_Node_Str"" + getComponent().getName()));
  Director directorAdapter=(Director)getCodeGenerator().getAdapter(((ptolemy.actor.CompositeActor)getComponent()).getDirector());
  Iterator<?> inputPorts=((ptolemy.actor.CompositeActor)getComponent()).inputPortList().iterator();
  StringBuffer tempCode=new StringBuffer();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    if (inputPort instanceof ParameterPort && inputPort.isOutsideConnected()) {
      PortParameter portParameter=((ParameterPort)inputPort).getParameter();
      tempCode.append(CodeStream.indent(getCodeGenerator().generateVariableName(portParameter)));
      tempCode.append(""String_Node_Str"");
      String reference=getReference(inputPort.getName(),false);
      if (reference != ""String_Node_Str"") {
        tempCode.append(reference);
      }
 else {
        tempCode.append(getReference(inputPort.getName(),true));
      }
      tempCode.append(""String_Node_Str"" + _eol);
    }
  }
  if (tempCode.length() > 0) {
    code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + getComponent().getName() + ""String_Node_Str"")));
    code.append(tempCode);
  }
  inputPorts=((ptolemy.actor.CompositeActor)getComponent()).inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    if (!(inputPort instanceof ParameterPort)) {
      directorAdapter.generateTransferInputsCode(inputPort,code);
    }
  }
  code.append(directorAdapter.generateFireCode());
  Iterator<?> outputPorts=((ptolemy.actor.CompositeActor)getComponent()).outputPortList().iterator();
  if ((getComponent() instanceof ModularCodeGenTypedCompositeActor) && ((ptolemy.actor.CompositeActor)getComponent()).outputPortList().size() > 0)   code.append(""String_Node_Str"" + _eol);
  while (outputPorts.hasNext()) {
    IOPort outputPort=(IOPort)outputPorts.next();
    directorAdapter.generateTransferOutputsCode(outputPort,code);
  }
  return processCode(code.toString());
}","/** 
 * Generate the fire code of the associated composite actor. This method first generates code for transferring any data from the input ports of this composite to the ports connected on the inside by calling the generateTransferInputsCode() method of the local director adapter. It then invokes the generateFireCode() method of its local director adapter.  After the generateFireCode() method of the director adapter returns, generate code for transferring any output data created by calling the local director adapter's generateTransferOutputsCode() method.
 * @return The generated fire code.
 * @exception IllegalActionException If the adapter associatedwith an actor throws it while generating fire code for the actor, or the director adapter throws it while generating code for transferring data.
 */
@Override protected String _generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(getCodeGenerator().comment(2,""String_Node_Str"" + getComponent().getName()));
  Director directorAdapter=(Director)getCodeGenerator().getAdapter(((ptolemy.actor.CompositeActor)getComponent()).getDirector());
  Iterator<?> inputPorts=((ptolemy.actor.CompositeActor)getComponent()).inputPortList().iterator();
  StringBuffer tempCode=new StringBuffer();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    if (inputPort instanceof ParameterPort && inputPort.isOutsideConnected()) {
      PortParameter portParameter=((ParameterPort)inputPort).getParameter();
      tempCode.append(CodeStream.indent(getCodeGenerator().generateVariableName(portParameter)));
      tempCode.append(""String_Node_Str"");
      String reference=getReference(inputPort.getName(),false);
      if (!reference.equals(""String_Node_Str"")) {
        tempCode.append(reference);
      }
 else {
        tempCode.append(getReference(inputPort.getName(),true));
      }
      tempCode.append(""String_Node_Str"" + _eol);
    }
  }
  if (tempCode.length() > 0) {
    code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + getComponent().getName() + ""String_Node_Str"")));
    code.append(tempCode);
  }
  inputPorts=((ptolemy.actor.CompositeActor)getComponent()).inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    if (!(inputPort instanceof ParameterPort)) {
      directorAdapter.generateTransferInputsCode(inputPort,code);
    }
  }
  code.append(directorAdapter.generateFireCode());
  Iterator<?> outputPorts=((ptolemy.actor.CompositeActor)getComponent()).outputPortList().iterator();
  if ((getComponent() instanceof ModularCodeGenTypedCompositeActor) && ((ptolemy.actor.CompositeActor)getComponent()).outputPortList().size() > 0)   code.append(""String_Node_Str"" + _eol);
  while (outputPorts.hasNext()) {
    IOPort outputPort=(IOPort)outputPorts.next();
    directorAdapter.generateTransferOutputsCode(outputPort,code);
  }
  return processCode(code.toString());
}"
73406,"/** 
 * Generate preinitialize code. Read the <code>CommonPreinitBlock</code> from MovingAverage.c replace macros with their values and return the processed code block.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
public String generatePreinitializeCode() throws IllegalActionException {
  super.generatePreinitializeCode();
  ptolemy.actor.lib.MovingAverage actor=(ptolemy.actor.lib.MovingAverage)getComponent();
  ArrayList<String> args=new ArrayList<String>();
  CodeStream codeStream=_templateParser.getCodeStream();
  Type type=actor.output.getType();
  if (getCodeGenerator().isPrimitive(type)) {
    args.add(targetType(type).toString());
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + type + ""String_Node_Str"");
  }
  return processCode(codeStream.toString());
}","/** 
 * Generate preinitialize code. Read the <code>CommonPreinitBlock</code> from MovingAverage.c replace macros with their values and return the processed code block.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
public String generatePreinitializeCode() throws IllegalActionException {
  super.generatePreinitializeCode();
  ptolemy.actor.lib.MovingAverage actor=(ptolemy.actor.lib.MovingAverage)getComponent();
  ArrayList<String> args=new ArrayList<String>();
  CodeStream codeStream=_templateParser.getCodeStream();
  Type type=actor.output.getType();
  if (getCodeGenerator().isPrimitive(type)) {
    args.add(targetType(type));
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + type + ""String_Node_Str"");
  }
  return processCode(codeStream.toString());
}"
73407,"/** 
 * Generate fire code. The method reads in <code>fireBlock</code> from Subscriber.c and replaces macros with their values and returns the processed code block.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.SubscriptionAggregator actor=(ptolemy.actor.lib.SubscriptionAggregator)getComponent();
  CodeStream codeStream=_templateParser.getCodeStream();
  if (actor.input.isOutsideConnected()) {
    codeStream.appendCodeBlock(""String_Node_Str"",false);
    ArrayList<String> args=new ArrayList<String>();
    args.add(Integer.toString(0));
    for (int i=1; i < actor.input.getWidth(); i++) {
      args.set(0,Integer.toString(i));
      if (actor.operation.stringValue().equals(""String_Node_Str"")) {
        codeStream.appendCodeBlock(""String_Node_Str"",args);
      }
 else       if (actor.operation.stringValue().equals(""String_Node_Str"")) {
        codeStream.appendCodeBlock(""String_Node_Str"",args);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + actor.operation + ""String_Node_Str"");
      }
    }
    codeStream.appendCodeBlock(""String_Node_Str"",false);
  }
  return processCode(codeStream.toString());
}","/** 
 * Generate fire code. The method reads in <code>fireBlock</code> from Subscriber.c and replaces macros with their values and returns the processed code block.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.SubscriptionAggregator actor=(ptolemy.actor.lib.SubscriptionAggregator)getComponent();
  CodeStream codeStream=_templateParser.getCodeStream();
  if (actor.input.isOutsideConnected()) {
    codeStream.appendCodeBlock(""String_Node_Str"",false);
    ArrayList<String> args=new ArrayList<String>();
    args.add(""String_Node_Str"");
    for (int i=1; i < actor.input.getWidth(); i++) {
      args.set(0,Integer.toString(i));
      if (actor.operation.stringValue().equals(""String_Node_Str"")) {
        codeStream.appendCodeBlock(""String_Node_Str"",args);
      }
 else       if (actor.operation.stringValue().equals(""String_Node_Str"")) {
        codeStream.appendCodeBlock(""String_Node_Str"",args);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + actor.operation + ""String_Node_Str"");
      }
    }
    codeStream.appendCodeBlock(""String_Node_Str"",false);
  }
  return processCode(codeStream.toString());
}"
73408,"/** 
 * Generate fire code. The method reads in <code>fireBlock</code> from VectorAssembler.c, replaces macros with their values and returns the processed code block.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.VectorAssembler actor=(ptolemy.actor.lib.VectorAssembler)getComponent();
  StringBuffer fireCode=new StringBuffer();
  ArrayList<String> args=new ArrayList<String>();
  args.add(Integer.toString(0));
  Type type=actor.input.getType();
  if (getCodeGenerator().isPrimitive(type)) {
    args.add(getCodeGenerator().codeGenType(type).toString());
  }
  for (int i=0; i < actor.input.getWidth(); i++) {
    args.set(0,Integer.toString(i));
    fireCode.append(getTemplateParser().generateBlockCode(""String_Node_Str"",args));
  }
  return processCode(fireCode.toString());
}","/** 
 * Generate fire code. The method reads in <code>fireBlock</code> from VectorAssembler.c, replaces macros with their values and returns the processed code block.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.VectorAssembler actor=(ptolemy.actor.lib.VectorAssembler)getComponent();
  StringBuffer fireCode=new StringBuffer();
  ArrayList<String> args=new ArrayList<String>();
  args.add(""String_Node_Str"");
  Type type=actor.input.getType();
  if (getCodeGenerator().isPrimitive(type)) {
    args.add(getCodeGenerator().codeGenType(type).toString());
  }
  for (int i=0; i < actor.input.getWidth(); i++) {
    args.set(0,Integer.toString(i));
    fireCode.append(getTemplateParser().generateBlockCode(""String_Node_Str"",args));
  }
  return processCode(fireCode.toString());
}"
73409,"/** 
 * Generate fire code. The method reads in <code>fireBlock</code> from VectorDisassembler.c, replaces macros with their values and returns the processed code block.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.VectorDisassembler actor=(ptolemy.actor.lib.VectorDisassembler)getComponent();
  StringBuffer fireCode=new StringBuffer();
  ArrayList<String> args=new ArrayList<String>();
  args.add(Integer.toString(actor.output.getWidth()));
  fireCode.append(getTemplateParser().generateBlockCode(""String_Node_Str"",args));
  ArrayList<String> args2=new ArrayList<String>();
  Type type=actor.output.getType();
  if (getCodeGenerator().isPrimitive(type)) {
    args2.add(getCodeGenerator().codeGenType(type).toString());
    fireCode.append(getTemplateParser().generateBlockCode(""String_Node_Str"",args2));
  }
 else {
    fireCode.append(getTemplateParser().generateBlockCode(""String_Node_Str"",args2));
  }
  ArrayList<String> args3=new ArrayList<String>();
  args3.add(Integer.toString(0));
  for (int i=0; i < actor.output.numberOfSinks(); i++) {
    args3.set(0,Integer.toString(i));
    fireCode.append(getTemplateParser().generateBlockCode(""String_Node_Str"",args3));
  }
  return processCode(fireCode.toString());
}","/** 
 * Generate fire code. The method reads in <code>fireBlock</code> from VectorDisassembler.c, replaces macros with their values and returns the processed code block.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.VectorDisassembler actor=(ptolemy.actor.lib.VectorDisassembler)getComponent();
  StringBuffer fireCode=new StringBuffer();
  ArrayList<String> args=new ArrayList<String>();
  args.add(Integer.toString(actor.output.getWidth()));
  fireCode.append(getTemplateParser().generateBlockCode(""String_Node_Str"",args));
  ArrayList<String> args2=new ArrayList<String>();
  Type type=actor.output.getType();
  if (getCodeGenerator().isPrimitive(type)) {
    args2.add(getCodeGenerator().codeGenType(type));
    fireCode.append(getTemplateParser().generateBlockCode(""String_Node_Str"",args2));
  }
 else {
    fireCode.append(getTemplateParser().generateBlockCode(""String_Node_Str"",args2));
  }
  ArrayList<String> args3=new ArrayList<String>();
  args3.add(Integer.toString(0));
  for (int i=0; i < actor.output.numberOfSinks(); i++) {
    args3.set(0,Integer.toString(i));
    fireCode.append(getTemplateParser().generateBlockCode(""String_Node_Str"",args3));
  }
  return processCode(fireCode.toString());
}"
73410,"/** 
 * Generate variable declarations for inputs and outputs and parameters. Append the declarations to the given string buffer.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableDeclaration() throws IllegalActionException {
  StringBuffer code=new StringBuffer(super.generateVariableDeclaration());
  Iterator refinements=((CompositeActor)getComponent()).deepEntityList().iterator();
  while (refinements.hasNext()) {
    CompositeActor refinement=(CompositeActor)refinements.next();
    code.append(getCodeGenerator().comment(""String_Node_Str"" + refinement.getFullName()));
    NamedProgramCodeGeneratorAdapter refinementAdapter=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(refinement);
  }
  Iterator<?> ports=((ptolemy.kernel.Entity)getComponent()).portList().iterator();
  while (ports.hasNext()) {
    ptolemy.actor.TypedIOPort port=(ptolemy.actor.TypedIOPort)ports.next();
    code.append(getCodeGenerator().comment(""String_Node_Str"" + port.getFullName()));
    NamedProgramCodeGeneratorAdapter portAdapter=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(port);
    _portVariableDeclaration(code,port);
  }
  return code.toString();
}","/** 
 * Generate variable declarations for inputs and outputs and parameters. Append the declarations to the given string buffer.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableDeclaration() throws IllegalActionException {
  StringBuffer code=new StringBuffer(super.generateVariableDeclaration());
  Iterator refinements=((CompositeActor)getComponent()).deepEntityList().iterator();
  while (refinements.hasNext()) {
    CompositeActor refinement=(CompositeActor)refinements.next();
    code.append(getCodeGenerator().comment(""String_Node_Str"" + refinement.getFullName()));
  }
  Iterator<?> ports=((ptolemy.kernel.Entity)getComponent()).portList().iterator();
  while (ports.hasNext()) {
    ptolemy.actor.TypedIOPort port=(ptolemy.actor.TypedIOPort)ports.next();
    code.append(getCodeGenerator().comment(""String_Node_Str"" + port.getFullName()));
    _portVariableDeclaration(code,port);
  }
  return code.toString();
}"
73411,"/** 
 * Generate a string that represents the offset for a dynamically determined channel of a multiport.
 * @param port The referenced port.
 * @param isWrite Whether to generate the write or read offset.
 * @param channelString The string that will determine the channel.
 * @return The expression that represents the offset for a channel determineddynamically in the generated code.
 */
private String _generateChannelOffset(IOPort port,boolean isWrite,String channelString) throws IllegalActionException {
  if (channelString.equals(""String_Node_Str"")) {
    channelString=""String_Node_Str"";
  }
  String channelOffset=generatePortName((TypedIOPort)port) + ((isWrite) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ channelString+ ""String_Node_Str"";
  return channelOffset;
}","/** 
 * Generate a string that represents the offset for a dynamically determined channel of a multiport.
 * @param port The referenced port.
 * @param isWrite Whether to generate the write or read offset.
 * @param channelString The string that will determine the channel.
 * @return The expression that represents the offset for a channel determineddynamically in the generated code.
 */
private String _generateChannelOffset(TypedIOPort port,boolean isWrite,String channelString) throws IllegalActionException {
  if (channelString.equals(""String_Node_Str"")) {
    channelString=""String_Node_Str"";
  }
  String channelOffset=generatePortName(port) + ((isWrite) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ channelString+ ""String_Node_Str"";
  return channelOffset;
}"
73412,"/** 
 * Return an unique label for the given port channel referenced by the given adapter. By default, this delegates to the adapter to  generate the reference. Subclass may override this method to generate the desire label according to the given parameters.
 * @param port The given port.
 * @param channelAndOffset The given channel and offset.
 * @param forComposite Whether the given adapter is associated witha CompositeActor
 * @param isWrite The type of the reference. True if this isa write reference; otherwise, this is a read reference.  
 * @param target The ProgramCodeGeneratorAdapter for which codeneeds to be generated.
 * @return an unique reference label for the given port channel.
 * @exception IllegalActionException If the adapter throws it whilegenerating the label.     
 */
public String getReference(TypedIOPort port,String[] channelAndOffset,boolean forComposite,boolean isWrite,NamedProgramCodeGeneratorAdapter target) throws IllegalActionException {
  boolean dynamicReferencesAllowed=allowDynamicMultiportReference();
  int channelNumber=0;
  boolean isChannelNumberInt=true;
  if (!channelAndOffset[0].equals(""String_Node_Str"")) {
    if (dynamicReferencesAllowed) {
      try {
        channelNumber=(Integer.valueOf(channelAndOffset[0])).intValue();
      }
 catch (      Exception ex) {
        isChannelNumberInt=false;
      }
    }
 else {
      channelNumber=(Integer.valueOf(channelAndOffset[0])).intValue();
    }
  }
  if (!isChannelNumberInt) {
    if (port.isOutput()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      String returnValue=_generatePortReference(port,channelAndOffset,isWrite);
      return returnValue;
    }
  }
  StringBuffer result=new StringBuffer();
  if (_checkRemote(forComposite,port)) {
    Receiver[][] remoteReceivers;
    if (port.isOutput()) {
      remoteReceivers=port.getRemoteReceivers();
    }
 else {
      remoteReceivers=port.deepGetReceivers();
    }
    if (remoteReceivers.length == 0) {
      String returnValue=generatePortName(port);
      return returnValue;
    }
    ProgramCodeGeneratorAdapter.Channel sourceChannel=new ProgramCodeGeneratorAdapter.Channel(port,channelNumber);
    List<ProgramCodeGeneratorAdapter.Channel> typeConvertSinks=target.getTypeConvertSinkChannels(sourceChannel);
    List<ProgramCodeGeneratorAdapter.Channel> sinkChannels=getSinkChannels(port,channelNumber);
    boolean hasTypeConvertReference=false;
    for (int i=0; i < sinkChannels.size(); i++) {
      ProgramCodeGeneratorAdapter.Channel channel=sinkChannels.get(i);
      IOPort sinkPort=channel.port;
      int sinkChannelNumber=channel.channelNumber;
      if (typeConvertSinks.contains(channel) && getCodeGenerator().isPrimitive(((TypedIOPort)sourceChannel.port).getType())) {
        if (!hasTypeConvertReference) {
          if (i != 0) {
            result.append(""String_Node_Str"");
          }
          result.append(getTypeConvertReference(sourceChannel));
          if (dynamicReferencesAllowed && port.isInput()) {
            if (channelAndOffset[1].trim().length() > 0) {
              result.append(""String_Node_Str"" + channelAndOffset[1].trim() + ""String_Node_Str"");
            }
 else {
              result.append(""String_Node_Str"" + _generateChannelOffset(port,isWrite,channelAndOffset[0]) + ""String_Node_Str"");
            }
          }
 else {
            int rate=Math.max(DFUtilities.getTokenProductionRate(sourceChannel.port),DFUtilities.getTokenConsumptionRate(sourceChannel.port));
            if (rate > 1 && channelAndOffset[1].trim().length() > 0) {
              result.append(""String_Node_Str"" + channelAndOffset[1].trim() + ""String_Node_Str"");
            }
          }
          hasTypeConvertReference=true;
        }
 else {
          continue;
        }
      }
 else {
        if (i != 0) {
          result.append(""String_Node_Str"");
        }
        result.append(generatePortName((TypedIOPort)sinkPort));
        if (sinkPort.isMultiport()) {
          result.append(""String_Node_Str"" + sinkChannelNumber + ""String_Node_Str"");
        }
        if (channelAndOffset[1].equals(""String_Node_Str"")) {
          channelAndOffset[1]=""String_Node_Str"";
        }
        result.append(_ports.generateOffset(sinkPort,channelAndOffset[1],sinkChannelNumber,true));
      }
    }
    return result.toString();
  }
  if (_checkLocal(forComposite,port)) {
    result.append(generatePortName(port));
    if (port.isMultiport()) {
      result.append(""String_Node_Str"" + channelAndOffset[0] + ""String_Node_Str"");
    }
    result.append(_ports.generateOffset(port,channelAndOffset[1],channelNumber,isWrite));
    return result.toString();
  }
  return ""String_Node_Str"";
}","/** 
 * Return an unique label for the given port channel referenced by the given adapter. By default, this delegates to the adapter to  generate the reference. Subclass may override this method to generate the desire label according to the given parameters.
 * @param port The given port.
 * @param channelAndOffset The given channel and offset.
 * @param forComposite Whether the given adapter is associated witha CompositeActor
 * @param isWrite The type of the reference. True if this isa write reference; otherwise, this is a read reference.  
 * @param target The ProgramCodeGeneratorAdapter for which codeneeds to be generated.
 * @return an unique reference label for the given port channel.
 * @exception IllegalActionException If the adapter throws it whilegenerating the label.     
 */
public String getReference(TypedIOPort port,String[] channelAndOffset,boolean forComposite,boolean isWrite,NamedProgramCodeGeneratorAdapter target) throws IllegalActionException {
  boolean dynamicReferencesAllowed=allowDynamicMultiportReference();
  int channelNumber=0;
  boolean isChannelNumberInt=true;
  if (!channelAndOffset[0].equals(""String_Node_Str"")) {
    if (dynamicReferencesAllowed) {
      try {
        channelNumber=(Integer.valueOf(channelAndOffset[0])).intValue();
      }
 catch (      NumberFormatException ex) {
        isChannelNumberInt=false;
      }
    }
 else {
      channelNumber=(Integer.valueOf(channelAndOffset[0])).intValue();
    }
  }
  if (!isChannelNumberInt) {
    if (port.isOutput()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      String returnValue=_generatePortReference(port,channelAndOffset,isWrite);
      return returnValue;
    }
  }
  StringBuffer result=new StringBuffer();
  if (_checkRemote(forComposite,port)) {
    Receiver[][] remoteReceivers;
    if (port.isOutput()) {
      remoteReceivers=port.getRemoteReceivers();
    }
 else {
      remoteReceivers=port.deepGetReceivers();
    }
    if (remoteReceivers.length == 0) {
      String returnValue=generatePortName(port);
      return returnValue;
    }
    ProgramCodeGeneratorAdapter.Channel sourceChannel=new ProgramCodeGeneratorAdapter.Channel(port,channelNumber);
    List<ProgramCodeGeneratorAdapter.Channel> typeConvertSinks=target.getTypeConvertSinkChannels(sourceChannel);
    List<ProgramCodeGeneratorAdapter.Channel> sinkChannels=getSinkChannels(port,channelNumber);
    boolean hasTypeConvertReference=false;
    for (int i=0; i < sinkChannels.size(); i++) {
      ProgramCodeGeneratorAdapter.Channel channel=sinkChannels.get(i);
      TypedIOPort sinkPort=(TypedIOPort)channel.port;
      int sinkChannelNumber=channel.channelNumber;
      if (typeConvertSinks.contains(channel) && getCodeGenerator().isPrimitive(((TypedIOPort)sourceChannel.port).getType())) {
        if (!hasTypeConvertReference) {
          if (i != 0) {
            result.append(""String_Node_Str"");
          }
          result.append(getTypeConvertReference(sourceChannel));
          if (dynamicReferencesAllowed && port.isInput()) {
            if (channelAndOffset[1].trim().length() > 0) {
              result.append(""String_Node_Str"" + channelAndOffset[1].trim() + ""String_Node_Str"");
            }
 else {
              result.append(""String_Node_Str"" + _generateChannelOffset(port,isWrite,channelAndOffset[0]) + ""String_Node_Str"");
            }
          }
 else {
            int rate=Math.max(DFUtilities.getTokenProductionRate(sourceChannel.port),DFUtilities.getTokenConsumptionRate(sourceChannel.port));
            if (rate > 1 && channelAndOffset[1].trim().length() > 0) {
              result.append(""String_Node_Str"" + channelAndOffset[1].trim() + ""String_Node_Str"");
            }
          }
          hasTypeConvertReference=true;
        }
 else {
          continue;
        }
      }
 else {
        if (i != 0) {
          result.append(""String_Node_Str"");
        }
        result.append(generatePortName(sinkPort));
        if (sinkPort.isMultiport()) {
          result.append(""String_Node_Str"" + sinkChannelNumber + ""String_Node_Str"");
        }
        if (channelAndOffset[1].equals(""String_Node_Str"")) {
          channelAndOffset[1]=""String_Node_Str"";
        }
        result.append(_ports.generateOffset(sinkPort,channelAndOffset[1],sinkChannelNumber,true));
      }
    }
    return result.toString();
  }
  if (_checkLocal(forComposite,port)) {
    result.append(generatePortName(port));
    if (port.isMultiport()) {
      result.append(""String_Node_Str"" + channelAndOffset[0] + ""String_Node_Str"");
    }
    result.append(_ports.generateOffset(port,channelAndOffset[1],channelNumber,isWrite));
    return result.toString();
  }
  return ""String_Node_Str"";
}"
73413,"/** 
 * Generate code for making transition. It generates code for both choice action and commit action.
 * @param code The string buffer that the generated code is appended to.
 * @param transitionRetriever An instance of a class implementinga method. which returns an iterator of all, preemptive or non-preemptive transitions of the current state.
 * @exception IllegalActionException If thrown while generatingtransition code.
 */
public void generateTransitionCode(StringBuffer code,TransitionRetriever transitionRetriever) throws IllegalActionException {
  StringBuffer codeBuffer=new StringBuffer();
  ptolemy.domains.modal.kernel.FSMActor fsmActor=(ptolemy.domains.modal.kernel.FSMActor)getComponent();
  codeBuffer.append(""String_Node_Str"" + _eol);
  codeBuffer.append(""String_Node_Str"" + _eol);
  for (  State state : (List<State>)fsmActor.entityList()) {
    codeBuffer.append(""String_Node_Str"" + _generateStateConstantLabel(state) + ""String_Node_Str""+ _eol);
    Iterator transitions=transitionRetriever.retrieveTransitions(state);
    List reOrderedTransitions=new LinkedList();
    List defaultTransitions=new LinkedList();
    while (transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      if (generateSimpleName(transition).equals(""String_Node_Str"")) {
        defaultTransitions.add(transition);
      }
 else {
        reOrderedTransitions.add(transition);
      }
    }
    reOrderedTransitions.addAll(defaultTransitions);
    transitions=reOrderedTransitions.iterator();
    int transitionCount=0;
    boolean hasDefaultCase=false;
    while (!hasDefaultCase && transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      String guard=transition.getGuardExpression();
      if (transition.isDefault() || guard.toLowerCase().equals(""String_Node_Str"")) {
        hasDefaultCase=true;
      }
 else {
        if (transitionCount == 0) {
          codeBuffer.append(""String_Node_Str"");
        }
 else {
          codeBuffer.append(""String_Node_Str"");
        }
        transitionCount++;
        PtParser parser=new PtParser();
        int index=guard.indexOf(""String_Node_Str"");
        ASTPtRootNode guardParseTree=parser.generateParseTree(guard);
        ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
        parseTreeCodeGenerator.evaluateParseTree(guardParseTree,_scope);
        int index2=transition.getFullName().indexOf(""String_Node_Str"");
        String tempName=transition.getFullName().substring(1,index2) + guard.substring(0,index - 1);
        tempName=tempName.replace(""String_Node_Str"",""String_Node_Str"");
        codeBuffer.append(tempName + ""String_Node_Str"");
        codeBuffer.append(""String_Node_Str"");
        codeBuffer.append(""String_Node_Str"");
      }
      codeBuffer.append(""String_Node_Str"" + _eol);
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.choiceActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          StringBuffer sendCode=new StringBuffer();
          if (channel >= 0) {
            codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            if (((IOPort)destination).isInput()) {
              NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
              StringBuffer containerReference=new StringBuffer();
              containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
              if (((IOPort)destination).isMultiport()) {
                containerReference.append(""String_Node_Str"" + channel);
              }
              containerReference.append(""String_Node_Str"");
              codeBuffer.append((containerHelper).processCode(containerReference.toString()) + ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol);
            }
          }
 else {
            int width=((IOPort)action.getDestination(destinationName)).getWidth();
            for (int i=0; i < width; i++) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str""+ _eol);
              if (((IOPort)destination).isInput()) {
                NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
                StringBuffer containerReference=new StringBuffer();
                containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
                if (((IOPort)destination).isMultiport()) {
                  containerReference.append(""String_Node_Str"" + i);
                }
                containerReference.append(""String_Node_Str"");
                codeBuffer.append((containerHelper).processCode(containerReference.toString()) + ""String_Node_Str"");
                sendCode.append(""String_Node_Str"" + generateSimpleName(destination) + ""String_Node_Str""+ i+ ""String_Node_Str""+ _eol);
              }
            }
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
          codeBuffer.append(sendCode);
        }
      }
      Actor[] actors=transition.getRefinement();
      if (actors != null) {
        for (int i=0; i < actors.length; i++) {
          NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
          codeBuffer.append(helper.generateFireCode());
        }
      }
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.commitActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          if (destination instanceof IOPort) {
            if (channel >= 0) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            }
 else {
              int width=((IOPort)action.getDestination(destinationName)).getWidth();
              for (int i=0; i < width; i++) {
                codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
              }
            }
          }
 else           if (destination instanceof Variable) {
            codeBuffer.append(getCodeGenerator().generateVariableName(destination) + ""String_Node_Str"");
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
        }
      }
      State destinationState=transition.destinationState();
      _updateCurrentState(codeBuffer,destinationState);
      BooleanToken resetToken=(BooleanToken)transition.reset.getToken();
      if (resetToken.booleanValue()) {
        actors=destinationState.getRefinement();
        if (actors != null) {
          for (int i=0; i < actors.length; ++i) {
            NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
            codeBuffer.append(helper.generateInitializeCode());
          }
        }
      }
      Director director=fsmActor.getExecutiveDirector();
      if (director instanceof ptolemy.domains.modal.kernel.MultirateFSMDirector) {
      }
      codeBuffer.append(""String_Node_Str"");
    }
    if (!hasDefaultCase) {
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol);
      }
 else {
        codeBuffer.append(_eol);
      }
      codeBuffer.append(""String_Node_Str"" + _eol);
      Director director=fsmActor.getExecutiveDirector();
      if (director instanceof ptolemy.domains.modal.kernel.MultirateFSMDirector) {
      }
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol);
      }
    }
    codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  }
  codeBuffer.append(""String_Node_Str"" + _eol);
  code.append(codeBuffer.toString());
}","/** 
 * Generate code for making transition. It generates code for both choice action and commit action.
 * @param code The string buffer that the generated code is appended to.
 * @param transitionRetriever An instance of a class implementinga method. which returns an iterator of all, preemptive or non-preemptive transitions of the current state.
 * @exception IllegalActionException If thrown while generatingtransition code.
 */
public void generateTransitionCode(StringBuffer code,TransitionRetriever transitionRetriever) throws IllegalActionException {
  StringBuffer codeBuffer=new StringBuffer();
  ptolemy.domains.modal.kernel.FSMActor fsmActor=(ptolemy.domains.modal.kernel.FSMActor)getComponent();
  codeBuffer.append(""String_Node_Str"" + _eol);
  codeBuffer.append(""String_Node_Str"" + _eol);
  for (  State state : (List<State>)fsmActor.entityList()) {
    codeBuffer.append(""String_Node_Str"" + _generateStateConstantLabel(state) + ""String_Node_Str""+ _eol);
    Iterator transitions=transitionRetriever.retrieveTransitions(state);
    List reOrderedTransitions=new LinkedList();
    List defaultTransitions=new LinkedList();
    while (transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      if (generateSimpleName(transition).equals(""String_Node_Str"")) {
        defaultTransitions.add(transition);
      }
 else {
        reOrderedTransitions.add(transition);
      }
    }
    reOrderedTransitions.addAll(defaultTransitions);
    transitions=reOrderedTransitions.iterator();
    int transitionCount=0;
    boolean hasDefaultCase=false;
    while (!hasDefaultCase && transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      String guard=transition.getGuardExpression();
      if (transition.isDefault() || guard.toLowerCase().equals(""String_Node_Str"")) {
        hasDefaultCase=true;
      }
 else {
        if (transitionCount == 0) {
          codeBuffer.append(""String_Node_Str"");
        }
 else {
          codeBuffer.append(""String_Node_Str"");
        }
        transitionCount++;
        PtParser parser=new PtParser();
        int index=guard.indexOf(""String_Node_Str"");
        ASTPtRootNode guardParseTree=parser.generateParseTree(guard);
        ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
        parseTreeCodeGenerator.evaluateParseTree(guardParseTree,_scope);
        int index2=transition.getFullName().indexOf(""String_Node_Str"");
        String tempName=transition.getFullName().substring(1,index2) + guard.substring(0,index - 1);
        tempName=tempName.replace(""String_Node_Str"",""String_Node_Str"");
        codeBuffer.append(tempName + ""String_Node_Str"");
        codeBuffer.append(""String_Node_Str"");
        codeBuffer.append(""String_Node_Str"");
      }
      codeBuffer.append(""String_Node_Str"" + _eol);
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.choiceActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          StringBuffer sendCode=new StringBuffer();
          if (channel >= 0) {
            codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            if (((IOPort)destination).isInput()) {
              NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
              StringBuffer containerReference=new StringBuffer();
              containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
              if (((IOPort)destination).isMultiport()) {
                containerReference.append(""String_Node_Str"" + channel);
              }
              containerReference.append(""String_Node_Str"");
              codeBuffer.append((containerHelper).processCode(containerReference.toString()) + ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol);
            }
          }
 else {
            int width=((IOPort)action.getDestination(destinationName)).getWidth();
            for (int i=0; i < width; i++) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str""+ _eol);
              if (((IOPort)destination).isInput()) {
                NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
                StringBuffer containerReference=new StringBuffer();
                containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
                if (((IOPort)destination).isMultiport()) {
                  containerReference.append(""String_Node_Str"" + i);
                }
                containerReference.append(""String_Node_Str"");
                codeBuffer.append((containerHelper).processCode(containerReference.toString()) + ""String_Node_Str"");
                sendCode.append(""String_Node_Str"" + generateSimpleName(destination) + ""String_Node_Str""+ i+ ""String_Node_Str""+ _eol);
              }
            }
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
          codeBuffer.append(sendCode);
        }
      }
      Actor[] actors=transition.getRefinement();
      if (actors != null) {
        for (int i=0; i < actors.length; i++) {
          NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
          codeBuffer.append(helper.generateFireCode());
        }
      }
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.commitActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          if (destination instanceof IOPort) {
            if (channel >= 0) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            }
 else {
              int width=((IOPort)action.getDestination(destinationName)).getWidth();
              for (int i=0; i < width; i++) {
                codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
              }
            }
          }
 else           if (destination instanceof Variable) {
            codeBuffer.append(getCodeGenerator().generateVariableName(destination) + ""String_Node_Str"");
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
        }
      }
      State destinationState=transition.destinationState();
      _updateCurrentState(codeBuffer,destinationState);
      BooleanToken resetToken=(BooleanToken)transition.reset.getToken();
      if (resetToken.booleanValue()) {
        actors=destinationState.getRefinement();
        if (actors != null) {
          for (int i=0; i < actors.length; ++i) {
            NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
            codeBuffer.append(helper.generateInitializeCode());
          }
        }
      }
      Director director=fsmActor.getExecutiveDirector();
      codeBuffer.append(""String_Node_Str"");
    }
    if (!hasDefaultCase) {
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol);
      }
 else {
        codeBuffer.append(_eol);
      }
      codeBuffer.append(""String_Node_Str"" + _eol);
      Director director=fsmActor.getExecutiveDirector();
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol);
      }
    }
    codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  }
  codeBuffer.append(""String_Node_Str"" + _eol);
  code.append(codeBuffer.toString());
}"
73414,"/** 
 * Generate The fire function code. This method is called when the firing code of each actor is not inlined. If the <i>inline</i> parameter of the code generator is true, then each actor's firing code is in a function with the same name as that of the actor.  If the <i>inline</i> parameter is false, then the firing code is grouped in inner classes.
 * @return The fire function code.
 * @exception IllegalActionException If thrown while generating fire code.
 */
public String generateFireFunctionCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  List actorList=((CompositeActor)_director.getContainer()).deepEntityList();
  Collections.sort(actorList,new Comparator(){
    /** 
 * Compare two NamedObjs by fullName().
 * @return -1 if object1 has fewer dots in its fullName(),1 if object1 has more dots in its fullName(), 0 if the objects are the same. If the fullName()s of both NamedObjs have the same number of dots, then return the String compareTo() of the fullName()s.
 */
    public int compare(    Object object1,    Object object2){
      String name1=((NamedObj)object1).getFullName();
      String name2=((NamedObj)object2).getFullName();
      int index=0;
      int dots1=0;
      while ((index=name1.indexOf(""String_Node_Str"",index)) != -1) {
        index++;
        dots1++;
      }
      int dots2=0;
      while ((index=name2.indexOf('.',index)) != -1) {
        index++;
        dots2++;
      }
      if (dots1 == dots2) {
        return 0;
      }
 else       if (dots1 < dots2) {
        return -1;
      }
      return 1;
    }
  }
);
  ProgramCodeGenerator codeGenerator=getCodeGenerator();
  code.append(codeGenerator.comment(""String_Node_Str""));
  boolean inline=((BooleanToken)codeGenerator.inline.getToken()).booleanValue();
  String className=""String_Node_Str"";
  String hackStart=""String_Node_Str"";
  ptolemy.actor.Director director=(ptolemy.actor.Director)getComponent();
  HashMap<String,StringBuffer> innerClasses=new HashMap<String,StringBuffer>();
  Iterator<?> actors=actorList.iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    NamedProgramCodeGeneratorAdapter actorAdapter=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    if (inline) {
      code.append(actorAdapter.generateFireFunctionCode());
    }
 else {
      String results[]=codeGenerator.generateFireFunctionVariableAndMethodName((NamedObj)actor);
      className=results[0];
      StringBuffer innerClassBuffer=innerClasses.get(className);
      if (innerClassBuffer == null) {
        innerClassBuffer=new StringBuffer();
        if (!director.isEmbedded() || director.getContainer() instanceof ptolemy.cg.lib.CompiledCompositeActor) {
          innerClassBuffer.append(codeGenerator.generateFireFunctionCompositeStart(className));
        }
 else {
          innerClassBuffer.append(hackStart + className + ""String_Node_Str"");
        }
        innerClasses.put(className,innerClassBuffer);
      }
      String subFireCode=actorAdapter.generateFireFunctionCode();
      int startIndex=0;
      if ((startIndex=subFireCode.indexOf(hackStart)) != -1) {
        int endIndex=subFireCode.indexOf(""String_Node_Str"",startIndex);
        className=subFireCode.substring(startIndex + hackStart.length(),endIndex);
        innerClassBuffer=innerClasses.get(className);
        if (innerClassBuffer == null) {
          innerClassBuffer=new StringBuffer();
          innerClassBuffer.append(""String_Node_Str"" + className + ""String_Node_Str""+ _eol);
          innerClasses.put(className,innerClassBuffer);
        }
      }
      innerClassBuffer.append(subFireCode);
    }
  }
  if (!inline) {
    for (    Map.Entry<String,StringBuffer> innerClassBuffer : innerClasses.entrySet()) {
      code.append(innerClassBuffer.getValue());
      if (!director.isEmbedded() || director.getContainer() instanceof ptolemy.cg.lib.CompiledCompositeActor) {
        code.append(codeGenerator.generateFireFunctionCompositeEnd());
      }
    }
  }
  return code.toString();
}","/** 
 * Generate The fire function code. This method is called when the firing code of each actor is not inlined. If the <i>inline</i> parameter of the code generator is true, then each actor's firing code is in a function with the same name as that of the actor.  If the <i>inline</i> parameter is false, then the firing code is grouped in inner classes.
 * @return The fire function code.
 * @exception IllegalActionException If thrown while generating fire code.
 */
public String generateFireFunctionCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  List actorList=((CompositeActor)_director.getContainer()).deepEntityList();
  Collections.sort(actorList,new FullNameComparator());
  ProgramCodeGenerator codeGenerator=getCodeGenerator();
  code.append(codeGenerator.comment(""String_Node_Str""));
  boolean inline=((BooleanToken)codeGenerator.inline.getToken()).booleanValue();
  String className=""String_Node_Str"";
  String hackStart=""String_Node_Str"";
  ptolemy.actor.Director director=(ptolemy.actor.Director)getComponent();
  HashMap<String,StringBuffer> innerClasses=new HashMap<String,StringBuffer>();
  Iterator<?> actors=actorList.iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    NamedProgramCodeGeneratorAdapter actorAdapter=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    if (inline) {
      code.append(actorAdapter.generateFireFunctionCode());
    }
 else {
      String results[]=codeGenerator.generateFireFunctionVariableAndMethodName((NamedObj)actor);
      className=results[0];
      StringBuffer innerClassBuffer=innerClasses.get(className);
      if (innerClassBuffer == null) {
        innerClassBuffer=new StringBuffer();
        if (!director.isEmbedded() || director.getContainer() instanceof ptolemy.cg.lib.CompiledCompositeActor) {
          innerClassBuffer.append(codeGenerator.generateFireFunctionCompositeStart(className));
        }
 else {
          innerClassBuffer.append(hackStart + className + ""String_Node_Str"");
        }
        innerClasses.put(className,innerClassBuffer);
      }
      String subFireCode=actorAdapter.generateFireFunctionCode();
      int startIndex=0;
      if ((startIndex=subFireCode.indexOf(hackStart)) != -1) {
        int endIndex=subFireCode.indexOf(""String_Node_Str"",startIndex);
        className=subFireCode.substring(startIndex + hackStart.length(),endIndex);
        innerClassBuffer=innerClasses.get(className);
        if (innerClassBuffer == null) {
          innerClassBuffer=new StringBuffer();
          innerClassBuffer.append(""String_Node_Str"" + className + ""String_Node_Str""+ _eol);
          innerClasses.put(className,innerClassBuffer);
        }
      }
      innerClassBuffer.append(subFireCode);
    }
  }
  if (!inline) {
    for (    Map.Entry<String,StringBuffer> innerClassBuffer : innerClasses.entrySet()) {
      code.append(innerClassBuffer.getValue());
      if (!director.isEmbedded() || director.getContainer() instanceof ptolemy.cg.lib.CompiledCompositeActor) {
        code.append(codeGenerator.generateFireFunctionCompositeEnd());
      }
    }
  }
  return code.toString();
}"
73415,"/** 
 * Generate code for putting tokens from the receiver.
 * @param sourcePort The source port.
 * @param offset The offset of the port.
 * @param token The token.    
 * @return The generated put code.
 * @exception IllegalActionException If thrown while getting the component,getting the adapter, getting the director or getting the port reference.
 */
public String generatePutCode(IOPort sourcePort,String offset,String token) throws IllegalActionException {
  TypedIOPort port=(TypedIOPort)getComponent().getContainer();
  int channel=port.getChannelForReceiver(getComponent());
  NamedProgramCodeGeneratorAdapter containingActorAdapter=(NamedProgramCodeGeneratorAdapter)getAdapter(getComponent().getContainer().getContainer());
  ProgramCodeGeneratorAdapter.Channel source=new Channel(sourcePort,0);
  ProgramCodeGeneratorAdapter.Channel sink=new Channel(port,channel);
  token=((NamedProgramCodeGeneratorAdapter)getAdapter(getComponent().getContainer().getContainer())).getTemplateParser().generateTypeConvertStatement(source,sink,0,token);
  token=_removeSink(token);
  boolean forComposite=_forComposite;
  if (getComponent().getContainer().getContainer() instanceof ModularCodeGenTypedCompositeActor && port.isInput()) {
    forComposite=false;
  }
  if (port.isInput() && ((Actor)(sourcePort.getContainer())).getDirector() != ((Actor)(port.getContainer())).getDirector()) {
    forComposite=false;
  }
  String result=null;
  try {
    result=_getDirectorForReceiver().getReference(port,new String[]{Integer.toString(channel),offset},forComposite,true,containingActorAdapter) + ""String_Node_Str"" + token+ ""String_Node_Str""+ _eol;
  }
 catch (  Exception ex) {
    result=_getExecutiveDirectorForReceiver().getReference(port,new String[]{Integer.toString(channel),offset},forComposite,true,containingActorAdapter) + ""String_Node_Str"" + token+ ""String_Node_Str""+ _eol;
  }
  return result;
}","/** 
 * Generate code for putting tokens from the receiver.
 * @param sourcePort The source port.
 * @param offset The offset of the port.
 * @param token The token.    
 * @return The generated put code.
 * @exception IllegalActionException If thrown while getting the component,getting the adapter, getting the director or getting the port reference.
 */
public String generatePutCode(IOPort sourcePort,String offset,String token) throws IllegalActionException {
  TypedIOPort port=(TypedIOPort)getComponent().getContainer();
  int channel=port.getChannelForReceiver(getComponent());
  NamedProgramCodeGeneratorAdapter containingActorAdapter=(NamedProgramCodeGeneratorAdapter)getAdapter(getComponent().getContainer().getContainer());
  ProgramCodeGeneratorAdapter.Channel source=new Channel(sourcePort,0);
  ProgramCodeGeneratorAdapter.Channel sink=new Channel(port,channel);
  token=((NamedProgramCodeGeneratorAdapter)getAdapter(getComponent().getContainer().getContainer())).getTemplateParser().generateTypeConvertStatement(source,sink,0,token);
  token=_removeSink(token);
  boolean forComposite=_forComposite;
  if (getComponent().getContainer().getContainer() instanceof ModularCodeGenTypedCompositeActor && port.isInput()) {
    forComposite=false;
  }
  if (port.isInput() && ((Actor)(sourcePort.getContainer())).getDirector() != ((Actor)(port.getContainer())).getDirector()) {
    forComposite=false;
  }
  String result=null;
  try {
    result=_getDirectorForReceiver().getReference(port,new String[]{Integer.toString(channel),offset},forComposite,true,containingActorAdapter) + ""String_Node_Str"" + token+ ""String_Node_Str""+ _eol;
  }
 catch (  Throwable throwable) {
    result=_getExecutiveDirectorForReceiver().getReference(port,new String[]{Integer.toString(channel),offset},forComposite,true,containingActorAdapter) + ""String_Node_Str"" + token+ ""String_Node_Str""+ _eol;
  }
  return result;
}"
73416,"/** 
 * Return an unique label for the given port channel referenced by the given adapter. By default, this delegates to the adapter to  generate the reference. Subclass may override this method to generate the desire label according to the given parameters.
 * @param port The given port.
 * @param channelAndOffset The given channel and offset.
 * @param forComposite Whether the given adapter is associated witha CompositeActor
 * @param isWrite The type of the reference. True if this isa write reference; otherwise, this is a read reference.  
 * @param target The ProgramCodeGeneratorAdapter for which code needs to be generated.
 * @return an unique reference label for the given port channel.
 * @exception IllegalActionException If the adapter throws it whilegenerating the label.     
 */
public String getReference(TypedIOPort port,String[] channelAndOffset,boolean forComposite,boolean isWrite,NamedProgramCodeGeneratorAdapter target) throws IllegalActionException {
  StringBuffer result=new StringBuffer();
  boolean dynamicReferencesAllowed=allowDynamicMultiportReference();
  int channelNumber=0;
  boolean isChannelNumberInt=true;
  if (!channelAndOffset[0].equals(""String_Node_Str"")) {
    if (dynamicReferencesAllowed) {
      try {
        channelNumber=(Integer.valueOf(channelAndOffset[0])).intValue();
      }
 catch (      Exception ex) {
        isChannelNumberInt=false;
      }
    }
 else {
      channelNumber=(Integer.valueOf(channelAndOffset[0])).intValue();
    }
  }
  if (!isChannelNumberInt) {
    if (port.isOutput()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      return _generatePortReference(port,channelAndOffset,isWrite);
    }
  }
  if (_checkRemote(forComposite,port)) {
    Receiver[][] remoteReceivers;
    if (port.isOutput()) {
      remoteReceivers=port.getRemoteReceivers();
    }
 else {
      remoteReceivers=port.deepGetReceivers();
    }
    if (remoteReceivers.length == 0) {
      result.append(NamedProgramCodeGeneratorAdapter.generateName(target.getComponent()));
      result.append(""String_Node_Str"");
      result.append(port.getName());
      return result.toString();
    }
    ProgramCodeGeneratorAdapter.Channel sourceChannel=new ProgramCodeGeneratorAdapter.Channel(port,channelNumber);
    List<ProgramCodeGeneratorAdapter.Channel> typeConvertSinks=target.getTypeConvertSinkChannels(sourceChannel);
    List<ProgramCodeGeneratorAdapter.Channel> sinkChannels=getSinkChannels(port,channelNumber);
    boolean hasTypeConvertReference=false;
    for (int i=0; i < sinkChannels.size(); i++) {
      ProgramCodeGeneratorAdapter.Channel channel=sinkChannels.get(i);
      IOPort sinkPort=channel.port;
      int sinkChannelNumber=channel.channelNumber;
      if (typeConvertSinks.contains(channel) && getCodeGenerator().isPrimitive(((TypedIOPort)sourceChannel.port).getType())) {
        if (!hasTypeConvertReference) {
          if (i != 0) {
            result.append(""String_Node_Str"");
          }
          result.append(getTypeConvertReference(sourceChannel));
          if (dynamicReferencesAllowed && port.isInput()) {
            if (channelAndOffset[1].trim().length() > 0) {
              result.append(""String_Node_Str"" + channelAndOffset[1].trim() + ""String_Node_Str"");
            }
 else {
              result.append(""String_Node_Str"" + _generateChannelOffset(port,isWrite,channelAndOffset[0]) + ""String_Node_Str"");
            }
          }
 else {
            int rate=Math.max(DFUtilities.getTokenProductionRate(sourceChannel.port),DFUtilities.getTokenConsumptionRate(sourceChannel.port));
            if (rate > 1 && channelAndOffset[1].trim().length() > 0) {
              result.append(""String_Node_Str"" + channelAndOffset[1].trim() + ""String_Node_Str"");
            }
          }
          hasTypeConvertReference=true;
        }
 else {
          continue;
        }
      }
 else {
        if (i != 0) {
          result.append(""String_Node_Str"");
        }
        result.append(NamedProgramCodeGeneratorAdapter.generateName(sinkPort));
        if (sinkPort.isMultiport()) {
          result.append(""String_Node_Str"" + sinkChannelNumber + ""String_Node_Str"");
        }
        if (channelAndOffset[1].equals(""String_Node_Str"")) {
          channelAndOffset[1]=""String_Node_Str"";
        }
        String res=_ports.generateOffset(sinkPort,channelAndOffset[1],sinkChannelNumber,true);
        if (res.equals(""String_Node_Str"")) {
          if (sinkPort.getContainer() instanceof CompositeActor) {
            SDFDirector directorAdapter=(SDFDirector)getAdapter(((CompositeActor)sinkPort.getContainer()).getDirector());
            result.append(directorAdapter._ports.generateOffset(sinkPort,channelAndOffset[1],sinkChannelNumber,true));
          }
        }
 else {
          result.append(res);
        }
      }
    }
    return result.toString();
  }
  if (_checkLocal(forComposite,port)) {
    result.append(NamedProgramCodeGeneratorAdapter.generateName(port));
    if (port.isMultiport()) {
      result.append(""String_Node_Str"" + channelAndOffset[0] + ""String_Node_Str"");
    }
    if (port.getContainer() instanceof CompositeActor) {
      result.append(_ports.generateOffset(port,channelAndOffset[1],channelNumber,isWrite));
    }
 else {
      result.append(_ports.generateOffset(port,channelAndOffset[1],channelNumber,isWrite));
    }
    return result.toString();
  }
  return ""String_Node_Str"";
}","/** 
 * Return an unique label for the given port channel referenced by the given adapter. By default, this delegates to the adapter to  generate the reference. Subclass may override this method to generate the desire label according to the given parameters.
 * @param port The given port.
 * @param channelAndOffset The given channel and offset.
 * @param forComposite Whether the given adapter is associated witha CompositeActor
 * @param isWrite The type of the reference. True if this isa write reference; otherwise, this is a read reference.  
 * @param target The ProgramCodeGeneratorAdapter for which code needs to be generated.
 * @return an unique reference label for the given port channel.
 * @exception IllegalActionException If the adapter throws it whilegenerating the label.     
 */
public String getReference(TypedIOPort port,String[] channelAndOffset,boolean forComposite,boolean isWrite,NamedProgramCodeGeneratorAdapter target) throws IllegalActionException {
  StringBuffer result=new StringBuffer();
  boolean dynamicReferencesAllowed=allowDynamicMultiportReference();
  int channelNumber=0;
  boolean isChannelNumberInt=true;
  if (!channelAndOffset[0].equals(""String_Node_Str"")) {
    if (dynamicReferencesAllowed) {
      try {
        channelNumber=(Integer.valueOf(channelAndOffset[0])).intValue();
      }
 catch (      Exception ex) {
        isChannelNumberInt=false;
      }
    }
 else {
      channelNumber=(Integer.valueOf(channelAndOffset[0])).intValue();
    }
  }
  if (!isChannelNumberInt) {
    if (port.isOutput()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      return _generatePortReference(port,channelAndOffset,isWrite);
    }
  }
  if (_checkRemote(forComposite,port)) {
    Receiver[][] remoteReceivers;
    if (port.isOutput()) {
      remoteReceivers=port.getRemoteReceivers();
    }
 else {
      remoteReceivers=port.deepGetReceivers();
    }
    if (remoteReceivers.length == 0) {
      result.append(NamedProgramCodeGeneratorAdapter.generateName(target.getComponent()));
      result.append(""String_Node_Str"");
      result.append(port.getName());
      return result.toString();
    }
    ProgramCodeGeneratorAdapter.Channel sourceChannel=new ProgramCodeGeneratorAdapter.Channel(port,channelNumber);
    List<ProgramCodeGeneratorAdapter.Channel> typeConvertSinks=target.getTypeConvertSinkChannels(sourceChannel);
    List<ProgramCodeGeneratorAdapter.Channel> sinkChannels=getSinkChannels(port,channelNumber);
    boolean hasTypeConvertReference=false;
    for (int i=0; i < sinkChannels.size(); i++) {
      ProgramCodeGeneratorAdapter.Channel channel=sinkChannels.get(i);
      IOPort sinkPort=channel.port;
      int sinkChannelNumber=channel.channelNumber;
      if (typeConvertSinks.contains(channel) && getCodeGenerator().isPrimitive(((TypedIOPort)sourceChannel.port).getType())) {
        if (!hasTypeConvertReference) {
          if (i != 0) {
            result.append(""String_Node_Str"");
          }
          result.append(getTypeConvertReference(sourceChannel));
          if (dynamicReferencesAllowed && port.isInput()) {
            if (channelAndOffset[1].trim().length() > 0) {
              result.append(""String_Node_Str"" + channelAndOffset[1].trim() + ""String_Node_Str"");
            }
 else {
              result.append(""String_Node_Str"" + _generateChannelOffset(port,isWrite,channelAndOffset[0]) + ""String_Node_Str"");
            }
          }
 else {
            int rate=Math.max(DFUtilities.getTokenProductionRate(sourceChannel.port),DFUtilities.getTokenConsumptionRate(sourceChannel.port));
            if (rate > 1 && channelAndOffset[1].trim().length() > 0) {
              result.append(""String_Node_Str"" + channelAndOffset[1].trim() + ""String_Node_Str"");
            }
          }
          hasTypeConvertReference=true;
        }
 else {
          continue;
        }
      }
 else {
        if (i != 0) {
          result.append(""String_Node_Str"");
        }
        result.append(NamedProgramCodeGeneratorAdapter.generateName(sinkPort));
        if (sinkPort.isMultiport()) {
          result.append(""String_Node_Str"" + sinkChannelNumber + ""String_Node_Str"");
        }
        if (channelAndOffset[1].equals(""String_Node_Str"")) {
          channelAndOffset[1]=""String_Node_Str"";
        }
        String res=_ports.generateOffset(sinkPort,channelAndOffset[1],sinkChannelNumber,true);
        if (res.equals(""String_Node_Str"")) {
          if (sinkPort.getContainer() instanceof CompositeActor) {
            SDFDirector directorAdapter=(SDFDirector)getAdapter(((CompositeActor)sinkPort.getContainer()).getDirector());
            result.append(directorAdapter._ports.generateOffset(sinkPort,channelAndOffset[1],sinkChannelNumber,true));
          }
        }
 else {
          result.append(res);
        }
      }
    }
    return result.toString();
  }
  if (_checkLocal(forComposite,port)) {
    result.append(NamedProgramCodeGeneratorAdapter.generateName(port));
    if (port.isMultiport()) {
      result.append(""String_Node_Str"" + channelAndOffset[0] + ""String_Node_Str"");
    }
    result.append(_ports.generateOffset(port,channelAndOffset[1],channelNumber,isWrite));
    return result.toString();
  }
  return ""String_Node_Str"";
}"
73417,"/** 
 * Write the code to a directory named by the codeDirectory parameter, with a file name that is a sanitized version of the model name, and an extension that is the last package of the generatorPackage.
 * @param code The StringBuffer containing the code.
 * @return The name of the file that was written.
 * @exception IllegalActionException  If there is a problem readinga parameter, if there is a problem creating the codeDirectory directory or if there is a problem writing the code to a file.
 */
protected String _writeCode(StringBuffer code) throws IllegalActionException {
  String codeFileName=_getOutputFilename();
  boolean overwriteFile=((BooleanToken)overwriteFiles.getToken()).booleanValue();
  if (_executeCommands != null) {
    _executeCommands.stdout(""String_Node_Str"" + (codeFileName == null ? ""String_Node_Str"" : codeFileName) + ""String_Node_Str""+ (codeDirectory == null ? ""String_Node_Str"" : codeDirectory.getBaseDirectory())+ ""String_Node_Str""+ (code == null ? 0 : code.length())+ ""String_Node_Str"");
  }
  return _writeCodeFileName(code,codeFileName,overwriteFile,false);
}","/** 
 * Write the code to a directory named by the codeDirectory parameter, with a file name that is a sanitized version of the model name, and an extension that is the last package of the generatorPackage.
 * @param code The StringBuffer containing the code.
 * @return The name of the file that was written.
 * @exception IllegalActionException  If there is a problem readinga parameter, if there is a problem creating the codeDirectory directory or if there is a problem writing the code to a file.
 */
protected String _writeCode(StringBuffer code) throws IllegalActionException {
  String codeFileName=_getOutputFilename();
  boolean overwriteFile=((BooleanToken)overwriteFiles.getToken()).booleanValue();
  if (_executeCommands != null) {
    _executeCommands.stdout(""String_Node_Str"" + codeFileName + ""String_Node_Str""+ (codeDirectory == null ? ""String_Node_Str"" : codeDirectory.getBaseDirectory())+ ""String_Node_Str""+ (code == null ? 0 : code.length())+ ""String_Node_Str"");
  }
  return _writeCodeFileName(code,codeFileName,overwriteFile,false);
}"
73418,"/** 
 * Set the parameters in the model stored in _parameterNames to the values given by _parameterValues. Those lists are populated by command line arguments.
 * @param model The model in which to update parameters.
 */
private void _updateParameters(NamedObj model){
  Iterator<String> names=_parameterNames.iterator();
  Iterator<String> values=_parameterValues.iterator();
  while (names.hasNext() && values.hasNext()) {
    String name=names.next();
    String value=values.next();
    Attribute attribute=model.getAttribute(name);
    if (attribute instanceof Settable) {
      String moml=""String_Node_Str"" + name + ""String_Node_Str""+ value+ ""String_Node_Str"";
      MoMLChangeRequest request=new MoMLChangeRequest(this,model,moml);
      model.requestChange(request);
    }
 else {
      attribute=getAttribute(name);
      if (attribute instanceof Settable) {
        String moml=""String_Node_Str"" + name + ""String_Node_Str""+ value+ ""String_Node_Str"";
        MoMLChangeRequest request=new MoMLChangeRequest(this,this,moml);
        model.requestChange(request);
      }
      attribute=getAttribute(name);
    }
    if (model instanceof CompositeActor) {
      ptolemy.actor.Director director=((CompositeActor)model).getDirector();
      if (director != null) {
        attribute=director.getAttribute(name);
        if (attribute instanceof Settable) {
          String moml=""String_Node_Str"" + name + ""String_Node_Str""+ value+ ""String_Node_Str"";
          MoMLChangeRequest request=new MoMLChangeRequest(this,director,moml);
          director.requestChange(request);
        }
      }
    }
  }
}","/** 
 * Set the parameters in the model stored in _parameterNames to the values given by _parameterValues. Those lists are populated by command line arguments.
 * @param model The model in which to update parameters.
 */
private void _updateParameters(NamedObj model){
  Iterator<String> names=_parameterNames.iterator();
  Iterator<String> values=_parameterValues.iterator();
  while (names.hasNext() && values.hasNext()) {
    String name=names.next();
    String value=values.next();
    Attribute attribute=model.getAttribute(name);
    if (attribute instanceof Settable) {
      String moml=""String_Node_Str"" + name + ""String_Node_Str""+ value+ ""String_Node_Str"";
      MoMLChangeRequest request=new MoMLChangeRequest(this,model,moml);
      model.requestChange(request);
    }
 else {
      attribute=getAttribute(name);
      if (attribute instanceof Settable) {
        String moml=""String_Node_Str"" + name + ""String_Node_Str""+ value+ ""String_Node_Str"";
        MoMLChangeRequest request=new MoMLChangeRequest(this,this,moml);
        model.requestChange(request);
      }
    }
    if (model instanceof CompositeActor) {
      ptolemy.actor.Director director=((CompositeActor)model).getDirector();
      if (director != null) {
        attribute=director.getAttribute(name);
        if (attribute instanceof Settable) {
          String moml=""String_Node_Str"" + name + ""String_Node_Str""+ value+ ""String_Node_Str"";
          MoMLChangeRequest request=new MoMLChangeRequest(this,director,moml);
          director.requestChange(request);
        }
      }
    }
  }
}"
73419,"/** 
 * Return the function output from the given input arguments. The output concept is a UnitConcept that is the result of multiplication or division of the two input UnitConcepts, or the top of the ontology lattice if there is no UnitConcept in the ontology that represents the product or quotient of the two input concepts.
 * @param argValues The 2 UnitConcept input arguments.
 * @return The output UnitConcept.
 * @throws IllegalActionException Thrown if there is a problem creatingthe output RecordConcept.
 */
protected Concept _evaluateFunction(List<Concept> argValues) throws IllegalActionException {
  Concept arg1=argValues.get(0);
  Concept arg2=argValues.get(1);
  if (arg1.equals(_bottomOfTheLattice) || arg2.equals(_bottomOfTheLattice)) {
    return _bottomOfTheLattice;
  }
 else   if (arg1.equals(_topOfTheLattice) || arg2.equals(_topOfTheLattice)) {
    return _topOfTheLattice;
  }
 else   if (arg1 instanceof FlatTokenInfiniteConcept && arg2 instanceof FlatTokenInfiniteConcept) {
    if (_isDivisionAndSecondArgumentIsZero((FlatTokenInfiniteConcept)arg2)) {
      return _bottomOfTheLattice;
    }
 else {
      return _getMathOperationResultConcept((FlatTokenInfiniteConcept)arg1,(FlatTokenInfiniteConcept)arg2);
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + arg1 + ""String_Node_Str""+ arg2+ ""String_Node_Str"");
  }
}","/** 
 * Return the function output from the given input arguments. The output concept is a FlatTokenInfiniteConcept that is the result of the addition, subtraction, multiplication or division of the two input FlatTokenInfiniteConcepts.
 * @param argValues The 2 FlatTokenInfiniteConcept input arguments.
 * @return The output FlatTokenInfiniteConcept.
 * @throws IllegalActionException Thrown if there is a problem creatingthe output FlatTokenInfiniteConcept.
 */
protected Concept _evaluateFunction(List<Concept> argValues) throws IllegalActionException {
  Concept arg1=argValues.get(0);
  Concept arg2=argValues.get(1);
  if (arg1.equals(_bottomOfTheLattice) || arg2.equals(_bottomOfTheLattice)) {
    return _bottomOfTheLattice;
  }
 else   if (arg1.equals(_topOfTheLattice) || arg2.equals(_topOfTheLattice)) {
    return _topOfTheLattice;
  }
 else   if (arg1 instanceof FlatTokenInfiniteConcept && arg2 instanceof FlatTokenInfiniteConcept) {
    if (_isDivisionAndSecondArgumentIsZero((FlatTokenInfiniteConcept)arg2)) {
      return _bottomOfTheLattice;
    }
 else {
      return _getMathOperationResultConcept((FlatTokenInfiniteConcept)arg1,(FlatTokenInfiniteConcept)arg2);
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + arg1 + ""String_Node_Str""+ arg2+ ""String_Node_Str"");
  }
}"
73420,"/** 
 * Create a new ConstPropagationMathFunctions concept function.
 * @param ontology The domain and range unit system ontology for thisconcept function. 
 * @param mathOperation Indicates whether this concept function will performmultiplication or division for the unit system concepts.
 * @throws IllegalActionException Thrown if the concept function cannot be created.
 */
public ConstPropagationMathFunctions(Ontology ontology,String mathOperation) throws IllegalActionException {
  super(""String_Node_Str"" + mathOperation,2,ontology);
  _mathOperation=mathOperation;
  _constPropagationOntology=ontology;
  ConceptGraph ontologyGraph=_constPropagationOntology.getConceptGraph();
  if (ontologyGraph == null) {
    throw new IllegalActionException(""String_Node_Str"" + _constPropagationOntology + ""String_Node_Str"");
  }
 else {
    _topOfTheLattice=ontologyGraph.top();
    _bottomOfTheLattice=ontologyGraph.bottom();
  }
}","/** 
 * Create a new ConstPropagationMathFunctions concept function.
 * @param ontology The domain and range unit system ontology for thisconcept function. 
 * @param mathOperation Indicates whether this concept function will performaddition, subtraction, multiplication or division for the FlatTokenInfiniteConcepts.
 * @throws IllegalActionException Thrown if the concept function cannot be created.
 */
public ConstPropagationMathFunctions(Ontology ontology,String mathOperation) throws IllegalActionException {
  super(""String_Node_Str"" + mathOperation,2,ontology);
  _mathOperation=mathOperation;
  _constPropagationOntology=ontology;
  ConceptGraph ontologyGraph=_constPropagationOntology.getConceptGraph();
  if (ontologyGraph == null) {
    throw new IllegalActionException(""String_Node_Str"" + _constPropagationOntology + ""String_Node_Str"");
  }
 else {
    _topOfTheLattice=ontologyGraph.top();
    _bottomOfTheLattice=ontologyGraph.bottom();
  }
}"
73421,"/** 
 * Return the function output from the given input arguments. The output concept is a UnitConcept that is the result of multiplication or division of the two input UnitConcepts, or the top of the ontology lattice if there is no UnitConcept in the ontology that represents the product or quotient of the two input concepts.
 * @param argValues The 2 UnitConcept input arguments.
 * @return The output UnitConcept.
 * @throws IllegalActionException Thrown if there is a problem creatingthe output RecordConcept.
 */
protected Concept _evaluateFunction(List<Concept> argValues) throws IllegalActionException {
  Concept arg1=argValues.get(0);
  Concept arg2=argValues.get(1);
  if (arg1.equals(_bottomOfTheLattice) || arg2.equals(_bottomOfTheLattice)) {
    return _bottomOfTheLattice;
  }
 else   if (arg1.equals(_topOfTheLattice) || arg2.equals(_topOfTheLattice)) {
    return _topOfTheLattice;
  }
 else {
    if (_isDivisionAndSecondArgumentIsZero(arg2)) {
      return _bottomOfTheLattice;
    }
 else {
      return _getMathOperationResultConcept(arg1,arg2);
    }
  }
}","/** 
 * Return the function output from the given input arguments. The output concept is a FlatScalarTokenInfiniteConcept that is the result of the addition, subtraction, multiplication or division of the two input FlatScalarTokenInfiniteConcepts. If the operation results in a value of zero, return the finite Zero concept in the constPropagationAbsInt ontology.
 * @param argValues The 2 FlatScalarTokenInfiniteConcept input arguments.
 * @return The output FlatScalarTokenInfiniteConcept.
 * @throws IllegalActionException Thrown if there is a problem creatingthe output FlatScalarTokenInfiniteConcept.
 */
protected Concept _evaluateFunction(List<Concept> argValues) throws IllegalActionException {
  Concept arg1=argValues.get(0);
  Concept arg2=argValues.get(1);
  if (arg1.equals(_bottomOfTheLattice) || arg2.equals(_bottomOfTheLattice)) {
    return _bottomOfTheLattice;
  }
 else   if (arg1.equals(_topOfTheLattice) || arg2.equals(_topOfTheLattice)) {
    return _topOfTheLattice;
  }
 else {
    if (_isDivisionAndSecondArgumentIsZero(arg2)) {
      return _bottomOfTheLattice;
    }
 else {
      return _getMathOperationResultConcept(arg1,arg2);
    }
  }
}"
73422,"/** 
 * Create a new ConstPropagationAbsIntMathFunctions concept function.
 * @param ontology The domain and range unit system ontology for thisconcept function. 
 * @param mathOperation Indicates whether this concept function will performmultiplication or division for the unit system concepts.
 * @throws IllegalActionException Thrown if the concept function cannot be created.
 */
public ConstPropagationAbsIntMathFunctions(Ontology ontology,String mathOperation) throws IllegalActionException {
  super(""String_Node_Str"" + mathOperation,2,ontology);
  _mathOperation=mathOperation;
  _constPropagationAbsIntOntology=ontology;
  _positiveRepresentative=(FlatScalarTokenRepresentativeConcept)_constPropagationAbsIntOntology.getConceptByString(""String_Node_Str"");
  _negativeRepresentative=(FlatScalarTokenRepresentativeConcept)_constPropagationAbsIntOntology.getConceptByString(""String_Node_Str"");
  _zeroConcept=_constPropagationAbsIntOntology.getConceptByString(""String_Node_Str"");
  ConceptGraph ontologyGraph=_constPropagationAbsIntOntology.getConceptGraph();
  if (ontologyGraph == null) {
    throw new IllegalActionException(""String_Node_Str"" + _constPropagationAbsIntOntology + ""String_Node_Str"");
  }
 else {
    _topOfTheLattice=ontologyGraph.top();
    _bottomOfTheLattice=ontologyGraph.bottom();
  }
}","/** 
 * Create a new ConstPropagationAbsIntMathFunctions concept function.
 * @param ontology The domain and range unit system ontology for thisconcept function. 
 * @param mathOperation Indicates whether this concept function will performaddition, subtraction, multiplication or division for the FlatScalarTokenInfiniteConcepts.
 * @throws IllegalActionException Thrown if the concept function cannot be created.
 */
public ConstPropagationAbsIntMathFunctions(Ontology ontology,String mathOperation) throws IllegalActionException {
  super(""String_Node_Str"" + mathOperation,2,ontology);
  _mathOperation=mathOperation;
  _constPropagationAbsIntOntology=ontology;
  _positiveRepresentative=(FlatScalarTokenRepresentativeConcept)_constPropagationAbsIntOntology.getConceptByString(""String_Node_Str"");
  _negativeRepresentative=(FlatScalarTokenRepresentativeConcept)_constPropagationAbsIntOntology.getConceptByString(""String_Node_Str"");
  _zeroConcept=_constPropagationAbsIntOntology.getConceptByString(""String_Node_Str"");
  ConceptGraph ontologyGraph=_constPropagationAbsIntOntology.getConceptGraph();
  if (ontologyGraph == null) {
    throw new IllegalActionException(""String_Node_Str"" + _constPropagationAbsIntOntology + ""String_Node_Str"");
  }
 else {
    _topOfTheLattice=ontologyGraph.top();
    _bottomOfTheLattice=ontologyGraph.bottom();
  }
}"
73423,"/** 
 * Return the function output from the given input arguments. The output concept is a UnitConcept that is the result of multiplication or division of the two input UnitConcepts, or the top of the ontology lattice if there is no UnitConcept in the ontology that represents the product or quotient of the two input concepts.
 * @param argValues The 2 UnitConcept input arguments.
 * @return The output UnitConcept.
 * @throws IllegalActionException Thrown if there is a problem creatingthe output RecordConcept.
 */
protected Concept _evaluateFunction(List<Concept> argValues) throws IllegalActionException {
  Concept arg1=argValues.get(0);
  Concept arg2=argValues.get(1);
  if (arg1.equals(_bottomOfTheLattice) || arg2.equals(_bottomOfTheLattice)) {
    return _bottomOfTheLattice;
  }
 else   if (arg1.equals(_topOfTheLattice) || arg2.equals(_topOfTheLattice)) {
    return _topOfTheLattice;
  }
 else   if (arg1 instanceof DimensionlessConcept && arg2 instanceof DimensionlessConcept) {
    return _unitOntology.getConceptGraph().leastUpperBound(arg1,arg2);
  }
 else   if (arg1 instanceof UnitConcept && arg2 instanceof DimensionlessConcept) {
    return arg1;
  }
 else   if (arg1 instanceof DimensionlessConcept && arg2 instanceof UnitConcept) {
    if (_isMultiply) {
      return arg2;
    }
 else {
      return _findInverseUnitConcept((UnitConcept)arg2);
    }
  }
 else   if (arg1 instanceof UnitConcept && arg2 instanceof UnitConcept) {
    return _findComposedUnitConcept((UnitConcept)arg1,(UnitConcept)arg2);
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + arg1 + ""String_Node_Str""+ arg2+ ""String_Node_Str"");
  }
}","/** 
 * Return the function output from the given input arguments. The output concept is a UnitConcept that is the result of multiplication or division of the two input UnitConcepts, or the top of the ontology lattice if there is no UnitConcept in the ontology that represents the product or quotient of the two input concepts.
 * @param argValues The 2 UnitConcept input arguments.
 * @return The output UnitConcept.
 * @throws IllegalActionException Thrown if there is a problem creatingthe output UnitConcept.
 */
protected Concept _evaluateFunction(List<Concept> argValues) throws IllegalActionException {
  Concept arg1=argValues.get(0);
  Concept arg2=argValues.get(1);
  if (arg1.equals(_bottomOfTheLattice) || arg2.equals(_bottomOfTheLattice)) {
    return _bottomOfTheLattice;
  }
 else   if (arg1.equals(_topOfTheLattice) || arg2.equals(_topOfTheLattice)) {
    return _topOfTheLattice;
  }
 else   if (arg1 instanceof DimensionlessConcept && arg2 instanceof DimensionlessConcept) {
    return _unitOntology.getConceptGraph().leastUpperBound(arg1,arg2);
  }
 else   if (arg1 instanceof UnitConcept && arg2 instanceof DimensionlessConcept) {
    return arg1;
  }
 else   if (arg1 instanceof DimensionlessConcept && arg2 instanceof UnitConcept) {
    if (_isMultiply) {
      return arg2;
    }
 else {
      return _findInverseUnitConcept((UnitConcept)arg2);
    }
  }
 else   if (arg1 instanceof UnitConcept && arg2 instanceof UnitConcept) {
    return _findComposedUnitConcept((UnitConcept)arg1,(UnitConcept)arg2);
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + arg1 + ""String_Node_Str""+ arg2+ ""String_Node_Str"");
  }
}"
73424,"/** 
 * Annotates the model so that when it is displayed it will be color coded and have tooltips that will convey various aspects of the solution.
 */
public void annotateGraph(){
  if (_debug) {
    trace();
  }
  String color;
  StringBuffer moml=new StringBuffer();
  for (int j=0; j < _numVariables; j++) {
    String explanation=_varBindings[j];
    color=null;
    if (_varState[j] == _CONSISTENT) {
      color=""String_Node_Str"";
    }
 else     if (_varState[j] == _INCONSISTENT) {
      color=""String_Node_Str"";
    }
    moml.append(""String_Node_Str"" + _variables[j] + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ color+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ explanation+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  for (int constraintNum=0; constraintNum < _numConstraints; constraintNum++) {
    NamedObj source=_source[constraintNum];
    String expression=_constraintExplanations[constraintNum];
    color=null;
    if (_constraintState[constraintNum] == _CONSISTENT) {
      color=""String_Node_Str"";
    }
 else     if (_constraintState[constraintNum] == _INCONSISTENT) {
      color=""String_Node_Str"";
    }
    if (source instanceof IOPort) {
      IOPort port=(IOPort)source;
      ComponentEntity actor=(ComponentEntity)(port.getContainer());
      moml.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ _momlAnnotate(port,color,expression)+ ""String_Node_Str"");
    }
 else     if (source instanceof IORelation) {
      IORelation relation=(IORelation)source;
      moml.append(_momlAnnotate(relation,color,expression));
    }
 else     if (source instanceof ComponentEntity) {
      ComponentEntity componentEntity=(ComponentEntity)source;
      moml.append(_momlAnnotate(componentEntity,color,expression));
    }
  }
  if (moml.length() > 0) {
    String momlUpdate=""String_Node_Str"" + moml.toString() + ""String_Node_Str"";
    MoMLChangeRequest request=new MoMLChangeRequest(this,_model,momlUpdate);
    request.setUndoable(true);
    request.setPersistent(false);
    _debug(""String_Node_Str"" + momlUpdate);
    _model.requestChange(request);
  }
}","/** 
 * Annotates the model so that when it is displayed it will be color coded and have tooltips that will convey various aspects of the solution.
 */
public void annotateGraph(){
  if (_debug) {
    trace();
  }
  String colorString;
  StringBuffer moml=new StringBuffer();
  for (int j=0; j < _numVariables; j++) {
    String explanation=_varBindings[j];
    Color colorValue=null;
    if (_varState[j] == _CONSISTENT) {
      colorValue=Color.GREEN;
    }
 else     if (_varState[j] == _INCONSISTENT) {
      colorValue=Color.RED;
    }
    colorString=_getColorString(colorValue);
    moml.append(""String_Node_Str"" + _variables[j] + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ colorString+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ explanation+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  for (int constraintNum=0; constraintNum < _numConstraints; constraintNum++) {
    NamedObj source=_source[constraintNum];
    String expression=_constraintExplanations[constraintNum];
    Color colorValue=null;
    if (_constraintState[constraintNum] == _CONSISTENT) {
      colorValue=Color.GREEN;
    }
 else     if (_constraintState[constraintNum] == _INCONSISTENT) {
      colorValue=Color.RED;
    }
    colorString=_getColorString(colorValue);
    if (source instanceof IOPort) {
      IOPort port=(IOPort)source;
      ComponentEntity actor=(ComponentEntity)(port.getContainer());
      moml.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ _momlAnnotate(port,colorString,expression)+ ""String_Node_Str"");
    }
 else     if (source instanceof IORelation) {
      IORelation relation=(IORelation)source;
      moml.append(_momlAnnotate(relation,colorString,expression));
    }
 else     if (source instanceof ComponentEntity) {
      ComponentEntity componentEntity=(ComponentEntity)source;
      moml.append(_momlAnnotate(componentEntity,colorString,expression));
    }
  }
  if (moml.length() > 0) {
    String momlUpdate=""String_Node_Str"" + moml.toString() + ""String_Node_Str"";
    MoMLChangeRequest request=new MoMLChangeRequest(this,_model,momlUpdate);
    request.setUndoable(true);
    request.setPersistent(false);
    _debug(""String_Node_Str"" + momlUpdate);
    _model.requestChange(request);
  }
}"
73425,"private String _momlAnnotate(NamedObj entity,String color,String expression){
  String colorProperty=null;
  StringAttribute currentColor=(StringAttribute)(entity.getAttribute(""String_Node_Str""));
  if ((currentColor != null) && (color == null)) {
    colorProperty=""String_Node_Str"";
  }
 else   if (color != null) {
    colorProperty=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + color + ""String_Node_Str"";
  }
  return ""String_Node_Str"" + entity.getElementName() + ""String_Node_Str""+ entity.getName()+ ""String_Node_Str""+ entity.getClassName()+ ""String_Node_Str""+ colorProperty+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ expression+ ""String_Node_Str""+ entity.getElementName()+ ""String_Node_Str"";
}","private String _momlAnnotate(NamedObj entity,String color,String expression){
  String colorProperty=null;
  ColorAttribute currentColor=(ColorAttribute)(entity.getAttribute(""String_Node_Str""));
  if ((currentColor != null) && (color == null)) {
    colorProperty=""String_Node_Str"";
  }
 else   if (color != null) {
    colorProperty=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + color + ""String_Node_Str"";
  }
  return ""String_Node_Str"" + entity.getElementName() + ""String_Node_Str""+ entity.getName()+ ""String_Node_Str""+ entity.getClassName()+ ""String_Node_Str""+ colorProperty+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ expression+ ""String_Node_Str""+ entity.getElementName()+ ""String_Node_Str"";
}"
73426,"/** 
 * Generate code for replacing the get() macro. This delegates to the receiver adapter for the specified channel and asks it to generate the get code.
 * @param channel The channel for which to generate the get code.
 * @param offset The offset in the array representation of the port.
 * @return The code that gets data from the specified channel.
 * @exception IllegalActionException If the receiver adapter is not found or it encounters an error while generating the get code.
 */
public String generateGetCode(String channel,String offset) throws IllegalActionException {
  Receiver[][] receivers=getReceiverAdapters();
  int channelIndex=Integer.parseInt(channel);
  if (receivers.length != 0) {
    if (channelIndex >= receivers.length) {
      throw new IllegalActionException(getComponent(),""String_Node_Str"" + channelIndex + ""String_Node_Str""+ ""String_Node_Str""+ receivers.length+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ offset+ ""String_Node_Str"");
    }
    if (receivers[channelIndex].length > 1) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channelIndex].length > 0) {
      return receivers[channelIndex][0].generateGetCode(offset);
    }
  }
  Type type=((TypedIOPort)getComponent()).getType();
  if (((TypedIOPort)getComponent()) instanceof ParameterPort) {
    Parameter parameter=((ParameterPort)getComponent()).getParameter();
    if (parameter.isStringMode()) {
      return ""String_Node_Str"" + parameter.getExpression().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    }
 else {
      return parameter.getValueAsString();
    }
  }
  String typeString=getCodeGenerator().codeGenType(type);
  return ""String_Node_Str"" + getCodeGenerator().codeGenType(BaseType.INT) + ""String_Node_Str""+ typeString+ ""String_Node_Str"";
}","/** 
 * Generate code for replacing the get() macro. This delegates to the receiver adapter for the specified channel and asks it to generate the get code.
 * @param channel The channel for which to generate the get code.
 * @param offset The offset in the array representation of the port.
 * @return The code that gets data from the specified channel.
 * @exception IllegalActionException If the receiver adapter is not found or it encounters an error while generating the get code.
 */
public String generateGetCode(String channel,String offset) throws IllegalActionException {
  Receiver[][] receivers=getReceiverAdapters();
  int channelIndex=Integer.parseInt(channel);
  if (receivers.length != 0) {
    if (channelIndex >= receivers.length) {
      throw new IllegalActionException(getComponent(),""String_Node_Str"" + channelIndex + ""String_Node_Str""+ ""String_Node_Str""+ receivers.length+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ offset+ ""String_Node_Str"");
    }
    if (receivers[channelIndex].length > 1) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channelIndex].length > 0) {
      return receivers[channelIndex][0].generateGetCode(offset);
    }
  }
  TypedIOPort port=(TypedIOPort)getComponent();
  Type type=port.getType();
  if (port instanceof ParameterPort) {
    Parameter parameter=((ParameterPort)getComponent()).getParameter();
    if (port.numLinks() <= 0) {
      if (parameter.isStringMode()) {
        return ""String_Node_Str"" + parameter.getExpression().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
      }
 else {
        return parameter.getValueAsString();
      }
    }
 else {
      throw new InternalErrorException(port,null,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  String typeString=getCodeGenerator().codeGenType(type);
  System.err.println(""String_Node_Str"");
  return ""String_Node_Str"" + getCodeGenerator().codeGenType(BaseType.INT) + ""String_Node_Str""+ typeString+ ""String_Node_Str"";
}"
73427,"/** 
 * Return the value or an expression in the target language for the specified parameter of the associated actor.  If the parameter is specified by an expression, then the expression will be parsed. If any parameter referenced in that expression is specified by another expression, the parsing continues recursively until either a parameter is directly specified by a constant or a parameter can be directly modified during execution in which case a reference to the parameter is generated.
 * @param name The name of the parameter.
 * @param container The container to search upwards from.
 * @return The value or expression as a string.
 * @exception IllegalActionException If the parameter does not exist ordoes not have a value.
 */
final public String getParameterValue(String name,NamedObj container) throws IllegalActionException {
  if (name.contains(""String_Node_Str"")) {
    name=processCode(name);
  }
  StringTokenizer tokenizer=new StringTokenizer(name,""String_Node_Str"");
  String attributeName=tokenizer.nextToken().trim();
  String offset=null;
  String castType=null;
  if (tokenizer.hasMoreTokens()) {
    offset=tokenizer.nextToken().trim();
    if (tokenizer.hasMoreTokens()) {
      CGException.throwException(_component,name + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  StringTokenizer tokenizer2=new StringTokenizer(attributeName,""String_Node_Str"",false);
  if (tokenizer2.countTokens() != 1 && tokenizer2.countTokens() != 2) {
    CGException.throwException(_component,""String_Node_Str"" + attributeName);
  }
  if (tokenizer2.countTokens() == 2) {
    castType=tokenizer2.nextToken().trim();
    attributeName=tokenizer2.nextToken().trim();
  }
  Attribute attribute=ModelScope.getScopedVariable(null,container,attributeName);
  if (attribute == null) {
    attribute=container.getAttribute(attributeName);
    if (attribute == null) {
      CGException.throwException(container,""String_Node_Str"" + name);
    }
  }
  if (offset == null) {
    if (attribute instanceof Variable) {
      Variable variable=(Variable)attribute;
      ParseTreeCodeGenerator parseTreeCodeGenerator=getParseTreeCodeGenerator();
      if (variable.isStringMode()) {
        return generateTypeConvertMethod(""String_Node_Str"" + StringUtilities.escapeString(parseTreeCodeGenerator.escapeForTargetLanguage(variable.getExpression())) + ""String_Node_Str"",castType,""String_Node_Str"");
      }
      PtParser parser=new PtParser();
      ASTPtRootNode parseTree=null;
      try {
        parseTree=parser.generateParseTree(variable.getExpression());
      }
 catch (      Throwable throwable) {
        CGException.throwException(variable,throwable,""String_Node_Str"" + name + ""String_Node_Str""+ container+ ""String_Node_Str"");
      }
      try {
        parseTreeCodeGenerator.evaluateParseTree(parseTree,new VariableScope(variable));
      }
 catch (      Exception ex) {
        StringBuffer results=new StringBuffer();
        Iterator<?> allScopedVariableNames=ModelScope.getAllScopedVariableNames(variable,container).iterator();
        while (allScopedVariableNames.hasNext()) {
          results.append(allScopedVariableNames.next().toString() + ""String_Node_Str"");
        }
        CGException.throwException(_component,ex,""String_Node_Str"" + variable.getFullName() + ""String_Node_Str""+ results.toString());
      }
      String fireCode=processCode(parseTreeCodeGenerator.generateFireCode());
      return generateTypeConvertMethod(fireCode,castType,_getCodeGenerator().codeGenType(variable.getType()));
    }
 else {
      return ((Settable)attribute).getExpression();
    }
  }
 else {
    if (attribute instanceof Parameter) {
      Token token=((Parameter)attribute).getToken();
      if (token instanceof ArrayToken) {
        Token element=((ArrayToken)token).getElement(Integer.valueOf(offset).intValue());
        ParseTreeCodeGenerator parseTreeCodeGenerator=getParseTreeCodeGenerator();
        PtParser parser=new PtParser();
        ASTPtRootNode parseTree=null;
        try {
          parseTree=parser.generateParseTree(element.toString());
        }
 catch (        Throwable throwable) {
          CGException.throwException(attribute,throwable,""String_Node_Str"" + name + ""String_Node_Str""+ container+ ""String_Node_Str"");
        }
        parseTreeCodeGenerator.evaluateParseTree(parseTree,new VariableScope((Parameter)attribute));
        String elementCode=processCode(parseTreeCodeGenerator.generateFireCode());
        return generateTypeConvertMethod(elementCode,castType,_getCodeGenerator().codeGenType(element.getType()));
      }
      CGException.throwException(_component,attributeName + ""String_Node_Str"");
    }
    CGException.throwException(_component,attributeName + ""String_Node_Str"");
  }
  return ""String_Node_Str"";
}","/** 
 * Return the value or an expression in the target language for the specified parameter of the associated actor.  If the parameter is specified by an expression, then the expression will be parsed. If any parameter referenced in that expression is specified by another expression, the parsing continues recursively until either a parameter is directly specified by a constant or a parameter can be directly modified during execution in which case a reference to the parameter is generated.
 * @param name The name of the parameter.
 * @param container The container to search upwards from.
 * @return The value or expression as a string.
 * @exception IllegalActionException If the parameter does not exist ordoes not have a value.
 */
final public String getParameterValue(String name,NamedObj container) throws IllegalActionException {
  if (name.contains(""String_Node_Str"")) {
    name=processCode(name);
  }
  StringTokenizer tokenizer=new StringTokenizer(name,""String_Node_Str"");
  String attributeName=tokenizer.nextToken().trim();
  String offset=null;
  String castType=null;
  if (tokenizer.hasMoreTokens()) {
    offset=tokenizer.nextToken().trim();
    if (tokenizer.hasMoreTokens()) {
      CGException.throwException(_component,name + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  StringTokenizer tokenizer2=new StringTokenizer(attributeName,""String_Node_Str"",false);
  if (tokenizer2.countTokens() != 1 && tokenizer2.countTokens() != 2) {
    CGException.throwException(_component,""String_Node_Str"" + attributeName);
  }
  if (tokenizer2.countTokens() == 2) {
    castType=tokenizer2.nextToken().trim();
    attributeName=tokenizer2.nextToken().trim();
  }
  Attribute attribute=ModelScope.getScopedVariable(null,container,attributeName);
  if (attribute == null) {
    attribute=container.getAttribute(attributeName);
    if (attribute == null) {
      CGException.throwException(container,""String_Node_Str"" + name);
    }
  }
  if (offset == null) {
    if (attribute instanceof Variable) {
      if (attribute instanceof PortParameter) {
        PortParameter portParameter=(PortParameter)attribute;
        TypedIOPort port=portParameter.getPort();
        if (port.isInsideConnected() || port.isOutsideConnected()) {
          String[] portChannel=_parsePortChannel(name);
          String channel=portChannel[1];
          PortCodeGenerator portAdapter=(PortCodeGenerator)_codeGenerator.getAdapter(port);
          return processCode(portAdapter.generateGetCode(channel,""String_Node_Str""));
        }
      }
      Variable variable=(Variable)attribute;
      ParseTreeCodeGenerator parseTreeCodeGenerator=getParseTreeCodeGenerator();
      if (variable.isStringMode()) {
        return generateTypeConvertMethod(""String_Node_Str"" + StringUtilities.escapeString(parseTreeCodeGenerator.escapeForTargetLanguage(variable.getExpression())) + ""String_Node_Str"",castType,""String_Node_Str"");
      }
      PtParser parser=new PtParser();
      ASTPtRootNode parseTree=null;
      try {
        parseTree=parser.generateParseTree(variable.getExpression());
      }
 catch (      Throwable throwable) {
        CGException.throwException(variable,throwable,""String_Node_Str"" + name + ""String_Node_Str""+ container+ ""String_Node_Str"");
      }
      try {
        parseTreeCodeGenerator.evaluateParseTree(parseTree,new VariableScope(variable));
      }
 catch (      Exception ex) {
        StringBuffer results=new StringBuffer();
        Iterator<?> allScopedVariableNames=ModelScope.getAllScopedVariableNames(variable,container).iterator();
        while (allScopedVariableNames.hasNext()) {
          results.append(allScopedVariableNames.next().toString() + ""String_Node_Str"");
        }
        CGException.throwException(_component,ex,""String_Node_Str"" + variable.getFullName() + ""String_Node_Str""+ results.toString());
      }
      String fireCode=processCode(parseTreeCodeGenerator.generateFireCode());
      return generateTypeConvertMethod(fireCode,castType,_getCodeGenerator().codeGenType(variable.getType()));
    }
 else {
      return ((Settable)attribute).getExpression();
    }
  }
 else {
    if (attribute instanceof Parameter) {
      Token token=((Parameter)attribute).getToken();
      if (token instanceof ArrayToken) {
        Token element=((ArrayToken)token).getElement(Integer.valueOf(offset).intValue());
        ParseTreeCodeGenerator parseTreeCodeGenerator=getParseTreeCodeGenerator();
        PtParser parser=new PtParser();
        ASTPtRootNode parseTree=null;
        try {
          parseTree=parser.generateParseTree(element.toString());
        }
 catch (        Throwable throwable) {
          CGException.throwException(attribute,throwable,""String_Node_Str"" + name + ""String_Node_Str""+ container+ ""String_Node_Str"");
        }
        parseTreeCodeGenerator.evaluateParseTree(parseTree,new VariableScope((Parameter)attribute));
        String elementCode=processCode(parseTreeCodeGenerator.generateFireCode());
        return generateTypeConvertMethod(elementCode,castType,_getCodeGenerator().codeGenType(element.getType()));
      }
      CGException.throwException(_component,attributeName + ""String_Node_Str"");
    }
    CGException.throwException(_component,attributeName + ""String_Node_Str"");
  }
  return ""String_Node_Str"";
}"
73428,"/** 
 * Clone this actor into the specified workspace. The new actor is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new actor with the same ports as the original, but no connections and no container.  A container must be set before much can be done with this actor.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return A new Bus.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  CrossbarSwitch newObject=(CrossbarSwitch)super.clone(workspace);
  newObject._actorPorts=new HashMap();
  newObject._receivers=new Hashtable();
  newObject._nextFireTime=null;
  newObject._inputTokens=new HashMap();
  newObject._outputTokens=new HashMap();
  newObject._switchFabricQueue=new HashMap();
  return newObject;
}","/** 
 * Clone this actor into the specified workspace. The new actor is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new actor with the same ports as the original, but no connections and no container.  A container must be set before much can be done with this actor.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return A new Bus.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  CrossbarSwitch newObject=(CrossbarSwitch)super.clone(workspace);
  newObject._actorPorts=new HashMap();
  newObject._receivers=new Hashtable();
  newObject._nextFireTime=null;
  newObject._inputTokens=new HashMap();
  newObject._outputTokens=new HashMap();
  newObject._switchFabricQueue=new HashMap();
  newObject._waitingOnSwitchFabricQueue=(HashMap)newObject._waitingOnSwitchFabricQueue;
  return newObject;
}"
73429,"/** 
 * Compute the down-set of an element in this concept graph. This is implemented by deferring to the downSet functions of the component graphs and then enumerating all the product results.
 * @param e An Object representing a ProductLatticeConcept in thisconcept graph.
 * @return An array of ProductLatticeConcepts of the down-set ofthe given argument concept.
 * @exception IllegalArgumentException If the passed object is not a ProductLatticeConcept or does not belong to this CPO.
 */
public ProductLatticeConcept[] downSet(Object e){
  _validateInputArguments(e,e);
  ProductLatticeConcept productConcept=(ProductLatticeConcept)e;
  List<List<Concept>> downSets=new ArrayList<List<Concept>>();
  for (  Concept c : productConcept.getConceptTuple()) {
    ConceptGraph cg=c.getOntology().getConceptGraph();
    List<Concept> downSet=Arrays.asList(cg.downSet(c));
    downSets.add(downSet);
  }
  List<List<Concept>> productLatticeConcepts=new ArrayList<List<Concept>>();
  productLatticeConcepts.add(new ArrayList<Concept>());
  for (  List<Concept> concepts : downSets) {
    List<List<Concept>> oldLayer=productLatticeConcepts;
    productLatticeConcepts=new ArrayList<List<Concept>>();
    for (    Concept c : concepts) {
      for (      List<Concept> intermediateResult : oldLayer) {
        List<Concept> newLayer=new ArrayList<Concept>(intermediateResult);
        newLayer.add(c);
        productLatticeConcepts.add(newLayer);
      }
    }
  }
  List<ProductLatticeConcept> result=new ArrayList<ProductLatticeConcept>();
  for (  List<Concept> pc : productLatticeConcepts) {
    try {
      result.add(_productOntology.getProductLatticeConceptFromTuple(pc));
    }
 catch (    IllegalActionException ex) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + e + ""String_Node_Str""+ this,ex);
    }
  }
  return result.toArray(new ProductLatticeConcept[0]);
}","/** 
 * Compute the down-set of an element in this concept graph. This is implemented by deferring to the downSet functions of the component graphs and then enumerating all the product results.
 * @param e An Object representing a ProductLatticeConcept in thisconcept graph.
 * @return An array of ProductLatticeConcepts of the down-set ofthe given argument concept.
 * @exception IllegalArgumentException If the passed object is not a ProductLatticeConcept or does not belong to this CPO.
 */
public ProductLatticeConcept[] downSet(Object e){
  _validateInputArguments(e,e);
  ProductLatticeConcept productConcept=(ProductLatticeConcept)e;
  List<List<Concept>> downSets=new ArrayList<List<Concept>>();
  for (  Concept c : productConcept.getConceptTuple()) {
    ConceptGraph cg=c.getOntology().getConceptGraph();
    List<Concept> downSet=Arrays.asList(cg.downSet(c));
    downSets.add(downSet);
  }
  List<List<Concept>> productLatticeConcepts=new ArrayList<List<Concept>>();
  productLatticeConcepts.add(new ArrayList<Concept>());
  for (  List<Concept> concepts : downSets) {
    List<List<Concept>> oldLayer=productLatticeConcepts;
    productLatticeConcepts=new ArrayList<List<Concept>>();
    for (    Concept c : concepts) {
      for (      List<Concept> intermediateResult : oldLayer) {
        List<Concept> newLayer=new ArrayList<Concept>(intermediateResult);
        newLayer.add(c);
        productLatticeConcepts.add(newLayer);
      }
    }
  }
  List<ProductLatticeConcept> result=new ArrayList<ProductLatticeConcept>();
  for (  List<Concept> pc : productLatticeConcepts) {
    try {
      result.add(_productOntology.getProductLatticeConceptFromTuple(pc));
    }
 catch (    IllegalActionException ex) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + e + ""String_Node_Str""+ this,ex);
    }
  }
  return result.toArray(new ProductLatticeConcept[result.size()]);
}"
73430,"/** 
 * Create a new BaseUnitConcept, belonging to the given ontology.
 * @param ontology The ontology to which this concept belongs.
 * @param representative The finite concept that represents the physicaldimension for the set infinite concepts that represent units for this dimension in the ontology lattice.
 * @param unitInfo The record token value that has the name and scalefactor information for this unit.
 * @throws NameDuplicationException Should never be thrown.
 * @throws IllegalActionException If the base class throws it.
 */
protected BaseUnitConcept(Ontology ontology,BaseDimensionRepresentativeConcept representative,RecordToken unitInfo) throws IllegalActionException, NameDuplicationException {
  super(ontology,representative,unitInfo);
  Token unitFactor=unitInfo.get(UnitConversionInfo.unitFactorLabel);
  if (unitFactor instanceof ScalarToken) {
    _unitFactor=(ScalarToken)unitFactor;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + unitFactor);
  }
  Token unitOffset=unitInfo.get(UnitConversionInfo.unitOffsetLabel);
  if (unitFactor instanceof ScalarToken) {
    _unitOffset=(ScalarToken)unitOffset;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + unitOffset);
  }
}","/** 
 * Create a new BaseUnitConcept, belonging to the given ontology.
 * @param ontology The ontology to which this concept belongs.
 * @param representative The finite concept that represents the physicaldimension for the set infinite concepts that represent units for this dimension in the ontology lattice.
 * @param unitInfo The record token value that has the name and scalefactor information for this unit.
 * @throws NameDuplicationException Should never be thrown.
 * @throws IllegalActionException If the base class throws it.
 */
protected BaseUnitConcept(Ontology ontology,BaseDimensionRepresentativeConcept representative,RecordToken unitInfo) throws IllegalActionException, NameDuplicationException {
  super(ontology,representative,unitInfo);
  Token unitFactor=unitInfo.get(UnitConversionInfo.unitFactorLabel);
  if (unitFactor instanceof ScalarToken) {
    _unitFactor=(ScalarToken)unitFactor;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + unitFactor);
  }
  Token unitOffset=unitInfo.get(UnitConversionInfo.unitOffsetLabel);
  if (unitOffset instanceof ScalarToken) {
    _unitOffset=(ScalarToken)unitOffset;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + unitOffset);
  }
}"
73431,"/** 
 * Get the integer exponent value from a dimensionRecord record token.
 * @param dimensionRecord The record token that specifies the dimensionand its exponent.
 * @return The integer exponent for the dimension contained in the record token.
 * @throws IllegalActionException Thrown if the dimension record tokenor the exponent value in the record token is zero or invalid.
 */
private Integer _getExponentValue(RecordToken dimensionRecord) throws IllegalActionException {
  Token exponentToken=dimensionRecord.get(_exponentLabel);
  if (exponentToken instanceof IntToken) {
    int exponentValue=(((IntToken)exponentToken).intValue());
    if (exponentValue == 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      return new Integer(exponentValue);
    }
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + dimensionRecord);
  }
}","/** 
 * Get the integer exponent value from a dimensionRecord record token.
 * @param dimensionRecord The record token that specifies the dimensionand its exponent.
 * @return The integer exponent for the dimension contained in the record token.
 * @throws IllegalActionException Thrown if the dimension record tokenor the exponent value in the record token is zero or invalid.
 */
private Integer _getExponentValue(RecordToken dimensionRecord) throws IllegalActionException {
  Token exponentToken=dimensionRecord.get(_exponentLabel);
  if (exponentToken instanceof IntToken) {
    int exponentValue=(((IntToken)exponentToken).intValue());
    if (exponentValue == 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      return Integer.valueOf(exponentValue);
    }
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + dimensionRecord);
  }
}"
73432,"/** 
 * Increment the base dimension exponent by the given exponent value.
 * @param baseDimensionsMap The map of base dimensions being updated.
 * @param dimension The specified base dimension to be incremented.
 * @param exponentValue The exponent value by which the base dimensionexponent will be incremented.
 * @throws IllegalActionException Thrown if the base dimension concept isinvalid.
 */
private static void _incrementBaseDimensionExponent(Map<BaseDimensionRepresentativeConcept,Integer> baseDimensionsMap,BaseDimensionRepresentativeConcept dimension,int exponentValue) throws IllegalActionException {
  Integer currentExponent=baseDimensionsMap.get(dimension);
  if (currentExponent == null && exponentValue != 0) {
    baseDimensionsMap.put(dimension,new Integer(exponentValue));
  }
 else {
    int newExponentValue=currentExponent.intValue() + exponentValue;
    if (newExponentValue != 0) {
      baseDimensionsMap.put(dimension,new Integer(newExponentValue));
    }
 else {
      baseDimensionsMap.remove(dimension);
    }
  }
}","/** 
 * Increment the base dimension exponent by the given exponent value.
 * @param baseDimensionsMap The map of base dimensions being updated.
 * @param dimension The specified base dimension to be incremented.
 * @param exponentValue The exponent value by which the base dimensionexponent will be incremented.
 * @throws IllegalActionException Thrown if the base dimension concept isinvalid.
 */
private static void _incrementBaseDimensionExponent(Map<BaseDimensionRepresentativeConcept,Integer> baseDimensionsMap,BaseDimensionRepresentativeConcept dimension,int exponentValue) throws IllegalActionException {
  Integer currentExponent=baseDimensionsMap.get(dimension);
  if (currentExponent == null) {
    if (exponentValue != 0) {
      baseDimensionsMap.put(dimension,Integer.valueOf(exponentValue));
    }
  }
 else {
    int newExponentValue=currentExponent.intValue() + exponentValue;
    if (newExponentValue != 0) {
      baseDimensionsMap.put(dimension,Integer.valueOf(newExponentValue));
    }
 else {
      baseDimensionsMap.remove(dimension);
    }
  }
}"
73433,"/** 
 * Update the base component units map with the set of base units from another derived units' base component units map.
 * @param baseUnitsMap The base component units map to be updated.
 * @param baseUnitsMapFromDerivedUnit The base component units map from anotherderived unit concept to be added to the baseUnitsMap.
 */
private static void _addDerivedUnit(Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseUnitsMap,Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseUnitsMapFromDerivedUnit){
  for (  BaseDimensionRepresentativeConcept baseDimension : baseUnitsMapFromDerivedUnit.keySet()) {
    List<BaseUnitConcept>[] arrayOfBaseUnitsListsFromDerivedUnit=baseUnitsMapFromDerivedUnit.get(baseDimension);
    List<BaseUnitConcept>[] arrayOfBaseUnitsLists=baseUnitsMap.get(baseDimension);
    if (arrayOfBaseUnitsLists == null) {
      arrayOfBaseUnitsLists=arrayOfBaseUnitsListsFromDerivedUnit;
    }
 else {
      arrayOfBaseUnitsLists[POSITIVE_EXPONENT_INDEX].addAll(arrayOfBaseUnitsListsFromDerivedUnit[POSITIVE_EXPONENT_INDEX]);
      arrayOfBaseUnitsLists[NEGATIVE_EXPONENT_INDEX].addAll(arrayOfBaseUnitsListsFromDerivedUnit[NEGATIVE_EXPONENT_INDEX]);
    }
    baseUnitsMap.put(baseDimension,arrayOfBaseUnitsLists);
  }
}","/** 
 * Update the base component units map with the set of base units from another derived units' base component units map.
 * @param baseUnitsMap The base component units map to be updated.
 * @param baseUnitsMapFromDerivedUnit The base component units map from anotherderived unit concept to be added to the baseUnitsMap.
 */
private static void _addDerivedUnit(Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseUnitsMap,Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseUnitsMapFromDerivedUnit){
  for (  Map.Entry<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseUnitsMapEntry : baseUnitsMapFromDerivedUnit.entrySet()) {
    BaseDimensionRepresentativeConcept baseDimension=baseUnitsMapEntry.getKey();
    List<BaseUnitConcept>[] arrayOfBaseUnitsListsFromDerivedUnit=baseUnitsMapEntry.getValue();
    List<BaseUnitConcept>[] arrayOfBaseUnitsLists=baseUnitsMap.get(baseDimension);
    if (arrayOfBaseUnitsLists == null) {
      arrayOfBaseUnitsLists=arrayOfBaseUnitsListsFromDerivedUnit;
    }
 else {
      arrayOfBaseUnitsLists[POSITIVE_EXPONENT_INDEX].addAll(arrayOfBaseUnitsListsFromDerivedUnit[POSITIVE_EXPONENT_INDEX]);
      arrayOfBaseUnitsLists[NEGATIVE_EXPONENT_INDEX].addAll(arrayOfBaseUnitsListsFromDerivedUnit[NEGATIVE_EXPONENT_INDEX]);
    }
    baseUnitsMap.put(baseDimension,arrayOfBaseUnitsLists);
  }
}"
73434,"/** 
 * Derive a map of base dimensions to lists of units that represents the given component units map and dimension map.
 * @param componentUnitsMap The map of dimensions to lists of units fromwhich the base component units map will be derived.
 * @param dimensionMap The map of dimensions to exponents from whichbase dimension map will be derived.
 * @param baseDimensionMap The map of base dimensions to exponents neededfor creating the base component units map.
 * @return The map of base dimensions to exponents that composes the givendimension map.
 * @throws IllegalActionException Thrown if an invalid dimension conceptis found.
 */
public static Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>> deriveComponentBaseUnitsMap(Map<DimensionRepresentativeConcept,List<UnitConcept>> componentUnitsMap,Map<DimensionRepresentativeConcept,Integer> dimensionMap,Map<BaseDimensionRepresentativeConcept,Integer> baseDimensionMap) throws IllegalActionException {
  Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>> baseComponentUnits=new HashMap<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>>();
  Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseComponentUnitsSeparateExponents=_deriveComponentBaseUnitsSeparateExponentsMap(componentUnitsMap,dimensionMap,baseDimensionMap);
  for (  BaseDimensionRepresentativeConcept baseDimension : baseDimensionMap.keySet()) {
    int exponent=baseDimensionMap.get(baseDimension).intValue();
    List<BaseUnitConcept> positiveExponentUnitList=baseComponentUnitsSeparateExponents.get(baseDimension)[POSITIVE_EXPONENT_INDEX];
    List<BaseUnitConcept> negativeExponentUnitList=baseComponentUnitsSeparateExponents.get(baseDimension)[NEGATIVE_EXPONENT_INDEX];
    List<BaseUnitConcept> composedUnitList=null;
    if (exponent > 0) {
      composedUnitList=_removeMatchingListElements(positiveExponentUnitList,negativeExponentUnitList);
    }
 else     if (exponent < 0) {
      composedUnitList=_removeMatchingListElements(negativeExponentUnitList,positiveExponentUnitList);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (composedUnitList.size() == Math.abs(exponent)) {
      Collections.sort(composedUnitList,new BaseUnitComparator());
      baseComponentUnits.put(baseDimension,composedUnitList);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + baseDimension + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ composedUnitList.size()+ ""String_Node_Str""+ exponent);
    }
  }
  return baseComponentUnits;
}","/** 
 * Derive a map of base dimensions to lists of units that represents the given component units map and dimension map.
 * @param componentUnitsMap The map of dimensions to lists of units fromwhich the base component units map will be derived.
 * @param dimensionMap The map of dimensions to exponents from whichbase dimension map will be derived.
 * @param baseDimensionMap The map of base dimensions to exponents neededfor creating the base component units map.
 * @return The map of base dimensions to exponents that composes the givendimension map.
 * @throws IllegalActionException Thrown if an invalid dimension conceptis found.
 */
public static Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>> deriveComponentBaseUnitsMap(Map<DimensionRepresentativeConcept,List<UnitConcept>> componentUnitsMap,Map<DimensionRepresentativeConcept,Integer> dimensionMap,Map<BaseDimensionRepresentativeConcept,Integer> baseDimensionMap) throws IllegalActionException {
  Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>> baseComponentUnits=new HashMap<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>>();
  Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseComponentUnitsSeparateExponents=_deriveComponentBaseUnitsSeparateExponentsMap(componentUnitsMap,dimensionMap,baseDimensionMap);
  for (  Map.Entry<BaseDimensionRepresentativeConcept,Integer> baseDimensionMapEntry : baseDimensionMap.entrySet()) {
    BaseDimensionRepresentativeConcept baseDimension=baseDimensionMapEntry.getKey();
    int exponent=baseDimensionMapEntry.getValue().intValue();
    List<BaseUnitConcept> positiveExponentUnitList=baseComponentUnitsSeparateExponents.get(baseDimension)[POSITIVE_EXPONENT_INDEX];
    List<BaseUnitConcept> negativeExponentUnitList=baseComponentUnitsSeparateExponents.get(baseDimension)[NEGATIVE_EXPONENT_INDEX];
    List<BaseUnitConcept> composedUnitList=null;
    if (exponent > 0) {
      composedUnitList=_removeMatchingListElements(positiveExponentUnitList,negativeExponentUnitList);
    }
 else     if (exponent < 0) {
      composedUnitList=_removeMatchingListElements(negativeExponentUnitList,positiveExponentUnitList);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (composedUnitList.size() == Math.abs(exponent)) {
      Collections.sort(composedUnitList,new BaseUnitComparator());
      baseComponentUnits.put(baseDimension,composedUnitList);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + baseDimension + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ composedUnitList.size()+ ""String_Node_Str""+ exponent);
    }
  }
  return baseComponentUnits;
}"
73435,"/** 
 * Recursively construct the base component units map for the given component units map and return it. Each value in the map is a two-element array of lists of BaseUnitConcepts that indicate the positive and negative exponent units for the base dimension.
 * @param componentUnitsMap The component units map from which to derivethe base component units map.
 * @param dimensionMap The dimension map for the component units map.
 * @param baseDimensionMap The already calculated base dimension map forthe dimension map input.
 * @return The base component units map with separate lists ofpositive and negative exponent units.
 * @throws IllegalActionException Thrown if unit concepts that areneither BaseUnitConcepts or DerivedUnitConcepts are found.
 */
private static Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> _deriveComponentBaseUnitsSeparateExponentsMap(Map<DimensionRepresentativeConcept,List<UnitConcept>> componentUnitsMap,Map<DimensionRepresentativeConcept,Integer> dimensionMap,Map<BaseDimensionRepresentativeConcept,Integer> baseDimensionMap) throws IllegalActionException {
  Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseComponentUnitsSeparateExponents=new HashMap<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]>();
  for (  DimensionRepresentativeConcept dimension : componentUnitsMap.keySet()) {
    List<UnitConcept> unitsList=componentUnitsMap.get(dimension);
    int exponent=dimensionMap.get(dimension).intValue();
    for (    UnitConcept unit : unitsList) {
      if (unit instanceof BaseUnitConcept) {
        Integer baseExponentInteger=baseDimensionMap.get(dimension);
        int baseDimensionMapExponent=0;
        if (baseExponentInteger != null) {
          baseDimensionMapExponent=baseExponentInteger;
        }
        _addBaseUnit(baseComponentUnitsSeparateExponents,(BaseUnitConcept)unit,exponent,baseDimensionMapExponent);
      }
 else       if (unit instanceof DerivedUnitConcept) {
        DerivedDimensionRepresentativeConcept unitDimension=(DerivedDimensionRepresentativeConcept)unit.getDimension();
        Map<DimensionRepresentativeConcept,Integer> unitDimensionMap=unitDimension.getComponentDimensions();
        Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> derivedUnitBaseComponentSeparateExponents=_deriveComponentBaseUnitsSeparateExponentsMap(((DerivedUnitConcept)unit).getComponentUnits(),unitDimensionMap,DerivedDimensionRepresentativeConcept.deriveComponentBaseDimensionsMap(unitDimensionMap));
        _addDerivedUnit(baseComponentUnitsSeparateExponents,derivedUnitBaseComponentSeparateExponents);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  return baseComponentUnitsSeparateExponents;
}","/** 
 * Recursively construct the base component units map for the given component units map and return it. Each value in the map is a two-element array of lists of BaseUnitConcepts that indicate the positive and negative exponent units for the base dimension.
 * @param componentUnitsMap The component units map from which to derivethe base component units map.
 * @param dimensionMap The dimension map for the component units map.
 * @param baseDimensionMap The already calculated base dimension map forthe dimension map input.
 * @return The base component units map with separate lists ofpositive and negative exponent units.
 * @throws IllegalActionException Thrown if unit concepts that areneither BaseUnitConcepts or DerivedUnitConcepts are found.
 */
private static Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> _deriveComponentBaseUnitsSeparateExponentsMap(Map<DimensionRepresentativeConcept,List<UnitConcept>> componentUnitsMap,Map<DimensionRepresentativeConcept,Integer> dimensionMap,Map<BaseDimensionRepresentativeConcept,Integer> baseDimensionMap) throws IllegalActionException {
  Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> baseComponentUnitsSeparateExponents=new HashMap<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]>();
  for (  Map.Entry<DimensionRepresentativeConcept,List<UnitConcept>> componentUnitsMapEntry : componentUnitsMap.entrySet()) {
    DimensionRepresentativeConcept dimension=componentUnitsMapEntry.getKey();
    List<UnitConcept> unitsList=componentUnitsMapEntry.getValue();
    int exponent=dimensionMap.get(dimension).intValue();
    for (    UnitConcept unit : unitsList) {
      if (unit instanceof BaseUnitConcept) {
        Integer baseExponentInteger=baseDimensionMap.get(dimension);
        int baseDimensionMapExponent=0;
        if (baseExponentInteger != null) {
          baseDimensionMapExponent=baseExponentInteger;
        }
        _addBaseUnit(baseComponentUnitsSeparateExponents,(BaseUnitConcept)unit,exponent,baseDimensionMapExponent);
      }
 else       if (unit instanceof DerivedUnitConcept) {
        DerivedDimensionRepresentativeConcept unitDimension=(DerivedDimensionRepresentativeConcept)unit.getDimension();
        Map<DimensionRepresentativeConcept,Integer> unitDimensionMap=unitDimension.getComponentDimensions();
        Map<BaseDimensionRepresentativeConcept,List<BaseUnitConcept>[]> derivedUnitBaseComponentSeparateExponents=_deriveComponentBaseUnitsSeparateExponentsMap(((DerivedUnitConcept)unit).getComponentUnits(),unitDimensionMap,DerivedDimensionRepresentativeConcept.deriveComponentBaseDimensionsMap(unitDimensionMap));
        _addDerivedUnit(baseComponentUnitsSeparateExponents,derivedUnitBaseComponentSeparateExponents);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  return baseComponentUnitsSeparateExponents;
}"
73436,"/** 
 * Return a new list of BaseUnitConcepts that removes all the elements of the elementsToBeRemoved list from the originalList.
 * @param originalList The original list of BaseUnitConcepts.
 * @param elementsToBeRemoved The list of BaseUnitConcepts to be removedfrom the originalList.
 * @return A new list that contains all the elements of the original listminus the elements from the elementsToBeRemoved list.
 * @throws IllegalActionException Thrown if the original list is null,or the original list has fewer elements than the elementsToBeRemoved list.
 */
private static List<BaseUnitConcept> _removeMatchingListElements(List<BaseUnitConcept> originalList,List<BaseUnitConcept> elementsToBeRemoved) throws IllegalActionException {
  if (originalList == null) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (originalList.size() < elementsToBeRemoved.size()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (elementsToBeRemoved == null || elementsToBeRemoved.isEmpty()) {
    return new ArrayList<BaseUnitConcept>(originalList);
  }
 else {
    List<BaseUnitConcept> resultList=new ArrayList<BaseUnitConcept>(originalList);
    for (    BaseUnitConcept unitToBeRemoved : elementsToBeRemoved) {
      resultList.remove(unitToBeRemoved);
    }
    return resultList;
  }
}","/** 
 * Return a new list of BaseUnitConcepts that removes all the elements of the elementsToBeRemoved list from the originalList.
 * @param originalList The original list of BaseUnitConcepts.
 * @param elementsToBeRemoved The list of BaseUnitConcepts to be removedfrom the originalList.
 * @return A new list that contains all the elements of the original listminus the elements from the elementsToBeRemoved list.
 * @throws IllegalActionException Thrown if the original list is null,or the original list has fewer elements than the elementsToBeRemoved list.
 */
private static List<BaseUnitConcept> _removeMatchingListElements(List<BaseUnitConcept> originalList,List<BaseUnitConcept> elementsToBeRemoved) throws IllegalActionException {
  if (originalList == null) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (elementsToBeRemoved == null || elementsToBeRemoved.isEmpty()) {
    return new ArrayList<BaseUnitConcept>(originalList);
  }
 else   if (originalList.size() < elementsToBeRemoved.size()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    List<BaseUnitConcept> resultList=new ArrayList<BaseUnitConcept>(originalList);
    for (    BaseUnitConcept unitToBeRemoved : elementsToBeRemoved) {
      resultList.remove(unitToBeRemoved);
    }
    return resultList;
  }
}"
73437,"/** 
 * Apply the individual unit conversion factors and offsets for each component unit to the conversion factor and offset for the derived unit.
 * @throws IllegalActionException Thrown if there is a problem gettingthe component dimensions.
 */
private void _applyComponentUnitConversionFactors() throws IllegalActionException {
  Map<DimensionRepresentativeConcept,Integer> componentDimensions=((DerivedDimensionRepresentativeConcept)_representative).getComponentDimensions();
  for (  DimensionRepresentativeConcept dimension : componentDimensions.keySet()) {
    int dimensionExponent=componentDimensions.get(dimension).intValue();
    List<UnitConcept> unitsList=_componentUnits.get(dimension);
    for (    UnitConcept unit : unitsList) {
      if (dimensionExponent > 0) {
        _unitFactor=(ScalarToken)_unitFactor.multiply(unit._unitFactor);
      }
 else       if (dimensionExponent < 0) {
        _unitFactor=(ScalarToken)_unitFactor.divide(unit._unitFactor);
      }
    }
  }
}","/** 
 * Apply the individual unit conversion factors and offsets for each component unit to the conversion factor and offset for the derived unit.
 * @throws IllegalActionException Thrown if there is a problem gettingthe component dimensions.
 */
private void _applyComponentUnitConversionFactors() throws IllegalActionException {
  Map<DimensionRepresentativeConcept,Integer> componentDimensions=((DerivedDimensionRepresentativeConcept)_representative).getComponentDimensions();
  for (  Map.Entry<DimensionRepresentativeConcept,Integer> componentDimensionsMapEntry : componentDimensions.entrySet()) {
    DimensionRepresentativeConcept dimension=componentDimensionsMapEntry.getKey();
    int dimensionExponent=componentDimensionsMapEntry.getValue().intValue();
    List<UnitConcept> unitsList=_componentUnits.get(dimension);
    for (    UnitConcept unit : unitsList) {
      if (dimensionExponent > 0) {
        _unitFactor=(ScalarToken)_unitFactor.multiply(unit._unitFactor);
      }
 else       if (dimensionExponent < 0) {
        _unitFactor=(ScalarToken)_unitFactor.divide(unit._unitFactor);
      }
    }
  }
}"
73438,"/** 
 * Set the component units for the derived unit based on the given record token that specifies the component units for this derived unit.
 * @param derivedUnitRecord The record token that contains the specifiedunit conversion information.
 * @param unitDimensionRepresentative The dimension representative conceptfor this derived unit concept.
 * @throws IllegalActionException Thrown if the record token has invalidunit conversion specifications.
 */
private void _setComponentUnitsMap(RecordToken derivedUnitRecord,DerivedDimensionRepresentativeConcept unitDimensionRepresentative) throws IllegalActionException {
  Map<DimensionRepresentativeConcept,Integer> componentDimensions=unitDimensionRepresentative.getComponentDimensions();
  for (  DimensionRepresentativeConcept dimension : componentDimensions.keySet()) {
    String dimensionName=dimension.getName();
    Token[] unitsStringTokens=_getUnitsArray(derivedUnitRecord,dimensionName);
    int dimensionExponent=componentDimensions.get(dimension).intValue();
    int dimensionExponentAbsValue=Math.abs(dimensionExponent);
    if (unitsStringTokens.length == dimensionExponentAbsValue) {
      List<UnitConcept> unitsList=new ArrayList<UnitConcept>();
      for (      Token unitStringToken : unitsStringTokens) {
        String unitName=((StringToken)unitStringToken).stringValue();
        Concept unit=getOntology().getConceptByString(dimensionName + ""String_Node_Str"" + unitName);
        if (unit instanceof UnitConcept) {
          unitsList.add((UnitConcept)unit);
        }
 else {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + unit);
        }
      }
      _componentUnits.put(dimension,unitsList);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + dimension + ""String_Node_Str""+ dimensionExponent+ ""String_Node_Str""+ ""String_Node_Str""+ dimensionExponentAbsValue+ ""String_Node_Str"");
    }
  }
  _componentBaseUnits=deriveComponentBaseUnitsMap(_componentUnits,componentDimensions,unitDimensionRepresentative.getComponentBaseDimensions());
}","/** 
 * Set the component units for the derived unit based on the given record token that specifies the component units for this derived unit.
 * @param derivedUnitRecord The record token that contains the specifiedunit conversion information.
 * @param unitDimensionRepresentative The dimension representative conceptfor this derived unit concept.
 * @throws IllegalActionException Thrown if the record token has invalidunit conversion specifications.
 */
private void _setComponentUnitsMap(RecordToken derivedUnitRecord,DerivedDimensionRepresentativeConcept unitDimensionRepresentative) throws IllegalActionException {
  Map<DimensionRepresentativeConcept,Integer> componentDimensions=unitDimensionRepresentative.getComponentDimensions();
  for (  Map.Entry<DimensionRepresentativeConcept,Integer> componentDimensionsMapEntry : componentDimensions.entrySet()) {
    DimensionRepresentativeConcept dimension=componentDimensionsMapEntry.getKey();
    String dimensionName=dimension.getName();
    Token[] unitsStringTokens=_getUnitsArray(derivedUnitRecord,dimensionName);
    int dimensionExponent=componentDimensionsMapEntry.getValue().intValue();
    int dimensionExponentAbsValue=Math.abs(dimensionExponent);
    if (unitsStringTokens.length == dimensionExponentAbsValue) {
      List<UnitConcept> unitsList=new ArrayList<UnitConcept>();
      for (      Token unitStringToken : unitsStringTokens) {
        String unitName=((StringToken)unitStringToken).stringValue();
        Concept unit=getOntology().getConceptByString(dimensionName + ""String_Node_Str"" + unitName);
        if (unit instanceof UnitConcept) {
          unitsList.add((UnitConcept)unit);
        }
 else {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + unit);
        }
      }
      _componentUnits.put(dimension,unitsList);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + dimension + ""String_Node_Str""+ dimensionExponent+ ""String_Node_Str""+ ""String_Node_Str""+ dimensionExponentAbsValue+ ""String_Node_Str"");
    }
  }
  _componentBaseUnits=deriveComponentBaseUnitsMap(_componentUnits,componentDimensions,unitDimensionRepresentative.getComponentBaseDimensions());
}"
73439,"/** 
 * Find the UnitConcept that represents the composition of the two input UnitConcepts which will be the result of either multiplication or division of the two units depending on the value of the _isMultiply class variable.
 * @param unit1 The first unit concept.
 * @param unit2 The second unit concept.
 * @return The unit concept that represents the multiplication or divisionof the two input concepts, or the top of the lattice if that unit does not exist in the ontology.
 * @throws IllegalActionException Thrown if either of the UnitConcep inputsis invalid.
 */
private Concept _findComposedUnitConcept(UnitConcept unit1,UnitConcept unit2) throws IllegalActionException {
  int exponentValue=0;
  ScalarToken newUnitFactor=null;
  if (_isMultiply) {
    exponentValue=1;
    newUnitFactor=(ScalarToken)unit1.getUnitFactor().multiply(unit2.getUnitFactor());
  }
 else {
    exponentValue=-1;
    newUnitFactor=(ScalarToken)unit1.getUnitFactor().divide(unit2.getUnitFactor());
  }
  DimensionRepresentativeConcept unit1Dimension=unit1.getDimension();
  DimensionRepresentativeConcept unit2Dimension=unit2.getDimension();
  Map<DimensionRepresentativeConcept,Integer> dimensionMap=null;
  Map<DimensionRepresentativeConcept,List<UnitConcept>> componentUnitsMap=null;
  if (unit1Dimension.equals(unit2Dimension)) {
    if (_isMultiply) {
      dimensionMap=new HashMap<DimensionRepresentativeConcept,Integer>();
      componentUnitsMap=new HashMap<DimensionRepresentativeConcept,List<UnitConcept>>();
      dimensionMap.put(unit1Dimension,new Integer(2));
      List<UnitConcept> unitsList=new ArrayList<UnitConcept>();
      unitsList.add(unit1);
      unitsList.add(unit2);
      componentUnitsMap.put(unit1Dimension,unitsList);
    }
 else {
      if (unit1.equals(unit2)) {
        return _getDimensionlessConceptOrTop();
      }
 else {
        return _topOfTheLattice;
      }
    }
  }
 else {
    dimensionMap=_createNewDimensionMap(unit2.getDimension(),exponentValue);
    componentUnitsMap=_createNewComponentUnitsMap(unit2);
    dimensionMap.put(unit1Dimension,new Integer(1));
    List<UnitConcept> unit1List=new ArrayList<UnitConcept>();
    unit1List.add(unit1);
    componentUnitsMap.put(unit1Dimension,unit1List);
  }
  return DerivedUnitConcept.findUnitByComponentMapsAndUnitFactor(dimensionMap,componentUnitsMap,newUnitFactor,_unitOntology);
}","/** 
 * Find the UnitConcept that represents the composition of the two input UnitConcepts which will be the result of either multiplication or division of the two units depending on the value of the _isMultiply class variable.
 * @param unit1 The first unit concept.
 * @param unit2 The second unit concept.
 * @return The unit concept that represents the multiplication or divisionof the two input concepts, or the top of the lattice if that unit does not exist in the ontology.
 * @throws IllegalActionException Thrown if either of the UnitConcep inputsis invalid.
 */
private Concept _findComposedUnitConcept(UnitConcept unit1,UnitConcept unit2) throws IllegalActionException {
  int exponentValue=0;
  ScalarToken newUnitFactor=null;
  if (_isMultiply) {
    exponentValue=1;
    newUnitFactor=(ScalarToken)unit1.getUnitFactor().multiply(unit2.getUnitFactor());
  }
 else {
    exponentValue=-1;
    newUnitFactor=(ScalarToken)unit1.getUnitFactor().divide(unit2.getUnitFactor());
  }
  DimensionRepresentativeConcept unit1Dimension=unit1.getDimension();
  DimensionRepresentativeConcept unit2Dimension=unit2.getDimension();
  Map<DimensionRepresentativeConcept,Integer> dimensionMap=null;
  Map<DimensionRepresentativeConcept,List<UnitConcept>> componentUnitsMap=null;
  if (unit1Dimension.equals(unit2Dimension)) {
    if (_isMultiply) {
      dimensionMap=new HashMap<DimensionRepresentativeConcept,Integer>();
      componentUnitsMap=new HashMap<DimensionRepresentativeConcept,List<UnitConcept>>();
      dimensionMap.put(unit1Dimension,Integer.valueOf(2));
      List<UnitConcept> unitsList=new ArrayList<UnitConcept>();
      unitsList.add(unit1);
      unitsList.add(unit2);
      componentUnitsMap.put(unit1Dimension,unitsList);
    }
 else {
      if (unit1.equals(unit2)) {
        return _getDimensionlessConceptOrTop();
      }
 else {
        return _topOfTheLattice;
      }
    }
  }
 else {
    dimensionMap=_createNewDimensionMap(unit2.getDimension(),exponentValue);
    componentUnitsMap=_createNewComponentUnitsMap(unit2);
    dimensionMap.put(unit1Dimension,Integer.valueOf(1));
    List<UnitConcept> unit1List=new ArrayList<UnitConcept>();
    unit1List.add(unit1);
    componentUnitsMap.put(unit1Dimension,unit1List);
  }
  return DerivedUnitConcept.findUnitByComponentMapsAndUnitFactor(dimensionMap,componentUnitsMap,newUnitFactor,_unitOntology);
}"
73440,"/** 
 * Create and return a new dimension map initialized with the given dimension and exponent.
 * @param dimension The dimension to be added to the dimension map.
 * @param exponentValue The exponent value to be assigned to the dimensionin the map.
 * @return The new dimension Map object.
 */
private Map<DimensionRepresentativeConcept,Integer> _createNewDimensionMap(DimensionRepresentativeConcept dimension,int exponentValue){
  Map<DimensionRepresentativeConcept,Integer> dimensionMap=new HashMap<DimensionRepresentativeConcept,Integer>();
  dimensionMap.put(dimension,new Integer(exponentValue));
  return dimensionMap;
}","/** 
 * Create and return a new dimension map initialized with the given dimension and exponent.
 * @param dimension The dimension to be added to the dimension map.
 * @param exponentValue The exponent value to be assigned to the dimensionin the map.
 * @return The new dimension Map object.
 */
private Map<DimensionRepresentativeConcept,Integer> _createNewDimensionMap(DimensionRepresentativeConcept dimension,int exponentValue){
  Map<DimensionRepresentativeConcept,Integer> dimensionMap=new HashMap<DimensionRepresentativeConcept,Integer>();
  dimensionMap.put(dimension,Integer.valueOf(exponentValue));
  return dimensionMap;
}"
73441,"/** 
 * If there are still tokens in the queue and a token has been produced in the fire,  schedule a refiring.
 */
public boolean postfire() throws IllegalActionException {
  boolean refiringScheduled=false;
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree != null && _tokens.size() > 0 && currentTime.compareTo(_nextTimeFree) == 0) {
    _tokens.take();
    if (_tokens.size() > 0) {
      _nextTimeFree=currentTime.add(_serviceTimeValue);
      _nextReceiver=(Receiver)((Object[])_tokens.get(0))[0];
      _fireAt(_nextTimeFree);
      refiringScheduled=true;
    }
 else {
      refiringScheduled=false;
    }
  }
  if (!(getDirector() instanceof DEDirector) && _receiversAndTokensToSendTo != null) {
    for (    Receiver receiver : _receiversAndTokensToSendTo.keySet()) {
      Token token=_receiversAndTokensToSendTo.get(receiver);
      if (token != null) {
        _tokens.put(new Object[]{receiver,token});
      }
    }
    _receiversAndTokensToSendTo.clear();
    if (!refiringScheduled && _tokens.size() > 0) {
      _nextTimeFree=currentTime.add(_serviceTimeValue);
      _nextReceiver=(Receiver)((Object[])_tokens.get(0))[0];
      _fireAt(_nextTimeFree);
    }
  }
  return super.postfire();
}","/** 
 * If there are still tokens in the queue and a token has been produced in the fire,  schedule a refiring.
 */
public boolean postfire() throws IllegalActionException {
  boolean refiringScheduled=false;
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree != null && _tokens.size() > 0 && currentTime.compareTo(_nextTimeFree) == 0) {
    _tokens.take();
  }
  if ((getDirector() instanceof FixedPointDirector) && _receiversAndTokensToSendTo != null) {
    for (    Receiver receiver : _receiversAndTokensToSendTo.keySet()) {
      Token token=_receiversAndTokensToSendTo.get(receiver);
      if (token != null) {
        _tokens.put(new Object[]{receiver,token});
      }
    }
    _receiversAndTokensToSendTo.clear();
  }
  if (_tokens.size() > 0 && (_nextTimeFree == null || currentTime.compareTo(_nextTimeFree) >= 0)) {
    _scheduleRefire();
  }
  return super.postfire();
}"
73442,"/** 
 * Initialize the actor.
 * @throws IllegalActionException If the superclass throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _receiversAndTokensToSendTo.clear();
}","/** 
 * Initialize the actor.
 * @throws IllegalActionException If the superclass throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _receiversAndTokensToSendTo.clear();
  _tokens.clear();
  _nextTimeFree=null;
}"
73443,"/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor if there is not one already scheduled.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @throws IllegalActionException If the refiring request fails.
 */
public void sendToken(Receiver receiver,Token token) throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree == null || _tokens.size() == 0 || currentTime.compareTo(_nextTimeFree) != 0 || receiver != _nextReceiver) {
    receiver.put(null);
  }
  Token tokenToSend=_receiversAndTokensToSendTo.get(receiver);
  if (tokenToSend != null) {
    if (!tokenToSend.equals(token)) {
      throw new IllegalActionException(this,receiver.getContainer(),""String_Node_Str"" + tokenToSend + ""String_Node_Str""+ token+ ""String_Node_Str"");
    }
  }
 else {
    if (getDirector() instanceof DEDirector) {
      if (token != null) {
        _tokens.put(new Object[]{receiver,token});
      }
      if (_tokens.size() == 1) {
        _nextTimeFree=currentTime.add(_serviceTimeValue);
        _nextReceiver=(Receiver)((Object[])_tokens.get(0))[0];
        _fireAt(_nextTimeFree);
      }
    }
 else {
      _receiversAndTokensToSendTo.put(receiver,token);
    }
  }
  if (token == null) {
    return;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime() + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
  }
}","/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor if there is not one already scheduled.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @throws IllegalActionException If the refiring request fails.
 */
public void sendToken(Receiver receiver,Token token) throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree == null || _tokens.size() == 0 || currentTime.compareTo(_nextTimeFree) != 0 || receiver != _nextReceiver) {
    receiver.put(null);
  }
  Token tokenToSend=_receiversAndTokensToSendTo.get(receiver);
  if (tokenToSend != null) {
    if (!tokenToSend.equals(token)) {
      throw new IllegalActionException(this,receiver.getContainer(),""String_Node_Str"" + tokenToSend + ""String_Node_Str""+ token+ ""String_Node_Str"");
    }
  }
 else {
    if (getDirector() instanceof FixedPointDirector) {
      _receiversAndTokensToSendTo.put(receiver,token);
    }
 else {
      _tokens.put(new Object[]{receiver,token});
      if (_tokens.size() == 1) {
        _scheduleRefire();
      }
    }
  }
  if (token == null) {
    return;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime() + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
  }
}"
73444,"/** 
 * Add new connections.
 * @exception TransformationException If transformation is unsuccessful.
 */
protected void _addConnections() throws TransformationException {
  for (  NamedObj replacement : _replacementToHost.keySet()) {
    NamedObj host=_replacementToHost.get(replacement);
    List<NamedObj> replacementLinkedList;
    List<NamedObj> hostLinkdList;
    if (host instanceof Port) {
      replacementLinkedList=new LinkedList<NamedObj>(((Port)replacement).linkedRelationList());
      hostLinkdList=new LinkedList<NamedObj>(((Port)host).linkedRelationList());
    }
 else     if (host instanceof Relation) {
      replacementLinkedList=new LinkedList<NamedObj>();
      for (      Object relation : ((Relation)replacement).linkedObjectsList()) {
        if (relation instanceof Relation) {
          replacementLinkedList.add((Relation)relation);
        }
      }
      hostLinkdList=new LinkedList<NamedObj>();
      for (      Object relation : ((Relation)host).linkedObjectsList()) {
        if (relation instanceof Relation) {
          replacementLinkedList.add((Relation)relation);
        }
      }
    }
 else {
      continue;
    }
    for (    NamedObj replacementLinkedObject : replacementLinkedList) {
      NamedObj hostLinkedObject=_replacementToHost.get(replacementLinkedObject);
      if (hostLinkedObject != null && !hostLinkdList.contains(hostLinkedObject)) {
        Relation relation=(hostLinkedObject instanceof Relation) ? (Relation)hostLinkedObject : (Relation)host;
        NamedObj hostContainer=relation.getContainer();
        String moml;
        if (relation == hostLinkedObject) {
          moml=_getLinkMoML(host,relation);
        }
 else {
          moml=_getLinkMoML(hostLinkedObject,relation);
        }
        MoMLChangeRequest request=_createChangeRequest(hostContainer,moml);
        request.execute();
      }
    }
    if (replacement instanceof ComponentPort && host instanceof ComponentPort) {
      ComponentPort replacementComponentPort=(ComponentPort)replacement;
      ComponentPort hostComponentPort=(ComponentPort)host;
      try {
        replacementComponentPort.workspace().getReadAccess();
        for (        Object replacementRelationObject : replacementComponentPort.insideRelationList()) {
          Relation replacementRelation=(Relation)replacementRelationObject;
          Relation hostRelation=(Relation)_replacementToHost.get(replacementRelation);
          if (!hostComponentPort.insideRelationList().contains(hostRelation)) {
            NamedObj hostContainer=hostRelation.getContainer();
            String moml=_getLinkMoML(host,hostRelation);
            MoMLChangeRequest request=_createChangeRequest(hostContainer,moml);
            request.execute();
          }
        }
      }
  finally {
        replacementComponentPort.workspace().doneReading();
      }
    }
  }
}","/** 
 * Add new connections.
 * @exception TransformationException If transformation is unsuccessful.
 */
protected void _addConnections() throws TransformationException {
  for (  NamedObj replacement : _replacementToHost.keySet()) {
    NamedObj host=_replacementToHost.get(replacement);
    List<NamedObj> replacementLinkedList;
    List<NamedObj> hostLinkdList;
    if (host instanceof Port) {
      replacementLinkedList=new LinkedList<NamedObj>(((Port)replacement).linkedRelationList());
      hostLinkdList=new LinkedList<NamedObj>(((Port)host).linkedRelationList());
    }
 else     if (host instanceof Relation) {
      replacementLinkedList=new LinkedList<NamedObj>();
      for (      Object relation : ((Relation)replacement).linkedObjectsList()) {
        if (relation instanceof Relation) {
          replacementLinkedList.add((Relation)relation);
        }
      }
      hostLinkdList=new LinkedList<NamedObj>();
      for (      Object relation : ((Relation)host).linkedObjectsList()) {
        if (relation instanceof Relation) {
          replacementLinkedList.add((Relation)relation);
        }
      }
    }
 else {
      continue;
    }
    for (    NamedObj replacementLinkedObject : replacementLinkedList) {
      NamedObj hostLinkedObject=_replacementToHost.get(replacementLinkedObject);
      if (hostLinkedObject != null && !hostLinkdList.contains(hostLinkedObject)) {
        Relation relation=(hostLinkedObject instanceof Relation) ? (Relation)hostLinkedObject : (Relation)host;
        NamedObj hostContainer=relation.getContainer();
        if (!(hostContainer instanceof MirrorComposite)) {
          String moml;
          if (relation == hostLinkedObject) {
            moml=_getLinkMoML(host,relation);
          }
 else {
            moml=_getLinkMoML(hostLinkedObject,relation);
          }
          MoMLChangeRequest request=_createChangeRequest(hostContainer,moml);
          request.execute();
        }
      }
    }
    if (replacement instanceof ComponentPort && host instanceof ComponentPort) {
      ComponentPort replacementComponentPort=(ComponentPort)replacement;
      ComponentPort hostComponentPort=(ComponentPort)host;
      try {
        replacementComponentPort.workspace().getReadAccess();
        for (        Object replacementRelationObject : replacementComponentPort.insideRelationList()) {
          Relation replacementRelation=(Relation)replacementRelationObject;
          Relation hostRelation=(Relation)_replacementToHost.get(replacementRelation);
          NamedObj hostContainer=host.getContainer();
          if (!(hostContainer instanceof MirrorComposite) && !hostComponentPort.insideRelationList().contains(hostRelation)) {
            String moml=_getLinkMoML(host,hostRelation);
            MoMLChangeRequest request=_createChangeRequest(hostContainer,moml);
            request.execute();
          }
        }
      }
  finally {
        replacementComponentPort.workspace().doneReading();
      }
    }
  }
}"
73445,"/** 
 * Given a platform physical tag, get the corresonding oracle physical tag. This assumes there's a one-to-one mapping from the platform's tag to the oracle tag, and vise versa. We also assume the platform tag to be continuous. If the platform time of interest is less than the last saved platform time of the corresponding clock, throw an exception.
 * @param platformTime The platform timestamp.
 * @param clockId The ID of the corresponding platform clock.
 * @return The oracle tag associated with the platform tag. Returns nullif the platform time of interest is less than the last saved platform time of the corresponding clock.
 * @exception IllegalActionException If the clock ID is not recognized.
 */
protected Time _getOraclePhysicalTimeForPlatformPhysicalTime(Time platformTime,int clockId) throws IllegalActionException {
  RealTimeClock realTimeClock;
  if (clockId == EXECUTION_TIMER) {
    realTimeClock=_executionTimeClock;
  }
 else   if (clockId == PLATFORM_TIMER) {
    realTimeClock=_platformTimeClock;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Time timeDifference=platformTime.subtract(realTimeClock._lastPlatformTime);
  if (timeDifference.compareTo(_zero) < 0) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (realTimeClock._clockDrift.equals(_zero)) {
    return (realTimeClock._lastOracleTime.subtract(realTimeClock._lastPlatformTime)).add(platformTime);
  }
  return (timeDifference.divide(realTimeClock._clockDrift)).add(realTimeClock._lastOracleTime);
}","/** 
 * Given a platform physical time, get the corresonding oracle physical time. This assumes there's a one-to-one mapping from the platform's tag to the oracle tag, and vise versa. We also assume the platform tag to be continuous. If the platform time of interest is less than the last saved platform time of the corresponding clock, throw an exception.
 * @param platformTime The platform timestamp.
 * @param clockId The ID of the corresponding platform clock.
 * @return The oracle tag associated with the platform tag. Returns nullif the platform time of interest is less than the last saved platform time of the corresponding clock.
 * @exception IllegalActionException If the clock ID is not recognized.
 */
protected Time _getOraclePhysicalTimeForPlatformPhysicalTime(Time platformTime,int clockId) throws IllegalActionException {
  RealTimeClock realTimeClock;
  if (clockId == EXECUTION_TIMER) {
    realTimeClock=_executionTimeClock;
  }
 else   if (clockId == PLATFORM_TIMER) {
    realTimeClock=_platformTimeClock;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Time timeDifference=platformTime.subtract(realTimeClock._lastPlatformTime);
  if (timeDifference.compareTo(_zero) < 0) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (realTimeClock._clockDrift.equals(_zero)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  return (timeDifference.divide(realTimeClock._clockDrift)).add(realTimeClock._lastOracleTime);
}"
73446,"/** 
 * Construct a real time clock, with all the times and clock drifts set to default values: All clock drifts are initialized to Time 1.0, and the oracle time is initialized to Time 0.0. However the corresponding platform is intialized to the initialClockSynchronizationError paramter.
 */
private RealTimeClock(double initialClockSynchronizationError,double clockDrift) throws IllegalActionException {
  _lastPlatformTime=new Time(PtidesBasicDirector.this,initialClockSynchronizationError);
  _clockDrift=new Time(PtidesBasicDirector.this,clockDrift);
  _lastOracleTime=new Time(PtidesBasicDirector.this);
}","/** 
 * Construct a real time clock, with all the times and clock drifts set to default values: All clock drifts are initialized to Time 1.0, and the oracle time is initialized to Time 0.0. However the corresponding platform is intialized to the initialClockSynchronizationError paramter. The <i>clockDrift</i> parameter specifies how much platform time should be incremented for each unit increment of oracle time. A clock drift of 1.0 means that the clocks remain perfectly synchronized. A clock drift less than 1.0 means that the platform time clock progresses more slowly than oracte time, and a clock drift greater than 1.0 means that it progresses more rapidly.
 * @param platformTimeAtOracleTimeZero The platform Time value interpreted to besimultaneous with oracle time zero.
 * @param clockDrift The relative rate of advance of platform time w.r.t.oracle time.
 */
private RealTimeClock(double platformTimeAtOracleTimeZero,double clockDrift) throws IllegalActionException {
  _lastPlatformTime=new Time(PtidesBasicDirector.this,platformTimeAtOracleTimeZero);
  _clockDrift=new Time(PtidesBasicDirector.this,clockDrift);
  _lastOracleTime=new Time(PtidesBasicDirector.this);
}"
73447,"/** 
 * Generate code for the assembly file.
 * @throws IllegalActionException if getAdaptor throws it, or if thePtidyOSCodeGenerator is not used in a Ptides environment.
 */
protected void _generateAssemblyFile() throws IllegalActionException {
  PtidesPreemptiveEDFDirector directorAdapter=null;
  Director director=((TypedCompositeActor)getContainer()).getDirector();
  if (director instanceof ptolemy.domains.ptides.kernel.PtidesBasicDirector) {
    directorAdapter=(PtidesPreemptiveEDFDirector)getAdapter(director);
    _writeCode(directorAdapter.generateAsseblyFile());
  }
 else   if (director instanceof ptolemy.domains.ptides.kernel.PtidesTopLevelDirector) {
    for (    Actor actor : (List<Actor>)((TypedCompositeActor)getContainer()).deepEntityList()) {
      Director insideDirector=actor.getDirector();
      if (insideDirector instanceof ptolemy.domains.ptides.kernel.PtidesBasicDirector) {
        directorAdapter=(PtidesPreemptiveEDFDirector)getAdapter(director);
        _writeCode(directorAdapter.generateAsseblyFile());
      }
    }
  }
 else {
    throw new IllegalActionException(director,""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Generate code for the assembly file.
 * @exception IllegalActionException If getAdaptor() throws it, or if thePtidyOSCodeGenerator is not used in a Ptides environment.
 */
protected void _generateAssemblyFile() throws IllegalActionException {
  PtidesPreemptiveEDFDirector directorAdapter=null;
  Director director=((TypedCompositeActor)getContainer()).getDirector();
  if (director instanceof ptolemy.domains.ptides.kernel.PtidesBasicDirector) {
    directorAdapter=(PtidesPreemptiveEDFDirector)getAdapter(director);
    _writeCode(directorAdapter.generateAsseblyFile());
  }
 else   if (director instanceof ptolemy.domains.ptides.kernel.PtidesTopLevelDirector) {
    for (    Actor actor : (List<Actor>)((TypedCompositeActor)getContainer()).deepEntityList()) {
      Director insideDirector=actor.getDirector();
      if (insideDirector instanceof ptolemy.domains.ptides.kernel.PtidesBasicDirector) {
        directorAdapter=(PtidesPreemptiveEDFDirector)getAdapter(director);
        _writeCode(directorAdapter.generateAsseblyFile());
      }
    }
  }
 else {
    throw new IllegalActionException(director,""String_Node_Str"" + ""String_Node_Str"");
  }
}"
73448,"/** 
 * Update all future fireAt times. This method should be used when the clock drift for a particular (platform or execution) clock changes, then the future fireAt times will also change. Also keep track of the list of ignored future fireAt times, so that when this director is woken up at those times, the director will not fire.
 * @param realTimeClock The realTimeClock of interest.
 * @throws IllegalActionException If either the original or updated fireAttime is in the past.
 */
public void updateClockDrift(int clockID,Time newClockDrift) throws IllegalActionException {
  if (newClockDrift.compareTo(_zero) < 0) {
    throw new IllegalActionException(PtidesBasicDirector.this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  RealTimeClock realTimeClock=null;
  if (clockID == PtidesBasicDirector.PLATFORM_TIMER) {
    realTimeClock=_platformTimeClock;
  }
 else   if (clockID == PtidesBasicDirector.EXECUTION_TIMER) {
    realTimeClock=_executionTimeClock;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (realTimeClock._clockDrift.compareTo(newClockDrift) != 0) {
    if (realTimeClock == _executionTimeClock) {
      _futureExecutionFireAtTimes=(List<Time>)_updateFireAtTimes(_futureExecutionFireAtTimes,_ignoredExecutionFireAtTimes,realTimeClock,newClockDrift);
    }
 else     if (realTimeClock == _platformTimeClock) {
      _futurePlatformFireAtTimes=(List<Time>)_updateFireAtTimes(_futurePlatformFireAtTimes,_ignoredPlatformFireAtTimes,realTimeClock,newClockDrift);
      _timedInterruptTimes=(List<TimedEvent>)_updateFireAtTimes(_timedInterruptTimes,null,realTimeClock,newClockDrift);
    }
 else {
      throw new InternalErrorException(this,null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    Time newOracleTime=_getOraclePhysicalTag().timestamp;
    realTimeClock._lastPlatformTime=_getPlatformPhysicalTimeForOraclePhysicalTime(newOracleTime,realTimeClock._lastOracleTime,realTimeClock._clockDrift,realTimeClock._lastPlatformTime);
    realTimeClock._lastOracleTime=newOracleTime;
    realTimeClock._clockDrift=newClockDrift;
  }
}","/** 
 * Update all future fireAt times. This method should be used when the clock drift for a particular (platform or execution) clock changes, then the future fireAt times will also change. Also keep track of the list of ignored future fireAt times, so that when this director is woken up at those times, the director will not fire.
 * @param clockID an int specifying the ID of the clock.
 * @param newClockDrift a Time object that indicates the new drift of thatparticular clock.
 * @throws IllegalActionException If either the original or updated fireAttime is in the past.
 */
public void updateClockDrift(int clockID,Time newClockDrift) throws IllegalActionException {
  if (newClockDrift.compareTo(_zero) < 0) {
    throw new IllegalActionException(PtidesBasicDirector.this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  RealTimeClock realTimeClock=null;
  if (clockID == PtidesBasicDirector.PLATFORM_TIMER) {
    realTimeClock=_platformTimeClock;
  }
 else   if (clockID == PtidesBasicDirector.EXECUTION_TIMER) {
    realTimeClock=_executionTimeClock;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (realTimeClock._clockDrift.compareTo(newClockDrift) != 0) {
    if (realTimeClock == _executionTimeClock) {
      _futureExecutionFireAtTimes=(List<Time>)_updateFireAtTimes(_futureExecutionFireAtTimes,_ignoredExecutionFireAtTimes,realTimeClock,newClockDrift);
    }
 else     if (realTimeClock == _platformTimeClock) {
      _futurePlatformFireAtTimes=(List<Time>)_updateFireAtTimes(_futurePlatformFireAtTimes,_ignoredPlatformFireAtTimes,realTimeClock,newClockDrift);
      _timedInterruptTimes=(List<TimedEvent>)_updateFireAtTimes(_timedInterruptTimes,null,realTimeClock,newClockDrift);
    }
 else {
      throw new InternalErrorException(this,null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    Time newOracleTime=_getOraclePhysicalTag().timestamp;
    realTimeClock._lastPlatformTime=_getPlatformPhysicalTimeForOraclePhysicalTime(newOracleTime,realTimeClock._lastOracleTime,realTimeClock._clockDrift,realTimeClock._lastPlatformTime);
    realTimeClock._lastOracleTime=newOracleTime;
    realTimeClock._clockDrift=newClockDrift;
  }
}"
73449,"/** 
 * Get the simulated physical time of the environment, which is the oracle physical time offset by the clock synchronization error due to clock drift.
 * @return the platform physical time.
 * @exception IllegalActionException If director cannot get token for theparameter platformTimeSynchronizationError.
 * @exception InternalErrorException If the platform physical time of thecorresponding current oracle time cannot be retrieved.
 */
public Tag getPlatformPhysicalTag(int clockId) throws IllegalActionException {
  Tag tag=_getOraclePhysicalTag();
  tag.timestamp=_getPlatformPhysicalTimeForOraclePhysicalTime(tag.timestamp,clockId);
  if (tag.timestamp == null) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return tag;
}","/** 
 * Get the simulated physical time of the environment, which is the oracle physical time offset by the clock synchronization error due to clock drift.
 * @param clockId Clock ID.
 * @return the platform physical time.
 * @exception IllegalActionException If director cannot get token for theparameter platformTimeSynchronizationError.
 * @exception InternalErrorException If the platform physical time of thecorresponding current oracle time cannot be retrieved.
 */
public Tag getPlatformPhysicalTag(int clockId) throws IllegalActionException {
  Tag tag=_getOraclePhysicalTag();
  tag.timestamp=_getPlatformPhysicalTimeForOraclePhysicalTime(tag.timestamp,clockId);
  if (tag.timestamp == null) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return tag;
}"
73450,"/** 
 * Given a platform physical tag, get the corresonding oracle physical tag. This assumes there's a one-to-one mapping from the platform's tag to the oracle tag, and vise versa. We also assume the platform tag to be continuous. If the platform time of interest is less than the last saved platform time of the corresponding clock, throw an exception.
 * @param platformTag The platform timestamp and microstep.
 * @param clockId The ID of the corresponding platform clock.
 * @return The oracle tag associated with the platform tag. Returns nullif the platform time of interest is less than the last saved platform time of the corresponding clock.
 * @exception IllegalActionException If the clock ID is not recognized.
 */
protected Time _getOraclePhysicalTimeForPlatformPhysicalTime(Time platformTime,int clockId) throws IllegalActionException {
  RealTimeClock realTimeClock;
  if (clockId == EXECUTION_TIMER) {
    realTimeClock=_executionTimeClock;
  }
 else   if (clockId == PLATFORM_TIMER) {
    realTimeClock=_platformTimeClock;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Time timeDifference=platformTime.subtract(realTimeClock._lastPlatformTime);
  if (timeDifference.compareTo(_zero) < 0) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (realTimeClock._clockDrift.equals(_zero)) {
    return (realTimeClock._lastOracleTime.subtract(realTimeClock._lastPlatformTime)).add(platformTime);
  }
  return (timeDifference.divide(realTimeClock._clockDrift)).add(realTimeClock._lastOracleTime);
}","/** 
 * Given a platform physical tag, get the corresonding oracle physical tag. This assumes there's a one-to-one mapping from the platform's tag to the oracle tag, and vise versa. We also assume the platform tag to be continuous. If the platform time of interest is less than the last saved platform time of the corresponding clock, throw an exception.
 * @param platformTime The platform timestamp.
 * @param clockId The ID of the corresponding platform clock.
 * @return The oracle tag associated with the platform tag. Returns nullif the platform time of interest is less than the last saved platform time of the corresponding clock.
 * @exception IllegalActionException If the clock ID is not recognized.
 */
protected Time _getOraclePhysicalTimeForPlatformPhysicalTime(Time platformTime,int clockId) throws IllegalActionException {
  RealTimeClock realTimeClock;
  if (clockId == EXECUTION_TIMER) {
    realTimeClock=_executionTimeClock;
  }
 else   if (clockId == PLATFORM_TIMER) {
    realTimeClock=_platformTimeClock;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Time timeDifference=platformTime.subtract(realTimeClock._lastPlatformTime);
  if (timeDifference.compareTo(_zero) < 0) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (realTimeClock._clockDrift.equals(_zero)) {
    return (realTimeClock._lastOracleTime.subtract(realTimeClock._lastPlatformTime)).add(platformTime);
  }
  return (timeDifference.divide(realTimeClock._clockDrift)).add(realTimeClock._lastOracleTime);
}"
73451,"/** 
 * Construct a structure that holds a real-time event. This event saves the token to be transmitted, the port and channel this token should be deliverd to, and the time this token should be delivered at.
 * @param port The destination port.
 * @param channel The destination channel.
 * @param token The token to be delivered.
 * @param deliveryTag The platform time of delivery of this token.
 */
public RealTimeEvent(IOPort port,int channel,Token token,Tag deliveryTag,Tag timestampTag){
  this.port=port;
  this.channel=channel;
  this.token=token;
  this.deliveryTag=deliveryTag;
  this.timestampTag=timestampTag;
}","/** 
 * Construct a structure that holds a real-time event. This event saves the token to be transmitted, the port and channel this token should be deliverd to, and the time this token should be delivered at.
 * @param port The destination port.
 * @param channel The destination channel.
 * @param token The token to be delivered.
 * @param deliveryTag The platform time of delivery of this token.
 * @param timestampTag The timestamp tag of this token.
 */
public RealTimeEvent(IOPort port,int channel,Token token,Tag deliveryTag,Tag timestampTag){
  this.port=port;
  this.channel=channel;
  this.token=token;
  this.deliveryTag=deliveryTag;
  this.timestampTag=timestampTag;
}"
73452,"/** 
 * Calculate the delayOffset for each input port in the model, and annotate the ports with these offsets. This causality analysis usually happens at the preinitialize phase. <p> Start from each input port that is connected to the outside of the platform (These input ports indicate sensors and network interfaces, call them startPorts), and traverse the graph until we reach the output port connected to the outside of the platform (actuators/network ports). For each input port in between, annotate it with a delayOffset parameter. This parameter is an array of doubles, where each double corresponds to the minimum delay offset for a particular channel of that port. This minimum delay offset is used for the safe to process analysis. <p> Note: for all transparent composite actors, the delayOffsets are not calculated for their input ports. Instead, the offsets are calculated and annotated for input ports that are inside of these actors.
 * @exception IllegalActionException If failed to clear or calculate delayOffset,cannot check whether the current port is a network port, cannot get the network delay of the current port, cannot get the real time delay of the current port, cannot get remote receivers, or cannot get the port channel for a particular receiver.
 */
protected void _calculateDelayOffsets() throws IllegalActionException {
  _visitedActors=new HashSet<Actor>();
  _clearDelayOffsets();
  _inputModelTimeDelays=new HashMap<IOPort,Map<Integer,SuperdenseDependency>>();
  _portDelays=new HashMap<IOPort,SuperdenseDependency>();
  if (getContainer() instanceof TypedCompositeActor) {
    for (    Actor actor : (List<Actor>)(((TypedCompositeActor)getContainer()).deepEntityList())) {
      for (      TypedIOPort inputPort : (List<TypedIOPort>)(actor.inputPortList())) {
        _portDelays.put(inputPort,SuperdenseDependency.OPLUS_IDENTITY);
      }
      for (      TypedIOPort outputPort : (List<TypedIOPort>)(actor.outputPortList())) {
        _portDelays.put(outputPort,SuperdenseDependency.OPLUS_IDENTITY);
      }
    }
    for (    TypedIOPort inputPort : (List<TypedIOPort>)(((Actor)getContainer()).inputPortList())) {
      SuperdenseDependency startDelay;
      Double start=null;
      if (_isNetworkPort(inputPort)) {
        start=_getNetworkTotalDelay(inputPort);
        if (start != null) {
          start+=getAssumedSynchronizationErrorBound();
        }
 else {
          start=getAssumedSynchronizationErrorBound();
        }
      }
 else {
        start=_getRealTimeDelay(inputPort);
      }
      if (start == null) {
        start=0.0;
      }
      startDelay=SuperdenseDependency.valueOf(-start,0);
      _portDelays.put(inputPort,startDelay);
    }
    for (    TypedIOPort startPort : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).inputPortList())) {
      _traverseToCalcMinDelay(startPort);
    }
    for (    Actor actor : (List<Actor>)((CompositeActor)getContainer()).deepEntityList()) {
      if (!_visitedActors.contains(actor)) {
        for (        IOPort port : (List<IOPort>)actor.outputPortList()) {
          Receiver[][] remoteReceivers=port.getRemoteReceivers();
          for (int i=0; i < remoteReceivers.length; i++) {
            if (remoteReceivers[0] != null) {
              for (int j=0; j < remoteReceivers[i].length; j++) {
                Receiver receiver=remoteReceivers[i][j];
                IOPort receivePort=receiver.getContainer();
                int channel=receivePort.getChannelForReceiver(receiver);
                Map<Integer,SuperdenseDependency> channelDependency=(Map<Integer,SuperdenseDependency>)_inputModelTimeDelays.get(receivePort);
                if (channelDependency == null) {
                  channelDependency=new HashMap<Integer,SuperdenseDependency>();
                }
                channelDependency.put(Integer.valueOf(channel),SuperdenseDependency.OPLUS_IDENTITY);
                _inputModelTimeDelays.put(receivePort,channelDependency);
              }
            }
          }
        }
      }
    }
  }
  for (  IOPort inputPort : (Set<IOPort>)_inputModelTimeDelays.keySet()) {
    Map<Integer,SuperdenseDependency> channelDependency=(Map<Integer,SuperdenseDependency>)_inputModelTimeDelays.get(inputPort);
    double[] delayOffsets=new double[channelDependency.size()];
    for (    Integer portChannelMinDelay : channelDependency.keySet()) {
      delayOffsets[portChannelMinDelay.intValue()]=_calculateMinDelayForPortChannel(inputPort,portChannelMinDelay);
    }
    _setDelayOffset(inputPort,delayOffsets);
  }
}","/** 
 * Calculate the delayOffset for each input port in the model, and annotate the ports with these offsets. This causality analysis usually happens at the preinitialize phase. <p> Start from each input port that is connected to the outside of the platform (These input ports indicate sensors and network interfaces, call them startPorts), and traverse the graph until we reach the output port connected to the outside of the platform (actuators/network ports). For each input port in between, annotate it with a delayOffset parameter. This parameter is an array of doubles, where each double corresponds to the minimum delay offset for a particular channel of that port. This minimum delay offset is used for the safe to process analysis. <p> Note: for all transparent composite actors, the delayOffsets are not calculated for their input ports. Instead, the offsets are calculated and annotated for input ports that are inside of these actors.
 * @exception IllegalActionException If failed to clear or calculate delayOffset,cannot check whether the current port is a network port, cannot get the network delay of the current port, cannot get the real time delay of the current port, cannot get remote receivers, or cannot get the port channel for a particular receiver.
 */
protected void _calculateDelayOffsets() throws IllegalActionException {
  _visitedActors=new HashSet<Actor>();
  _clearDelayOffsets();
  _inputModelTimeDelays=new HashMap<IOPort,Map<Integer,SuperdenseDependency>>();
  _portDelays=new HashMap<IOPort,SuperdenseDependency>();
  if (getContainer() instanceof TypedCompositeActor) {
    for (    Actor actor : (List<Actor>)(((TypedCompositeActor)getContainer()).deepEntityList())) {
      for (      TypedIOPort inputPort : (List<TypedIOPort>)(actor.inputPortList())) {
        _portDelays.put(inputPort,SuperdenseDependency.OPLUS_IDENTITY);
      }
      for (      TypedIOPort outputPort : (List<TypedIOPort>)(actor.outputPortList())) {
        _portDelays.put(outputPort,SuperdenseDependency.OPLUS_IDENTITY);
      }
    }
    for (    TypedIOPort inputPort : (List<TypedIOPort>)(((Actor)getContainer()).inputPortList())) {
      SuperdenseDependency startDelay;
      Double start=null;
      if (_isNetworkPort(inputPort)) {
        start=_getNetworkTotalDelay(inputPort);
        if (start != null) {
          start+=getAssumedSynchronizationErrorBound();
        }
 else {
          start=getAssumedSynchronizationErrorBound();
        }
      }
 else {
        start=_getRealTimeDelay(inputPort);
      }
      if (start == null) {
        start=0.0;
      }
      startDelay=SuperdenseDependency.valueOf(-start,0);
      _portDelays.put(inputPort,startDelay);
    }
    for (    TypedIOPort startPort : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).inputPortList())) {
      _traverseToCalcMinDelay(startPort);
    }
    for (    Actor actor : (List<Actor>)((CompositeActor)getContainer()).deepEntityList()) {
      if (!_visitedActors.contains(actor)) {
        for (        IOPort port : (List<IOPort>)actor.outputPortList()) {
          Receiver[][] remoteReceivers=port.getRemoteReceivers();
          for (int i=0; i < remoteReceivers.length; i++) {
            if (remoteReceivers[0] != null) {
              for (int j=0; j < remoteReceivers[i].length; j++) {
                Receiver receiver=remoteReceivers[i][j];
                IOPort receivePort=receiver.getContainer();
                int channel=receivePort.getChannelForReceiver(receiver);
                Map<Integer,SuperdenseDependency> channelDependency=(Map<Integer,SuperdenseDependency>)_inputModelTimeDelays.get(receivePort);
                if (channelDependency == null) {
                  channelDependency=new HashMap<Integer,SuperdenseDependency>();
                }
                channelDependency.put(Integer.valueOf(channel),SuperdenseDependency.OPLUS_IDENTITY);
                _inputModelTimeDelays.put(receivePort,channelDependency);
              }
            }
          }
        }
      }
    }
  }
  for (  IOPort inputPort : (Set<IOPort>)_inputModelTimeDelays.keySet()) {
    Map<Integer,SuperdenseDependency> channelDependency=(Map<Integer,SuperdenseDependency>)_inputModelTimeDelays.get(inputPort);
    int size=1;
    for (    Integer portChannelMinDelay : channelDependency.keySet()) {
      if (portChannelMinDelay.intValue() >= size) {
        size=portChannelMinDelay.intValue() + 1;
      }
    }
    double[] delayOffsets=new double[size];
    for (    Integer portChannelMinDelay : channelDependency.keySet()) {
      delayOffsets[portChannelMinDelay.intValue()]=_calculateMinDelayForPortChannel(inputPort,portChannelMinDelay);
    }
    _setDelayOffset(inputPort,delayOffsets);
  }
}"
73453,"/** 
 * Convert the platform to an oracle time based on the platform clock that is used. Call fireAt() of the executive director, which is in charge of keeping track of the simulated physical time.
 * @param wakeUpTime The time to wake up.
 * @exception IllegalActionException If cannot call fireAt of enclosingdirector, or if the oracle time is in the past, or cannot get the oracle time.
 */
protected void _fireAtPlatformTime(Time platformTime,int clockId) throws IllegalActionException {
  Actor container=(Actor)getContainer();
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  Time fireAtTime=_getOraclePhysicalTimeForPlatformPhysicalTime(platformTime,clockId);
  if (fireAtTime == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (clockId == PLATFORM_TIMER) {
    boolean fireAtTimeExists=false;
    if (_futurePlatformFireAtTimes.contains(fireAtTime)) {
      fireAtTimeExists=true;
    }
    if (!fireAtTimeExists) {
      _futurePlatformFireAtTimes.add(fireAtTime);
      Collections.sort(_futurePlatformFireAtTimes);
    }
  }
 else   if (clockId == EXECUTION_TIMER) {
    boolean fireAtTimeExists=false;
    if (_futureExecutionFireAtTimes.contains(fireAtTime)) {
      fireAtTimeExists=true;
    }
    if (!fireAtTimeExists) {
      _futureExecutionFireAtTimes.add(fireAtTime);
      Collections.sort(_futureExecutionFireAtTimes);
    }
  }
  Time temp=executiveDirector.fireAt((Actor)container,fireAtTime);
  if (temp.compareTo(fireAtTime) != 0) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + fireAtTime.toString() + ""String_Node_Str""+ temp.toString());
  }
}","/** 
 * Convert the platform to an oracle time based on the platform clock that is used. Call fireAt() of the executive director, which is in charge of keeping track of the simulated physical time.
 * @param platformTime a Time object indicate the future platform time to fire.
 * @param clockId an int specifying the ID of the clock.
 * @exception IllegalActionException If cannot call fireAt of enclosingdirector, or if the oracle time is in the past, or cannot get the oracle time.
 */
protected void _fireAtPlatformTime(Time platformTime,int clockId) throws IllegalActionException {
  Actor container=(Actor)getContainer();
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  Time fireAtTime=_getOraclePhysicalTimeForPlatformPhysicalTime(platformTime,clockId);
  if (fireAtTime == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (clockId == PLATFORM_TIMER) {
    boolean fireAtTimeExists=false;
    if (_futurePlatformFireAtTimes.contains(fireAtTime)) {
      fireAtTimeExists=true;
    }
    if (!fireAtTimeExists) {
      _futurePlatformFireAtTimes.add(fireAtTime);
      Collections.sort(_futurePlatformFireAtTimes);
    }
  }
 else   if (clockId == EXECUTION_TIMER) {
    boolean fireAtTimeExists=false;
    if (_futureExecutionFireAtTimes.contains(fireAtTime)) {
      fireAtTimeExists=true;
    }
    if (!fireAtTimeExists) {
      _futureExecutionFireAtTimes.add(fireAtTime);
      Collections.sort(_futureExecutionFireAtTimes);
    }
  }
  Time temp=executiveDirector.fireAt((Actor)container,fireAtTime);
  if (temp.compareTo(fireAtTime) != 0) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + fireAtTime.toString() + ""String_Node_Str""+ temp.toString());
  }
}"
73454,"/** 
 * Return the token (value) of this event.
 * @return The token.
 * @exception If event is not a pure event and token field is null.
 */
public final Token token(){
  if (!isPureEvent() && (_token == null)) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return _token;
}","/** 
 * Return the token (value) of this event.
 * @return The token.
 * @exception InternalErrorException If event is not a pure eventand token field is null.
 */
public final Token token(){
  if (!isPureEvent() && (_token == null)) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return _token;
}"
73455,"/** 
 * Set the ActorConstraintsDefinitionAttribute icon to be the same icon as that of the actor for which it is defining constraints.  The actor icon can be found either from an XML file that defines the actor icon, or its _iconDescription attribute.
 * @param actorClassNameString The fully qualified name of the class with its package prefix.
 * @param tempActorInstance A temporary instance of the actor from which its icon description attribute canbe taken.
 * @throws IllegalActionException If a problem occurs when trying to set the actor icon.
 */
private void _setActorIcon(String actorClassNameString,ComponentEntity tempActorInstance) throws IllegalActionException {
  String iconFile=actorClassNameString.replace('.','/') + ""String_Node_Str"";
  URL xmlFile=tempActorInstance.getClass().getClassLoader().getResource(iconFile);
  if (xmlFile != null) {
    try {
      MoMLParser parser=new MoMLParser(this.workspace());
      parser.setContext(this);
      parser.setContext(tempActorInstance);
      parser.parse(xmlFile,xmlFile);
      List<EditorIcon> tempActorIconList=tempActorInstance.attributeList(EditorIcon.class);
      if (!tempActorIconList.isEmpty()) {
        EditorIcon actorIcon=tempActorIconList.get(0);
        String actorIconMoML=actorIcon.exportMoML();
        MoMLVariableChecker momlChecker=new MoMLVariableChecker();
        String prependMoML=momlChecker.checkCopy(actorIconMoML,tempActorInstance,true);
        parser.setContext(this);
        parser.parse(prependMoML);
        parser.parse(actorIconMoML);
      }
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    ConfigurableAttribute actorIconAttribute=(ConfigurableAttribute)((ComponentEntity)tempActorInstance).getAttribute(""String_Node_Str"");
    if (actorIconAttribute != null) {
      String iconDescription=actorIconAttribute.getConfigureText();
      SingletonConfigurableAttribute description=(SingletonConfigurableAttribute)this.getAttribute(""String_Node_Str"");
      try {
        description.configure(null,null,iconDescription);
      }
 catch (      Exception ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
}","/** 
 * Set the ActorConstraintsDefinitionAttribute icon to be the same icon as that of the actor for which it is defining constraints.  The actor icon can be found either from an XML file that defines the actor icon, or its _iconDescription attribute.
 * @param actorClassNameString The fully qualified name of the class with its package prefix.
 * @param tempActorInstance A temporary instance of the actor from which its icon description attribute canbe taken.
 * @throws IllegalActionException If a problem occurs when trying to set the actor icon.
 */
private void _setActorIcon(String actorClassNameString,ComponentEntity tempActorInstance) throws IllegalActionException {
  String iconFile=actorClassNameString.replace('.','/') + ""String_Node_Str"";
  URL xmlFile=tempActorInstance.getClass().getClassLoader().getResource(iconFile);
  if (xmlFile != null) {
    try {
      MoMLParser parser=new MoMLParser(this.workspace());
      parser.setContext(this);
      parser.setContext(tempActorInstance);
      parser.parse(xmlFile,xmlFile);
      List<EditorIcon> tempActorIconList=tempActorInstance.attributeList(EditorIcon.class);
      if (!tempActorIconList.isEmpty()) {
        EditorIcon actorIcon=tempActorIconList.get(0);
        String actorIconMoML=actorIcon.exportMoML();
        MoMLVariableChecker momlChecker=new MoMLVariableChecker();
        String prependMoML=momlChecker.checkCopy(actorIconMoML,tempActorInstance,true);
        parser.setContext(this);
        if (prependMoML != null && !prependMoML.equals(""String_Node_Str"")) {
          parser.parse(prependMoML);
        }
        parser.parse(actorIconMoML);
      }
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    ConfigurableAttribute actorIconAttribute=(ConfigurableAttribute)((ComponentEntity)tempActorInstance).getAttribute(""String_Node_Str"");
    if (actorIconAttribute != null) {
      String iconDescription=actorIconAttribute.getConfigureText();
      SingletonConfigurableAttribute description=(SingletonConfigurableAttribute)this.getAttribute(""String_Node_Str"");
      try {
        description.configure(null,null,iconDescription);
      }
 catch (      Exception ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
}"
73456,"/** 
 * Set the ActorConstraintsDefinitionAttribute icon to be the same icon as that of the actor for which it is defining constraints.  The actor icon can be found either from an XML file that defines the actor icon, or its _iconDescription attribute.
 * @param actorClassNameString The fully qualified name of the class with its package prefix.
 * @param tempActorInstance A temporary instance of the actor from which its icon description attribute canbe taken.
 * @throws IllegalActionException If a problem occurs when trying to set the actor icon.
 */
private void _setActorIcon(String actorClassNameString,ComponentEntity tempActorInstance) throws IllegalActionException {
  String iconFile=actorClassNameString.replace('.','/') + ""String_Node_Str"";
  URL xmlFile=tempActorInstance.getClass().getClassLoader().getResource(iconFile);
  if (xmlFile != null) {
    try {
      MoMLParser parser=new MoMLParser(this.workspace());
      parser.setContext(this);
      parser.setContext(tempActorInstance);
      parser.parse(xmlFile,xmlFile);
      List<EditorIcon> tempActorIconList=tempActorInstance.attributeList(EditorIcon.class);
      if (!tempActorIconList.isEmpty()) {
        EditorIcon actorIcon=tempActorIconList.get(0);
        String actorIconMoML=actorIcon.exportMoML();
        MoMLVariableChecker momlChecker=new MoMLVariableChecker();
        String prependMoML=momlChecker.checkCopy(actorIconMoML,tempActorInstance,true);
        parser.setContext(this);
        if (prependMoML != null && !prependMoML.equals(""String_Node_Str"")) {
          parser.parse(prependMoML);
        }
        parser.parse(actorIconMoML);
      }
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    ConfigurableAttribute actorIconAttribute=(ConfigurableAttribute)((ComponentEntity)tempActorInstance).getAttribute(""String_Node_Str"");
    if (actorIconAttribute != null) {
      String iconDescription=actorIconAttribute.getConfigureText();
      SingletonConfigurableAttribute description=(SingletonConfigurableAttribute)this.getAttribute(""String_Node_Str"");
      try {
        description.configure(null,null,iconDescription);
      }
 catch (      Exception ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
}","/** 
 * Set the ActorConstraintsDefinitionAttribute icon to be the same icon as that of the actor for which it is defining constraints.  The actor icon can be found either from an XML file that defines the actor icon, or its _iconDescription attribute.
 * @param actorClassNameString The fully qualified name of the class with its package prefix.
 * @param tempActorInstance A temporary instance of the actor from which its icon description attribute canbe taken.
 * @throws IllegalActionException If a problem occurs when trying to set the actor icon.
 */
private void _setActorIcon(String actorClassNameString,ComponentEntity tempActorInstance) throws IllegalActionException {
  String iconFile=actorClassNameString.replace('.','/') + ""String_Node_Str"";
  URL xmlFile=tempActorInstance.getClass().getClassLoader().getResource(iconFile);
  if (xmlFile != null) {
    try {
      MoMLParser parser=new MoMLParser(this.workspace());
      parser.setContext(this);
      parser.setContext(tempActorInstance);
      parser.parse(xmlFile,xmlFile);
      List<EditorIcon> tempActorIconList=tempActorInstance.attributeList(EditorIcon.class);
      if (!tempActorIconList.isEmpty()) {
        EditorIcon actorIcon=tempActorIconList.get(0);
        String actorIconMoML=actorIcon.exportMoML();
        MoMLVariableChecker momlChecker=new MoMLVariableChecker();
        String prependMoML=momlChecker.checkCopy(actorIconMoML,tempActorInstance,true);
        StringBuffer iconMoML=new StringBuffer();
        iconMoML.append(""String_Node_Str"");
        iconMoML.append(prependMoML + actorIconMoML);
        iconMoML.append(""String_Node_Str"");
        parser.setContext(this);
        parser.parse(iconMoML.toString());
      }
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    ConfigurableAttribute actorIconAttribute=(ConfigurableAttribute)((ComponentEntity)tempActorInstance).getAttribute(""String_Node_Str"");
    if (actorIconAttribute != null) {
      String iconDescription=actorIconAttribute.getConfigureText();
      SingletonConfigurableAttribute description=(SingletonConfigurableAttribute)this.getAttribute(""String_Node_Str"");
      try {
        description.configure(null,null,iconDescription);
      }
 catch (      Exception ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
}"
73457,"/** 
 * Run concept inference and save the inferred concept values. For values that are correctly resolved to a non-null concept, a string representation of the concept is stored in the <i>_trainedConcept</i> attribute of the NamedObj.  For values that resolve to null, nothing is recorded.
 * @exception IllegalActionException If inference fails..
 */
public void train() throws IllegalActionException {
  try {
    workspace().getWriteAccess();
    invokeSolver();
    for (    NamedObj conceptable : getAllConceptableNamedObjs()) {
      Concept inferred=getConcept(conceptable);
      if (inferred == null) {
        continue;
      }
      StringParameter trained;
      try {
        trained=new StringParameter(conceptable,""String_Node_Str"");
      }
 catch (      NameDuplicationException e) {
        trained=(StringParameter)conceptable.getAttribute(""String_Node_Str"");
      }
      trained.setExpression(inferred.toString());
    }
  }
  finally {
    workspace().doneWriting();
  }
}","/** 
 * Run concept inference and save the inferred concept values. For values that are correctly resolved to a non-null concept, a string representation of the concept is stored in the <i>_trainedConcept</i> attribute of the NamedObj.  For values that resolve to null, nothing is recorded.
 * @exception IllegalActionException If inference fails..
 */
public void train() throws IllegalActionException {
  try {
    workspace().getWriteAccess();
    invokeSolver();
    Set<NamedObj> allNamedObjs=getAllConceptableNamedObjs();
    for (    NamedObj conceptable : allNamedObjs) {
      Concept inferred=getConcept(conceptable);
      if (inferred == null) {
        continue;
      }
      StringParameter trained;
      try {
        trained=new StringParameter(conceptable,""String_Node_Str"");
      }
 catch (      NameDuplicationException e) {
        trained=(StringParameter)conceptable.getAttribute(""String_Node_Str"");
      }
      trained.setExpression(inferred.toString());
      trained.getToken();
    }
  }
  finally {
    workspace().doneWriting();
  }
}"
73458,"/** 
 * Return the list of lattice ontologies that comprise the product lattice ontology.
 * @return The list of lattice ontology objects.
 * @throws IllegalActionException If the latticeOntologies parameter doesnot return an array token that contains the ontology objects, or at least one of the specified component ontologies is not a lattice.
 */
public List<Ontology> getLatticeOntologies() throws IllegalActionException {
  if (workspace().getVersion() != _latticeVersion) {
    ArrayToken ontologies=(ArrayToken)latticeOntologies.getToken();
    if (ontologies != null && ontologies.length() != 0) {
      Token[] ontologiesTokenArray=(Token[])ontologies.arrayValue();
      List<Ontology> ontologiesList=new ArrayList<Ontology>();
      for (int i=0; i < ontologiesTokenArray.length; i++) {
        Ontology ontology=(Ontology)((ObjectToken)ontologiesTokenArray[i]).getValue();
        if (ontology != null) {
          if (ontology.isLattice()) {
            ontologiesList.add(ontology);
          }
 else {
            throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + ontology.getName() + ""String_Node_Str"");
          }
        }
      }
      _latticeOntologies=ontologiesList;
    }
 else {
      _latticeOntologies=null;
    }
    _latticeVersion=workspace().getVersion();
  }
  return _latticeOntologies;
}","/** 
 * Return the list of lattice ontologies that comprise the product lattice ontology.
 * @return The list of lattice ontology objects.
 * @throws IllegalActionException If the latticeOntologies parameter doesnot return an array token that contains the ontology objects, or at least one of the specified component ontologies is not a lattice.
 */
public List<Ontology> getLatticeOntologies() throws IllegalActionException {
  if (workspace().getVersion() != _latticeVersion) {
    ArrayToken ontologies=(ArrayToken)latticeOntologies.getToken();
    List<Ontology> ontologiesList=new ArrayList<Ontology>();
    if (ontologies != null && ontologies.length() != 0) {
      Token[] ontologiesTokenArray=(Token[])ontologies.arrayValue();
      for (int i=0; i < ontologiesTokenArray.length; i++) {
        Ontology ontology=(Ontology)((ObjectToken)ontologiesTokenArray[i]).getValue();
        if (ontology != null) {
          if (ontology.isLattice()) {
            ontologiesList.add(ontology);
          }
 else {
            throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + ontology.getName() + ""String_Node_Str"");
          }
        }
      }
    }
    _latticeOntologies=ontologiesList;
    _latticeVersion=workspace().getVersion();
  }
  return _latticeOntologies;
}"
73459,"/** 
 * Construct a Bus with a name and a container. The container argument must not be null, or a NullPointerException will be thrown.  This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public Bus(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _tokens=new FIFOQueue();
  serviceTime=new Parameter(this,""String_Node_Str"");
  serviceTime.setExpression(""String_Node_Str"");
  serviceTime.setTypeEquals(BaseType.DOUBLE);
}","/** 
 * Construct a Bus with a name and a container. The container argument must not be null, or a NullPointerException will be thrown.  This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public Bus(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _tokens=new FIFOQueue();
  _receiversAndTokensToSendTo=new HashMap();
  serviceTime=new Parameter(this,""String_Node_Str"");
  serviceTime.setExpression(""String_Node_Str"");
  serviceTime.setTypeEquals(BaseType.DOUBLE);
}"
73460,"/** 
 * If there are still tokens in the queue and a token has been produced in the fire,  schedule a refiring.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree != null && _tokens.size() > 0 && currentTime.compareTo(_nextTimeFree) == 0) {
    _tokens.take();
    if (_tokens.size() > 0) {
      _nextTimeFree=currentTime.add(_serviceTimeValue);
      _nextReceiver=(Receiver)((Object[])_tokens.get(0))[0];
      _fireAt(_nextTimeFree);
    }
  }
  if (_tokenToSend != null) {
    _tokens.put(new Object[]{_receiverToSendTo,_tokenToSend});
    _tokenToSend=null;
    _receiverToSendTo=null;
    if (_tokens.size() == 1) {
      _nextTimeFree=currentTime.add(_serviceTimeValue);
      _nextReceiver=_receiverToSendTo;
      _fireAt(_nextTimeFree);
    }
  }
  return super.postfire();
}","/** 
 * If there are still tokens in the queue and a token has been produced in the fire,  schedule a refiring.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree != null && _tokens.size() > 0 && currentTime.compareTo(_nextTimeFree) == 0) {
    _tokens.take();
    if (_tokens.size() > 0) {
      _nextTimeFree=currentTime.add(_serviceTimeValue);
      _nextReceiver=(Receiver)((Object[])_tokens.get(0))[0];
      _fireAt(_nextTimeFree);
    }
  }
  if (_receiversAndTokensToSendTo != null) {
    for (    Receiver receiver : _receiversAndTokensToSendTo.keySet()) {
      Token token=_receiversAndTokensToSendTo.get(receiver);
      if (token != null) {
        _tokens.put(new Object[]{receiver,token});
      }
    }
    _receiversAndTokensToSendTo.clear();
    if (_tokens.size() == 1) {
      _nextTimeFree=currentTime.add(_serviceTimeValue);
      _nextReceiver=(Receiver)((Object[])_tokens.get(0))[0];
      _fireAt(_nextTimeFree);
    }
  }
  return super.postfire();
}"
73461,"/** 
 * Initialize the actor.
 * @throws IllegalActionException If the superclass throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _tokenToSend=null;
  _receiverToSendTo=null;
}","/** 
 * Initialize the actor.
 * @throws IllegalActionException If the superclass throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _receiversAndTokensToSendTo.clear();
}"
73462,"/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor if there is not one already scheduled.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @throws IllegalActionException If the refiring request fails.
 */
public void sendToken(Receiver receiver,Token token) throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree == null || _tokens.size() == 0 || currentTime.compareTo(_nextTimeFree) != 0 || receiver != _nextReceiver) {
    receiver.put(null);
  }
  if (_tokenToSend != null) {
    if (!_tokenToSend.equals(token)) {
      throw new IllegalActionException(this,receiver.getContainer(),""String_Node_Str"" + _tokenToSend + ""String_Node_Str""+ token+ ""String_Node_Str"");
    }
  }
  _tokenToSend=token;
  _receiverToSendTo=receiver;
  if (token == null) {
    return;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime() + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
  }
}","/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor if there is not one already scheduled.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @throws IllegalActionException If the refiring request fails.
 */
public void sendToken(Receiver receiver,Token token) throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree == null || _tokens.size() == 0 || currentTime.compareTo(_nextTimeFree) != 0 || receiver != _nextReceiver) {
    receiver.put(null);
  }
  Token tokenToSend=_receiversAndTokensToSendTo.get(receiver);
  if (tokenToSend != null) {
    if (!tokenToSend.equals(token)) {
      throw new IllegalActionException(this,receiver.getContainer(),""String_Node_Str"" + tokenToSend + ""String_Node_Str""+ token+ ""String_Node_Str"");
    }
  }
 else {
    _receiversAndTokensToSendTo.put(receiver,token);
  }
  if (token == null) {
    return;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime() + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
  }
}"
73463,"/** 
 * Send first token in the queue to the target receiver.
 */
public void fire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree != null && _tokens.size() > 0 && currentTime.compareTo(_nextTimeFree) == 0) {
    Object[] output=(Object[])_tokens.get(0);
    Receiver receiver=(Receiver)output[0];
    Token token=(Token)output[1];
    receiver.put(token);
    if (_debugging) {
      _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
    }
  }
}","/** 
 * Send first token in the queue to the target receiver.
 */
public void fire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree != null && _tokens.size() > 0 && currentTime.compareTo(_nextTimeFree) == 0) {
    Object[] output=(Object[])_tokens.get(0);
    Receiver receiver=(Receiver)output[0];
    Token token=(Token)output[1];
    receiver.put(token);
    if (!(receiver instanceof IntermediateReceiver)) {
      Actor container=(Actor)receiver.getContainer().getContainer();
      if (receiver.getContainer().isOutput()) {
        while (container instanceof CompositeActor) {
          Iterator<?> outports=container.outputPortList().iterator();
          while (outports.hasNext()) {
            IOPort p=(IOPort)outports.next();
            container.getDirector().transferOutputs(p);
          }
          container=(Actor)container.getContainer();
        }
      }
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
    }
  }
}"
73464,"/** 
 * Send first token in the queue to the target receiver.
 */
public void fire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree != null && _tokens.size() > 0 && currentTime.compareTo(_nextTimeFree) == 0) {
    Object[] output=(Object[])_tokens.get(0);
    Receiver receiver=(Receiver)output[0];
    Token token=(Token)output[1];
    receiver.put(token);
    if (!(receiver instanceof IntermediateReceiver)) {
      Actor container=(Actor)receiver.getContainer().getContainer();
      if (receiver.getContainer().isOutput()) {
        while (container instanceof CompositeActor) {
          Iterator<?> outports=container.outputPortList().iterator();
          while (outports.hasNext()) {
            IOPort p=(IOPort)outports.next();
            container.getDirector().transferOutputs(p);
          }
          container=(Actor)container.getContainer();
        }
      }
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
    }
  }
}","/** 
 * Send first token in the queue to the target receiver.
 */
public void fire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree != null && _tokens.size() > 0 && currentTime.compareTo(_nextTimeFree) == 0) {
    Object[] output=(Object[])_tokens.get(0);
    Receiver receiver=(Receiver)output[0];
    Token token=(Token)output[1];
    if (receiver.isKnown() && !receiver.hasToken()) {
      receiver.reset();
    }
    if (!(receiver instanceof IntermediateReceiver)) {
      Actor container=(Actor)receiver.getContainer().getContainer();
      if (receiver.getContainer().isOutput()) {
        receiver.put(token);
        ((Actor)container.getContainer()).getDirector().fireAt(container,currentTime);
      }
 else {
        if (receiver.getContainer().isInput()) {
          ((Actor)container.getContainer()).getDirector().fireAt(container,currentTime);
          receiver.put(token);
          ((Actor)container.getContainer()).getDirector().fireAt(container,currentTime);
        }
      }
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
    }
  }
}"
73465,"/** 
 * Return a new time object whose time value is the sum of that of this time object and of the specified time object. The two time objects are expected to have directors with the same time resolution. If they do not, then the returned result is a new Time object representing the sum of the double values of the two Time objects. This would not be as accurate. If either Time object has a non-null remainder term, then the resulting Time would find the sum of the remainder terms. If the sum of two fractions results in, for example 3/3, then the remainder term is set to null, and the integer term is incremented by 1.
 * @param time The time object contains the amount of time increment.
 * @return A new time object with the quantized and incremented time value.
 * @exception ArithmeticException If the result is not a valid number(it is the sum of positive and negative infinity).
 */
public Time add(Time time){
  if (time._isNegativeInfinite) {
    if (_isPositiveInfinite) {
      throw new ArithmeticException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      return NEGATIVE_INFINITY;
    }
  }
 else   if (time._isPositiveInfinite) {
    if (_isNegativeInfinite) {
      throw new ArithmeticException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      return POSITIVE_INFINITY;
    }
  }
 else   if (isInfinite()) {
    return this;
  }
  try {
    double resolution=_timeResolution();
    if (resolution != time._timeResolution()) {
      double thisValue=getDoubleValue();
      double thatValue=time.getDoubleValue();
      return new Time(_director,thisValue + thatValue);
    }
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e);
  }
  if (!hasRemainder() && !time.hasRemainder()) {
    return new Time(_director,_timeValue.add(time._timeValue),null,null);
  }
 else   if (hasRemainder() && !time.hasRemainder()) {
    return new Time(_director,_timeValue.add(time._timeValue),_divisorAndRemainder[0],_divisorAndRemainder[1]);
  }
 else   if (!hasRemainder() && time.hasRemainder()) {
    return new Time(_director,_timeValue.add(time._timeValue),time._divisorAndRemainder[0],time._divisorAndRemainder[1]);
  }
 else {
    BigInteger gcd=_divisorAndRemainder[0].gcd(time._divisorAndRemainder[0]);
    BigInteger lcm=_divisorAndRemainder[0].multiply(time._divisorAndRemainder[0]).divide(gcd);
    BigInteger factor1=lcm.divide(_divisorAndRemainder[0]);
    BigInteger factor2=lcm.divide(time._divisorAndRemainder[0]);
    _divisorAndRemainder[1]=_divisorAndRemainder[1].multiply(factor1);
    time._divisorAndRemainder[1]=time._divisorAndRemainder[1].multiply(factor2);
    return new Time(_director,_timeValue.add(time._timeValue),lcm,_divisorAndRemainder[1].add(time._divisorAndRemainder[1]));
  }
}","/** 
 * Return a new time object whose time value is the sum of that of this time object and of the specified time object. The two time objects are expected to have directors with the same time resolution. If they do not, then the returned result is a new Time object representing the sum of the double values of the two Time objects. This would not be as accurate. If either Time object has a non-null remainder term, then the resulting Time would find the sum of the remainder terms. If the sum of two fractions results in, for example 3/3, then the remainder term is set to null, and the integer term is incremented by 1.
 * @param time The time object contains the amount of time increment.
 * @return A new time object with the quantized and incremented time value.
 * @exception ArithmeticException If the result is not a valid number(it is the sum of positive and negative infinity).
 */
public Time add(Time time){
  if (time._isNegativeInfinite) {
    if (_isPositiveInfinite) {
      throw new ArithmeticException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      return NEGATIVE_INFINITY;
    }
  }
 else   if (time._isPositiveInfinite) {
    if (_isNegativeInfinite) {
      throw new ArithmeticException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      return POSITIVE_INFINITY;
    }
  }
 else   if (isInfinite()) {
    return this;
  }
  try {
    double resolution=_timeResolution();
    if (resolution != time._timeResolution()) {
      double thisValue=getDoubleValue();
      double thatValue=time.getDoubleValue();
      return new Time(_director,thisValue + thatValue);
    }
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e);
  }
  if (!hasRemainder() && !time.hasRemainder()) {
    return new Time(_director,_timeValue.add(time._timeValue),null,null);
  }
 else   if (hasRemainder() && !time.hasRemainder()) {
    return new Time(_director,_timeValue.add(time._timeValue),_divisorAndRemainder[0],_divisorAndRemainder[1]);
  }
 else   if (!hasRemainder() && time.hasRemainder()) {
    return new Time(_director,_timeValue.add(time._timeValue),time._divisorAndRemainder[0],time._divisorAndRemainder[1]);
  }
 else {
    BigInteger gcd=_divisorAndRemainder[0].gcd(time._divisorAndRemainder[0]);
    BigInteger lcm=_divisorAndRemainder[0].multiply(time._divisorAndRemainder[0]).divide(gcd);
    BigInteger factor1=lcm.divide(_divisorAndRemainder[0]);
    BigInteger factor2=lcm.divide(time._divisorAndRemainder[0]);
    BigInteger temp1=_divisorAndRemainder[1].multiply(factor1);
    BigInteger temp2=time._divisorAndRemainder[1].multiply(factor2);
    return new Time(_director,_timeValue.add(time._timeValue),lcm,temp1.add(temp2));
  }
}"
73466,"/** 
 * Given original fireAt times, and a realTime clock with updated clock drift, create a new list of fireAt times. Also add the old fireAt times into the list of ignored fireAt times.
 * @param originalFireAtTimes The original fireAt times.
 * @param ignoreFireAtTimes The list of ignored fireAt times.
 * @param realTimeClock The real time clock whose clock drift has changed.
 * @return The new list of fireAt times.
 * @exception IllegalActionException If either the original or updated fireAttime is in the past.
 */
private List<?> _updateFireAtTimes(List<?> originalFireAtTimes,List<Time> ignoreFireAtTimes,RealTimeClock realTimeClock,Time newClockDrift) throws IllegalActionException {
  List<Time> newFireAtTimes=new LinkedList<Time>();
  for (  Object originalFireAt : originalFireAtTimes) {
    Time originalFireAtTime=null;
    if (originalFireAt instanceof Time) {
      originalFireAtTime=(Time)originalFireAt;
    }
 else     if (originalFireAt instanceof TimedEvent) {
      originalFireAtTime=((TimedEvent)originalFireAt).timeStamp;
    }
 else {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (originalFireAtTime.compareTo(realTimeClock._lastOracleTime) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + originalFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ realTimeClock._lastOracleTime.toString());
    }
    if (originalFireAtTime.compareTo(_getOraclePhysicalTag().timestamp) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + originalFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ _getOraclePhysicalTag().timestamp.toString());
    }
    Time clockDriftDiff=newClockDrift.subtract(realTimeClock._clockDrift);
    Time temp1=(realTimeClock._lastOracleTime.multiply(clockDriftDiff)).divide(newClockDrift);
    Time temp2=(originalFireAtTime.multiply(realTimeClock._clockDrift)).divide(newClockDrift);
    Time newFireAtTime=temp1.add(temp2);
    if (newFireAtTime.compareTo(realTimeClock._lastOracleTime) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + newFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ realTimeClock._lastOracleTime.toString());
    }
    if (newFireAtTime.compareTo(_getOraclePhysicalTag().timestamp) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + newFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ _getOraclePhysicalTag().timestamp.toString());
    }
    newFireAtTimes.add(newFireAtTime);
    if (ignoreFireAtTimes != null) {
      ignoreFireAtTimes.add(originalFireAtTime);
    }
  }
  Collections.sort(newFireAtTimes);
  if (ignoreFireAtTimes != null) {
    Collections.sort(ignoreFireAtTimes);
  }
  return newFireAtTimes;
}","/** 
 * Given original fireAt times, and a realTime clock with updated clock drift, create a new list of fireAt times. Also add the old fireAt times into the list of ignored fireAt times.
 * @param originalFireAtTimes The original fireAt times.
 * @param ignoreFireAtTimes The list of ignored fireAt times.
 * @param realTimeClock The real time clock whose clock drift has changed.
 * @return The new list of fireAt times.
 * @exception IllegalActionException If either the original or updated fireAttime is in the past.
 */
private List<?> _updateFireAtTimes(List<?> originalFireAtTimes,List<Time> ignoreFireAtTimes,RealTimeClock realTimeClock,Time newClockDrift) throws IllegalActionException {
  List<Time> newFireAtTimes=new LinkedList<Time>();
  Actor container=(Actor)getContainer();
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  for (  Object originalFireAt : originalFireAtTimes) {
    Time originalFireAtTime=null;
    if (originalFireAt instanceof Time) {
      originalFireAtTime=(Time)originalFireAt;
    }
 else     if (originalFireAt instanceof TimedEvent) {
      originalFireAtTime=((TimedEvent)originalFireAt).timeStamp;
    }
 else {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (originalFireAtTime.compareTo(realTimeClock._lastOracleTime) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + originalFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ realTimeClock._lastOracleTime.toString());
    }
    if (originalFireAtTime.compareTo(_getOraclePhysicalTag().timestamp) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + originalFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ _getOraclePhysicalTag().timestamp.toString());
    }
    Time clockDriftDiff=newClockDrift.subtract(realTimeClock._clockDrift);
    Time temp1=(realTimeClock._lastOracleTime.multiply(clockDriftDiff)).divide(newClockDrift);
    Time temp2=(originalFireAtTime.multiply(realTimeClock._clockDrift)).divide(newClockDrift);
    Time newFireAtTime=temp1.add(temp2);
    if (newFireAtTime.compareTo(realTimeClock._lastOracleTime) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + newFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ realTimeClock._lastOracleTime.toString());
    }
    if (newFireAtTime.compareTo(_getOraclePhysicalTag().timestamp) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + newFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ _getOraclePhysicalTag().timestamp.toString());
    }
    newFireAtTimes.add(newFireAtTime);
    Time temp=executiveDirector.fireAt((Actor)container,newFireAtTime);
    if (temp.compareTo(newFireAtTime) != 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + newFireAtTime.toString() + ""String_Node_Str""+ temp.toString());
    }
    if (ignoreFireAtTimes != null) {
      ignoreFireAtTimes.add(originalFireAtTime);
    }
  }
  Collections.sort(newFireAtTimes);
  if (ignoreFireAtTimes != null) {
    Collections.sort(ignoreFireAtTimes);
  }
  return newFireAtTimes;
}"
73467,"/** 
 * Divide this Time by the other Time object, and produce a new Time object as a result. If the dividend (this Time structure) is a perfect multiple of the time resolution, then the divideAndRemainder method of BigInteger is used, with the quotient as the new _timeValue. If the method returned a non-zero remainder, the divisor and remainder values are saved in the new Time structure. <p> If the dividend already has a non-null divisor and remainder fields, then we need to represent the final result of the division in a non-null divisor and remainder. The final representation is as follows: let q1 be the quotient, b be the divisor, and r1 be the remainder of this time structure (the dividend time structure). Let c be the divisor, let q2 be q1/c, let r2 be q1%c, then the final result can be represented as: q2 + (r1 + r2*b) / (b*c). In other words, the returned Time structure would have _timeValue = q2 + (r1 + r2*b) / (b*c), while the divisor would be b*c, and remainder would be (r1 + r2*b) % (b*c).
 * @param dividend The dividend of this division.
 * @param resolutionInverse The inverse of the time resolution
 * @param divisor The divisor of this divisor.
 * @return a new Time structure of the division.
 */
private Time _divide(BigInteger resolutionInverse,Time time){
  if (_divisorAndRemainder == null && time._divisorAndRemainder == null) {
    return _bigIntegerDivideByBigInteger(_timeValue,time._timeValue,resolutionInverse);
  }
 else   if (_divisorAndRemainder != null && time._divisorAndRemainder == null) {
    return _timeDivideByBigInteger(this,time._timeValue,resolutionInverse);
  }
 else   if (_divisorAndRemainder == null && time._divisorAndRemainder != null) {
    BigInteger divisor=time._timeValue.multiply(time._divisorAndRemainder[0].divide(resolutionInverse).add(time._divisorAndRemainder[1]));
    return _bigIntegerDivideByBigInteger(_timeValue.multiply(time._divisorAndRemainder[0]),divisor,resolutionInverse);
  }
 else {
    BigInteger divisor=time._timeValue.multiply(time._divisorAndRemainder[0].divide(resolutionInverse).add(time._divisorAndRemainder[1]));
    Time dividend=this.multiply(new Time(_director,time._divisorAndRemainder[0],null,null));
    return _timeDivideByBigInteger(dividend,divisor,resolutionInverse);
  }
}","/** 
 * Divide this Time by the other Time object, and produce a new Time object as a result. If the dividend (this Time structure) is a perfect multiple of the time resolution, then the divideAndRemainder method of BigInteger is used, with the quotient as the new _timeValue. If the method returned a non-zero remainder, the divisor and remainder values are saved in the new Time structure. <p> If the dividend already has a non-null divisor and remainder fields, then we need to represent the final result of the division in a non-null divisor and remainder. The final representation is as follows: let q1 be the quotient, b be the divisor, and r1 be the remainder of this time structure (the dividend time structure). Let c be the divisor, let q2 be q1/c, let r2 be q1%c, then the final result can be represented as: q2 + (r1 + r2*b) / (b*c). In other words, the returned Time structure would have _timeValue = q2 + (r1 + r2*b) / (b*c), while the divisor would be b*c, and remainder would be (r1 + r2*b) % (b*c).
 * @param dividend The dividend of this division.
 * @param resolutionInverse The inverse of the time resolution
 * @param divisor The divisor of this divisor.
 * @return a new Time structure of the division.
 */
private Time _divide(BigInteger resolutionInverse,Time time){
  if (_divisorAndRemainder == null && time._divisorAndRemainder == null) {
    return _bigIntegerDivideByBigInteger(_timeValue,time._timeValue,resolutionInverse);
  }
 else   if (_divisorAndRemainder != null && time._divisorAndRemainder == null) {
    return _timeDivideByBigInteger(this,time._timeValue,resolutionInverse);
  }
 else   if (_divisorAndRemainder == null && time._divisorAndRemainder != null) {
    BigInteger divisor=time._timeValue.multiply(time._divisorAndRemainder[0]).add(time._divisorAndRemainder[1]);
    return _bigIntegerDivideByBigInteger(_timeValue.multiply(time._divisorAndRemainder[0]),divisor,resolutionInverse);
  }
 else {
    BigInteger divisor=time._timeValue.multiply(time._divisorAndRemainder[0]).add(time._divisorAndRemainder[1]);
    Time dividend=this.multiply(time._divisorAndRemainder[0].doubleValue());
    if (dividend._divisorAndRemainder == null) {
      return _bigIntegerDivideByBigInteger(dividend._timeValue,divisor,resolutionInverse);
    }
    return _timeDivideByBigInteger(dividend,divisor,resolutionInverse);
  }
}"
73468,"/** 
 * Multiplies this object with another Time object. The formula for multiplying two Times with fraction parts are described as follows: To find X * Y, where X = q1 + r1/b, and Y = q2 + r2/d, X * Y can be written as: q1*q2 + (r1*q2*d + r2*q1*b + r1*r2) / (b*d), where all variables in this equation are BigIntegers, and the result is a new Time object that retains the arbitrary precision. By default, r1 and r2 are initialized to be zero, while b and d are initialized to be one. These values are used if the fraction part of either this object or the other Time object is null. However if either of them are not null, then r1, r2, b, and d are overwritten. The final Time is calculated according to the above equation.
 * @param resolutionInverse The inverse of the resolution.
 * @param time The other Time object
 * @return A new Time object that is the multple of this Time andthe other Time object.
 */
private Time _multiply(BigInteger resolutionInverse,Time time){
  BigInteger d=BigInteger.ONE;
  BigInteger b=BigInteger.ONE;
  BigInteger r1=BigInteger.ZERO;
  BigInteger r2=BigInteger.ZERO;
  if (_divisorAndRemainder != null) {
    b=_divisorAndRemainder[0];
    r1=_divisorAndRemainder[1];
  }
  if (time._divisorAndRemainder != null) {
    d=time._divisorAndRemainder[0];
    r2=time._divisorAndRemainder[1];
  }
  BigInteger temp1=r1.multiply(time._timeValue).multiply(d).divide(resolutionInverse);
  BigInteger temp2=r2.multiply(_timeValue).multiply(b).divide(resolutionInverse);
  BigInteger temp3=r1.multiply(r2);
  BigInteger newDivisor=b.multiply(d);
  BigInteger temp4=temp1.add(temp2).add(temp3);
  BigInteger q_r[]=temp4.divideAndRemainder(newDivisor);
  return new Time(_director,_timeValue.multiply(time._timeValue).divide(resolutionInverse).add(q_r[0]),newDivisor,q_r[1]);
}","/** 
 * Multiplies this object with another Time object. The formula for multiplying two Times with fraction parts are described as follows: To find X * Y, where X = q1 + r1/b, and Y = q2 + r2/d, X * Y can be written as: q1*q2 + (r1*q2*d + r2*q1*b + r1*r2) / (b*d), where all variables in this equation are BigIntegers, and the result is a new Time object that retains the arbitrary precision. By default, r1 and r2 are initialized to be zero, while b and d are initialized to be one. These values are used if the fraction part of either this object or the other Time object is null. However if either of them are not null, then r1, r2, b, and d are overwritten. The final Time is calculated according to the above equation.
 * @param resolutionInverse The inverse of the resolution.
 * @param time The other Time object
 * @return A new Time object that is the multiple of this Time andthe other Time object.
 */
private Time _multiply(BigInteger resolutionInverse,Time time){
  BigInteger d=BigInteger.ONE;
  BigInteger b=BigInteger.ONE;
  BigInteger r1=BigInteger.ZERO;
  BigInteger r2=BigInteger.ZERO;
  if (_divisorAndRemainder != null) {
    b=_divisorAndRemainder[0];
    r1=_divisorAndRemainder[1];
  }
  if (time._divisorAndRemainder != null) {
    d=time._divisorAndRemainder[0];
    r2=time._divisorAndRemainder[1];
  }
  BigInteger temp1=r1.multiply(time._timeValue).multiply(d);
  BigInteger temp2=r2.multiply(_timeValue).multiply(b);
  BigInteger temp3=r1.multiply(r2);
  BigInteger newDivisor=b.multiply(d);
  BigInteger temp4=temp1.add(temp2).add(temp3);
  BigInteger q_r[]=temp4.divideAndRemainder(newDivisor);
  return new Time(_director,_timeValue.multiply(time._timeValue).add(q_r[0]).divide(resolutionInverse),newDivisor,q_r[1]);
}"
73469,"/** 
 * Divide a Time object by another BigInterger. Produces a new Time object. The Time object (the dividend, must not have a null _divisorAndRemainder term.
 * @param dividendTime The dividend.
 * @param divisor The divisor.
 * @param resolutionInverse The inverse of the resolution.
 * @return A new Time object.
 */
private Time _timeDivideByBigInteger(Time dividendTime,BigInteger divisor,BigInteger resolutionInverse){
  assert(dividendTime._divisorAndRemainder != null);
  BigInteger dividend=dividendTime._timeValue.multiply(resolutionInverse);
  BigInteger[] q_r=dividend.divideAndRemainder(divisor);
  BigInteger dividend2=q_r[1].multiply(dividendTime._divisorAndRemainder[0]).add(dividendTime._divisorAndRemainder[1]);
  BigInteger divisor2=dividendTime._divisorAndRemainder[0].multiply(divisor);
  BigInteger[] q_r2=dividend2.divideAndRemainder(_divisorAndRemainder[0]);
  assert(q_r2[1].compareTo(BigInteger.ZERO) != 0);
  return new Time(_director,q_r[0].add(q_r2[0]),divisor2,q_r2[1]);
}","/** 
 * Divide a Time object by another BigInterger. Produces a new Time object. The Time object (the dividend), must not have a null _divisorAndRemainder term.
 * @param dividendTime The dividend.
 * @param divisor The divisor.
 * @param resolutionInverse The inverse of the resolution.
 * @return A new Time object.
 */
private Time _timeDivideByBigInteger(Time dividendTime,BigInteger divisor,BigInteger resolutionInverse){
  assert(dividendTime._divisorAndRemainder != null);
  BigInteger dividend=dividendTime._timeValue.multiply(resolutionInverse);
  BigInteger[] q_r=dividend.divideAndRemainder(divisor);
  BigInteger dividend2=q_r[1].multiply(dividendTime._divisorAndRemainder[0]).add(dividendTime._divisorAndRemainder[1].multiply(resolutionInverse));
  BigInteger divisor2=dividendTime._divisorAndRemainder[0].multiply(divisor);
  BigInteger[] q_r2=dividend2.divideAndRemainder(divisor2);
  assert(q_r2[1].compareTo(BigInteger.ZERO) != 0);
  return new Time(_director,q_r[0].add(q_r2[0]),divisor2,q_r2[1]);
}"
73470,"public void managerStateChanged(Manager manager){
  if (manager.getState() == Manager.PREINITIALIZING) {
    MoMLParser.addMoMLFilter(filter);
    _isModified=MoMLParser.isModified();
    try {
      _lastUndoStack.setContainer(container);
      _lastUndoStack.moveToFirst();
    }
 catch (    KernelException e) {
      e.printStackTrace();
    }
  }
 else   if (manager.getState() == Manager.IDLE) {
    MoMLParser.getMoMLFilters().remove(filter);
    MoMLParser.setModified(_isModified);
    _lastUndoStack=undoStack;
    try {
      undoStack.setContainer(null);
    }
 catch (    KernelException e) {
    }
    attribute.removeExecutionListener(this);
  }
}","@Override public void managerStateChanged(Manager manager){
  if (manager.getState() == Manager.PREINITIALIZING) {
    MoMLParser.addMoMLFilter(filter);
    _isModified=MoMLParser.isModified();
    try {
      _lastUndoStack.setContainer(container);
      _lastUndoStack.moveToFirst();
    }
 catch (    KernelException e) {
      e.printStackTrace();
    }
  }
 else   if (manager.getState() == Manager.IDLE) {
    MoMLParser.getMoMLFilters().remove(filter);
    MoMLParser.setModified(_isModified);
    _lastUndoStack=undoStack;
    try {
      undoStack.setContainer(null);
    }
 catch (    KernelException e) {
    }
    attribute.removeExecutionListener(this);
  }
}"
73471,"public void executionFinished(Manager manager){
}","@Override public void executionFinished(Manager manager){
}"
73472,"/** 
 * React to change of an attribute and update the container of this importer.
 * @param settable The attribute changed.
 */
public void valueChanged(Settable settable){
  update();
}","/** 
 * React to change of an attribute and update the container of this importer.
 * @param settable The attribute changed.
 */
@Override public void valueChanged(Settable settable){
  update();
}"
73473,"/** 
 * Set the created element to be non-persistent.
 * @param container The object defined by the element that thisis the end of.
 * @param elementName The element name.
 * @param currentCharData The character data, which appearsonly in the doc and configure elements
 * @param xmlFile The file currently being parsed.
 * @exception Exception Not thrown in this class.
 */
public void filterEndElement(NamedObj container,String elementName,StringBuffer currentCharData,String xmlFile) throws Exception {
  if (container != null && !""String_Node_Str"".equals(elementName)) {
    NamedObj context=getContainer();
    NamedObj parent=container;
    while (parent != null && parent != context) {
      parent=parent.getContainer();
    }
    if (parent == context && container != context) {
      container.setPersistent(false);
    }
  }
}","/** 
 * Set the created element to be non-persistent.
 * @param container The object defined by the element that thisis the end of.
 * @param elementName The element name.
 * @param currentCharData The character data, which appearsonly in the doc and configure elements
 * @param xmlFile The file currently being parsed.
 * @exception Exception Not thrown in this class.
 */
@Override public void filterEndElement(NamedObj container,String elementName,StringBuffer currentCharData,String xmlFile) throws Exception {
  if (container != null && !""String_Node_Str"".equals(elementName)) {
    NamedObj context=getContainer();
    NamedObj parent=container;
    while (parent != null && parent != context) {
      parent=parent.getContainer();
    }
    if (parent == context && container != context) {
      if (container.attributeList(PersistenceAttribute.class).isEmpty()) {
        new PersistenceAttribute(container,container.uniqueName(""String_Node_Str""));
      }
    }
  }
}"
73474,"/** 
 * Return the value of the attribute.
 * @param container  The container for XML element.
 * @param element The XML element name.
 * @param attributeName The name of the attribute.
 * @param attributeValue The value of the attribute.
 * @param xmlFile The file currently being parsed.
 * @return The value of the attribute.
 */
public String filterAttributeValue(NamedObj container,String element,String attributeName,String attributeValue,String xmlFile){
  return attributeValue;
}","/** 
 * Return the value of the attribute.
 * @param container  The container for XML element.
 * @param element The XML element name.
 * @param attributeName The name of the attribute.
 * @param attributeValue The value of the attribute.
 * @param xmlFile The file currently being parsed.
 * @return The value of the attribute.
 */
@Override public String filterAttributeValue(NamedObj container,String element,String attributeName,String attributeValue,String xmlFile){
  return attributeValue;
}"
73475,"/** 
 * Update the container of this importer with the design pattern. If a design pattern is previously added to the container, the importer first tries to undo the importation before importing the new design pattern.
 */
public void update(){
  List<Parameter> parameters=attributeList(Parameter.class);
  HashMap<String,Token> table=new HashMap<String,Token>();
  String value=null;
  DesignPatternGetMoMLAction action=new DesignPatternGetMoMLAction();
  for (  Parameter parameter : parameters) {
    try {
      Token token=parameter.getToken();
      table.put(parameter.getName(),token);
      if (parameter == designPatternFile) {
        value=((StringToken)token).stringValue();
      }
 else {
        action.overrideParameter(parameter.getName(),parameter.getExpression());
      }
    }
 catch (    IllegalActionException e) {
      throw new InternalErrorException(this,e,""String_Node_Str"" + ""String_Node_Str"" + parameter.getName());
    }
  }
  if (table.equals(_lastValues)) {
    return;
  }
 else {
    _lastValues=table;
  }
  if (_lastUndoStack != null) {
    try {
      _lastUndoStack.undo();
    }
 catch (    Exception e) {
      throw new InternalErrorException(this,e,""String_Node_Str"");
    }
 finally {
      _lastUndoStack=null;
    }
  }
  if (value == null || value.equals(""String_Node_Str"")) {
    return;
  }
  final MoMLParser parser=new MoMLParser();
  NamedObj model;
  try {
    Reader reader=designPatternFile.openForReading();
    URI baseDirectory=designPatternFile.getBaseDirectory();
    model=parser.parse(baseDirectory == null ? null : baseDirectory.toURL(),value,reader);
  }
 catch (  Exception e) {
    throw new InternalErrorException(this,e,""String_Node_Str"" + ""String_Node_Str"" + value + ""String_Node_Str"");
  }
  final String moml=action.getMoml(model,null);
  parser.reset();
  final NamedObj container=getContainer();
  final UndoStackAttribute undoStack;
  try {
    undoStack=new UndoStackAttribute(container,container.uniqueName(""String_Node_Str""));
    undoStack.moveToFirst();
  }
 catch (  KernelException e) {
    throw new InternalErrorException(this,e,""String_Node_Str"" + ""String_Node_Str"");
  }
  boolean isModified=MoMLParser.isModified();
  final MoMLContentFilter filter=new MoMLContentFilter();
  parser.setContext(container);
  parser.setUndoable(true);
  try {
    MoMLParser.addMoMLFilter(filter);
    parser.parse(moml);
  }
 catch (  Exception e) {
    throw new InternalErrorException(this,e,""String_Node_Str"" + ""String_Node_Str"" + value + ""String_Node_Str"");
  }
 finally {
    MoMLParser.getMoMLFilters().remove(filter);
    MoMLParser.setModified(isModified);
    _lastUndoStack=undoStack;
    try {
      undoStack.setContainer(null);
    }
 catch (    KernelException e) {
    }
    Attribute after=container.getAttribute(""String_Node_Str"");
    if (after instanceof TransformationAttribute) {
      final TransformationAttribute attribute=(TransformationAttribute)after;
      attribute.addExecutionListener(new ExecutionListener(){
        public void executionError(        Manager manager,        Throwable throwable){
        }
        public void executionFinished(        Manager manager){
        }
        public void managerStateChanged(        Manager manager){
          if (manager.getState() == Manager.PREINITIALIZING) {
            MoMLParser.addMoMLFilter(filter);
            _isModified=MoMLParser.isModified();
            try {
              _lastUndoStack.setContainer(container);
              _lastUndoStack.moveToFirst();
            }
 catch (            KernelException e) {
              e.printStackTrace();
            }
          }
 else           if (manager.getState() == Manager.IDLE) {
            MoMLParser.getMoMLFilters().remove(filter);
            MoMLParser.setModified(_isModified);
            _lastUndoStack=undoStack;
            try {
              undoStack.setContainer(null);
            }
 catch (            KernelException e) {
            }
            attribute.removeExecutionListener(this);
          }
        }
        private boolean _isModified;
      }
);
    }
  }
}","/** 
 * Update the container of this importer with the design pattern. If a design pattern is previously added to the container, the importer first tries to undo the importation before importing the new design pattern.
 */
public void update(){
  List<Parameter> parameters=attributeList(Parameter.class);
  HashMap<String,Token> table=new HashMap<String,Token>();
  String value=null;
  DesignPatternGetMoMLAction action=new DesignPatternGetMoMLAction();
  for (  Parameter parameter : parameters) {
    try {
      Token token=parameter.getToken();
      table.put(parameter.getName(),token);
      if (parameter == designPatternFile) {
        value=((StringToken)token).stringValue();
      }
 else {
        action.overrideParameter(parameter.getName(),parameter.getExpression());
      }
    }
 catch (    IllegalActionException e) {
      throw new InternalErrorException(this,e,""String_Node_Str"" + ""String_Node_Str"" + parameter.getName());
    }
  }
  if (table.equals(_lastValues)) {
    return;
  }
 else {
    _lastValues=table;
  }
  if (_lastUndoStack != null) {
    try {
      _lastUndoStack.undo();
    }
 catch (    Exception e) {
      throw new InternalErrorException(this,e,""String_Node_Str"");
    }
 finally {
      _lastUndoStack=null;
    }
  }
  if (value == null || value.equals(""String_Node_Str"")) {
    return;
  }
  final MoMLParser parser=new MoMLParser();
  NamedObj model;
  try {
    Reader reader=designPatternFile.openForReading();
    URI baseDirectory=designPatternFile.getBaseDirectory();
    model=parser.parse(baseDirectory == null ? null : baseDirectory.toURL(),value,reader);
  }
 catch (  Exception e) {
    throw new InternalErrorException(this,e,""String_Node_Str"" + ""String_Node_Str"" + value + ""String_Node_Str"");
  }
  final String moml=action.getMoml(model,null);
  parser.reset();
  final NamedObj container=getContainer();
  final UndoStackAttribute undoStack;
  try {
    undoStack=new UndoStackAttribute(container,container.uniqueName(""String_Node_Str""));
    undoStack.moveToFirst();
  }
 catch (  KernelException e) {
    throw new InternalErrorException(this,e,""String_Node_Str"" + ""String_Node_Str"");
  }
  boolean isModified=MoMLParser.isModified();
  final MoMLContentFilter filter=new MoMLContentFilter();
  parser.setContext(container);
  parser.setUndoable(true);
  try {
    MoMLParser.addMoMLFilter(filter);
    parser.parse(moml);
  }
 catch (  Exception e) {
    throw new InternalErrorException(this,e,""String_Node_Str"" + ""String_Node_Str"" + value + ""String_Node_Str"");
  }
 finally {
    MoMLParser.getMoMLFilters().remove(filter);
    MoMLParser.setModified(isModified);
    _lastUndoStack=undoStack;
    try {
      undoStack.setContainer(null);
    }
 catch (    KernelException e) {
    }
    Attribute after=container.getAttribute(""String_Node_Str"");
    if (after instanceof TransformationAttribute) {
      final TransformationAttribute attribute=(TransformationAttribute)after;
      attribute.addExecutionListener(new ExecutionListener(){
        @Override public void executionError(        Manager manager,        Throwable throwable){
        }
        @Override public void executionFinished(        Manager manager){
        }
        @Override public void managerStateChanged(        Manager manager){
          if (manager.getState() == Manager.PREINITIALIZING) {
            MoMLParser.addMoMLFilter(filter);
            _isModified=MoMLParser.isModified();
            try {
              _lastUndoStack.setContainer(container);
              _lastUndoStack.moveToFirst();
            }
 catch (            KernelException e) {
              e.printStackTrace();
            }
          }
 else           if (manager.getState() == Manager.IDLE) {
            MoMLParser.getMoMLFilters().remove(filter);
            MoMLParser.setModified(_isModified);
            _lastUndoStack=undoStack;
            try {
              undoStack.setContainer(null);
            }
 catch (            KernelException e) {
            }
            attribute.removeExecutionListener(this);
          }
        }
        private boolean _isModified;
      }
);
    }
  }
}"
73476,"public void executionError(Manager manager,Throwable throwable){
}","@Override public void executionError(Manager manager,Throwable throwable){
}"
73477,"/** 
 * Set the container of this importer, and update the new container if it is not null.
 * @param container The new container.
 * @exception IllegalActionException If thrown by the superclass.
 * @exception NameDuplicationException If thrown by the superclass.
 */
public void setContainer(NamedObj container) throws IllegalActionException, NameDuplicationException {
  NamedObj oldContainer=getContainer();
  try {
    if (oldContainer != null && _lastUndoStack != null) {
      _lastUndoStack.undo();
    }
  }
 catch (  Exception e) {
    throw new InternalErrorException(this,e,""String_Node_Str"");
  }
 finally {
    _lastUndoStack=null;
  }
  super.setContainer(container);
  if (container != null) {
    update();
  }
}","/** 
 * Set the container of this importer, and update the new container if it is not null.
 * @param container The new container.
 * @exception IllegalActionException If thrown by the superclass.
 * @exception NameDuplicationException If thrown by the superclass.
 */
@Override public void setContainer(NamedObj container) throws IllegalActionException, NameDuplicationException {
  NamedObj oldContainer=getContainer();
  try {
    if (oldContainer != null && _lastUndoStack != null) {
      _lastUndoStack.undo();
    }
  }
 catch (  Exception e) {
    throw new InternalErrorException(this,e,""String_Node_Str"");
  }
 finally {
    _lastUndoStack=null;
  }
  super.setContainer(container);
  if (container != null) {
    update();
  }
}"
73478,"/** 
 * Create an instance of OntologyGraphTableau for the specified effigy, if it is an effigy for an instance of FSMActor.
 * @param effigy The effigy for an FSMActor.
 * @return A new OntologyGraphTableau, if the effigy is a PtolemyEffigythat references an FSMActor, or null otherwise.
 * @exception Exception If an exception occurs when creating thetableau.
 */
public Tableau createTableau(Effigy effigy) throws Exception {
  if (!(effigy instanceof PtolemyEffigy)) {
    return null;
  }
  Tableau tableau=(Tableau)effigy.getEntity(""String_Node_Str"");
  if (tableau != null) {
    return tableau;
  }
  NamedObj model=((PtolemyEffigy)effigy).getModel();
  if (model instanceof OntologySolverModel) {
    LibraryAttribute library=(LibraryAttribute)getAttribute(""String_Node_Str"",LibraryAttribute.class);
    tableau=new OntologySolverTableau((PtolemyEffigy)effigy,""String_Node_Str"",library);
    return tableau;
  }
 else {
    return null;
  }
}","/** 
 * Create an instance of OntologyGraphTableau for the specified effigy, if it is an effigy for an instance of OntologySolverModel.
 * @param effigy The effigy for an OntologySolverModel.
 * @return A new OntologySolverTableau, if the effigy is a PtolemyEffigythat references an OntologySolverModel, or null otherwise.
 * @exception Exception If an exception occurs when creating thetableau.
 */
public Tableau createTableau(Effigy effigy) throws Exception {
  if (!(effigy instanceof PtolemyEffigy)) {
    return null;
  }
  Tableau tableau=(Tableau)effigy.getEntity(""String_Node_Str"");
  if (tableau != null) {
    return tableau;
  }
  NamedObj model=((PtolemyEffigy)effigy).getModel();
  if (model instanceof OntologySolverModel) {
    LibraryAttribute library=(LibraryAttribute)getAttribute(""String_Node_Str"",LibraryAttribute.class);
    tableau=new OntologySolverTableau((PtolemyEffigy)effigy,""String_Node_Str"",library);
    return tableau;
  }
 else {
    return null;
  }
}"
73479,"/** 
 * Create the graph frame that displays the model associated with this tableau together with the specified library. This method creates a FSMGraphFrame. If a subclass uses another frame, this method should be overridden to create that frame.
 * @param model The Ptolemy II model to display in the graph frame.
 * @param defaultLibrary The default library, or null to not specifyone.
 */
public void createGraphFrame(CompositeEntity model,LibraryAttribute defaultLibrary){
  ExtendedGraphFrame frame=new ActorGraphFrame(model,this,defaultLibrary);
  try {
    setFrame(frame);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex);
  }
  frame.setBackground(BACKGROUND_COLOR);
  frame.pack();
  frame.centerOnScreen();
  frame.setVisible(true);
}","/** 
 * Create the graph frame that displays the model associated with this tableau together with the specified library.
 * @param model The Ptolemy II model to display in the graph frame.
 * @param defaultLibrary The default library, or null to not specifyone.
 */
public void createGraphFrame(CompositeEntity model,LibraryAttribute defaultLibrary){
  ExtendedGraphFrame frame=new ActorGraphFrame(model,this,defaultLibrary);
  try {
    setFrame(frame);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex);
  }
  frame.setBackground(BACKGROUND_COLOR);
  frame.pack();
  frame.centerOnScreen();
  frame.setVisible(true);
}"
73480,"/** 
 * Create a new FSM editor tableau with the specified container, name, and default library.
 * @param container The container.
 * @param name The name.
 * @param defaultLibrary The default library, or null to not specify one.
 * @exception IllegalActionException If the model associated withthe container effigy is not an FSMActor.
 * @exception NameDuplicationException If the container alreadycontains an object with the specified name.
 */
public OntologySolverTableau(PtolemyEffigy container,String name,LibraryAttribute defaultLibrary) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  NamedObj model=container.getModel();
  if (!(model instanceof OntologySolverModel)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  createGraphFrame((OntologySolverModel)model,defaultLibrary);
}","/** 
 * Create a new OntologySolverModel tableau with the specified container, name, and default library.
 * @param container The container.
 * @param name The name.
 * @param defaultLibrary The default library, or null to not specify one.
 * @exception IllegalActionException If the model associated withthe container effigy is not an OntologySolverModel.
 * @exception NameDuplicationException If the container alreadycontains an object with the specified name.
 */
public OntologySolverTableau(PtolemyEffigy container,String name,LibraryAttribute defaultLibrary) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  NamedObj model=container.getModel();
  if (!(model instanceof OntologySolverModel)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  createGraphFrame((OntologySolverModel)model,defaultLibrary);
}"
73481,"/** 
 * If the event's destination port does not have a delayOffset parameter, or if there doesn't exist a destination port (in case of pure event) then the event is always safe to process. Otherwise: If the current physical time has passed the timestamp of the event minus delayOffset of the port, then the event is safe to process. Otherwise the event is not safe to process, and we calculate the physical time when the event is safe to process and setup a timed interrupt. This method calls _setTimedInterrupt at the oracle time of the corresponding safe-to-process time.
 * @see #_setTimedInterrupt(Time)
 * @see #_getOraclePhysicalTagForPlatformPhysicalTag(Tag)
 * @param event The event checked for safe to process
 * @return True if the event is safe to process, otherwise return false.
 * @exception IllegalActionException If port is null and event is not a pureevent.
 * @see #_setTimedInterrupt(Time)
 */
protected boolean _safeToProcess(PtidesEvent event) throws IllegalActionException {
  IOPort port=event.ioPort();
  if (port == null) {
    assert(event.isPureEvent());
    return true;
  }
  assert(!port.isOutput());
  double delayOffset=_getMininumDelayOffset(port,((PtidesEvent)event).channel(),event.isPureEvent());
  Time waitUntilPhysicalTime=event.timeStamp().subtract(delayOffset);
  Tag platformPhysicalTag=getPlatformPhysicalTag(PLATFORM_TIMER);
  int compare=platformPhysicalTag.timestamp.subtract(waitUntilPhysicalTime).compareTo(_zero);
  int microstep=platformPhysicalTag.microstep;
  if ((compare > 0) || compare == 0 && (microstep >= event.microstep())) {
    return true;
  }
 else {
    if (!_eventTimedInterruptTimes.containsKey(event)) {
      _eventTimedInterruptTimes.put(event,waitUntilPhysicalTime);
      _timedInterruptWakeUpTimes.add(waitUntilPhysicalTime);
      Collections.sort(_timedInterruptWakeUpTimes);
      _fireAtPlatformTime(waitUntilPhysicalTime,PLATFORM_TIMER);
    }
    return false;
  }
}","/** 
 * If the event's destination port does not have a delayOffset parameter, or if there doesn't exist a destination port (in case of pure event) then the event is always safe to process. Otherwise: If the current physical time has passed the timestamp of the event minus delayOffset of the port, then the event is safe to process. Otherwise the event is not safe to process, and we calculate the physical time when the event is safe to process and setup a timed interrupt. This method calls _setTimedInterrupt at the oracle time of the corresponding safe-to-process time.
 * @see #_setTimedInterrupt(Time)
 * @see #_getOraclePhysicalTagForPlatformPhysicalTag(Tag)
 * @param event The event checked for safe to process
 * @return True if the event is safe to process, otherwise return false.
 * @exception IllegalActionException If port is null and event is not a pureevent.
 * @see #_setTimedInterrupt(Time)
 */
protected boolean _safeToProcess(PtidesEvent event) throws IllegalActionException {
  IOPort port=event.ioPort();
  if (port == null) {
    assert(event.isPureEvent());
    return true;
  }
  assert(!port.isOutput());
  double delayOffset=_getMininumDelayOffset(port,((PtidesEvent)event).channel(),event.isPureEvent());
  Time waitUntilPhysicalTime=event.timeStamp().subtract(delayOffset);
  Tag platformPhysicalTag=getPlatformPhysicalTag(PLATFORM_TIMER);
  int compare=platformPhysicalTag.timestamp.subtract(waitUntilPhysicalTime).compareTo(_zero);
  int microstep=platformPhysicalTag.microstep;
  if ((compare > 0) || compare == 0 && (microstep >= event.microstep())) {
    return true;
  }
 else {
    if (!_eventsWithTimedInterrupt.contains(event)) {
      _eventsWithTimedInterrupt.add(event);
      TimedEvent timedEvent=new TimedEvent(waitUntilPhysicalTime,event);
      _timedInterruptTimes.add(timedEvent);
      Collections.sort(_timedInterruptTimes);
      _fireAtPlatformTime(waitUntilPhysicalTime,PLATFORM_TIMER);
    }
    return false;
  }
}"
73482,"/** 
 * Return the actor to fire in this iteration, or null if no actor should be fired. This method performs the simulation of execution time, as described below. Execution times are assumed to be in oracle simulated physical time, not platform simulated physical time. The difference between these two times are described in the comment of this class. In this base class, this method first checks whether the top event from the event queue is destined for an actuator. If it is, then we check if physical time has reached the timestamp of the actuation event. If it has, then we fire the actuator. If it has not, then we take the actuator event from the event queue and put it onto the _realTimeEventQueue, and call fireAt() of the executive director. We then check if a real-time event should be processed by looking at the top event of the _realTimeEventQueue. If there is one that should be fired, that actor is returned for firing. If not, we go on and considers two cases, depending whether there is an actor currently executing, as follows: <p> <b>Case 1</b>: If there is no actor currently executing, then this method checks the event queue and returns null if it is empty. If it is not empty, it checks the destination actor of the earliest event on the event queue, and if it has a non-zero execution time, then it pushes it onto the currently executing stack and returns null. Otherwise, if the execution time of the actor is zero, it sets the current model time to the time stamp of that earliest event and returns that actor. <p> <b>Case 2</b>: If there is an actor currently executing, then this method checks whether it has a remaining execution time of zero. If it does, then it returns the currently executing actor. If it does not, then it checks whether the earliest event on the event queue should preempt it (by invoking _preemptExecutingActor()), and if so, checks the destination actor of that event and removes the event from the event queue. If that destination actor has an execution time of zero, then it sets the current model time to the time stamp of that event, and returns that actor. Else if the destination actor has an execution time of bigger than zero, then it calls fireAt() on the enclosing director passing it the time it expects the currently executing actor to finish executing, and returns null. If there is no event on the event queue or that event should not preempt the currently executing actor, then it calls fireAt() on the enclosing director passing it the time it expects the currently executing actor to finish executing, and returns null.
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards, or if the enclosing director does not respect the fireAt call. <p> Also, when an actor is fired, not only is the top event processed, all events in the event queue are also checked to see whether they have the same actor as destination, and they have the same timestamp as the top event. Those that do are also taken out of the event queue and processed. <p> Finally, in any of the following situations: a sensor interrupt has occurred, a timed interrupt has occurred, or an actor has finished firing; the scheduler must run to decide whether the next event should be processed. Since the Ptides simulator simulates the passage of physical time, we also simulate the overhead for the scheduler to make its decision. The parameter:  {@link #schedulerExecutionTime} indicates this time.Note, when sensor and timed interrupts occurs, the currently executing event will be preempted to perform the scheduling overhead. <p> If at some simulated physical time, a sensor interrupt occurred, at the same time, a previous event finished execution, then we always assume the sensor interruption occurred first, and the event should be put into the event queue before the finished event is dealt with.
 * @see #_preemptExecutingActor()
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  Tag executionPhysicalTag=getPlatformPhysicalTag(EXECUTION_TIMER);
  Actor container=(Actor)getContainer();
  Director executiveDirector=container.getExecutiveDirector();
  if (_schedulerStillRunning()) {
    return null;
  }
  if (_inputEventInterruptOccurred) {
    _inputEventInterruptOccurred=false;
    if (_startScheduler()) {
      _resetExecutionTimeForPreemptedEvent();
      _physicalTimeExecutionStarted=null;
      return null;
    }
  }
  if (_timedInterruptOccurred()) {
    if (_startScheduler()) {
      _resetExecutionTimeForPreemptedEvent();
      _physicalTimeExecutionStarted=null;
      return null;
    }
  }
  if (_scheduleNewEvent) {
    _scheduleNewEvent=false;
    if (_startScheduler()) {
      _resetExecutionTimeForPreemptedEvent();
      _physicalTimeExecutionStarted=null;
      return null;
    }
  }
  if (!_currentlyExecutingStack.isEmpty()) {
    if (_physicalTimeExecutionStarted == null) {
      _physicalTimeExecutionStarted=executionPhysicalTag.timestamp;
    }
    DoubleTimedEvent currentEventList=(DoubleTimedEvent)_currentlyExecutingStack.peek();
    Time remainingExecutionTime=currentEventList.remainingExecutionTime;
    Time finishTime=_physicalTimeExecutionStarted.add(remainingExecutionTime);
    int comparison=finishTime.compareTo(executionPhysicalTag.timestamp);
    if (comparison < 0) {
      throw new IllegalActionException(this,_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),""String_Node_Str"");
    }
 else     if (comparison == 0) {
      setTag(currentEventList.timeStamp,currentEventList.microstep);
      _currentlyExecutingStack.pop();
      _physicalTimeExecutionStarted=executionPhysicalTag.timestamp;
      if (_debugging) {
        _debug(""String_Node_Str"" + _getActorFromEventList((List<PtidesEvent>)currentEventList.contents).getName(getContainer()) + ""String_Node_Str""+ executionPhysicalTag.timestamp);
      }
      _setIcon(_getIdleIcon(),false);
      _clearHighlight(_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),false);
      _lastExecutingActor=null;
      executiveDirector.fireAtCurrentTime((Actor)container);
      _lastActorFired=_getActorFromEventList((List<PtidesEvent>)currentEventList.contents);
      if (!(_lastActorFired instanceof SensorInputDevice)) {
        _scheduleNewEvent=true;
      }
      return _lastActorFired;
    }
 else {
      _fireAtPlatformTime(finishTime,EXECUTION_TIMER);
      if (_eventQueue.isEmpty() || !_preemptExecutingActor()) {
        return null;
      }
    }
  }
  if (_eventQueue.isEmpty()) {
    _setIcon(_getIdleIcon(),false);
    return null;
  }
  PtidesEvent eventFromQueue=_getNextSafeEvent();
  if (eventFromQueue == null) {
    return null;
  }
  Time timeStampOfEventFromQueue=eventFromQueue.timeStamp();
  int microstepOfEventFromQueue=eventFromQueue.microstep();
  _trackLastTagConsumedByActor(eventFromQueue);
  List<PtidesEvent> eventsToProcess=_takeAllSameTagEventsFromQueue(eventFromQueue);
  Actor actorToFire=_getNextActorToFireForTheseEvents(eventsToProcess);
  IOPort ioPort=eventFromQueue.ioPort();
  if (ioPort == null) {
    List<IOPort> inPortList=eventFromQueue.actor().inputPortList();
    if (inPortList.size() > 0) {
      ioPort=inPortList.get(0);
    }
  }
  _saveEventInformation(eventsToProcess);
  Time executionTime=new Time(this,_getExecutionTime(ioPort,actorToFire));
  if (executionTime.compareTo(_zero) == 0) {
    setTag(timeStampOfEventFromQueue,microstepOfEventFromQueue);
    executiveDirector.fireAtCurrentTime((Actor)container);
    _lastActorFired=actorToFire;
    if (!(_lastActorFired instanceof SensorInputDevice)) {
      _scheduleNewEvent=true;
    }
    return actorToFire;
  }
 else {
    Time expectedCompletionTime=executionPhysicalTag.timestamp.add(executionTime);
    _fireAtPlatformTime(expectedCompletionTime,EXECUTION_TIMER);
    _resetExecutionTimeForPreemptedEvent();
    _currentlyExecutingStack.push(new DoubleTimedEvent(timeStampOfEventFromQueue,microstepOfEventFromQueue,eventsToProcess,executionTime));
    _physicalTimeExecutionStarted=executionPhysicalTag.timestamp;
    if (_debugging) {
      _debug(""String_Node_Str"" + actorToFire.toString() + ""String_Node_Str""+ executionPhysicalTag.timestamp);
    }
    _setIcon(_getExecutingIcon(actorToFire),false);
    _lastExecutingActor=actorToFire;
    return null;
  }
}","/** 
 * Return the actor to fire in this iteration, or null if no actor should be fired. This method performs the simulation of execution time, as described below. Execution times are assumed to be in oracle simulated physical time, not platform simulated physical time. The difference between these two times are described in the comment of this class. In this base class, this method first checks whether the top event from the event queue is destined for an actuator. If it is, then we check if physical time has reached the timestamp of the actuation event. If it has, then we fire the actuator. If it has not, then we take the actuator event from the event queue and put it onto the _realTimeEventQueue, and call fireAt() of the executive director. We then check if a real-time event should be processed by looking at the top event of the _realTimeEventQueue. If there is one that should be fired, that actor is returned for firing. If not, we go on and considers two cases, depending whether there is an actor currently executing, as follows: <p> <b>Case 1</b>: If there is no actor currently executing, then this method checks the event queue and returns null if it is empty. If it is not empty, it checks the destination actor of the earliest event on the event queue, and if it has a non-zero execution time, then it pushes it onto the currently executing stack and returns null. Otherwise, if the execution time of the actor is zero, it sets the current model time to the time stamp of that earliest event and returns that actor. <p> <b>Case 2</b>: If there is an actor currently executing, then this method checks whether it has a remaining execution time of zero. If it does, then it returns the currently executing actor. If it does not, then it checks whether the earliest event on the event queue should preempt it (by invoking _preemptExecutingActor()), and if so, checks the destination actor of that event and removes the event from the event queue. If that destination actor has an execution time of zero, then it sets the current model time to the time stamp of that event, and returns that actor. Else if the destination actor has an execution time of bigger than zero, then it calls fireAt() on the enclosing director passing it the time it expects the currently executing actor to finish executing, and returns null. If there is no event on the event queue or that event should not preempt the currently executing actor, then it calls fireAt() on the enclosing director passing it the time it expects the currently executing actor to finish executing, and returns null.
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards, or if the enclosing director does not respect the fireAt call. <p> Also, when an actor is fired, not only is the top event processed, all events in the event queue are also checked to see whether they have the same actor as destination, and they have the same timestamp as the top event. Those that do are also taken out of the event queue and processed. <p> Finally, in any of the following situations: a sensor interrupt has occurred, a timed interrupt has occurred, or an actor has finished firing; the scheduler must run to decide whether the next event should be processed. Since the Ptides simulator simulates the passage of physical time, we also simulate the overhead for the scheduler to make its decision. The parameter:  {@link #schedulerExecutionTime} indicates this time.Note, when sensor and timed interrupts occurs, the currently executing event will be preempted to perform the scheduling overhead. <p> If at some simulated physical time, a sensor interrupt occurred, at the same time, a previous event finished execution, then we always assume the sensor interruption occurred first, and the event should be put into the event queue before the finished event is dealt with.
 * @see #_preemptExecutingActor()
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  Tag executionPhysicalTag=getPlatformPhysicalTag(EXECUTION_TIMER);
  Actor container=(Actor)getContainer();
  Director executiveDirector=container.getExecutiveDirector();
  if (_ignoreThisFireAtTime(_ignoredExecutionFireAtTimes) || _ignoreThisFireAtTime(_ignoredPlatformFireAtTimes)) {
    return null;
  }
  if (_schedulerStillRunning()) {
    return null;
  }
  if (_inputEventInterruptOccurred) {
    _inputEventInterruptOccurred=false;
    if (_startScheduler()) {
      _resetExecutionTimeForPreemptedEvent();
      _physicalTimeExecutionStarted=null;
      return null;
    }
  }
  if (_timedInterruptOccurred()) {
    if (_startScheduler()) {
      _resetExecutionTimeForPreemptedEvent();
      _physicalTimeExecutionStarted=null;
      return null;
    }
  }
  if (_scheduleNewEvent) {
    _scheduleNewEvent=false;
    if (_startScheduler()) {
      _resetExecutionTimeForPreemptedEvent();
      _physicalTimeExecutionStarted=null;
      return null;
    }
  }
  if (!_currentlyExecutingStack.isEmpty()) {
    if (_physicalTimeExecutionStarted == null) {
      _physicalTimeExecutionStarted=executionPhysicalTag.timestamp;
    }
    DoubleTimedEvent currentEventList=(DoubleTimedEvent)_currentlyExecutingStack.peek();
    Time remainingExecutionTime=currentEventList.remainingExecutionTime;
    Time finishTime=_physicalTimeExecutionStarted.add(remainingExecutionTime);
    int comparison=finishTime.compareTo(executionPhysicalTag.timestamp);
    if (comparison < 0) {
      throw new IllegalActionException(this,_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),""String_Node_Str"");
    }
 else     if (comparison == 0) {
      setTag(currentEventList.timeStamp,currentEventList.microstep);
      _currentlyExecutingStack.pop();
      _physicalTimeExecutionStarted=executionPhysicalTag.timestamp;
      if (_debugging) {
        _debug(""String_Node_Str"" + _getActorFromEventList((List<PtidesEvent>)currentEventList.contents).getName(getContainer()) + ""String_Node_Str""+ executionPhysicalTag.timestamp);
      }
      _setIcon(_getIdleIcon(),false);
      _clearHighlight(_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),false);
      _lastExecutingActor=null;
      executiveDirector.fireAtCurrentTime((Actor)container);
      _lastActorFired=_getActorFromEventList((List<PtidesEvent>)currentEventList.contents);
      if (!(_lastActorFired instanceof SensorInputDevice)) {
        _scheduleNewEvent=true;
      }
      return _lastActorFired;
    }
 else {
      _fireAtPlatformTime(finishTime,EXECUTION_TIMER);
      if (_eventQueue.isEmpty() || !_preemptExecutingActor()) {
        return null;
      }
    }
  }
  if (_eventQueue.isEmpty()) {
    _setIcon(_getIdleIcon(),false);
    return null;
  }
  PtidesEvent eventFromQueue=_getNextSafeEvent();
  if (eventFromQueue == null) {
    return null;
  }
  Time timeStampOfEventFromQueue=eventFromQueue.timeStamp();
  int microstepOfEventFromQueue=eventFromQueue.microstep();
  _trackLastTagConsumedByActor(eventFromQueue);
  List<PtidesEvent> eventsToProcess=_takeAllSameTagEventsFromQueue(eventFromQueue);
  Actor actorToFire=_getNextActorToFireForTheseEvents(eventsToProcess);
  IOPort ioPort=eventFromQueue.ioPort();
  if (ioPort == null) {
    List<IOPort> inPortList=eventFromQueue.actor().inputPortList();
    if (inPortList.size() > 0) {
      ioPort=inPortList.get(0);
    }
  }
  _saveEventInformation(eventsToProcess);
  Time executionTime=new Time(this,_getExecutionTime(ioPort,actorToFire));
  if (executionTime.compareTo(_zero) == 0) {
    setTag(timeStampOfEventFromQueue,microstepOfEventFromQueue);
    executiveDirector.fireAtCurrentTime((Actor)container);
    _lastActorFired=actorToFire;
    if (!(_lastActorFired instanceof SensorInputDevice)) {
      _scheduleNewEvent=true;
    }
    return actorToFire;
  }
 else {
    Time expectedCompletionTime=executionPhysicalTag.timestamp.add(executionTime);
    _fireAtPlatformTime(expectedCompletionTime,EXECUTION_TIMER);
    _resetExecutionTimeForPreemptedEvent();
    _currentlyExecutingStack.push(new DoubleTimedEvent(timeStampOfEventFromQueue,microstepOfEventFromQueue,eventsToProcess,executionTime));
    _physicalTimeExecutionStarted=executionPhysicalTag.timestamp;
    if (_debugging) {
      _debug(""String_Node_Str"" + actorToFire.toString() + ""String_Node_Str""+ executionPhysicalTag.timestamp);
    }
    _setIcon(_getExecutingIcon(actorToFire),false);
    _lastExecutingActor=actorToFire;
    return null;
  }
}"
73483,"/** 
 * Construct a structure that holds a real-time event. This event saves the token to be transmitted, the port and channel this token should be deliverd to, and the time this token should be delivered at.
 * @param port The destination port.
 * @param channel The destination channel.
 * @param token The token to be delivered.
 * @param deliveryTag The time of delivery of this token.
 */
public RealTimeEvent(IOPort port,int channel,Token token,Tag deliveryTag,Tag timestampTag){
  this.port=port;
  this.channel=channel;
  this.token=token;
  this.deliveryTag=deliveryTag;
  this.timestampTag=timestampTag;
}","/** 
 * Construct a structure that holds a real-time event. This event saves the token to be transmitted, the port and channel this token should be deliverd to, and the time this token should be delivered at.
 * @param port The destination port.
 * @param channel The destination channel.
 * @param token The token to be delivered.
 * @param deliveryTag The platform time of delivery of this token.
 */
public RealTimeEvent(IOPort port,int channel,Token token,Tag deliveryTag,Tag timestampTag){
  this.port=port;
  this.channel=channel;
  this.token=token;
  this.deliveryTag=deliveryTag;
  this.timestampTag=timestampTag;
}"
73484,"/** 
 * Check if timed interrupt has just occurred.
 * @return true if a timed interrupt has occured. Return false otherwise. 
 * @exception IllegalActionException If failed to get physical tag or if timeinterrupt occurred in the past. 
 */
private boolean _timedInterruptOccurred() throws IllegalActionException {
  if (_timedInterruptWakeUpTimes.isEmpty()) {
    return false;
  }
  Time topTimedInterruptWakeUpTime=_timedInterruptWakeUpTimes.get(0);
  int result=topTimedInterruptWakeUpTime.compareTo(getPlatformPhysicalTag(PLATFORM_TIMER).timestamp);
  if (result < 0) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + topTimedInterruptWakeUpTime.toString() + ""String_Node_Str""+ getPlatformPhysicalTag(PLATFORM_TIMER).timestamp+ ""String_Node_Str"");
  }
 else   if (result == 0) {
    _timedInterruptWakeUpTimes.remove(0);
    return true;
  }
  return false;
}","/** 
 * Check if timed interrupt has just occurred.
 * @return true if a timed interrupt has occured. Return false otherwise. 
 * @exception IllegalActionException If failed to get physical tag or if timeinterrupt occurred in the past. 
 */
private boolean _timedInterruptOccurred() throws IllegalActionException {
  if (_timedInterruptTimes.isEmpty()) {
    return false;
  }
  TimedEvent timedEvent=_timedInterruptTimes.get(0);
  Time topTimedInterruptWakeUpTime=timedEvent.timeStamp;
  int result=topTimedInterruptWakeUpTime.compareTo(getPlatformPhysicalTag(PLATFORM_TIMER).timestamp);
  if (result < 0) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + topTimedInterruptWakeUpTime.toString() + ""String_Node_Str""+ getPlatformPhysicalTag(PLATFORM_TIMER).timestamp+ ""String_Node_Str"");
  }
 else   if (result == 0) {
    _timedInterruptTimes.remove(0);
    _eventsWithTimedInterrupt.remove(timedEvent.contents);
    return true;
  }
  return false;
}"
73485,"/** 
 * Given original fireAt times, and a realTime clock with updated clock drift, create a new list of fireAt times. Also add the old fireAt times into the list of ignored fireAt times.
 * @param originalFireAtTimes The original fireAt times.
 * @param ignoreFireAtTimes The list of ignored fireAt times.
 * @param realTimeClock The real time clock whose clock drift has changed.
 * @return The new list of fireAt times.
 * @exception IllegalActionException If either the original or updated fireAttime is in the past.
 */
private List<Time> _updateFireAtTimes(List<Time> originalFireAtTimes,List<Time> ignoreFireAtTimes,RealTimeClock realTimeClock) throws IllegalActionException {
  List<Time> newFireAtTimes=new LinkedList<Time>();
  for (  Time originalFireAtTime : originalFireAtTimes) {
    if (originalFireAtTime.compareTo(realTimeClock._lastOracleTime) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + originalFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ realTimeClock._lastOracleTime.toString());
    }
    if (originalFireAtTime.compareTo(_getOraclePhysicalTag().timestamp) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + originalFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ _getOraclePhysicalTag().timestamp.toString());
    }
    Time clockDriftDiff=realTimeClock._clockDrift.subtract(realTimeClock._previousClockDrift);
    Time temp1=(realTimeClock._lastOracleTime.multiply(clockDriftDiff)).divide(realTimeClock._clockDrift);
    Time temp2=(originalFireAtTime.multiply(realTimeClock._previousClockDrift)).divide(realTimeClock._clockDrift);
    Time newFireAtTime=temp1.add(temp2);
    if (newFireAtTime.compareTo(realTimeClock._lastOracleTime) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + newFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ realTimeClock._lastOracleTime.toString());
    }
    if (newFireAtTime.compareTo(_getOraclePhysicalTag().timestamp) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + newFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ _getOraclePhysicalTag().timestamp.toString());
    }
    newFireAtTimes.add(newFireAtTime);
    if (ignoreFireAtTimes != null) {
      ignoreFireAtTimes.add(originalFireAtTime);
    }
  }
  Collections.sort(newFireAtTimes);
  if (ignoreFireAtTimes != null) {
    Collections.sort(ignoreFireAtTimes);
  }
  return newFireAtTimes;
}","/** 
 * Given original fireAt times, and a realTime clock with updated clock drift, create a new list of fireAt times. Also add the old fireAt times into the list of ignored fireAt times.
 * @param originalFireAtTimes The original fireAt times.
 * @param ignoreFireAtTimes The list of ignored fireAt times.
 * @param realTimeClock The real time clock whose clock drift has changed.
 * @return The new list of fireAt times.
 * @exception IllegalActionException If either the original or updated fireAttime is in the past.
 */
private List<?> _updateFireAtTimes(List<?> originalFireAtTimes,List<Time> ignoreFireAtTimes,RealTimeClock realTimeClock,Time newClockDrift) throws IllegalActionException {
  List<Time> newFireAtTimes=new LinkedList<Time>();
  for (  Object originalFireAt : originalFireAtTimes) {
    Time originalFireAtTime=null;
    if (originalFireAt instanceof Time) {
      originalFireAtTime=(Time)originalFireAt;
    }
 else     if (originalFireAt instanceof TimedEvent) {
      originalFireAtTime=((TimedEvent)originalFireAt).timeStamp;
    }
 else {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (originalFireAtTime.compareTo(realTimeClock._lastOracleTime) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + originalFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ realTimeClock._lastOracleTime.toString());
    }
    if (originalFireAtTime.compareTo(_getOraclePhysicalTag().timestamp) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + originalFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ _getOraclePhysicalTag().timestamp.toString());
    }
    Time clockDriftDiff=newClockDrift.subtract(realTimeClock._clockDrift);
    Time temp1=(realTimeClock._lastOracleTime.multiply(clockDriftDiff)).divide(newClockDrift);
    Time temp2=(originalFireAtTime.multiply(realTimeClock._clockDrift)).divide(newClockDrift);
    Time newFireAtTime=temp1.add(temp2);
    if (newFireAtTime.compareTo(realTimeClock._lastOracleTime) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + newFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ realTimeClock._lastOracleTime.toString());
    }
    if (newFireAtTime.compareTo(_getOraclePhysicalTag().timestamp) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + newFireAtTime.toString() + ""String_Node_Str""+ ""String_Node_Str""+ _getOraclePhysicalTag().timestamp.toString());
    }
    newFireAtTimes.add(newFireAtTime);
    if (ignoreFireAtTimes != null) {
      ignoreFireAtTimes.add(originalFireAtTime);
    }
  }
  Collections.sort(newFireAtTimes);
  if (ignoreFireAtTimes != null) {
    Collections.sort(ignoreFireAtTimes);
  }
  return newFireAtTimes;
}"
73486,"/** 
 * Construct a real time clock, with all the times and clock drifts set to default values: All clock drifts are initialized to Time 1.0, and the oracle time is initialized to Time 0.0. However the corresponding platform is intialized to the initialClockSynchronizationError paramter.
 */
public RealTimeClock(double initialClockSynchronizationError) throws IllegalActionException {
  _lastPlatformTime=new Time(PtidesBasicDirector.this,initialClockSynchronizationError);
  _clockDrift=new Time(PtidesBasicDirector.this,1.0);
  _previousClockDrift=new Time(PtidesBasicDirector.this,1.0);
  _lastOracleTime=new Time(PtidesBasicDirector.this);
}","/** 
 * Construct a real time clock, with all the times and clock drifts set to default values: All clock drifts are initialized to Time 1.0, and the oracle time is initialized to Time 0.0. However the corresponding platform is intialized to the initialClockSynchronizationError paramter.
 */
public RealTimeClock(double initialClockSynchronizationError) throws IllegalActionException {
  _lastPlatformTime=new Time(PtidesBasicDirector.this,initialClockSynchronizationError);
  _clockDrift=new Time(PtidesBasicDirector.this,1.0);
  _lastOracleTime=new Time(PtidesBasicDirector.this);
}"
73487,"/** 
 * Update all future fireAt times. This method should be used when the clock drift for a particular (platform or execution) clock changes, then the future fireAt times will also change. Also keep track of the list of ignored future fireAt times, so that when this director is woken up at those times, the director will not fire.
 * @param realTimeClock The realTimeClock of interest.
 * @throws IllegalActionException If either the original or updated fireAttime is in the past.
 */
public void updateFireAtTimes(RealTimeClock realTimeClock,Time newClockDrift) throws IllegalActionException {
  if (realTimeClock._clockDrift != realTimeClock._previousClockDrift) {
    Time newOracleTime=_getOraclePhysicalTag().timestamp;
    realTimeClock._lastPlatformTime=((newOracleTime.subtract(realTimeClock._lastOracleTime)).multiply(realTimeClock._clockDrift)).add(realTimeClock._lastPlatformTime);
    realTimeClock._lastOracleTime=newOracleTime;
    realTimeClock._previousClockDrift=realTimeClock._clockDrift;
    realTimeClock._clockDrift=newClockDrift;
    if (realTimeClock == _executionTimeClock) {
      _futureExecutionFireAtTimes=_updateFireAtTimes(_futureExecutionFireAtTimes,_ignoredExecutionFireAtTimes,realTimeClock);
    }
 else     if (realTimeClock == _platformTimeClock) {
      _futurePlatformFireAtTimes=_updateFireAtTimes(_futurePlatformFireAtTimes,_ignoredPlatformFireAtTimes,realTimeClock);
      _timedInterruptWakeUpTimes=_updateFireAtTimes(_timedInterruptWakeUpTimes,null,realTimeClock);
    }
 else {
      throw new InternalErrorException(this,null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}","/** 
 * Update all future fireAt times. This method should be used when the clock drift for a particular (platform or execution) clock changes, then the future fireAt times will also change. Also keep track of the list of ignored future fireAt times, so that when this director is woken up at those times, the director will not fire.
 * @param realTimeClock The realTimeClock of interest.
 * @throws IllegalActionException If either the original or updated fireAttime is in the past.
 */
public void updateFireAtTimes(RealTimeClock realTimeClock,Time newClockDrift) throws IllegalActionException {
  if (realTimeClock._clockDrift.compareTo(newClockDrift) != 0) {
    Time newOracleTime=_getOraclePhysicalTag().timestamp;
    realTimeClock._lastPlatformTime=((newOracleTime.subtract(realTimeClock._lastOracleTime)).multiply(realTimeClock._clockDrift)).add(realTimeClock._lastPlatformTime);
    realTimeClock._lastOracleTime=newOracleTime;
    realTimeClock._clockDrift=newClockDrift;
    if (realTimeClock == _executionTimeClock) {
      _futureExecutionFireAtTimes=(List<Time>)_updateFireAtTimes(_futureExecutionFireAtTimes,_ignoredExecutionFireAtTimes,realTimeClock,newClockDrift);
    }
 else     if (realTimeClock == _platformTimeClock) {
      _futurePlatformFireAtTimes=(List<Time>)_updateFireAtTimes(_futurePlatformFireAtTimes,_ignoredPlatformFireAtTimes,realTimeClock,newClockDrift);
      _timedInterruptTimes=(List<TimedEvent>)_updateFireAtTimes(_timedInterruptTimes,null,realTimeClock,newClockDrift);
    }
 else {
      throw new InternalErrorException(this,null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}"
73488,"/** 
 * Create new variables, initialize the actors and request a refiring at the current time of the executive director. This overrides the base class to throw an exception if there is no executive director.
 * @exception IllegalActionException If the superclass throwsit or if there is no executive director.
 */
public void initialize() throws IllegalActionException {
  _currentlyExecutingStack=new Stack<DoubleTimedEvent>();
  _realTimeInputEventQueue=new PriorityQueue<RealTimeEvent>();
  _realTimeOutputEventQueue=new PriorityQueue<RealTimeEvent>();
  _lastConsumedTag=new HashMap<NamedObj,Tag>();
  _pureEventDeadlines=new HashMap<NamedObj,Time>();
  _pureEventDelays=new HashMap<NamedObj,Time>();
  _pureEventSourcePorts=new HashMap<NamedObj,IOPort>();
  _physicalTimeExecutionStarted=null;
  _schedulerFinishTime=new Time(this,Double.NEGATIVE_INFINITY);
  _inputEventInterruptOccurred=false;
  _scheduleNewEvent=false;
  _timedInterruptWakeUpTimes=new LinkedList<Time>();
  _eventTimedInterruptTimes=new HashMap<PtidesEvent,Time>();
  _futureExecutionFireAtTimes=new LinkedList<Time>();
  _ignoredExecutionFireAtTimes=new LinkedList<Time>();
  _futurePlatformFireAtTimes=new LinkedList<Time>();
  _ignoredPlatformFireAtTimes=new LinkedList<Time>();
  _lastExecutingActor=null;
  _executionTimeClock=null;
  _platformTimeClock=null;
  super.initialize();
  (((Actor)getContainer()).getExecutiveDirector()).fireAtCurrentTime((Actor)getContainer());
  _setIcon(_getIdleIcon(),true);
  if (_executionTimeClock == null) {
    _executionTimeClock=new RealTimeClock(((DoubleToken)initializeExecutionTimeSynchronizationError.getToken()).doubleValue());
  }
  if (_platformTimeClock == null) {
    _platformTimeClock=new RealTimeClock(((DoubleToken)initializePlatformTimeSynchronizationError.getToken()).doubleValue());
  }
}","/** 
 * Create new variables, initialize the actors and request a refiring at the current time of the executive director. This overrides the base class to throw an exception if there is no executive director.
 * @exception IllegalActionException If the superclass throwsit or if there is no executive director.
 */
public void initialize() throws IllegalActionException {
  _currentlyExecutingStack=new Stack<DoubleTimedEvent>();
  _realTimeInputEventQueue=new PriorityQueue<RealTimeEvent>();
  _realTimeOutputEventQueue=new PriorityQueue<RealTimeEvent>();
  _lastConsumedTag=new HashMap<NamedObj,Tag>();
  _pureEventDeadlines=new HashMap<NamedObj,Time>();
  _pureEventDelays=new HashMap<NamedObj,Time>();
  _pureEventSourcePorts=new HashMap<NamedObj,IOPort>();
  _physicalTimeExecutionStarted=null;
  _schedulerFinishTime=new Time(this,Double.NEGATIVE_INFINITY);
  _inputEventInterruptOccurred=false;
  _scheduleNewEvent=false;
  _timedInterruptTimes=new LinkedList<TimedEvent>();
  _eventsWithTimedInterrupt=new HashSet<PtidesEvent>();
  _futureExecutionFireAtTimes=new LinkedList<Time>();
  _ignoredExecutionFireAtTimes=new LinkedList<Time>();
  _futurePlatformFireAtTimes=new LinkedList<Time>();
  _ignoredPlatformFireAtTimes=new LinkedList<Time>();
  _lastExecutingActor=null;
  _executionTimeClock=null;
  _platformTimeClock=null;
  super.initialize();
  (((Actor)getContainer()).getExecutiveDirector()).fireAtCurrentTime((Actor)getContainer());
  _setIcon(_getIdleIcon(),true);
  if (_executionTimeClock == null) {
    _executionTimeClock=new RealTimeClock(((DoubleToken)initializeExecutionTimeSynchronizationError.getToken()).doubleValue());
  }
  if (_platformTimeClock == null) {
    _platformTimeClock=new RealTimeClock(((DoubleToken)initializePlatformTimeSynchronizationError.getToken()).doubleValue());
  }
}"
73489,"/** 
 * Return the concept from the given subset of concepts that is the least or greatest.
 * @param subset The set of concepts in question. 
 * @param direction The directionality of the extremity. CPO.HIGHERfor greatest, and CPO.LOWER for least.
 * @return The concept at the extremity, if it exists. Null, if nosuch concept exists.
 */
private Concept _superlativeElement(Object[] subset,int direction){
  if (subset != null && subset.length > 0) {
    Concept greatest=(Concept)subset[0];
    for (    Object concept : subset) {
      if (compare(concept,greatest) == direction) {
        greatest=(Concept)concept;
      }
    }
    return greatest;
  }
  return null;
}","/** 
 * Return the concept from the given subset of concepts that is the least or greatest.
 * @param subset The set of concepts in question. 
 * @param direction The directionality of the extremity. CPO.HIGHERfor greatest, and CPO.LOWER for least.
 * @return The concept at the extremity, if it exists. Null, if nosuch concept exists.
 */
private Concept _superlativeElement(Object[] subset,int direction){
  if (subset != null && subset.length > 0) {
    Concept greatest=(Concept)subset[0];
    for (    Object concept : subset) {
      if (compare(concept,greatest) == CPO.INCOMPARABLE) {
        return null;
      }
 else       if (compare(concept,greatest) == direction) {
        greatest=(Concept)concept;
      }
    }
    return greatest;
  }
  return null;
}"
73490,"/** 
 * Return the size of the collection mapped to the specified key.
 * @param key The specified key.
 * @return The size of the collection, or zero if key isnot in the map.
 */
public int size(Object key){
  Collection values=_map.get(key);
  if (values == null) {
    return 0;
  }
 else {
    return values.size();
  }
}","/** 
 * Return the size of the collection mapped to the specified key.
 * @param key The specified key.
 * @return The size of the collection, or zero if key isnot in the map.
 */
public int size(Object key){
  Collection<V> values=_map.get(key);
  if (values == null) {
    return 0;
  }
 else {
    return values.size();
  }
}"
73491,"/** 
 * Return a view of the collection containing all values in the map. This is a collection containing the union of each collection mapped to the keys.
 * @return A view of all values contained in this map.
 */
public Collection values(){
  Collection result=new ArrayList();
  for (  Object object : _map.values()) {
    Collection values=(Collection)object;
    result.addAll(values);
  }
  return result;
}","/** 
 * Return a view of the collection containing all values in the map. This is a collection containing the union of each collection mapped to the keys.
 * @return A view of all values contained in this map.
 */
public Collection<V> values(){
  Collection<V> result=new ArrayList<V>();
  for (  Collection<V> values : _map.values()) {
    result.addAll(values);
  }
  return result;
}"
73492,"/** 
 * Remove a specified value from the map. The value is removed from the collection mapped to the specified key. If this is the last value removed from the given key, the specified key is also removed from the map. Subsequent call to get(key) will return null.
 * @param key The specified key to remove the value from.
 * @param value The specified value to remove.
 * @return The value removed, or null if nothing is removed.
 */
public Object remove(K key,V value){
  Collection values=_map.get(key);
  if (values == null) {
    return null;
  }
 else {
    Object object=values.remove(value);
    if (values.size() == 0) {
      _map.remove(key);
    }
    return object;
  }
}","/** 
 * Remove a specified value from the map. The value is removed from the collection mapped to the specified key. If this is the last value removed from the given key, the specified key is also removed from the map. Subsequent call to get(key) will return null.
 * @param key The specified key to remove the value from.
 * @param value The specified value to remove.
 * @return The value removed, or null if nothing is removed.
 */
public Object remove(K key,V value){
  Collection<V> values=_map.get(key);
  if (values == null) {
    return null;
  }
 else {
    Object object=values.remove(value);
    if (values.size() == 0) {
      _map.remove(key);
    }
    return object;
  }
}"
73493,"/** 
 * Create a new function for inferring the monotonicity concept over a relational node, given the operator at the node, the monotonicity ontology.
 * @param operator Token for the operator at this node.
 * @param monotonicityOntology The monotonicity ontology.
 * @throws IllegalActionException If a function cannot be created.
 */
public ASTPtRelationalNodeFunction(ptolemy.data.expr.Token operator,Ontology monotonicityOntology,Ontology domainOntology) throws IllegalActionException {
  super(""String_Node_Str"",2,monotonicityOntology,domainOntology);
  _operator=operator.toString();
}","/** 
 * Create a new function for inferring the monotonicity concept over a relational node, given the operator at the node, the monotonicity ontology.
 * @param operator Token for the operator at this node.
 * @param monotonicityOntology The monotonicity ontology.
 * @param domainOntology The ontology over which the expressioncontaining this relational node is defined.
 * @throws IllegalActionException If a function cannot be created.
 */
public ASTPtRelationalNodeFunction(ptolemy.data.expr.Token operator,Ontology monotonicityOntology,Ontology domainOntology) throws IllegalActionException {
  super(""String_Node_Str"",2,monotonicityOntology,domainOntology);
  _operator=operator.toString();
}"
73494,"/** 
 * Convert the argument token into a RecordToken having this type, if lossless conversion can be done.  The argument must be an RecordToken, and its type must be a subtype of this record type.  The argument token must have at least the fields of this type.  Extra fields in the argument token that are not in this type are removed.
 * @param token A token.
 * @return An RecordToken.
 * @exception IllegalActionException If lossless conversioncannot be done.
 */
public Token convert(Token token) throws IllegalActionException {
  if (!isCompatible(token.getType())) {
    throw new IllegalArgumentException(Token.notSupportedConversionMessage(token,this.toString()));
  }
  RecordToken recordToken=(RecordToken)token;
  Object[] labelArray=recordToken.labelSet().toArray();
  String[] labelStringArray=new String[labelArray.length];
  Token[] values=new Token[labelArray.length];
  for (int i=0; i < labelArray.length; i++) {
    String label=(String)labelArray[i];
    Token fieldToken=recordToken.get(label);
    Type newFieldType=get(label);
    if (newFieldType != null) {
      values[i]=newFieldType.convert(fieldToken);
    }
 else {
      values[i]=fieldToken;
    }
    labelStringArray[i]=label;
  }
  return new RecordToken(labelStringArray,values);
}","/** 
 * Convert the argument token into a RecordToken having this type, if lossless conversion can be done.  The argument must be a RecordToken, and its type must be a subtype of this record type.  The argument token must have at least the fields of this type.  Extra fields in the argument token that are not in this type are removed.
 * @param token A token.
 * @return An RecordToken.
 * @exception IllegalActionException If lossless conversioncannot be done.
 */
public Token convert(Token token) throws IllegalActionException {
  if (!isCompatible(token.getType())) {
    throw new IllegalArgumentException(Token.notSupportedConversionMessage(token,this.toString()));
  }
  RecordToken recordToken=(RecordToken)token;
  Object[] labelArray=recordToken.labelSet().toArray();
  String[] labelStringArray=new String[labelArray.length];
  Token[] values=new Token[labelArray.length];
  for (int i=0; i < labelArray.length; i++) {
    String label=(String)labelArray[i];
    Token fieldToken=recordToken.get(label);
    Type newFieldType=get(label);
    if (newFieldType != null) {
      values[i]=newFieldType.convert(fieldToken);
    }
 else {
      values[i]=fieldToken;
    }
    labelStringArray[i]=label;
  }
  if (recordToken instanceof OrderedRecordToken) {
    return new OrderedRecordToken(labelStringArray,values);
  }
 else {
    return new RecordToken(labelStringArray,values);
  }
}"
73495,"/** 
 * Return the value of this token as a string. The syntax is similar to the ML record: <code>{<i>label</i> = <i>value</i>, <i>label</i> = <i>value</i>, ...}</code> The record fields are listed in the their original order
 * @return A String beginning with ""{"" that contains label and valuepairs separated by commas, ending with ""}"".
 */
public String toString(){
  Object[] labelsObjects=_fields.keySet().toArray();
  StringBuffer stringRepresentation=new StringBuffer(""String_Node_Str"");
  int size=labelsObjects.length;
  for (int i=0; i < size; i++) {
    String label=(String)labelsObjects[i];
    String value=get(label).toString();
    if (i != 0) {
      stringRepresentation.append(""String_Node_Str"");
    }
    stringRepresentation.append(label + ""String_Node_Str"" + value);
  }
  return stringRepresentation.toString() + ""String_Node_Str"";
}","/** 
 * Return the value of this token as a string. The syntax is similar to that of a record, but using square braces instead of curly braces, <code>[<i>label</i> = <i>value</i>, <i>label</i> = <i>value</i>, ...]</code> The record fields are listed in the their original order
 * @return A String beginning with ""["" that contains label and valuepairs separated by commas, ending with ""]"".
 */
public String toString(){
  Object[] labelsObjects=_fields.keySet().toArray();
  StringBuffer stringRepresentation=new StringBuffer(""String_Node_Str"");
  int size=labelsObjects.length;
  for (int i=0; i < size; i++) {
    String label=(String)labelsObjects[i];
    String value=get(label).toString();
    if (i != 0) {
      stringRepresentation.append(""String_Node_Str"");
    }
    stringRepresentation.append(label + ""String_Node_Str"" + value);
  }
  return stringRepresentation.toString() + ""String_Node_Str"";
}"
73496,"/** 
 * Compare two concepts in the ontology. The arguments must be instances of   {@link Concept}, otherwise an exception will be thrown. This method returns one of ptolemy.graph.CPO.LOWER, ptolemy.graph.CPO.SAME, ptolemy.graph.CPO.HIGHER, ptolemy.graph.CPO.INCOMPARABLE, indicating the first argument is lower than, equal to, higher than, or incomparable with the second argument in the property hierarchy, respectively.
 * @param e1 An instance of {@link Concept}.
 * @param e2 An instance of {@link Concept}.
 * @return One of CPO.LOWER, CPO.SAME, CPO.HIGHER, CPO.INCOMPARABLE.
 * @exception IllegalArgumentException If one or both arguments are notinstances of  {@link Concept}.
 */
public int compare(Object e1,Object e2){
  if (!(e1 instanceof Concept) || !(e2 instanceof Concept)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + e1 + ""String_Node_Str""+ e2);
  }
  if ((e1 instanceof FiniteConcept) && (e2 instanceof FiniteConcept)) {
    return _dag.compare(e1,e2);
  }
 else   if (e1 instanceof InfiniteConcept) {
    try {
      return ((InfiniteConcept)e1).compare((Concept)e2);
    }
 catch (    IllegalActionException e) {
      return CPO.INCOMPARABLE;
    }
  }
 else {
    try {
      int oppositeResult=((InfiniteConcept)e2).compare((Concept)e1);
      return DirectedAcyclicGraph.reverseCompareCode(oppositeResult);
    }
 catch (    IllegalActionException e) {
      return CPO.INCOMPARABLE;
    }
  }
}","/** 
 * Compare two concepts in the ontology. The arguments must be instances of   {@link Concept}, otherwise an exception will be thrown. This method returns one of ptolemy.graph.CPO.LOWER, ptolemy.graph.CPO.SAME, ptolemy.graph.CPO.HIGHER, ptolemy.graph.CPO.INCOMPARABLE, indicating the first argument is lower than, equal to, higher than, or incomparable with the second argument in the property hierarchy, respectively.
 * @param e1 An instance of {@link Concept}.
 * @param e2 An instance of {@link Concept}.
 * @return One of CPO.LOWER, CPO.SAME, CPO.HIGHER, CPO.INCOMPARABLE.
 * @exception IllegalArgumentException If one or both arguments are notinstances of  {@link Concept}.
 */
public int compare(Object e1,Object e2){
  if (!(e1 instanceof Concept) || !(e2 instanceof Concept)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + e1 + ""String_Node_Str""+ e2);
  }
  if ((e1 instanceof FiniteConcept) && (e2 instanceof FiniteConcept)) {
    return _dag.compare(e1,e2);
  }
 else   if (e1 instanceof InfiniteConcept) {
    try {
      return ((InfiniteConcept)e1).compare((Concept)e2);
    }
 catch (    IllegalActionException e) {
      return CPO.INCOMPARABLE;
    }
  }
 else   if (e2 instanceof InfiniteConcept) {
    try {
      int oppositeResult=((InfiniteConcept)e2).compare((Concept)e1);
      return DirectedAcyclicGraph.reverseCompareCode(oppositeResult);
    }
 catch (    IllegalActionException e) {
      return CPO.INCOMPARABLE;
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + e1 + ""String_Node_Str""+ e2+ ""String_Node_Str"");
  }
}"
73497,"/** 
 * Compute the least upper bound (LUB) of two elements. The LUB of two elements is the least element in the concept graph that is greater than or the same as both of the two elements.
 * @param e1 An Object representing an element in this concept graph.
 * @param e2 An Object representing an element in this concept graph.
 * @return A Concept representing the LUB of the two specifiedelements, or <code>null</code> if the LUB does not exist.
 * @exception IllegalArgumentException If at least one of thespecified Objects is not an element of this concept graph.
 */
public Concept leastUpperBound(Object e1,Object e2){
  if (!(e1 instanceof Concept) || !(e2 instanceof Concept)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + e1 + ""String_Node_Str""+ e2);
  }
  if ((e1 instanceof FiniteConcept) && (e2 instanceof FiniteConcept)) {
    Concept lub=(Concept)_dag.leastUpperBound(e1,e2);
    if (lub instanceof FlatTokenRepresentativeConcept && !lub.equals(e1) && !lub.equals(e2)) {
      lub=leastUpperBound(((FiniteConcept)lub).getCoverSetAbove().toArray());
    }
    return lub;
  }
 else   if (e1 instanceof InfiniteConcept) {
    return ((InfiniteConcept)e1).leastUpperBound((Concept)e2);
  }
 else {
    return ((InfiniteConcept)e2).leastUpperBound((Concept)e1);
  }
}","/** 
 * Compute the least upper bound (LUB) of two elements. The LUB of two elements is the least element in the concept graph that is greater than or the same as both of the two elements.
 * @param e1 An Object representing an element in this concept graph.
 * @param e2 An Object representing an element in this concept graph.
 * @return A Concept representing the LUB of the two specifiedelements, or <code>null</code> if the LUB does not exist.
 * @exception IllegalArgumentException If at least one of thespecified Objects is not an element of this concept graph.
 */
public Concept leastUpperBound(Object e1,Object e2){
  if (!(e1 instanceof Concept) || !(e2 instanceof Concept)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + e1 + ""String_Node_Str""+ e2);
  }
  if ((e1 instanceof FiniteConcept) && (e2 instanceof FiniteConcept)) {
    Concept lub=(Concept)_dag.leastUpperBound(e1,e2);
    if (lub instanceof FlatTokenRepresentativeConcept && !lub.equals(e1) && !lub.equals(e2)) {
      lub=leastUpperBound(((FiniteConcept)lub).getCoverSetAbove().toArray());
    }
    return lub;
  }
 else   if (e1 instanceof InfiniteConcept) {
    return ((InfiniteConcept)e1).leastUpperBound((Concept)e2);
  }
 else   if (e2 instanceof InfiniteConcept) {
    return ((InfiniteConcept)e2).leastUpperBound((Concept)e1);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + e1 + ""String_Node_Str""+ e2+ ""String_Node_Str"");
  }
}"
73498,"/** 
 * Update the cached transition lists. This method is read-synchronized on the workspace.
 */
private void _updateTransitionLists(){
  try {
    workspace().getReadAccess();
    _nonpreemptiveTransitionList.clear();
    _preemptiveTransitionList.clear();
    _errorTransitionList.clear();
    Iterator transitions=outgoingPort.linkedRelationList().iterator();
    while (transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      if (transition.isPreemptive()) {
        _preemptiveTransitionList.add(transition);
      }
 else       if (transition.isErrorTransition()) {
        _errorTransitionList.add(transition);
        _nonpreemptiveTransitionList.add(transition);
      }
 else {
        _nonpreemptiveTransitionList.add(transition);
      }
    }
    _transitionListVersion=workspace().getVersion();
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Update the cached transition lists. This method is read-synchronized on the workspace.
 */
private void _updateTransitionLists(){
  try {
    workspace().getReadAccess();
    _nonpreemptiveTransitionList.clear();
    _preemptiveTransitionList.clear();
    _errorTransitionList.clear();
    Iterator transitions=outgoingPort.linkedRelationList().iterator();
    while (transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      if (transition.isPreemptive()) {
        _preemptiveTransitionList.add(transition);
      }
 else       if (transition.isErrorTransition()) {
        _errorTransitionList.add(transition);
      }
 else {
        _nonpreemptiveTransitionList.add(transition);
      }
    }
    _transitionListVersion=workspace().getVersion();
  }
  finally {
    workspace().doneReading();
  }
}"
73499,"/** 
 * Return a new time object whose time value is the multiple of that of this time object and of the specified time object. The two time objects are expected to have directors with the same time resolution. If they do not, then the returned result is a new Time object representing the sum of the double values of the two Time objects. This would not be as accurate.
 * @param time The time object contains the amount of time increment.
 * @return A new time object with the quantized and multiplied time value.
 * @exception ArithmeticException If the result is not a valid number(it is the multiple of positive and negative infinity).
 */
public Time multiply(Time time){
  if (time._isNegativeInfinite) {
    if (_isPositiveInfinite) {
      throw new ArithmeticException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      return NEGATIVE_INFINITY;
    }
  }
 else   if (time._isPositiveInfinite) {
    if (_isNegativeInfinite) {
      throw new ArithmeticException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      return POSITIVE_INFINITY;
    }
  }
 else   if (isInfinite()) {
    return this;
  }
  try {
    double resolution=_timeResolution();
    if (resolution != time._timeResolution()) {
      double thisValue=getDoubleValue();
      double thatValue=time.getDoubleValue();
      return new Time(_director,thisValue + thatValue);
    }
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e);
  }
  return new Time(_director,_timeValue.multiply(time._timeValue));
}","/** 
 * Return a new time object whose time value is the multiple of that of this time object and of the specified time object. The two time objects are expected to have directors with the same time resolution. If they do not, then the returned result is a new Time object representing the sum of the double values of the two Time objects. This would not be as accurate.
 * @param time The time object contains the amount of time increment.
 * @return A new time object with the quantized and multiplied time value.
 * @exception ArithmeticException If the result is not a valid number(it is the multiple of positive/negative infinity and zero).
 */
public Time multiply(Time time){
  if (time.isInfinite()) {
    if (time.isNegativeInfinite()) {
      if (isZero()) {
        throw new ArithmeticException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (isPositive()) {
        return NEGATIVE_INFINITY;
      }
 else {
        assert(isNegative());
        return POSITIVE_INFINITY;
      }
    }
 else     if (time.isPositiveInfinite()) {
      if (isZero()) {
        throw new ArithmeticException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (isPositive()) {
        return POSITIVE_INFINITY;
      }
 else {
        assert(isNegative());
        return NEGATIVE_INFINITY;
      }
    }
  }
 else   if (isInfinite()) {
    if (time.isZero()) {
      throw new ArithmeticException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_isNegativeInfinite) {
      if (time.isNegative()) {
        return POSITIVE_INFINITY;
      }
 else {
        assert(time.isPositive());
        return NEGATIVE_INFINITY;
      }
    }
 else {
      assert(_isPositiveInfinite);
      if (time.isNegative()) {
        return NEGATIVE_INFINITY;
      }
 else {
        assert(time.isPositive());
        return POSITIVE_INFINITY;
      }
    }
  }
  try {
    double resolution=_timeResolution();
    if (resolution != time._timeResolution()) {
      double thisValue=getDoubleValue();
      double thatValue=time.getDoubleValue();
      return new Time(_director,thisValue * thatValue);
    }
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e);
  }
  return new Time(_director,_timeValue.multiply(time._timeValue));
}"
73500,"/** 
 * Return whether the port is a networkPort. this method is default to return false, i.e., an output port to the outside of the platform is by default an actuator port.
 * @exception IllegalActionException If token of networkPort cannot beevaluated.
 */
public static boolean isNetworkPort(IOPort port) throws IllegalActionException {
  Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
  if (parameter != null) {
    return ((BooleanToken)parameter.getToken()).booleanValue();
  }
  return false;
}","/** 
 * Return whether the port is a networkPort. this method is default to return false, i.e., an output port to the outside of the platform is by default an actuator port.
 * @exception IllegalActionException If token of networkPort cannot beevaluated.
 */
public static boolean isNetworkPort(IOPort port) throws IllegalActionException {
  if (port.isInput()) {
    Double networkTotalDelay=_getNetworkTotalDelay(port);
    return (networkTotalDelay != null);
  }
  IllegalActionException up=new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  throw up;
}"
73501,"/** 
 * For all events in the sensorEventQueue, transfer input events that are ready. For all events that are currently sitting at the input port, if the realTimeDelay is 0.0, then transfer them into the platform, otherwise move them into the sensorEventQueue and call fireAt() of the executive director. In either case, if the input port is a networkPort, we make sure the timestamp of the data token transmitted is set to the timestamp of the local event associated with this token.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 * @exception IllegalActionException If the port is not an opaqueinput port, if the super class throws it, if physical tag cannot be evaluated, if token cannot be sent to the inside, or if there exists no token in the port, but hasToken() return true.
 */
protected boolean _transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferInputs(port);
  }
  boolean result=false;
  Tag physicalTag=getPhysicalTag();
  while (true) {
    if (_realTimeInputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent realTimeEvent=(RealTimeEvent)_realTimeInputEventQueue.peek();
    int compare=realTimeEvent.deliveryTag.compareTo(physicalTag);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      Parameter parameter=(Parameter)((NamedObj)realTimeEvent.port).getAttribute(""String_Node_Str"");
      double realTimeDelay=0.0;
      if (parameter != null) {
        realTimeDelay=((DoubleToken)parameter.getToken()).doubleValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"");
      }
      Time lastModelTime=_currentTime;
      if (isNetworkPort(realTimeEvent.port)) {
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
      }
 else {
        int lastMicrostep=_microstep;
        setTag(realTimeEvent.deliveryTag.timestamp.subtract(realTimeDelay),realTimeEvent.deliveryTag.microstep);
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
        setTag(lastModelTime,lastMicrostep);
      }
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + realTimeEvent.port.getName());
      }
      _sensorInterruptOccurred=true;
      result=true;
    }
 else {
      throw new IllegalActionException(realTimeEvent.port,""String_Node_Str"" + ""String_Node_Str"" + realTimeEvent.deliveryTag.timestamp + ""String_Node_Str""+ realTimeEvent.deliveryTag.microstep+ ""String_Node_Str""+ physicalTag.timestamp+ ""String_Node_Str""+ physicalTag.microstep);
    }
  }
  if (isNetworkPort(port)) {
    while (true) {
      if (!super._transferInputs(port)) {
        break;
      }
 else {
        result=true;
        _sensorInterruptOccurred=true;
      }
    }
  }
  Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
  double realTimeDelay=0.0;
  if (parameter != null) {
    realTimeDelay=((DoubleToken)parameter.getToken()).doubleValue();
  }
  if (realTimeDelay == 0.0) {
    Time lastModelTime=_currentTime;
    int lastMicrostep=_microstep;
    setTag(physicalTag.timestamp,physicalTag.microstep);
    if (super._transferInputs(port)) {
      _sensorInterruptOccurred=true;
      result=true;
    }
    setTag(lastModelTime,lastMicrostep);
  }
 else {
    for (int i=0; i < port.getWidth(); i++) {
      try {
        if (i < port.getWidthInside()) {
          if (port.hasToken(i)) {
            Token t=port.get(i);
            Time waitUntilTime=physicalTag.timestamp.add(realTimeDelay);
            RealTimeEvent realTimeEvent=new RealTimeEvent(port,i,t,new Tag(waitUntilTime,physicalTag.microstep));
            _realTimeInputEventQueue.add(realTimeEvent);
            result=true;
            Actor container=(Actor)getContainer();
            container.getExecutiveDirector().fireAt((Actor)container,waitUntilTime);
          }
        }
      }
 catch (      NoTokenException ex) {
        throw new IllegalActionException(this,ex,null);
      }
    }
  }
  return result;
}","/** 
 * For all events in the sensorEventQueue, transfer input events that are ready. For all events that are currently sitting at the input port, if the realTimeDelay is 0.0, then transfer them into the platform, otherwise move them into the sensorEventQueue and call fireAt() of the executive director. In either case, if the input port is a networkPort, we make sure the timestamp of the data token transmitted is set to the timestamp of the local event associated with this token.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 * @exception IllegalActionException If the port is not an opaqueinput port, if the super class throws it, if physical tag cannot be evaluated, if token cannot be sent to the inside, or if there exists no token in the port, but hasToken() return true.
 */
protected boolean _transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferInputs(port);
  }
  boolean result=false;
  Tag physicalTag=getPhysicalTag();
  while (true) {
    if (_realTimeInputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent realTimeEvent=(RealTimeEvent)_realTimeInputEventQueue.peek();
    int compare=realTimeEvent.deliveryTag.compareTo(physicalTag);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      Time lastModelTime=_currentTime;
      int lastMicrostep=_microstep;
      if (isNetworkPort(realTimeEvent.port)) {
        _realTimeInputEventQueue.poll();
        setTag(new Time(this,Double.NEGATIVE_INFINITY),0);
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
        setTag(lastModelTime,lastMicrostep);
      }
 else {
        setTag(realTimeEvent.timestampTag.timestamp,realTimeEvent.timestampTag.microstep);
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
        setTag(lastModelTime,lastMicrostep);
      }
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + realTimeEvent.port.getName());
      }
      _sensorInterruptOccurred=true;
      result=true;
    }
 else {
      throw new IllegalActionException(realTimeEvent.port,""String_Node_Str"" + ""String_Node_Str"" + realTimeEvent.deliveryTag.timestamp + ""String_Node_Str""+ realTimeEvent.deliveryTag.microstep+ ""String_Node_Str""+ physicalTag.timestamp+ ""String_Node_Str""+ physicalTag.microstep);
    }
  }
  Double inputDelay=_getNetworkDriverDelay(port);
  if (inputDelay == null) {
    inputDelay=_getRealTimeDelay(port);
  }
  if (inputDelay == null) {
    inputDelay=0.0;
  }
  if (inputDelay == 0.0) {
    Time lastModelTime=_currentTime;
    int lastMicrostep=_microstep;
    if (isNetworkPort(port)) {
      setTag(new Time(this,Double.NEGATIVE_INFINITY),0);
    }
 else {
      setTag(physicalTag.timestamp,physicalTag.microstep);
    }
    if (super._transferInputs(port)) {
      _sensorInterruptOccurred=true;
      result=true;
    }
    setTag(lastModelTime,lastMicrostep);
  }
 else {
    for (int i=0; i < port.getWidth(); i++) {
      try {
        if (i < port.getWidthInside()) {
          if (port.hasToken(i)) {
            Token t=port.get(i);
            Time waitUntilTime=physicalTag.timestamp.add(inputDelay);
            RealTimeEvent realTimeEvent=new RealTimeEvent(port,i,t,new Tag(waitUntilTime,physicalTag.microstep),new Tag(physicalTag.timestamp,physicalTag.microstep));
            _realTimeInputEventQueue.add(realTimeEvent);
            result=true;
            Actor container=(Actor)getContainer();
            container.getExecutiveDirector().fireAt((Actor)container,waitUntilTime);
          }
        }
      }
 catch (      NoTokenException ex) {
        throw new IllegalActionException(this,ex,null);
      }
    }
  }
  return result;
}"
73502,"/** 
 * Return the model time of the enclosing director, which is our model of time in the physical environment.
 * @return the model time of the enclosing director, which is a model oftime in the physical environment.
 * @exception IllegalActionException If enclosing director is nota DE of PtidesTopLevelDirector, or if the platform synchronization error is non-zero and the enclosing director is not a PtidesTopLevelDirector.
 */
public Tag getPhysicalTag() throws IllegalActionException {
  Tag tag=new Tag();
  Director director=this;
  while (director instanceof PtidesBasicDirector) {
    director=((Actor)director.getContainer().getContainer()).getDirector();
  }
  if (!(director instanceof DEDirector)) {
    IllegalActionException up=new IllegalActionException(director,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    throw up;
  }
  if (director instanceof PtidesTopLevelDirector) {
    tag.timestamp=((PtidesTopLevelDirector)director).getSimulatedPhysicalTime((Actor)getContainer());
    tag.microstep=((PtidesTopLevelDirector)director).getMicrostep();
  }
 else {
    if (getSynchronizationError() != 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    tag.timestamp=director.getModelTime();
    tag.microstep=((DEDirector)director).getMicrostep();
  }
  return tag;
}","/** 
 * Return the model time of the enclosing director, which is our model of time in the physical environment.
 * @return the model time of the enclosing director, which is a model oftime in the physical environment.
 * @exception IllegalActionException If enclosing director is nota DE of PtidesTopLevelDirector, or if the platform synchronization error is non-zero and the enclosing director is not a PtidesTopLevelDirector.
 */
public Tag getPhysicalTag() throws IllegalActionException {
  Tag tag=new Tag();
  Director executiveDrector=((Actor)getContainer()).getExecutiveDirector();
  if (executiveDrector instanceof PtidesTopLevelDirector) {
    tag.timestamp=((PtidesTopLevelDirector)executiveDrector).getSimulatedPhysicalTime((Actor)getContainer());
    tag.microstep=((PtidesTopLevelDirector)executiveDrector).getMicrostep();
  }
 else {
    if (getSynchronizationError() != 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    tag.timestamp=executiveDrector.getModelTime();
    tag.microstep=((DEDirector)executiveDrector).getMicrostep();
  }
  return tag;
}"
73503,"/** 
 * Override the _transferOutputs() function. First, for tokens that are stored in the actuator event queue and send them to the outside of the platform if physical time has arrived. The second step is to check if this port is a networkedOutput port, if it is, transfer data tokens immediately to the outside by calling super._transferOutputs(port). Finally, we check for current model time, if the current model time is equal to the physical time, we can send the tokens to the outside. Else if current model time has exceeded the physical time, and we still have tokens to transfer, then we have missed the deadline. Else if current model time has not arrived at the physical time, then we put the token along with the port and channel into the actuator event queue, and call fireAt of the executive director so we could send it at a later physical time.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 * @exception IllegalActionException If the port is not an opaqueinput port, if the super class throws it, if physical tag cannot be evaluated, if the token cannot be sent to the inside.     
 */
protected boolean _transferOutputs(IOPort port) throws IllegalActionException {
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferOutputs(port);
  }
  boolean result=false;
  Tag physicalTag=getPhysicalTag();
  int compare=0;
  while (true) {
    if (_realTimeOutputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent tokenEvent=(RealTimeEvent)_realTimeOutputEventQueue.peek();
    compare=tokenEvent.deliveryTag.compareTo(physicalTag);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      if (isNetworkPort(tokenEvent.port)) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
      _realTimeOutputEventQueue.poll();
      tokenEvent.port.send(tokenEvent.channel,tokenEvent.token);
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + tokenEvent.token + ""String_Node_Str""+ tokenEvent.port.getName());
      }
      result=true;
    }
 else     if (compare < 0) {
      throw new IllegalActionException(tokenEvent.port,""String_Node_Str"" + tokenEvent.deliveryTag.timestamp + ""String_Node_Str""+ tokenEvent.deliveryTag.microstep+ ""String_Node_Str""+ physicalTag.timestamp);
    }
  }
  if (isNetworkPort(port) || _transferImmediately(port)) {
    while (true) {
      if (!super._transferOutputs(port)) {
        break;
      }
 else {
        result=true;
      }
    }
  }
  compare=_currentTime.compareTo(physicalTag.timestamp);
  if (compare == 0) {
    result=result || super._transferOutputs(port);
  }
 else   if (compare < 0) {
    for (int i=0; i < port.getWidthInside(); i++) {
      if (port.hasTokenInside(i)) {
        throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + _currentTime + ""String_Node_Str""+ physicalTag.timestamp);
      }
    }
  }
 else {
    for (int i=0; i < port.getWidthInside(); i++) {
      try {
        if (port.hasTokenInside(i)) {
          Token t=port.getInside(i);
          RealTimeEvent tokenEvent=new RealTimeEvent(port,i,t,new Tag(_currentTime,_microstep));
          _realTimeOutputEventQueue.add(tokenEvent);
          Actor container=(Actor)getContainer();
          container.getExecutiveDirector().fireAt((Actor)container,_currentTime);
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
  }
  return result;
}","/** 
 * Override the _transferOutputs() function. First, for tokens that are stored in the actuator event queue and send them to the outside of the platform if physical time has arrived. Second, compare current model time with simulated physical time. if physical time is smaller than current model time, then deadline has been missed. Throw an exception unless the port is annotated with ignoreDeadline. If deadline has been missed and ignoreDeadline is true, or if the current model time is equal to the physical time,  or if the port is annotated with transferImmediate, we send the tokens to the outside. If current model time has not arrived at the physical time, we put the token along with the destination  port and channel into the actuator event queue, and call fireAt of the executive director so we could send it at a later physical time.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 * @exception IllegalActionException If the port is not an opaqueinput port, if the super class throws it, if physical tag cannot be evaluated, if the token cannot be sent to the inside.     
 */
protected boolean _transferOutputs(IOPort port) throws IllegalActionException {
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferOutputs(port);
  }
  boolean result=false;
  Tag physicalTag=getPhysicalTag();
  int compare=0;
  while (true) {
    if (_realTimeOutputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent tokenEvent=(RealTimeEvent)_realTimeOutputEventQueue.peek();
    compare=tokenEvent.deliveryTag.compareTo(physicalTag);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      _realTimeOutputEventQueue.poll();
      tokenEvent.port.send(tokenEvent.channel,tokenEvent.token);
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + tokenEvent.token + ""String_Node_Str""+ tokenEvent.port.getName());
      }
      result=true;
    }
 else     if (compare < 0) {
      throw new IllegalActionException(tokenEvent.port,""String_Node_Str"" + tokenEvent.deliveryTag.timestamp + ""String_Node_Str""+ tokenEvent.deliveryTag.microstep+ ""String_Node_Str""+ physicalTag.timestamp);
    }
  }
  compare=_currentTime.compareTo(physicalTag.timestamp);
  if (compare < 0 && !_ignoreDeadline(port)) {
    for (int i=0; i < port.getWidthInside(); i++) {
      if (port.hasTokenInside(i)) {
        throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + _currentTime + ""String_Node_Str""+ physicalTag.timestamp);
      }
    }
  }
 else   if (compare == 0 || _transferImmediately(port) || (compare < 0 && _ignoreDeadline(port))) {
    while (true) {
      if (!super._transferOutputs(port)) {
        break;
      }
 else {
        result=true;
      }
    }
  }
 else {
    assert(compare > 0);
    for (int i=0; i < port.getWidthInside(); i++) {
      try {
        if (port.hasTokenInside(i)) {
          Token t=port.getInside(i);
          RealTimeEvent tokenEvent=new RealTimeEvent(port,i,t,new Tag(_currentTime,_microstep),null);
          _realTimeOutputEventQueue.add(tokenEvent);
          Actor container=(Actor)getContainer();
          container.getExecutiveDirector().fireAt((Actor)container,_currentTime);
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
  }
  return result;
}"
73504,"/** 
 * Return whether we want to preempt the currently executing actor and instead execute the earliest event on the event queue. This base class returns false, indicating that the currently executing actor is never preempted.
 * @return False.
 * @exception IllegalActionException If false.
 */
protected boolean _preemptExecutingActor() throws IllegalActionException {
  return false;
}","/** 
 * Return whether we want to preempt the currently executing actor and instead execute the earliest event on the event queue. This base class returns false, indicating that the currently executing actor is never preempted.
 * @return False.
 * @exception IllegalActionException Not thrown in this base class. Derivedclasses may throw it if unable to preempt the currently exeucting actor.
 */
protected boolean _preemptExecutingActor() throws IllegalActionException {
  return false;
}"
73505,"/** 
 * Construct a structure that holds a real-time event. This event saves the token to be transmitted, the port and channel this token should be deliverd to, and the time this token should be delivered at.
 * @param port The destination port.
 * @param channel The destination channel.
 * @param token The token to be delivered.
 * @param tag The time of delivery of this token.
 */
public RealTimeEvent(IOPort port,int channel,Token token,Tag tag){
  this.port=port;
  this.channel=channel;
  this.token=token;
  this.deliveryTag=tag;
}","/** 
 * Construct a structure that holds a real-time event. This event saves the token to be transmitted, the port and channel this token should be deliverd to, and the time this token should be delivered at.
 * @param port The destination port.
 * @param channel The destination channel.
 * @param token The token to be delivered.
 * @param deliveryTag The time of delivery of this token.
 */
public RealTimeEvent(IOPort port,int channel,Token token,Tag deliveryTag,Tag timestampTag){
  this.port=port;
  this.channel=channel;
  this.token=token;
  this.deliveryTag=deliveryTag;
  this.timestampTag=timestampTag;
}"
73506,"/** 
 * Return the network delay of the port.
 * @param port The port with network delay.
 * @exception IllegalActionException If token of networkDelay parametercannot be evaluated.
 */
private static double _getNetworkDelay(IOPort port) throws IllegalActionException {
  Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
  if (parameter != null) {
    return ((DoubleToken)parameter.getToken()).doubleValue();
  }
  return 0.0;
}","/** 
 * Return the network delay of the port, if the parameter exists.
 * @param port The port with network delay.
 * @return 
 * @exception IllegalActionException If token of networkDelay parametercannot be evaluated.
 */
private static Double _getNetworkDelay(IOPort port) throws IllegalActionException {
  Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
  if (parameter != null) {
    return Double.valueOf(((DoubleToken)parameter.getToken()).doubleValue());
  }
  return null;
}"
73507,"/** 
 * Calculate the delayOffset for each input port in the model, and annotate the ports with these offsets. This causality analysis usually happens at the preinitialize phase. <p> Start from each input port that is connected to the outside of the platform (These input ports indicate sensors and network interfaces, call them startPorts), and traverse the graph until we reach the output port connected to the outside of the platform (actuators/network ports). For each input port in between, annotate it with a delayOffset parameter. This parameter is an array of doubles, where each double corresponds to the minimum delay offset for a particular channel of that port. This minimum delay offset is used for the safe to process analysis. <p> Note: for all transparent composite actors, the delayOffsets are not calculated for their input ports. Instead, the offsets are calculated and annotated for input ports that are inside of these actors.
 * @exception IllegalActionException If failed to clear or calculate delayOffset,cannot check whether the current port is a network port, cannot get the network delay of the current port, cannot get the real time delay of the current port, cannot get remote receivers, or cannot get the port channel for a particular receiver.
 */
protected void _calculateDelayOffsets() throws IllegalActionException {
  _visitedActors=new HashSet<Actor>();
  _clearDelayOffsets();
  _inputModelTimeDelays=new HashMap<IOPort,Map<Integer,SuperdenseDependency>>();
  _portDelays=new HashMap<IOPort,SuperdenseDependency>();
  if (getContainer() instanceof TypedCompositeActor) {
    for (    Actor actor : (List<Actor>)(((TypedCompositeActor)getContainer()).deepEntityList())) {
      for (      TypedIOPort inputPort : (List<TypedIOPort>)(actor.inputPortList())) {
        _portDelays.put(inputPort,SuperdenseDependency.OPLUS_IDENTITY);
      }
      for (      TypedIOPort outputPort : (List<TypedIOPort>)(actor.outputPortList())) {
        _portDelays.put(outputPort,SuperdenseDependency.OPLUS_IDENTITY);
      }
    }
    for (    TypedIOPort inputPort : (List<TypedIOPort>)(((Actor)getContainer()).inputPortList())) {
      SuperdenseDependency startDelay;
      if (isNetworkPort(inputPort)) {
        startDelay=SuperdenseDependency.valueOf(-_getNetworkDelay(inputPort),0);
      }
 else {
        startDelay=SuperdenseDependency.valueOf(-_getRealTimeDelay(inputPort),0);
      }
      _portDelays.put(inputPort,startDelay);
    }
    for (    TypedIOPort startPort : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).inputPortList())) {
      _traverseToCalcMinDelay(startPort);
    }
    for (    Actor actor : (List<Actor>)((CompositeActor)getContainer()).deepEntityList()) {
      if (!_visitedActors.contains(actor)) {
        for (        IOPort port : (List<IOPort>)actor.outputPortList()) {
          Receiver[][] remoteReceivers=port.getRemoteReceivers();
          for (int i=0; i < remoteReceivers.length; i++) {
            if (remoteReceivers[0] != null) {
              for (int j=0; j < remoteReceivers[i].length; j++) {
                Receiver receiver=remoteReceivers[i][j];
                IOPort receivePort=receiver.getContainer();
                int channel=receivePort.getChannelForReceiver(receiver);
                Map<Integer,SuperdenseDependency> channelDependency=(Map<Integer,SuperdenseDependency>)_inputModelTimeDelays.get(receivePort);
                if (channelDependency == null) {
                  channelDependency=new HashMap<Integer,SuperdenseDependency>();
                }
                channelDependency.put(Integer.valueOf(channel),SuperdenseDependency.OPLUS_IDENTITY);
                _inputModelTimeDelays.put(receivePort,channelDependency);
              }
            }
          }
        }
      }
    }
  }
  for (  IOPort inputPort : (Set<IOPort>)_inputModelTimeDelays.keySet()) {
    Map<Integer,SuperdenseDependency> channelDependency=(Map<Integer,SuperdenseDependency>)_inputModelTimeDelays.get(inputPort);
    double[] delayOffsets=new double[channelDependency.size()];
    for (    Integer portChannelMinDelay : channelDependency.keySet()) {
      delayOffsets[portChannelMinDelay.intValue()]=_calculateMinDelayForPortChannel(inputPort,portChannelMinDelay);
    }
    _setMinDelay(inputPort,delayOffsets);
  }
}","/** 
 * Calculate the delayOffset for each input port in the model, and annotate the ports with these offsets. This causality analysis usually happens at the preinitialize phase. <p> Start from each input port that is connected to the outside of the platform (These input ports indicate sensors and network interfaces, call them startPorts), and traverse the graph until we reach the output port connected to the outside of the platform (actuators/network ports). For each input port in between, annotate it with a delayOffset parameter. This parameter is an array of doubles, where each double corresponds to the minimum delay offset for a particular channel of that port. This minimum delay offset is used for the safe to process analysis. <p> Note: for all transparent composite actors, the delayOffsets are not calculated for their input ports. Instead, the offsets are calculated and annotated for input ports that are inside of these actors.
 * @exception IllegalActionException If failed to clear or calculate delayOffset,cannot check whether the current port is a network port, cannot get the network delay of the current port, cannot get the real time delay of the current port, cannot get remote receivers, or cannot get the port channel for a particular receiver.
 */
protected void _calculateDelayOffsets() throws IllegalActionException {
  _visitedActors=new HashSet<Actor>();
  _clearDelayOffsets();
  _inputModelTimeDelays=new HashMap<IOPort,Map<Integer,SuperdenseDependency>>();
  _portDelays=new HashMap<IOPort,SuperdenseDependency>();
  if (getContainer() instanceof TypedCompositeActor) {
    for (    Actor actor : (List<Actor>)(((TypedCompositeActor)getContainer()).deepEntityList())) {
      for (      TypedIOPort inputPort : (List<TypedIOPort>)(actor.inputPortList())) {
        _portDelays.put(inputPort,SuperdenseDependency.OPLUS_IDENTITY);
      }
      for (      TypedIOPort outputPort : (List<TypedIOPort>)(actor.outputPortList())) {
        _portDelays.put(outputPort,SuperdenseDependency.OPLUS_IDENTITY);
      }
    }
    for (    TypedIOPort inputPort : (List<TypedIOPort>)(((Actor)getContainer()).inputPortList())) {
      SuperdenseDependency startDelay;
      Double start=_getNetworkTotalDelay(inputPort);
      if (start == null) {
        start=_getRealTimeDelay(inputPort);
      }
      if (start == null) {
        start=0.0;
      }
      startDelay=SuperdenseDependency.valueOf(-start,0);
      _portDelays.put(inputPort,startDelay);
    }
    for (    TypedIOPort startPort : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).inputPortList())) {
      _traverseToCalcMinDelay(startPort);
    }
    for (    Actor actor : (List<Actor>)((CompositeActor)getContainer()).deepEntityList()) {
      if (!_visitedActors.contains(actor)) {
        for (        IOPort port : (List<IOPort>)actor.outputPortList()) {
          Receiver[][] remoteReceivers=port.getRemoteReceivers();
          for (int i=0; i < remoteReceivers.length; i++) {
            if (remoteReceivers[0] != null) {
              for (int j=0; j < remoteReceivers[i].length; j++) {
                Receiver receiver=remoteReceivers[i][j];
                IOPort receivePort=receiver.getContainer();
                int channel=receivePort.getChannelForReceiver(receiver);
                Map<Integer,SuperdenseDependency> channelDependency=(Map<Integer,SuperdenseDependency>)_inputModelTimeDelays.get(receivePort);
                if (channelDependency == null) {
                  channelDependency=new HashMap<Integer,SuperdenseDependency>();
                }
                channelDependency.put(Integer.valueOf(channel),SuperdenseDependency.OPLUS_IDENTITY);
                _inputModelTimeDelays.put(receivePort,channelDependency);
              }
            }
          }
        }
      }
    }
  }
  for (  IOPort inputPort : (Set<IOPort>)_inputModelTimeDelays.keySet()) {
    Map<Integer,SuperdenseDependency> channelDependency=(Map<Integer,SuperdenseDependency>)_inputModelTimeDelays.get(inputPort);
    double[] delayOffsets=new double[channelDependency.size()];
    for (    Integer portChannelMinDelay : channelDependency.keySet()) {
      delayOffsets[portChannelMinDelay.intValue()]=_calculateMinDelayForPortChannel(inputPort,portChannelMinDelay);
    }
    _setDelayOffset(inputPort,delayOffsets);
  }
}"
73508,"/** 
 * Instantiate new model structures to get ready for a simulation run. Call the preinitialize() method in the super class. The superclass instantiates an event queue structure, however, here a  PtidesListEventQueue structure is instantiated in its place.  We do this because a Ptides scheduler not only need to access the first event in the event queue, but all other events, in sorted order.  Also, the delayOffset used in the  safe-to-process analysis is calculated. This is followed by a check to see if sensors, actuators, and networks ports are annotated with the corresponding parameters, and whether they are connected to the  corresponding sensor/actuator/network actors. Finally, the parameter stopWhenQueueIsEmpty is set to false.  In general, Ptides models should never stop when the event queue is empty, because it can wait and react to future sensor input events.
 * @see #_calculateDelayOffsets
 * @exception IllegalActionException If delayOffset cannot be calculated, sensor/actuator/network consistency cannot be checked, or if the  super class throws it.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  _eventQueue=new PtidesListEventQueue();
  _calculateDelayOffsets();
  stopWhenQueueIsEmpty.setExpression(""String_Node_Str"");
  _checkSensorActuatorNetworkConsistency();
}","/** 
 * Instantiate new model structures to get ready for a simulation run. Check if the enclosing director is a DEDirector. If not, throw an exception. Call the preinitialize() method in the super class. The superclass instantiates an event queue structure, however, here a  PtidesListEventQueue structure is instantiated in its place.  We do this because a Ptides scheduler not only need to access the first event in the event queue, but all other events, in sorted order.  Also, the delayOffset used in the  safe-to-process analysis is calculated. This is followed by a check to see if sensors, actuators, and networks ports are annotated with the corresponding parameters, and whether they are connected to the  corresponding sensor/actuator/network actors. Finally, the parameter stopWhenQueueIsEmpty is set to false.  In general, Ptides models should never stop when the event queue is empty, because it can wait and react to future sensor input events.
 * @see #_calculateDelayOffsets
 * @exception IllegalActionException If the enclosing director doesnot exist or is not a DEDirector, delayOffset cannot be calculated,  sensor/actuator/network consistency cannot be checked, or if the  super class throws it.
 */
public void preinitialize() throws IllegalActionException {
  NamedObj container=getContainer();
  if (!(container instanceof Actor)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  if (executiveDirector == null || !(executiveDirector instanceof DEDirector)) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  super.preinitialize();
  _eventQueue=new PtidesListEventQueue();
  _checkSensorActuatorNetworkConsistency();
  _calculateDelayOffsets();
  stopWhenQueueIsEmpty.setExpression(""String_Node_Str"");
}"
73509,"/** 
 * Check the consistency of input/output ports. The following things are checked. <p> If an input port is a sensor port (no annotation), then it should not be connected to a NetworkInputDevice. Also, it should not have a networkDelay attribute. </p><p> If an input port is a network port (annotated networkPort), then it should always be connected to a NetworkInputDeivce. Also, it should not have a realTimeDelay attribute. </p>
 * @exception IllegalActionException If sensor ports are connected toNetworkInputDevice or have a networkDelay attribute; Or if a network port is not connected to a NetworkInputDeivce, or it has a realTimeDelay attribute.
 */
protected void _checkSensorActuatorNetworkConsistency() throws IllegalActionException {
  if (getContainer() instanceof TypedCompositeActor) {
    for (    TypedIOPort port : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).inputPortList())) {
      for (      TypedIOPort sinkPort : (List<TypedIOPort>)port.deepInsidePortList()) {
        if (isNetworkPort(port)) {
          if (sinkPort.isInput() && !(sinkPort.getContainer() instanceof NetworkInputDevice)) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
 else {
          Parameter parameter=(Parameter)getAttribute(""String_Node_Str"");
          if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0) && sinkPort.isInput()&& !(sinkPort.getContainer() instanceof SensorInputDevice)) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          if (sinkPort.isInput() && sinkPort.getContainer() instanceof NetworkInputDevice) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
    }
    for (    TypedIOPort port : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).outputPortList())) {
      for (      TypedIOPort sourcePort : (List<TypedIOPort>)port.deepInsidePortList()) {
        if (isNetworkPort(port)) {
          if (sourcePort.isOutput() && !(sourcePort.getContainer() instanceof NetworkOutputDevice)) {
            throw new IllegalActionException(port,sourcePort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
 else {
          Parameter parameter=(Parameter)getAttribute(""String_Node_Str"");
          if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0) && sourcePort.isInput()&& !(sourcePort.getContainer() instanceof ActuatorOutputDevice)) {
            throw new IllegalActionException(port,sourcePort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          if (sourcePort.isOutput() && sourcePort.getContainer() instanceof NetworkOutputDevice) {
            throw new IllegalActionException(port,sourcePort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
    }
  }
}","/** 
 * Check the consistency of input/output ports. The following things are checked. <p> If an input port is a sensor port (no annotation), then it should not be connected to a NetworkInputDevice. Also, it should not have a networkDelay attribute. </p><p> If an input port is a network port (annotated networkPort), then it should always be connected to a NetworkInputDeivce. Also, it should not have a realTimeDelay attribute. </p>
 * @exception IllegalActionException If sensor ports are connected toNetworkInputDevice or have a networkDelay attribute; Or if a network port is not connected to a NetworkInputDeivce, or it has a realTimeDelay attribute.
 */
protected void _checkSensorActuatorNetworkConsistency() throws IllegalActionException {
  if (getContainer() instanceof TypedCompositeActor) {
    for (    TypedIOPort port : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).inputPortList())) {
      boolean sensorPort=false;
      boolean networkPort=false;
      if (_getNetworkTotalDelay(port) != null) {
        networkPort=true;
      }
      if (_getRealTimeDelay(port) != null) {
        sensorPort=true;
      }
      if (sensorPort && networkPort) {
        throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      for (      TypedIOPort sinkPort : (List<TypedIOPort>)port.deepInsidePortList()) {
        if (isNetworkPort(port)) {
          if (sinkPort.isInput() && !(sinkPort.getContainer() instanceof NetworkInputDevice)) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
 else {
          Parameter parameter=(Parameter)getAttribute(""String_Node_Str"");
          if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0) && sinkPort.isInput()&& !(sinkPort.getContainer() instanceof SensorInputDevice)) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          if (sinkPort.isInput() && sinkPort.getContainer() instanceof NetworkInputDevice) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
    }
    for (    TypedIOPort port : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).outputPortList())) {
      for (      TypedIOPort sourcePort : (List<TypedIOPort>)port.deepInsidePortList()) {
        Parameter parameter=(Parameter)getAttribute(""String_Node_Str"");
        if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0) && sourcePort.isInput()&& !((sourcePort.getContainer() instanceof ActuatorOutputDevice) || (sourcePort.getContainer() instanceof NetworkOutputDevice))) {
          throw new IllegalActionException(port,sourcePort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
  }
}"
73510,"/** 
 * Return the executionTime parameter.
 * @param port The port at which execution time is denoted.
 * @param actor an Actor object.
 * @return executionTime parameter.
 * @exception IllegalActionException If excution time fromPtidesActorProperties cannot be obtained.
 */
protected static double _getExecutionTime(IOPort port,Actor actor) throws IllegalActionException {
  Double result=null;
  if (port != null) {
    result=PtidesActorProperties.getExecutionTime(port);
  }
  if (result != null) {
    return result.doubleValue();
  }
 else {
    return PtidesActorProperties.getExecutionTime(actor);
  }
}","/** 
 * Return the executionTime parameter.
 * @param port The port at which execution time is denoted.
 * @param actor an Actor object.
 * @return executionTime parameter.
 * @exception IllegalActionException If excution time from PtidesActorProperties cannot be obtained.
 */
protected static double _getExecutionTime(IOPort port,Actor actor) throws IllegalActionException {
  Double result=null;
  if (port != null) {
    result=PtidesActorProperties.getExecutionTime(port);
  }
  if (result != null) {
    return result.doubleValue();
  }
 else {
    return PtidesActorProperties.getExecutionTime(actor);
  }
}"
73511,"/** 
 * Create new variables, initialize the actors and request a refiring at the current time of the executive director. This overrides the base class to throw an exception if there is no executive director.
 * @exception IllegalActionException If the superclass throwsit or if there is no executive director.
 */
public void initialize() throws IllegalActionException {
  _currentlyExecutingStack=new Stack<DoubleTimedEvent>();
  _realTimeInputEventQueue=new PriorityQueue<RealTimeEvent>();
  _realTimeOutputEventQueue=new PriorityQueue<RealTimeEvent>();
  _lastConsumedTag=new HashMap<NamedObj,Tag>();
  _pureEventDeadlines=new HashMap<NamedObj,Time>();
  _pureEventDelays=new HashMap<NamedObj,Time>();
  _pureEventSourcePorts=new HashMap<NamedObj,IOPort>();
  _physicalTimeExecutionStarted=null;
  _schedulerFinishTime=new Time(this,Double.NEGATIVE_INFINITY);
  _sensorInterruptOccurred=false;
  _scheduleNewEvent=false;
  _timedInterruptWakeUpTime=null;
  _lastExecutingActor=null;
  super.initialize();
  NamedObj container=getContainer();
  if (!(container instanceof Actor)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  if (executiveDirector == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  executiveDirector.fireAtCurrentTime((Actor)container);
  _setIcon(_getIdleIcon(),true);
}","/** 
 * Create new variables, initialize the actors and request a refiring at the current time of the executive director. This overrides the base class to throw an exception if there is no executive director.
 * @exception IllegalActionException If the superclass throwsit or if there is no executive director.
 */
public void initialize() throws IllegalActionException {
  _currentlyExecutingStack=new Stack<DoubleTimedEvent>();
  _realTimeInputEventQueue=new PriorityQueue<RealTimeEvent>();
  _realTimeOutputEventQueue=new PriorityQueue<RealTimeEvent>();
  _lastConsumedTag=new HashMap<NamedObj,Tag>();
  _pureEventDeadlines=new HashMap<NamedObj,Time>();
  _pureEventDelays=new HashMap<NamedObj,Time>();
  _pureEventSourcePorts=new HashMap<NamedObj,IOPort>();
  _physicalTimeExecutionStarted=null;
  _schedulerFinishTime=new Time(this,Double.NEGATIVE_INFINITY);
  _sensorInterruptOccurred=false;
  _scheduleNewEvent=false;
  _timedInterruptWakeUpTime=null;
  _lastExecutingActor=null;
  super.initialize();
  (((Actor)getContainer()).getExecutiveDirector()).fireAtCurrentTime((Actor)getContainer());
  _setIcon(_getIdleIcon(),true);
}"
73512,"/** 
 * Return the value stored in realTimeDelay parameter.
 * @param port The port the realTimeDelay is associated with.
 * @return realTimeDelay parameter
 * @exception IllegalActionException If the token of the realTimeDelayparameter cannot be evaluated.
 */
protected double _getRealTimeDelay(IOPort port) throws IllegalActionException {
  Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
  if (parameter != null) {
    return ((DoubleToken)parameter.getToken()).doubleValue();
  }
 else {
    return 0.0;
  }
}","/** 
 * Return the value stored in realTimeDelay parameter.
 * @param port The port the realTimeDelay is associated with.
 * @return realTimeDelay parameter
 * @exception IllegalActionException If the token of the realTimeDelayparameter cannot be evaluated.
 */
private static Double _getRealTimeDelay(IOPort port) throws IllegalActionException {
  Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
  if (parameter != null) {
    return Double.valueOf(((DoubleToken)parameter.getToken()).doubleValue());
  }
  return null;
}"
73513,"/** 
 * Returns the event that was selected to preempt in _preemptExecutingActor. If no event was selected, return the event of smallest deadline that is safe to process. This is when _eventToProcess is last used in this iteration, so it should be cleared to null, so that later iterations will not see the same events stored in _eventToProcess.
 */
protected PtidesEvent _getNextSafeEvent() throws IllegalActionException {
  PtidesEvent tempEvent;
  if (_eventToProcess == null) {
    _getSmallestDeadlineSafeEventFromQueue();
  }
  tempEvent=_eventToProcess;
  _eventToProcess=null;
  return tempEvent;
}","/** 
 * Return the event that was selected to preempt in _preemptExecutingActor. If no event was selected, return the event of smallest deadline that is safe to process. This is when _eventToProcess is last used in this iteration, so it should be cleared to null, so that later iterations will not see the same events stored in _eventToProcess.
 */
protected PtidesEvent _getNextSafeEvent() throws IllegalActionException {
  PtidesEvent tempEvent;
  if (_eventToProcess == null) {
    _getSmallestDeadlineSafeEventFromQueue();
  }
  tempEvent=_eventToProcess;
  _eventToProcess=null;
  return tempEvent;
}"
73514,"/** 
 * Clears what's stored in _eventToProcess, and call the super method of preinitialize.
 * @exception IllegalActionException If the superclass throwsit or if there is no executive director.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  _eventToProcess=null;
  _calculateDeadline();
}","/** 
 * Clear what's stored in _eventToProcess, and call the super method of preinitialize.
 * @exception IllegalActionException If the superclass throwsit or if there is no executive director.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  _eventToProcess=null;
  _calculateDeadline();
}"
73515,"/** 
 * Sets the relativeDeadline parameter for an input port.
 * @param inputPort The port to set the parameter.
 * @param dependency The value of the relativeDeadline to be set.
 * @exception IllegalActionException If unsuccessful in getting the attribute.
 */
protected void _setDeadline(IOPort inputPort,SuperdenseDependency dependency) throws IllegalActionException {
  Parameter parameter=(Parameter)(inputPort).getAttribute(""String_Node_Str"");
  if (parameter == null) {
    try {
      parameter=new Parameter(inputPort,""String_Node_Str"");
    }
 catch (    NameDuplicationException e) {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
  parameter.setToken(new DoubleToken(dependency.timeValue()));
}","/** 
 * Set the relativeDeadline parameter for an input port.
 * @param inputPort The port to set the parameter.
 * @param dependency The value of the relativeDeadline to be set.
 * @exception IllegalActionException If unsuccessful in getting the attribute.
 */
protected void _setDeadline(IOPort inputPort,SuperdenseDependency dependency) throws IllegalActionException {
  Parameter parameter=(Parameter)(inputPort).getAttribute(""String_Node_Str"");
  if (parameter == null) {
    try {
      parameter=new Parameter(inputPort,""String_Node_Str"");
    }
 catch (    NameDuplicationException e) {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
  parameter.setToken(new DoubleToken(dependency.timeValue()));
}"
73516,"/** 
 * Calculates the deadline for each channel in each input port within the composite actor governed by this Ptides director. Deadlines are calculated with only model time delays, not worst-case-execution-times (WCET).
 * @exception IllegalActionException when ports that are both input/output ports exist.
 */
protected void _calculateDeadline() throws IllegalActionException {
  HashMap portDeadlines=new HashMap<IOPort,SuperdenseDependency>();
  for (  Actor actor : (List<Actor>)(((TypedCompositeActor)getContainer()).deepEntityList())) {
    for (    TypedIOPort inputPort : (List<TypedIOPort>)(actor.inputPortList())) {
      portDeadlines.put(inputPort,SuperdenseDependency.OPLUS_IDENTITY);
    }
    for (    TypedIOPort outputPort : (List<TypedIOPort>)(actor.outputPortList())) {
      portDeadlines.put(outputPort,SuperdenseDependency.OPLUS_IDENTITY);
    }
  }
  for (  TypedIOPort outputPort : (List<TypedIOPort>)(((Actor)getContainer()).outputPortList())) {
    SuperdenseDependency startDelay=SuperdenseDependency.OTIMES_IDENTITY;
    portDeadlines.put(outputPort,startDelay);
  }
  for (  TypedIOPort startPort : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).outputPortList())) {
    HashMap localPortDeadlines=new HashMap<IOPort,SuperdenseDependency>(portDeadlines);
    PriorityQueue distQueue=new PriorityQueue<PortDependency>();
    distQueue.add(new PortDependency(startPort,(SuperdenseDependency)localPortDeadlines.get(startPort)));
    while (!distQueue.isEmpty()) {
      PortDependency portDependency=(PortDependency)distQueue.remove();
      IOPort port=portDependency.port;
      SuperdenseDependency prevDependency=(SuperdenseDependency)portDependency.dependency;
      Actor actor=(Actor)port.getContainer();
      if (port.isInput() && port.isOutput()) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (actor != getContainer()) {
        if (port.isOutput()) {
          Collection<IOPort> inputs=_finiteDependentPorts(port);
          for (          IOPort inputPort : inputs) {
            SuperdenseDependency minimumDelay=(SuperdenseDependency)_getDependency(inputPort,port);
            SuperdenseDependency modelTime=(SuperdenseDependency)prevDependency.oTimes(minimumDelay);
            if (((SuperdenseDependency)localPortDeadlines.get(inputPort)).compareTo(modelTime) > 0) {
              localPortDeadlines.put(inputPort,modelTime);
              distQueue.add(new PortDependency(inputPort,modelTime));
            }
          }
        }
 else {
          for (          IOPort sourcePort : (List<IOPort>)port.sourcePortList()) {
            if (sourcePort.getContainer() != getContainer()) {
              if (((SuperdenseDependency)localPortDeadlines.get(sourcePort)).compareTo(prevDependency) > 0) {
                localPortDeadlines.put(sourcePort,prevDependency);
                distQueue.add(new PortDependency(sourcePort,prevDependency));
              }
            }
          }
        }
      }
 else       if (port == startPort) {
        for (        IOPort sourcePort : (List<IOPort>)port.deepInsidePortList()) {
          if (sourcePort.getContainer() != getContainer()) {
            if (((SuperdenseDependency)localPortDeadlines.get(sourcePort)).compareTo(prevDependency) > 0) {
              localPortDeadlines.put(sourcePort,prevDependency);
              distQueue.add(new PortDependency(sourcePort,prevDependency));
            }
          }
        }
      }
    }
    portDeadlines=localPortDeadlines;
  }
  for (  IOPort port : (Set<IOPort>)(portDeadlines.keySet())) {
    if (port.isInput()) {
      SuperdenseDependency dependency=(SuperdenseDependency)(portDeadlines.get(port));
      _setDeadline(port,dependency);
    }
  }
}","/** 
 * Calculate the deadline for each channel in each input port within the composite actor governed by this Ptides director. Deadlines are calculated with only model time delays, not worst-case-execution-times (WCET).
 * @exception IllegalActionException when ports that are both input/output ports exist.
 */
protected void _calculateDeadline() throws IllegalActionException {
  HashMap portDeadlines=new HashMap<IOPort,SuperdenseDependency>();
  for (  Actor actor : (List<Actor>)(((TypedCompositeActor)getContainer()).deepEntityList())) {
    for (    TypedIOPort inputPort : (List<TypedIOPort>)(actor.inputPortList())) {
      portDeadlines.put(inputPort,SuperdenseDependency.OPLUS_IDENTITY);
    }
    for (    TypedIOPort outputPort : (List<TypedIOPort>)(actor.outputPortList())) {
      portDeadlines.put(outputPort,SuperdenseDependency.OPLUS_IDENTITY);
    }
  }
  for (  TypedIOPort outputPort : (List<TypedIOPort>)(((Actor)getContainer()).outputPortList())) {
    SuperdenseDependency startDelay=SuperdenseDependency.OTIMES_IDENTITY;
    portDeadlines.put(outputPort,startDelay);
  }
  for (  TypedIOPort startPort : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).outputPortList())) {
    HashMap localPortDeadlines=new HashMap<IOPort,SuperdenseDependency>(portDeadlines);
    PriorityQueue distQueue=new PriorityQueue<PortDependency>();
    distQueue.add(new PortDependency(startPort,(SuperdenseDependency)localPortDeadlines.get(startPort)));
    while (!distQueue.isEmpty()) {
      PortDependency portDependency=(PortDependency)distQueue.remove();
      IOPort port=portDependency.port;
      SuperdenseDependency prevDependency=(SuperdenseDependency)portDependency.dependency;
      Actor actor=(Actor)port.getContainer();
      if (port.isInput() && port.isOutput()) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (actor != getContainer()) {
        if (port.isOutput()) {
          Collection<IOPort> inputs=_finiteDependentPorts(port);
          for (          IOPort inputPort : inputs) {
            SuperdenseDependency minimumDelay=(SuperdenseDependency)_getDependency(inputPort,port);
            SuperdenseDependency modelTime=(SuperdenseDependency)prevDependency.oTimes(minimumDelay);
            if (((SuperdenseDependency)localPortDeadlines.get(inputPort)).compareTo(modelTime) > 0) {
              localPortDeadlines.put(inputPort,modelTime);
              distQueue.add(new PortDependency(inputPort,modelTime));
            }
          }
        }
 else {
          for (          IOPort sourcePort : (List<IOPort>)port.sourcePortList()) {
            if (sourcePort.getContainer() != getContainer()) {
              if (((SuperdenseDependency)localPortDeadlines.get(sourcePort)).compareTo(prevDependency) > 0) {
                localPortDeadlines.put(sourcePort,prevDependency);
                distQueue.add(new PortDependency(sourcePort,prevDependency));
              }
            }
          }
        }
      }
 else       if (port == startPort) {
        for (        IOPort sourcePort : (List<IOPort>)port.deepInsidePortList()) {
          if (sourcePort.getContainer() != getContainer()) {
            if (((SuperdenseDependency)localPortDeadlines.get(sourcePort)).compareTo(prevDependency) > 0) {
              localPortDeadlines.put(sourcePort,prevDependency);
              distQueue.add(new PortDependency(sourcePort,prevDependency));
            }
          }
        }
      }
    }
    portDeadlines=localPortDeadlines;
  }
  for (  IOPort port : (Set<IOPort>)(portDeadlines.keySet())) {
    if (port.isInput()) {
      SuperdenseDependency dependency=(SuperdenseDependency)(portDeadlines.get(port));
      _setDeadline(port,dependency);
    }
  }
}"
73517,"/** 
 * This method finds the event in the queue that is of the smallest deadline The event found is stored in _eventToProcess. It then stores the index of the event in _peekingIndex.
 * @return false if no event is found. returns false, otherwise returns true.
 * @exception IllegalActionException
 */
protected boolean _getSmallestDeadlineSafeEventFromQueue() throws IllegalActionException {
  _eventToProcess=null;
  Time smallestDeadline=new Time(this,Double.POSITIVE_INFINITY);
  int result=0;
  for (int eventIndex=0; eventIndex < _eventQueue.size(); eventIndex++) {
    PtidesEvent event=((PtidesListEventQueue)_eventQueue).get(eventIndex);
    if (event.isPureEvent()) {
      if (event.actor().inputPortList().size() == 0) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + event.actor() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
    if (_safeToProcess(event) && !_currentlyFiring(event.actor())) {
      Time absNextDeadline=_getAbsoluteDeadline(event);
      if (absNextDeadline.compareTo(smallestDeadline) < 0) {
        smallestDeadline=absNextDeadline;
        _eventToProcess=event;
        result=eventIndex;
      }
 else       if (absNextDeadline.compareTo(smallestDeadline) == 0) {
        if (_eventToProcess == null) {
          _eventToProcess=event;
          result=eventIndex;
        }
      }
    }
  }
  if (_eventToProcess == null) {
    return false;
  }
 else {
    _peekingIndex=result;
    return true;
  }
}","/** 
 * Find the event in the queue that is of the smallest deadline The event found is stored in _eventToProcess. It then stores the index of the event in _peekingIndex.
 * @return false if no event is found. returns false, otherwise returns true.
 * @exception IllegalActionException
 */
protected boolean _getSmallestDeadlineSafeEventFromQueue() throws IllegalActionException {
  _eventToProcess=null;
  Time smallestDeadline=new Time(this,Double.POSITIVE_INFINITY);
  int result=0;
  for (int eventIndex=0; eventIndex < _eventQueue.size(); eventIndex++) {
    PtidesEvent event=((PtidesListEventQueue)_eventQueue).get(eventIndex);
    if (event.isPureEvent()) {
      if (event.actor().inputPortList().size() == 0) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + event.actor() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
    if (_safeToProcess(event) && !_currentlyFiring(event.actor())) {
      Time absNextDeadline=_getAbsoluteDeadline(event);
      if (absNextDeadline.compareTo(smallestDeadline) < 0) {
        smallestDeadline=absNextDeadline;
        _eventToProcess=event;
        result=eventIndex;
      }
 else       if (absNextDeadline.compareTo(smallestDeadline) == 0) {
        if (_eventToProcess == null) {
          _eventToProcess=event;
          result=eventIndex;
        }
      }
    }
  }
  if (_eventToProcess == null) {
    return false;
  }
 else {
    _peekingIndex=result;
    return true;
  }
}"
73518,"/** 
 * Perform a check to see if this device is connected to a network port on the outside. If so, throw an exception. Also call preinitialize of the super class.
 * @exception IllegalActionException If there are no outside sinkports, or if any of the outside sink ports is a network port.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  Parameter parameter=(Parameter)getDirector().getAttribute(""String_Node_Str"");
  if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0)) {
    boolean flag=false;
    for (    IOPort output : (List<IOPort>)outputPortList()) {
      for (      IOPort sinkPort : (List<IOPort>)output.sinkPortList()) {
        if (sinkPort.getContainer() == getContainer()) {
          flag=true;
          if (PtidesBasicDirector.isNetworkPort(sinkPort)) {
            throw new IllegalActionException(this,sinkPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
    }
    if (!flag) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}","/** 
 * Perform a check to see if this device is connected to a network port on the outside. If so, throw an exception. Also call preinitialize of the super class.
 * @exception IllegalActionException If there are no outside sinkports, or if any of the outside sink ports is a network port.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  Parameter parameter=(Parameter)getDirector().getAttribute(""String_Node_Str"");
  if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0)) {
    boolean flag=false;
    for (    IOPort output : (List<IOPort>)outputPortList()) {
      for (      IOPort sinkPort : (List<IOPort>)output.sinkPortList()) {
        if (sinkPort.getContainer() == getContainer()) {
          flag=true;
          break;
        }
      }
    }
    if (!flag) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
}"
73519,"/** 
 * Perform a check to see if this device is connected to a network port on the outside. If not, throw an exception. Also call preinitialize of the super class.
 * @exception IllegalActionException If there are no outside sinkports, or if any of the outside sink ports is not a network port.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  boolean flag=false;
  for (  IOPort output : (List<IOPort>)outputPortList()) {
    for (    IOPort sinkPort : (List<IOPort>)output.sinkPortList()) {
      if (sinkPort.getContainer() == getContainer()) {
        flag=true;
        if (!PtidesBasicDirector.isNetworkPort(sinkPort)) {
          throw new IllegalActionException(this,sinkPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
  if (!flag) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Perform a check to see if this device is connected to a network port on the outside. If not, throw an exception. Also call preinitialize of the super class.
 * @exception IllegalActionException If there are no outside sinkports, or if any of the outside sink ports is not a network port.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  boolean flag=false;
  for (  IOPort output : (List<IOPort>)outputPortList()) {
    for (    IOPort sinkPort : (List<IOPort>)output.sinkPortList()) {
      if (sinkPort.getContainer() == getContainer()) {
        flag=true;
        break;
      }
    }
  }
  if (!flag) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
}"
73520,"/** 
 * Perform a check to see if this device is connected to a network port on the outside. If so, throw an exception. Also call preinitialize of the super class.
 * @exception IllegalActionException If there are no outside sourceports, or if any of the outside source ports is a network port.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  Parameter parameter=(Parameter)getDirector().getAttribute(""String_Node_Str"");
  if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0)) {
    boolean flag=false;
    for (    IOPort input : (List<IOPort>)inputPortList()) {
      for (      IOPort sourcePort : (List<IOPort>)input.sourcePortList()) {
        if (sourcePort.getContainer() == getContainer()) {
          flag=true;
          if (PtidesBasicDirector.isNetworkPort(sourcePort)) {
            throw new IllegalActionException(this,sourcePort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
    }
    if (!flag) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}","/** 
 * Perform a check to see if this device is connected to a network port on the outside. If so, throw an exception. Also call preinitialize of the super class.
 * @exception IllegalActionException If there are no outside sourceports, or if any of the outside source ports is a network port.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  Parameter parameter=(Parameter)getDirector().getAttribute(""String_Node_Str"");
  if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0)) {
    boolean flag=false;
    for (    IOPort input : (List<IOPort>)inputPortList()) {
      for (      IOPort sourcePort : (List<IOPort>)input.sourcePortList()) {
        if (sourcePort.getContainer() == getContainer()) {
          flag=true;
          if (PtidesBasicDirector.isNetworkPort(sourcePort)) {
            throw new IllegalActionException(this,sourcePort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
    }
    if (!flag) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}"
73521,"/** 
 * Placeholder for book keeping procedures after actor firing. This method does nothing in this class, instead it's a placeholder for subclasses to override.
 */
protected void _actorFired(){
}","/** 
 * Placeholder for book keeping procedures after actor firing. This method does nothing in this class, instead it's a placeholder for subclasses to override.
 * @throws IllegalActionException If false.
 */
protected void _actorFired() throws IllegalActionException {
}"
73522,"/** 
 * Place holder that gets the next actuation event. This method does nothing here. It's used for the Ptides subclass.
 */
protected void _getNextActuationEvent(){
}","/** 
 * Place holder that gets the next actuation event. This method does nothing here. It's used for the Ptides subclass.
 * @throws IllegalActionException If false.
 */
protected void _getNextActuationEvent() throws IllegalActionException {
}"
73523,"/** 
 * Perform book keeping after actor firing. This procedure consist of two actions: <ol> <li>An actor has just been fired. A token destined to the outside of the Ptides platform could have been produced. If so, the corresponding  event is taken out of event queue, and the token is placed at the actuator/network port, ready to be transferred to the outside.</li> <li> Bookkeeping structures that keeps track of which actor has just fired are cleared.</li> </ol>
 */
protected void _actorFired(){
  _getNextActuationEvent();
  if (_lastActorFired != null) {
    _pureEventDeadlines.remove(_lastActorFired);
    _pureEventDelays.remove(_lastActorFired);
    _pureEventSourcePorts.remove(_lastActorFired);
  }
}","/** 
 * Perform book keeping after actor firing. This procedure consist of two actions: <ol> <li>An actor has just been fired. A token destined to the outside of the Ptides platform could have been produced. If so, the corresponding  event is taken out of event queue, and the token is placed at the actuator/network port, ready to be transferred to the outside.</li> <li> Bookkeeping structures that keeps track of which actor has just fired are cleared.</li> </ol>
 * @throws IllegalActionException If unable to get next actuation event.
 */
protected void _actorFired() throws IllegalActionException {
  _getNextActuationEvent();
  if (_lastActorFired != null) {
    _pureEventDeadlines.remove(_lastActorFired);
    _pureEventDelays.remove(_lastActorFired);
    _pureEventSourcePorts.remove(_lastActorFired);
  }
}"
73524,"/** 
 * Return the actor to fire in this iteration, or null if no actor should be fired. In this base class, this method first checks whether the top event from the event queue is destined for an actuator. If it is, then we check if physical time has reached the timestamp of the actuation event. If it has, then we fire the actuator. If it has not, then we take the actuator event from the event queue and put it onto the _realTimeEventQueue, and call fireAt() of the executive director. We then check if a real-time event should be processed by looking at the top event of the _realTimeEventQueue. If there is one that should be fired, that actor is returned for firing. If not, we go on and considers two cases, depending whether there is an actor currently executing, as follows: <p> <b>Case 1</b>: If there is no actor currently executing, then this method checks the event queue and returns null if it is empty. If it is not empty, it checks the destination actor of the earliest event on the event queue, and if it has a non-zero execution time, then it pushes it onto the currently executing stack and returns null. Otherwise, if the execution time of the actor is zero, it sets the current model time to the time stamp of that earliest event and returns that actor. <p> <b>Case 2</b>: If there is an actor currently executing, then this method checks whether it has a remaining execution time of zero. If it does, then it returns the currently executing actor. If it does not, then it checks whether the earliest event on the event queue should preempt it (by invoking _preemptExecutingActor()), and if so, checks the destination actor of that event and removes the event from the event queue. If that destination actor has an execution time of zero, then it sets the current model time to the time stamp of that event, and returns that actor. Else if the destination actor has an execution time of bigger than zero, then it calls fireAt() on the enclosing director passing it the time it expects the currently executing actor to finish executing, and returns null. If there is no event on the event queue or that event should not preempt the currently executing actor, then it calls fireAt() on the enclosing director passing it the time it expects the currently executing actor to finish executing, and returns null.
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards, or if the enclosing director does not respect the fireAt call. <p> Also, when an actor is fired, not only is the top event processed, all events in the event queue are also checked to see whether they have the same actor as destination, and they have the same timestamp as the top event. Those that do are also taken out of the event queue and processed. <p> Finally, in any of the following situations: a sensor interrupt has occurred, a timed interrupt has occurred, or an actor has finished firing; the scheduler must run to decide whether the next event should be processed. Since the Ptides simulator simulates the passage of physical time, we also simulate the overhead for the scheduler to make its decision. The parameter:  {@link #schedulerExecutionTime} indicates this time.
 * @see #_preemptExecutingActor()
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  Tag physicalTag=getPhysicalTag();
  Actor container=(Actor)getContainer();
  Director executiveDirector=container.getExecutiveDirector();
  if (_schedulerStillRunning()) {
    return null;
  }
  if (_sensorInterruptOccurred) {
    _startScheduler();
    _sensorInterruptOccurred=false;
  }
  if (_timedInterruptOccurred()) {
    _startScheduler();
    _timedInterruptWakeUpTime=null;
  }
  if (_scheduleNewEvent) {
    _startScheduler();
    _scheduleNewEvent=false;
  }
  if (!_currentlyExecutingStack.isEmpty()) {
    DoubleTimedEvent currentEventList=(DoubleTimedEvent)_currentlyExecutingStack.peek();
    Time remainingExecutionTime=currentEventList.remainingExecutionTime;
    Time finishTime=_physicalTimeExecutionStarted.add(remainingExecutionTime);
    int comparison=finishTime.compareTo(physicalTag.timestamp);
    if (comparison < 0) {
      throw new IllegalActionException(this,_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),""String_Node_Str"");
    }
 else     if (comparison == 0) {
      setTag(currentEventList.timeStamp,currentEventList.microstep);
      _currentlyExecutingStack.pop();
      _physicalTimeExecutionStarted=physicalTag.timestamp;
      if (_debugging) {
        _debug(""String_Node_Str"" + _getActorFromEventList((List<PtidesEvent>)currentEventList.contents).getName(getContainer()) + ""String_Node_Str""+ physicalTag.timestamp);
      }
      _setIcon(_getIdleIcon(),false);
      _clearHighlight(_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),false);
      _lastExecutingActor=null;
      executiveDirector.fireAtCurrentTime((Actor)container);
      _lastActorFired=_getActorFromEventList((List<PtidesEvent>)currentEventList.contents);
      _scheduleNewEvent=true;
      return _lastActorFired;
    }
 else {
      Time nextEventOnStackFireTime=_currentlyExecutingStack.peek().remainingExecutionTime;
      Time expectedCompletionTime=nextEventOnStackFireTime.add(_physicalTimeExecutionStarted);
      Time fireAtTime=executiveDirector.fireAt(container,expectedCompletionTime);
      if (!fireAtTime.equals(expectedCompletionTime)) {
        throw new IllegalActionException(executiveDirector,""String_Node_Str"" + expectedCompletionTime + ""String_Node_Str""+ fireAtTime);
      }
      if (_eventQueue.isEmpty() || !_preemptExecutingActor()) {
        return null;
      }
    }
  }
  if (_eventQueue.isEmpty()) {
    _setIcon(_getIdleIcon(),false);
    return null;
  }
  PtidesEvent eventFromQueue=_getNextSafeEvent();
  if (eventFromQueue == null) {
    return null;
  }
  Time timeStampOfEventFromQueue=eventFromQueue.timeStamp();
  int microstepOfEventFromQueue=eventFromQueue.microstep();
  _trackLastTagConsumedByActor(eventFromQueue);
  List<PtidesEvent> eventsToProcess=_takeAllSameTagEventsFromQueue(eventFromQueue);
  Actor actorToFire=_getNextActorToFireForTheseEvents(eventsToProcess);
  IOPort ioPort=eventFromQueue.ioPort();
  if (ioPort == null) {
    List<IOPort> inPortList=eventFromQueue.actor().inputPortList();
    if (inPortList.size() > 0) {
      ioPort=inPortList.get(0);
    }
  }
  _saveEventInformation(eventsToProcess);
  Time executionTime=new Time(this,_getExecutionTime(ioPort,actorToFire));
  if (executionTime.compareTo(_zero) == 0) {
    setTag(timeStampOfEventFromQueue,microstepOfEventFromQueue);
    executiveDirector.fireAtCurrentTime((Actor)container);
    _lastActorFired=actorToFire;
    _scheduleNewEvent=true;
    return actorToFire;
  }
 else {
    Time expectedCompletionTime=physicalTag.timestamp.add(executionTime);
    Time fireAtTime=executiveDirector.fireAt(container,expectedCompletionTime);
    if (!fireAtTime.equals(expectedCompletionTime)) {
      throw new IllegalActionException(actorToFire,executiveDirector,""String_Node_Str"" + expectedCompletionTime + ""String_Node_Str""+ fireAtTime);
    }
    if (!_currentlyExecutingStack.isEmpty()) {
      DoubleTimedEvent currentEventList=_currentlyExecutingStack.peek();
      Time elapsedTime=physicalTag.timestamp.subtract(_physicalTimeExecutionStarted);
      currentEventList.remainingExecutionTime=currentEventList.remainingExecutionTime.subtract(elapsedTime);
      if (currentEventList.remainingExecutionTime.compareTo(_zero) < 0) {
        throw new IllegalActionException(this,_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + _getActorFromEventList((List<PtidesEvent>)currentEventList.contents).getName((NamedObj)container) + ""String_Node_Str""+ physicalTag.timestamp+ ""String_Node_Str""+ currentEventList.remainingExecutionTime);
      }
    }
    _currentlyExecutingStack.push(new DoubleTimedEvent(timeStampOfEventFromQueue,microstepOfEventFromQueue,eventsToProcess,executionTime));
    _physicalTimeExecutionStarted=physicalTag.timestamp;
    if (_debugging) {
      _debug(""String_Node_Str"" + actorToFire.toString() + ""String_Node_Str""+ physicalTag.timestamp);
    }
    _setIcon(_getExecutingIcon(actorToFire),false);
    _lastExecutingActor=actorToFire;
    return null;
  }
}","/** 
 * Return the actor to fire in this iteration, or null if no actor should be fired. In this base class, this method first checks whether the top event from the event queue is destined for an actuator. If it is, then we check if physical time has reached the timestamp of the actuation event. If it has, then we fire the actuator. If it has not, then we take the actuator event from the event queue and put it onto the _realTimeEventQueue, and call fireAt() of the executive director. We then check if a real-time event should be processed by looking at the top event of the _realTimeEventQueue. If there is one that should be fired, that actor is returned for firing. If not, we go on and considers two cases, depending whether there is an actor currently executing, as follows: <p> <b>Case 1</b>: If there is no actor currently executing, then this method checks the event queue and returns null if it is empty. If it is not empty, it checks the destination actor of the earliest event on the event queue, and if it has a non-zero execution time, then it pushes it onto the currently executing stack and returns null. Otherwise, if the execution time of the actor is zero, it sets the current model time to the time stamp of that earliest event and returns that actor. <p> <b>Case 2</b>: If there is an actor currently executing, then this method checks whether it has a remaining execution time of zero. If it does, then it returns the currently executing actor. If it does not, then it checks whether the earliest event on the event queue should preempt it (by invoking _preemptExecutingActor()), and if so, checks the destination actor of that event and removes the event from the event queue. If that destination actor has an execution time of zero, then it sets the current model time to the time stamp of that event, and returns that actor. Else if the destination actor has an execution time of bigger than zero, then it calls fireAt() on the enclosing director passing it the time it expects the currently executing actor to finish executing, and returns null. If there is no event on the event queue or that event should not preempt the currently executing actor, then it calls fireAt() on the enclosing director passing it the time it expects the currently executing actor to finish executing, and returns null.
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards, or if the enclosing director does not respect the fireAt call. <p> Also, when an actor is fired, not only is the top event processed, all events in the event queue are also checked to see whether they have the same actor as destination, and they have the same timestamp as the top event. Those that do are also taken out of the event queue and processed. <p> Finally, in any of the following situations: a sensor interrupt has occurred, a timed interrupt has occurred, or an actor has finished firing; the scheduler must run to decide whether the next event should be processed. Since the Ptides simulator simulates the passage of physical time, we also simulate the overhead for the scheduler to make its decision. The parameter:  {@link #schedulerExecutionTime} indicates this time.Notice, when sensor and timed interrupts occurs, the currently executing event will be preempted to perform the scheduling overhead. <p> If at some simulated physical time, a sensor interrupt occurred, at the same time, a previous event finished execution, then we always assume the sensor interruption occurred first, and the event should be put into the event queue before the finished event is dealt with.
 * @see #_preemptExecutingActor()
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  Tag physicalTag=getPhysicalTag();
  Actor container=(Actor)getContainer();
  Director executiveDirector=container.getExecutiveDirector();
  if (_schedulerStillRunning()) {
    return null;
  }
  if (_sensorInterruptOccurred) {
    _startScheduler();
    _resetExecutionTimeForPreemptedEvent();
    _physicalTimeExecutionStarted=null;
    _sensorInterruptOccurred=false;
    return null;
  }
  if (_timedInterruptOccurred()) {
    _startScheduler();
    _resetExecutionTimeForPreemptedEvent();
    _physicalTimeExecutionStarted=null;
    _timedInterruptWakeUpTime=null;
    return null;
  }
  if (_scheduleNewEvent) {
    _startScheduler();
    _scheduleNewEvent=false;
    return null;
  }
  if (!_currentlyExecutingStack.isEmpty()) {
    if (_physicalTimeExecutionStarted == null) {
      _physicalTimeExecutionStarted=getPhysicalTag().timestamp;
    }
    DoubleTimedEvent currentEventList=(DoubleTimedEvent)_currentlyExecutingStack.peek();
    Time remainingExecutionTime=currentEventList.remainingExecutionTime;
    Time finishTime=_physicalTimeExecutionStarted.add(remainingExecutionTime);
    int comparison=finishTime.compareTo(physicalTag.timestamp);
    if (comparison < 0) {
      throw new IllegalActionException(this,_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),""String_Node_Str"");
    }
 else     if (comparison == 0) {
      setTag(currentEventList.timeStamp,currentEventList.microstep);
      _currentlyExecutingStack.pop();
      _physicalTimeExecutionStarted=physicalTag.timestamp;
      if (_debugging) {
        _debug(""String_Node_Str"" + _getActorFromEventList((List<PtidesEvent>)currentEventList.contents).getName(getContainer()) + ""String_Node_Str""+ physicalTag.timestamp);
      }
      _setIcon(_getIdleIcon(),false);
      _clearHighlight(_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),false);
      _lastExecutingActor=null;
      executiveDirector.fireAtCurrentTime((Actor)container);
      _lastActorFired=_getActorFromEventList((List<PtidesEvent>)currentEventList.contents);
      _scheduleNewEvent=true;
      return _lastActorFired;
    }
 else {
      Time nextEventOnStackFireTime=_currentlyExecutingStack.peek().remainingExecutionTime;
      Time expectedCompletionTime=nextEventOnStackFireTime.add(_physicalTimeExecutionStarted);
      Time fireAtTime=executiveDirector.fireAt(container,expectedCompletionTime);
      if (!fireAtTime.equals(expectedCompletionTime)) {
        throw new IllegalActionException(executiveDirector,""String_Node_Str"" + expectedCompletionTime + ""String_Node_Str""+ fireAtTime);
      }
      if (_eventQueue.isEmpty() || !_preemptExecutingActor()) {
        return null;
      }
    }
  }
  if (_eventQueue.isEmpty()) {
    _setIcon(_getIdleIcon(),false);
    return null;
  }
  PtidesEvent eventFromQueue=_getNextSafeEvent();
  if (eventFromQueue == null) {
    return null;
  }
  Time timeStampOfEventFromQueue=eventFromQueue.timeStamp();
  int microstepOfEventFromQueue=eventFromQueue.microstep();
  _trackLastTagConsumedByActor(eventFromQueue);
  List<PtidesEvent> eventsToProcess=_takeAllSameTagEventsFromQueue(eventFromQueue);
  Actor actorToFire=_getNextActorToFireForTheseEvents(eventsToProcess);
  IOPort ioPort=eventFromQueue.ioPort();
  if (ioPort == null) {
    List<IOPort> inPortList=eventFromQueue.actor().inputPortList();
    if (inPortList.size() > 0) {
      ioPort=inPortList.get(0);
    }
  }
  _saveEventInformation(eventsToProcess);
  Time executionTime=new Time(this,_getExecutionTime(ioPort,actorToFire));
  if (executionTime.compareTo(_zero) == 0) {
    setTag(timeStampOfEventFromQueue,microstepOfEventFromQueue);
    executiveDirector.fireAtCurrentTime((Actor)container);
    _lastActorFired=actorToFire;
    if (!(actorToFire instanceof SensorInputDevice)) {
      _scheduleNewEvent=true;
    }
    return actorToFire;
  }
 else {
    Time expectedCompletionTime=physicalTag.timestamp.add(executionTime);
    Time fireAtTime=executiveDirector.fireAt(container,expectedCompletionTime);
    if (!fireAtTime.equals(expectedCompletionTime)) {
      throw new IllegalActionException(actorToFire,executiveDirector,""String_Node_Str"" + expectedCompletionTime + ""String_Node_Str""+ fireAtTime);
    }
    _resetExecutionTimeForPreemptedEvent();
    _currentlyExecutingStack.push(new DoubleTimedEvent(timeStampOfEventFromQueue,microstepOfEventFromQueue,eventsToProcess,executionTime));
    _physicalTimeExecutionStarted=physicalTag.timestamp;
    if (_debugging) {
      _debug(""String_Node_Str"" + actorToFire.toString() + ""String_Node_Str""+ physicalTag.timestamp);
    }
    _setIcon(_getExecutingIcon(actorToFire),false);
    _lastExecutingActor=actorToFire;
    return null;
  }
}"
73525,"/** 
 * For all events in the sensorEventQueue, transfer input events that are ready. For all events that are currently sitting at the input port, if the realTimeDelay is 0.0, then transfer them into the platform, otherwise move them into the sensorEventQueue and call fireAt() of the executive director. In either case, if the input port is a networkPort, we make sure the timestamp of the data token transmitted is set to the timestamp of the local event associated with this token.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 * @exception IllegalActionException If the port is not an opaqueinput port, if the super class throws it, if physical tag cannot be evaulated, if token cannot be sent to the inside.
 */
protected boolean _transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferInputs(port);
  }
  boolean result=false;
  Tag physicalTag=getPhysicalTag();
  while (true) {
    if (_realTimeInputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent realTimeEvent=(RealTimeEvent)_realTimeInputEventQueue.peek();
    int compare=realTimeEvent.deliveryTag.compareTo(physicalTag);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      Parameter parameter=(Parameter)((NamedObj)realTimeEvent.port).getAttribute(""String_Node_Str"");
      double realTimeDelay=0.0;
      if (parameter != null) {
        realTimeDelay=((DoubleToken)parameter.getToken()).doubleValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"");
      }
      Time lastModelTime=_currentTime;
      if (_isNetworkPort(realTimeEvent.port)) {
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
      }
 else {
        int lastMicrostep=_microstep;
        setTag(realTimeEvent.deliveryTag.timestamp.subtract(realTimeDelay),realTimeEvent.deliveryTag.microstep);
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
        setTag(lastModelTime,lastMicrostep);
      }
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + realTimeEvent.port.getName());
      }
      _sensorInterruptOccurred=true;
      result=true;
    }
 else {
      throw new IllegalActionException(realTimeEvent.port,""String_Node_Str"" + ""String_Node_Str"" + realTimeEvent.deliveryTag.timestamp + ""String_Node_Str""+ realTimeEvent.deliveryTag.microstep+ ""String_Node_Str""+ physicalTag.timestamp+ ""String_Node_Str""+ physicalTag.microstep);
    }
  }
  if (_isNetworkPort(port)) {
    while (true) {
      if (!super._transferInputs(port)) {
        break;
      }
 else {
        result=true;
      }
    }
  }
  Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
  double realTimeDelay=0.0;
  if (parameter != null) {
    realTimeDelay=((DoubleToken)parameter.getToken()).doubleValue();
  }
  if (realTimeDelay == 0.0) {
    Time lastModelTime=_currentTime;
    int lastMicrostep=_microstep;
    setTag(physicalTag.timestamp,physicalTag.microstep);
    result=result || super._transferInputs(port);
    setTag(lastModelTime,lastMicrostep);
  }
 else {
    for (int i=0; i < port.getWidth(); i++) {
      try {
        if (i < port.getWidthInside()) {
          if (port.hasToken(i)) {
            Token t=port.get(i);
            Time waitUntilTime=physicalTag.timestamp.add(realTimeDelay);
            RealTimeEvent realTimeEvent=new RealTimeEvent(port,i,t,new Tag(waitUntilTime,physicalTag.microstep));
            _realTimeInputEventQueue.add(realTimeEvent);
            result=true;
            Actor container=(Actor)getContainer();
            container.getExecutiveDirector().fireAt((Actor)container,waitUntilTime);
          }
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
  }
  return result;
}","/** 
 * For all events in the sensorEventQueue, transfer input events that are ready. For all events that are currently sitting at the input port, if the realTimeDelay is 0.0, then transfer them into the platform, otherwise move them into the sensorEventQueue and call fireAt() of the executive director. In either case, if the input port is a networkPort, we make sure the timestamp of the data token transmitted is set to the timestamp of the local event associated with this token.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 * @exception IllegalActionException If the port is not an opaqueinput port, if the super class throws it, if physical tag cannot be evaulated, if token cannot be sent to the inside, or if there exists no token in the port, but hasToken() return true.
 */
protected boolean _transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferInputs(port);
  }
  boolean result=false;
  Tag physicalTag=getPhysicalTag();
  while (true) {
    if (_realTimeInputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent realTimeEvent=(RealTimeEvent)_realTimeInputEventQueue.peek();
    int compare=realTimeEvent.deliveryTag.compareTo(physicalTag);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      Parameter parameter=(Parameter)((NamedObj)realTimeEvent.port).getAttribute(""String_Node_Str"");
      double realTimeDelay=0.0;
      if (parameter != null) {
        realTimeDelay=((DoubleToken)parameter.getToken()).doubleValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"");
      }
      Time lastModelTime=_currentTime;
      if (_isNetworkPort(realTimeEvent.port)) {
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
      }
 else {
        int lastMicrostep=_microstep;
        setTag(realTimeEvent.deliveryTag.timestamp.subtract(realTimeDelay),realTimeEvent.deliveryTag.microstep);
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
        setTag(lastModelTime,lastMicrostep);
      }
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + realTimeEvent.port.getName());
      }
      _sensorInterruptOccurred=true;
      result=true;
    }
 else {
      throw new IllegalActionException(realTimeEvent.port,""String_Node_Str"" + ""String_Node_Str"" + realTimeEvent.deliveryTag.timestamp + ""String_Node_Str""+ realTimeEvent.deliveryTag.microstep+ ""String_Node_Str""+ physicalTag.timestamp+ ""String_Node_Str""+ physicalTag.microstep);
    }
  }
  if (_isNetworkPort(port)) {
    while (true) {
      if (!super._transferInputs(port)) {
        break;
      }
 else {
        result=true;
        _sensorInterruptOccurred=true;
      }
    }
  }
  Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
  double realTimeDelay=0.0;
  if (parameter != null) {
    realTimeDelay=((DoubleToken)parameter.getToken()).doubleValue();
  }
  if (realTimeDelay == 0.0) {
    Time lastModelTime=_currentTime;
    int lastMicrostep=_microstep;
    setTag(physicalTag.timestamp,physicalTag.microstep);
    if (super._transferInputs(port)) {
      _sensorInterruptOccurred=true;
      result=true;
    }
    setTag(lastModelTime,lastMicrostep);
  }
 else {
    for (int i=0; i < port.getWidth(); i++) {
      try {
        if (i < port.getWidthInside()) {
          if (port.hasToken(i)) {
            Token t=port.get(i);
            Time waitUntilTime=physicalTag.timestamp.add(realTimeDelay);
            RealTimeEvent realTimeEvent=new RealTimeEvent(port,i,t,new Tag(waitUntilTime,physicalTag.microstep));
            _realTimeInputEventQueue.add(realTimeEvent);
            result=true;
            Actor container=(Actor)getContainer();
            container.getExecutiveDirector().fireAt((Actor)container,waitUntilTime);
          }
        }
      }
 catch (      NoTokenException ex) {
        throw new IllegalActionException(this,ex,null);
      }
    }
  }
  return result;
}"
73526,"/** 
 * Among all events in the event queue, find the first event that is destined to an output port of the containing composite actor. This event is taken from the event queue, and the token is sent to the actuator/network output port.
 */
protected void _getNextActuationEvent(){
  int eventIndex=0;
synchronized (_eventQueue) {
    while (eventIndex < _eventQueue.size()) {
      PtidesEvent nextEvent=((PtidesListEventQueue)_eventQueue).get(eventIndex);
      if (nextEvent.ioPort() != null && nextEvent.ioPort().isOutput()) {
        ((PtidesListEventQueue)_eventQueue).take(eventIndex);
        continue;
      }
      eventIndex++;
    }
  }
}","/** 
 * Among all events in the event queue, find the first event that is destined to an output port of the containing composite actor. This event is taken from the event queue, and the token is sent to the actuator/network output port.
 * @throws IllegalActionException If cannot set the current tag ofthe director.
 */
protected void _getNextActuationEvent() throws IllegalActionException {
  int eventIndex=0;
synchronized (_eventQueue) {
    while (eventIndex < _eventQueue.size()) {
      PtidesEvent nextEvent=((PtidesListEventQueue)_eventQueue).get(eventIndex);
      if (nextEvent.ioPort() != null && nextEvent.ioPort().isOutput()) {
        PtidesEvent ptidesEvent=((PtidesListEventQueue)_eventQueue).take(eventIndex);
        setTag(ptidesEvent.timeStamp(),ptidesEvent.microstep());
      }
      eventIndex++;
    }
  }
}"
73527,"/** 
 * Check the consistency of input/output ports. The following things are checked. <p> If an input port is a sensor port (no annotation), then it should not be connected to a NetworkInputDevice. Also, it should not have a networkDelay attribute. </p><p> If an input port is a network port (annotated networkPort), then it should always be connected to a NetworkInputDeivce. Also, it should not have a realTimeDelay attribute. </p>
 * @exception IllegalActionException If sensor ports are connected toNetworkInputDevice or have a networkDelay attribute; Or if a network port is not connected to a NetworkInputDeivce, or it has a realTimeDelay attribute.
 */
protected void _checkSensorActuatorNetworkConsistency() throws IllegalActionException {
  if (getContainer() instanceof TypedCompositeActor) {
    for (    TypedIOPort port : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).inputPortList())) {
      for (      TypedIOPort sinkPort : (List<TypedIOPort>)port.deepInsidePortList()) {
        if (_isNetworkPort(port)) {
          if (sinkPort.isInput() && !(sinkPort.getContainer() instanceof NetworkInputDevice)) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
 else {
          if (sinkPort.isInput() && sinkPort.getContainer() instanceof NetworkInputDevice) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
    }
    for (    TypedIOPort port : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).outputPortList())) {
      for (      TypedIOPort sourcePort : (List<TypedIOPort>)port.deepInsidePortList()) {
        if (_isNetworkPort(port)) {
          if (sourcePort.isOutput() && !(sourcePort.getContainer() instanceof NetworkOutputDevice)) {
            throw new IllegalActionException(port,sourcePort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
 else {
          if (sourcePort.isOutput() && sourcePort.getContainer() instanceof NetworkOutputDevice) {
            throw new IllegalActionException(port,sourcePort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
    }
  }
}","/** 
 * Check the consistency of input/output ports. The following things are checked. <p> If an input port is a sensor port (no annotation), then it should not be connected to a NetworkInputDevice. Also, it should not have a networkDelay attribute. </p><p> If an input port is a network port (annotated networkPort), then it should always be connected to a NetworkInputDeivce. Also, it should not have a realTimeDelay attribute. </p>
 * @exception IllegalActionException If sensor ports are connected toNetworkInputDevice or have a networkDelay attribute; Or if a network port is not connected to a NetworkInputDeivce, or it has a realTimeDelay attribute.
 */
protected void _checkSensorActuatorNetworkConsistency() throws IllegalActionException {
  if (getContainer() instanceof TypedCompositeActor) {
    for (    TypedIOPort port : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).inputPortList())) {
      for (      TypedIOPort sinkPort : (List<TypedIOPort>)port.deepInsidePortList()) {
        if (_isNetworkPort(port)) {
          if (sinkPort.isInput() && !(sinkPort.getContainer() instanceof NetworkInputDevice)) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
 else {
          Parameter parameter=(Parameter)getAttribute(""String_Node_Str"");
          if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0) && sinkPort.isInput()&& !(sinkPort.getContainer() instanceof SensorInputDevice)) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          if (sinkPort.isInput() && sinkPort.getContainer() instanceof NetworkInputDevice) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
    }
    for (    TypedIOPort port : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).outputPortList())) {
      for (      TypedIOPort sourcePort : (List<TypedIOPort>)port.deepInsidePortList()) {
        if (_isNetworkPort(port)) {
          if (sourcePort.isOutput() && !(sourcePort.getContainer() instanceof NetworkOutputDevice)) {
            throw new IllegalActionException(port,sourcePort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
 else {
          Parameter parameter=(Parameter)getAttribute(""String_Node_Str"");
          if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0) && sourcePort.isInput()&& !(sourcePort.getContainer() instanceof ActuatorOutputDevice)) {
            throw new IllegalActionException(port,sourcePort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          if (sourcePort.isOutput() && sourcePort.getContainer() instanceof NetworkOutputDevice) {
            throw new IllegalActionException(port,sourcePort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
    }
  }
}"
73528,"/** 
 * For all events in the sensorEventQueue, transfer input events that are ready. For all events that are currently sitting at the input port, if the realTimeDelay is 0.0, then transfer them into the platform, otherwise move them into the sensorEventQueue and call fireAt() of the executive director. In either case, if the input port is a networkPort, we make sure the timestamp of the data token transmitted is set to the timestamp of the local event associated with this token.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 * @exception IllegalActionException If the port is not an opaqueinput port, if the super class throws it, if physical tag cannot be evaluated, if token cannot be sent to the inside, or if there exists no token in the port, but hasToken() return true.
 */
protected boolean _transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferInputs(port);
  }
  boolean result=false;
  Tag physicalTag=getPhysicalTag();
  while (true) {
    if (_realTimeInputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent realTimeEvent=(RealTimeEvent)_realTimeInputEventQueue.peek();
    int compare=realTimeEvent.deliveryTag.compareTo(physicalTag);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      Time lastModelTime=_currentTime;
      int lastMicrostep=_microstep;
      if (isNetworkPort(realTimeEvent.port)) {
        _realTimeInputEventQueue.poll();
        setTag(new Time(this,Double.NEGATIVE_INFINITY),0);
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
        setTag(lastModelTime,lastMicrostep);
      }
 else {
        setTag(realTimeEvent.timestampTag.timestamp,realTimeEvent.timestampTag.microstep);
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
        setTag(lastModelTime,lastMicrostep);
      }
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + realTimeEvent.port.getName());
      }
      _sensorInterruptOccurred=true;
      result=true;
    }
 else {
      throw new IllegalActionException(realTimeEvent.port,""String_Node_Str"" + ""String_Node_Str"" + realTimeEvent.deliveryTag.timestamp + ""String_Node_Str""+ realTimeEvent.deliveryTag.microstep+ ""String_Node_Str""+ physicalTag.timestamp+ ""String_Node_Str""+ physicalTag.microstep);
    }
  }
  Double inputDelay=_getNetworkDriverDelay(port);
  if (inputDelay == null) {
    inputDelay=_getRealTimeDelay(port);
  }
  if (inputDelay == null) {
    inputDelay=0.0;
  }
  if (inputDelay == 0.0) {
    Time lastModelTime=_currentTime;
    int lastMicrostep=_microstep;
    if (isNetworkPort(port)) {
      setTag(new Time(this,Double.NEGATIVE_INFINITY),0);
    }
 else {
      setTag(physicalTag.timestamp,physicalTag.microstep);
    }
    if (super._transferInputs(port)) {
      _sensorInterruptOccurred=true;
      result=true;
    }
    setTag(lastModelTime,lastMicrostep);
  }
 else {
    for (int i=0; i < port.getWidth(); i++) {
      try {
        if (i < port.getWidthInside()) {
          if (port.hasToken(i)) {
            Token t=port.get(i);
            Time waitUntilTime=physicalTag.timestamp.add(inputDelay);
            RealTimeEvent realTimeEvent=new RealTimeEvent(port,i,t,new Tag(waitUntilTime,physicalTag.microstep),new Tag(physicalTag.timestamp,physicalTag.microstep));
            _realTimeInputEventQueue.add(realTimeEvent);
            result=true;
            Actor container=(Actor)getContainer();
            container.getExecutiveDirector().fireAt((Actor)container,waitUntilTime);
          }
        }
      }
 catch (      NoTokenException ex) {
        throw new IllegalActionException(this,ex,null);
      }
    }
  }
  return result;
}","/** 
 * For all events in the sensorEventQueue, transfer input events that are ready. For all events that are currently sitting at the input port, if the realTimeDelay is 0.0, then transfer them into the platform, otherwise move them into the sensorEventQueue and call fireAt() of the executive director. In either case, if the input port is a networkPort, we make sure the timestamp of the data token transmitted is set to the timestamp of the local event associated with this token.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 * @exception IllegalActionException If the port is not an opaqueinput port, if the super class throws it, if physical tag cannot be evaluated, if token cannot be sent to the inside, or if there exists no token in the port, but hasToken() return true.
 */
protected boolean _transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferInputs(port);
  }
  boolean result=false;
  Tag physicalTag=getPhysicalTag();
  while (true) {
    if (_realTimeInputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent realTimeEvent=(RealTimeEvent)_realTimeInputEventQueue.peek();
    int compare=realTimeEvent.deliveryTag.compareTo(physicalTag);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      Time lastModelTime=_currentTime;
      int lastMicrostep=_microstep;
      if (_isNetworkPort(realTimeEvent.port)) {
        _realTimeInputEventQueue.poll();
        setTag(new Time(this,Double.NEGATIVE_INFINITY),0);
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
        setTag(lastModelTime,lastMicrostep);
      }
 else {
        setTag(realTimeEvent.timestampTag.timestamp,realTimeEvent.timestampTag.microstep);
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
        setTag(lastModelTime,lastMicrostep);
      }
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + realTimeEvent.port.getName());
      }
      _sensorInterruptOccurred=true;
      result=true;
    }
 else {
      throw new IllegalActionException(realTimeEvent.port,""String_Node_Str"" + ""String_Node_Str"" + realTimeEvent.deliveryTag.timestamp + ""String_Node_Str""+ realTimeEvent.deliveryTag.microstep+ ""String_Node_Str""+ physicalTag.timestamp+ ""String_Node_Str""+ physicalTag.microstep);
    }
  }
  Double inputDelay=_getNetworkDriverDelay(port);
  if (inputDelay == null) {
    inputDelay=_getRealTimeDelay(port);
  }
  if (inputDelay == null) {
    inputDelay=0.0;
  }
  if (inputDelay == 0.0) {
    Time lastModelTime=_currentTime;
    int lastMicrostep=_microstep;
    if (_isNetworkPort(port)) {
      setTag(new Time(this,Double.NEGATIVE_INFINITY),0);
    }
 else {
      setTag(physicalTag.timestamp,physicalTag.microstep);
    }
    if (super._transferInputs(port)) {
      _sensorInterruptOccurred=true;
      result=true;
    }
    setTag(lastModelTime,lastMicrostep);
  }
 else {
    for (int i=0; i < port.getWidth(); i++) {
      try {
        if (i < port.getWidthInside()) {
          if (port.hasToken(i)) {
            Token t=port.get(i);
            Time waitUntilTime=physicalTag.timestamp.add(inputDelay);
            RealTimeEvent realTimeEvent=new RealTimeEvent(port,i,t,new Tag(waitUntilTime,physicalTag.microstep),new Tag(physicalTag.timestamp,physicalTag.microstep));
            _realTimeInputEventQueue.add(realTimeEvent);
            result=true;
            Actor container=(Actor)getContainer();
            container.getExecutiveDirector().fireAt((Actor)container,waitUntilTime);
          }
        }
      }
 catch (      NoTokenException ex) {
        throw new IllegalActionException(this,ex,null);
      }
    }
  }
  return result;
}"
73529,"/** 
 * Instantiate new model structures to get ready for a simulation run. Check if the enclosing director is a DEDirector. If not, throw an exception. Call the preinitialize() method in the super class. The superclass instantiates an event queue structure, however, here a  PtidesListEventQueue structure is instantiated in its place.  We do this because a Ptides scheduler not only need to access the first event in the event queue, but all other events, in sorted order.  Also, the delayOffset used in the  safe-to-process analysis is calculated. This is followed by a check to see if sensors, actuators, and networks ports are annotated with the corresponding parameters, and whether they are connected to the  corresponding sensor/actuator/network actors. Finally, the parameter stopWhenQueueIsEmpty is set to false.  In general, Ptides models should never stop when the event queue is empty, because it can wait and react to future sensor input events.
 * @see #_calculateDelayOffsets
 * @exception IllegalActionException If the enclosing director doesnot exist or is not a DEDirector, delayOffset cannot be calculated,  sensor/actuator/network consistency cannot be checked, or if the  super class throws it.
 */
public void preinitialize() throws IllegalActionException {
  NamedObj container=getContainer();
  if (!(container instanceof Actor)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  if (executiveDirector == null || !(executiveDirector instanceof DEDirector)) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  super.preinitialize();
  _eventQueue=new PtidesListEventQueue();
  _checkSensorActuatorNetworkConsistency();
  _calculateDelayOffsets();
  stopWhenQueueIsEmpty.setExpression(""String_Node_Str"");
}","/** 
 * Instantiate new model structures to get ready for a simulation run. Check if the enclosing director is a DEDirector. If not, throw an exception. Call the preinitialize() method in the super class. The superclass instantiates an event queue structure, however, here a  PtidesListEventQueue structure is instantiated in its place.  We do this because a Ptides scheduler not only need to access the first event in the event queue, but all other events, in sorted order.  Also, the delayOffset used in the  safe-to-process analysis is calculated. This is followed by a check to see if sensors, actuators, and networks ports are annotated with the corresponding parameters, and whether they are connected to the  corresponding sensor/actuator/network actors. Finally, the parameter stopWhenQueueIsEmpty is set to false.  In general, Ptides models should never stop when the event queue is empty, because it can wait and react to future sensor input events.
 * @see #_calculateDelayOffsets
 * @exception IllegalActionException If the enclosing director doesnot exist or is not a DEDirector, delayOffset cannot be calculated,  sensor/actuator/network consistency cannot be checked, or if the  super class throws it.
 */
public void preinitialize() throws IllegalActionException {
  NamedObj container=getContainer();
  if (!(container instanceof Actor)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  if (executiveDirector == null || !(executiveDirector instanceof DEDirector)) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (((BooleanToken)animateExecution.getToken()).booleanValue()) {
    Parameter parameter=(Parameter)((NamedObj)executiveDirector).getAttribute(""String_Node_Str"");
    if (parameter == null) {
      throw new IllegalActionException(executiveDirector,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (!((BooleanToken)parameter.getToken()).booleanValue()) {
      throw new IllegalActionException(executiveDirector,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  super.preinitialize();
  _eventQueue=new PtidesListEventQueue();
  _checkSensorActuatorNetworkConsistency();
  _calculateDelayOffsets();
  stopWhenQueueIsEmpty.setExpression(""String_Node_Str"");
}"
73530,"/** 
 * Check the consistency of input/output ports. The following things are checked. <p> If an input port is a sensor port (no annotation), then it should not be connected to a NetworkInputDevice. Also, it should not have a networkDelay attribute. </p><p> If an input port is a network port (annotated networkPort), then it should always be connected to a NetworkInputDeivce. Also, it should not have a realTimeDelay attribute. </p>
 * @exception IllegalActionException If sensor ports are connected toNetworkInputDevice or have a networkDelay attribute; Or if a network port is not connected to a NetworkInputDeivce, or it has a realTimeDelay attribute.
 */
protected void _checkSensorActuatorNetworkConsistency() throws IllegalActionException {
  if (getContainer() instanceof TypedCompositeActor) {
    for (    TypedIOPort port : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).inputPortList())) {
      boolean sensorPort=false;
      boolean networkPort=false;
      if (_getNetworkTotalDelay(port) != null) {
        networkPort=true;
      }
      if (_getRealTimeDelay(port) != null) {
        sensorPort=true;
      }
      if (sensorPort && networkPort) {
        throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      for (      TypedIOPort sinkPort : (List<TypedIOPort>)port.deepInsidePortList()) {
        if (isNetworkPort(port)) {
          if (sinkPort.isInput() && !(sinkPort.getContainer() instanceof NetworkInputDevice)) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
 else {
          Parameter parameter=(Parameter)getAttribute(""String_Node_Str"");
          if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0) && sinkPort.isInput()&& !(sinkPort.getContainer() instanceof SensorInputDevice)) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          if (sinkPort.isInput() && sinkPort.getContainer() instanceof NetworkInputDevice) {
            throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
          if (parameter != null) {
            throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
    }
    for (    TypedIOPort port : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).outputPortList())) {
      for (      TypedIOPort sourcePort : (List<TypedIOPort>)port.deepInsidePortList()) {
        Parameter parameter=(Parameter)getAttribute(""String_Node_Str"");
        if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0) && sourcePort.isInput()&& !((sourcePort.getContainer() instanceof ActuatorOutputDevice) || (sourcePort.getContainer() instanceof NetworkOutputDevice))) {
          throw new IllegalActionException(port,sourcePort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
  }
}","/** 
 * Check the consistency of input/output ports. The following things are checked. <p> If an input port is a sensor port (no annotation), then it should not be connected to a NetworkInputDevice. Also, it should not have a networkDelay attribute. </p><p> If an input port is a network port (annotated networkPort), then it should always be connected to a NetworkInputDeivce. Also, it should not have a realTimeDelay attribute. </p>
 * @exception IllegalActionException If sensor ports are connected toNetworkInputDevice or have a networkDelay attribute; Or if a network port is not connected to a NetworkInputDeivce, or it has a realTimeDelay attribute.
 */
protected void _checkSensorActuatorNetworkConsistency() throws IllegalActionException {
  _networkInpuPorts=new HashSet<IOPort>();
  for (  TypedIOPort port : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).inputPortList())) {
    _checkSensorNetworkInputConsistency(port);
    for (    TypedIOPort sinkPort : (List<TypedIOPort>)port.deepInsidePortList()) {
      if (!_isNetworkPort(port)) {
        Parameter parameter=(Parameter)getAttribute(""String_Node_Str"");
        if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0) && sinkPort.isInput()&& !(sinkPort.getContainer() instanceof SensorInputDevice)) {
          throw new IllegalActionException(port,sinkPort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
  }
  for (  TypedIOPort port : (List<TypedIOPort>)(((TypedCompositeActor)getContainer()).outputPortList())) {
    for (    TypedIOPort sourcePort : (List<TypedIOPort>)port.deepInsidePortList()) {
      Parameter parameter=(Parameter)getAttribute(""String_Node_Str"");
      if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0) && sourcePort.isOutput()&& !((sourcePort.getContainer() instanceof ActuatorOutputDevice) || (sourcePort.getContainer() instanceof NetworkOutputDevice))) {
        throw new IllegalActionException(port,sourcePort.getContainer(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
  }
}"
73531,"/** 
 * Perform a check to see if this device is connected to a network port on the outside. If not, throw an exception. Also call preinitialize of the super class.
 * @exception IllegalActionException If there are no outside sourceports, or if any of the outside source ports is not a network port.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  boolean flag=false;
  for (  IOPort input : (List<IOPort>)inputPortList()) {
    for (    IOPort sourcePort : (List<IOPort>)input.sourcePortList()) {
      if (sourcePort.getContainer() == getContainer()) {
        flag=true;
        if (!PtidesBasicDirector.isNetworkPort(sourcePort)) {
          throw new IllegalActionException(this,sourcePort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
  if (!flag) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Perform a check to see if this device is connected to a network port on the outside. If not, throw an exception. Also call preinitialize of the super class.
 * @exception IllegalActionException If there are no outside sourceports, or if any of the outside source ports is not a network port.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  boolean flag=false;
  for (  IOPort input : (List<IOPort>)inputPortList()) {
    for (    IOPort sourcePort : (List<IOPort>)input.sourcePortList()) {
      if (sourcePort.getContainer() == getContainer()) {
        flag=true;
      }
    }
  }
  if (!flag) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
}"
73532,"/** 
 * Perform a check to see if this device is connected to a network port on the outside. If so, throw an exception. Also call preinitialize of the super class.
 * @exception IllegalActionException If there are no outside sourceports, or if any of the outside source ports is a network port.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  Parameter parameter=(Parameter)getDirector().getAttribute(""String_Node_Str"");
  if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0)) {
    boolean flag=false;
    for (    IOPort input : (List<IOPort>)inputPortList()) {
      for (      IOPort sourcePort : (List<IOPort>)input.sourcePortList()) {
        if (sourcePort.getContainer() == getContainer()) {
          flag=true;
          if (PtidesBasicDirector.isNetworkPort(sourcePort)) {
            throw new IllegalActionException(this,sourcePort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
    }
    if (!flag) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}","/** 
 * Perform a check to see if this device is connected to a network port on the outside. If so, throw an exception. Also call preinitialize of the super class.
 * @exception IllegalActionException If there are no outside sourceports, or if any of the outside source ports is a network port.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  Parameter parameter=(Parameter)getDirector().getAttribute(""String_Node_Str"");
  if ((parameter != null) && (((DoubleToken)parameter.getToken()).doubleValue() != 0.0)) {
    boolean flag=false;
    for (    IOPort input : (List<IOPort>)inputPortList()) {
      for (      IOPort sourcePort : (List<IOPort>)input.sourcePortList()) {
        if (sourcePort.getContainer() == getContainer()) {
          flag=true;
        }
      }
    }
    if (!flag) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}"
73533,"/** 
 * Construct an instance with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public GiottoTimingManager(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  SingletonParameter hideName=new SingletonParameter(this,""String_Node_Str"");
  hideName.setToken(BooleanToken.TRUE);
  hideName.setVisibility(Settable.EXPERT);
  seed=new SharedParameter(this,""String_Node_Str"",GiottoTimingManager.class,""String_Node_Str"");
  seed.setTypeEquals(BaseType.LONG);
  resetOnEachRun=new SharedParameter(this,""String_Node_Str"",GiottoTimingManager.class,""String_Node_Str"");
  resetOnEachRun.setTypeEquals(BaseType.BOOLEAN);
  probabilityDistribution=new StringParameter(this,""String_Node_Str"");
  probabilityDistribution.setExpression(""String_Node_Str"");
  probabilityDistribution.addChoice(""String_Node_Str"");
  _overRunThusFar=0.0;
}","/** 
 * Construct an instance with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public GiottoTimingManager(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  SingletonParameter hideName=new SingletonParameter(this,""String_Node_Str"");
  hideName.setToken(BooleanToken.TRUE);
  hideName.setVisibility(Settable.EXPERT);
  seed=new SharedParameter(this,""String_Node_Str"",GiottoTimingManager.class,""String_Node_Str"");
  seed.setTypeEquals(BaseType.LONG);
  resetOnEachRun=new SharedParameter(this,""String_Node_Str"",GiottoTimingManager.class,""String_Node_Str"");
  resetOnEachRun.setTypeEquals(BaseType.BOOLEAN);
  probabilityDistribution=new StringParameter(this,""String_Node_Str"");
  probabilityDistribution.setExpression(""String_Node_Str"");
  probabilityDistribution.addChoice(""String_Node_Str"");
  _overRunThusFar=0.0;
  _totalExpectedExecutionTime=_getDirectorPeriod(container);
  _totalObservedExecutionTime=0;
  NamedObj parentContainer=getContainer().getContainer();
  if (parentContainer != null) {
    if (parentContainer.getFullName().contains(""String_Node_Str"")) {
      if (_debugging) {
        _debug(""String_Node_Str"" + parentContainer.getFullName());
      }
      setModelErrorHandler(parentContainer);
    }
  }
}"
73534,"public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (_needNewGenerator) {
    _createGenerator();
  }
  if (_needNew) {
    _generateRandomNumber();
    _needNew=false;
  }
  List<Actor> entities=((CompositeActor)container).deepEntityList();
  for (  Actor actor : entities) {
    _myPhysicalTime=actor.getDirector().getModelTime().getDoubleValue() + _overRunThusFar;
    if (_debugging) {
      _debug(""String_Node_Str"" + actor.getName());
    }
    double actorWCET;
    Attribute executionTime=((Entity)actor).getAttribute(""String_Node_Str"");
    Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
    actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
    double t=_random.nextDouble() * 2 * actorWCET;
    if (t > actorWCET) {
      _overRunThusFar+=(t - actorWCET);
      _myPhysicalTime+=t;
      System.out.println(""String_Node_Str"" + actorWCET + ""String_Node_Str""+ t);
      System.out.println(""String_Node_Str"" + (actor.getDirector().getModelTime().getDoubleValue() + actorWCET) + ""String_Node_Str""+ _myPhysicalTime);
    }
    Parameter dummyP=(Parameter)executionTime;
    dummyP.setExpression(Double.toString(t));
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + ""String_Node_Str"");
  }
}","public void fire() throws IllegalActionException {
  if (!_readyToFire) {
    return;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + container);
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (_needNewGenerator) {
    _createGenerator();
  }
  if (_needNew) {
    _generateRandomNumber();
    _needNew=false;
  }
  if (!_readyToFire) {
    return;
  }
  while ((_unitIndex < _schedule.size())) {
    Schedule unitSchedule=(Schedule)_schedule.get(_unitIndex);
    Iterator scheduleIterator=unitSchedule.iterator();
    while (scheduleIterator.hasNext()) {
      Actor actor=((Firing)scheduleIterator.next()).getActor();
      if (_debugging) {
        _debug(""String_Node_Str"" + actor.getFullName());
      }
      _myPhysicalTime=actor.getDirector().getModelTime().getDoubleValue() + _overRunThusFar;
      double actorWCET;
      Attribute executionTime=((Entity)actor).getAttribute(""String_Node_Str"");
      Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
      actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
      double t=_random.nextDouble() * 2 * actorWCET;
      if (_debugging) {
        _debug(""String_Node_Str"" + t);
      }
      _totalObservedExecutionTime+=t;
      if (t > actorWCET) {
        _overRunThusFar+=(t - actorWCET);
        _myPhysicalTime+=t;
        if (_debugging) {
          _debug(""String_Node_Str"" + actorWCET + ""String_Node_Str""+ t);
          _debug(""String_Node_Str"" + (actor.getDirector().getModelTime().getDoubleValue() + actorWCET) + ""String_Node_Str""+ _myPhysicalTime);
        }
      }
      Parameter dummyP=(Parameter)executionTime;
      dummyP.setExpression(Double.toString(t));
      if (_debugging) {
        _debug(""String_Node_Str"" + actor + ""String_Node_Str"");
      }
    }
    scheduleIterator=unitSchedule.iterator();
    while (scheduleIterator.hasNext()) {
      Actor actor1=((Firing)scheduleIterator.next()).getActor();
      if (_debugging) {
        _debug(""String_Node_Str"" + ((NamedObj)actor1).getFullName());
      }
      if (actor1.iterate(1) == STOP_ITERATING) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"" + actor1.getFullName() + ""String_Node_Str"");
      }
    }
    _unitIndex++;
  }
  if (_unitIndex >= _schedule.size()) {
    _unitIndex=0;
  }
}"
73535,"public void preinitialize() throws IllegalActionException {
  double wcet=0;
  double _periodValue=0;
  wcet=_getDirectorWCET(container);
  _periodValue=_getDirectorPeriod(container);
  if (_debugging) {
    _debug(""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue);
  }
  if (wcet > _periodValue) {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    throw new IllegalActionException(container,""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue+ ""String_Node_Str""+ ((CompositeActor)(getContainer())).getDisplayName());
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}","public void preinitialize() throws IllegalActionException {
  double wcet=0;
  double _periodValue=0;
  wcet=_getDirectorWCET(container);
  _periodValue=_getDirectorPeriod(container);
  GiottoScheduler scheduler=(GiottoScheduler)((GiottoDirector)((CompositeActor)container).getDirector()).getScheduler();
  _schedule=scheduler.getSchedule();
  if (_debugging) {
    _debug(""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue);
  }
  if (wcet > _periodValue) {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    throw new IllegalActionException(container,""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue+ ""String_Node_Str""+ ((CompositeActor)(getContainer())).getDisplayName());
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}"
73536,"public boolean postfire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  _needNew=true;
  double actorExecutionTimes=0;
  double actorWorstCaseExecutionTimes=0;
  List<Actor> entities=((CompositeActor)container).deepEntityList();
  for (  Actor actor : entities) {
    Attribute executionTime=((Entity)actor).getAttribute(""String_Node_Str"");
    Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
    try {
      actorWorstCaseExecutionTimes+=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
      actorExecutionTimes+=((DoubleToken)((Variable)executionTime).getToken()).doubleValue();
    }
 catch (    IllegalActionException ex) {
      ex.printStackTrace();
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + actorExecutionTimes + ""String_Node_Str""+ actorWorstCaseExecutionTimes);
  }
  if (actorExecutionTimes > actorWorstCaseExecutionTimes) {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
    handleModelError(container,new IllegalActionException(container,""String_Node_Str"" + actorExecutionTimes + ""String_Node_Str""+ actorWorstCaseExecutionTimes+ ""String_Node_Str""+ container.getDisplayName()));
  }
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str"",true){
    protected void _execute() throws IllegalActionException {
    }
  }
;
  request.setPersistent(false);
  requestChange(request);
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return true;
}","public boolean postfire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  _needNew=true;
  if (_debugging) {
    _debug(""String_Node_Str"" + _totalObservedExecutionTime + ""String_Node_Str""+ _totalExpectedExecutionTime);
  }
  if (_totalObservedExecutionTime > _totalExpectedExecutionTime) {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    handleModelError(container,new IllegalActionException(container,""String_Node_Str"" + _totalObservedExecutionTime + ""String_Node_Str""+ _totalExpectedExecutionTime+ ""String_Node_Str""+ container.getDisplayName()));
  }
  _totalObservedExecutionTime=0;
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str"",true){
    protected void _execute() throws IllegalActionException {
    }
  }
;
  request.setPersistent(false);
  requestChange(request);
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return true;
}"
73537,"/** 
 * Generate the next random number.
 * @exception IllegalActionException If a call to nextDouble() throws an IllegalActionException
 */
protected void _generateRandomNumber() throws IllegalActionException {
  _current=_random.nextDouble();
}","/** 
 * Generate the next random number.
 * @exception IllegalActionException Not thrown in this base class.
 */
protected void _generateRandomNumber() throws IllegalActionException {
  _current=_random.nextDouble();
}"
73538,"/** 
 * Specify the container. If the container is not the same as the previous container, then start monitoring the new container.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 * @see #getContainer()
 */
public void setContainer(final NamedObj container) throws IllegalActionException, NameDuplicationException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  NamedObj previousContainer=getContainer();
  if (previousContainer == container) {
    return;
  }
  if ((previousContainer != null) && (previousContainer instanceof CompositeActor)) {
    if (_piggybackContainer != null) {
      _piggybackContainer.removePiggyback(_executable);
    }
    _executable=null;
    String name;
    try {
      workspace().getWriteAccess();
      List<Actor> entities=((CompositeActor)previousContainer).deepEntityList();
      for (      Actor entity : entities) {
        List<Attribute> paramList=((Entity)entity).attributeList();
        for (        Attribute param : paramList) {
          name=param.getDisplayName();
          if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
          }
        }
      }
    }
 catch (    Exception ex) {
      throw new InternalErrorException(ex);
    }
 finally {
      workspace().doneTemporaryWriting();
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
  }
  super.setContainer(container);
  if (container != null && container instanceof CompositeActor) {
    if (_executable == null) {
      _executable=new Executable(){
        public void initialize() throws IllegalActionException {
          if (_random == null || ((BooleanToken)resetOnEachRun.getToken()).booleanValue()) {
            _createGenerator();
          }
          _needNew=true;
        }
        public boolean postfire() throws IllegalActionException {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          _needNew=true;
          double actorExecutionTimes=0;
          double actorWorstCaseExecutionTimes=0;
          List<Actor> entities=((CompositeActor)container).deepEntityList();
          for (          Actor actor : entities) {
            Attribute executionTime=((Entity)actor).getAttribute(""String_Node_Str"");
            Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
            try {
              actorWorstCaseExecutionTimes+=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
              actorExecutionTimes+=((DoubleToken)((Variable)executionTime).getToken()).doubleValue();
            }
 catch (            IllegalActionException ex) {
              ex.printStackTrace();
            }
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + actorExecutionTimes + ""String_Node_Str""+ actorWorstCaseExecutionTimes);
          }
          if (actorExecutionTimes > actorWorstCaseExecutionTimes) {
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            System.out.println(""String_Node_Str"");
            handleModelError(container,new IllegalActionException(container,""String_Node_Str"" + actorExecutionTimes + ""String_Node_Str""+ actorWorstCaseExecutionTimes+ ""String_Node_Str""+ container.getDisplayName()));
          }
          ChangeRequest request=new ChangeRequest(this,""String_Node_Str"",true){
            protected void _execute() throws IllegalActionException {
            }
          }
;
          request.setPersistent(false);
          requestChange(request);
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          return true;
        }
        public void wrapup(){
          ChangeRequest request=new ChangeRequest(this,""String_Node_Str"",true){
            protected void _execute() throws IllegalActionException {
            }
          }
;
          request.setPersistent(false);
          requestChange(request);
        }
        public void fire() throws IllegalActionException {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          if (_needNewGenerator) {
            _createGenerator();
          }
          if (_needNew) {
            _generateRandomNumber();
            _needNew=false;
          }
          List<Actor> entities=((CompositeActor)container).deepEntityList();
          for (          Actor actor : entities) {
            _myPhysicalTime=actor.getDirector().getModelTime().getDoubleValue() + _overRunThusFar;
            if (_debugging) {
              _debug(""String_Node_Str"" + actor.getName());
            }
            double actorWCET;
            Attribute executionTime=((Entity)actor).getAttribute(""String_Node_Str"");
            Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
            actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
            double t=_random.nextDouble() * 2 * actorWCET;
            if (t > actorWCET) {
              _overRunThusFar+=(t - actorWCET);
              _myPhysicalTime+=t;
              System.out.println(""String_Node_Str"" + actorWCET + ""String_Node_Str""+ t);
              System.out.println(""String_Node_Str"" + (actor.getDirector().getModelTime().getDoubleValue() + actorWCET) + ""String_Node_Str""+ _myPhysicalTime);
            }
            Parameter dummyP=(Parameter)executionTime;
            dummyP.setExpression(Double.toString(t));
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        public boolean isFireFunctional(){
          return true;
        }
        public boolean isStrict(){
          return true;
        }
        public int iterate(        int count){
          return Executable.COMPLETED;
        }
        public boolean prefire() throws IllegalActionException {
          return true;
        }
        public void stop(){
        }
        public void stopFire(){
        }
        public void terminate(){
        }
        public void addInitializable(        Initializable initializable){
        }
        public void preinitialize() throws IllegalActionException {
          double wcet=0;
          double _periodValue=0;
          wcet=_getDirectorWCET(container);
          _periodValue=_getDirectorPeriod(container);
          if (_debugging) {
            _debug(""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue);
          }
          if (wcet > _periodValue) {
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            throw new IllegalActionException(container,""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue+ ""String_Node_Str""+ ((CompositeActor)(getContainer())).getDisplayName());
          }
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
        }
        public void removeInitializable(        Initializable initializable){
        }
      }
;
    }
    _piggybackContainer=(CompositeActor)container;
    _piggybackContainer.addPiggyback(_executable);
  }
}","/** 
 * Specify the container. If the container is not the same as the previous container, then start monitoring the new container.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 * @see #getContainer()
 */
public void setContainer(final NamedObj container) throws IllegalActionException, NameDuplicationException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  NamedObj previousContainer=getContainer();
  if (previousContainer == container) {
    return;
  }
  if ((previousContainer != null) && (previousContainer instanceof CompositeActor)) {
    if (_piggybackContainer != null) {
      _piggybackContainer.removePiggyback(_executable);
    }
    _executable=null;
    String name;
    try {
      workspace().getWriteAccess();
      List<Actor> entities=((CompositeActor)previousContainer).deepEntityList();
      for (      Actor entity : entities) {
        List<Attribute> paramList=((Entity)entity).attributeList();
        for (        Attribute param : paramList) {
          name=param.getDisplayName();
          if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
          }
        }
      }
    }
 catch (    Exception ex) {
      throw new InternalErrorException(ex);
    }
 finally {
      workspace().doneTemporaryWriting();
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
  }
  super.setContainer(container);
  if (container != null && container instanceof CompositeActor) {
    if (_executable == null) {
      _executable=new Executable(){
        public void initialize() throws IllegalActionException {
          if (_random == null || ((BooleanToken)resetOnEachRun.getToken()).booleanValue()) {
            _createGenerator();
          }
          _needNew=true;
        }
        public boolean postfire() throws IllegalActionException {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          _needNew=true;
          if (_debugging) {
            _debug(""String_Node_Str"" + _totalObservedExecutionTime + ""String_Node_Str""+ _totalExpectedExecutionTime);
          }
          if (_totalObservedExecutionTime > _totalExpectedExecutionTime) {
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            handleModelError(container,new IllegalActionException(container,""String_Node_Str"" + _totalObservedExecutionTime + ""String_Node_Str""+ _totalExpectedExecutionTime+ ""String_Node_Str""+ container.getDisplayName()));
          }
          _totalObservedExecutionTime=0;
          ChangeRequest request=new ChangeRequest(this,""String_Node_Str"",true){
            protected void _execute() throws IllegalActionException {
            }
          }
;
          request.setPersistent(false);
          requestChange(request);
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          return true;
        }
        public void wrapup(){
          ChangeRequest request=new ChangeRequest(this,""String_Node_Str"",true){
            protected void _execute() throws IllegalActionException {
            }
          }
;
          request.setPersistent(false);
          requestChange(request);
        }
        public void fire() throws IllegalActionException {
          if (!_readyToFire) {
            return;
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + container);
          }
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          if (_needNewGenerator) {
            _createGenerator();
          }
          if (_needNew) {
            _generateRandomNumber();
            _needNew=false;
          }
          if (!_readyToFire) {
            return;
          }
          while ((_unitIndex < _schedule.size())) {
            Schedule unitSchedule=(Schedule)_schedule.get(_unitIndex);
            Iterator scheduleIterator=unitSchedule.iterator();
            while (scheduleIterator.hasNext()) {
              Actor actor=((Firing)scheduleIterator.next()).getActor();
              if (_debugging) {
                _debug(""String_Node_Str"" + actor.getFullName());
              }
              _myPhysicalTime=actor.getDirector().getModelTime().getDoubleValue() + _overRunThusFar;
              double actorWCET;
              Attribute executionTime=((Entity)actor).getAttribute(""String_Node_Str"");
              Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
              actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
              double t=_random.nextDouble() * 2 * actorWCET;
              if (_debugging) {
                _debug(""String_Node_Str"" + t);
              }
              _totalObservedExecutionTime+=t;
              if (t > actorWCET) {
                _overRunThusFar+=(t - actorWCET);
                _myPhysicalTime+=t;
                if (_debugging) {
                  _debug(""String_Node_Str"" + actorWCET + ""String_Node_Str""+ t);
                  _debug(""String_Node_Str"" + (actor.getDirector().getModelTime().getDoubleValue() + actorWCET) + ""String_Node_Str""+ _myPhysicalTime);
                }
              }
              Parameter dummyP=(Parameter)executionTime;
              dummyP.setExpression(Double.toString(t));
              if (_debugging) {
                _debug(""String_Node_Str"" + actor + ""String_Node_Str"");
              }
            }
            scheduleIterator=unitSchedule.iterator();
            while (scheduleIterator.hasNext()) {
              Actor actor1=((Firing)scheduleIterator.next()).getActor();
              if (_debugging) {
                _debug(""String_Node_Str"" + ((NamedObj)actor1).getFullName());
              }
              if (actor1.iterate(1) == STOP_ITERATING) {
                System.err.println(""String_Node_Str"" + ""String_Node_Str"" + actor1.getFullName() + ""String_Node_Str"");
              }
            }
            _unitIndex++;
          }
          if (_unitIndex >= _schedule.size()) {
            _unitIndex=0;
          }
        }
        public boolean isFireFunctional(){
          return true;
        }
        public boolean isStrict(){
          return true;
        }
        public int iterate(        int count){
          return Executable.COMPLETED;
        }
        public boolean prefire() throws IllegalActionException {
          return true;
        }
        public void stop(){
        }
        public void stopFire(){
        }
        public void terminate(){
        }
        public void addInitializable(        Initializable initializable){
        }
        public void preinitialize() throws IllegalActionException {
          double wcet=0;
          double _periodValue=0;
          wcet=_getDirectorWCET(container);
          _periodValue=_getDirectorPeriod(container);
          GiottoScheduler scheduler=(GiottoScheduler)((GiottoDirector)((CompositeActor)container).getDirector()).getScheduler();
          _schedule=scheduler.getSchedule();
          if (_debugging) {
            _debug(""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue);
          }
          if (wcet > _periodValue) {
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            throw new IllegalActionException(container,""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue+ ""String_Node_Str""+ ((CompositeActor)(getContainer())).getDisplayName());
          }
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
        }
        public void removeInitializable(        Initializable initializable){
        }
      }
;
    }
    _piggybackContainer=(CompositeActor)container;
    _piggybackContainer.addPiggyback(_executable);
  }
}"
73539,"/** 
 * Construct a server on the port specified by <tt>portNo</tt>.
 * @param portNo Port number for BSD socket.
 * @param timOut Socket time out in milliseconds.
 * @exception IOException If the server socket cannot be opened.
 */
public Server(int portNo,int timOut) throws IOException {
  serSoc=new ServerSocket(portNo);
  flaFroCli=0;
  if (!serSoc.isBound()) {
    String em=""String_Node_Str"";
    throw new IOException(em);
  }
  serSoc.setSoTimeout(timOut);
}","/** 
 * Construct a server on the port specified by <tt>portNo</tt>.
 * @param portNo Port number for BSD socket.
 * @param timOut Socket time out in milliseconds.
 * @exception IOException If the server socket cannot be opened.
 */
public Server(int portNo,int timOut) throws IOException {
  serSoc=new ServerSocket();
  serSoc.bind(new java.net.InetSocketAddress(portNo));
  flaFroCli=0;
  if (!serSoc.isBound()) {
    String em=""String_Node_Str"";
    throw new IOException(em);
  }
  serSoc.setSoTimeout(timOut);
}"
73540,"/** 
 * Write data to the socket.
 * @param flagToClient The communication flag.
 * @param curTim The current simulation time.
 * @param dblVal The array with double values.
 * @exception IOException If a communication problems occur.
 */
public void write(int flagToClient,double curTim,double[] dblVal) throws IOException {
  simTimWri=curTim;
  final int nDbl=(dblVal != null) ? dblVal.length : 0;
  StringBuffer strBuf=new StringBuffer(Integer.toString(verNo));
  strBuf.append(""String_Node_Str"" + Integer.toString(flagToClient));
  strBuf.append(""String_Node_Str"" + Integer.toString(nDbl));
  strBuf.append(""String_Node_Str"");
  strBuf.append(curTim);
  strBuf.append(""String_Node_Str"");
  for (int i=0; i < nDbl; i++) {
    strBuf.append(String.valueOf(dblVal[i]));
    strBuf.append(""String_Node_Str"");
  }
  strBuf.append(System.getProperty(""String_Node_Str""));
  _write(strBuf);
}","/** 
 * Write data to the socket.
 * @param flagToClient The communication flag.
 * @param curTim The current simulation time.
 * @param dblVal The array with double values.
 * @exception IOException If a communication problems occur.
 */
public void write(int flagToClient,double curTim,double[] dblVal) throws IOException {
  simTimWri=curTim;
  final int nDbl=(dblVal != null) ? dblVal.length : 0;
  StringBuffer strBuf=new StringBuffer(Integer.toString(verNo));
  strBuf.append(""String_Node_Str"" + Integer.toString(flagToClient));
  strBuf.append(""String_Node_Str"" + Integer.toString(nDbl));
  strBuf.append(""String_Node_Str"");
  strBuf.append(curTim);
  strBuf.append(""String_Node_Str"");
  for (int i=0; i < nDbl; i++) {
    strBuf.append(String.valueOf(dblVal[i]));
    strBuf.append(""String_Node_Str"");
  }
  strBuf.append(""String_Node_Str"");
  _write(strBuf);
}"
73541,"/** 
 * Write the data to the socket.
 * @param strBuf The string buffer to be sent to the socket.
 * @exception IOException If communication problems occur.
 */
private void _write(StringBuffer strBuf) throws IOException {
  BufferedWriter wr=new BufferedWriter(new OutputStreamWriter(cliSoc.getOutputStream()));
  wr.write(new String(strBuf));
  wr.flush();
}","/** 
 * Write the data to the socket.
 * @param strBuf The string buffer to be sent to the socket.
 * @exception IOException If communication problems occur.
 */
private void _write(StringBuffer strBuf) throws IOException {
  BufferedWriter wr=new BufferedWriter(new OutputStreamWriter(cliSoc.getOutputStream()));
  final String str=new String(strBuf);
  final int maxCha=8192;
  final int strLen=str.length();
  final int nWri=strLen / maxCha + 1;
  for (int i=0; i < nWri; i++) {
    wr.write(str.substring(i * maxCha,java.lang.Math.min(strLen,(i + 1) * maxCha)));
    wr.flush();
  }
}"
73542,"/** 
 * Construct an instance with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public GiottoTimingManager(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  SingletonParameter hideName=new SingletonParameter(this,""String_Node_Str"");
  hideName.setToken(BooleanToken.TRUE);
  hideName.setVisibility(Settable.EXPERT);
  seed=new SharedParameter(this,""String_Node_Str"",GiottoTimingManager.class,""String_Node_Str"");
  seed.setTypeEquals(BaseType.LONG);
  resetOnEachRun=new SharedParameter(this,""String_Node_Str"",GiottoTimingManager.class,""String_Node_Str"");
  resetOnEachRun.setTypeEquals(BaseType.BOOLEAN);
  probabilityDistribution=new StringParameter(this,""String_Node_Str"");
  probabilityDistribution.setExpression(""String_Node_Str"");
  probabilityDistribution.addChoice(""String_Node_Str"");
}","/** 
 * Construct an instance with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public GiottoTimingManager(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  SingletonParameter hideName=new SingletonParameter(this,""String_Node_Str"");
  hideName.setToken(BooleanToken.TRUE);
  hideName.setVisibility(Settable.EXPERT);
  seed=new SharedParameter(this,""String_Node_Str"",GiottoTimingManager.class,""String_Node_Str"");
  seed.setTypeEquals(BaseType.LONG);
  resetOnEachRun=new SharedParameter(this,""String_Node_Str"",GiottoTimingManager.class,""String_Node_Str"");
  resetOnEachRun.setTypeEquals(BaseType.BOOLEAN);
  probabilityDistribution=new StringParameter(this,""String_Node_Str"");
  probabilityDistribution.setExpression(""String_Node_Str"");
  probabilityDistribution.addChoice(""String_Node_Str"");
  _overRunThusFar=0.0;
}"
73543,"public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (_needNewGenerator) {
    _createGenerator();
  }
  if (_needNew) {
    _generateRandomNumber();
    _needNew=false;
  }
  List<Actor> entities=((CompositeActor)container).deepEntityList();
  for (  Actor actor : entities) {
    if (_debugging) {
      _debug(""String_Node_Str"" + actor.getName());
    }
    double actorWCET;
    Attribute executionTime=((Entity)actor).getAttribute(""String_Node_Str"");
    Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
    actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
    double t=_random.nextDouble() * 2 * actorWCET;
    Parameter dummyP=(Parameter)executionTime;
    dummyP.setExpression(Double.toString(t));
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + ""String_Node_Str"");
  }
}","public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (_needNewGenerator) {
    _createGenerator();
  }
  if (_needNew) {
    _generateRandomNumber();
    _needNew=false;
  }
  List<Actor> entities=((CompositeActor)container).deepEntityList();
  for (  Actor actor : entities) {
    _myPhysicalTime=actor.getDirector().getModelTime().getDoubleValue() + _overRunThusFar;
    if (_debugging) {
      _debug(""String_Node_Str"" + actor.getName());
    }
    double actorWCET;
    Attribute executionTime=((Entity)actor).getAttribute(""String_Node_Str"");
    Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
    actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
    double t=_random.nextDouble() * 2 * actorWCET;
    if (t > actorWCET) {
      _overRunThusFar+=(t - actorWCET);
      _myPhysicalTime+=t;
      System.out.println(""String_Node_Str"" + actorWCET + ""String_Node_Str""+ t);
      System.out.println(""String_Node_Str"" + (actor.getDirector().getModelTime().getDoubleValue() + actorWCET) + ""String_Node_Str""+ _myPhysicalTime);
    }
    Parameter dummyP=(Parameter)executionTime;
    dummyP.setExpression(Double.toString(t));
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
73544,"/** 
 * Generate the next random number.
 */
protected void _generateRandomNumber() throws IllegalActionException {
  _current=_random.nextDouble();
}","/** 
 * Generate the next random number.
 * @exception IllegalActionException If a call to nextDouble() throws an IllegalActionException
 */
protected void _generateRandomNumber() throws IllegalActionException {
  _current=_random.nextDouble();
}"
73545,"/** 
 * Specify the container. If the container is not the same as the previous container, then start monitoring the new container.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 * @see #getContainer()
 */
public void setContainer(final NamedObj container) throws IllegalActionException, NameDuplicationException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  NamedObj previousContainer=getContainer();
  if (previousContainer == container) {
    return;
  }
  if ((previousContainer != null) && (previousContainer instanceof CompositeActor)) {
    if (_piggybackContainer != null) {
      _piggybackContainer.removePiggyback(_executable);
    }
    _executable=null;
    String name;
    try {
      workspace().getWriteAccess();
      List<Actor> entities=((CompositeActor)previousContainer).deepEntityList();
      for (      Actor entity : entities) {
        List<Attribute> paramList=((Entity)entity).attributeList();
        for (        Attribute param : paramList) {
          name=param.getDisplayName();
          if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
          }
        }
      }
    }
 catch (    Exception ex) {
      throw new InternalErrorException(ex);
    }
 finally {
      workspace().doneTemporaryWriting();
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
  }
  super.setContainer(container);
  if (container != null && container instanceof CompositeActor) {
    if (_executable == null) {
      _executable=new Executable(){
        public void initialize() throws IllegalActionException {
          if (_random == null || ((BooleanToken)resetOnEachRun.getToken()).booleanValue()) {
            _createGenerator();
          }
          _needNew=true;
        }
        public boolean postfire() throws IllegalActionException {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          _needNew=true;
          double actorExecutionTimes=0;
          double actorWorstCaseExecutionTimes=0;
          List<Actor> entities=((CompositeActor)container).deepEntityList();
          for (          Actor actor : entities) {
            Attribute executionTime=((Entity)actor).getAttribute(""String_Node_Str"");
            Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
            try {
              actorWorstCaseExecutionTimes+=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
              actorExecutionTimes+=((DoubleToken)((Variable)executionTime).getToken()).doubleValue();
            }
 catch (            IllegalActionException ex) {
              ex.printStackTrace();
            }
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + actorExecutionTimes + ""String_Node_Str""+ actorWorstCaseExecutionTimes);
          }
          if (actorExecutionTimes > actorWorstCaseExecutionTimes) {
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            System.out.println(""String_Node_Str"");
            handleModelError(container,new IllegalActionException(container,""String_Node_Str"" + actorExecutionTimes + ""String_Node_Str""+ actorWorstCaseExecutionTimes+ ""String_Node_Str""+ container.getDisplayName()));
          }
          ChangeRequest request=new ChangeRequest(this,""String_Node_Str"",true){
            protected void _execute() throws IllegalActionException {
            }
          }
;
          request.setPersistent(false);
          requestChange(request);
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          return true;
        }
        public void wrapup(){
          ChangeRequest request=new ChangeRequest(this,""String_Node_Str"",true){
            protected void _execute() throws IllegalActionException {
            }
          }
;
          request.setPersistent(false);
          requestChange(request);
        }
        public void fire() throws IllegalActionException {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          if (_needNewGenerator) {
            _createGenerator();
          }
          if (_needNew) {
            _generateRandomNumber();
            _needNew=false;
          }
          List<Actor> entities=((CompositeActor)container).deepEntityList();
          for (          Actor actor : entities) {
            if (_debugging) {
              _debug(""String_Node_Str"" + actor.getName());
            }
            double actorWCET;
            Attribute executionTime=((Entity)actor).getAttribute(""String_Node_Str"");
            Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
            actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
            double t=_random.nextDouble() * 2 * actorWCET;
            Parameter dummyP=(Parameter)executionTime;
            dummyP.setExpression(Double.toString(t));
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        public boolean isFireFunctional(){
          return true;
        }
        public boolean isStrict(){
          return true;
        }
        public int iterate(        int count){
          return Executable.COMPLETED;
        }
        public boolean prefire() throws IllegalActionException {
          return true;
        }
        public void stop(){
        }
        public void stopFire(){
        }
        public void terminate(){
        }
        public void addInitializable(        Initializable initializable){
        }
        public void preinitialize() throws IllegalActionException {
          double wcet=0;
          double _periodValue=0;
          wcet=_getDirectorWCET(container);
          _periodValue=_getDirectorPeriod(container);
          if (_debugging) {
            _debug(""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue);
          }
          if (wcet > _periodValue) {
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            throw new IllegalActionException(container,""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue+ ""String_Node_Str""+ ((CompositeActor)(getContainer())).getDisplayName());
          }
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
        }
        public void removeInitializable(        Initializable initializable){
        }
      }
;
    }
    _piggybackContainer=(CompositeActor)container;
    _piggybackContainer.addPiggyback(_executable);
  }
}","/** 
 * Specify the container. If the container is not the same as the previous container, then start monitoring the new container.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 * @see #getContainer()
 */
public void setContainer(final NamedObj container) throws IllegalActionException, NameDuplicationException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  NamedObj previousContainer=getContainer();
  if (previousContainer == container) {
    return;
  }
  if ((previousContainer != null) && (previousContainer instanceof CompositeActor)) {
    if (_piggybackContainer != null) {
      _piggybackContainer.removePiggyback(_executable);
    }
    _executable=null;
    String name;
    try {
      workspace().getWriteAccess();
      List<Actor> entities=((CompositeActor)previousContainer).deepEntityList();
      for (      Actor entity : entities) {
        List<Attribute> paramList=((Entity)entity).attributeList();
        for (        Attribute param : paramList) {
          name=param.getDisplayName();
          if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
          }
        }
      }
    }
 catch (    Exception ex) {
      throw new InternalErrorException(ex);
    }
 finally {
      workspace().doneTemporaryWriting();
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
  }
  super.setContainer(container);
  if (container != null && container instanceof CompositeActor) {
    if (_executable == null) {
      _executable=new Executable(){
        public void initialize() throws IllegalActionException {
          if (_random == null || ((BooleanToken)resetOnEachRun.getToken()).booleanValue()) {
            _createGenerator();
          }
          _needNew=true;
        }
        public boolean postfire() throws IllegalActionException {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          _needNew=true;
          double actorExecutionTimes=0;
          double actorWorstCaseExecutionTimes=0;
          List<Actor> entities=((CompositeActor)container).deepEntityList();
          for (          Actor actor : entities) {
            Attribute executionTime=((Entity)actor).getAttribute(""String_Node_Str"");
            Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
            try {
              actorWorstCaseExecutionTimes+=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
              actorExecutionTimes+=((DoubleToken)((Variable)executionTime).getToken()).doubleValue();
            }
 catch (            IllegalActionException ex) {
              ex.printStackTrace();
            }
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + actorExecutionTimes + ""String_Node_Str""+ actorWorstCaseExecutionTimes);
          }
          if (actorExecutionTimes > actorWorstCaseExecutionTimes) {
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            System.out.println(""String_Node_Str"");
            handleModelError(container,new IllegalActionException(container,""String_Node_Str"" + actorExecutionTimes + ""String_Node_Str""+ actorWorstCaseExecutionTimes+ ""String_Node_Str""+ container.getDisplayName()));
          }
          ChangeRequest request=new ChangeRequest(this,""String_Node_Str"",true){
            protected void _execute() throws IllegalActionException {
            }
          }
;
          request.setPersistent(false);
          requestChange(request);
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          return true;
        }
        public void wrapup(){
          ChangeRequest request=new ChangeRequest(this,""String_Node_Str"",true){
            protected void _execute() throws IllegalActionException {
            }
          }
;
          request.setPersistent(false);
          requestChange(request);
        }
        public void fire() throws IllegalActionException {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          if (_needNewGenerator) {
            _createGenerator();
          }
          if (_needNew) {
            _generateRandomNumber();
            _needNew=false;
          }
          List<Actor> entities=((CompositeActor)container).deepEntityList();
          for (          Actor actor : entities) {
            _myPhysicalTime=actor.getDirector().getModelTime().getDoubleValue() + _overRunThusFar;
            if (_debugging) {
              _debug(""String_Node_Str"" + actor.getName());
            }
            double actorWCET;
            Attribute executionTime=((Entity)actor).getAttribute(""String_Node_Str"");
            Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
            actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
            double t=_random.nextDouble() * 2 * actorWCET;
            if (t > actorWCET) {
              _overRunThusFar+=(t - actorWCET);
              _myPhysicalTime+=t;
              System.out.println(""String_Node_Str"" + actorWCET + ""String_Node_Str""+ t);
              System.out.println(""String_Node_Str"" + (actor.getDirector().getModelTime().getDoubleValue() + actorWCET) + ""String_Node_Str""+ _myPhysicalTime);
            }
            Parameter dummyP=(Parameter)executionTime;
            dummyP.setExpression(Double.toString(t));
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        public boolean isFireFunctional(){
          return true;
        }
        public boolean isStrict(){
          return true;
        }
        public int iterate(        int count){
          return Executable.COMPLETED;
        }
        public boolean prefire() throws IllegalActionException {
          return true;
        }
        public void stop(){
        }
        public void stopFire(){
        }
        public void terminate(){
        }
        public void addInitializable(        Initializable initializable){
        }
        public void preinitialize() throws IllegalActionException {
          double wcet=0;
          double _periodValue=0;
          wcet=_getDirectorWCET(container);
          _periodValue=_getDirectorPeriod(container);
          if (_debugging) {
            _debug(""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue);
          }
          if (wcet > _periodValue) {
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            throw new IllegalActionException(container,""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue+ ""String_Node_Str""+ ((CompositeActor)(getContainer())).getDisplayName());
          }
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
        }
        public void removeInitializable(        Initializable initializable){
        }
      }
;
    }
    _piggybackContainer=(CompositeActor)container;
    _piggybackContainer.addPiggyback(_executable);
  }
}"
73546,"/** 
 * Return the string representation of this monotonicity concept. Note that the syntax here is similar to that used for records (e.g. { x:Monotonic, y:Anitmonotonic }).
 * @return The string representation of this concept.
 */
public String toString(){
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  for (  String key : _variableToMonotonicity.keySet()) {
    result.append(' ');
    result.append(key);
    result.append(':');
    result.append(getMonotonicity(key));
    result.append(',');
  }
  result.deleteCharAt(result.length() - 1);
  result.append(""String_Node_Str"");
  return result.toString();
}","/** 
 * Return the string representation of this monotonicity concept. Note that the syntax here is similar to that used for records (e.g. { x:Monotonic, y:Anitmonotonic }).
 * @return The string representation of this concept.
 */
public String toString(){
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  for (  String key : _variableToMonotonicity.keySet()) {
    result.append(' ');
    result.append(key);
    result.append(':');
    result.append(getMonotonicity(key));
    result.append(',');
  }
  if (result.charAt(result.length() - 1) == ',') {
    result.deleteCharAt(result.length() - 1);
  }
  result.append(""String_Node_Str"");
  return result.toString();
}"
73547,"/** 
 * Initialize the variables of this relation. 
 */
private void _init() throws IllegalActionException, NameDuplicationException {
  annotation=new StringParameter(this,""String_Node_Str"");
  annotation.setExpression(""String_Node_Str"");
  Variable variable=new Variable(annotation,""String_Node_Str"");
  variable.setExpression(""String_Node_Str"");
  variable.setPersistent(false);
  exitAngle=new Parameter(this,""String_Node_Str"");
  exitAngle.setVisibility(Settable.NONE);
  exitAngle.setExpression(""String_Node_Str"");
  exitAngle.setTypeEquals(BaseType.DOUBLE);
}","/** 
 * Initialize the variables of this relation.
 * @throws IllegalActionException Thrown if the relation's variablescannot be initialized.
 * @throws NameDuplicationException Thrown if any of the names of attributescreated for this relation conflict with existing attributes in this relation.
 */
private void _init() throws IllegalActionException, NameDuplicationException {
  annotation=new StringParameter(this,""String_Node_Str"");
  annotation.setExpression(""String_Node_Str"");
  Variable variable=new Variable(annotation,""String_Node_Str"");
  variable.setExpression(""String_Node_Str"");
  variable.setPersistent(false);
  exitAngle=new Parameter(this,""String_Node_Str"");
  exitAngle.setVisibility(Settable.NONE);
  exitAngle.setExpression(""String_Node_Str"");
  exitAngle.setTypeEquals(BaseType.DOUBLE);
}"
73548,"/** 
 * Set the property of specified object equal to the specified property.
 * @param object The specified object.
 * @param property The specified property.
 */
public void setEquals(Object object,Concept property){
  _solver.setResolvedConcept(object,property);
  _solver.markAsNonSettable(object);
}","/** 
 * Set the property of specified object equal to the specified property.
 * @param object The specified object.
 * @param property The specified property.
 */
public void setEquals(Object object,Concept property){
  _solver.setConcept(object,property);
  _solver.markAsNonSettable(object);
}"
73549,"/** 
 * Show all concept values as text annotations on each model element.
 * @throws IllegalActionException If getting the resolved concept fails.
 */
public void showConceptAnnotations() throws IllegalActionException {
  OntologySolver solver=(OntologySolver)getContainer();
  for (  Object propertyable : solver.getAllPropertyables()) {
    if (propertyable instanceof NamedObj) {
      Concept concept=solver.getResolvedConcept(propertyable,false);
      if (concept != null) {
        String request=""String_Node_Str"" + concept.toString() + ""String_Node_Str"";
        MoMLChangeRequest change=new MoMLChangeRequest(this,(NamedObj)propertyable,request,false);
        ((NamedObj)propertyable).requestChange(change);
      }
    }
  }
  solver.requestChange(new MoMLChangeRequest(this,solver,""String_Node_Str""));
}","/** 
 * Show all concept values as text annotations on each model element.
 * @throws IllegalActionException If getting the resolved concept fails.
 */
public void showConceptAnnotations() throws IllegalActionException {
  OntologySolver solver=(OntologySolver)getContainer();
  for (  Object propertyable : solver.getAllPropertyables()) {
    if (propertyable instanceof NamedObj) {
      Concept concept=solver.getConcept(propertyable);
      if (concept != null) {
        String request=""String_Node_Str"" + concept.toString() + ""String_Node_Str"";
        MoMLChangeRequest change=new MoMLChangeRequest(this,(NamedObj)propertyable,request,false);
        ((NamedObj)propertyable).requestChange(change);
      }
    }
  }
  solver.requestChange(new MoMLChangeRequest(this,solver,""String_Node_Str""));
}"
73550,"/** 
 * Remove the highlighting and visible annotations for all property-able objects.
 * @param colors True if the highlight colors should be cleared.
 * @param text True if the ontology concept annotation text should be cleared.
 * @throws IllegalActionException If getting the resolved concept fails.
 */
public void clearDisplay(boolean colors,boolean text) throws IllegalActionException {
  if (colors || text) {
    OntologySolver solver=(OntologySolver)getContainer();
    for (    Object propertyable : solver.getAllPropertyables()) {
      if (propertyable instanceof NamedObj) {
        Concept concept=solver.getResolvedConcept(propertyable,false);
        if (concept != null || ((((NamedObj)propertyable).getAttribute(""String_Node_Str"") != null) && colors || (((NamedObj)propertyable).getAttribute(""String_Node_Str"") != null) && text)) {
          String request=""String_Node_Str"";
          if (((NamedObj)propertyable).getAttribute(""String_Node_Str"") != null && text) {
            request+=""String_Node_Str"";
          }
          if (((NamedObj)propertyable).getAttribute(""String_Node_Str"") != null && colors) {
            request+=""String_Node_Str"";
          }
          request+=""String_Node_Str"";
          MoMLChangeRequest change=new MoMLChangeRequest(this,(NamedObj)propertyable,request,false);
          ((NamedObj)propertyable).requestChange(change);
        }
      }
    }
    solver.requestChange(new MoMLChangeRequest(this,solver,""String_Node_Str""));
  }
}","/** 
 * Remove the highlighting and visible annotations for all property-able objects.
 * @param colors True if the highlight colors should be cleared.
 * @param text True if the ontology concept annotation text should be cleared.
 * @throws IllegalActionException If getting the resolved concept fails.
 */
public void clearDisplay(boolean colors,boolean text) throws IllegalActionException {
  if (colors || text) {
    OntologySolver solver=(OntologySolver)getContainer();
    for (    Object propertyable : solver.getAllPropertyables()) {
      if (propertyable instanceof NamedObj) {
        Concept concept=solver.getConcept(propertyable);
        if (concept != null || ((((NamedObj)propertyable).getAttribute(""String_Node_Str"") != null) && colors || (((NamedObj)propertyable).getAttribute(""String_Node_Str"") != null) && text)) {
          String request=""String_Node_Str"";
          if (((NamedObj)propertyable).getAttribute(""String_Node_Str"") != null && text) {
            request+=""String_Node_Str"";
          }
          if (((NamedObj)propertyable).getAttribute(""String_Node_Str"") != null && colors) {
            request+=""String_Node_Str"";
          }
          request+=""String_Node_Str"";
          MoMLChangeRequest change=new MoMLChangeRequest(this,(NamedObj)propertyable,request,false);
          ((NamedObj)propertyable).requestChange(change);
        }
      }
    }
    solver.requestChange(new MoMLChangeRequest(this,solver,""String_Node_Str""));
  }
}"
73551,"/** 
 * Highlight concepts that have already been resolved, but do not run solver. Otherwise, do nothing.
 * @param objects The set of objects to highlight.
 */
public void highlightConcepts(Set<Object> objects){
  if (objects != null) {
    OntologySolver solver=(OntologySolver)getContainer();
    for (    Object object : objects) {
      if (object instanceof NamedObj) {
        Concept concept=solver.getResolvedConcept(object,false);
        if (concept != null) {
          List<ColorAttribute> colors=concept.attributeList(ColorAttribute.class);
          if (colors != null && colors.size() > 0) {
            ColorAttribute conceptColor=colors.get(0);
            String request=""String_Node_Str"" + ""String_Node_Str"" + conceptColor.getExpression() + ""String_Node_Str"";
            MoMLChangeRequest change=new MoMLChangeRequest(this,(NamedObj)object,request,false);
            ((NamedObj)object).requestChange(change);
          }
        }
      }
    }
    solver.requestChange(new MoMLChangeRequest(this,solver,""String_Node_Str""));
  }
}","/** 
 * Highlight concepts that have already been resolved, but do not run solver. Otherwise, do nothing.
 * @param objects The set of objects to highlight.
 */
public void highlightConcepts(Set<Object> objects){
  if (objects != null) {
    OntologySolver solver=(OntologySolver)getContainer();
    for (    Object object : objects) {
      if (object instanceof NamedObj) {
        Concept concept=solver.getConcept(object);
        if (concept != null) {
          List<ColorAttribute> colors=concept.attributeList(ColorAttribute.class);
          if (colors != null && colors.size() > 0) {
            ColorAttribute conceptColor=colors.get(0);
            String request=""String_Node_Str"" + ""String_Node_Str"" + conceptColor.getExpression() + ""String_Node_Str"";
            MoMLChangeRequest change=new MoMLChangeRequest(this,(NamedObj)object,request,false);
            ((NamedObj)object).requestChange(change);
          }
        }
      }
    }
    solver.requestChange(new MoMLChangeRequest(this,solver,""String_Node_Str""));
  }
}"
73552,"/** 
 * Invoke the solver directly, with a choice as to whether or not this  solver should display its resolved concepts.
 * @param displayProperties  True if the solver should display its properties; false otherwise (for example, if it is called from another solver)
 * @return True if the invocation succeeds; otherwise false which means anerror has occurred during the process.
 */
public boolean invokeSolver(boolean displayProperties){
  boolean success=false;
  try {
    initialize();
    resolveConcepts();
    updateConcepts();
    checkErrors();
    if (displayProperties) {
      displayConcepts();
    }
  }
 catch (  KernelException e) {
    resetAll();
    throw new InternalErrorException(e);
  }
  return success;
}","/** 
 * Invoke the solver directly, with a choice as to whether or not this  solver should display its resolved concepts.
 * @param displayProperties  True if the solver should display its properties; false otherwise (for example, if it is called from another solver)
 * @return True if the invocation succeeds; otherwise false which means anerror has occurred during the process.
 */
public boolean invokeSolver(boolean displayProperties){
  boolean success=false;
  try {
    initialize();
    resolveConcepts();
    checkErrors();
    if (displayProperties) {
      displayConcepts();
    }
  }
 catch (  KernelException e) {
    reset();
    throw new InternalErrorException(e);
  }
  return success;
}"
73553,"/** 
 * Reset the solver. This removes the internal states of the solver (e.g. previously recorded properties, statistics, etc.).  It also removes this solver from the list of ran solvers.
 */
public void reset(){
  super.reset();
  _ontologySolverUtilities.removeRanSolver(this);
}","/** 
 * Reset the solver. This removes the internal states of the solver (e.g. previously recorded properties, statistics, etc.).  It also removes this solver from the list of ran solvers.
 */
public void reset(){
  super.reset();
}"
73554,"/** 
 * Return the concept value associated with the specified object.
 * @param object The specified object.
 * @return The property of the specified object.
 */
public Concept getConcept(Object object){
  return getResolvedConcept(object,false);
}","/** 
 * Return the concept value associated with the specified object.
 * @param object The specified object.
 * @return The property of the specified object.
 */
public Concept getConcept(Object object){
  return _resolvedProperties.get(object);
}"
73555,"/** 
 * Perform property resolution.
 * @exception KernelException Thrown if sub-class throws it.
 */
public abstract void resolveConcepts() throws KernelException ;","/** 
 * Execute the OntologySolver's algorithm to resolve which Concepts in the Ontology are assigned to each object in the model.
 * @throws KernelException If the ontology resolution fails.
 */
public abstract void resolveConcepts() throws KernelException ;"
73556,"/** 
 * Reset the solver.  
 */
public void reset(){
  _resolvedProperties=new HashMap<Object,Concept>();
  _nonSettables=new HashSet<Object>();
  _adapterStore=new HashMap<Object,OntologyAdapter>();
}","/** 
 * Reset the solver.  
 */
public void reset(){
  _resolvedProperties=new HashMap<Object,Concept>();
  _nonSettables=new HashSet<Object>();
  _adapterStore=new HashMap<Object,OntologyAdapter>();
  _resetParser();
  getOntologySolverUtilities().resetAll();
}"
73557,"/** 
 * Return true if the product lattice ontology is a lattice. If all the component onotlogies are lattices, then the product lattice ontology will also be a lattice. This is determined by the complete partial order for this lattice.
 * @return true if the product lattice ontology is a lattice, falseotherwise.
 * @see #getGraph()
 * @see ProductLatticeCPO
 */
public boolean isLattice(){
  CPO ontologyCPO=getGraph();
  if (ontologyCPO != null) {
    return ontologyCPO.isLattice();
  }
 else {
    return false;
  }
}","/** 
 * Return true if the product lattice ontology is a lattice. If all the component onotlogies are lattices, then the product lattice ontology will also be a lattice. This is determined by the complete partial order for this lattice.
 * @return true if the product lattice ontology is a lattice, falseotherwise.
 * @see #getGraph()
 * @see ProductLatticeCPO
 */
public boolean isLattice(){
  CPO ontologyCPO=getConceptGraph();
  if (ontologyCPO != null) {
    return ontologyCPO.isLattice();
  }
 else {
    return false;
  }
}"
73558,"/** 
 * Generate code for making transition. It generates code for both choice action and commit action.
 * @param code The string buffer that the generated code is appended to.
 * @param transitionRetriever An instance of a class implementinga method. which returns an iterator of all, preemptive or non-preemptive transitions of the current state.
 * @exception IllegalActionException If thrown while generatingtransition code.
 */
public void generateTransitionCode(StringBuffer code,TransitionRetriever transitionRetriever) throws IllegalActionException {
  StringBuffer codeBuffer=new StringBuffer();
  ptolemy.domains.modal.kernel.FSMActor fsmActor=(ptolemy.domains.modal.kernel.FSMActor)getComponent();
  codeBuffer.append(""String_Node_Str"" + _eol);
  codeBuffer.append(""String_Node_Str"" + _eol);
  for (  State state : (List<State>)fsmActor.entityList()) {
    codeBuffer.append(""String_Node_Str"" + _generateStateConstantLabel(state) + ""String_Node_Str""+ _eol);
    Iterator transitions=transitionRetriever.retrieveTransitions(state);
    List reOrderedTransitions=new LinkedList();
    List defaultTransitions=new LinkedList();
    while (transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      if (generateSimpleName(transition).equals(""String_Node_Str"")) {
        defaultTransitions.add(transition);
      }
 else {
        reOrderedTransitions.add(transition);
      }
    }
    reOrderedTransitions.addAll(defaultTransitions);
    transitions=reOrderedTransitions.iterator();
    int transitionCount=0;
    boolean hasDefaultCase=false;
    while (!hasDefaultCase && transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      String guard=transition.getGuardExpression();
      if (transition.isDefault() || guard.toLowerCase().equals(""String_Node_Str"")) {
        hasDefaultCase=true;
      }
 else {
        if (transitionCount == 0) {
          codeBuffer.append(""String_Node_Str"");
        }
 else {
          codeBuffer.append(""String_Node_Str"");
        }
        transitionCount++;
        PtParser parser=new PtParser();
        int index=guard.indexOf(""String_Node_Str"");
        ASTPtRootNode guardParseTree=parser.generateParseTree(guard);
        ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
        parseTreeCodeGenerator.evaluateParseTree(guardParseTree,_scope);
        int index2=transition.getFullName().indexOf(""String_Node_Str"");
        String tempName=transition.getFullName().substring(1,index2) + guard.substring(0,index - 1);
        tempName=tempName.replace(""String_Node_Str"",""String_Node_Str"");
        codeBuffer.append(tempName + ""String_Node_Str"");
        codeBuffer.append(""String_Node_Str"");
        codeBuffer.append(""String_Node_Str"");
      }
      codeBuffer.append(""String_Node_Str"" + _eol);
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.choiceActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          StringBuffer sendCode=new StringBuffer();
          if (channel >= 0) {
            codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            if (((IOPort)destination).isInput()) {
              NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
              StringBuffer containerReference=new StringBuffer();
              containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
              if (((IOPort)destination).isMultiport()) {
                containerReference.append(""String_Node_Str"" + channel);
              }
              containerReference.append(""String_Node_Str"");
              codeBuffer.append((containerHelper).processCode(containerReference.toString()) + ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol);
            }
          }
 else {
            int width=((IOPort)action.getDestination(destinationName)).getWidth();
            for (int i=0; i < width; i++) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str""+ _eol);
              if (((IOPort)destination).isInput()) {
                NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
                StringBuffer containerReference=new StringBuffer();
                containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
                if (((IOPort)destination).isMultiport()) {
                  containerReference.append(""String_Node_Str"" + i);
                }
                containerReference.append(""String_Node_Str"");
                codeBuffer.append((containerHelper).processCode(containerReference.toString()) + ""String_Node_Str"");
                sendCode.append(""String_Node_Str"" + generateSimpleName(destination) + ""String_Node_Str""+ i+ ""String_Node_Str""+ _eol);
              }
            }
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
          codeBuffer.append(sendCode);
        }
      }
      Actor[] actors=transition.getRefinement();
      if (actors != null) {
        for (int i=0; i < actors.length; i++) {
          NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
          codeBuffer.append(helper.generateFireCode());
        }
      }
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.commitActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          if (destination instanceof IOPort) {
            if (channel >= 0) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            }
 else {
              int width=((IOPort)action.getDestination(destinationName)).getWidth();
              for (int i=0; i < width; i++) {
                codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
              }
            }
          }
 else           if (destination instanceof Variable) {
            if (getCodeGenerator() == null) {
            }
            codeBuffer.append(getCodeGenerator().generateVariableName(destination) + ""String_Node_Str"");
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
        }
      }
      State destinationState=transition.destinationState();
      _updateCurrentState(codeBuffer,destinationState);
      BooleanToken resetToken=(BooleanToken)transition.reset.getToken();
      if (resetToken.booleanValue()) {
        actors=destinationState.getRefinement();
        if (actors != null) {
          for (int i=0; i < actors.length; ++i) {
            NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
            codeBuffer.append(helper.generateInitializeCode());
          }
        }
      }
      Director director=fsmActor.getExecutiveDirector();
      if (director instanceof ptolemy.domains.modal.kernel.MultirateFSMDirector) {
      }
      codeBuffer.append(""String_Node_Str"");
    }
    if (!hasDefaultCase) {
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol);
      }
 else {
        codeBuffer.append(_eol);
      }
      codeBuffer.append(""String_Node_Str"" + _eol);
      Director director=fsmActor.getExecutiveDirector();
      if (director instanceof ptolemy.domains.modal.kernel.MultirateFSMDirector) {
      }
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol);
      }
    }
    codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  }
  codeBuffer.append(""String_Node_Str"" + _eol);
  code.append(codeBuffer.toString());
}","/** 
 * Generate code for making transition. It generates code for both choice action and commit action.
 * @param code The string buffer that the generated code is appended to.
 * @param transitionRetriever An instance of a class implementinga method. which returns an iterator of all, preemptive or non-preemptive transitions of the current state.
 * @exception IllegalActionException If thrown while generatingtransition code.
 */
public void generateTransitionCode(StringBuffer code,TransitionRetriever transitionRetriever) throws IllegalActionException {
  StringBuffer codeBuffer=new StringBuffer();
  ptolemy.domains.modal.kernel.FSMActor fsmActor=(ptolemy.domains.modal.kernel.FSMActor)getComponent();
  codeBuffer.append(""String_Node_Str"" + _eol);
  codeBuffer.append(""String_Node_Str"" + _eol);
  for (  State state : (List<State>)fsmActor.entityList()) {
    codeBuffer.append(""String_Node_Str"" + _generateStateConstantLabel(state) + ""String_Node_Str""+ _eol);
    Iterator transitions=transitionRetriever.retrieveTransitions(state);
    List reOrderedTransitions=new LinkedList();
    List defaultTransitions=new LinkedList();
    while (transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      if (generateSimpleName(transition).equals(""String_Node_Str"")) {
        defaultTransitions.add(transition);
      }
 else {
        reOrderedTransitions.add(transition);
      }
    }
    reOrderedTransitions.addAll(defaultTransitions);
    transitions=reOrderedTransitions.iterator();
    int transitionCount=0;
    boolean hasDefaultCase=false;
    while (!hasDefaultCase && transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      String guard=transition.getGuardExpression();
      if (transition.isDefault() || guard.toLowerCase().equals(""String_Node_Str"")) {
        hasDefaultCase=true;
      }
 else {
        if (transitionCount == 0) {
          codeBuffer.append(""String_Node_Str"");
        }
 else {
          codeBuffer.append(""String_Node_Str"");
        }
        transitionCount++;
        PtParser parser=new PtParser();
        int index=guard.indexOf(""String_Node_Str"");
        ASTPtRootNode guardParseTree=parser.generateParseTree(guard);
        ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
        parseTreeCodeGenerator.evaluateParseTree(guardParseTree,_scope);
        int index2=transition.getFullName().indexOf(""String_Node_Str"");
        String tempName=transition.getFullName().substring(1,index2) + guard.substring(0,index - 1);
        tempName=tempName.replace(""String_Node_Str"",""String_Node_Str"");
        codeBuffer.append(tempName + ""String_Node_Str"");
        codeBuffer.append(""String_Node_Str"");
        codeBuffer.append(""String_Node_Str"");
      }
      codeBuffer.append(""String_Node_Str"" + _eol);
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.choiceActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          StringBuffer sendCode=new StringBuffer();
          if (channel >= 0) {
            codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            if (((IOPort)destination).isInput()) {
              NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
              StringBuffer containerReference=new StringBuffer();
              containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
              if (((IOPort)destination).isMultiport()) {
                containerReference.append(""String_Node_Str"" + channel);
              }
              containerReference.append(""String_Node_Str"");
              codeBuffer.append((containerHelper).processCode(containerReference.toString()) + ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol);
            }
          }
 else {
            int width=((IOPort)action.getDestination(destinationName)).getWidth();
            for (int i=0; i < width; i++) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str""+ _eol);
              if (((IOPort)destination).isInput()) {
                NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
                StringBuffer containerReference=new StringBuffer();
                containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
                if (((IOPort)destination).isMultiport()) {
                  containerReference.append(""String_Node_Str"" + i);
                }
                containerReference.append(""String_Node_Str"");
                codeBuffer.append((containerHelper).processCode(containerReference.toString()) + ""String_Node_Str"");
                sendCode.append(""String_Node_Str"" + generateSimpleName(destination) + ""String_Node_Str""+ i+ ""String_Node_Str""+ _eol);
              }
            }
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
          codeBuffer.append(sendCode);
        }
      }
      Actor[] actors=transition.getRefinement();
      if (actors != null) {
        for (int i=0; i < actors.length; i++) {
          NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
          codeBuffer.append(helper.generateFireCode());
        }
      }
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.commitActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          if (destination instanceof IOPort) {
            if (channel >= 0) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            }
 else {
              int width=((IOPort)action.getDestination(destinationName)).getWidth();
              for (int i=0; i < width; i++) {
                codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
              }
            }
          }
 else           if (destination instanceof Variable) {
            codeBuffer.append(getCodeGenerator().generateVariableName(destination) + ""String_Node_Str"");
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
        }
      }
      State destinationState=transition.destinationState();
      _updateCurrentState(codeBuffer,destinationState);
      BooleanToken resetToken=(BooleanToken)transition.reset.getToken();
      if (resetToken.booleanValue()) {
        actors=destinationState.getRefinement();
        if (actors != null) {
          for (int i=0; i < actors.length; ++i) {
            NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
            codeBuffer.append(helper.generateInitializeCode());
          }
        }
      }
      Director director=fsmActor.getExecutiveDirector();
      if (director instanceof ptolemy.domains.modal.kernel.MultirateFSMDirector) {
      }
      codeBuffer.append(""String_Node_Str"");
    }
    if (!hasDefaultCase) {
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol);
      }
 else {
        codeBuffer.append(_eol);
      }
      codeBuffer.append(""String_Node_Str"" + _eol);
      Director director=fsmActor.getExecutiveDirector();
      if (director instanceof ptolemy.domains.modal.kernel.MultirateFSMDirector) {
      }
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol);
      }
    }
    codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  }
  codeBuffer.append(""String_Node_Str"" + _eol);
  code.append(codeBuffer.toString());
}"
73559,"/** 
 * Generate the code for the firing of actors. In this base class, it is attempted to fire all the actors once. In subclasses such as the adapters for SDF and Giotto directors, the firings of actors observe the associated schedule. In addition, some special handling is needed, e.g., the iteration limit in SDF and time advancement in Giotto.
 * @return The generated code.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating fire code for the actor.
 */
public String generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(getCodeGenerator().comment(""String_Node_Str""));
  Iterator<?> actors=((CompositeActor)_director.getContainer()).deepEntityList().iterator();
  actors=((CompositeActor)_director.getContainer()).deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    if (actor.getFullName().contains(""String_Node_Str"")) {
      NamedProgramCodeGeneratorAdapter adapter=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
      code.append(adapter.generateFireCode());
    }
  }
  return code.toString();
}","/** 
 * Generate the code for the firing of actors. In this base class, it is attempted to fire all the actors once. In subclasses such as the adapters for SDF and Giotto directors, the firings of actors observe the associated schedule. In addition, some special handling is needed, e.g., the iteration limit in SDF and time advancement in Giotto.
 * @return The generated code.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating fire code for the actor.
 */
public String generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(getCodeGenerator().comment(""String_Node_Str""));
  Iterator<?> actors=((CompositeActor)_director.getContainer()).deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    if (actor.getFullName().contains(""String_Node_Str"")) {
      NamedProgramCodeGeneratorAdapter adapter=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
      code.append(adapter.generateFireCode());
    }
  }
  return code.toString();
}"
73560,"/** 
 * Create a new Infinite concept, belonging to the given ontology, with an automatically generated name.
 * @param ontology The finite ontology to which this belongs.
 * @throws NameDuplicationException Should never be thrown.
 * @throws IllegalActionException If the base class throws it.
 */
protected InfiniteConcept(Ontology ontology) throws IllegalActionException, NameDuplicationException {
  super(ontology,""String_Node_Str"" + ++_conceptNumber);
  setName(getName() + ""String_Node_Str"" + getClass().getSimpleName()+ ""String_Node_Str"");
}","/** 
 * Create a new Infinite concept, belonging to the given ontology, with an automatically generated name.
 * @param ontology The finite ontology to which this belongs.
 * @throws NameDuplicationException Should never be thrown.
 * @throws IllegalActionException If the base class throws it.
 */
protected InfiniteConcept(Ontology ontology) throws IllegalActionException, NameDuplicationException {
  super(ontology,""String_Node_Str"" + ++_conceptNumber);
  setName(getName() + ""String_Node_Str"" + getClass().getSimpleName()+ ""String_Node_Str"");
  _ontology=ontology;
}"
73561,"private void _init() throws IllegalActionException, NameDuplicationException {
  GiottoScheduler scheduler=new GiottoScheduler(workspace());
  setScheduler(scheduler);
  period=new Parameter(this,""String_Node_Str"");
  period.setToken(new DoubleToken(_DEFAULT_GIOTTO_PERIOD));
  iterations=new Parameter(this,""String_Node_Str"",new IntToken(0));
  synchronizeToRealTime=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  timeResolution.setVisibility(Settable.FULL);
}","private void _init() throws NameDuplicationException, IllegalActionException {
  GiottoScheduler scheduler=new GiottoScheduler(workspace());
  setScheduler(scheduler);
  period=new Parameter(this,""String_Node_Str"");
  period.setToken(new DoubleToken(_DEFAULT_GIOTTO_PERIOD));
  iterations=new Parameter(this,""String_Node_Str"",new IntToken(0));
  synchronizeToRealTime=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  timeResolution.setVisibility(Settable.FULL);
}"
73562,"/** 
 * Construct an instance with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public GiottoTimingManager(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  SingletonParameter hideName=new SingletonParameter(this,""String_Node_Str"");
  hideName.setToken(BooleanToken.TRUE);
  hideName.setVisibility(Settable.EXPERT);
  seed=new SharedParameter(this,""String_Node_Str"",GiottoTimingManager.class,""String_Node_Str"");
  seed.setTypeEquals(BaseType.LONG);
  resetOnEachRun=new SharedParameter(this,""String_Node_Str"",GiottoTimingManager.class,""String_Node_Str"");
  resetOnEachRun.setTypeEquals(BaseType.BOOLEAN);
}","/** 
 * Construct an instance with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public GiottoTimingManager(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  SingletonParameter hideName=new SingletonParameter(this,""String_Node_Str"");
  hideName.setToken(BooleanToken.TRUE);
  hideName.setVisibility(Settable.EXPERT);
  seed=new SharedParameter(this,""String_Node_Str"",GiottoTimingManager.class,""String_Node_Str"");
  seed.setTypeEquals(BaseType.LONG);
  resetOnEachRun=new SharedParameter(this,""String_Node_Str"",GiottoTimingManager.class,""String_Node_Str"");
  resetOnEachRun.setTypeEquals(BaseType.BOOLEAN);
  probabilityDistribution=new StringParameter(this,""String_Node_Str"");
  probabilityDistribution.setExpression(""String_Node_Str"");
  probabilityDistribution.addChoice(""String_Node_Str"");
}"
73563,"/** 
 * If the attribute is <i>seed</i> then create the base random number generator.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == seed) {
    long seedValue=((LongToken)(seed.getToken())).longValue();
    if (seedValue != _generatorSeed) {
      _needNewGenerator=true;
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If the attribute is <i>seed</i> then create the base random number generator.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == seed) {
    long seedValue=((LongToken)(seed.getToken())).longValue();
    if (seedValue != _generatorSeed) {
      _needNewGenerator=true;
    }
  }
  if (attribute == probabilityDistribution) {
  }
 else {
    super.attributeChanged(attribute);
  }
}"
73564,"protected void _generateRandomNumber() throws IllegalActionException {
}","/** 
 * Generate the next random number.
 */
protected void _generateRandomNumber() throws IllegalActionException {
  _current=_random.nextDouble();
}"
73565,"public State(ptolemy.domains.modal.kernel.State component){
  super(component);
}","/** 
 * Construct the code generator adapter associated with the given state.
 * @param componentThe associatedptolemy.domains.modal.kernel.State
 */
public State(ptolemy.domains.modal.kernel.State component){
  super(component);
}"
73566,"public FSMDirector(ptolemy.domains.modal.kernel.FSMDirector director){
  super(director);
}","/** 
 * Construct the code generator adapter associated with the given FSMDirector.
 * @param director The associated ptolemy.domains.modal.kernel.FSMDirector
 */
public FSMDirector(ptolemy.domains.modal.kernel.FSMDirector director){
  super(director);
}"
73567,"/** 
 * Construct the code generator helper associated with the given FSMActor.
 * @param component The associated component.
 */
public FSMActor(ptolemy.domains.modal.kernel.FSMActor component) throws NameDuplicationException, IllegalActionException {
  super(component);
}","/** 
 * Construct the code generator helper associated with the given FSMActor.
 * @param component The associated component.
 * @exception NameDuplicationException If the container already contains a a code generator adapter for this particular FSMActor.
 * @exception IllegalActionException If the NamedProgramCodeGeneratorAdapter throws an IllegalActionException.
 */
public FSMActor(ptolemy.domains.modal.kernel.FSMActor component) throws NameDuplicationException, IllegalActionException {
  super(component);
}"
73568,"/** 
 * Construct the code generator adapter associated with the given state.
 * @param componentThe associatedptolemy.domains.modal.kernel.State
 */
public State(ptolemy.domains.modal.kernel.State component){
  super(component);
}","/** 
 * Construct the code generator adapter associated with the given state.
 * @param component The associatedptolemy.domains.modal.kernel.State
 */
public State(ptolemy.domains.modal.kernel.State component){
  super(component);
}"
73569,"/** 
 * Advance the current model tag to that of the earliest event in the event queue, and fire all actors that have requested or are triggered to be fired at the current tag. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the timestamp of the event. Note that the default unit for time is seconds. <p> Each actor is fired repeatedly (prefire(), fire()), until either it has no more input tokens, or its prefire() method returns false. Note that if the actor fails to consume its inputs, then this can result in an infinite loop. Each actor that is fired is then postfired once at the conclusion of the iteration. </p><p> If there are no events in the event queue, then the behavior depends on the <i>stopWhenQueueIsEmpty</i> parameter. If it is false, then this thread will stall until events become available in the event queue. Otherwise, time will advance to the stop time and the execution will halt.</p>
 * @exception IllegalActionException If the firing actor throws it, orevent queue is not ready, or an event is missed, or time is set backwards.
 */
public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + getModelTime() + ""String_Node_Str""+ _microstep);
  }
  while (true) {
    int result=_fire();
    assert(result <= 1 && result >= -1);
    if (result == 1) {
      continue;
    }
 else     if (result == -1) {
      return;
    }
    _actorFired();
    if (!_checkForNextEvent()) {
      break;
    }
  }
  _stopFireRequested=false;
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}","/** 
 * Advance the current model tag to that of the earliest event in the event queue, and fire all actors that have requested or are triggered to be fired at the current tag. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the timestamp of the event. Note that the default unit for time is seconds. <p> Each actor is fired repeatedly (prefire(), fire()), until either it has no more input tokens, or its prefire() method returns false. Note that if the actor fails to consume its inputs, then this can result in an infinite loop. Each actor that is fired is then postfired once at the conclusion of the iteration. </p><p> If there are no events in the event queue, then the behavior depends on the <i>stopWhenQueueIsEmpty</i> parameter. If it is false, then this thread will stall until events become available in the event queue. Otherwise, time will advance to the stop time and the execution will halt.</p>
 * @exception IllegalActionException If the firing actor throws it, orevent queue is not ready, or an event is missed, or time is set backwards.
 */
public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + getModelTime() + ""String_Node_Str""+ _microstep);
  }
  while (true) {
    int result=_fire();
    assert(result <= 1 && result >= -1);
    if (result == 1) {
      continue;
    }
 else     if (result == -1) {
      _getNextActuationEvent();
      return;
    }
    _actorFired();
    if (!_checkForNextEvent()) {
      break;
    }
  }
  _stopFireRequested=false;
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}"
73570,"/** 
 * Among all events in the event queue, find the first event that is destined to an output port of the containing composite actor. This event is taken from the event queue, and the token is sent to the actuator/network output port.
 * @return the containing composite actor.
 */
protected void _actorFired(){
  int eventIndex=0;
synchronized (_eventQueue) {
    while (eventIndex < _eventQueue.size()) {
      PtidesEvent nextEvent=((PtidesListEventQueue)_eventQueue).get(eventIndex);
      if (nextEvent.ioPort() != null && nextEvent.ioPort().isOutput()) {
        ((PtidesListEventQueue)_eventQueue).take(eventIndex);
        continue;
      }
      eventIndex++;
    }
  }
  if (_lastActorFired != null) {
    _pureEventDeadlines.remove(_lastActorFired);
    _pureEventDelays.remove(_lastActorFired);
    _pureEventSourcePorts.remove(_lastActorFired);
  }
}","/** 
 * An actor has just been fired. An actuation event could have been produced, so we transfer that event to the outside. Also, we clear  bookkeeping structures that keeps track of what actor has just fired.
 */
protected void _actorFired(){
  _getNextActuationEvent();
  if (_lastActorFired != null) {
    _pureEventDeadlines.remove(_lastActorFired);
    _pureEventDelays.remove(_lastActorFired);
    _pureEventSourcePorts.remove(_lastActorFired);
  }
}"
73571,"/** 
 * Check whether the given attribute equals to this attribute.
 * @param attribute The given attribute to be checked. 
 * @return true - if the given attribute equals to this attribute.<br>false - if the given attribute does not equal to this attribute.
 */
@Override public boolean equals(Object attribute){
  PTDBGenericAttribute genericAttribute=(PTDBGenericAttribute)attribute;
  if (_className != null && _attributeName != null && _values != null) {
    return _className.equals(genericAttribute.getClassName()) && _attributeName.equals(genericAttribute.getAttributeName()) && _values.equals(genericAttribute.getValues());
  }
  if (_className == null && _attributeName == null) {
    return genericAttribute.getClassName() == null && genericAttribute.getAttributeName() == null && _values.equals(genericAttribute.getValues());
  }
  if (_attributeName == null && _values == null) {
    return genericAttribute.getAttributeName() == null && genericAttribute.getValues() == null && _className.equals(genericAttribute.getClassName());
  }
  if (_values == null && _className == null) {
    return genericAttribute.getValues() == null && genericAttribute.getClassName() == null && _attributeName.equals(genericAttribute.getAttributeName());
  }
  if (_className == null) {
    return genericAttribute.getClassName() == null && _attributeName.equals(genericAttribute.getAttributeName()) && _values.equals(genericAttribute.getValues());
  }
  if (_attributeName == null) {
    return genericAttribute.getAttributeName() == null && _className.equals(genericAttribute.getClassName()) && _values.equals(genericAttribute.getValues());
  }
  if (_values == null) {
    return genericAttribute.getValues() == null && _className.equals(genericAttribute.getClassName()) && _attributeName.equals(genericAttribute.getAttributeName());
  }
  return false;
}","/** 
 * Check whether the given attribute equals to this attribute.
 * @param attribute The given attribute to be checked. 
 * @return true - if the given attribute equals to this attribute.<br>false - if the given attribute does not equal to this attribute.
 */
@Override public boolean equals(Object attribute){
  if (!(attribute instanceof PTDBGenericAttribute)) {
    return false;
  }
  PTDBGenericAttribute genericAttribute=(PTDBGenericAttribute)attribute;
  if (_className != null && _attributeName != null && _values != null) {
    return _className.equals(genericAttribute.getClassName()) && _attributeName.equals(genericAttribute.getAttributeName()) && _values.equals(genericAttribute.getValues());
  }
  if (_className == null && _attributeName == null) {
    return genericAttribute.getClassName() == null && genericAttribute.getAttributeName() == null && _values.equals(genericAttribute.getValues());
  }
  if (_attributeName == null && _values == null) {
    return genericAttribute.getAttributeName() == null && genericAttribute.getValues() == null && _className.equals(genericAttribute.getClassName());
  }
  if (_values == null && _className == null) {
    return genericAttribute.getValues() == null && genericAttribute.getClassName() == null && _attributeName.equals(genericAttribute.getAttributeName());
  }
  if (_className == null) {
    return genericAttribute.getClassName() == null && _attributeName.equals(genericAttribute.getAttributeName()) && _values.equals(genericAttribute.getValues());
  }
  if (_attributeName == null) {
    return genericAttribute.getAttributeName() == null && _className.equals(genericAttribute.getClassName()) && _values.equals(genericAttribute.getValues());
  }
  if (_values == null) {
    return genericAttribute.getValues() == null && _className.equals(genericAttribute.getClassName()) && _attributeName.equals(genericAttribute.getAttributeName());
  }
  return false;
}"
73572,"@Test public void testExecuteUpdateParentsToNewVersion() throws Exception {
  OracleXMLDBConnection conn=(OracleXMLDBConnection)DBConnectorFactory.getSyncConnection(true);
  UpdateParentsToNewVersionTask task=new UpdateParentsToNewVersionTask();
  try {
    conn.executeUpdateParentsToNewVersion(task);
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  XMLDBModel oldModel=new XMLDBModel(""String_Node_Str"");
  XMLDBModel newModel=new XMLDBModel(""String_Node_Str"");
  task.setNewModel(newModel);
  try {
    conn.executeUpdateParentsToNewVersion(task);
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  task.setOldModel(oldModel);
  try {
    conn.executeUpdateParentsToNewVersion(task);
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  ArrayList<String> parentsList=new ArrayList<String>();
  parentsList.add(""String_Node_Str"");
  task.setParentsList(parentsList);
  try {
    conn.executeUpdateParentsToNewVersion(task);
    GetReferenceStringTask task1=new GetReferenceStringTask(""String_Node_Str"");
    String referenceString=conn.executeGetReferenceStringTask(task1);
    assertTrue(""String_Node_Str"",referenceString.indexOf(""String_Node_Str"") != -1);
    assertTrue(""String_Node_Str"",referenceString.indexOf(""String_Node_Str"") == -1);
    oldModel=new XMLDBModel(""String_Node_Str"",""String_Node_Str"");
    newModel=new XMLDBModel(""String_Node_Str"",""String_Node_Str"");
    task=new UpdateParentsToNewVersionTask();
    task.setNewModel(newModel);
    task.setOldModel(oldModel);
    parentsList=new ArrayList<String>();
    parentsList.add(""String_Node_Str"");
    task.setParentsList(parentsList);
    conn.executeUpdateParentsToNewVersion(task);
    task1=new GetReferenceStringTask(""String_Node_Str"");
    referenceString=conn.executeGetReferenceStringTask(task1);
    assertTrue(""String_Node_Str"",referenceString.indexOf(""String_Node_Str"") != -1);
    assertTrue(""String_Node_Str"",referenceString.indexOf(""String_Node_Str"") == -1);
    newModel=new XMLDBModel(""String_Node_Str"",""String_Node_Str"");
    task.setNewModel(newModel);
    try {
      conn.executeUpdateParentsToNewVersion(task);
      fail(""String_Node_Str"");
    }
 catch (    Exception e) {
    }
  }
 catch (  DBExecutionException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (conn != null) {
      conn.abortConnection();
      conn.closeConnection();
    }
  }
}","@Test public void testExecuteUpdateParentsToNewVersion() throws Exception {
  OracleXMLDBConnection conn=(OracleXMLDBConnection)DBConnectorFactory.getSyncConnection(true);
  UpdateParentsToNewVersionTask task=new UpdateParentsToNewVersionTask();
  try {
    conn.executeUpdateParentsToNewVersion(task);
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  XMLDBModel oldModel=new XMLDBModel(""String_Node_Str"");
  XMLDBModel newModel=new XMLDBModel(""String_Node_Str"");
  task.setNewModel(newModel);
  try {
    conn.executeUpdateParentsToNewVersion(task);
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  task.setOldModel(oldModel);
  try {
    conn.executeUpdateParentsToNewVersion(task);
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  ArrayList<String> parentsList=new ArrayList<String>();
  parentsList.add(""String_Node_Str"");
  task.setParentsList(parentsList);
  try {
    conn.executeUpdateParentsToNewVersion(task);
    GetReferenceStringTask task1=new GetReferenceStringTask(""String_Node_Str"");
    String referenceString=conn.executeGetReferenceStringTask(task1);
    assertTrue(""String_Node_Str"",referenceString.indexOf(""String_Node_Str"") != -1);
    assertTrue(""String_Node_Str"",referenceString.indexOf(""String_Node_Str"") == -1);
    oldModel=new XMLDBModel(""String_Node_Str"");
    newModel=new XMLDBModel(""String_Node_Str"");
    task=new UpdateParentsToNewVersionTask();
    task.setNewModel(newModel);
    task.setOldModel(oldModel);
    parentsList=new ArrayList<String>();
    parentsList.add(""String_Node_Str"");
    task.setParentsList(parentsList);
    conn.executeUpdateParentsToNewVersion(task);
    task1=new GetReferenceStringTask(""String_Node_Str"");
    referenceString=conn.executeGetReferenceStringTask(task1);
    assertTrue(""String_Node_Str"",referenceString.indexOf(""String_Node_Str"") != -1);
    assertTrue(""String_Node_Str"",referenceString.indexOf(""String_Node_Str"") == -1);
    newModel=new XMLDBModel(""String_Node_Str"",""String_Node_Str"");
    task.setNewModel(newModel);
    try {
      conn.executeUpdateParentsToNewVersion(task);
      fail(""String_Node_Str"");
    }
 catch (    Exception e) {
    }
  }
 catch (  DBExecutionException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (conn != null) {
      conn.abortConnection();
      conn.closeConnection();
    }
  }
}"
73573,"/** 
 * Return the hash code for the event object.
 * @return The hash code for the event object.
 * @see #equals(Object)
 */
public int hashCode(){
  return super.hashCode();
}","/** 
 * Return the hash code for the event object.
 * @return The hash code for the event object.
 * @see #equals(Object)
 */
public int hashCode(){
  int primitiveFieldHash=super.hashCode() >>> _channel;
  int objectFieldHash=(isPureEvent() ? _absoluteDeadline.hashCode() : (_token.hashCode()) >>> _receiver.hashCode());
  return primitiveFieldHash >>> objectFieldHash;
}"
73574,"/** 
 * Indicate whether some other object is equal to this PtidesEvent. PtidesEvents are equal if the super class indicates they are equal and their tokens, receiver, channel, absoluteDeadline, as well as indication whether they are pure events are all equal.
 * @param object The object with which to compare.
 * @return true if the object is a DEEvent and the fields ofthe object and of this object are equal.
 * @see #hashCode()
 */
public boolean equals(Object object){
  if (!(object instanceof PtidesEvent)) {
    return false;
  }
  PtidesEvent event=(PtidesEvent)object;
  return (super.equals(object) && event.token().equals(_token) && event.isPureEvent() == _isPureEvent && event.receiver() == _receiver && event.channel() == _channel && ((event.isPureEvent() && event.absoluteDeadline().equals(_absoluteDeadline)) || !event.isPureEvent()));
}","/** 
 * Indicate whether some other object is equal to this PtidesEvent. PtidesEvents are equal if the super class indicates they are equal and their tokens, receiver, channel, absoluteDeadline, as well as indication whether they are pure events are all equal.
 * @param object The object with which to compare.
 * @return true if the object is a DEEvent and the fields ofthe object and of this object are equal.
 * @see #hashCode()
 */
public boolean equals(Object object){
  if (!(object instanceof PtidesEvent)) {
    return false;
  }
  PtidesEvent event=(PtidesEvent)object;
  return (super.equals(object) && ((!event.isPureEvent() && event.token().equals(_token)) || event.isPureEvent()) && event.isPureEvent() == _isPureEvent && event.receiver() == _receiver && event.channel() == _channel && ((event.isPureEvent() && event.absoluteDeadline().equals(_absoluteDeadline)) || !event.isPureEvent()));
}"
73575,"/** 
 * Return the output of the concept function based on the concept inputs.
 * @param argValues The list of concept inputs to the function.
 * @return The concept output result of the function.
 * @exception IllegalActionException If there is an error withthe input argument array or evaluating the function.
 */
public Concept evaluateFunction(List<Concept> argValues) throws IllegalActionException {
  if (argValues == null) {
    throw new IllegalActionException(""String_Node_Str"" + this + ""String_Node_Str"");
  }
 else   if (_numArgsIsFixed) {
    if (argValues.size() != getNumberOfArguments()) {
      throw new IllegalActionException(""String_Node_Str"" + this + ""String_Node_Str""+ ""String_Node_Str""+ getNumberOfArguments()+ ""String_Node_Str""+ argValues.size());
    }
 else {
      int index=0;
      for (      Concept argument : argValues) {
        if (argument != null && !_argumentDomainOntologies.get(index).entityList(FiniteConcept.class).contains(argument)) {
          throw new IllegalActionException(""String_Node_Str"" + argument + ""String_Node_Str""+ index+ ""String_Node_Str""+ this+ ""String_Node_Str""+ _argumentDomainOntologies.get(index)+ ""String_Node_Str"");
        }
        index++;
      }
    }
  }
  Concept outputValue=_evaluateFunction(argValues);
  if (outputValue != null && _outputRangeOntology.equals(outputValue.getOntology())) {
    throw new IllegalActionException(""String_Node_Str"" + this + ""String_Node_Str""+ outputValue+ ""String_Node_Str""+ _outputRangeOntology+ ""String_Node_Str"");
  }
 else {
    return outputValue;
  }
}","/** 
 * Return the output of the concept function based on the concept inputs.
 * @param argValues The list of concept inputs to the function.
 * @return The concept output result of the function.
 * @exception IllegalActionException If there is an error withthe input argument array or evaluating the function.
 */
public Concept evaluateFunction(List<Concept> argValues) throws IllegalActionException {
  if (argValues == null) {
    throw new IllegalActionException(""String_Node_Str"" + this + ""String_Node_Str"");
  }
 else   if (_numArgsIsFixed) {
    if (argValues.size() != getNumberOfArguments()) {
      throw new IllegalActionException(""String_Node_Str"" + this + ""String_Node_Str""+ ""String_Node_Str""+ getNumberOfArguments()+ ""String_Node_Str""+ argValues.size());
    }
 else {
      int index=0;
      for (      Concept argument : argValues) {
        if (argument != null && !_argumentDomainOntologies.get(index).entityList(FiniteConcept.class).contains(argument)) {
          throw new IllegalActionException(""String_Node_Str"" + argument + ""String_Node_Str""+ index+ ""String_Node_Str""+ this+ ""String_Node_Str""+ _argumentDomainOntologies.get(index)+ ""String_Node_Str"");
        }
        index++;
      }
    }
  }
  Concept outputValue=_evaluateFunction(argValues);
  if (outputValue != null && !_outputRangeOntology.equals(outputValue.getOntology())) {
    throw new IllegalActionException(""String_Node_Str"" + this + ""String_Node_Str""+ outputValue+ ""String_Node_Str""+ _outputRangeOntology+ ""String_Node_Str"");
  }
 else {
    return outputValue;
  }
}"
73576,"/** 
 * Construct a trigger event with the specified destination IO port, timestamp, microstep, and depth. This constructor should be used if the event is a trigger event (a non-pure event that is destined to a port). To construct trigger event, neither _token nor _receiver should be null.
 * @param ioPort The destination IO port.
 * @param channel The channel the event is destined to.
 * @param timeStamp The time when the event occurs.
 * @param microstep The phase of execution within a fixed time.
 * @param depth The topological depth of the destination IO Port.
 * @param token The token associated with the event.
 * @param receiver The Receiver the event is destined to.
 * @exception IllegalActionException If the actor has a priority parameter,but its value cannot be obtained, which should be an integer.
 */
public PtidesEvent(IOPort ioPort,int channel,Time timeStamp,int microstep,int depth,Token token,Receiver receiver) throws IllegalActionException {
  super(ioPort,timeStamp,microstep,depth);
  if (token == null || receiver == null) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  _channel=channel;
  _token=token;
  _receiver=receiver;
  _isPureEvent=false;
}","/** 
 * Construct a trigger event with the specified destination IO port, timestamp, microstep, and depth. This constructor should be used if the event is a trigger event (a non-pure event that is destined to a port). To construct trigger event, neither _token nor _receiver should be null.
 * @param ioPort The destination IO port.
 * @param channel The channel the event is destined to.
 * @param timeStamp The time when the event occurs.
 * @param microstep The phase of execution within a fixed time.
 * @param depth The topological depth of the destination IO Port.
 * @param token The token associated with the event. This field shouldnot be null.
 * @param receiver The Receiver the event is destined to. This field should not be null.
 * @exception IllegalActionException If the actor has a priority parameter,but its value cannot be obtained, which should be an integer.
 */
public PtidesEvent(IOPort ioPort,int channel,Time timeStamp,int microstep,int depth,Token token,Receiver receiver) throws IllegalActionException {
  super(ioPort,timeStamp,microstep,depth);
  assert(token != null && receiver != null);
  _channel=channel;
  _token=token;
  _receiver=receiver;
  _isPureEvent=false;
}"
73577,"/** 
 * Return the receiver this event is destined to.
 * @return The receiver.
 */
public final Receiver receiver(){
  if (!isPureEvent() && (_receiver == null)) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return _receiver;
}","/** 
 * Return the destination receiver for this event.
 * @return The destination receiver for this event.
 */
public final Receiver receiver(){
  if (!isPureEvent()) {
    assert(_receiver != null);
  }
  return _receiver;
}"
73578,"/** 
 * Indicate whether some other object is equal to this PtidesEvent. PtidesEvents are equal if the super class indicates they are equal and the event types (pure vs. non-pure) are the same, and their receivers are the same object, and the channels, tokens,  and absoluteDeadlines values are the same.
 * @param object The object with which to compare.
 * @return true if the object is a DEEvent and the fields ofthe object and of this object are equal.
 * @see #hashCode()
 */
public boolean equals(Object object){
  if (!(object instanceof PtidesEvent)) {
    return false;
  }
  PtidesEvent event=(PtidesEvent)object;
  return (super.equals(object) && ((!event.isPureEvent() && event.token().equals(_token)) || event.isPureEvent()) && event.isPureEvent() == _isPureEvent && event.receiver() == _receiver && event.channel() == _channel && ((event.isPureEvent() && event.absoluteDeadline().equals(_absoluteDeadline)) || !event.isPureEvent()));
}","/** 
 * Indicate whether some other object is equal to this PtidesEvent. PtidesEvents are equal if the super class indicates they are equal and the event types (pure vs. non-pure) are the same, and their receivers are the same object, and the channels, tokens,  and absoluteDeadline values are the same.
 * @param object The object with which to compare.
 * @return true if the object is a DEEvent and the fields ofthe object and of this object are equal.
 * @see #hashCode()
 */
public boolean equals(Object object){
  if (!(object instanceof PtidesEvent)) {
    return false;
  }
  PtidesEvent event=(PtidesEvent)object;
  boolean result=super.equals(object);
  if (!event.isPureEvent()) {
    result=result && event.token().equals(_token);
  }
 else {
    result=result && event.absoluteDeadline().equals(_absoluteDeadline);
  }
  return result && event.isPureEvent() == _isPureEvent && event.receiver() == _receiver && event.channel() == _channel;
}"
73579,"/** 
 * Return the channel this event is destined to.
 * @return The channel.
 */
public final int channel(){
  return _channel;
}","/** 
 * Return the destination channel for this event.
 * @return The channel The destination channel for this event.
 */
public final int channel(){
  return _channel;
}"
73580,"/** 
 * Return a description of the event, including the the tag, depth, the token, and destination information.
 * @return The token as a string with the time stamp.
 */
public String toString(){
  String name=""String_Node_Str"";
  if (_actor != null) {
    name=((NamedObj)_actor).getFullName();
  }
  return ""String_Node_Str"" + _timestamp + ""String_Node_Str""+ _microstep+ ""String_Node_Str""+ _depth+ ""String_Node_Str""+ _token+ ""String_Node_Str""+ _absoluteDeadline+ ""String_Node_Str""+ name+ ""String_Node_Str""+ (_ioPort == null ? ""String_Node_Str"" : _ioPort.getName())+ ""String_Node_Str""+ _channel+ ""String_Node_Str""+ (_receiver == null ? ""String_Node_Str"" : getClass().getName() + ""String_Node_Str"" + (_receiver.getContainer() != null ? _receiver.getContainer().getFullName() : ""String_Node_Str"")+ ""String_Node_Str"")+ ""String_Node_Str""+ _isPureEvent+ ""String_Node_Str"";
}","/** 
 * Return a description of the event, including the the tag, depth, the token, absolute deadline, and destination information.
 * @return The token as a string with the time stamp.
 */
public String toString(){
  String name=""String_Node_Str"";
  if (_actor != null) {
    name=((NamedObj)_actor).getFullName();
  }
  return ""String_Node_Str"" + _timestamp + ""String_Node_Str""+ _microstep+ ""String_Node_Str""+ _depth+ ""String_Node_Str""+ _token+ ""String_Node_Str""+ (_absoluteDeadline == null ? ""String_Node_Str"" : _absoluteDeadline.toString())+ ""String_Node_Str""+ name+ ""String_Node_Str""+ (_ioPort == null ? ""String_Node_Str"" : _ioPort.getName())+ ""String_Node_Str""+ _channel+ ""String_Node_Str""+ (_receiver == null ? ""String_Node_Str"" : getClass().getName() + ""String_Node_Str"" + (_receiver.getContainer() != null ? _receiver.getContainer().getFullName() : ""String_Node_Str"")+ ""String_Node_Str"")+ ""String_Node_Str""+ _isPureEvent+ ""String_Node_Str"";
}"
73581,"/** 
 * Return the absolute deadline of this event if the event is a pure event. A pure event is one that does not contained a token (value) that  is destined to an input port.
 * @return absolute deadline if the event is a pure event.
 * @exception InternalErrorException If event is not a pure event,or the event is a pure event and absoluteDeadline is null.
 */
public final Time absoluteDeadline(){
  if (!isPureEvent()) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (isPureEvent() && _absoluteDeadline == null) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return _absoluteDeadline;
}","/** 
 * Return the absolute deadline of this event if the event is a pure event. A pure event is one that does not contained a token (value) that  is destined to an input port.
 * @return absolute deadline if the event is a pure event.
 * @exception InternalErrorException If event is not a pure event,or the event is a pure event and absoluteDeadline is null.
 */
public final Time absoluteDeadline(){
  if (!isPureEvent()) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    assert(_absoluteDeadline == null);
  }
  return _absoluteDeadline;
}"
73582,"/** 
 * Return true if this event is a pure event.
 * @return True if this event is a pure event.
 */
public final boolean isPureEvent(){
  return _isPureEvent;
}","/** 
 * Return true if this event is a pure event. A pure event is one that does not contained a token that is destined to an input port.
 * @return True if this event is a pure event.
 */
public final boolean isPureEvent(){
  return _isPureEvent;
}"
73583,"/** 
 * Indicate whether some other object is equal to this PtidesEvent. PtidesEvents are equal if the super class indicates they are equal and their tokens, receiver, channel, absoluteDeadline, as well as indication whether they are pure events are all equal.
 * @param object The object with which to compare.
 * @return true if the object is a DEEvent and the fields ofthe object and of this object are equal.
 * @see #hashCode()
 */
public boolean equals(Object object){
  if (!(object instanceof PtidesEvent)) {
    return false;
  }
  PtidesEvent event=(PtidesEvent)object;
  return (super.equals(object) && event.token() == _token && event.isPureEvent() == _isPureEvent && event.receiver() == _receiver && event.channel() == _channel && ((event.isPureEvent() && event.absoluteDeadline() == _absoluteDeadline) || !event.isPureEvent()));
}","/** 
 * Indicate whether some other object is equal to this PtidesEvent. PtidesEvents are equal if the super class indicates they are equal and their tokens, receiver, channel, absoluteDeadline, as well as indication whether they are pure events are all equal.
 * @param object The object with which to compare.
 * @return true if the object is a DEEvent and the fields ofthe object and of this object are equal.
 * @see #hashCode()
 */
public boolean equals(Object object){
  if (!(object instanceof PtidesEvent)) {
    return false;
  }
  PtidesEvent event=(PtidesEvent)object;
  return (super.equals(object) && event.token().equals(_token) && event.isPureEvent() == _isPureEvent && event.receiver() == _receiver && event.channel() == _channel && ((event.isPureEvent() && event.absoluteDeadline().equals(_absoluteDeadline)) || !event.isPureEvent()));
}"
73584,"/** 
 * Return a description of the event, including the the tag, depth, the token, and destination information.
 * @return The token as a string with the time stamp.
 */
public String toString(){
  String name=""String_Node_Str"";
  if (_actor != null) {
    name=((NamedObj)_actor).getFullName();
  }
  return ""String_Node_Str"" + _timestamp + ""String_Node_Str""+ _microstep+ ""String_Node_Str""+ _depth+ ""String_Node_Str""+ _token+ ""String_Node_Str""+ _absoluteDeadline+ ""String_Node_Str""+ name+ ""String_Node_Str""+ (_ioPort == null ? ""String_Node_Str"" : _ioPort.getName())+ ""String_Node_Str""+ _channel+ ""String_Node_Str""+ _isPureEvent+ ""String_Node_Str"";
}","/** 
 * Return a description of the event, including the the tag, depth, the token, and destination information.
 * @return The token as a string with the time stamp.
 */
public String toString(){
  String name=""String_Node_Str"";
  if (_actor != null) {
    name=((NamedObj)_actor).getFullName();
  }
  return ""String_Node_Str"" + _timestamp + ""String_Node_Str""+ _microstep+ ""String_Node_Str""+ _depth+ ""String_Node_Str""+ _token+ ""String_Node_Str""+ _absoluteDeadline+ ""String_Node_Str""+ name+ ""String_Node_Str""+ (_ioPort == null ? ""String_Node_Str"" : _ioPort.getName())+ ""String_Node_Str""+ _channel+ ""String_Node_Str""+ _isPureEvent+ (_receiver == null ? ""String_Node_Str"" : getClass().getName() + ""String_Node_Str"" + (_receiver.getContainer() != null ? _receiver.getContainer().getFullName() : ""String_Node_Str"")+ ""String_Node_Str"")+ ""String_Node_Str"";
}"
73585,"/** 
 * Return the absolute deadline of this event.
 * @return absolute deadline if the event is not a pure event.
 */
public final Time absoluteDeadline(){
  if (!isPureEvent()) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  return _absoluteDeadline;
}","/** 
 * Return the absolute deadline of this event. A pure event is one that does not contained a token (value) that  is destined to an input port.
 * @return absolute deadline if the event is not a pure event.
 * @exception InternalErrorException If event is not a pure event.
 */
public final Time absoluteDeadline(){
  if (!isPureEvent()) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  return _absoluteDeadline;
}"
73586,"public void put(DEEvent event) throws IllegalActionException {
  put((PtidesEvent)event);
}","/** 
 * Put the event queue into the event queue, and then sort it by timestamp order. 
 * @param event a DEEvent object.
 * @throws IllegalActionException if the addFirst() method of the queue throws it.
 */
public void put(DEEvent event) throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + event);
  }
  _listQueue.addFirst(event);
  Collections.sort(_listQueue);
}"
73587,"public int compare(Object o1,Object o2){
  double[] location1={Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY};
  double[] location2={Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY};
  List locations=((Entity)o1).attributeList(Locatable.class);
  if (locations.size() > 0) {
    location1=((Locatable)locations.get(0)).getLocation();
  }
  locations=((Entity)o2).attributeList(Locatable.class);
  if (locations.size() > 0) {
    location2=((Locatable)locations.get(0)).getLocation();
  }
  if (location1[0] < location2[0]) {
    return -1;
  }
 else   if (location1[0] > location2[0]) {
    return 1;
  }
 else {
    return 0;
  }
}","public int compare(Object o1,Object o2){
  double[] location1={Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY};
  double[] location2={Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY};
  List locations=((Entity)o1).attributeList(Locatable.class);
  if (locations.size() > 0) {
    location1=((Locatable)locations.get(0)).getLocation();
  }
  locations=((Entity)o2).attributeList(Locatable.class);
  if (locations.size() > 0) {
    location2=((Locatable)locations.get(0)).getLocation();
  }
  if (location1[0] < location2[0]) {
    return -1;
  }
 else   if (location1[0] > location2[0]) {
    return 1;
  }
 else {
    if (o1.equals(o2)) {
      return 0;
    }
    return -1;
  }
}"
73588,"protected Schedule _getSchedule() throws IllegalActionException, NotSchedulableException {
  StaticSchedulingDirector director=(StaticSchedulingDirector)getContainer();
  CompositeActor compositeActor=(CompositeActor)(director.getContainer());
  List actors=compositeActor.deepEntityList();
  Iterator actorIterator=actors.iterator();
  TreeSet sortedActors=new TreeSet(new LeftRightComparator());
  while (actorIterator.hasNext()) {
    Actor actor=(Actor)actorIterator.next();
    sortedActors.add(actor);
  }
  Schedule schedule=new Schedule();
  Iterator sortedActorsIterator=sortedActors.iterator();
  while (sortedActorsIterator.hasNext()) {
    Actor actor=(Actor)sortedActorsIterator.next();
    Firing firing=new Firing();
    firing.setActor(actor);
    schedule.add(firing);
  }
  return schedule;
}","/** 
 * Return a left-to-right schedule. 
 */
protected Schedule _getSchedule() throws IllegalActionException, NotSchedulableException {
  NamedObj director=getContainer();
  CompositeActor compositeActor=(CompositeActor)(director.getContainer());
  List<Actor> actors=compositeActor.deepEntityList();
  TreeSet<Actor> sortedActors=new TreeSet(new LeftRightComparator());
  sortedActors.addAll(actors);
  Schedule schedule=new Schedule();
  for (  Actor actor : sortedActors) {
    Firing firing=new Firing(actor);
    schedule.add(firing);
  }
  return schedule;
}"
73589,"public LeftRightDirector(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  setScheduler(new LeftRightScheduler(this,""String_Node_Str""));
}","/** 
 * Constructor. A director is an Attribute.
 * @param container The container for the director.
 * @param name The name of the director.
 * @throws IllegalActionException If the container cannot contain this director.
 * @throws NameDuplicationException If the container already contains anAttribute with this name.
 */
public LeftRightDirector(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  setScheduler(new LeftRightScheduler(this,""String_Node_Str""));
}"
73590,"public LeftRightScheduler(LeftRightDirector director,String name) throws IllegalActionException, NameDuplicationException {
  super(director,name);
}","/** 
 * Constructor. A Scheduler is an Attribute, normally contained by a director.
 * @param director The director that will use this scheduler.
 * @param name The name of the scheduler.
 * @throws IllegalActionException If the director cannot use this scheduler.
 * @throws NameDuplicationException If the director already contains anAttribute with this name.
 */
public LeftRightScheduler(LeftRightDirector director,String name) throws IllegalActionException, NameDuplicationException {
  super(director,name);
}"
73591,"/** 
 * Return the receiver.
 * @return The receiver.
 */
public final boolean isPureEvent(){
  return _isPureEvent;
}","/** 
 * Return true if this event is a pure event.
 * @return True if this event is a pure event.
 */
public final boolean isPureEvent(){
  return _isPureEvent;
}"
73592,"/** 
 * Indicate whether some the super class returns they are equal and their tokens are equal.
 * @param object The object with which to compare.
 * @return true if the object is a DEEvent and the fields ofthe object and of this object are equal.
 * @see #hashCode()
 */
public boolean equals(Object object){
  boolean result=super.equals(object);
  if (result == true && ((PtidesEvent)object).token() == _token) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Indicate whether some the super class returns they are equal and their tokens are equal.
 * @param object The object with which to compare.
 * @return true if the object is a DEEvent and the fields ofthe object and of this object are equal.
 * @see #hashCode()
 */
public boolean equals(Object object){
  if (!(object instanceof PtidesEvent)) {
    return false;
  }
  boolean result=super.equals(object);
  if (result == true && ((PtidesEvent)object).token() == _token) {
    return true;
  }
 else {
    return false;
  }
}"
73593,"/** 
 * Return a description of the event, including the the tag, depth, the token, and destination information.
 * @return The token as a string with the time stamp.
 */
public String toString(){
  String name=""String_Node_Str"";
  if (_actor != null) {
    name=((NamedObj)_actor).getFullName();
  }
  if (!_isPureEvent) {
    return ""String_Node_Str"" + _timestamp + ""String_Node_Str""+ _microstep+ ""String_Node_Str""+ _depth+ ""String_Node_Str""+ _token+ ""String_Node_Str""+ name+ ""String_Node_Str""+ _ioPort.getName()+ ""String_Node_Str""+ _channel+ ""String_Node_Str"";
  }
 else {
    return ""String_Node_Str"" + _timestamp + ""String_Node_Str""+ _microstep+ ""String_Node_Str""+ _depth+ ""String_Node_Str""+ _token+ ""String_Node_Str""+ name+ ""String_Node_Str""+ _isPureEvent+ ""String_Node_Str""+ ""String_Node_Str"";
  }
}","/** 
 * Return a description of the event, including the the tag, depth, the token, and destination information.
 * @return The token as a string with the time stamp.
 */
public String toString(){
  String name=""String_Node_Str"";
  if (_actor != null) {
    name=((NamedObj)_actor).getFullName();
  }
  if (!_isPureEvent) {
    return ""String_Node_Str"" + _timestamp + ""String_Node_Str""+ _microstep+ ""String_Node_Str""+ _depth+ ""String_Node_Str""+ _token+ ""String_Node_Str""+ _absoluteDeadline+ ""String_Node_Str""+ name+ ""String_Node_Str""+ (_ioPort == null ? ""String_Node_Str"" : _ioPort.getName())+ ""String_Node_Str""+ _channel+ ""String_Node_Str"";
  }
 else {
    return ""String_Node_Str"" + _timestamp + ""String_Node_Str""+ _microstep+ ""String_Node_Str""+ _depth+ ""String_Node_Str""+ ""String_Node_Str""+ _token+ ""String_Node_Str""+ _absoluteDeadline+ ""String_Node_Str""+ name+ ""String_Node_Str""+ _isPureEvent+ ""String_Node_Str""+ ""String_Node_Str"";
  }
}"
73594,"/** 
 * Construct the AttributeSearcher according to the input search criteria.
 * @param searchCriteria The search criteria that input by the user.
 */
public AttributeSearcher(SearchCriteria searchCriteria){
  if (searchCriteria.getAttributes() != null && searchCriteria.getAttributes().size() > 0) {
    HashMap<String,PTDBGenericAttribute> attributesMap=new HashMap<String,PTDBGenericAttribute>();
    for (    Attribute originalAttribute : searchCriteria.getAttributes()) {
      if (!attributesMap.containsKey(originalAttribute.getName())) {
        PTDBGenericAttribute newAttribute=new PTDBGenericAttribute(originalAttribute.getName());
        newAttribute.addValue(((Variable)originalAttribute).getExpression());
        if (originalAttribute instanceof PTDBSearchAttribute) {
          if (!((PTDBSearchAttribute)originalAttribute).isGenericAttribute()) {
            newAttribute.setClassName(originalAttribute.getClassName());
          }
 else {
            newAttribute.setClassName(((PTDBSearchAttribute)originalAttribute).getGenericClassName());
          }
        }
 else {
          newAttribute.setClassName(originalAttribute.getClassName());
        }
        attributesMap.put(newAttribute.getAttributeName(),newAttribute);
      }
 else {
        PTDBGenericAttribute attribute=attributesMap.get(originalAttribute.getName());
        attribute.addValue(((Variable)originalAttribute).getValueAsString());
      }
    }
    ArrayList<PTDBGenericAttribute> attributeList=new ArrayList<PTDBGenericAttribute>(attributesMap.values());
    _attributesCriteria=attributeList;
  }
}","/** 
 * Construct the AttributeSearcher according to the input search criteria.
 * @param searchCriteria The search criteria that input by the user.
 */
public AttributeSearcher(SearchCriteria searchCriteria){
  if (searchCriteria.getAttributes() != null && searchCriteria.getAttributes().size() > 0) {
    HashMap<String,PTDBGenericAttribute> attributesMap=new HashMap<String,PTDBGenericAttribute>();
    for (    Attribute originalAttribute : searchCriteria.getAttributes()) {
      if (!attributesMap.containsKey(originalAttribute.getName())) {
        PTDBGenericAttribute newAttribute=new PTDBGenericAttribute(originalAttribute.getName());
        newAttribute.addValue(((Variable)originalAttribute).getExpression());
        if (originalAttribute instanceof PTDBSearchAttribute) {
          if (!((PTDBSearchAttribute)originalAttribute).isGenericAttribute()) {
            newAttribute.setClassName(originalAttribute.getClassName());
          }
 else {
            newAttribute.setClassName(((PTDBSearchAttribute)originalAttribute).getGenericClassName());
          }
        }
 else {
          newAttribute.setClassName(originalAttribute.getClassName());
        }
        attributesMap.put(newAttribute.getAttributeName(),newAttribute);
      }
 else {
        PTDBGenericAttribute attribute=attributesMap.get(originalAttribute.getName());
        attribute.addValue(((Variable)originalAttribute).getExpression());
      }
    }
    ArrayList<PTDBGenericAttribute> attributeList=new ArrayList<PTDBGenericAttribute>(attributesMap.values());
    _attributesCriteria=attributeList;
  }
}"
73595,"/** 
 * Create the attribute sub-query for the given attribute.
 * @param attribute PTDBGenericAttribute for which the sub-query needs to be created.
 * @return Sub-query for the given attribute.
 */
private String _createAttributeClause(PTDBGenericAttribute attribute){
  StringBuffer attributesQuery=new StringBuffer();
  boolean isPreviousClauseSet=false;
  if (attribute.getAttributeName() != null && !""String_Node_Str"".equals(attribute.getAttributeName().trim())) {
    attributesQuery.append(""String_Node_Str"").append(attribute.getAttributeName()).append(""String_Node_Str"");
    isPreviousClauseSet=true;
  }
  ArrayList<String> attributeValues=attribute.getValues();
  if (attributeValues != null && attributeValues.size() > 0) {
    if (isPreviousClauseSet) {
      attributesQuery.append(""String_Node_Str"");
    }
    String valuesClause=""String_Node_Str"";
    for (    String value : attributeValues) {
      if (value != null && value.length() > 0) {
        valuesClause=valuesClause + ""String_Node_Str"" + value+ ""String_Node_Str""+ ""String_Node_Str"";
      }
 else {
        valuesClause=""String_Node_Str"";
        break;
      }
      isPreviousClauseSet=true;
    }
    if (valuesClause != null && valuesClause.length() > 0) {
      valuesClause=valuesClause.substring(0,valuesClause.lastIndexOf(""String_Node_Str""));
      valuesClause=valuesClause.trim();
      if (attributeValues.size() > 1) {
        valuesClause=""String_Node_Str"" + valuesClause + ""String_Node_Str"";
      }
    }
    attributesQuery.append(valuesClause);
  }
  String attributeClass=attribute.getClassName();
  if (attributeClass != null && attributeClass.length() > 0) {
    if (isPreviousClauseSet) {
      attributesQuery.append(""String_Node_Str"");
    }
    attributesQuery.append(""String_Node_Str"").append(attributeClass).append(""String_Node_Str"");
  }
  return attributesQuery.toString();
}","/** 
 * Create the attribute sub-query for the given attribute.
 * @param attribute PTDBGenericAttribute for which the sub-query needs to be created.
 * @return Sub-query for the given attribute.
 */
private String _createAttributeClause(PTDBGenericAttribute attribute){
  StringBuffer attributesQuery=new StringBuffer();
  boolean isPreviousClauseSet=false;
  if (attribute.getAttributeName() != null && !""String_Node_Str"".equals(attribute.getAttributeName().trim())) {
    attributesQuery.append(""String_Node_Str"").append(attribute.getAttributeName()).append(""String_Node_Str"");
    isPreviousClauseSet=true;
  }
  ArrayList<String> attributeValues=attribute.getValues();
  if (attributeValues != null && attributeValues.size() > 0) {
    String valuesClause=""String_Node_Str"";
    for (    String value : attributeValues) {
      if (value != null && value.length() > 0) {
        valuesClause=valuesClause + ""String_Node_Str"" + value+ ""String_Node_Str""+ ""String_Node_Str"";
      }
 else {
        valuesClause=""String_Node_Str"";
        break;
      }
    }
    if (valuesClause != null && valuesClause.length() > 0) {
      valuesClause=valuesClause.substring(0,valuesClause.lastIndexOf(""String_Node_Str""));
      valuesClause=valuesClause.trim();
      if (attributeValues.size() > 1) {
        valuesClause=""String_Node_Str"" + valuesClause + ""String_Node_Str"";
      }
      if (isPreviousClauseSet) {
        attributesQuery.append(""String_Node_Str"");
      }
      attributesQuery.append(valuesClause);
      isPreviousClauseSet=true;
    }
  }
  String attributeClass=attribute.getClassName();
  if (attributeClass != null && attributeClass.length() > 0) {
    if (isPreviousClauseSet) {
      attributesQuery.append(""String_Node_Str"");
    }
    attributesQuery.append(""String_Node_Str"").append(attributeClass).append(""String_Node_Str"");
  }
  return attributesQuery.toString();
}"
73596,"/** 
 * Create new form ModelsListFrame 
 */
public ModelsListFrame(Configuration configuration){
  this.setTitle(""String_Node_Str"");
  _initModelsList();
  initComponents();
  _configuration=configuration;
}","/** 
 * Create new form ModelsListFrame 
 */
public ModelsListFrame(Configuration configuration){
  setTitle(""String_Node_Str"");
  _initModelsList();
  initComponents();
  _configuration=configuration;
}"
73597,"/** 
 * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
 */
@SuppressWarnings(""String_Node_Str"") private void initComponents(){
  jScrollPane1=new javax.swing.JScrollPane();
  _modelsListTable=new javax.swing.JTable();
  jPanel1=new javax.swing.JPanel();
  _totalModelsLabel=new java.awt.Label();
  _noOfModelsLabel=new java.awt.Label();
  _previousPageButton=new java.awt.Button();
  _pageNumberCombo=new javax.swing.JComboBox();
  _nextPageButton=new java.awt.Button();
  _hintLabel=new java.awt.Label();
  _hintLabel.setFont(new java.awt.Font(""String_Node_Str"",1,12));
  _hintLabel.setText(""String_Node_Str"");
  setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
  setResizable(false);
  _setTableData();
  _setPageNumbers();
  jScrollPane1.setViewportView(_modelsListTable);
  _modelsListTable.addMouseListener(new MouseAdapter(){
    public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() == 2) {
        javax.swing.JTable target=(javax.swing.JTable)e.getSource();
        int row=target.getSelectedRow();
        int column=target.getSelectedColumn();
        _loadModel((String)target.getValueAt(row,1));
      }
    }
  }
);
  _totalModelsLabel.setFont(new java.awt.Font(""String_Node_Str"",1,12));
  _totalModelsLabel.setName(""String_Node_Str"");
  _totalModelsLabel.setText(""String_Node_Str"");
  _noOfModelsLabel.setName(""String_Node_Str"");
  _noOfModelsLabel.setText(Integer.toString(_noOfModels));
  _previousPageButton.setLabel(""String_Node_Str"");
  _previousPageButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      _gotToPreviousPage(evt);
    }
  }
);
  _pageNumberCombo.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      _gotoPage(evt);
    }
  }
);
  javax.swing.GroupLayout jPanel1Layout=new javax.swing.GroupLayout(jPanel1);
  jPanel1.setLayout(jPanel1Layout);
  jPanel1Layout.setHorizontalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addComponent(_totalModelsLabel,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_noOfModelsLabel,javax.swing.GroupLayout.PREFERRED_SIZE,50,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,148,Short.MAX_VALUE).addComponent(_previousPageButton,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_pageNumberCombo,javax.swing.GroupLayout.PREFERRED_SIZE,41,javax.swing.GroupLayout.PREFERRED_SIZE)));
  jPanel1Layout.setVerticalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(_totalModelsLabel,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_noOfModelsLabel,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_pageNumberCombo,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_previousPageButton,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE)).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE)));
  _nextPageButton.setLabel(""String_Node_Str"");
  _nextPageButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      _goToNextPage(evt);
    }
  }
);
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(getContentPane());
  getContentPane().setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(_hintLabel,javax.swing.GroupLayout.Alignment.LEADING).addComponent(jScrollPane1,javax.swing.GroupLayout.Alignment.LEADING,javax.swing.GroupLayout.DEFAULT_SIZE,380,Short.MAX_VALUE).addGroup(javax.swing.GroupLayout.Alignment.LEADING,layout.createSequentialGroup().addComponent(jPanel1,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_nextPageButton,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE))).addContainerGap()));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(_hintLabel).addComponent(jScrollPane1,javax.swing.GroupLayout.PREFERRED_SIZE,265,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jPanel1,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_nextPageButton,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE)).addContainerGap()));
  pack();
}","/** 
 * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
 */
@SuppressWarnings(""String_Node_Str"") private void initComponents(){
  jScrollPane1=new javax.swing.JScrollPane();
  _modelsListTable=new javax.swing.JTable();
  jPanel1=new javax.swing.JPanel();
  _totalModelsLabel=new java.awt.Label();
  _numberOfModelsLabel=new java.awt.Label();
  _previousPageButton=new java.awt.Button();
  _pageNumberCombo=new javax.swing.JComboBox();
  _nextPageButton=new java.awt.Button();
  _hintLabel=new java.awt.Label();
  _hintLabel.setFont(new java.awt.Font(""String_Node_Str"",1,12));
  _hintLabel.setText(""String_Node_Str"");
  setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
  setResizable(false);
  _setTableData();
  _setPageNumbers();
  jScrollPane1.setViewportView(_modelsListTable);
  _modelsListTable.addMouseListener(new MouseAdapter(){
    public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() == 2) {
        javax.swing.JTable target=(javax.swing.JTable)e.getSource();
        int row=target.getSelectedRow();
        int column=target.getSelectedColumn();
        _loadModel((String)target.getValueAt(row,1));
      }
    }
  }
);
  _totalModelsLabel.setFont(new java.awt.Font(""String_Node_Str"",1,12));
  _totalModelsLabel.setName(""String_Node_Str"");
  _totalModelsLabel.setText(""String_Node_Str"");
  _numberOfModelsLabel.setName(""String_Node_Str"");
  _numberOfModelsLabel.setText(Integer.toString(_noOfModels));
  _previousPageButton.setLabel(""String_Node_Str"");
  _previousPageButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      _gotToPreviousPage(evt);
    }
  }
);
  _pageNumberCombo.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      _gotoPage(evt);
    }
  }
);
  javax.swing.GroupLayout jPanel1Layout=new javax.swing.GroupLayout(jPanel1);
  jPanel1.setLayout(jPanel1Layout);
  jPanel1Layout.setHorizontalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addComponent(_totalModelsLabel,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_numberOfModelsLabel,javax.swing.GroupLayout.PREFERRED_SIZE,50,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,148,Short.MAX_VALUE).addComponent(_previousPageButton,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_pageNumberCombo,javax.swing.GroupLayout.PREFERRED_SIZE,41,javax.swing.GroupLayout.PREFERRED_SIZE)));
  jPanel1Layout.setVerticalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(_totalModelsLabel,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_numberOfModelsLabel,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_pageNumberCombo,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_previousPageButton,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE)).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE)));
  _nextPageButton.setLabel(""String_Node_Str"");
  _nextPageButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      _goToNextPage(evt);
    }
  }
);
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(getContentPane());
  getContentPane().setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(_hintLabel,javax.swing.GroupLayout.Alignment.LEADING).addComponent(jScrollPane1,javax.swing.GroupLayout.Alignment.LEADING,javax.swing.GroupLayout.DEFAULT_SIZE,380,Short.MAX_VALUE).addGroup(javax.swing.GroupLayout.Alignment.LEADING,layout.createSequentialGroup().addComponent(jPanel1,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_nextPageButton,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE))).addContainerGap()));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(_hintLabel).addComponent(jScrollPane1,javax.swing.GroupLayout.PREFERRED_SIZE,265,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jPanel1,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_nextPageButton,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE)).addContainerGap()));
  pack();
}"
73598,"protected ArrayList<Attribute> getAttributes() throws IllegalActionException {
  ArrayList<Attribute> returnList=super.getAttributes();
  Component[] componentArray1=_attListPanel.getComponents();
  for (int i=0; i < componentArray1.length; i++) {
    if (componentArray1[i] instanceof JPanel) {
      Component[] componentArray2=((JPanel)componentArray1[i]).getComponents();
      for (int j=0; j < componentArray2.length; j++) {
        if (componentArray2[j] instanceof GenericAttributePanel) {
          try {
            PTDBSearchAttribute attribute=new PTDBSearchAttribute();
            attribute.setGenericAttribute(true);
            if ((((GenericAttributePanel)componentArray2[j]).getAttributeClass()).length() > 0) {
              attribute.setGenericClassName((((GenericAttributePanel)componentArray2[j]).getAttributeClass()));
            }
            attribute.setName(((GenericAttributePanel)componentArray2[j]).getAttributeName());
            if ((((GenericAttributePanel)componentArray2[j]).getValue()).length() > 0) {
              attribute.setExpression(((GenericAttributePanel)componentArray2[j]).getValue());
            }
            returnList.add(attribute);
          }
 catch (          NameDuplicationException e) {
          }
        }
      }
    }
  }
  return returnList;
}","protected ArrayList<Attribute> getAttributes() throws IllegalActionException {
  ArrayList<Attribute> returnList=new ArrayList();
  Component[] componentArray1=_attListPanel.getComponents();
  for (int i=0; i < componentArray1.length; i++) {
    if (componentArray1[i] instanceof JPanel) {
      Component[] componentArray2=((JPanel)componentArray1[i]).getComponents();
      for (int j=0; j < componentArray2.length; j++) {
        if (componentArray2[j] instanceof ModelAttributePanel) {
          try {
            StringParameter stringParameter;
            stringParameter=new StringParameter(new NamedObj(),((ModelAttributePanel)componentArray2[j]).getAttributeName());
            stringParameter.setExpression(((ModelAttributePanel)componentArray2[j]).getValue());
            returnList.add(stringParameter);
          }
 catch (          NameDuplicationException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
  for (int i=0; i < componentArray1.length; i++) {
    if (componentArray1[i] instanceof JPanel) {
      Component[] componentArray2=((JPanel)componentArray1[i]).getComponents();
      for (int j=0; j < componentArray2.length; j++) {
        if (componentArray2[j] instanceof GenericAttributePanel) {
          try {
            PTDBSearchAttribute attribute=new PTDBSearchAttribute();
            attribute.setGenericAttribute(true);
            if ((((GenericAttributePanel)componentArray2[j]).getAttributeClass()).length() > 0) {
              attribute.setGenericClassName((((GenericAttributePanel)componentArray2[j]).getAttributeClass()));
            }
            attribute.setName(((GenericAttributePanel)componentArray2[j]).getAttributeName());
            attribute.setExpression(((GenericAttributePanel)componentArray2[j]).getValue());
            returnList.add(attribute);
          }
 catch (          NameDuplicationException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
  return returnList;
}"
73599,"/** 
 * Traverse a composite KNode containing corresponding Kieler nodes, ports and edges for the Ptolemy model and apply all layout information contained by it back to the Ptolemy model. Do most changes to the Ptolemy model via MoMLChangeRequests. Set location attributes for all visible Ptolemy nodes. So far Ptolemy does not support setting of connection bendpoints explicitly. The Ptolemy connection router does not consider obstruction avoidance so there are likely to be connection overlappings in the diagram. <p> Optionally route edges explicitly by inserting new relation vertices for each bend point.
 * @see #setApplyEdgeLayout(boolean)
 * @param kgraph The Kieler graph object containing all layout information to apply to the Ptolemy model
 * @exception IllegalActionException Exception can be thrown if routing of edges fails due to not allowed unlinking or linking of new relations.
 */
private void _applyLayout(KNode kgraph) throws IllegalActionException {
  GraphModel graph=this.getLayoutTarget().getGraphModel();
  if (graph instanceof ActorGraphModel) {
    Collection<KNode> kNodes=kgraph.getChildren();
    if (_doBoxLayout) {
      kNodes=_kieler2ptolemyEntityNodes.keySet();
    }
    for (    KNode knode : kNodes) {
      KShapeLayout absoluteLayout=KielerGraphUtil._getAbsoluteLayout(knode);
      NamedObj namedObj=_kieler2ptolemyEntityNodes.get(knode);
      _kNode2Ptolemy(absoluteLayout,knode);
      if (namedObj instanceof Relation) {
        Vertex vertex=(Vertex)_kieler2ptolemyDivaNodes.get(knode);
        _ptolemyModelUtil._setLocation(vertex,(Relation)namedObj,absoluteLayout.getXpos(),absoluteLayout.getYpos());
      }
 else {
        _ptolemyModelUtil._setLocation(namedObj,absoluteLayout.getXpos(),absoluteLayout.getYpos());
      }
    }
    if (_doApplyEdgeLayout) {
      Set<Relation> relationsToDelete=new HashSet<Relation>();
      for (      KEdge kedge : _kieler2PtolemyDivaEdges.keySet()) {
        Relation oldRelation=_applyEdgeLayout(kedge);
        if (oldRelation != null) {
          relationsToDelete.add(oldRelation);
        }
      }
      _ptolemyModelUtil._removeRelations(relationsToDelete);
    }
    if (_doApplyEdgeLayoutBendPointAnnotation) {
      for (      KEdge kedge : _kieler2PtolemyDivaEdges.keySet()) {
        _applyEdgeLayout(kedge);
      }
    }
  }
  _ptolemyModelUtil._performChangeRequest(_compositeActor);
}","/** 
 * Traverse a composite KNode containing corresponding Kieler nodes, ports and edges for the Ptolemy model and apply all layout information contained by it back to the Ptolemy model. Do most changes to the Ptolemy model via MoMLChangeRequests. Set location attributes for all visible Ptolemy nodes. So far Ptolemy does not support setting of connection bendpoints explicitly. The Ptolemy connection router does not consider obstruction avoidance so there are likely to be connection overlappings in the diagram. <p> Optionally route edges explicitly by inserting new relation vertices for each bend point.
 * @see #setApplyEdgeLayout(boolean)
 * @param kgraph The Kieler graph object containing all layout information to apply to the Ptolemy model
 * @exception IllegalActionException Exception can be thrown if routing of edges fails due to not allowed unlinking or linking of new relations.
 */
private void _applyLayout(KNode kgraph) throws IllegalActionException {
  GraphModel graph=this.getLayoutTarget().getGraphModel();
  if (graph instanceof ActorGraphModel) {
    Collection<KNode> kNodes=kgraph.getChildren();
    if (_doBoxLayout) {
      kNodes=_kieler2ptolemyEntityNodes.keySet();
    }
    for (    KNode knode : kNodes) {
      KShapeLayout absoluteLayout=KielerGraphUtil._getAbsoluteLayout(knode);
      NamedObj namedObj=_kieler2ptolemyEntityNodes.get(knode);
      _kNode2Ptolemy(absoluteLayout,knode);
      if (namedObj instanceof Relation) {
        Vertex vertex=(Vertex)_kieler2ptolemyDivaNodes.get(knode);
        _ptolemyModelUtil._setLocation(vertex,(Relation)namedObj,absoluteLayout.getXpos(),absoluteLayout.getYpos());
      }
 else {
        _ptolemyModelUtil._setLocation(namedObj,absoluteLayout.getXpos(),absoluteLayout.getYpos());
      }
    }
    if (_doApplyEdgeLayout) {
      Set<Relation> relationsToDelete=new HashSet<Relation>();
      for (      KEdge kedge : _kieler2PtolemyDivaEdges.keySet()) {
        Relation oldRelation=_applyEdgeLayout(kedge);
        if (oldRelation != null) {
          relationsToDelete.add(oldRelation);
        }
      }
      _ptolemyModelUtil._removeRelations(relationsToDelete);
    }
    if (_doApplyEdgeLayoutBendPointAnnotation) {
      for (      KEdge kedge : _kieler2PtolemyDivaEdges.keySet()) {
        _applyEdgeLayoutBendPointAnnotation(kedge);
      }
    }
  }
  _ptolemyModelUtil._performChangeRequest(_compositeActor);
}"
73600,"/** 
 * Save the model to the database, together with the references changes  to its parent models. 
 * @param isNew Whether this is a new model. 
 * @param id The id of this model. 
 * @param parentsMaintainOldVersion The list of parents names that do not want to reflect the changes to the submodel they have.  
 * @param newVersionName The new name of this saving model, to have those parent models maintaining the old reference.
 * @throws Exception Thrown if errors occur during the saving. 
 */
private void _commitSave(boolean isNew,String id,ArrayList<String> parentsMaintainOldVersion,String newVersionName) throws Exception {
  String newName=_attributesListPanel.getModelName();
  _modelToSave.setName(newName);
  _updateDisplayedModel();
  if (isNew || id == null) {
    if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) != null) {
      _modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR).setContainer(null);
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
      }
 catch (      Exception e) {
        _resetValues();
        throw e;
      }
    }
  }
  if (_xmlModel == null) {
    _xmlModel=new XMLDBModel(_modelToSave.getName());
  }
  _xmlModel.setModelName(_modelToSave.getName());
  _xmlModel.setModel(_modelToSave.exportMoML());
  _xmlModel.setIsNew(isNew);
  _xmlModel.setModelId(id);
  XMLDBModelWithReferenceChanges xmlDBModelWithReferenceChanges=new XMLDBModelWithReferenceChanges(_xmlModel,parentsMaintainOldVersion,newVersionName);
  try {
    String modelId=_saveModelManager.saveWithParents(xmlDBModelWithReferenceChanges);
    if (modelId != null) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) == null) {
        StringConstantParameter dbModelParam=new StringConstantParameter(_modelToSave,XMLDBModel.DB_MODEL_ID_ATTR);
        dbModelParam.setExpression(modelId);
        dbModelParam.setContainer(_modelToSave);
      }
 else       if (!((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).getExpression().equals(modelId)) {
        ((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).setExpression(modelId);
      }
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
        _source.setTitle(_xmlModel.getModelName());
        try {
          _source.updateDBModelHistory(_xmlModel.getModelName(),false);
        }
 catch (        IOException e) {
        }
      }
 catch (      Exception e) {
        throw e;
      }
      ArrayList<String> openedParents=null;
      if (_parentValidateFrame != null) {
        openedParents=new ArrayList<String>();
        for (        String openedParentModelName : _parentValidateFrame._getOpenedParents()) {
          openedParents.add(openedParentModelName);
        }
      }
      _source.setModified(false);
      if (_parentValidateFrame != null) {
        _parentValidateFrame.dispose();
      }
      dispose();
      if (openedParents != null) {
        for (        String openedParentModelName : openedParents) {
          PtolemyEffigy parentModelEffigy=(PtolemyEffigy)_source.getConfiguration().getDirectory().getEffigy(openedParentModelName);
          parentModelEffigy.closeTableaux();
          parentModelEffigy.setContainer(null);
          PtolemyEffigy updatedParentModelEffigy=LoadManager.loadModel(openedParentModelName,_source.getConfiguration());
          if (updatedParentModelEffigy != null) {
            updatedParentModelEffigy.showTableaux();
          }
        }
      }
      _source.getConfiguration().getDirectory().getEffigy(_xmlModel.getModelName()).showTableaux();
    }
 else {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    }
  }
 catch (  DBConnectionException exception) {
    _resetValues();
    throw exception;
  }
catch (  DBExecutionException exception) {
    _resetValues();
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    _resetValues();
    throw exception;
  }
catch (  ModelAlreadyExistException exception) {
    _resetValues();
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    _rollbackModel();
  }
}","/** 
 * Save the model to the database, together with the references changes  to its parent models. 
 * @param isNew Whether this is a new model. 
 * @param id The id of this model. 
 * @param parentsMaintainOldVersion The list of parents names that do not want to reflect the changes to the submodel they have.  
 * @param newVersionName The new name of this saving model, to have those parent models maintaining the old reference.
 * @throws Exception Thrown if errors occur during the saving. 
 */
private void _commitSave(boolean isNew,String id,ArrayList<String> parentsMaintainOldVersion,String newVersionName) throws Exception {
  String newName=_attributesListPanel.getModelName();
  _modelToSave.setName(newName);
  _updateDisplayedModel();
  if (isNew || id == null) {
    if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) != null) {
      _modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR).setContainer(null);
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
      }
 catch (      Exception e) {
        _resetValues();
        throw e;
      }
    }
  }
  if (_xmlModel == null) {
    _xmlModel=new XMLDBModel(_modelToSave.getName());
  }
  _xmlModel.setModelName(_modelToSave.getName());
  _xmlModel.setModel(_modelToSave.exportMoML());
  _xmlModel.setIsNew(isNew);
  _xmlModel.setModelId(id);
  XMLDBModelWithReferenceChanges xmlDBModelWithReferenceChanges=new XMLDBModelWithReferenceChanges(_xmlModel,parentsMaintainOldVersion,newVersionName);
  try {
    String modelId=_saveModelManager.saveWithParents(xmlDBModelWithReferenceChanges);
    if (modelId != null) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) == null) {
        StringConstantParameter dbModelParam=new StringConstantParameter(_modelToSave,XMLDBModel.DB_MODEL_ID_ATTR);
        dbModelParam.setExpression(modelId);
        dbModelParam.setContainer(_modelToSave);
      }
 else       if (!((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).getExpression().equals(modelId)) {
        ((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).setExpression(modelId);
      }
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
        _source.setTitle(_xmlModel.getModelName());
        try {
          _source.updateDBModelHistory(_xmlModel.getModelName(),false);
        }
 catch (        IOException e) {
        }
      }
 catch (      Exception e) {
        throw e;
      }
      ArrayList<String> openedParents=null;
      if (_parentValidateFrame != null) {
        openedParents=new ArrayList<String>();
        for (        String openedParentModelName : _parentValidateFrame._getOpenedParents()) {
          openedParents.add(openedParentModelName);
        }
      }
      _source.setModified(false);
      if (_parentValidateFrame != null) {
        _parentValidateFrame.dispose();
      }
      dispose();
      if (openedParents != null) {
        for (        String openedParentModelName : openedParents) {
          PtolemyEffigy parentModelEffigy=(PtolemyEffigy)_source.getConfiguration().getDirectory().getEffigy(openedParentModelName);
          parentModelEffigy.closeTableaux();
          parentModelEffigy.setContainer(null);
          PtolemyEffigy updatedParentModelEffigy=LoadManager.loadModel(openedParentModelName,_source.getConfiguration());
          if (updatedParentModelEffigy != null) {
            updatedParentModelEffigy.showTableaux();
          }
        }
      }
      if (_source.getConfiguration().getDirectory().getEffigy(_xmlModel.getModelName()) != null) {
        _source.getConfiguration().getDirectory().getEffigy(_xmlModel.getModelName()).showTableaux();
      }
    }
 else {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    }
  }
 catch (  DBConnectionException exception) {
    _resetValues();
    throw exception;
  }
catch (  DBExecutionException exception) {
    _resetValues();
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    _resetValues();
    throw exception;
  }
catch (  ModelAlreadyExistException exception) {
    _resetValues();
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    _rollbackModel();
  }
}"
73601,"/** 
 * Constructor for a generic attribute PTDBSearchAttribute.
 * @param genericClassName Name of the Attribute class.
 */
public PTDBSearchAttribute(String genericClassName){
  super();
  _isGenericAttribute=true;
  _genericClassName=genericClassName;
}","/** 
 * Default constructor of PTDBSearchAttribute.
 */
public PTDBSearchAttribute(){
  super();
  _isGenericAttribute=false;
}"
73602,"protected ArrayList<Attribute> getAttributes() throws IllegalActionException {
  ArrayList<Attribute> returnList=super.getAttributes();
  Component[] componentArray1=_attListPanel.getComponents();
  for (int i=0; i < componentArray1.length; i++) {
    if (componentArray1[i] instanceof JPanel) {
      Component[] componentArray2=((JPanel)componentArray1[i]).getComponents();
      for (int j=0; j < componentArray2.length; j++) {
        if (componentArray2[j] instanceof GenericAttributePanel) {
          try {
            PTDBSearchAttribute attribute=new PTDBSearchAttribute((((GenericAttributePanel)componentArray2[j]).getAttributeClass()));
            attribute.setName(((GenericAttributePanel)componentArray2[j]).getAttributeName());
            attribute.setExpression(((GenericAttributePanel)componentArray2[j]).getValue());
            returnList.add(attribute);
          }
 catch (          NameDuplicationException e) {
          }
        }
      }
    }
  }
  return returnList;
}","protected ArrayList<Attribute> getAttributes() throws IllegalActionException {
  ArrayList<Attribute> returnList=super.getAttributes();
  Component[] componentArray1=_attListPanel.getComponents();
  for (int i=0; i < componentArray1.length; i++) {
    if (componentArray1[i] instanceof JPanel) {
      Component[] componentArray2=((JPanel)componentArray1[i]).getComponents();
      for (int j=0; j < componentArray2.length; j++) {
        if (componentArray2[j] instanceof GenericAttributePanel) {
          try {
            PTDBSearchAttribute attribute=new PTDBSearchAttribute();
            attribute.setGenericAttribute(true);
            if ((((GenericAttributePanel)componentArray2[j]).getAttributeClass()).length() > 0) {
              attribute.setGenericClassName((((GenericAttributePanel)componentArray2[j]).getAttributeClass()));
            }
            attribute.setName(((GenericAttributePanel)componentArray2[j]).getAttributeName());
            if ((((GenericAttributePanel)componentArray2[j]).getValue()).length() > 0) {
              attribute.setExpression(((GenericAttributePanel)componentArray2[j]).getValue());
            }
            System.out.println(""String_Node_Str"" + attribute.getName());
            System.out.println(""String_Node_Str"" + attribute.getExpression());
            System.out.println(""String_Node_Str"" + attribute.getGenericClassName());
            returnList.add(attribute);
          }
 catch (          NameDuplicationException e) {
          }
        }
      }
    }
  }
  return returnList;
}"
73603,"/** 
 * Construct the AttributeSearcher according to the input search criteria.
 * @param searchCriteria The search criteria that input by the user.
 */
public AttributeSearcher(SearchCriteria searchCriteria){
  if (searchCriteria.getAttributes() != null && searchCriteria.getAttributes().size() > 0) {
    HashMap<String,PTDBGenericAttribute> attributesMap=new HashMap<String,PTDBGenericAttribute>();
    for (    Attribute originalAttribute : searchCriteria.getAttributes()) {
      if (!attributesMap.containsKey(originalAttribute.getName())) {
        PTDBGenericAttribute newAttribute=new PTDBGenericAttribute(originalAttribute.getName());
        newAttribute.addValue(((Variable)originalAttribute).getValueAsString());
        if (originalAttribute instanceof PTDBSearchAttribute) {
          if (!((PTDBSearchAttribute)originalAttribute).isGenericAttribute()) {
            newAttribute.setClassName(originalAttribute.getClassName());
          }
        }
 else {
          newAttribute.setClassName(originalAttribute.getClassName());
        }
        attributesMap.put(newAttribute.getAttributeName(),newAttribute);
      }
 else {
        PTDBGenericAttribute attribute=attributesMap.get(originalAttribute.getName());
        attribute.addValue(((Variable)originalAttribute).getValueAsString());
      }
    }
    ArrayList<PTDBGenericAttribute> attributeList=new ArrayList<PTDBGenericAttribute>(attributesMap.values());
    _attributesCriteria=attributeList;
  }
}","/** 
 * Construct the AttributeSearcher according to the input search criteria.
 * @param searchCriteria The search criteria that input by the user.
 */
public AttributeSearcher(SearchCriteria searchCriteria){
  if (searchCriteria.getAttributes() != null && searchCriteria.getAttributes().size() > 0) {
    HashMap<String,PTDBGenericAttribute> attributesMap=new HashMap<String,PTDBGenericAttribute>();
    for (    Attribute originalAttribute : searchCriteria.getAttributes()) {
      if (!attributesMap.containsKey(originalAttribute.getName())) {
        PTDBGenericAttribute newAttribute=new PTDBGenericAttribute(originalAttribute.getName());
        newAttribute.addValue(((Variable)originalAttribute).getExpression());
        if (originalAttribute instanceof PTDBSearchAttribute) {
          if (!((PTDBSearchAttribute)originalAttribute).isGenericAttribute()) {
            System.out.println(""String_Node_Str"");
            newAttribute.setClassName(originalAttribute.getClassName());
          }
 else {
            newAttribute.setClassName(((PTDBSearchAttribute)originalAttribute).getGenericClassName());
          }
        }
 else {
          newAttribute.setClassName(originalAttribute.getClassName());
        }
        attributesMap.put(newAttribute.getAttributeName(),newAttribute);
      }
 else {
        PTDBGenericAttribute attribute=attributesMap.get(originalAttribute.getName());
        attribute.addValue(((Variable)originalAttribute).getValueAsString());
      }
    }
    ArrayList<PTDBGenericAttribute> attributeList=new ArrayList<PTDBGenericAttribute>(attributesMap.values());
    _attributesCriteria=attributeList;
  }
}"
73604,"public boolean hasCode(){
  return true;
}","public boolean hasCode(){
  return !isEmpty();
}"
73605,"/** 
 * Create new empty Syntactic Column. 
 */
public SyntacticColumn(){
  super();
  _inputs=new LinkedList();
  _outputs=new LinkedList();
}","/** 
 * Create new empty Syntactic Column. 
 */
public SyntacticColumn(){
  super();
}"
73606,"/** 
 * Sort constituent terms in column by type order.  Sorting a column will change its neighboring permutations. 
 */
public void sort(){
  final Comparator<SyntacticTerm> compareNodes=new Comparator<SyntacticTerm>(){
    public int compare(    SyntacticTerm a,    SyntacticTerm b){
      return a.getOrder() - b.getOrder();
    }
  }
;
  Collections.sort(this,compareNodes);
  _inputs.clear();
  _outputs.clear();
  for (  SyntacticTerm node : this) {
    _inputs.addAll(node.getInputs());
    _outputs.addAll(node.getOutputs());
  }
}","/** 
 * Sort constituent terms in column by type order.  Sorting a column will change its neighboring permutations. 
 */
public void sort(){
  final Comparator<SyntacticTerm> compareNodes=new Comparator<SyntacticTerm>(){
    public int compare(    SyntacticTerm a,    SyntacticTerm b){
      return a.getOrder() - b.getOrder();
    }
  }
;
  Collections.sort(this,compareNodes);
  _refreshPorts();
}"
73607,"public String generateCode(){
  return ""String_Node_Str"" + _degree + ""String_Node_Str""+ (_kernel == null ? ""String_Node_Str"" : _kernel.generateCode())+ ""String_Node_Str"";
}","public String generateCode(){
  if (_kernel == null)   return ""String_Node_Str"";
 else   return ""String_Node_Str"" + _degree + ""String_Node_Str""+ _kernel.generateCode()+ ""String_Node_Str"";
}"
73608,"public SyntacticContraction(int degree){
  _degree=degree > 0 ? degree : 0;
  _kernel=null;
}","public SyntacticContraction(int degree){
  _degree=degree > 0 ? degree : 0;
  _kernel=null;
  _rank=null;
}"
73609,"public boolean setKernel(SyntacticTerm term){
  int termIns=term.sizeInputs();
  int termOuts=term.sizeOutputs();
  System.out.print(""String_Node_Str"" + _degree + ""String_Node_Str""+ termIns+ ""String_Node_Str""+ termOuts+ ""String_Node_Str"");
  if (_degree > termIns || _degree > termOuts)   return false;
  _kernel=term;
  return true;
}","public boolean setKernel(SyntacticTerm term){
  SyntacticRank rank=term.rank();
  SyntacticRank crank=SyntacticRank.contract(rank,_degree);
  if (crank == null)   return false;
  _rank=crank;
  _kernel=term;
  System.out.print(""String_Node_Str"" + _degree + ""String_Node_Str""+ crank.generateCode()+ ""String_Node_Str"");
  return true;
}"
73610,"public Rank rank(){
  return null;
}","public SyntacticRank rank(){
  return _rank;
}"
73611,"/** 
 * Transfer at most one data token from the given output port of the container to the ports it is connected to on the outside. If the receiver is known to be empty, then send a clear. If the receiver status is not known, do nothing.
 * @exception IllegalActionException If the port is not an opaque output port.
 * @param port The port to transfer tokens from.
 * @return True if the port has an inside token that was successfully transferred. Otherwisereturn false (or throw an exception).
 */
protected boolean _transferOutputs(IOPort port) throws IllegalActionException {
  boolean result=false;
  if (_debugging) {
    _debug(""String_Node_Str"" + port.getFullName());
  }
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < port.getWidthInside(); i++) {
    try {
      if (port.isKnownInside(i)) {
        if (port.hasTokenInside(i)) {
          Token t=port.getInside(i);
          if (_debugging) {
            _debug(getName(),""String_Node_Str"" + t + ""String_Node_Str""+ port.getName());
          }
          port.send(i,t);
          _hadToken.add(port);
          result=true;
        }
 else {
          if (_debugging) {
            _debug(getName(),""String_Node_Str"" + port.getName());
          }
          if (!_hadToken.contains(port)) {
            FSMActor controller=getController();
            boolean guardsEvaluable=_isSafeToClear(port,controller);
            if (guardsEvaluable) {
              port.send(i,null);
            }
          }
        }
      }
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(this,ex,null);
    }
  }
  return result;
}","/** 
 * Transfer at most one data token from the given output port of the container to the ports it is connected to on the outside. If the receiver is known to be empty, then send a clear. If the receiver status is not known, do nothing.
 * @exception IllegalActionException If the port is not an opaque output port.
 * @param port The port to transfer tokens from.
 * @return True if the port has an inside token that was successfully transferred. Otherwisereturn false (or throw an exception).
 */
protected boolean _transferOutputs(IOPort port) throws IllegalActionException {
  boolean result=false;
  if (_debugging) {
    _debug(""String_Node_Str"" + port.getFullName());
  }
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < port.getWidthInside(); i++) {
    try {
      if (port.isKnownInside(i)) {
        if (port.hasTokenInside(i)) {
          Token t=port.getInside(i);
          if (_debugging) {
            _debug(getName(),""String_Node_Str"" + t + ""String_Node_Str""+ port.getName());
          }
          port.send(i,t);
          _hadToken.add(port);
          result=true;
        }
 else {
          if (!_hadToken.contains(port)) {
            if (_debugging) {
              _debug(getName(),""String_Node_Str"" + port.getName());
            }
            FSMActor controller=getController();
            if ((controller.getLastChosenTransition() != null) || _isSafeToClear(port,controller)) {
              port.send(i,null);
            }
          }
        }
      }
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(this,ex,null);
    }
  }
  return result;
}"
73612,"/** 
 * Display the given node with the current prefix, recursing into the children of the node.
 * @param node The node to be displayed.
 * @exception If there is a problem displaying the children.
 */
protected void _displayNode(ASTPtRootNode node) throws IllegalActionException {
  if (node.isEvaluated()) {
    String str=node.toString(_prefix) + ""String_Node_Str"";
    str=str + node.getToken().getClass().getName() + ""String_Node_Str"";
    _stream.println(str + node.getToken().toString());
  }
 else {
    _stream.println(node.toString(_prefix) + ""String_Node_Str"");
  }
  _stream.println(""String_Node_Str"" + node.getType());
  if (node.jjtGetNumChildren() > 0) {
    String oldPrefix=_prefix;
    _prefix=""String_Node_Str"" + oldPrefix;
    for (int i=0; i < node.jjtGetNumChildren(); i++) {
      ASTPtRootNode child=(ASTPtRootNode)node.jjtGetChild(i);
      child.visit(this);
    }
    _prefix=oldPrefix;
  }
}","/** 
 * Display the given node with the current prefix, recursing into the children of the node.
 * @param node The node to be displayed.
 * @exception IllegalActionException If there is a problemdisplaying the children.
 */
protected void _displayNode(ASTPtRootNode node) throws IllegalActionException {
  if (node.isEvaluated()) {
    String str=node.toString(_prefix) + ""String_Node_Str"";
    str=str + node.getToken().getClass().getName() + ""String_Node_Str"";
    _stream.println(str + node.getToken().toString());
  }
 else {
    _stream.println(node.toString(_prefix) + ""String_Node_Str"");
  }
  _stream.println(""String_Node_Str"" + node.getType());
  if (node.jjtGetNumChildren() > 0) {
    String oldPrefix=_prefix;
    _prefix=""String_Node_Str"" + oldPrefix;
    for (int i=0; i < node.jjtGetNumChildren(); i++) {
      ASTPtRootNode child=(ASTPtRootNode)node.jjtGetChild(i);
      child.visit(this);
    }
    _prefix=oldPrefix;
  }
}"
73613,"/** 
 * Add hot keys to the actions in the given JGraph.
 * @param jgraph The JGraph to which hot keys are to be added.
 */
protected void _addHotKeys(JGraph jgraph){
  super._addHotKeys(jgraph);
  _classDefinitionController.addHotKeys(getFrame().getJGraph());
}","/** 
 * Add hot keys to the actions in the given JGraph.
 * @param jgraph The JGraph to which hot keys are to be added.
 */
protected void _addHotKeys(JGraph jgraph){
  super._addHotKeys(jgraph);
  _classDefinitionController.addHotKeys(getFrame().getJGraph());
  StringParameter actorInteractionAddon;
  try {
    actorInteractionAddon=(StringParameter)this.getConfiguration().getAttribute(""String_Node_Str"",Parameter.class);
    if (actorInteractionAddon != null) {
      _dbActorController.addHotKeys(getFrame().getJGraph());
    }
  }
 catch (  Exception e) {
  }
}"
73614,"/** 
 * Create the controllers for nodes in this graph. In this class, controllers with FULL access are created. This is called by the constructor, so derived classes that override this must be careful not to reference local variables defined in the derived classes, because the derived classes will not have been fully constructed by the time this is called.
 */
protected void _createControllers(){
  Configuration _config=(Configuration)Configuration.configurations().iterator().next();
  String _alternateActorInstanceClassName=null;
  _attributeController=new AttributeController(this,AttributeController.FULL);
  _classDefinitionController=new ClassDefinitionController(this);
  if (_config != null) {
    StringParameter actorInteractionAddon;
    try {
      actorInteractionAddon=(StringParameter)_config.getAttribute(""String_Node_Str"",Parameter.class);
      if (actorInteractionAddon != null) {
        String actorInteractionAddonClassName=actorInteractionAddon.stringValue();
        Class actorInteractionAddonClass=Class.forName(actorInteractionAddonClassName);
        ActorInteractionAddon actorInterationAddon=(ActorInteractionAddon)actorInteractionAddonClass.newInstance();
        Method method2=actorInteractionAddonClass.getMethod(""String_Node_Str"",GraphController.class);
        _dbActorController=(ActorController)method2.invoke(actorInterationAddon,this);
      }
 else {
      }
    }
 catch (    Exception e) {
    }
  }
 else {
  }
  if (_config != null) {
    StringAttribute _alternateActorInstanceAttribute=(StringAttribute)_config.getAttribute(""String_Node_Str"");
    if (_alternateActorInstanceAttribute != null) {
      _alternateActorInstanceClassName=_alternateActorInstanceAttribute.getExpression();
    }
  }
  if (_alternateActorInstanceClassName == null) {
    _entityController=new ActorInstanceController(this);
  }
 else {
    try {
      Class _alternateActorInstanceClass=Class.forName(_alternateActorInstanceClassName);
      Class[] argsClass=new Class[]{diva.graph.GraphController.class};
      Object[] args=new Object[]{this};
      Constructor alternateActorInstanceConstructor=_alternateActorInstanceClass.getConstructor(argsClass);
      _entityController=(ActorController)alternateActorInstanceConstructor.newInstance(args);
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + _alternateActorInstanceClassName + ""String_Node_Str""+ ""String_Node_Str""+ e.getMessage());
      e.printStackTrace();
    }
  }
  _entityPortController=new IOPortController(this,AttributeController.FULL);
  _portController=new ExternalIOPortController(this,AttributeController.FULL);
  _relationController=new RelationController(this);
  _linkController=new LinkController(this);
}","/** 
 * Create the controllers for nodes in this graph. In this class, controllers with FULL access are created. This is called by the constructor, so derived classes that override this must be careful not to reference local variables defined in the derived classes, because the derived classes will not have been fully constructed by the time this is called.
 */
protected void _createControllers(){
  Configuration _config=(Configuration)Configuration.configurations().iterator().next();
  String _alternateActorInstanceClassName=null;
  _attributeController=new AttributeController(this,AttributeController.FULL);
  _classDefinitionController=new ClassDefinitionController(this);
  if (_config != null) {
    StringParameter actorInteractionAddon;
    try {
      actorInteractionAddon=(StringParameter)_config.getAttribute(""String_Node_Str"",Parameter.class);
      if (actorInteractionAddon != null) {
        String actorInteractionAddonClassName=actorInteractionAddon.stringValue();
        Class actorInteractionAddonClass=Class.forName(actorInteractionAddonClassName);
        ActorInteractionAddon actorInterationAddon=(ActorInteractionAddon)actorInteractionAddonClass.newInstance();
        Method method2=actorInteractionAddonClass.getMethod(""String_Node_Str"",GraphController.class);
        _dbActorController=(ActorController)method2.invoke(actorInterationAddon,this);
      }
    }
 catch (    Exception e) {
    }
  }
  if (_config != null) {
    StringAttribute _alternateActorInstanceAttribute=(StringAttribute)_config.getAttribute(""String_Node_Str"");
    if (_alternateActorInstanceAttribute != null) {
      _alternateActorInstanceClassName=_alternateActorInstanceAttribute.getExpression();
    }
  }
  if (_alternateActorInstanceClassName == null) {
    _entityController=new ActorInstanceController(this);
  }
 else {
    try {
      Class _alternateActorInstanceClass=Class.forName(_alternateActorInstanceClassName);
      Class[] argsClass=new Class[]{diva.graph.GraphController.class};
      Object[] args=new Object[]{this};
      Constructor alternateActorInstanceConstructor=_alternateActorInstanceClass.getConstructor(argsClass);
      _entityController=(ActorController)alternateActorInstanceConstructor.newInstance(args);
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + _alternateActorInstanceClassName + ""String_Node_Str""+ ""String_Node_Str""+ e.getMessage());
      e.printStackTrace();
    }
  }
  _entityPortController=new IOPortController(this,AttributeController.FULL);
  _portController=new ExternalIOPortController(this,AttributeController.FULL);
  _relationController=new RelationController(this);
  _linkController=new LinkController(this);
}"
73615,"/** 
 * Create the controllers for nodes in this graph. In this base class, controllers with PARTIAL access are created. This is called by the constructor, so derived classes that override this must be careful not to reference local variables defined in the derived classes, because the derived classes will not have been fully constructed by the time this is called.
 */
protected void _createControllers(){
  super._createControllers();
  _attributeController=new AttributeController(this,AttributeController.PARTIAL);
  _classDefinitionController=new ClassDefinitionController(this,AttributeController.PARTIAL);
  StringParameter actorInteractionAddon;
  try {
    actorInteractionAddon=(StringParameter)this.getConfiguration().getAttribute(""String_Node_Str"",Parameter.class);
    if (actorInteractionAddon != null) {
      String actorInteractionAddonClassName=actorInteractionAddon.stringValue();
      Class actorInteractionAddonClass=Class.forName(actorInteractionAddonClassName);
      ActorInteractionAddon actorInterationAddon=(ActorInteractionAddon)actorInteractionAddonClass.newInstance();
      Method method2=actorInteractionAddonClass.getMethod(""String_Node_Str"",GraphController.class,Boolean.TYPE);
      _dbActorController=(ActorController)method2.invoke(actorInterationAddon,this,false);
    }
 else {
    }
  }
 catch (  Exception e) {
  }
  _entityController=new ActorInstanceController(this,AttributeController.PARTIAL);
  _entityPortController=new IOPortController(this,AttributeController.PARTIAL);
  _relationController=new RelationController(this);
  _linkController=new LinkController(this);
}","/** 
 * Create the controllers for nodes in this graph. In this base class, controllers with PARTIAL access are created. This is called by the constructor, so derived classes that override this must be careful not to reference local variables defined in the derived classes, because the derived classes will not have been fully constructed by the time this is called.
 */
protected void _createControllers(){
  super._createControllers();
  _attributeController=new AttributeController(this,AttributeController.PARTIAL);
  _classDefinitionController=new ClassDefinitionController(this,AttributeController.PARTIAL);
  StringParameter actorInteractionAddon;
  try {
    actorInteractionAddon=(StringParameter)this.getConfiguration().getAttribute(""String_Node_Str"",Parameter.class);
    if (actorInteractionAddon != null) {
      String actorInteractionAddonClassName=actorInteractionAddon.stringValue();
      Class actorInteractionAddonClass=Class.forName(actorInteractionAddonClassName);
      ActorInteractionAddon actorInterationAddon=(ActorInteractionAddon)actorInteractionAddonClass.newInstance();
      Method method2=actorInteractionAddonClass.getMethod(""String_Node_Str"",GraphController.class,Boolean.TYPE);
      _dbActorController=(ActorController)method2.invoke(actorInterationAddon,this,false);
    }
  }
 catch (  Exception e) {
  }
  _entityController=new ActorInstanceController(this,AttributeController.PARTIAL);
  _entityPortController=new IOPortController(this,AttributeController.PARTIAL);
  _relationController=new RelationController(this);
  _linkController=new LinkController(this);
}"
73616,"/** 
 * Add hot keys to the actions in the given JGraph.
 * @param jgraph The JGraph to which hot keys are to be added.
 */
protected void _addHotKeys(JGraph jgraph){
  super._addHotKeys(jgraph);
  _entityController.addHotKeys(jgraph);
  _classDefinitionController.addHotKeys(jgraph);
  _attributeController.addHotKeys(jgraph);
}","/** 
 * Add hot keys to the actions in the given JGraph.
 * @param jgraph The JGraph to which hot keys are to be added.
 */
protected void _addHotKeys(JGraph jgraph){
  super._addHotKeys(jgraph);
  _entityController.addHotKeys(jgraph);
  _classDefinitionController.addHotKeys(jgraph);
  _attributeController.addHotKeys(jgraph);
  StringParameter actorInteractionAddon;
  try {
    actorInteractionAddon=(StringParameter)this.getConfiguration().getAttribute(""String_Node_Str"",Parameter.class);
    if (actorInteractionAddon != null) {
      _dbActorController.addHotKeys(jgraph);
    }
  }
 catch (  Exception e) {
  }
}"
73617,"/** 
 * Set the configuration.  The configuration is used when opening documentation files.
 * @param configuration The configuration.
 */
public void setConfiguration(Configuration configuration){
  super.setConfiguration(configuration);
  _attributeController.setConfiguration(configuration);
  _classDefinitionController.setConfiguration(configuration);
  _entityController.setConfiguration(configuration);
  _entityPortController.setConfiguration(configuration);
  _relationController.setConfiguration(configuration);
  _linkController.setConfiguration(configuration);
}","/** 
 * Set the configuration.  The configuration is used when opening documentation files.
 * @param configuration The configuration.
 */
public void setConfiguration(Configuration configuration){
  super.setConfiguration(configuration);
  _attributeController.setConfiguration(configuration);
  _classDefinitionController.setConfiguration(configuration);
  _entityController.setConfiguration(configuration);
  _entityPortController.setConfiguration(configuration);
  _relationController.setConfiguration(configuration);
  _linkController.setConfiguration(configuration);
  StringParameter actorInteractionAddon;
  try {
    actorInteractionAddon=(StringParameter)this.getConfiguration().getAttribute(""String_Node_Str"",Parameter.class);
    if (actorInteractionAddon != null) {
      _dbActorController.setConfiguration(configuration);
    }
  }
 catch (  Exception e) {
  }
}"
73618,"/** 
 * Return the greater concept of the counterexample.
 * @return The greater concept
 * @see java.util.Map.Entry#getValue()
 */
public Concept getValue(){
  return greater;
}","/** 
 * Return the greater concept of the counterexample.
 * @return The greater concept
 * @see java.util.Map.Entry#getValue()
 * @see #setValue(Concept)
 */
public Concept getValue(){
  return greater;
}"
73619,"/** 
 * Do nothing. (Counterexamples are immutable)
 * @param value Ignored
 * @return Always return null.
 * @see java.util.Map.Entry#setValue(java.lang.Object)
 */
public Concept setValue(Concept value){
  return null;
}","/** 
 * Do nothing. (Counterexamples are immutable)
 * @param value Ignored
 * @return Always return null.
 * @see java.util.Map.Entry#setValue(java.lang.Object)
 * @see #getValue()
 */
public Concept setValue(Concept value){
  return null;
}"
73620,"/** 
 * Unregister a ""published port"" coming from a publisher. The name is the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the same name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param name The name is being used in the matching processto match publisher and subscriber. This will be the port that should be removed
 * @param publisherPort The publisher port.
 * @param global If true, unregister the port all the way up the hierarchy.
 * @throws NameDuplicationException 
 * @throws IllegalActionException 
 */
public void unregisterPublisherPort(String name,IOPort publisherPort,boolean global) throws IllegalActionException, NameDuplicationException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).unregisterPublisherPort(name,publisherPort);
  }
 else {
    if (_publishedPorts != null) {
      List<IOPort> ports=_publishedPorts.get(name);
      if (ports != null) {
        ports.remove(publisherPort);
        if (ports.isEmpty()) {
          _publishedPorts.remove(name);
        }
      }
    }
    List connectedPorts=publisherPort.connectedPortList();
    if (_publisherRelations != null) {
      IORelation relation=_publisherRelations.get(name);
      if (relation != null) {
        relation.setContainer(null);
        notifyConnectivityChange();
        _publisherRelations.remove(name);
      }
    }
    if (global && container instanceof CompositeActor) {
      for (      Object port : connectedPorts) {
        IOPort publishedPort=(IOPort)port;
        if (publishedPort.isOutput()) {
          ((CompositeActor)container).unregisterPublisherPort(name,publishedPort,global);
          publishedPort.setContainer(null);
        }
      }
    }
  }
}","/** 
 * Unregister a ""published port"" coming from a publisher. The name is the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the same name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param name The name is being used in the matching processto match publisher and subscriber. This will be the port that should be removed
 * @param publisherPort The publisher port.
 * @param global If true, unregister the port all the way up the hierarchy.
 * @throws NameDuplicationException 
 * @throws IllegalActionException 
 */
public void unregisterPublisherPort(String name,IOPort publisherPort,boolean global) throws IllegalActionException, NameDuplicationException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).unregisterPublisherPort(name,publisherPort);
  }
 else {
    if (_publishedPorts != null) {
      List<IOPort> ports=_publishedPorts.get(name);
      if (ports != null) {
        ports.remove(publisherPort);
        if (ports.isEmpty()) {
          _publishedPorts.remove(name);
        }
      }
    }
    if (_publisherRelations != null) {
      IORelation relation=_publisherRelations.get(name);
      if (relation != null) {
        if (global && container instanceof CompositeActor) {
          for (          Object port : relation.linkedPortList(publisherPort)) {
            IOPort publishedPort=(IOPort)port;
            if (publishedPort.isOutput()) {
              ((CompositeActor)container).unregisterPublisherPort(name,publishedPort,global);
              publishedPort.setContainer(null);
            }
          }
        }
        relation.setContainer(null);
        notifyConnectivityChange();
        _publisherRelations.remove(name);
      }
    }
  }
}"
73621,"/** 
 * Override the base class to record the operation choice.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == operation) {
    String newValue=operation.stringValue();
    if (newValue.equals(""String_Node_Str"")) {
      _addOperation=true;
    }
 else {
      _addOperation=false;
    }
  }
 else   if (attribute == channel) {
    String newValue=channel.stringValue();
    if (!newValue.equals(_channel)) {
      NamedObj container=getContainer();
      if (container instanceof CompositeActor && !(_channel == null || _channel.trim().equals(""String_Node_Str""))) {
        ((CompositeActor)container).unlinkToPublishedPort(_channelPattern,input,_global);
      }
      _channel=newValue;
      super.attributeChanged(attribute);
      _channelPattern=Pattern.compile(_channel);
    }
  }
 else   if (attribute == global) {
    _global=((BooleanToken)global.getToken()).booleanValue();
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * Override the base class to record the operation choice.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == operation) {
    String newValue=operation.stringValue();
    if (newValue.equals(""String_Node_Str"")) {
      _addOperation=true;
    }
 else {
      _addOperation=false;
    }
  }
 else   if (attribute == channel) {
    String newValue=channel.stringValue();
    if (!newValue.equals(_channel)) {
      NamedObj container=getContainer();
      if (container instanceof CompositeActor && !(_channel == null || _channel.trim().equals(""String_Node_Str""))) {
        ((CompositeActor)container).unlinkToPublishedPort(_channelPattern,input,_global);
      }
      _channel=newValue;
      super.attributeChanged(attribute);
      _channelPattern=Pattern.compile(_channel);
    }
  }
 else   if (attribute == global) {
    boolean newValue=((BooleanToken)global.getToken()).booleanValue();
    if (newValue == false && _global == true) {
      NamedObj container=getContainer();
      if (container instanceof CompositeActor && !(_channel == null || _channel.trim().equals(""String_Node_Str""))) {
        ((CompositeActor)container).unlinkToPublishedPort(_channelPattern,input,_global);
      }
    }
    _global=newValue;
  }
 else {
    super.attributeChanged(attribute);
  }
}"
73622,"/** 
 * React to a change in an attribute.  This method is called by a contained attribute when its value changes.  This overrides the base class so that if the attribute is an instance of TypeAttribute, then it sets the type of the port.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  super.attributeChanged(attribute);
  if (attribute == recompileHierarchy) {
    if (((BooleanToken)recompileHierarchy.getToken()).booleanValue()) {
      List<?> entities=entityList(ModularCodeGenTypedCompositeActor.class);
      for (      Object entity : entities) {
        ((ModularCodeGenTypedCompositeActor)entity).recompileHierarchy.setToken(new BooleanToken(true));
      }
    }
  }
 else   if (attribute != recompileThisLevel) {
  }
}","/** 
 * React to a change in an attribute.  This method is called by a contained attribute when its value changes.  This overrides the base class so that if the attribute is an instance of TypeAttribute, then it sets the type of the port.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  super.attributeChanged(attribute);
  if (attribute == recompileHierarchy) {
    if (((BooleanToken)recompileHierarchy.getToken()).booleanValue()) {
      List<?> entities=entityList(ModularCodeGenTypedCompositeActor.class);
      for (      Object entity : entities) {
        ((ModularCodeGenTypedCompositeActor)entity).recompileHierarchy.setToken(new BooleanToken(true));
      }
    }
  }
 else   if (attribute == recompileThisLevel) {
    populate();
  }
 else   if (attribute != recompileThisLevel) {
  }
}"
73623,"/** 
 * Link the subscriberPort with a already registered ""published port"" coming from a publisher. The pattern represents the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the  name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param pattern The pattern is being used in the matching processto match publisher and subscriber.
 * @param subscriberPort The subscribed port. 
 * @param global Specification of whether the data is subscribedglobally.  If set to true, then subscribers will see values published by publishers anywhere in the model that reference the same channel by name.  If set to false, then only values published by publishers that are fired by the same director are seen by this subscriber.
 * @exception NameDuplicationException If there are name conflictsas a result of the added relations or ports. 
 * @exception IllegalActionException If the published port cannot be found.
 */
public void linkToPublishedPort(Pattern pattern,TypedIOPort subscriberPort,boolean global) throws IllegalActionException, NameDuplicationException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).linkToPublishedPort(pattern,subscriberPort,global);
  }
 else {
    if (_publishedPorts == null) {
      if (!global || this == toplevel()) {
        throw new IllegalActionException(subscriberPort.getContainer(),""String_Node_Str"" + subscriberPort.getContainer().getFullName());
      }
    }
 else {
      boolean matched=false;
      for (      String name : _publishedPorts.keySet()) {
        Matcher matcher=pattern.matcher(name);
        if (matcher.matches()) {
          matched=true;
          linkToPublishedPort(name,subscriberPort);
        }
      }
      if (!matched && (!global || this == toplevel())) {
        throw new IllegalActionException(subscriberPort.getContainer(),""String_Node_Str"" + pattern + ""String_Node_Str"");
      }
    }
    if (global && this != toplevel()) {
      String portName=""String_Node_Str"" + StringUtilities.sanitizeName(pattern.toString());
      IOPort port=(IOPort)getPort(portName);
      if (port == null) {
        port=(IOPort)newPort(portName);
        new Parameter(port,""String_Node_Str"",BooleanToken.TRUE);
        port.setPersistent(false);
        port.setInput(true);
        port.setMultiport(true);
        port.setDefaultWidth(0);
        IORelation relation=null;
        try {
          relation=(IORelation)newRelation(uniqueName(subscriberPort.getContainer().getName() + ""String_Node_Str""));
        }
 catch (        NameDuplicationException e) {
          throw new IllegalStateException(e);
        }
        relation.setPersistent(false);
        new Parameter(relation,""String_Node_Str"",BooleanToken.TRUE);
        port.liberalLink(relation);
        if (!subscriberPort.isLinked(relation)) {
          subscriberPort.liberalLink(relation);
          notifyConnectivityChange();
        }
      }
      if (container instanceof CompositeActor) {
        ((CompositeActor)container).linkToPublishedPort(pattern,(TypedIOPort)port,global);
      }
    }
  }
}","/** 
 * Link the subscriberPort with a already registered ""published port"" coming from a publisher. The pattern represents the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the  name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param pattern The pattern is being used in the matching processto match publisher and subscriber.
 * @param subscriberPort The subscribed port. 
 * @param global Specification of whether the data is subscribedglobally.  If set to true, then subscribers will see values published by publishers anywhere in the model that reference the same channel by name.  If set to false, then only values published by publishers that are fired by the same director are seen by this subscriber.
 * @exception NameDuplicationException If there are name conflictsas a result of the added relations or ports. 
 * @exception IllegalActionException If the published port cannot be found.
 */
public void linkToPublishedPort(Pattern pattern,TypedIOPort subscriberPort,boolean global) throws IllegalActionException, NameDuplicationException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).linkToPublishedPort(pattern,subscriberPort,global);
  }
 else {
    if (_publishedPorts == null) {
      if (!global || this == toplevel()) {
        throw new IllegalActionException(subscriberPort.getContainer(),""String_Node_Str"" + subscriberPort.getContainer().getFullName());
      }
    }
 else {
      boolean matched=false;
      for (      String name : _publishedPorts.keySet()) {
        Matcher matcher=pattern.matcher(name);
        if (matcher.matches()) {
          matched=true;
          linkToPublishedPort(name,subscriberPort);
        }
      }
      if (!matched && (!global || this == toplevel())) {
        throw new IllegalActionException(subscriberPort.getContainer(),""String_Node_Str"" + pattern + ""String_Node_Str"");
      }
    }
    if (global && this != toplevel()) {
      String portName=""String_Node_Str"" + StringUtilities.sanitizeName(pattern.toString());
      IOPort port=(IOPort)getPort(portName);
      if (port == null) {
        port=(IOPort)newPort(portName);
        new Parameter(port,""String_Node_Str"",BooleanToken.TRUE);
        port.setPersistent(false);
        port.setInput(true);
        port.setMultiport(true);
        port.setDefaultWidth(0);
      }
      if (!subscriberPort.connectedPortList().contains(port)) {
        IORelation relation=null;
        try {
          relation=(IORelation)newRelation(uniqueName(subscriberPort.getContainer().getName() + ""String_Node_Str""));
        }
 catch (        NameDuplicationException e) {
          throw new IllegalStateException(e);
        }
        relation.setPersistent(false);
        new Parameter(relation,""String_Node_Str"",BooleanToken.TRUE);
        port.liberalLink(relation);
        if (!subscriberPort.isLinked(relation)) {
          subscriberPort.liberalLink(relation);
          notifyConnectivityChange();
        }
      }
      if (container instanceof CompositeActor) {
        ((CompositeActor)container).linkToPublishedPort(pattern,(TypedIOPort)port,global);
      }
    }
  }
}"
73624,"/** 
 * Unlink the subscriberPort with a already registered ""published port"" coming from a publisher. The pattern is the pattern being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the  name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param pattern The pattern is being used in the matching processto match publisher and subscriber.
 * @param subscriberPort The subscribed port.
 * @param global Specification of whether the data is subscribedglobally.  If set to true, then subscribers will see values published by publishers anywhere in the model that reference the same channel by name.  If set to false, then only values published by publishers that are fired by the same director are seen by this subscriber.
 * @exception NameDuplicationException If there are name conflictsas a result of the added relations or ports. 
 * @exception IllegalActionException If the published port cannot be found.
 */
public void unlinkToPublishedPort(Pattern pattern,TypedIOPort subscriberPort,boolean global) throws IllegalActionException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).unlinkToPublishedPort(pattern,subscriberPort,global);
  }
 else {
    List connectedPorts=subscriberPort.connectedPortList();
    if (_publishedPorts != null) {
      for (      String name : _publishedPorts.keySet()) {
        Matcher matcher=pattern.matcher(name);
        if (matcher.matches()) {
          unlinkToPublishedPort(name,subscriberPort);
        }
      }
    }
    if (global && container instanceof CompositeActor) {
      for (      Object port : connectedPorts) {
        IOPort subscribedPort=(IOPort)port;
        if (subscribedPort.isOutput()) {
          ((CompositeActor)container).unlinkToPublishedPort(pattern,(TypedIOPort)subscribedPort,global);
          try {
            subscribedPort.setContainer(null);
          }
 catch (          NameDuplicationException ex) {
            throw new InternalErrorException(subscriberPort.getContainer(),ex,""String_Node_Str"");
          }
        }
      }
    }
  }
}","/** 
 * Unlink the subscriberPort with a already registered ""published port"" coming from a publisher. The pattern is the pattern being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the  name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param pattern The pattern is being used in the matching processto match publisher and subscriber.
 * @param subscriberPort The subscribed port.
 * @param global Specification of whether the data is subscribedglobally.  If set to true, then subscribers will see values published by publishers anywhere in the model that reference the same channel by name.  If set to false, then only values published by publishers that are fired by the same director are seen by this subscriber.
 * @exception NameDuplicationException If there are name conflictsas a result of the added relations or ports. 
 * @exception IllegalActionException If the published port cannot be found.
 */
public void unlinkToPublishedPort(Pattern pattern,TypedIOPort subscriberPort,boolean global) throws IllegalActionException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).unlinkToPublishedPort(pattern,subscriberPort,global);
  }
 else {
    if (_publishedPorts != null) {
      for (      String name : _publishedPorts.keySet()) {
        Matcher matcher=pattern.matcher(name);
        if (matcher.matches()) {
          unlinkToPublishedPort(name,subscriberPort);
        }
      }
    }
    for (    Object relationObj : subscriberPort.linkedRelationList()) {
      try {
        for (        Object port : ((IORelation)relationObj).linkedPortList(subscriberPort)) {
          IOPort subscribedPort=(IOPort)port;
          if (subscribedPort.isInput()) {
            ((CompositeActor)container).unlinkToPublishedPort(pattern,(TypedIOPort)subscribedPort,global);
            subscribedPort.setContainer(null);
          }
        }
        ((IORelation)relationObj).setContainer(null);
      }
 catch (      NameDuplicationException ex) {
        throw new InternalErrorException(subscriberPort.getContainer(),ex,""String_Node_Str"");
      }
    }
  }
}"
73625,"/** 
 * Override the base class to record the operation choice.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == operation) {
    String newValue=operation.stringValue();
    if (newValue.equals(""String_Node_Str"")) {
      _addOperation=true;
    }
 else {
      _addOperation=false;
    }
  }
 else   if (attribute == channel) {
    String newValue=channel.stringValue();
    if (!newValue.equals(_channel)) {
      NamedObj container=getContainer();
      if (container instanceof CompositeActor && !(_channel == null || _channel.trim().equals(""String_Node_Str""))) {
        ((CompositeActor)container).unlinkToPublishedPort(_channelPattern,input);
      }
      _channel=newValue;
      super.attributeChanged(attribute);
      _channelPattern=Pattern.compile(_channel);
    }
  }
 else   if (attribute == global) {
    _global=((BooleanToken)global.getToken()).booleanValue();
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * Override the base class to record the operation choice.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == operation) {
    String newValue=operation.stringValue();
    if (newValue.equals(""String_Node_Str"")) {
      _addOperation=true;
    }
 else {
      _addOperation=false;
    }
  }
 else   if (attribute == channel) {
    String newValue=channel.stringValue();
    if (!newValue.equals(_channel)) {
      NamedObj container=getContainer();
      if (container instanceof CompositeActor && !(_channel == null || _channel.trim().equals(""String_Node_Str""))) {
        ((CompositeActor)container).unlinkToPublishedPort(_channelPattern,input,_global);
      }
      _channel=newValue;
      super.attributeChanged(attribute);
      _channelPattern=Pattern.compile(_channel);
    }
  }
 else   if (attribute == global) {
    _global=((BooleanToken)global.getToken()).booleanValue();
  }
 else {
    super.attributeChanged(attribute);
  }
}"
73626,"/** 
 * Unregister a ""published port"" coming from a publisher. The name is the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the same name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param name The name is being used in the matching processto match publisher and subscriber. This will be the port that should be removed
 * @param publisherPort The publisher port.
 * @param global If true, unregister the port all the way up the hierarchy.
 * @throws NameDuplicationException 
 * @throws IllegalActionException 
 */
public void unregisterPublisherPort(String name,IOPort publisherPort,boolean global) throws IllegalActionException, NameDuplicationException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).unregisterPublisherPort(name,publisherPort);
  }
 else {
    if (_publishedPorts != null) {
      List<IOPort> ports=_publishedPorts.get(name);
      if (ports != null) {
        ports.remove(publisherPort);
        if (ports.isEmpty()) {
          _publishedPorts.remove(name);
        }
      }
    }
    if (_publisherRelations != null) {
      IORelation relation=_publisherRelations.get(name);
      if (relation != null) {
        if (global && container instanceof CompositeActor) {
          for (          Object port : relation.linkedPortList(publisherPort)) {
            IOPort publishedPort=(IOPort)port;
            if (publishedPort.isOutput()) {
              ((CompositeActor)container).unregisterPublisherPort(name,publishedPort,global);
              publishedPort.setContainer(null);
            }
          }
        }
        relation.setContainer(null);
        notifyConnectivityChange();
        _publisherRelations.remove(name);
      }
    }
  }
}","/** 
 * Unregister a ""published port"" coming from a publisher. The name is the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the same name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param name The name is being used in the matching processto match publisher and subscriber. This will be the port that should be removed
 * @param publisherPort The publisher port.
 * @param global If true, unregister the port all the way up the hierarchy.
 * @throws NameDuplicationException 
 * @throws IllegalActionException 
 */
public void unregisterPublisherPort(String name,IOPort publisherPort,boolean global) throws IllegalActionException, NameDuplicationException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).unregisterPublisherPort(name,publisherPort);
  }
 else {
    if (_publishedPorts != null) {
      List<IOPort> ports=_publishedPorts.get(name);
      if (ports != null) {
        ports.remove(publisherPort);
        if (ports.isEmpty()) {
          _publishedPorts.remove(name);
        }
      }
    }
    if (_publisherRelations != null) {
      IORelation relation=_publisherRelations.get(name);
      if (relation != null) {
        if (global && container instanceof CompositeActor) {
          for (          Object port : relation.linkedPortList(publisherPort)) {
            IOPort publishedPort=(IOPort)port;
            if (publishedPort.isOutput()) {
              ((CompositeActor)container).unregisterPublisherPort(name,publishedPort,global);
              publishedPort.setContainer(null);
            }
          }
        }
        relation.setContainer(null);
        _publisherRelations.remove(name);
      }
    }
  }
}"
73627,"/** 
 * Unlink the subscriberPort with a already registered ""published port"" coming from a publisher. The pattern is the pattern being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the  name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param pattern The pattern is being used in the matching processto match publisher and subscriber.
 * @param subscriberPort The subscribed port.
 * @param global Specification of whether the data is subscribedglobally.  If set to true, then subscribers will see values published by publishers anywhere in the model that reference the same channel by name.  If set to false, then only values published by publishers that are fired by the same director are seen by this subscriber.
 * @exception NameDuplicationException If there are name conflictsas a result of the added relations or ports. 
 * @exception IllegalActionException If the published port cannot be found.
 */
public void unlinkToPublishedPort(Pattern pattern,TypedIOPort subscriberPort,boolean global) throws IllegalActionException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).unlinkToPublishedPort(pattern,subscriberPort,global);
  }
 else {
    if (_publishedPorts != null) {
      for (      String name : _publishedPorts.keySet()) {
        Matcher matcher=pattern.matcher(name);
        if (matcher.matches()) {
          unlinkToPublishedPort(name,subscriberPort);
        }
      }
    }
    for (    Object relationObj : subscriberPort.linkedRelationList()) {
      try {
        for (        Object port : ((IORelation)relationObj).linkedPortList(subscriberPort)) {
          IOPort subscribedPort=(IOPort)port;
          if (subscribedPort.isInput()) {
            ((CompositeActor)container).unlinkToPublishedPort(pattern,(TypedIOPort)subscribedPort,global);
            subscribedPort.setContainer(null);
          }
        }
        ((IORelation)relationObj).setContainer(null);
      }
 catch (      NameDuplicationException ex) {
        throw new InternalErrorException(subscriberPort.getContainer(),ex,""String_Node_Str"");
      }
    }
  }
}","/** 
 * Unlink the subscriberPort with a already registered ""published port"" coming from a publisher. The pattern is the pattern being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the  name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param pattern The pattern is being used in the matching processto match publisher and subscriber.
 * @param subscriberPort The subscribed port.
 * @param global Specification of whether the data is subscribedglobally.  If set to true, then subscribers will see values published by publishers anywhere in the model that reference the same channel by name.  If set to false, then only values published by publishers that are fired by the same director are seen by this subscriber.
 * @exception NameDuplicationException If there are name conflictsas a result of the added relations or ports. 
 * @exception IllegalActionException If the published port cannot be found.
 */
public void unlinkToPublishedPort(Pattern pattern,TypedIOPort subscriberPort,boolean global) throws IllegalActionException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).unlinkToPublishedPort(pattern,subscriberPort,global);
  }
 else {
    if (_publishedPorts != null) {
      for (      String name : _publishedPorts.keySet()) {
        Matcher matcher=pattern.matcher(name);
        if (matcher.matches()) {
          unlinkToPublishedPort(name,subscriberPort);
        }
      }
    }
    for (    Object relationObj : subscriberPort.linkedRelationList()) {
      try {
        for (        Object port : ((IORelation)relationObj).linkedPortList(subscriberPort)) {
          IOPort subscribedPort=(IOPort)port;
          if (subscribedPort.isInput()) {
            Set connectedInsidePort=new HashSet(subscribedPort.insidePortList());
            connectedInsidePort.remove(subscriberPort);
            if (connectedInsidePort.size() == 0) {
              ((CompositeActor)container).unlinkToPublishedPort(pattern,(TypedIOPort)subscribedPort,global);
              subscribedPort.setContainer(null);
            }
          }
        }
        ((IORelation)relationObj).setContainer(null);
      }
 catch (      NameDuplicationException ex) {
        throw new InternalErrorException(subscriberPort.getContainer(),ex,""String_Node_Str"");
      }
    }
  }
}"
73628,"/** 
 * Generate variable initialization for the referenced parameters.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableInitialization() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=(CompositeActor)_director.getContainer();
  GenericCodeGenerator codeGenerator=getCodeGenerator();
{
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(container);
    code.append(_generateVariableInitialization(adapterObject));
  }
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    code.append(_generateVariableInitialization(adapterObject));
  }
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    if (actor instanceof ModularCodeGenTypedCompositeActor || actor instanceof ModularCompiledSDFTypedCompositeActor) {
      String className=NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor);
      String actorName=ModularCodeGenTypedCompositeActor.classToActorName(className);
      code.append(actorName + ""String_Node_Str"" + className+ ""String_Node_Str""+ _eol);
      code.append(actorName + ""String_Node_Str"" + _eol);
    }
  }
  return code.toString();
}","/** 
 * Generate variable initialization for the referenced parameters.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableInitialization() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=(CompositeActor)_director.getContainer();
  GenericCodeGenerator codeGenerator=getCodeGenerator();
{
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(container);
    code.append(_generateVariableInitialization(adapterObject));
  }
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    code.append(_generateVariableInitialization(adapterObject));
  }
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    if (actor instanceof ModularCodeGenTypedCompositeActor || actor instanceof ModularCompiledSDFTypedCompositeActor) {
      String className=NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor);
      String actorName=ModularCodeGenTypedCompositeActor.classToActorName(className);
      code.append(actorName + ""String_Node_Str"" + className+ ""String_Node_Str""+ _eol);
      code.append(actorName + ""String_Node_Str"" + _eol);
    }
 else {
      NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
      code.append(adapterObject.generateVariableInitialization());
    }
  }
  return code.toString();
}"
73629,"/** 
 * Generate variable declarations for inputs and outputs and parameters. Append the declarations to the given string buffer.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableDeclaration() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=(CompositeActor)_director.getContainer();
  GenericCodeGenerator codeGenerator=getCodeGenerator();
{
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(container);
    code.append(_generateVariableDeclaration(adapterObject));
  }
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    if (actor instanceof CompositeActor) {
      code.append(adapterObject.generateVariableDeclaration());
    }
 else {
      code.append(_generateVariableDeclaration(adapterObject));
    }
  }
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    if (actor instanceof ModularCodeGenTypedCompositeActor || actor instanceof ModularCompiledSDFTypedCompositeActor) {
      String className=NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor);
      String actorName=ModularCodeGenTypedCompositeActor.classToActorName(className);
      code.append(className + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ _eol);
    }
  }
  return code.toString();
}","/** 
 * Generate variable declarations for inputs and outputs and parameters. Append the declarations to the given string buffer.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableDeclaration() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=(CompositeActor)_director.getContainer();
  GenericCodeGenerator codeGenerator=getCodeGenerator();
{
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(container);
    code.append(_generateVariableDeclaration(adapterObject));
  }
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    if (actor instanceof CompositeActor && !(actor instanceof ModularCodeGenTypedCompositeActor)) {
      code.append(adapterObject.generateVariableDeclaration());
    }
 else {
      code.append(_generateVariableDeclaration(adapterObject));
    }
  }
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    if (actor instanceof ModularCodeGenTypedCompositeActor || actor instanceof ModularCompiledSDFTypedCompositeActor) {
      String className=NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor);
      String actorName=ModularCodeGenTypedCompositeActor.classToActorName(className);
      code.append(className + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ _eol);
    }
  }
  return code.toString();
}"
73630,"/** 
 * Parse the specified command-line arguments, instanting classes and reading files that are specified.
 * @param basePath The basePath to look for configurationsin, usually ""ptolemy/configs"", but other tools might have other configurations in other directories
 * @param args The command-line arguments.
 * @exception Exception If command line arguments have problems.
 */
public MoMLApplication(String basePath,String[] args) throws Exception {
  super(basePath,args);
  MessageHandler.setMessageHandler(new GraphicalMessageHandler());
}","/** 
 * Parse the specified command-line arguments, instanting classes and reading files that are specified.
 * @param basePath The basePath to look for configurationsin, usually ""ptolemy/configs"", but other tools might have other configurations in other directories
 * @param args The command-line arguments.
 * @exception Exception If command line arguments have problems.
 */
public MoMLApplication(String basePath,String[] args) throws Exception {
  super(basePath,args);
  MessageHandler.setMessageHandler(new ActorGraphicalMessageHandler());
}"
73631,"/** 
 * Execute the given task to update the referenced version for the given  parents from the old model to the new model. 
 * @param task Task that contains the list of parents, the old model and the new model.
 * @throws DBExecutionException If thrown while updating the parents in the database.
 */
public void executeUpdateParentsToNewVersion(UpdateParentsToNewVersionTask task) throws DBExecutionException {
  if (task.getNewModel() == null || task.getOldModel() == null || task.getParentsList() == null) {
    throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  String newModelId=task.getNewModel().getModelId();
  String newModelName=task.getNewModel().getModelName();
  if (newModelId == null || newModelId.length() == 0) {
    newModelId=_getModelIdFromModelName(newModelName);
  }
  String oldModelId=task.getOldModel().getModelId();
  String oldModelName=task.getOldModel().getModelName();
  if (oldModelId == null || oldModelId.length() == 0) {
    oldModelId=_getModelIdFromModelName(oldModelName);
  }
  String propertyString=Utilities.getPropertyString(XMLDBModel.DB_MODEL_ID_ATTR,newModelId);
  for (  String parentName : task.getParentsList()) {
    String parentsQuery=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ parentName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ XMLDBModel.DB_REFERENCE_ATTR+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ XMLDBModel.DB_MODEL_ID_ATTR+ ""String_Node_Str""+ ""String_Node_Str""+ oldModelId+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ propertyString;
    try {
      XmlQueryContext xmlQueryContext=_xmlManager.createQueryContext();
      _xmlManager.query(_xmlTransaction,parentsQuery,xmlQueryContext,null);
    }
 catch (    XmlException e) {
      throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
    String referenceString=_getModelReferences(newModelId);
    String referenceFileQuery=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ ""String_Node_Str""+ parentName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ oldModelName+ ""String_Node_Str""+ referenceString;
    try {
      XmlQueryContext xmlQueryContext=_xmlManager.createQueryContext();
      _xmlManager.query(_xmlTransaction,referenceFileQuery,xmlQueryContext,null);
    }
 catch (    XmlException e) {
      throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
}","/** 
 * Execute the given task to update the referenced version for the given  parents from the old model to the new model. 
 * @param task Task that contains the list of parents, the old model and the new model.
 * @throws DBExecutionException If thrown while updating the parents in the database.
 */
public void executeUpdateParentsToNewVersion(UpdateParentsToNewVersionTask task) throws DBExecutionException {
  if (task.getNewModel() == null || task.getOldModel() == null || task.getParentsList() == null) {
    throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  String newModelId=task.getNewModel().getModelId();
  String newModelName=task.getNewModel().getModelName();
  if (newModelId == null || newModelId.length() == 0) {
    newModelId=_getModelIdFromModelName(newModelName);
  }
  String oldModelId=task.getOldModel().getModelId();
  String oldModelName=task.getOldModel().getModelName();
  if (oldModelId == null || oldModelId.length() == 0) {
    oldModelId=_getModelIdFromModelName(oldModelName);
  }
  for (  String parentName : task.getParentsList()) {
    GetModelTask getModelTask=new GetModelTask(parentName);
    XmlDocument parentModelDoc=_getModelFromDB(getModelTask);
    String parentModelContent;
    try {
      parentModelContent=parentModelDoc.getContentAsString();
    }
 catch (    XmlException e1) {
      throw new DBExecutionException(""String_Node_Str"" + parentName);
    }
    parentModelContent=parentModelContent.replaceAll(""String_Node_Str"" + oldModelId + ""String_Node_Str"",""String_Node_Str"" + newModelId + ""String_Node_Str"");
    XMLDBModel parentModel=new XMLDBModel(parentName);
    parentModel.setModel(parentModelContent);
    executeUpdateModelInCache(parentModel);
    String referenceString=_getModelReferences(newModelId);
    String referenceFileQuery=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ ""String_Node_Str""+ parentName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ oldModelName+ ""String_Node_Str""+ referenceString;
    try {
      XmlQueryContext xmlQueryContext=_xmlManager.createQueryContext();
      _xmlManager.query(_xmlTransaction,referenceFileQuery,xmlQueryContext,null);
    }
 catch (    XmlException e) {
      throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
}"
73632,"/** 
 * Get the model name for the given model id.  
 * @param modelId Model If for which the model name is required. 
 * @return Model name for the given model id, null if not found.
 * @throws XmlException
 */
private String _getModelNameFromModelId(String modelId) throws XmlException {
  String modelName=null;
  String query=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ ""String_Node_Str""+ modelId+ ""String_Node_Str""+ ""String_Node_Str"";
  XmlQueryContext context=_xmlManager.createQueryContext();
  XmlResults results=_xmlManager.query(query,context,null);
  if (results != null) {
    XmlValue value;
    while (results.hasNext()) {
      value=results.next();
      modelName=value.asString();
      modelName=modelId.substring(modelId.lastIndexOf('/') + 1);
    }
  }
  return modelName;
}","/** 
 * Get the model name for the given model id.  
 * @param modelId Model If for which the model name is required. 
 * @return Model name for the given model id, null if not found.
 * @throws XmlException
 */
private String _getModelNameFromModelId(String modelId) throws XmlException {
  String modelName=null;
  String query=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ ""String_Node_Str""+ modelId+ ""String_Node_Str""+ ""String_Node_Str"";
  XmlQueryContext context=_xmlManager.createQueryContext();
  XmlResults results=_xmlManager.query(query,context,null);
  if (results != null) {
    XmlValue value;
    while (results.hasNext()) {
      value=results.next();
      modelName=value.asString();
      modelName=modelName.substring(modelName.lastIndexOf('/') + 1);
    }
  }
  return modelName;
}"
73633,"/** 
 * Construct the rename model frame. 
 * @param model The model to be renamed. 
 * @param sourceFrame The source frame from which opened this frame.
 */
public RenameModelFrame(NamedObj model,ActorGraphDBFrame sourceFrame){
  super(""String_Node_Str"");
  setDefaultCloseOperation(DISPOSE_ON_CLOSE);
  _model=model;
  _sourceFrame=sourceFrame;
  addWindowListener(new WindowListener(){
    @Override public void windowOpened(    WindowEvent e){
      _sourceFrame.setEnabled(false);
    }
    @Override public void windowIconified(    WindowEvent e){
    }
    @Override public void windowDeiconified(    WindowEvent e){
    }
    @Override public void windowDeactivated(    WindowEvent e){
    }
    @Override public void windowClosing(    WindowEvent e){
      _sourceFrame.setEnabled(true);
    }
    @Override public void windowClosed(    WindowEvent e){
      _sourceFrame.setEnabled(true);
    }
    @Override public void windowActivated(    WindowEvent e){
    }
  }
);
  setLayout(new BoxLayout(this.getContentPane(),BoxLayout.Y_AXIS));
  _topPanel=new JPanel();
  _bottomPanel=new JPanel();
  JLabel newNameLabel=new JLabel(""String_Node_Str"");
  newNameLabel.setAlignmentX(LEFT_ALIGNMENT);
  _topPanel.setAlignmentX(CENTER_ALIGNMENT);
  _bottomPanel.setAlignmentX(CENTER_ALIGNMENT);
  _topPanel.setAlignmentY(TOP_ALIGNMENT);
  _bottomPanel.setAlignmentY(TOP_ALIGNMENT);
  _topPanel.setBorder(BorderFactory.createEmptyBorder());
  _newNameTextField=new JTextField();
  _newNameTextField.setPreferredSize(new Dimension(100,20));
  _closeButton=new JButton(""String_Node_Str"");
  _updateButton=new JButton(""String_Node_Str"");
  _updateButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      try {
        _update();
      }
 catch (      IllegalNameException e1) {
        JOptionPane.showMessageDialog(RenameModelFrame.this,e1.getMessage());
      }
    }
  }
);
  _updateButton.setMnemonic(KeyEvent.VK_ENTER);
  _closeButton.setMnemonic(KeyEvent.VK_ESCAPE);
  _updateButton.setActionCommand(""String_Node_Str"");
  _closeButton.setActionCommand(""String_Node_Str"");
  _updateButton.setHorizontalTextPosition(SwingConstants.CENTER);
  _closeButton.setHorizontalTextPosition(SwingConstants.CENTER);
  _closeButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      dispose();
    }
  }
);
  _topPanel.add(newNameLabel);
  _topPanel.add(_newNameTextField);
  _bottomPanel.add(_updateButton);
  _bottomPanel.add(_closeButton);
  add(_topPanel);
  add(_bottomPanel);
  setResizable(false);
  validate();
  repaint();
}","/** 
 * Construct the rename model frame. 
 * @param model The model to be renamed. 
 * @param sourceFrame The source frame from which opened this frame.
 */
public RenameModelFrame(NamedObj model,ActorGraphDBFrame sourceFrame){
  super(""String_Node_Str"");
  setDefaultCloseOperation(DISPOSE_ON_CLOSE);
  _model=model;
  _sourceFrame=sourceFrame;
  addWindowListener(new WindowListener(){
    @Override public void windowOpened(    WindowEvent e){
      _sourceFrame.setEnabled(false);
    }
    @Override public void windowIconified(    WindowEvent e){
    }
    @Override public void windowDeiconified(    WindowEvent e){
    }
    @Override public void windowDeactivated(    WindowEvent e){
    }
    @Override public void windowClosing(    WindowEvent e){
    }
    @Override public void windowClosed(    WindowEvent e){
      _sourceFrame.setEnabled(true);
      _sourceFrame.toFront();
    }
    @Override public void windowActivated(    WindowEvent e){
    }
  }
);
  setLayout(new BoxLayout(this.getContentPane(),BoxLayout.Y_AXIS));
  _topPanel=new JPanel();
  _bottomPanel=new JPanel();
  JLabel newNameLabel=new JLabel(""String_Node_Str"");
  newNameLabel.setAlignmentX(LEFT_ALIGNMENT);
  _topPanel.setAlignmentX(CENTER_ALIGNMENT);
  _bottomPanel.setAlignmentX(CENTER_ALIGNMENT);
  _topPanel.setAlignmentY(TOP_ALIGNMENT);
  _bottomPanel.setAlignmentY(TOP_ALIGNMENT);
  _topPanel.setBorder(BorderFactory.createEmptyBorder());
  _newNameTextField=new JTextField();
  _newNameTextField.setPreferredSize(new Dimension(100,20));
  _closeButton=new JButton(""String_Node_Str"");
  _updateButton=new JButton(""String_Node_Str"");
  _updateButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      try {
        _update();
      }
 catch (      IllegalNameException e1) {
        JOptionPane.showMessageDialog(RenameModelFrame.this,e1.getMessage());
      }
    }
  }
);
  _updateButton.setMnemonic(KeyEvent.VK_ENTER);
  _closeButton.setMnemonic(KeyEvent.VK_ESCAPE);
  _updateButton.setActionCommand(""String_Node_Str"");
  _closeButton.setActionCommand(""String_Node_Str"");
  _updateButton.setHorizontalTextPosition(SwingConstants.CENTER);
  _closeButton.setHorizontalTextPosition(SwingConstants.CENTER);
  _closeButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      dispose();
    }
  }
);
  _topPanel.add(newNameLabel);
  _topPanel.add(_newNameTextField);
  _bottomPanel.add(_updateButton);
  _bottomPanel.add(_closeButton);
  add(_topPanel);
  add(_bottomPanel);
  setResizable(false);
  validate();
  repaint();
}"
73634,"@Override public void windowClosed(WindowEvent e){
  _sourceFrame.setEnabled(true);
}","@Override public void windowClosed(WindowEvent e){
  _sourceFrame.setEnabled(true);
  _sourceFrame.toFront();
}"
73635,"@Override public void windowClosing(WindowEvent e){
  _sourceFrame.setEnabled(true);
}","@Override public void windowClosing(WindowEvent e){
}"
73636,"public void add(Concept x1,Concept x2){
  _counterexamples.put(x1,x2);
}","public void add(Concept x1,Concept x2){
  _counterexamples.remove(x1,x2);
  _counterexamples.put(x1,x2);
}"
73637,"/** 
 * Return the monotonicity of the conditional being analyzed given a few extra assumptions.  The if statement must be of the form: (x <= c) ? e1 : e2 where both e1 and e2 are montonic, and c is a constant. If these assumptions are not met, this function may return an unsound analysis. Note that this function performs an analysis that is approximately equivalent to the ifc analysis of ""Static Monotonicity Analysis for lambda-definable Functions over Lattices"" (Murawski and Yi, 2002), except that that analysis is unsound.  This analysis is a corrected form of that one.
 * @param constant The constant c.
 * @return Monotonic, if the function is monotonic.Nonmonotonic, otherwise.
 * @exception IllegalActionException If there is a problemevaluating the subexpressions of the conditional.
 */
private Concept _specialIfAnalysis(Concept constant) throws IllegalActionException {
  MonotonicityCounterexamples toCheck=_nodeToCounterexamples.get(_ifNode.jjtGetChild(2));
  if (toCheck == null) {
    toCheck=new MonotonicityCounterexamples();
  }
  ConceptGraph inputLattice=_domainOntology.getGraph();
  List downsetList=Arrays.asList(inputLattice.downSet(constant));
  List<Concept> downset=(List<Concept>)downsetList;
  for (  Concept b : downset) {
    for (    Concept d : b.getStrictDominators()) {
      if (downset.contains(d)) {
        continue;
      }
      toCheck.add(b,d);
    }
  }
  MonotonicityCounterexamples counterexamples=new MonotonicityCounterexamples();
  for (  MonotonicityCounterexamples.ConceptPair pair : toCheck.entrySet()) {
    Concept fb=_evaluateChild(1,pair.getKey());
    Concept fd=_evaluateChild(2,pair.getValue());
    if (!fd.isAboveOrEqualTo(fb)) {
      counterexamples.add(pair.getKey(),pair.getValue());
    }
  }
  if (counterexamples.containsCounterexamples()) {
    _nodeToCounterexamples.put(_ifNode,counterexamples);
    return _nonmonotonicConcept;
  }
 else {
    return _monotonicConcept;
  }
}","/** 
 * Return the monotonicity of the conditional being analyzed given a few extra assumptions.  The if statement must be of the form: (x <= c) ? e1 : e2 where both e1 and e2 are montonic, and c is a constant. If these assumptions are not met, this function may return an unsound analysis. Note that this function performs an analysis that is approximately equivalent to the ifc analysis of ""Static Monotonicity Analysis for lambda-definable Functions over Lattices"" (Murawski and Yi, 2002), except that that analysis is unsound.  This analysis is a corrected form of that one.
 * @param constant The constant c.
 * @return Monotonic, if the function is monotonic.Nonmonotonic, otherwise.
 * @exception IllegalActionException If there is a problemevaluating the subexpressions of the conditional.
 */
private Concept _specialIfAnalysis(Concept constant) throws IllegalActionException {
  MonotonicityCounterexamples toCheck=_nodeToCounterexamples.get(_ifNode.jjtGetChild(2));
  if (toCheck == null) {
    toCheck=new MonotonicityCounterexamples();
  }
  ConceptGraph inputLattice=_domainOntology.getGraph();
  List downsetList=Arrays.asList(inputLattice.downSet(constant));
  List<Concept> downset=(List<Concept>)downsetList;
  for (  Concept b : downset) {
    for (    Concept d : b.getStrictDominators()) {
      if (downset.contains(d)) {
        continue;
      }
      toCheck.add(b,d);
    }
  }
  MonotonicityCounterexamples counterexamples=new MonotonicityCounterexamples();
  for (  MonotonicityCounterexamples.ConceptPair pair : toCheck.entrySet()) {
    Concept fb=_evaluateNode(_ifNode,pair.getKey());
    Concept fd=_evaluateNode(_ifNode,pair.getValue());
    if (!fd.isAboveOrEqualTo(fb)) {
      counterexamples.add(pair.getKey(),pair.getValue());
    }
  }
  if (counterexamples.containsCounterexamples()) {
    _nodeToCounterexamples.put(_ifNode,counterexamples);
    return _nonmonotonicConcept;
  }
 else {
    return _monotonicConcept;
  }
}"
73638,"/** 
 * Evaluate a branch of the if statement pointed to by _ifNode and return the result.
 * @param childNumber 1 for the then branch, and 2 for theelse branch.
 * @param xValue The value of the variable ""x"" during evaluation.
 * @return The concept that the given child evaluates to.
 * @exception IllegalActionException If there is a problem whileevaluating the parse tree, or an invalid childNumber is passed.
 */
private Concept _evaluateChild(int childNumber,Concept xValue) throws IllegalActionException {
  ptolemy.data.expr.ASTPtRootNode childNode=(ptolemy.data.expr.ASTPtRootNode)_ifNode.jjtGetChild(childNumber);
  List<String> argumentNames=new LinkedList<String>();
  argumentNames.add(""String_Node_Str"");
  List<Concept> argumentValues=new LinkedList<Concept>();
  argumentValues.add(xValue);
  List<Ontology> argumentDomains=new LinkedList<Ontology>();
  argumentDomains.add(_domainOntology);
  ParseTreeEvaluator evaluator=new ExpressionConceptFunctionParseTreeEvaluator(argumentNames,argumentValues,null,argumentDomains);
  ConceptToken evaluatedToken=(ConceptToken)evaluator.evaluateParseTree(childNode);
  return evaluatedToken.conceptValue();
}","/** 
 * Evaluate a branch of the if statement pointed to by _ifNode and return the result.
 * @param childNumber 1 for the then branch, and 2 for theelse branch.
 * @param xValue The value of the variable ""x"" during evaluation.
 * @return The concept that the given child evaluates to.
 * @exception IllegalActionException If there is a problem whileevaluating the parse tree, or an invalid childNumber is passed.
 */
private Concept _evaluateChild(int childNumber,Concept xValue) throws IllegalActionException {
  ptolemy.data.expr.ASTPtRootNode childNode=(ptolemy.data.expr.ASTPtRootNode)_ifNode.jjtGetChild(childNumber);
  return _evaluateNode(childNode,xValue);
}"
73639,"/** 
 * Save the model to the database, together with the references changes  to its parent models. 
 * @param isNew Whether this is a new model. 
 * @param id The id of this model. 
 * @param parentsMaintainOldVersion The list of parents names that do not want to reflect the changes to the submodel they have.  
 * @param newVersionName The new name of this saving model, to have those parent models maintaining the old reference.
 * @throws Exception Thrown if errors occur during the saving. 
 */
private void _commitSave(boolean isNew,String id,ArrayList<String> parentsMaintainOldVersion,String newVersionName) throws Exception {
  String newName=_attributesListPanel.getModelName();
  _modelToSave.setName(newName);
  _updateDisplayedModel();
  if (isNew || id == null) {
    if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) != null) {
      _modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR).setContainer(null);
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
      }
 catch (      Exception e) {
        _resetValues();
        throw e;
      }
    }
  }
  if (_xmlModel == null) {
    _xmlModel=new XMLDBModel(_modelToSave.getName());
  }
  _xmlModel.setModelName(_modelToSave.getName());
  _xmlModel.setModel(_modelToSave.exportMoML());
  _xmlModel.setIsNew(isNew);
  _xmlModel.setModelId(id);
  XMLDBModelWithReferenceChanges xmlDBModelWithReferenceChanges=new XMLDBModelWithReferenceChanges(_xmlModel,parentsMaintainOldVersion,newVersionName);
  try {
    String modelId=_saveModelManager.saveWithParents(xmlDBModelWithReferenceChanges);
    if (modelId != null) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) == null) {
        StringConstantParameter dbModelParam=new StringConstantParameter(_modelToSave,XMLDBModel.DB_MODEL_ID_ATTR);
        dbModelParam.setExpression(modelId);
        dbModelParam.setContainer(_modelToSave);
      }
 else       if (!((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).getExpression().equals(modelId)) {
        ((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).setExpression(modelId);
      }
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
        _source.setTitle(_xmlModel.getModelName());
        try {
          _source.updateDBModelHistory(_xmlModel.getModelName(),false);
        }
 catch (        IOException e) {
        }
      }
 catch (      Exception e) {
        throw e;
      }
      if (parentsMaintainOldVersion != null && parentsMaintainOldVersion.size() > 0) {
        XMLDBModel newVersionModel=DBModelFetcher.load(newVersionName);
        for (        String parentName : parentsMaintainOldVersion) {
          if (_source.getConfiguration().getDirectory().getEntity(parentName) != null) {
            PtolemyEffigy parentModelEffigy=(PtolemyEffigy)_source.getConfiguration().getDirectory().getEffigy(parentName);
            for (            Object entity : parentModelEffigy.entityList()) {
              ComponentEntity componentEntity=(ComponentEntity)entity;
              if (Utilities.getIdFromModel(componentEntity) != null && Utilities.getIdFromModel(componentEntity).equals(modelId)) {
                StringParameter modelIdAttribute=(StringParameter)componentEntity.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR);
                modelIdAttribute.setToken(newVersionModel.getModelId());
                componentEntity.setName(parentModelEffigy.uniqueName(newVersionModel.getModelName()));
              }
            }
            MoMLChangeRequest change=new MoMLChangeRequest(null,parentModelEffigy.getModel(),parentModelEffigy.getModel().exportMoML());
            change.setUndoable(true);
            parentModelEffigy.getModel().requestChange(change);
          }
        }
      }
      if (_parentValidateFrame != null) {
        ArrayList<String> parentsModelsMaintainReferences=_parentValidateFrame._getParentsMaintainReferences();
        if (parentsModelsMaintainReferences != null && parentsModelsMaintainReferences.size() > 0) {
          XMLDBModel savedModel=DBModelFetcher.loadUsingId(modelId);
          for (          String parentName : parentsModelsMaintainReferences) {
            if (_source.getConfiguration().getDirectory().getEntity(parentName) != null) {
              PtolemyEffigy parentModelEffigy=(PtolemyEffigy)_source.getConfiguration().getDirectory().getEffigy(parentName);
              for (              Object entity : parentModelEffigy.entityList()) {
                ComponentEntity componentEntity=(ComponentEntity)entity;
                if (Utilities.getIdFromModel(componentEntity) != null && Utilities.getIdFromModel(componentEntity).equals(modelId)) {
                  MoMLChangeRequest change=new MoMLChangeRequest(null,componentEntity,savedModel.getModel());
                  change.setUndoable(true);
                  componentEntity.requestChange(change);
                }
              }
              MoMLChangeRequest change=new MoMLChangeRequest(null,parentModelEffigy.getModel(),parentModelEffigy.getModel().exportMoML());
              change.setUndoable(true);
              parentModelEffigy.getModel().requestChange(change);
            }
          }
        }
      }
      _source.setModified(false);
      if (_parentValidateFrame != null) {
        _parentValidateFrame.dispose();
      }
      dispose();
    }
 else {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    }
  }
 catch (  DBConnectionException exception) {
    _resetValues();
    throw exception;
  }
catch (  DBExecutionException exception) {
    _resetValues();
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    _resetValues();
    throw exception;
  }
catch (  ModelAlreadyExistException exception) {
    _resetValues();
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    _rollbackModel();
  }
}","/** 
 * Save the model to the database, together with the references changes  to its parent models. 
 * @param isNew Whether this is a new model. 
 * @param id The id of this model. 
 * @param parentsMaintainOldVersion The list of parents names that do not want to reflect the changes to the submodel they have.  
 * @param newVersionName The new name of this saving model, to have those parent models maintaining the old reference.
 * @throws Exception Thrown if errors occur during the saving. 
 */
private void _commitSave(boolean isNew,String id,ArrayList<String> parentsMaintainOldVersion,String newVersionName) throws Exception {
  String newName=_attributesListPanel.getModelName();
  _modelToSave.setName(newName);
  _updateDisplayedModel();
  if (isNew || id == null) {
    if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) != null) {
      _modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR).setContainer(null);
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
      }
 catch (      Exception e) {
        _resetValues();
        throw e;
      }
    }
  }
  if (_xmlModel == null) {
    _xmlModel=new XMLDBModel(_modelToSave.getName());
  }
  _xmlModel.setModelName(_modelToSave.getName());
  _xmlModel.setModel(_modelToSave.exportMoML());
  _xmlModel.setIsNew(isNew);
  _xmlModel.setModelId(id);
  XMLDBModelWithReferenceChanges xmlDBModelWithReferenceChanges=new XMLDBModelWithReferenceChanges(_xmlModel,parentsMaintainOldVersion,newVersionName);
  try {
    String modelId=_saveModelManager.saveWithParents(xmlDBModelWithReferenceChanges);
    if (modelId != null) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) == null) {
        StringConstantParameter dbModelParam=new StringConstantParameter(_modelToSave,XMLDBModel.DB_MODEL_ID_ATTR);
        dbModelParam.setExpression(modelId);
        dbModelParam.setContainer(_modelToSave);
      }
 else       if (!((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).getExpression().equals(modelId)) {
        ((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).setExpression(modelId);
      }
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
        _source.setTitle(_xmlModel.getModelName());
        try {
          _source.updateDBModelHistory(_xmlModel.getModelName(),false);
        }
 catch (        IOException e) {
        }
      }
 catch (      Exception e) {
        throw e;
      }
      if (parentsMaintainOldVersion != null && parentsMaintainOldVersion.size() > 0) {
        XMLDBModel newVersionModel=DBModelFetcher.load(newVersionName);
        for (        String parentName : parentsMaintainOldVersion) {
          if (_source.getConfiguration().getDirectory().getEntity(parentName) != null) {
            PtolemyEffigy parentModelEffigy=(PtolemyEffigy)_source.getConfiguration().getDirectory().getEffigy(parentName);
            boolean modifiedFlag=parentModelEffigy.isModified();
            for (            Object entity : ((CompositeEntity)parentModelEffigy.getModel()).entityList()) {
              ComponentEntity componentEntity=(ComponentEntity)entity;
              if (Utilities.getIdFromModel(componentEntity) != null && Utilities.getIdFromModel(componentEntity).equals(modelId)) {
                StringParameter modelIdAttribute=(StringParameter)componentEntity.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR);
                modelIdAttribute.setExpression(newVersionModel.getModelId());
                componentEntity.setName(parentModelEffigy.getModel().uniqueName(newVersionModel.getModelName()));
                String momlString=componentEntity.exportMoML();
                if (componentEntity instanceof CompositeEntity) {
                  CompositeEntity compositeEntity=(CompositeEntity)componentEntity;
                  compositeEntity.removeAllEntities();
                }
                MoMLChangeRequest change=new MoMLChangeRequest(null,parentModelEffigy.getModel(),momlString);
                change.setUndoable(true);
                parentModelEffigy.getModel().requestChange(change);
              }
            }
            if (!modifiedFlag) {
              parentModelEffigy.setModified(false);
            }
          }
        }
      }
      if (_parentValidateFrame != null) {
        ArrayList<String> parentsModelsMaintainReferences=_parentValidateFrame._getParentsMaintainReferences();
        if (parentsModelsMaintainReferences != null && parentsModelsMaintainReferences.size() > 0) {
          XMLDBModel savedModel=DBModelFetcher.loadUsingId(modelId);
          MoMLParser parser=new MoMLParser();
          parser.resetAll();
          Entity savedSubModel=(Entity)parser.parse(savedModel.getModel());
          StringParameter referenceAttribute=null;
          if (savedSubModel.getAttribute(XMLDBModel.DB_REFERENCE_ATTR) != null) {
            referenceAttribute=(StringParameter)savedSubModel.getAttribute(XMLDBModel.DB_REFERENCE_ATTR);
          }
 else {
            referenceAttribute=new StringParameter(savedSubModel,XMLDBModel.DB_REFERENCE_ATTR);
          }
          referenceAttribute.setExpression(""String_Node_Str"");
          for (          String parentName : parentsModelsMaintainReferences) {
            if (_source.getConfiguration().getDirectory().getEntity(parentName) != null) {
              PtolemyEffigy parentModelEffigy=(PtolemyEffigy)_source.getConfiguration().getDirectory().getEffigy(parentName);
              boolean modifiedFlag=parentModelEffigy.isModified();
              for (              Object entity : ((CompositeEntity)parentModelEffigy.getModel()).entityList()) {
                ComponentEntity componentEntity=(ComponentEntity)entity;
                if (Utilities.getIdFromModel(componentEntity) != null && Utilities.getIdFromModel(componentEntity).equals(modelId)) {
                  savedSubModel.setName(componentEntity.getName());
                  Location location=(Location)savedSubModel.getAttribute(""String_Node_Str"");
                  if (location == null) {
                    location=new Location(savedSubModel,""String_Node_Str"");
                  }
                  location.setExpression(((Location)componentEntity.getAttribute(""String_Node_Str"")).getExpression());
                  String newMoml=savedSubModel.exportMoML();
                  if (componentEntity instanceof CompositeEntity) {
                    CompositeEntity compositeEntity=(CompositeEntity)componentEntity;
                    compositeEntity.removeAllEntities();
                  }
                  MoMLChangeRequest change=new MoMLChangeRequest(null,parentModelEffigy.getModel(),newMoml);
                  change.setUndoable(true);
                  parentModelEffigy.getModel().requestChange(change);
                }
              }
              if (!modifiedFlag) {
                parentModelEffigy.setModified(false);
              }
            }
          }
        }
      }
      _source.setModified(false);
      if (_parentValidateFrame != null) {
        _parentValidateFrame.dispose();
      }
      dispose();
    }
 else {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    }
  }
 catch (  DBConnectionException exception) {
    _resetValues();
    throw exception;
  }
catch (  DBExecutionException exception) {
    _resetValues();
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    _resetValues();
    throw exception;
  }
catch (  ModelAlreadyExistException exception) {
    _resetValues();
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    _rollbackModel();
  }
}"
73640,"/** 
 * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
 */
private void initComponents(){
  _jLabel1=new javax.swing.JLabel();
  _jLabel2=new javax.swing.JLabel();
  _directoryPathTextField=new javax.swing.JTextField();
  _browseButton=new javax.swing.JButton();
  _migrateButton=new javax.swing.JButton();
  _doneButton=new javax.swing.JButton();
  _resultsTextField=new javax.swing.JTextField();
  _jLabel3=new javax.swing.JLabel();
  _jLabel4=new javax.swing.JLabel();
  _jLabel5=new javax.swing.JLabel();
  _allSubDirectoriesCheckBox=new javax.swing.JCheckBox();
  setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
  _jLabel1.setText(""String_Node_Str"");
  _jLabel2.setText(""String_Node_Str"");
  _browseButton.setText(""String_Node_Str"");
  _browseButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      browseButtonActionPerformed(evt);
    }
  }
);
  _migrateButton.setText(""String_Node_Str"");
  _migrateButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      migrateButtonActionPerformed(evt);
    }
  }
);
  _doneButton.setText(""String_Node_Str"");
  _doneButton.setVisible(false);
  _doneButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      doneButtonActionPerformed(evt);
    }
  }
);
  _resultsTextField.setBorder(javax.swing.BorderFactory.createEtchedBorder(javax.swing.border.EtchedBorder.RAISED));
  _resultsTextField.setEditable(false);
  _jLabel3.setText(""String_Node_Str"");
  _jLabel4.setText(""String_Node_Str"");
  _jLabel5.setText(""String_Node_Str"");
  _allSubDirectoriesCheckBox.setSelected(true);
  _allSubDirectoriesCheckBox.setText(""String_Node_Str"");
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(getContentPane());
  getContentPane().setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(_resultsTextField,javax.swing.GroupLayout.DEFAULT_SIZE,463,Short.MAX_VALUE).addGroup(layout.createSequentialGroup().addGap(156,156,156).addComponent(_migrateButton).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_doneButton,javax.swing.GroupLayout.PREFERRED_SIZE,72,javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap()).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap().addComponent(_jLabel3,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(_jLabel5,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(_jLabel4,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(_allSubDirectoriesCheckBox).addGroup(layout.createSequentialGroup().addComponent(_jLabel2).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_directoryPathTextField,javax.swing.GroupLayout.PREFERRED_SIZE,271,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(_browseButton)).addComponent(_jLabel1,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE)).addContainerGap()));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap().addComponent(_jLabel3).addGap(4,4,4).addComponent(_jLabel4).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_jLabel5).addGap(18,18,18).addComponent(_jLabel1).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(_jLabel2).addComponent(_directoryPathTextField,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_browseButton)).addGap(18,18,18).addComponent(_allSubDirectoriesCheckBox).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,23,Short.MAX_VALUE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(_migrateButton).addComponent(_doneButton)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_resultsTextField,javax.swing.GroupLayout.PREFERRED_SIZE,27,javax.swing.GroupLayout.PREFERRED_SIZE)));
  pack();
}","/** 
 * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
 */
private void initComponents(){
  _jLabel1=new javax.swing.JLabel();
  _jLabel2=new javax.swing.JLabel();
  _directoryPathTextField=new javax.swing.JTextField();
  _browseButton=new javax.swing.JButton();
  _migrateButton=new javax.swing.JButton();
  _doneButton=new javax.swing.JButton();
  _resultsTextField=new javax.swing.JTextField();
  _jLabel3=new javax.swing.JLabel();
  _jLabel4=new javax.swing.JLabel();
  _jLabel5=new javax.swing.JLabel();
  _allSubDirectoriesCheckBox=new javax.swing.JCheckBox();
  setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
  _jLabel1.setText(""String_Node_Str"");
  _jLabel2.setText(""String_Node_Str"");
  _browseButton.setText(""String_Node_Str"");
  _browseButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      browseButtonActionPerformed(evt);
    }
  }
);
  _migrateButton.setText(""String_Node_Str"");
  _migrateButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      migrateButtonActionPerformed(evt);
    }
  }
);
  _doneButton.setText(""String_Node_Str"");
  _doneButton.setVisible(false);
  _doneButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      doneButtonActionPerformed(evt);
    }
  }
);
  _resultsTextField.setBorder(javax.swing.BorderFactory.createEtchedBorder(javax.swing.border.EtchedBorder.RAISED));
  _resultsTextField.setEditable(false);
  _jLabel3.setText(""String_Node_Str"");
  _jLabel4.setText(""String_Node_Str"");
  _jLabel5.setText(""String_Node_Str"");
  _allSubDirectoriesCheckBox.setSelected(true);
  _allSubDirectoriesCheckBox.setText(""String_Node_Str"");
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(getContentPane());
  getContentPane().setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(_resultsTextField,javax.swing.GroupLayout.DEFAULT_SIZE,463,Short.MAX_VALUE).addGroup(layout.createSequentialGroup().addGap(156,156,156).addComponent(_migrateButton).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_doneButton,javax.swing.GroupLayout.PREFERRED_SIZE,72,javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap()).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap().addComponent(_jLabel3,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(_jLabel5,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(_jLabel4,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(_allSubDirectoriesCheckBox).addGroup(layout.createSequentialGroup().addComponent(_jLabel2).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_directoryPathTextField,javax.swing.GroupLayout.PREFERRED_SIZE,271,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(_browseButton)).addComponent(_jLabel1,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE)).addContainerGap()));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap().addComponent(_jLabel3).addGap(4,4,4).addComponent(_jLabel4).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_jLabel5).addGap(18,18,18).addComponent(_jLabel1).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(_jLabel2).addComponent(_directoryPathTextField,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_browseButton)).addGap(18,18,18).addComponent(_allSubDirectoriesCheckBox).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,23,Short.MAX_VALUE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(_migrateButton).addComponent(_doneButton)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_resultsTextField,javax.swing.GroupLayout.PREFERRED_SIZE,27,javax.swing.GroupLayout.PREFERRED_SIZE)));
  pack();
}"
73641,"private void _importByValue(){
  ArrayList<String> modelNames=new ArrayList();
  for (  SearchResultPanel panel : _resultPanelList) {
    modelNames.addAll(panel.getSelections());
  }
  for (  String modelName : modelNames) {
    try {
      Entity modelToImport=LoadManager.importModel(modelName,false,_containerModel);
      if (modelToImport != null) {
        MoMLChangeRequest change=new MoMLChangeRequest(this,_containerModel,modelToImport.exportMoML());
        change.setUndoable(true);
        _containerModel.requestChange(change);
      }
 else {
        throw new Exception();
      }
    }
 catch (    Exception e) {
      MessageHandler.error(""String_Node_Str"",e);
    }
  }
  _sourceFrame.toFront();
  JOptionPane.showMessageDialog(_sourceFrame,""String_Node_Str"");
}","private void _importByValue(){
  ArrayList<String> modelNames=new ArrayList();
  for (  SearchResultPanel panel : _resultPanelList) {
    modelNames.addAll(panel.getSelections());
  }
  if (modelNames.size() > 0) {
    for (    String modelName : modelNames) {
      try {
        Entity modelToImport=LoadManager.importModel(modelName,false,_containerModel);
        if (modelToImport != null) {
          MoMLChangeRequest change=new MoMLChangeRequest(this,_containerModel,modelToImport.exportMoML());
          change.setUndoable(true);
          _containerModel.requestChange(change);
        }
 else {
          throw new Exception();
        }
      }
 catch (      Exception e) {
        MessageHandler.error(""String_Node_Str"",e);
      }
    }
    _sourceFrame.toFront();
    JOptionPane.showMessageDialog(_sourceFrame,""String_Node_Str"");
  }
 else {
    JOptionPane.showMessageDialog(this,""String_Node_Str"");
  }
}"
73642,"private void _importByReference(){
  ArrayList<String> modelNames=new ArrayList();
  for (  SearchResultPanel panel : _resultPanelList) {
    modelNames.addAll(panel.getSelections());
  }
  for (  String modelName : modelNames) {
    try {
      Entity modelToImport=LoadManager.importModel(modelName,true,_containerModel);
      if (modelToImport != null) {
        MoMLChangeRequest change=new MoMLChangeRequest(this,_containerModel,modelToImport.exportMoML());
        change.setUndoable(true);
        _containerModel.requestChange(change);
      }
 else {
        throw new Exception();
      }
    }
 catch (    Exception e) {
      MessageHandler.error(""String_Node_Str"",e);
    }
  }
  _sourceFrame.toFront();
  JOptionPane.showMessageDialog(_sourceFrame,""String_Node_Str"");
}","private void _importByReference(){
  ArrayList<String> modelNames=new ArrayList();
  for (  SearchResultPanel panel : _resultPanelList) {
    modelNames.addAll(panel.getSelections());
  }
  if (modelNames.size() > 0) {
    for (    String modelName : modelNames) {
      try {
        Entity modelToImport=LoadManager.importModel(modelName,true,_containerModel);
        if (modelToImport != null) {
          MoMLChangeRequest change=new MoMLChangeRequest(this,_containerModel,modelToImport.exportMoML());
          change.setUndoable(true);
          _containerModel.requestChange(change);
        }
 else {
          throw new Exception();
        }
      }
 catch (      Exception e) {
        MessageHandler.error(""String_Node_Str"",e);
      }
    }
    _sourceFrame.toFront();
    JOptionPane.showMessageDialog(_sourceFrame,""String_Node_Str"");
  }
 else {
    JOptionPane.showMessageDialog(this,""String_Node_Str"");
  }
}"
73643,"/** 
 * Implement the update method for Observer interface. Call display to display search results.
 * @param buffer The observer.  Only handled if it is an instance of SearchResultBuffer.
 * @param arg Option argument.  This is unused, but included by Java conventions.
 */
public void update(Observable buffer,Object arg){
  if (buffer instanceof SearchResultBuffer) {
    ArrayList<XMLDBModel> results=((SearchResultBuffer)buffer).getResults();
    if (results != null && results.size() > 0) {
      display(results);
    }
 else {
      if (_resultPanelList.size() == 0) {
        JOptionPane.showMessageDialog(this,""String_Node_Str"");
      }
 else {
        JOptionPane.showMessageDialog(this,""String_Node_Str"");
      }
    }
  }
}","/** 
 * Implement the update method for Observer interface. Call display to display search results.
 * @param buffer The observer.  Only handled if it is an instance of SearchResultBuffer.
 * @param arg Option argument.  This is unused, but included by Java conventions.
 */
public void update(Observable buffer,Object arg){
  if (buffer instanceof SearchResultBuffer) {
    ArrayList<XMLDBModel> results=((SearchResultBuffer)buffer).getResults();
    if (results != null && results.size() > 0) {
      display(results);
    }
 else {
      if (_resultPanelList.size() == 0) {
        JOptionPane.showMessageDialog(this,""String_Node_Str"");
      }
 else {
        JOptionPane.showMessageDialog(this,""String_Node_Str"");
      }
      _cancelButton.setEnabled(false);
    }
  }
}"
73644,"/** 
 * Construct an AddSubtract adapter.
 * @param actor the associated actor
 */
public MovingAverage(ptolemy.actor.lib.MovingAverage actor){
  super(actor);
}","/** 
 * Construct a MovingAverage adapter.
 * @param actor the associated actor
 */
public MovingAverage(ptolemy.actor.lib.MovingAverage actor){
  super(actor);
}"
73645,"/** 
 * Construct a AddSubtract adapter.
 * @param actor The given ptolemy.actor.lib.AddSubtract actor.
 */
public SampleDelay(ptolemy.domains.sdf.lib.SampleDelay actor){
  super(actor);
}","/** 
 * Construct a SampleDelay adapter.
 * @param actor The given ptolemy.domains.sdf.lib.SampleDelay actor.
 */
public SampleDelay(ptolemy.domains.sdf.lib.SampleDelay actor){
  super(actor);
}"
73646,"/** 
 * Generate preinitialize code. Read the <code>preinitBlock</code> from AddSubtract.c, replace macros with their values and returns the processed code block.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
@Override public String generatePreinitializeCode() throws IllegalActionException {
  super.generatePreinitializeCode();
  ptolemy.domains.sdf.lib.UpSample actor=(ptolemy.domains.sdf.lib.UpSample)getComponent();
  ArrayList<String> args=new ArrayList<String>();
  Type type=actor.input.getType();
  args.add(targetType(type));
  CodeStream codeStream=_templateParser.getCodeStream();
  if (codeStream.isEmpty()) {
    codeStream.append(_eol + getCodeGenerator().comment(""String_Node_Str"" + getComponent().getName()));
  }
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  return processCode(codeStream.toString());
}","/** 
 * Generate preinitialize code. Read the <code>preinitBlock</code> from the template file. replace macros with their values and returns the processed code block.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
@Override public String generatePreinitializeCode() throws IllegalActionException {
  super.generatePreinitializeCode();
  ptolemy.domains.sdf.lib.UpSample actor=(ptolemy.domains.sdf.lib.UpSample)getComponent();
  ArrayList<String> args=new ArrayList<String>();
  Type type=actor.input.getType();
  args.add(targetType(type));
  CodeStream codeStream=_templateParser.getCodeStream();
  if (codeStream.isEmpty()) {
    codeStream.append(_eol + getCodeGenerator().comment(""String_Node_Str"" + getComponent().getName()));
  }
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  return processCode(codeStream.toString());
}"
73647,"/** 
 * Construct a AddSubtract adapter.
 * @param actor The given ptolemy.actor.lib.AddSubtract actor.
 */
public Const(ptolemy.actor.lib.Const actor){
  super(actor);
}","/** 
 * Construct a Const adapter.
 * @param actor The given ptolemy.actor.lib.Const actor.
 */
public Const(ptolemy.actor.lib.Const actor){
  super(actor);
}"
73648,"/** 
 * Construct a AddSubtract adapter.
 * @param actor The given ptolemy.actor.lib.AddSubtract actor.
 */
public SampleDelay(ptolemy.domains.sdf.lib.SampleDelay actor){
  super(actor);
}","/** 
 * Construct a SampleDelay adapter.
 * @param actor The given ptolemy.domains.sdf.lib.SampleDelay actor.
 */
public SampleDelay(ptolemy.domains.sdf.lib.SampleDelay actor){
  super(actor);
}"
73649,"/** 
 * Check with the given name meet the attribute or model name convention. 
 * @param name The name to be verified. 
 * @return true - if the name is valid.<br>false - if the name is invalid. 
 */
public static boolean checkAttributeModelName(String name){
  if (name == null || name.trim().isEmpty()) {
    return false;
  }
  if (name.matches(""String_Node_Str"")) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Check with the given name meet the attribute or model name convention. 
 * @param name The name to be verified. 
 * @return true - if the name is valid.<br>false - if the name is invalid. 
 * @exception IllegalNameException Thrown if the verifying name is invalid. 
 */
public static boolean checkAttributeModelName(String name) throws IllegalNameException {
  if (name == null || name.trim().isEmpty()) {
    throw new IllegalNameException(""String_Node_Str"");
  }
  if (name.matches(""String_Node_Str"")) {
    return true;
  }
 else {
    throw new IllegalNameException(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
73650,"/** 
 * Validate whether the search criteria that the user has input is valid or  not. 
 * @return true - the search criteria is valid.<br>false - the search criteria is invalid. 
 * @exception NameDuplicationException Thrown if attributes with duplicatednames are found in the search criteria. 
 * @exception IllegalActionException Thrown if the intend action is illegal. 
 */
private boolean _isValid() throws NameDuplicationException, IllegalActionException {
  if (_attributesListPanel.getAttributeCount() == 0 && _attributesListPanel.getModelName().trim().isEmpty()) {
    return true;
  }
  if (!_attributesListPanel.getModelName().trim().isEmpty()) {
    if (!Utilities.checkAttributeModelName(_attributesListPanel.getModelName())) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      return false;
    }
  }
  if (_attributesListPanel.containsDuplicates()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeNamesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeValuesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  return true;
}","/** 
 * Validate whether the search criteria that the user has input is valid or  not. 
 * @return true - the search criteria is valid.<br>false - the search criteria is invalid. 
 * @exception NameDuplicationException Thrown if attributes with duplicatednames are found in the search criteria. 
 * @exception IllegalActionException Thrown if the intend action is illegal. 
 */
private boolean _isValid() throws NameDuplicationException, IllegalActionException {
  if (_attributesListPanel.getAttributeCount() == 0 && _attributesListPanel.getModelName().trim().isEmpty()) {
    return true;
  }
  if (!_attributesListPanel.getModelName().trim().isEmpty()) {
    try {
      Utilities.checkAttributeModelName(_attributesListPanel.getModelName());
    }
 catch (    IllegalNameException e) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      return false;
    }
  }
  if (_attributesListPanel.containsDuplicates()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeNamesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeValuesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  return true;
}"
73651,"/** 
 * Called from within the constructor to initialize the form.
 */
@SuppressWarnings(""String_Node_Str"") private void _initComponents(){
  _listItemTextField=new JTextField();
  _jScrollPane1=new JScrollPane();
  _itemsJList=new JList();
  _addButton=new JButton();
  _deleteButton=new JButton();
  _editListItemsLabel=new JLabel();
  _saveButton=new JButton();
  addWindowListener(new WindowListener(){
    @Override public void windowOpened(    WindowEvent e){
    }
    @Override public void windowIconified(    WindowEvent e){
    }
    @Override public void windowDeiconified(    WindowEvent e){
    }
    @Override public void windowDeactivated(    WindowEvent e){
    }
    @Override public void windowClosing(    WindowEvent e){
      _parentFrame.setEnabled(true);
      AttributeListEditFrame.this.dispose();
    }
    @Override public void windowClosed(    WindowEvent e){
      _parentFrame.setEnabled(true);
      AttributeListEditFrame.this.dispose();
    }
    @Override public void windowActivated(    WindowEvent e){
    }
  }
);
  _itemsJList.setModel(new ArrayModelList(_storedListItems));
  _itemsJList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      _deleteButton.setEnabled(true);
    }
  }
);
  _jScrollPane1.setViewportView(_itemsJList);
  _addButton.setText(""String_Node_Str"");
  _addButton.setEnabled(false);
  _addButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (!_validate()) {
        JOptionPane.showMessageDialog(AttributeListEditFrame.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
 else {
        ((ArrayModelList)_itemsJList.getModel()).addItem(_listItemTextField.getText());
        _addButton.setEnabled(false);
        _listItemTextField.setText(""String_Node_Str"");
      }
    }
  }
);
  _deleteButton.setText(""String_Node_Str"");
  _deleteButton.setEnabled(false);
  _deleteButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      ((ArrayModelList)_itemsJList.getModel()).removeItem((String)_itemsJList.getSelectedValue());
      _deleteButton.setEnabled(false);
    }
  }
);
  _editListItemsLabel.setFont(new Font(""String_Node_Str"",1,18));
  _editListItemsLabel.setText(""String_Node_Str"");
  _saveButton.setText(""String_Node_Str"");
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(getContentPane());
  getContentPane().setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap(50,Short.MAX_VALUE).addComponent(_listItemTextField,javax.swing.GroupLayout.PREFERRED_SIZE,143,javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18,18,18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING,false).addComponent(_deleteButton,0,0,Short.MAX_VALUE).addComponent(_addButton,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE)).addGap(18,18,18).addComponent(_jScrollPane1,javax.swing.GroupLayout.PREFERRED_SIZE,156,javax.swing.GroupLayout.PREFERRED_SIZE).addGap(62,62,62)).addGroup(layout.createSequentialGroup().addGap(28,28,28).addComponent(_editListItemsLabel).addContainerGap(380,Short.MAX_VALUE)).addGroup(layout.createSequentialGroup().addGap(224,224,224).addComponent(_saveButton,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE).addGap(241,241,241)));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(38,38,38).addComponent(_editListItemsLabel).addGap(76,76,76).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(_listItemTextField,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_addButton)).addGap(30,30,30).addComponent(_deleteButton).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,79,Short.MAX_VALUE).addComponent(_saveButton).addGap(48,48,48)).addGroup(layout.createSequentialGroup().addGap(74,74,74).addComponent(_jScrollPane1,javax.swing.GroupLayout.PREFERRED_SIZE,202,javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(105,Short.MAX_VALUE)));
  _listItemTextField.addKeyListener(new KeyListener(){
    @Override public void keyTyped(    KeyEvent e){
    }
    @Override public void keyReleased(    KeyEvent e){
      if (_listItemTextField.getText().isEmpty()) {
        _addButton.setEnabled(false);
      }
 else {
        _addButton.setEnabled(true);
      }
    }
    @Override public void keyPressed(    KeyEvent e){
    }
  }
);
  _saveButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      _parentFrame.setEnabled(true);
      AttributeListEditFrame.this.dispose();
    }
  }
);
  pack();
}","/** 
 * Called from within the constructor to initialize the form.
 */
@SuppressWarnings(""String_Node_Str"") private void _initComponents(){
  _listItemTextField=new JTextField();
  _jScrollPane1=new JScrollPane();
  _itemsJList=new JList();
  _addButton=new JButton();
  _deleteButton=new JButton();
  _editListItemsLabel=new JLabel();
  _saveButton=new JButton();
  addWindowListener(new WindowListener(){
    @Override public void windowOpened(    WindowEvent e){
    }
    @Override public void windowIconified(    WindowEvent e){
    }
    @Override public void windowDeiconified(    WindowEvent e){
    }
    @Override public void windowDeactivated(    WindowEvent e){
    }
    @Override public void windowClosing(    WindowEvent e){
      _parentFrame.setEnabled(true);
      AttributeListEditFrame.this.dispose();
    }
    @Override public void windowClosed(    WindowEvent e){
      _parentFrame.setEnabled(true);
      AttributeListEditFrame.this.dispose();
    }
    @Override public void windowActivated(    WindowEvent e){
    }
  }
);
  _itemsJList.setModel(new ArrayModelList(_storedListItems));
  _itemsJList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      _deleteButton.setEnabled(true);
    }
  }
);
  _jScrollPane1.setViewportView(_itemsJList);
  _addButton.setText(""String_Node_Str"");
  _addButton.setEnabled(false);
  _addButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      try {
        _validate();
        ((ArrayModelList)_itemsJList.getModel()).addItem(_listItemTextField.getText());
        _addButton.setEnabled(false);
        _listItemTextField.setText(""String_Node_Str"");
      }
 catch (      IllegalNameException exception) {
        JOptionPane.showMessageDialog(AttributeListEditFrame.this,exception.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  _deleteButton.setText(""String_Node_Str"");
  _deleteButton.setEnabled(false);
  _deleteButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      ((ArrayModelList)_itemsJList.getModel()).removeItem((String)_itemsJList.getSelectedValue());
      _deleteButton.setEnabled(false);
    }
  }
);
  _editListItemsLabel.setFont(new Font(""String_Node_Str"",1,18));
  _editListItemsLabel.setText(""String_Node_Str"");
  _saveButton.setText(""String_Node_Str"");
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(getContentPane());
  getContentPane().setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap(50,Short.MAX_VALUE).addComponent(_listItemTextField,javax.swing.GroupLayout.PREFERRED_SIZE,143,javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18,18,18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING,false).addComponent(_deleteButton,0,0,Short.MAX_VALUE).addComponent(_addButton,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE)).addGap(18,18,18).addComponent(_jScrollPane1,javax.swing.GroupLayout.PREFERRED_SIZE,156,javax.swing.GroupLayout.PREFERRED_SIZE).addGap(62,62,62)).addGroup(layout.createSequentialGroup().addGap(28,28,28).addComponent(_editListItemsLabel).addContainerGap(380,Short.MAX_VALUE)).addGroup(layout.createSequentialGroup().addGap(224,224,224).addComponent(_saveButton,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE).addGap(241,241,241)));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(38,38,38).addComponent(_editListItemsLabel).addGap(76,76,76).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(_listItemTextField,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_addButton)).addGap(30,30,30).addComponent(_deleteButton).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,79,Short.MAX_VALUE).addComponent(_saveButton).addGap(48,48,48)).addGroup(layout.createSequentialGroup().addGap(74,74,74).addComponent(_jScrollPane1,javax.swing.GroupLayout.PREFERRED_SIZE,202,javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(105,Short.MAX_VALUE)));
  _listItemTextField.addKeyListener(new KeyListener(){
    @Override public void keyTyped(    KeyEvent e){
    }
    @Override public void keyReleased(    KeyEvent e){
      if (_listItemTextField.getText().isEmpty()) {
        _addButton.setEnabled(false);
      }
 else {
        _addButton.setEnabled(true);
      }
    }
    @Override public void keyPressed(    KeyEvent e){
    }
  }
);
  _saveButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      _parentFrame.setEnabled(true);
      AttributeListEditFrame.this.dispose();
    }
  }
);
  pack();
}"
73652,"/** 
 * Validate whether the added item is valid to add to the list. 
 * @return true - It is valid to add that item.<br>false - It is invalid to add that item.
 */
private boolean _validate(){
  if (!Utilities.checkAttributeModelName(_listItemTextField.getText())) {
    return false;
  }
  ArrayModelList modelList=((ArrayModelList)_itemsJList.getModel());
  for (int i=0; i < modelList.getSize(); i++) {
    if (_listItemTextField.getText().equals(modelList.getElementAt(i))) {
      return false;
    }
  }
  return true;
}","/** 
 * Validate whether the added item is valid to add to the list. 
 * @return true - It is valid to add that item.<br>false - It is invalid to add that item.
 * @exception IllegalNameException Thrown if the item value is legal. 
 */
private boolean _validate() throws IllegalNameException {
  try {
    Utilities.checkAttributeModelName(_listItemTextField.getText());
  }
 catch (  IllegalNameException e) {
    throw new IllegalNameException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  ArrayModelList modelList=((ArrayModelList)_itemsJList.getModel());
  for (int i=0; i < modelList.getSize(); i++) {
    if (_listItemTextField.getText().equals(modelList.getElementAt(i))) {
      throw new IllegalNameException(""String_Node_Str"");
    }
  }
  return true;
}"
73653,"/** 
 * Save a model but keep a list of models that reference it point to the old model and update the rest of the models.
 * @param xmlDBModelWithReferenceChanges An object that contains the modelto be saved, the list of parents that should have the old reference, and the new version name that will be placed as a reference in the parents' list.
 * @return A string that represents the model Id of the newly created model.
 * @exception DBConnectionException Thrown if the connection to the databasefails.
 * @exception DBExecutionException Thrown if the operation fails to execute.
 * @exception DBModelNotFoundException Thrown if the model to be saved isnot in the database.
 * @exception ModelAlreadyExistException Thrown if the new version name matchesa name of a model that is already in the database.
 * @exception IllegalArgumentException Thrown if the parameters passed are notproperly set.
 * @exception XMLDBModelParsingException Thrown if the MoML in the model objectis corrupted.
 * @exception CircularDependencyException Thrown if the save operation causes acircular dependency.
 */
public String saveWithParents(XMLDBModelWithReferenceChanges xmlDBModelWithReferenceChanges) throws DBConnectionException, DBExecutionException, DBModelNotFoundException, ModelAlreadyExistException, IllegalArgumentException, XMLDBModelParsingException, CircularDependencyException {
  String newModelId=""String_Node_Str"";
  if (xmlDBModelWithReferenceChanges == null || xmlDBModelWithReferenceChanges.getModelToBeSaved() == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  DBConnection dbConnection=null;
  try {
    dbConnection=DBConnectorFactory.getSyncConnection(true);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    if (xmlDBModelWithReferenceChanges != null && xmlDBModelWithReferenceChanges.getModelToBeSaved() != null && !xmlDBModelWithReferenceChanges.getModelToBeSaved().getIsNew() && xmlDBModelWithReferenceChanges.getVersionName() != null && xmlDBModelWithReferenceChanges.getVersionName().length() > 0 && xmlDBModelWithReferenceChanges.getParentsList() != null && xmlDBModelWithReferenceChanges.getParentsList().size() > 0) {
      GetModelTask getModelTask=new GetModelTask(xmlDBModelWithReferenceChanges.getModelToBeSaved().getModelName());
      XMLDBModel dbModelToBeSaved=dbConnection.executeGetModelTask(getModelTask);
      XMLDBModel newXMLDBModel=new XMLDBModel(xmlDBModelWithReferenceChanges.getVersionName());
      newXMLDBModel.setIsNew(true);
      newXMLDBModel.setModel(dbModelToBeSaved.getModel());
      newModelId=save(newXMLDBModel,dbConnection);
      newXMLDBModel.setModelId(newModelId);
      UpdateParentsToNewVersionTask updateParentsToNewVersionTask=new UpdateParentsToNewVersionTask();
      updateParentsToNewVersionTask.setNewModel(newXMLDBModel);
      updateParentsToNewVersionTask.setOldModel(xmlDBModelWithReferenceChanges.getModelToBeSaved());
      updateParentsToNewVersionTask.setParentsList(xmlDBModelWithReferenceChanges.getParentsList());
      dbConnection.executeUpdateParentsToNewVersion(updateParentsToNewVersionTask);
    }
    String oldModelId=""String_Node_Str"";
    oldModelId=save(xmlDBModelWithReferenceChanges.getModelToBeSaved(),dbConnection);
    if (xmlDBModelWithReferenceChanges.getModelToBeSaved().getIsNew()) {
      newModelId=oldModelId;
    }
    dbConnection.commitConnection();
  }
 catch (  DBConnectionException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  DBExecutionException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  ModelAlreadyExistException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  IllegalArgumentException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  XMLDBModelParsingException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  CircularDependencyException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  return newModelId;
}","/** 
 * Save a model but keep a list of models that reference it point to the old model and update the rest of the models.
 * @param xmlDBModelWithReferenceChanges An object that contains the modelto be saved, the list of parents that should have the old reference, and the new version name that will be placed as a reference in the parents' list.
 * @return A string that represents the model Id of the model being saved.
 * @exception DBConnectionException Thrown if the connection to the databasefails.
 * @exception DBExecutionException Thrown if the operation fails to execute.
 * @exception DBModelNotFoundException Thrown if the model to be saved isnot in the database.
 * @exception ModelAlreadyExistException Thrown if the new version name matchesa name of a model that is already in the database.
 * @exception IllegalArgumentException Thrown if the parameters passed are notproperly set.
 * @exception XMLDBModelParsingException Thrown if the MoML in the model objectis corrupted.
 * @exception CircularDependencyException Thrown if the save operation causes acircular dependency.
 */
public String saveWithParents(XMLDBModelWithReferenceChanges xmlDBModelWithReferenceChanges) throws DBConnectionException, DBExecutionException, DBModelNotFoundException, ModelAlreadyExistException, IllegalArgumentException, XMLDBModelParsingException, CircularDependencyException {
  String modelId=""String_Node_Str"";
  if (xmlDBModelWithReferenceChanges == null || xmlDBModelWithReferenceChanges.getModelToBeSaved() == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  DBConnection dbConnection=null;
  try {
    dbConnection=DBConnectorFactory.getSyncConnection(true);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    if (!xmlDBModelWithReferenceChanges.getModelToBeSaved().getIsNew() && xmlDBModelWithReferenceChanges.getVersionName() != null && xmlDBModelWithReferenceChanges.getVersionName().length() > 0 && xmlDBModelWithReferenceChanges.getParentsList() != null && xmlDBModelWithReferenceChanges.getParentsList().size() > 0) {
      GetModelTask getModelTask=new GetModelTask(xmlDBModelWithReferenceChanges.getModelToBeSaved().getModelName());
      XMLDBModel dbModelToBeSaved=dbConnection.executeGetModelTask(getModelTask);
      XMLDBModel newXMLDBModel=new XMLDBModel(xmlDBModelWithReferenceChanges.getVersionName());
      newXMLDBModel.setIsNew(true);
      newXMLDBModel.setModel(dbModelToBeSaved.getModel());
      String newModelId=save(newXMLDBModel,dbConnection);
      newXMLDBModel.setModelId(newModelId);
      UpdateParentsToNewVersionTask updateParentsToNewVersionTask=new UpdateParentsToNewVersionTask();
      updateParentsToNewVersionTask.setNewModel(newXMLDBModel);
      updateParentsToNewVersionTask.setOldModel(xmlDBModelWithReferenceChanges.getModelToBeSaved());
      updateParentsToNewVersionTask.setParentsList(xmlDBModelWithReferenceChanges.getParentsList());
      dbConnection.executeUpdateParentsToNewVersion(updateParentsToNewVersionTask);
    }
    String oldModelId=""String_Node_Str"";
    modelId=save(xmlDBModelWithReferenceChanges.getModelToBeSaved(),dbConnection);
    dbConnection.commitConnection();
  }
 catch (  DBConnectionException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  DBExecutionException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  ModelAlreadyExistException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  IllegalArgumentException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  XMLDBModelParsingException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  CircularDependencyException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  return modelId;
}"
73654,"/** 
 * Set the graph search criteria.
 * @param graphSearchCriteria The graph search criteria.
 */
public void setGraphSearchCriteria(DBGraphSearchCriteria graphSearchCriteria){
  this._graphSearchCriteria=graphSearchCriteria;
}","/** 
 * Set the graph search criteria.
 * @param graphSearchCriteria The graph search criteria.
 * @see #getGraphSearchCriteria
 */
public void setGraphSearchCriteria(DBGraphSearchCriteria graphSearchCriteria){
  this._graphSearchCriteria=graphSearchCriteria;
}"
73655,"/** 
 * Return the graphical search criteria.
 * @return The graph search criteria.
 */
public DBGraphSearchCriteria getGraphSearchCriteria(){
  return _graphSearchCriteria;
}","/** 
 * Return the graphical search criteria.
 * @return The graph search criteria.
 * @see #setGraphSearchCriteria
 */
public DBGraphSearchCriteria getGraphSearchCriteria(){
  return _graphSearchCriteria;
}"
73656,"/** 
 * Create an XML string representation of XMLDBAttribute object.
 * @return The XML string representation of XMLDBAttribute object.
 */
public String getAttributeXMLStringFormat(){
  String attributeNode=""String_Node_Str"" + _attributeId + ""String_Node_Str""+ ""String_Node_Str""+ _attributeName+ ""String_Node_Str""+ _attributeType+ ""String_Node_Str"";
  if (_attributeType.equalsIgnoreCase(XMLDBAttribute.ATTRIBUTE_TYPE_LIST)) {
    if (_attributeValues != null && _attributeValues.size() > 0) {
      for (int i=0; i < _attributeValues.size(); i++) {
        attributeNode=attributeNode + ""String_Node_Str"" + _attributeValues.get(i).toString()+ ""String_Node_Str"";
      }
    }
  }
  attributeNode=attributeNode + ""String_Node_Str"";
  return attributeNode;
}","/** 
 * Create an XML string representation of XMLDBAttribute object.
 * @return The XML string representation of XMLDBAttribute object.
 */
public String getAttributeXMLStringFormat(){
  String attributeNode=""String_Node_Str"" + _attributeId + ""String_Node_Str""+ ""String_Node_Str""+ _attributeName+ ""String_Node_Str""+ _attributeType+ ""String_Node_Str"";
  StringBuffer attributeBuffer=new StringBuffer(attributeNode);
  if (_attributeType.equalsIgnoreCase(XMLDBAttribute.ATTRIBUTE_TYPE_LIST)) {
    if (_attributeValues != null && _attributeValues.size() > 0) {
      for (int i=0; i < _attributeValues.size(); i++) {
        attributeBuffer.append(""String_Node_Str"" + _attributeValues.get(i).toString() + ""String_Node_Str"");
      }
    }
  }
  attributeBuffer.append(""String_Node_Str"");
  attributeNode=attributeBuffer.toString();
  return attributeNode;
}"
73657,"/** 
 * Test method for   {@link ptdb.kernel.database.RebuildReferenceFile#RebuildReferenceFile(ptdb.common.dto.DBConnectionParameters)}.
 */
@Test public void testRebuildReferenceFile(){
  DBConnectionParameters dbConnectionParameters=DBConnectorFactory.getDBConnectionParameters();
  try {
    RebuildReferenceFile rebuildReferenceFile=new RebuildReferenceFile(dbConnectionParameters);
  }
 catch (  DBConnectionException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Test method for   {@link ptdb.kernel.database.RebuildReferenceFile#RebuildReferenceFile(ptdb.common.dto.DBConnectionParameters)}.
 */
@Test public void testRebuildReferenceFile(){
  DBConnectionParameters dbConnectionParameters=DBConnectorFactory.getDBConnectionParameters();
  try {
    new RebuildReferenceFile(dbConnectionParameters);
  }
 catch (  DBConnectionException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
}"
73658,"/** 
 * Test method for   {@link ptdb.kernel.database.RebuildReferenceFile#main(java.lang.String[])}.
 * @throws Exception 
 */
@Test public void testMain() throws Exception {
  try {
    BufferedReader mockBufferedReader=PowerMock.createMock(BufferedReader.class);
    InputStreamReader mockInputStreamReader=PowerMock.createMock(InputStreamReader.class);
    PowerMock.expectNew(InputStreamReader.class,System.in).andReturn(mockInputStreamReader);
    PowerMock.expectNew(BufferedReader.class,mockInputStreamReader).andReturn(mockBufferedReader);
    EasyMock.expect(mockBufferedReader.readLine()).andReturn(""String_Node_Str"");
    mockBufferedReader.close();
    PowerMock.replay(InputStreamReader.class,BufferedReader.class,mockBufferedReader,mockInputStreamReader);
    RebuildReferenceFile.main(null);
    PowerMock.verify();
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
catch (  DBConnectionException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
catch (  DBExecutionException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
catch (  XMLDBModelParsingException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Test method for   {@link ptdb.kernel.database.RebuildReferenceFile#main(java.lang.String[])}.
 * @throws Exception 
 */
@Test public void testMain() throws Exception {
  try {
    BufferedReader mockBufferedReader=PowerMock.createMock(BufferedReader.class);
    InputStreamReader mockInputStreamReader=PowerMock.createMock(InputStreamReader.class);
    PowerMock.expectNew(InputStreamReader.class,System.in).andReturn(mockInputStreamReader);
    PowerMock.expectNew(BufferedReader.class,mockInputStreamReader).andReturn(mockBufferedReader);
    EasyMock.expect(mockBufferedReader.readLine()).andReturn(""String_Node_Str"");
    mockBufferedReader.close();
    PowerMock.replay(InputStreamReader.class,BufferedReader.class,mockBufferedReader,mockInputStreamReader);
    RebuildReferenceFile.main(new String[1]);
    PowerMock.verify();
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
catch (  DBConnectionException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
catch (  DBExecutionException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
catch (  XMLDBModelParsingException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
}"
73659,"/** 
 * Save the changes of an existing model in the database or create a new model in the database. Remove all prior entries to the saved model from the cache, including any other models that reference it.
 * @param xmlDBModel The model object that is required to be saved orcreated in the database.
 * @param dbConnection The connection to the database that will be used toexecute the task.
 * @return A boolean indicator of weather the operation was successful ornot.
 * @exception DBConnectionException Thrown if there is a database connectionerror.
 * @exception DBExecutionException Thrown if the execution failed.
 * @exception IllegalArgumentException Thrown if the parameters were notright.
 * @exception ModelAlreadyExistException Thrown if the model being createdalready exists.
 * @throws XMLDBModelParsingException Thrown if the model is parsedincorrectly.
 * @throws CircularDependencyException
 */
private String save(XMLDBModel xmlDBModel,DBConnection dbConnection) throws DBConnectionException, DBExecutionException, IllegalArgumentException, ModelAlreadyExistException, XMLDBModelParsingException, CircularDependencyException {
  String returnString=null;
  try {
    if (xmlDBModel == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    xmlDBModel=populateChildModelsList(xmlDBModel);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    if (xmlDBModel.getIsNew()) {
      CreateModelTask createModelTask=new CreateModelTask(xmlDBModel);
      returnString=dbConnection.executeCreateModelTask(createModelTask);
      dbConnection.commitConnection();
    }
 else {
      SaveModelTask saveModelTask=new SaveModelTask(xmlDBModel);
      returnString=dbConnection.executeSaveModelTask(saveModelTask);
      dbConnection.commitConnection();
    }
  }
 catch (  DBExecutionException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
  updateCache(xmlDBModel);
  return returnString;
}","/** 
 * Save the changes of an existing model in the database or create a new model in the database. Remove all prior entries to the saved model from the cache, including any other models that reference it.
 * @param xmlDBModel The model object that is required to be saved orcreated in the database.
 * @param dbConnection The connection to the database that will be used toexecute the task.
 * @return A boolean indicator of weather the operation was successful ornot.
 * @exception DBConnectionException Thrown if there is a database connectionerror.
 * @exception DBExecutionException Thrown if the execution failed.
 * @exception IllegalArgumentException Thrown if the parameters were notright.
 * @exception ModelAlreadyExistException Thrown if the model being createdalready exists.
 * @throws XMLDBModelParsingException Thrown if the model is parsedincorrectly.
 * @throws CircularDependencyException
 */
private String save(XMLDBModel xmlDBModel,DBConnection dbConnection) throws DBConnectionException, DBExecutionException, IllegalArgumentException, ModelAlreadyExistException, XMLDBModelParsingException, CircularDependencyException {
  String returnString=null;
  try {
    if (xmlDBModel == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    xmlDBModel=populateChildModelsList(xmlDBModel);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    if (xmlDBModel.getIsNew()) {
      CreateModelTask createModelTask=new CreateModelTask(xmlDBModel);
      returnString=dbConnection.executeCreateModelTask(createModelTask);
    }
 else {
      SaveModelTask saveModelTask=new SaveModelTask(xmlDBModel);
      returnString=dbConnection.executeSaveModelTask(saveModelTask);
    }
  }
 catch (  DBExecutionException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
  updateCache(xmlDBModel);
  return returnString;
}"
73660,"/** 
 * Save the changes of an existing model in the database or create a new model in the database. Remove all prior entries to the saved model from the cache, including any other models that reference it.
 * @param xmlDBModel The model object that is required to be saved orcreated in the database.
 * @param dbConnection The connection to the database that will be used toexecute the task.
 * @return A boolean indicator of weather the operation was successful ornot.
 * @exception DBConnectionException Thrown if there is a database connectionerror.
 * @exception DBExecutionException Thrown if the execution failed.
 * @exception IllegalArgumentException Thrown if the parameters were notright.
 * @exception ModelAlreadyExistException Thrown if the model being createdalready exists.
 * @throws XMLDBModelParsingException Thrown if the model is parsedincorrectly.
 * @throws CircularDependencyException
 */
private String save(XMLDBModel xmlDBModel,DBConnection dbConnection) throws DBConnectionException, DBExecutionException, IllegalArgumentException, ModelAlreadyExistException, XMLDBModelParsingException, CircularDependencyException {
  String returnString=null;
  try {
    if (xmlDBModel == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    xmlDBModel=populateChildModelsList(xmlDBModel);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    if (xmlDBModel.getIsNew()) {
      CreateModelTask createModelTask=new CreateModelTask(xmlDBModel);
      returnString=dbConnection.executeCreateModelTask(createModelTask);
    }
 else {
      SaveModelTask saveModelTask=new SaveModelTask(xmlDBModel);
      returnString=dbConnection.executeSaveModelTask(saveModelTask);
    }
  }
 catch (  DBExecutionException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
  updateCache(xmlDBModel);
  return returnString;
}","/** 
 * Save the changes of an existing model in the database or create a new model in the database. Remove all prior entries to the saved model from the cache, including any other models that reference it.
 * @param xmlDBModel The model object that is required to be saved orcreated in the database.
 * @param dbConnection The connection to the database that will be used toexecute the task.
 * @return A string representing the model id that was saved.
 * @exception DBConnectionException Thrown if there is a database connectionerror.
 * @exception DBExecutionException Thrown if the execution failed.
 * @exception IllegalArgumentException Thrown if the parameters were notright.
 * @exception ModelAlreadyExistException Thrown if the model being createdalready exists.
 * @throws XMLDBModelParsingException Thrown if the model is parsedincorrectly.
 * @throws CircularDependencyException
 */
private String save(XMLDBModel xmlDBModel,DBConnection dbConnection) throws DBConnectionException, DBExecutionException, IllegalArgumentException, ModelAlreadyExistException, XMLDBModelParsingException, CircularDependencyException {
  String newModelId=null;
  try {
    if (xmlDBModel == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    xmlDBModel=populateChildModelsList(xmlDBModel);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    if (xmlDBModel.getIsNew()) {
      CreateModelTask createModelTask=new CreateModelTask(xmlDBModel);
      newModelId=dbConnection.executeCreateModelTask(createModelTask);
    }
 else {
      SaveModelTask saveModelTask=new SaveModelTask(xmlDBModel);
      newModelId=dbConnection.executeSaveModelTask(saveModelTask);
    }
  }
 catch (  DBExecutionException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
  updateCache(xmlDBModel);
  return newModelId;
}"
73661,"/** 
 * Save a model but keep a list of models that reference it point to the old model and update the rest of the models.
 * @param xmlDBModelWithReferenceChanges An object that contains the modelto be saved, the list of parents that should have the old reference, and the new version name that will be placed as a reference in the parents' list.
 * @return A string that represents the model Id of the newly created model.
 * @exception DBConnectionException Thrown if the connection to the databasefails.
 * @exception DBExecutionException Thrown if the operation fails to execute.
 * @exception DBModelNotFoundException Thrown if the model to be saved isnot in the database.
 * @exception ModelAlreadyExistException Thrown if the new version name matchesa name of a model that is already in the database.
 * @exception IllegalArgumentException Thrown if the parameters passed are notproperly set.
 * @exception XMLDBModelParsingException Thrown if the MoML in the model objectis corrupted.
 * @exception CircularDependencyException Thrown if the save operation causes acircular dependency.
 */
public String saveWithParents(XMLDBModelWithReferenceChanges xmlDBModelWithReferenceChanges) throws DBConnectionException, DBExecutionException, DBModelNotFoundException, ModelAlreadyExistException, IllegalArgumentException, XMLDBModelParsingException, CircularDependencyException {
  String newModelId=""String_Node_Str"";
  if (xmlDBModelWithReferenceChanges == null || xmlDBModelWithReferenceChanges.getModelToBeSaved() == null || xmlDBModelWithReferenceChanges.getVersionName() == null || xmlDBModelWithReferenceChanges.getVersionName().length() == 0 || xmlDBModelWithReferenceChanges.getParentsList() == null || xmlDBModelWithReferenceChanges.getParentsList().size() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  DBConnection dbConnection=null;
  try {
    dbConnection=DBConnectorFactory.getSyncConnection(true);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    GetModelTask getModelTask=new GetModelTask(xmlDBModelWithReferenceChanges.getModelToBeSaved().getModelName());
    XMLDBModel dbModelToBeSaved=dbConnection.executeGetModelTask(getModelTask);
    XMLDBModel newXMLDBModel=new XMLDBModel(xmlDBModelWithReferenceChanges.getVersionName());
    newXMLDBModel.setIsNew(true);
    newXMLDBModel.setModel(dbModelToBeSaved.getModel());
    newModelId=save(newXMLDBModel,dbConnection);
    newXMLDBModel.setModelId(newModelId);
    UpdateParentsToNewVersionTask updateParentsToNewVersionTask=new UpdateParentsToNewVersionTask();
    updateParentsToNewVersionTask.setNewModel(newXMLDBModel);
    updateParentsToNewVersionTask.setOldModel(xmlDBModelWithReferenceChanges.getModelToBeSaved());
    updateParentsToNewVersionTask.setParentsList(xmlDBModelWithReferenceChanges.getParentsList());
    dbConnection.executeUpdateParentsToNewVersion(updateParentsToNewVersionTask);
    save(xmlDBModelWithReferenceChanges.getModelToBeSaved(),dbConnection);
  }
 catch (  DBConnectionException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  DBExecutionException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  MethodNotFoundException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  ModelAlreadyExistException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  IllegalArgumentException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  XMLDBModelParsingException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  return newModelId;
}","/** 
 * Save a model but keep a list of models that reference it point to the old model and update the rest of the models.
 * @param xmlDBModelWithReferenceChanges An object that contains the modelto be saved, the list of parents that should have the old reference, and the new version name that will be placed as a reference in the parents' list.
 * @return A string that represents the model Id of the newly created model.
 * @exception DBConnectionException Thrown if the connection to the databasefails.
 * @exception DBExecutionException Thrown if the operation fails to execute.
 * @exception DBModelNotFoundException Thrown if the model to be saved isnot in the database.
 * @exception ModelAlreadyExistException Thrown if the new version name matchesa name of a model that is already in the database.
 * @exception IllegalArgumentException Thrown if the parameters passed are notproperly set.
 * @exception XMLDBModelParsingException Thrown if the MoML in the model objectis corrupted.
 * @exception CircularDependencyException Thrown if the save operation causes acircular dependency.
 */
public String saveWithParents(XMLDBModelWithReferenceChanges xmlDBModelWithReferenceChanges) throws DBConnectionException, DBExecutionException, DBModelNotFoundException, ModelAlreadyExistException, IllegalArgumentException, XMLDBModelParsingException, CircularDependencyException {
  String newModelId=""String_Node_Str"";
  if (xmlDBModelWithReferenceChanges == null || xmlDBModelWithReferenceChanges.getModelToBeSaved() == null || xmlDBModelWithReferenceChanges.getVersionName() == null || xmlDBModelWithReferenceChanges.getVersionName().length() == 0 || xmlDBModelWithReferenceChanges.getParentsList() == null || xmlDBModelWithReferenceChanges.getParentsList().size() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  DBConnection dbConnection=null;
  try {
    dbConnection=DBConnectorFactory.getSyncConnection(true);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    GetModelTask getModelTask=new GetModelTask(xmlDBModelWithReferenceChanges.getModelToBeSaved().getModelName());
    XMLDBModel dbModelToBeSaved=dbConnection.executeGetModelTask(getModelTask);
    XMLDBModel newXMLDBModel=new XMLDBModel(xmlDBModelWithReferenceChanges.getVersionName());
    newXMLDBModel.setIsNew(true);
    newXMLDBModel.setModel(dbModelToBeSaved.getModel());
    newModelId=save(newXMLDBModel,dbConnection);
    newXMLDBModel.setModelId(newModelId);
    UpdateParentsToNewVersionTask updateParentsToNewVersionTask=new UpdateParentsToNewVersionTask();
    updateParentsToNewVersionTask.setNewModel(newXMLDBModel);
    updateParentsToNewVersionTask.setOldModel(xmlDBModelWithReferenceChanges.getModelToBeSaved());
    updateParentsToNewVersionTask.setParentsList(xmlDBModelWithReferenceChanges.getParentsList());
    dbConnection.executeUpdateParentsToNewVersion(updateParentsToNewVersionTask);
    save(xmlDBModelWithReferenceChanges.getModelToBeSaved(),dbConnection);
    dbConnection.commitConnection();
  }
 catch (  DBConnectionException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  DBExecutionException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  MethodNotFoundException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  ModelAlreadyExistException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  IllegalArgumentException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
catch (  XMLDBModelParsingException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw e;
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  return newModelId;
}"
73662,"protected void _addMenus(){
  this.setJMenuBar(_menuBar);
  _fileMenu=new JMenu(""String_Node_Str"");
  _fileMenu.setMnemonic(KeyEvent.VK_F);
  _menuBar.add(_fileMenu);
  GUIUtilities.addHotKey(this.getRootPane(),_newSearchCriteriaAction);
  GUIUtilities.addMenuItem(_fileMenu,_newSearchCriteriaAction);
  GUIUtilities.addHotKey(this.createRootPane(),_openSearchCriteriaAction);
  GUIUtilities.addMenuItem(_fileMenu,_openSearchCriteriaAction);
  GUIUtilities.addHotKey(this.createRootPane(),_saveSearchCriteriaAction);
  GUIUtilities.addMenuItem(_fileMenu,_saveSearchCriteriaAction);
  GUIUtilities.addHotKey(this.createRootPane(),_saveAsSearchCriteriaAction);
  GUIUtilities.addMenuItem(_fileMenu,_saveAsSearchCriteriaAction);
  GUIUtilities.addHotKey(this.getRootPane(),_exitSearchCriteriaAction);
  GUIUtilities.addMenuItem(_fileMenu,_exitSearchCriteriaAction);
}","/** 
 * Add menus to the menu bar.
 */
protected void _addMenus(){
  this.setJMenuBar(_menuBar);
  _fileMenu=new JMenu(""String_Node_Str"");
  _fileMenu.setMnemonic(KeyEvent.VK_F);
  _menuBar.add(_fileMenu);
  GUIUtilities.addHotKey(this.getRootPane(),_newSearchCriteriaAction);
  GUIUtilities.addMenuItem(_fileMenu,_newSearchCriteriaAction);
  GUIUtilities.addHotKey(this.createRootPane(),_openSearchCriteriaAction);
  GUIUtilities.addMenuItem(_fileMenu,_openSearchCriteriaAction);
  GUIUtilities.addHotKey(this.createRootPane(),_saveSearchCriteriaAction);
  GUIUtilities.addMenuItem(_fileMenu,_saveSearchCriteriaAction);
  GUIUtilities.addHotKey(this.createRootPane(),_saveAsSearchCriteriaAction);
  GUIUtilities.addMenuItem(_fileMenu,_saveAsSearchCriteriaAction);
  GUIUtilities.addHotKey(this.getRootPane(),_exitSearchCriteriaAction);
  GUIUtilities.addMenuItem(_fileMenu,_exitSearchCriteriaAction);
}"
73663,"protected void _open(){
  JFileChooser chooser=new JFileChooser();
  FileFilter filter=new SearchCriteriaFileFilter(""String_Node_Str"");
  chooser.setFileFilter(filter);
  chooser.setDialogTitle(""String_Node_Str"");
  int returnVal=chooser.showOpenDialog(this);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    try {
      if (isModified()) {
        Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int n=JOptionPane.showOptionDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
        if (n == JOptionPane.YES_OPTION) {
          _save();
        }
 else         if (n == JOptionPane.CANCEL_OPTION) {
          return;
        }
      }
      _searchCriteria.setModelName(""String_Node_Str"");
      try {
        StringParameter test=new StringParameter(new NamedObj(),""String_Node_Str"");
        test.setName(""String_Node_Str"");
        test.setExpression(""String_Node_Str"");
        ArrayList<Attribute> list=new ArrayList();
        list.add(test);
        _searchCriteria.setAttributes(list);
      }
 catch (      IllegalActionException e) {
      }
catch (      NameDuplicationException e) {
      }
      _topPanel.removeAll();
      _attributesListPanel=new AttributesListPanel(new NamedObj());
      _topPanel.add(_attributesListPanel);
      validate();
      repaint();
      if (_searchCriteria.getModelName() != null) {
        _attributesListPanel.setModelName(_searchCriteria.getModelName());
      }
      if (_searchCriteria.getAttributes() != null) {
        for (        Attribute attribute : _searchCriteria.getAttributes()) {
          _attributesListPanel.addAttribute((StringParameter)attribute);
        }
      }
      _saveLocation=chooser.getSelectedFile().getCanonicalPath();
      setModified(false);
    }
 catch (    IOException e) {
      MessageHandler.error(""String_Node_Str"",e);
    }
  }
}","/** 
 * Open a previously saved search criteria file.  If the currently opened search criteria was changed, give the user an opportunity to save it.
 */
protected void _open(){
  JFileChooser chooser=new JFileChooser();
  FileFilter filter=new SearchCriteriaFileFilter(""String_Node_Str"");
  chooser.setFileFilter(filter);
  chooser.setDialogTitle(""String_Node_Str"");
  int returnVal=chooser.showOpenDialog(this);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    try {
      if (isModified()) {
        Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int n=JOptionPane.showOptionDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
        if (n == JOptionPane.YES_OPTION) {
          _save();
        }
 else         if (n == JOptionPane.CANCEL_OPTION) {
          return;
        }
      }
      _searchCriteria.setModelName(""String_Node_Str"");
      try {
        StringParameter test=new StringParameter(new NamedObj(),""String_Node_Str"");
        test.setName(""String_Node_Str"");
        test.setExpression(""String_Node_Str"");
        ArrayList<Attribute> list=new ArrayList();
        list.add(test);
        _searchCriteria.setAttributes(list);
      }
 catch (      IllegalActionException e) {
      }
catch (      NameDuplicationException e) {
      }
      _topPanel.removeAll();
      _attributesListPanel=new AttributesListPanel(new NamedObj());
      _topPanel.add(_attributesListPanel);
      validate();
      repaint();
      if (_searchCriteria.getModelName() != null) {
        _attributesListPanel.setModelName(_searchCriteria.getModelName());
      }
      if (_searchCriteria.getAttributes() != null) {
        for (        Attribute attribute : _searchCriteria.getAttributes()) {
          _attributesListPanel.addAttribute((StringParameter)attribute);
        }
      }
      _saveLocation=chooser.getSelectedFile().getCanonicalPath();
      setModified(false);
    }
 catch (    IOException e) {
      MessageHandler.error(""String_Node_Str"",e);
    }
  }
}"
73664,"protected void _new(){
  if (isModified()) {
    Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    int n=JOptionPane.showOptionDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
    if (n == JOptionPane.YES_OPTION) {
      _save();
    }
 else     if (n == JOptionPane.CANCEL_OPTION) {
      return;
    }
  }
  _topPanel.removeAll();
  _attributesListPanel=new AttributesListPanel(new NamedObj());
  _topPanel.add(_attributesListPanel);
  validate();
  repaint();
  _saveLocation=null;
  _searchCriteria=new SearchCriteria();
  setModified(false);
}","/** 
 * Create new search criteria.  If the currently opened search criteria is changed, give the user an opportunity to save it.
 */
protected void _new(){
  if (isModified()) {
    Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    int n=JOptionPane.showOptionDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
    if (n == JOptionPane.YES_OPTION) {
      _save();
    }
 else     if (n == JOptionPane.CANCEL_OPTION) {
      return;
    }
  }
  _topPanel.removeAll();
  _attributesListPanel=new AttributesListPanel(new NamedObj());
  _topPanel.add(_attributesListPanel);
  validate();
  repaint();
  _saveLocation=null;
  _searchCriteria=new SearchCriteria();
  setModified(false);
}"
73665,"protected void _saveAs(){
  try {
    JFileChooser chooser=new JFileChooser();
    FileFilter filter=new SearchCriteriaFileFilter(""String_Node_Str"");
    chooser.setFileFilter(filter);
    chooser.setDialogTitle(""String_Node_Str"");
    if (_saveLocation != null) {
      chooser.setSelectedFile(new File(_saveLocation));
    }
    boolean saveComplete=false;
    while (!saveComplete) {
      if (chooser.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) {
        return;
      }
 else {
        File filename=chooser.getSelectedFile();
        if (filename.exists() && !filename.getCanonicalFile().toString().equals(_saveLocation)) {
          Object[] options={""String_Node_Str"",""String_Node_Str""};
          int n=JOptionPane.showOptionDialog(this,filename.toString() + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE,null,options,options[1]);
          if (n == JOptionPane.YES_OPTION) {
            saveComplete=true;
          }
 else {
            saveComplete=false;
          }
        }
 else {
          saveComplete=true;
        }
        if (saveComplete) {
          _saveLocation=chooser.getSelectedFile().getCanonicalPath();
          setModified(false);
        }
      }
    }
  }
 catch (  IOException e) {
    MessageHandler.error(""String_Node_Str"",e);
  }
}","/** 
 * Save the currently opened search criteria to a new location.
 */
protected void _saveAs(){
  try {
    JFileChooser chooser=new JFileChooser();
    FileFilter filter=new SearchCriteriaFileFilter(""String_Node_Str"");
    chooser.setFileFilter(filter);
    chooser.setDialogTitle(""String_Node_Str"");
    if (_saveLocation != null) {
      chooser.setSelectedFile(new File(_saveLocation));
    }
    boolean saveComplete=false;
    while (!saveComplete) {
      if (chooser.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) {
        return;
      }
 else {
        File filename=chooser.getSelectedFile();
        if (filename.exists() && !filename.getCanonicalFile().toString().equals(_saveLocation)) {
          Object[] options={""String_Node_Str"",""String_Node_Str""};
          int n=JOptionPane.showOptionDialog(this,filename.toString() + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE,null,options,options[1]);
          if (n == JOptionPane.YES_OPTION) {
            saveComplete=true;
          }
 else {
            saveComplete=false;
          }
        }
 else {
          saveComplete=true;
        }
        if (saveComplete) {
          _saveLocation=chooser.getSelectedFile().getCanonicalPath();
          setModified(false);
        }
      }
    }
  }
 catch (  IOException e) {
    MessageHandler.error(""String_Node_Str"",e);
  }
}"
73666,"protected void _exit(){
  if (isModified()) {
    Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    int n=JOptionPane.showOptionDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
    if (n == JOptionPane.YES_OPTION) {
      _save();
    }
 else     if (n == JOptionPane.CANCEL_OPTION) {
      return;
    }
  }
  dispose();
}","/** 
 * Exit the window.  If the search criteria was changed, give the user an opportunity to save it.
 */
protected void _exit(){
  if (isModified()) {
    Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    int n=JOptionPane.showOptionDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
    if (n == JOptionPane.YES_OPTION) {
      _save();
    }
 else     if (n == JOptionPane.CANCEL_OPTION) {
      return;
    }
  }
  dispose();
}"
73667,"protected void _initActorGraphDBFrame(){
  _newSearchCriteriaAction=new NewSearchCriteriaAction();
  _openSearchCriteriaAction=new OpenSearchCriteriaAction();
  _saveSearchCriteriaAction=new SaveSearchCriteriaAction();
  _saveAsSearchCriteriaAction=new SaveAsSearchCriteriaAction();
  _exitSearchCriteriaAction=new ExitSearchCriteriaAction();
}","/** 
 * Establish all event listeners.
 */
protected void _initActorGraphDBFrame(){
  _newSearchCriteriaAction=new NewSearchCriteriaAction();
  _openSearchCriteriaAction=new OpenSearchCriteriaAction();
  _saveSearchCriteriaAction=new SaveSearchCriteriaAction();
  _saveAsSearchCriteriaAction=new SaveAsSearchCriteriaAction();
  _exitSearchCriteriaAction=new ExitSearchCriteriaAction();
}"
73668,"protected void _save(){
  if (_saveLocation == null) {
    _saveAs();
  }
 else {
  }
}","/** 
 * Save the currently opened search criteria.
 */
protected void _save(){
  if (_saveLocation == null) {
    _saveAs();
  }
 else {
  }
}"
73669,"/** 
 * Execute the given task to fetch the first level parents for the given  model. First level parents are models that are immediate parents for the given  model.
 * @param model Model for which the first level parents list needs to be fetched.
 * @return List of models that are the first-level parents of the given model.
 * @throws DBExecutionException If thrown while fetching the parents list from the database.
 */
public List<XMLDBModel> executeGetFirstLevelParents(GetFirstLevelParentsTask task) throws DBExecutionException {
  String references=null;
  ArrayList<XMLDBModel> parentsList=new ArrayList<XMLDBModel>();
  XMLDBModel model=task.getModel();
  try {
    XmlQueryContext xmlContext=_xmlManager.createQueryContext();
    String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + model.getModelName() + ""String_Node_Str"";
    XmlQueryExpression queryExpression=_xmlManager.prepare(query,xmlContext);
    XmlResults results=queryExpression.execute(xmlContext);
    if (results != null && results.size() > 0) {
      XmlValue xmlValue=results.next();
      references=""String_Node_Str"" + xmlValue.asString() + ""String_Node_Str"";
      Node entitiesNode=Utilities.parseXML(references);
      NodeList entityList=entitiesNode.getChildNodes();
      for (int i=0; i < entityList.getLength(); i++) {
        Node entity=entityList.item(i);
        String parentName=Utilities.getValueForAttribute(entity,XMLDBModel.DB_MODEL_NAME);
        String parentId=Utilities.getValueForAttribute(entity,XMLDBModel.DB_MODEL_ID_ATTR);
        parentsList.add(new XMLDBModel(parentName,parentId));
      }
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  XMLDBModelParsingException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
  return parentsList;
}","/** 
 * Execute the given task to fetch the first level parents for the given  model. First level parents are models that are immediate parents for the given  model.
 * @param model Model for which the first level parents list needs to be fetched.
 * @return List of models that are the first-level parents of the given model.
 * @throws DBExecutionException If thrown while fetching the parents list from the database.
 */
public List<XMLDBModel> executeGetFirstLevelParents(GetFirstLevelParentsTask task) throws DBExecutionException {
  String references=null;
  ArrayList<XMLDBModel> parentsList=new ArrayList<XMLDBModel>();
  HashSet alreadyFetchedParents=new HashSet();
  XMLDBModel model=task.getModel();
  try {
    XmlQueryContext xmlContext=_xmlManager.createQueryContext();
    String query=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ model.getModelName()+ ""String_Node_Str"";
    XmlQueryExpression queryExpression=_xmlManager.prepare(query,xmlContext);
    XmlResults results=queryExpression.execute(xmlContext);
    if (results != null && results.size() > 0) {
      XmlValue xmlValue=results.next();
      references=""String_Node_Str"" + xmlValue.asString() + ""String_Node_Str"";
      Node entitiesNode=Utilities.parseXML(references);
      NodeList entityList=entitiesNode.getChildNodes();
      for (int i=0; i < entityList.getLength(); i++) {
        Node entity=entityList.item(i);
        String parentName=Utilities.getValueForAttribute(entity,XMLDBModel.DB_MODEL_NAME);
        String parentId=Utilities.getValueForAttribute(entity,XMLDBModel.DB_MODEL_ID_ATTR);
        if (!alreadyFetchedParents.contains(parentName)) {
          parentsList.add(new XMLDBModel(parentName,parentId));
          alreadyFetchedParents.add(parentName);
        }
      }
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  XMLDBModelParsingException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
  return parentsList;
}"
73670,"/** 
 * Execute the given task to update the referenced version for the given  parents from the old model to the new model. 
 * @param task Task that contains the list of parents, the old model and the new model.
 * @throws DBExecutionException If thrown while updating the parents in the database.
 */
public void executeUpdateParentsToNewVersion(UpdateParentsToNewVersionTask task) throws DBExecutionException {
  String newModelId=task.getNewModel().getModelId();
  String newModelName=task.getNewModel().getModelName();
  if (newModelId == null || newModelId.length() == 0) {
    newModelId=_getModelIdFromModelName(newModelName);
  }
  String propertyString=Utilities.getPropertyString(XMLDBModel.DB_MODEL_ID_ATTR,newModelName);
  String oldModelId=task.getOldModel().getModelId();
  for (  String parentName : task.getParentsList()) {
    String parentsQuery=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ parentName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ XMLDBModel.DB_REFERENCE_ATTR+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ XMLDBModel.DB_MODEL_ID_ATTR+ ""String_Node_Str""+ ""String_Node_Str""+ oldModelId+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ propertyString;
    try {
      XmlQueryContext xmlQueryContext=_xmlManager.createQueryContext();
      _xmlManager.query(_xmlTransaction,parentsQuery,xmlQueryContext,null);
    }
 catch (    XmlException e) {
      throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
    String referenceString=_getModelReferences(newModelId);
    String referenceFileQuery=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ ""String_Node_Str""+ newModelName+ ""String_Node_Str""+ parentName+ ""String_Node_Str""+ ""String_Node_Str""+ newModelName+ ""String_Node_Str""+ referenceString;
    try {
      XmlQueryContext xmlQueryContext=_xmlManager.createQueryContext();
      _xmlManager.query(_xmlTransaction,referenceFileQuery,xmlQueryContext,null);
    }
 catch (    XmlException e) {
      throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
}","/** 
 * Execute the given task to update the referenced version for the given  parents from the old model to the new model. 
 * @param task Task that contains the list of parents, the old model and the new model.
 * @throws DBExecutionException If thrown while updating the parents in the database.
 */
public void executeUpdateParentsToNewVersion(UpdateParentsToNewVersionTask task) throws DBExecutionException {
  if (task.getNewModel() == null || task.getOldModel() == null || task.getParentsList() == null) {
    throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  String newModelId=task.getNewModel().getModelId();
  String newModelName=task.getNewModel().getModelName();
  if (newModelId == null || newModelId.length() == 0) {
    newModelId=_getModelIdFromModelName(newModelName);
  }
  String oldModelId=task.getOldModel().getModelId();
  String oldModelName=task.getOldModel().getModelName();
  if (oldModelId == null || oldModelId.length() == 0) {
    oldModelId=_getModelIdFromModelName(oldModelName);
  }
  String propertyString=Utilities.getPropertyString(XMLDBModel.DB_MODEL_ID_ATTR,newModelId);
  for (  String parentName : task.getParentsList()) {
    String parentsQuery=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ parentName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ XMLDBModel.DB_REFERENCE_ATTR+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ XMLDBModel.DB_MODEL_ID_ATTR+ ""String_Node_Str""+ ""String_Node_Str""+ oldModelId+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ propertyString;
    try {
      XmlQueryContext xmlQueryContext=_xmlManager.createQueryContext();
      _xmlManager.query(_xmlTransaction,parentsQuery,xmlQueryContext,null);
    }
 catch (    XmlException e) {
      throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
    String referenceString=_getModelReferences(newModelId);
    String referenceFileQuery=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ ""String_Node_Str""+ oldModelName+ ""String_Node_Str""+ parentName+ ""String_Node_Str""+ ""String_Node_Str""+ oldModelName+ ""String_Node_Str""+ referenceString;
    try {
      XmlQueryContext xmlQueryContext=_xmlManager.createQueryContext();
      _xmlManager.query(_xmlTransaction,referenceFileQuery,xmlQueryContext,null);
    }
 catch (    XmlException e) {
      throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
}"
73671,"/** 
 * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
 */
private void initComponents(){
  _jLabel1=new javax.swing.JLabel();
  _jLabel2=new javax.swing.JLabel();
  _directoryPathTextField=new javax.swing.JTextField();
  _browseButton=new javax.swing.JButton();
  _migrateButton=new javax.swing.JButton();
  _doneButton=new javax.swing.JButton();
  _resultsTextField=new javax.swing.JTextField();
  _jLabel3=new javax.swing.JLabel();
  _jLabel4=new javax.swing.JLabel();
  _jLabel5=new javax.swing.JLabel();
  setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
  _jLabel1.setText(""String_Node_Str"");
  _jLabel2.setText(""String_Node_Str"");
  _browseButton.setText(""String_Node_Str"");
  _browseButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      browseButtonActionPerformed(evt);
    }
  }
);
  _migrateButton.setText(""String_Node_Str"");
  _migrateButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      migrateButtonActionPerformed(evt);
    }
  }
);
  _doneButton.setText(""String_Node_Str"");
  _doneButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      doneButtonActionPerformed(evt);
    }
  }
);
  _resultsTextField.setBorder(javax.swing.BorderFactory.createEtchedBorder(javax.swing.border.EtchedBorder.RAISED));
  _resultsTextField.setEnabled(false);
  _jLabel3.setText(""String_Node_Str"");
  _jLabel4.setText(""String_Node_Str"");
  _jLabel5.setText(""String_Node_Str"");
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(getContentPane());
  getContentPane().setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(_resultsTextField,javax.swing.GroupLayout.DEFAULT_SIZE,463,Short.MAX_VALUE).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(_jLabel2).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_directoryPathTextField,javax.swing.GroupLayout.PREFERRED_SIZE,271,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(_browseButton)).addGroup(layout.createSequentialGroup().addGap(146,146,146).addComponent(_migrateButton).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_doneButton,javax.swing.GroupLayout.PREFERRED_SIZE,72,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,150,javax.swing.GroupLayout.PREFERRED_SIZE))).addContainerGap()).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(_jLabel1,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap().addComponent(_jLabel3,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(_jLabel5,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(_jLabel4,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap().addComponent(_jLabel3).addGap(4,4,4).addComponent(_jLabel4).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_jLabel5).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,30,Short.MAX_VALUE).addComponent(_jLabel1).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(_jLabel2).addComponent(_directoryPathTextField,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_browseButton)).addGap(18,18,18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(_migrateButton).addComponent(_doneButton)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_resultsTextField,javax.swing.GroupLayout.PREFERRED_SIZE,27,javax.swing.GroupLayout.PREFERRED_SIZE)));
  pack();
}","/** 
 * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
 */
private void initComponents(){
  _jLabel1=new javax.swing.JLabel();
  _jLabel2=new javax.swing.JLabel();
  _directoryPathTextField=new javax.swing.JTextField();
  _browseButton=new javax.swing.JButton();
  _migrateButton=new javax.swing.JButton();
  _doneButton=new javax.swing.JButton();
  _resultsTextField=new javax.swing.JTextField();
  _jLabel3=new javax.swing.JLabel();
  _jLabel4=new javax.swing.JLabel();
  _jLabel5=new javax.swing.JLabel();
  setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
  _jLabel1.setText(""String_Node_Str"");
  _jLabel2.setText(""String_Node_Str"");
  _browseButton.setText(""String_Node_Str"");
  _browseButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      browseButtonActionPerformed(evt);
    }
  }
);
  _migrateButton.setText(""String_Node_Str"");
  _migrateButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      migrateButtonActionPerformed(evt);
    }
  }
);
  _doneButton.setText(""String_Node_Str"");
  _doneButton.setVisible(false);
  _doneButton.addActionListener(new java.awt.event.ActionListener(){
    public void actionPerformed(    java.awt.event.ActionEvent evt){
      doneButtonActionPerformed(evt);
    }
  }
);
  _resultsTextField.setBorder(javax.swing.BorderFactory.createEtchedBorder(javax.swing.border.EtchedBorder.RAISED));
  _resultsTextField.setEditable(false);
  _jLabel3.setText(""String_Node_Str"");
  _jLabel4.setText(""String_Node_Str"");
  _jLabel5.setText(""String_Node_Str"");
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(getContentPane());
  getContentPane().setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(_resultsTextField,javax.swing.GroupLayout.DEFAULT_SIZE,463,Short.MAX_VALUE).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(_jLabel2).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_directoryPathTextField,javax.swing.GroupLayout.PREFERRED_SIZE,271,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(_browseButton)).addGroup(layout.createSequentialGroup().addGap(146,146,146).addComponent(_migrateButton).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_doneButton,javax.swing.GroupLayout.PREFERRED_SIZE,72,javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,150,javax.swing.GroupLayout.PREFERRED_SIZE))).addContainerGap()).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(_jLabel1,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap().addComponent(_jLabel3,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(_jLabel5,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(_jLabel4,javax.swing.GroupLayout.DEFAULT_SIZE,443,Short.MAX_VALUE).addContainerGap()));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap().addComponent(_jLabel3).addGap(4,4,4).addComponent(_jLabel4).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_jLabel5).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,30,Short.MAX_VALUE).addComponent(_jLabel1).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(_jLabel2).addComponent(_directoryPathTextField,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_browseButton)).addGap(18,18,18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(_migrateButton).addComponent(_doneButton)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(_resultsTextField,javax.swing.GroupLayout.PREFERRED_SIZE,27,javax.swing.GroupLayout.PREFERRED_SIZE)));
  pack();
}"
73672,"/** 
 * Update the existing database connection parameters with the given parameters.
 * @param params The new database connection parameters.
 * @exception DBConnectionException Thrown if the connection fails.
 * @exception IOException Thrown if an error occurs while writing the newparameters.
 */
public void updateDBConnectionSetupParameters(SetupParameters params) throws DBConnectionException, IOException {
  if (params == null) {
    throw new DBConnectionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String ptdbParams=DBConnectorFactory._PROPERTIES_FILE_PATH;
  Properties props=new Properties();
  File tempFile=FileUtilities.nameToFile(ptdbParams,null);
  File file=new File(tempFile.getPath().replaceAll(""String_Node_Str"",""String_Node_Str""));
  if (file.exists() == false) {
    file.createNewFile();
  }
  URL url=FileUtilities.nameToURL(ptdbParams,null,null);
  if (url == null) {
    throw new IOException(""String_Node_Str"" + ptdbParams);
  }
  String defaultDBClassName=""String_Node_Str"";
  props.load(url.openStream());
  String dbClassName=(String)props.getProperty(DBConnectorFactory._DB_CLASS_NAME);
  if (dbClassName == null || dbClassName.length() == 0) {
    dbClassName=defaultDBClassName;
  }
  props.setProperty(DBConnectorFactory._DB_CLASS_NAME,dbClassName);
  props.setProperty(DBConnectorFactory._DB_URL,params.getUrl());
  props.setProperty(DBConnectorFactory._XMLDB_CONTAINER_NAME,params.getContainerName());
  props.setProperty(DBConnectorFactory._CACHE_CONTAINER_NAME,params.getCacheContainerName());
  props.store(new FileOutputStream(url.getPath().replaceAll(""String_Node_Str"",""String_Node_Str"")),null);
  DBConnectorFactory.loadDBProperties();
}","/** 
 * Update the existing database connection parameters with the given parameters.
 * @param params The new database connection parameters.
 * @exception DBConnectionException Thrown if the connection fails.
 * @exception IOException Thrown if an error occurs while writing the newparameters.
 */
public void updateDBConnectionSetupParameters(SetupParameters params) throws DBConnectionException, IOException {
  if (params == null) {
    throw new DBConnectionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String ptdbParams=DBConnectorFactory._PROPERTIES_FILE_PATH;
  Properties props=new Properties();
  File tempFile=FileUtilities.nameToFile(ptdbParams,null);
  File file=new File(tempFile.getPath().replaceAll(""String_Node_Str"",""String_Node_Str""));
  if (file.exists() == false) {
    if (file.createNewFile() == false) {
      throw new IOException(""String_Node_Str"" + ptdbParams);
    }
  }
  URL url=FileUtilities.nameToURL(ptdbParams,null,null);
  if (url == null) {
    throw new IOException(""String_Node_Str"" + ptdbParams);
  }
  String defaultDBClassName=""String_Node_Str"";
  props.load(url.openStream());
  String dbClassName=(String)props.getProperty(DBConnectorFactory._DB_CLASS_NAME);
  if (dbClassName == null || dbClassName.length() == 0) {
    dbClassName=defaultDBClassName;
  }
  props.setProperty(DBConnectorFactory._DB_CLASS_NAME,dbClassName);
  props.setProperty(DBConnectorFactory._DB_URL,params.getUrl());
  props.setProperty(DBConnectorFactory._XMLDB_CONTAINER_NAME,params.getContainerName());
  props.setProperty(DBConnectorFactory._CACHE_CONTAINER_NAME,params.getCacheContainerName());
  props.store(new FileOutputStream(url.getPath().replaceAll(""String_Node_Str"",""String_Node_Str"")),null);
  DBConnectorFactory.loadDBProperties();
}"
73673,"/** 
 * Test the migrateModels() method in the case when the given path is incorrect.
 * @exception Exception Thrown by PowerMock if error occurs in the testing.
 */
@Test public void testMigrateModelsIncorrectPath() throws Exception {
  String directoryPath=""String_Node_Str"";
  MigrateModelsManager migrateModelsManager=new MigrateModelsManager();
  try {
    String csvFilePath=migrateModelsManager.migrateModels(directoryPath);
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
    assertTrue(true);
  }
}","/** 
 * Test the migrateModels() method in the case when the given path is incorrect.
 * @exception Exception Thrown by PowerMock if error occurs in the testing.
 */
@Test public void testMigrateModelsIncorrectPath() throws Exception {
  String directoryPath=""String_Node_Str"";
  MigrateModelsManager migrateModelsManager=new MigrateModelsManager();
  try {
    migrateModelsManager.migrateModels(directoryPath);
    fail(""String_Node_Str"");
  }
 catch (  IOException e) {
    assertTrue(true);
  }
}"
73674,"/** 
 * Test the migrateModels() method in the case when the given path is correct and it contains only the models with no sub directories.
 * @exception Exception Thrown by PowerMock if error occurs in the testing.
 */
@Test public void testMigrateModelsFirstLevel() throws Exception {
  String directoryPath=createDirectory(0,3);
  MigrateModelsManager migrateModelsManager=new MigrateModelsManager();
  try {
    String csvFilePath=migrateModelsManager.migrateModels(directoryPath);
    assertTrue(csvFilePath.equals(directoryPath + ""String_Node_Str""));
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    deleteDirectory(directoryPath);
  }
}","/** 
 * Test the migrateModels() method in the case when the given path is correct and it contains only the models with no sub directories.
 * @exception Exception Thrown by PowerMock if error occurs in the testing.
 */
@Test public void testMigrateModelsFirstLevel() throws Exception {
  String directoryPath=createDirectory(0,3);
  MigrateModelsManager migrateModelsManager=new MigrateModelsManager();
  try {
    String csvFilePath=migrateModelsManager.migrateModels(directoryPath);
    assertTrue(csvFilePath.equals(directoryPath + ""String_Node_Str""));
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    deleteDirectory(directoryPath);
  }
}"
73675,"/** 
 * Test the migrateModels() method in the case when the given path is correct and it contains models at the first level and models inside a directory which is inside the current directory.
 * @exception Exception Thrown by PowerMock if error occurs in the testing.
 */
@Test public void testMigrateModelsDepth() throws Exception {
  String directoryPath=createDirectory(2,2);
  MigrateModelsManager migrateModelsManager=new MigrateModelsManager();
  try {
    String csvFilePath=migrateModelsManager.migrateModels(directoryPath);
    assertTrue(csvFilePath.equals(directoryPath + ""String_Node_Str""));
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    deleteDirectory(directoryPath);
  }
}","/** 
 * Test the migrateModels() method in the case when the given path is correct and it contains models at the first level and models inside a directory which is inside the current directory.
 * @exception Exception Thrown by PowerMock if error occurs in the testing.
 */
@Test public void testMigrateModelsDepth() throws Exception {
  String directoryPath=createDirectory(2,2);
  MigrateModelsManager migrateModelsManager=new MigrateModelsManager();
  try {
    String csvFilePath=migrateModelsManager.migrateModels(directoryPath);
    assertTrue(csvFilePath.equals(directoryPath + ""String_Node_Str""));
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    deleteDirectory(directoryPath);
  }
}"
73676,"/** 
 * Create a directory with levels of depth and models.
 * @param levels The number of levels of depth required to be created.
 * @param models The number of models to be created in each folder created.
 * @return The parent directory path of the directories created.
 * @exception IOException Thrown if the operation failed to create the folders or the models inside them.
 */
private String createDirectory(int levels,int models) throws IOException {
  String fileName=""String_Node_Str"";
  String fileContent=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + XMLDBModel.DB_MODEL_ID_ATTR + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ XMLDBModel.DB_REFERENCE_ATTR+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ XMLDBModel.DB_MODEL_ID_ATTR+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ XMLDBModel.DB_REFERENCE_ATTR+ ""String_Node_Str""+ ""String_Node_Str"";
  String directoryPath=StringUtilities.preferencesDirectory() + ""String_Node_Str"";
  File directory=new File(directoryPath);
  directory.mkdir();
  for (int i=0; i < models; i++) {
    FileWriter writer=new FileWriter(directoryPath + ""String_Node_Str"" + i+ ""String_Node_Str"");
    writer.write(fileContent);
    writer.flush();
    writer.close();
  }
  for (int i=0; i < levels; i++) {
    String subPath=directoryPath + ""String_Node_Str"" + i;
    File sub=new File(subPath);
    sub.mkdir();
    for (int j=0; j < models; j++) {
      FileWriter writer=new FileWriter(sub + ""String_Node_Str"" + i+ j+ ""String_Node_Str"");
      writer.write(fileContent);
      writer.flush();
      writer.close();
    }
  }
  return directoryPath;
}","/** 
 * Create a directory with levels of depth and models.
 * @param levels The number of levels of depth required to be created.
 * @param models The number of models to be created in each folder created.
 * @return The parent directory path of the directories created.
 * @exception IOException Thrown if the operation failed to create the folders or the models inside them.
 */
private String createDirectory(int levels,int models) throws IOException {
  String fileName=""String_Node_Str"";
  String fileContent=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + XMLDBModel.DB_MODEL_ID_ATTR + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ XMLDBModel.DB_REFERENCE_ATTR+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ XMLDBModel.DB_MODEL_ID_ATTR+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ XMLDBModel.DB_REFERENCE_ATTR+ ""String_Node_Str""+ ""String_Node_Str"";
  String directoryPath=StringUtilities.preferencesDirectory() + ""String_Node_Str"";
  File directory=new File(directoryPath);
  if (directory.mkdir()) {
    for (int i=0; i < models; i++) {
      FileWriter writer=new FileWriter(directoryPath + ""String_Node_Str"" + i+ ""String_Node_Str"");
      try {
        writer.write(fileContent);
        writer.flush();
      }
  finally {
        writer.close();
      }
    }
    for (int i=0; i < levels; i++) {
      String subPath=directoryPath + ""String_Node_Str"" + i;
      File sub=new File(subPath);
      if (sub.mkdir()) {
        for (int j=0; j < models; j++) {
          FileWriter writer=new FileWriter(sub + ""String_Node_Str"" + i+ j+ ""String_Node_Str"");
          try {
            writer.write(fileContent);
            writer.flush();
          }
  finally {
            writer.close();
          }
        }
      }
    }
  }
  return directoryPath;
}"
73677,"/** 
 * Migrate models from the file system stored in the given path to the database.
 * @param directoryPath The path on the file system where the models exist.
 * @return A string representing the path to the CSV file the contains the results of the migration.
 * @exception IOException Thrown if there is an error reading or writing files.
 */
public String migrateModels(String directoryPath) throws IOException {
  File directoryFile=new File(directoryPath);
  if (directoryFile.exists() == false) {
    throw new IOException(""String_Node_Str"" + directoryPath + ""String_Node_Str"");
  }
  String csvFilePath=directoryPath + System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  try {
    File csvFile=new File(csvFilePath);
    csvFile.createNewFile();
  }
 catch (  Exception e) {
    csvFilePath=StringUtilities.preferencesDirectory() + ""String_Node_Str"";
  }
  _csvFileWriter=new FileWriter(csvFilePath);
  _csvFileWriter.write(""String_Node_Str"" + System.getProperty(""String_Node_Str""));
  try {
    _readFiles(directoryFile);
  }
  finally {
    _csvFileWriter.flush();
    _csvFileWriter.close();
  }
  return csvFilePath;
}","/** 
 * Migrate models from the file system stored in the given path to the database.
 * @param directoryPath The path on the file system where the models exist.
 * @return A string representing the path to the CSV file the contains the results of the migration.
 * @exception IOException Thrown if there is an error reading or writing files.
 */
public String migrateModels(String directoryPath) throws IOException {
  File directoryFile=new File(directoryPath);
  if (directoryFile.exists() == false) {
    throw new IOException(""String_Node_Str"" + directoryPath + ""String_Node_Str"");
  }
  String csvFilePath=directoryPath + System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  try {
    File csvFile=new File(csvFilePath);
    csvFile.createNewFile();
  }
 catch (  IOException e) {
    csvFilePath=StringUtilities.preferencesDirectory() + ""String_Node_Str"";
  }
  _csvFileWriter=new FileWriter(csvFilePath);
  _csvFileWriter.write(""String_Node_Str"" + System.getProperty(""String_Node_Str""));
  try {
    _readFiles(directoryFile);
  }
  finally {
    _csvFileWriter.flush();
    _csvFileWriter.close();
  }
  return csvFilePath;
}"
73678,"/** 
 * Return the model name.
 * @see #setModelName
 */
public String getModelName(){
  return modelName;
}","/** 
 * Return the model name.
 * @return The model name.
 * @see #setModelName
 */
public String getModelName(){
  return modelName;
}"
73679,"/** 
 * Generate a main loop for an execution under the control of this director. If the associated director has a parameter named <i>iterations</i> with a value greater than zero, then wrap code generated by generateFireCode() in a loop that executes the specified number of iterations. Otherwise, wrap it in a loop that executes forever. In the loop, first get the code returned by generateFireCode(), and follow that with the code produced by the container help for generateModeTransitionCode(). That code will make state transitions in modal models at the conclusion of each iteration. Next, this code calls postfire(), and that returns false, breaks out of the main loop. Finally, if the director has a parameter named <i>period</i>, then increment the variable _currentTime after each pass through the loop.
 * @return Code for the main loop of an execution.
 * @exception IllegalActionException If something goes wrong.
 */
public String generateMainLoop() throws IllegalActionException {
  StringBuffer code=new StringBuffer(_eol + getCodeGenerator().getMethodVisibiliyString() + ""String_Node_Str""+ getCodeGenerator().getMethodExceptionString()+ ""String_Node_Str""+ _eol);
  Attribute iterations=_director.getAttribute(""String_Node_Str"");
  if (iterations == null) {
    code.append(_eol + ""String_Node_Str"" + _eol);
  }
 else {
    int iterationCount=((IntToken)((Variable)iterations).getToken()).intValue();
    if (iterationCount <= 0) {
      code.append(_eol + ""String_Node_Str"" + _eol);
    }
 else {
      code.append(_eol + ""String_Node_Str"" + _eol);
      code.append(""String_Node_Str"" + iterationCount + ""String_Node_Str""+ _eol);
    }
  }
  code.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ _eol+ getCodeGenerator().getMethodVisibiliyString()+ ""String_Node_Str""+ getCodeGenerator().getMethodExceptionString()+ ""String_Node_Str""+ _eol);
  code.append(generateFireCode());
  NamedProgramCodeGeneratorAdapter modelAdapter=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(_director.getContainer());
  modelAdapter.generateModeTransitionCode(code);
  _generateUpdatePortOffsetCode(code,(Actor)_director.getContainer());
  code.append(generatePostfireCode());
  code.append(""String_Node_Str"" + _eol);
  Attribute period=_director.getAttribute(""String_Node_Str"");
  if (period != null) {
    Double periodValue=((DoubleToken)((Variable)period).getToken()).doubleValue();
    if (periodValue != 0.0) {
      code.append(""String_Node_Str"" + periodValue + ""String_Node_Str""+ _eol);
    }
  }
  code.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  return code.toString();
}","/** 
 * Generate a main loop for an execution under the control of this director. If the associated director has a parameter named <i>iterations</i> with a value greater than zero, then wrap code generated by generateFireCode() in a loop that executes the specified number of iterations. Otherwise, wrap it in a loop that executes forever. In the loop, first get the code returned by generateFireCode(), and follow that with the code produced by the container help for generateModeTransitionCode(). That code will make state transitions in modal models at the conclusion of each iteration. Next, this code calls postfire(), and that returns false, breaks out of the main loop. Finally, if the director has a parameter named <i>period</i>, then increment the variable _currentTime after each pass through the loop.
 * @return Code for the main loop of an execution.
 * @exception IllegalActionException If something goes wrong.
 */
public String generateMainLoop() throws IllegalActionException {
  StringBuffer code=new StringBuffer(_eol + getCodeGenerator().getMethodVisibiliyString() + ""String_Node_Str""+ getCodeGenerator().getMethodExceptionString()+ ""String_Node_Str""+ _eol);
  Attribute iterations=_director.getAttribute(""String_Node_Str"");
  if (iterations == null) {
    code.append(_eol + ""String_Node_Str"" + _eol);
  }
 else {
    int iterationCount=((IntToken)((Variable)iterations).getToken()).intValue();
    if (iterationCount <= 0) {
      code.append(_eol + ""String_Node_Str"" + _eol);
    }
 else {
      code.append(_eol + ""String_Node_Str"" + _eol);
      code.append(""String_Node_Str"" + iterationCount + ""String_Node_Str""+ _eol);
    }
  }
  String[] splitFireCode=getCodeGenerator()._splitBody(""String_Node_Str"" + NamedProgramCodeGeneratorAdapter.generateName(getComponent()) + ""String_Node_Str"",generateFireCode());
  code.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ _eol+ splitFireCode[0]+ _eol+ getCodeGenerator().getMethodVisibiliyString()+ ""String_Node_Str""+ getCodeGenerator().getMethodExceptionString()+ ""String_Node_Str""+ _eol+ splitFireCode[1]);
  NamedProgramCodeGeneratorAdapter modelAdapter=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(_director.getContainer());
  modelAdapter.generateModeTransitionCode(code);
  _generateUpdatePortOffsetCode(code,(Actor)_director.getContainer());
  code.append(generatePostfireCode());
  code.append(""String_Node_Str"" + _eol);
  Attribute period=_director.getAttribute(""String_Node_Str"");
  if (period != null) {
    Double periodValue=((DoubleToken)((Variable)period).getToken()).doubleValue();
    if (periodValue != 0.0) {
      code.append(""String_Node_Str"" + periodValue + ""String_Node_Str""+ _eol);
    }
  }
  code.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  return code.toString();
}"
73680,"/** 
 * Specifies the input array that will read the buffer allocated as output.  Here we only check that everything is correct, and computes addresses in output buffer.
 * @param port the associated port
 * @param actor the associated actor
 * @exception IllegalActionException
 */
public void setInputArray(IOPort port,Actor actor) throws IllegalActionException {
  if (_buffer != null) {
    fillParameters(actor,port);
  }
}","/** 
 * Specifies the input array that will read the buffer allocated as output.  Here we only check that everything is correct, and computes addresses in output buffer.
 * @param port the associated port
 * @param actor the associated actor
 * @exception IllegalActionException
 */
public void setInputArray(IOPort port,Actor actor) throws IllegalActionException {
  if (!_dynamic && _buffer != null) {
    fillParameters(actor,port);
  }
}"
73681,"/** 
 * @exception IllegalActionException   
 * @exception NotSchedulableException
 */
protected Schedule _getSchedule() throws IllegalActionException, NotSchedulableException {
  PthalesDirector director=(PthalesDirector)getContainer();
  CompositeActor compositeActor=(CompositeActor)(director.getContainer());
  List<Actor> actors=compositeActor.deepEntityList();
  CompositeActor model=(CompositeActor)director.getContainer();
  _checkDynamicRateVariables(model,_rateVariables);
  for (  Actor actor : actors) {
    List<IOPort> ports=actor.outputPortList();
    for (    IOPort port : ports) {
      Receiver[][] receivers=port.getRemoteReceivers();
      if (receivers != null && receivers.length > 0) {
        for (        Receiver[] receiverss : receivers) {
          if (receiverss != null && receiverss.length > 0) {
            for (            Receiver receiver : receiverss) {
              if (receiver instanceof PthalesReceiver)               ((PthalesReceiver)receiver).setOutputArray(port,actor);
            }
          }
        }
      }
    }
    if (actor instanceof PthalesDynamicCompositeActor)     continue;
    ports=actor.inputPortList();
    for (    IOPort port : ports) {
      Receiver[][] receivers=port.getReceivers();
      if (receivers != null && receivers.length > 0) {
        for (        Receiver[] receiverss : receivers) {
          if (receiverss != null && receiverss.length > 0) {
            for (            Receiver receiver : receiverss) {
              ((PthalesReceiver)receiver).setInputArray(port,actor);
            }
          }
        }
      }
    }
  }
  Schedule schedule=new Schedule();
  CausalityInterfaceForComposites causality=(CausalityInterfaceForComposites)compositeActor.getCausalityInterface();
  List<Actor> sortedActors=causality.topologicalSort();
  for (  Actor actor : sortedActors) {
    Firing firing=new Firing(actor);
    firing.setIterationCount(PthalesAtomicActor.getIteration((ComponentEntity)actor));
    schedule.add(firing);
  }
  return schedule;
}","/** 
 * @exception IllegalActionException   
 * @exception NotSchedulableException
 */
protected Schedule _getSchedule() throws IllegalActionException, NotSchedulableException {
  PthalesDirector director=(PthalesDirector)getContainer();
  CompositeActor compositeActor=(CompositeActor)(director.getContainer());
  List<Actor> actors=compositeActor.deepEntityList();
  CompositeActor model=(CompositeActor)director.getContainer();
  _checkDynamicRateVariables(model,_rateVariables);
  for (  Actor actor : actors) {
    List<IOPort> ports=actor.outputPortList();
    for (    IOPort port : ports) {
      Receiver[][] receivers=port.getRemoteReceivers();
      if (receivers != null && receivers.length > 0) {
        for (        Receiver[] receiverss : receivers) {
          if (receiverss != null && receiverss.length > 0) {
            for (            Receiver receiver : receiverss) {
              if (receiver instanceof PthalesReceiver)               ((PthalesReceiver)receiver).setOutputArray(port,actor);
            }
          }
        }
      }
    }
    ports=actor.inputPortList();
    for (    IOPort port : ports) {
      Receiver[][] receivers=port.getReceivers();
      if (receivers != null && receivers.length > 0) {
        for (        Receiver[] receiverss : receivers) {
          if (receiverss != null && receiverss.length > 0) {
            for (            Receiver receiver : receiverss) {
              ((PthalesReceiver)receiver).setInputArray(port,actor);
            }
          }
        }
      }
    }
  }
  Schedule schedule=new Schedule();
  CausalityInterfaceForComposites causality=(CausalityInterfaceForComposites)compositeActor.getCausalityInterface();
  List<Actor> sortedActors=causality.topologicalSort();
  for (  Actor actor : sortedActors) {
    Firing firing=new Firing(actor);
    firing.setIterationCount(PthalesAtomicActor.getIteration((ComponentEntity)actor));
    schedule.add(firing);
  }
  return schedule;
}"
73682,"/** 
 * Construct a Pthales scheduler in the given container with the given name.
 * @param container The container.
 * @param name The name of this attribute.
 * @exception IllegalActionException If the attribute is not of anacceptable class for the container, or if the name contains a period.
 * @exception NameDuplicationException If the name coincides withan attribute already in the container.
 */
public PthalesScheduler(Director container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
}","public PthalesScheduler(Director container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
}"
73683,"/** 
 * Generate fire code. The method reads in <code>fireBlock</code> from Accumulator.c, replaces macros with their values and returns the processed code block.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.Accumulator actor=(ptolemy.actor.lib.Accumulator)getComponent();
  ArrayList args=new ArrayList<String>();
  args.add(""String_Node_Str"");
  Type type=actor.output.getType();
  String targetType=targetType(type);
  CodeStream codeStream=_templateParser.getCodeStream();
  if (actor.reset.isOutsideConnected()) {
    codeStream.appendCodeBlock(""String_Node_Str"");
    for (int i=1; i < actor.reset.getWidth(); i++) {
      args.set(0,Integer.valueOf(i).toString());
      codeStream.appendCodeBlock(""String_Node_Str"",args);
    }
    codeStream.appendCodeBlock(""String_Node_Str"");
    codeStream.appendCodeBlock((targetType.equals(""String_Node_Str"")) ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (!getCodeGenerator().isPrimitive(type)) {
    targetType=""String_Node_Str"";
  }
  for (int i=0; i < actor.input.getWidth(); i++) {
    args.set(0,Integer.valueOf(i).toString());
    codeStream.appendCodeBlock(targetType + ""String_Node_Str"",args);
  }
  codeStream.appendCodeBlock(""String_Node_Str"");
  return processCode(codeStream.toString());
}","/** 
 * Generate fire code. The method reads in <code>fireBlock</code> from Accumulator.c, replaces macros with their values and returns the processed code block.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.Accumulator actor=(ptolemy.actor.lib.Accumulator)getComponent();
  ArrayList args=new ArrayList<String>();
  args.add(""String_Node_Str"");
  Type type=actor.output.getType();
  String targetType=targetType(type);
  CodeStream codeStream=_templateParser.getCodeStream();
  if (actor.reset.isOutsideConnected()) {
    codeStream.appendCodeBlock(""String_Node_Str"");
    for (int i=1; i < actor.reset.getWidth(); i++) {
      args.set(0,Integer.valueOf(i).toString());
      codeStream.appendCodeBlock(""String_Node_Str"",args);
    }
    codeStream.appendCodeBlock(""String_Node_Str"");
    codeStream.appendCodeBlock((targetType.equals(""String_Node_Str"")) ? ""String_Node_Str"" : ""String_Node_Str"");
    codeStream.append(""String_Node_Str"");
  }
  if (!getCodeGenerator().isPrimitive(type)) {
    targetType=""String_Node_Str"";
  }
  for (int i=0; i < actor.input.getWidth(); i++) {
    args.set(0,Integer.valueOf(i).toString());
    codeStream.appendCodeBlock(targetType + ""String_Node_Str"",args);
  }
  codeStream.appendCodeBlock(""String_Node_Str"");
  return processCode(codeStream.toString());
}"
73684,"/** 
 * If this actor is opaque, invoke the prefire() method of the local director. This method returns true if the actor is ready to fire (determined by the prefire() method of the director). It is read-synchronized on the workspace.
 * @exception IllegalActionException If there is no director,or if the director's prefire() method throws it, or if this actor is not opaque.
 */
public boolean prefire() throws IllegalActionException {
  boolean result=super.prefire();
  Iterator<?> outports=outputPortList().iterator();
  while (outports.hasNext() && !_stopRequested) {
    IOPort p=(IOPort)outports.next();
    LinkedHashMap<String,Integer> sizes=PthalesIOPort.getArraySizes(p,_repetition);
    List<Token> header=new ArrayList<Token>();
    int nbDims=PthalesIOPort.getDimensions(p).length;
    header.add(new IntToken(nbDims));
    header.add(new IntToken(PthalesIOPort.getNbTokenPerData(p)));
    for (    String dim : sizes.keySet()) {
      header.add(new StringToken(dim));
      header.add(new IntToken(sizes.get(dim)));
    }
    for (int i=0; i < p.getWidth(); i++) {
      for (int j=0; j < header.size(); j++) {
        p.send(i,header.get(j));
      }
    }
  }
  return result;
}","/** 
 * If this actor is opaque, invoke the prefire() method of the local director. This method returns true if the actor is ready to fire (determined by the prefire() method of the director). It is read-synchronized on the workspace.
 * @exception IllegalActionException If there is no director,or if the director's prefire() method throws it, or if this actor is not opaque.
 */
public boolean prefire() throws IllegalActionException {
  boolean result=super.prefire();
  if (!_headerSent) {
    Iterator<?> outports=outputPortList().iterator();
    while (outports.hasNext() && !_stopRequested) {
      IOPort p=(IOPort)outports.next();
      LinkedHashMap<String,Integer> sizes=PthalesIOPort.getArraySizes(p,_repetition);
      List<Token> header=new ArrayList<Token>();
      int nbDims=PthalesIOPort.getDimensions(p).length;
      header.add(new IntToken(nbDims));
      header.add(new IntToken(PthalesIOPort.getNbTokenPerData(p)));
      for (      String dim : sizes.keySet()) {
        header.add(new StringToken(dim));
        header.add(new IntToken(sizes.get(dim)));
      }
      for (int i=0; i < p.getWidth(); i++) {
        for (int j=0; j < header.size(); j++) {
          p.send(i,header.get(j));
        }
      }
    }
    _headerSent=true;
  }
  return result;
}"
73685,"/** 
 * Invoke a specified number of iterations of the actor. An iteration is equivalent to invoking prefire(), fire(), and postfire(), in that order. In an iteration, if prefire() returns true, then fire() will be called once, followed by postfire(). Otherwise, if prefire() returns false, fire() and postfire() are not invoked, and this method returns NOT_READY. If postfire() returns false, then no more iterations are invoked, and this method returns STOP_ITERATING. Otherwise, it returns COMPLETED.  If stop() is called during this iteration, then cease iterating and return STOP_ITERATING. <p> This base class method actually invokes prefire(), fire(), and postfire(), as described above, but a derived class may override the method to execute more efficient code.
 * @param count The number of iterations to perform.
 * @return NOT_READY, STOP_ITERATING, or COMPLETED.
 * @exception IllegalActionException If iterating is notpermitted, or if prefire(), fire(), or postfire() throw it.
 */
public int iterate(int count) throws IllegalActionException {
  int iterations=count;
  if (count == 0) {
    iterations=computeIterations();
  }
  return super.iterate(iterations);
}","/** 
 * Invoke a specified number of iterations of the actor. An iteration is equivalent to invoking prefire(), fire(), and postfire(), in that order. In an iteration, if prefire() returns true, then fire() will be called once, followed by postfire(). Otherwise, if prefire() returns false, fire() and postfire() are not invoked, and this method returns NOT_READY. If postfire() returns false, then no more iterations are invoked, and this method returns STOP_ITERATING. Otherwise, it returns COMPLETED.  If stop() is called during this iteration, then cease iterating and return STOP_ITERATING. <p> This base class method actually invokes prefire(), fire(), and postfire(), as described above, but a derived class may override the method to execute more efficient code.
 * @param count The number of iterations to perform.
 * @return NOT_READY, STOP_ITERATING, or COMPLETED.
 * @exception IllegalActionException If iterating is notpermitted, or if prefire(), fire(), or postfire() throw it.
 */
public int iterate(int count) throws IllegalActionException {
  int iterations=count;
  if (count == 0) {
    iterations=computeIterations();
  }
  _headerSent=false;
  return super.iterate(iterations);
}"
73686,"/** 
 * Read the contents of the array, and extract the header containing  the number of dimensions and the size of each dimension at the beginning of the array then send only the useful informations.
 */
public void fire() throws IllegalActionException {
  IOPort portIn=(IOPort)getPort(""String_Node_Str"");
  IOPort portOut=(IOPort)getPort(""String_Node_Str"");
  Token[] tokensIn=null;
  int nDims=((IntToken)portIn.get(0)).intValue();
  int nbTokens=((IntToken)portIn.get(0)).intValue();
  Token[] headerIn=portIn.get(0,nDims * 2);
  int dataSize=nbTokens;
  String[] dims=new String[nDims];
  int[] sizes=new int[dims.length];
  for (int i=0; i < nDims; i++) {
    dataSize*=((IntToken)headerIn[2 * i + 1]).intValue();
    dims[i]=((StringToken)headerIn[2 * i]).stringValue();
    sizes[i]=((IntToken)headerIn[2 * i + 1]).intValue();
  }
  PthalesIOPort.modifyPattern(portOut,""String_Node_Str"",dataSize);
  PthalesIOPort.modifyPattern(portIn,dims,sizes);
  tokensIn=portIn.get(0,dataSize);
  for (int i=0; i < portOut.getWidth(); i++) {
    portOut.send(i,tokensIn,dataSize);
  }
}","/** 
 * Read the contents of the array, and extract the header containing  the number of dimensions and the size of each dimension at the beginning of the array then send only the useful informations.
 */
public void fire() throws IllegalActionException {
  IOPort portIn=(IOPort)getPort(""String_Node_Str"");
  IOPort portOut=(IOPort)getPort(""String_Node_Str"");
  Token[] tokensIn=null;
  int nDims=((IntToken)portIn.get(0)).intValue();
  int nbTokens=((IntToken)portIn.get(0)).intValue();
  Token[] headerIn=portIn.get(0,nDims * 2);
  int dataSize=nbTokens;
  String[] dims=new String[nDims];
  int[] sizes=new int[dims.length];
  for (int i=0; i < nDims; i++) {
    dataSize*=((IntToken)headerIn[2 * i + 1]).intValue();
    dims[i]=((StringToken)headerIn[2 * i]).stringValue();
    sizes[i]=((IntToken)headerIn[2 * i + 1]).intValue();
  }
  tokensIn=portIn.get(0,dataSize);
  for (int i=0; i < portOut.getWidth(); i++) {
    portOut.send(i,tokensIn,dataSize);
  }
}"
73687,"/** 
 * Handle the model results passed to this class, and handle the results according to the certain search criteria. The  search criteria is passed to the concrete searchers when they are  constructed. 
 * @param modelResults The results to be handled in this searcher.
 * @exception DBConnectionException Thrown by the DBConnectorFactoryif getting the DBConnection from it, which indicates that the DBConnection cannot be obtained.
 * @exception DBExecutionException Happens in the executionof DB tasks, and is thrown by the concrete searcher if they are performing the actual searching in the database.
 */
public void handleResults(ArrayList<XMLDBModel> modelResults) throws DBConnectionException, DBExecutionException {
  if (isSearchCancelled()) {
    return;
  }
  _previousResults=modelResults;
  if (_noMatch()) {
    wholeSearchDone();
  }
 else {
    if (_isSearchCriteriaSet()) {
      if (this instanceof AbstractDBSearcher) {
        try {
          if (_dbConnection == null) {
            _dbConnection=DBConnectorFactory.getSyncConnection(false);
            setConnection(_dbConnection);
          }
          _search();
        }
 catch (        DBExecutionException e) {
          _dbConnection.closeConnection();
          throw e;
        }
        if ((!_isFirstSearcher()) && _isIntersectNeeded()) {
          if (_isSearchCriteriaSet()) {
            _toPassResults=Utilities.intersectResults(_previousResults,_currentResults);
          }
 else {
            _toPassResults=_previousResults;
          }
        }
 else {
          _toPassResults=_currentResults;
        }
        _nextResultHandler.handleResults(_toPassResults);
      }
 else {
        _search();
      }
    }
 else {
      _pass();
      _nextResultHandler.handleResults(modelResults);
    }
    if (_isLastSeacher() && _previousSearcher.isPassed()) {
      _nextResultHandler.wholeSearchDone();
    }
  }
}","/** 
 * Handle the model results passed to this class, and handle the results according to the certain search criteria. The  search criteria is passed to the concrete searchers when they are  constructed. 
 * @param modelResults The results to be handled in this searcher.
 * @exception DBConnectionException Thrown by the DBConnectorFactoryif getting the DBConnection from it, which indicates that the DBConnection cannot be obtained.
 * @exception DBExecutionException Happens in the executionof DB tasks, and is thrown by the concrete searcher if they are performing the actual searching in the database.
 */
public void handleResults(ArrayList<XMLDBModel> modelResults) throws DBConnectionException, DBExecutionException {
  if (isSearchCancelled()) {
    return;
  }
  _previousResults=modelResults;
  if (_previousResults != null && _previousResults.size() > 0) {
    Collections.sort(_previousResults);
  }
  if (_noMatch()) {
    wholeSearchDone();
  }
 else {
    if (_isSearchCriteriaSet()) {
      if (this instanceof AbstractDBSearcher) {
        try {
          if (_dbConnection == null) {
            _dbConnection=DBConnectorFactory.getSyncConnection(false);
            setConnection(_dbConnection);
          }
          _search();
        }
 catch (        DBExecutionException e) {
          _dbConnection.closeConnection();
          throw e;
        }
        if ((!_isFirstSearcher()) && _isIntersectNeeded()) {
          if (_isSearchCriteriaSet()) {
            _toPassResults=Utilities.intersectResults(_previousResults,_currentResults);
          }
 else {
            _toPassResults=_previousResults;
          }
        }
 else {
          _toPassResults=_currentResults;
        }
        _nextResultHandler.handleResults(_toPassResults);
      }
 else {
        _search();
      }
    }
 else {
      _pass();
      _nextResultHandler.handleResults(modelResults);
    }
    if (_isLastSeacher() && _previousSearcher.isPassed()) {
      _nextResultHandler.wholeSearchDone();
    }
  }
}"
73688,"/** 
 * Update the existing database connection parameters with the given parameters.
 * @param params The new database connection parameters.
 * @exception DBConnectionException Thrown if the connection fails.
 * @exception IOException Thrown if an error occurs while writing the newparameters.
 */
public void updateDBConnectionSetupParameters(SetupParameters params) throws DBConnectionException, IOException {
  if (params == null) {
    throw new DBConnectionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String ptdbParams=DBConnectorFactory._PROPERTIES_FILE_PATH;
  Properties props=new Properties();
  File file=FileUtilities.nameToFile(ptdbParams,null);
  if (file.exists() == false) {
    file.createNewFile();
  }
  URL url=FileUtilities.nameToURL(ptdbParams,null,null);
  if (url == null) {
    throw new IOException(""String_Node_Str"" + ptdbParams);
  }
  String defaultDBClassName=""String_Node_Str"";
  props.load(url.openStream());
  String dbClassName=(String)props.getProperty(DBConnectorFactory._DB_CLASS_NAME);
  if (dbClassName == null || dbClassName.length() == 0) {
    dbClassName=defaultDBClassName;
  }
  props.setProperty(DBConnectorFactory._DB_CLASS_NAME,dbClassName);
  props.setProperty(DBConnectorFactory._DB_URL,params.getUrl());
  props.setProperty(DBConnectorFactory._XMLDB_CONTAINER_NAME,params.getContainerName());
  props.setProperty(DBConnectorFactory._CACHE_CONTAINER_NAME,params.getCacheContainerName());
  props.store(new FileOutputStream(url.getPath()),null);
  DBConnectorFactory.loadDBProperties();
}","/** 
 * Update the existing database connection parameters with the given parameters.
 * @param params The new database connection parameters.
 * @exception DBConnectionException Thrown if the connection fails.
 * @exception IOException Thrown if an error occurs while writing the newparameters.
 */
public void updateDBConnectionSetupParameters(SetupParameters params) throws DBConnectionException, IOException {
  if (params == null) {
    throw new DBConnectionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String ptdbParams=DBConnectorFactory._PROPERTIES_FILE_PATH;
  Properties props=new Properties();
  File tempFile=FileUtilities.nameToFile(ptdbParams,null);
  File file=new File(tempFile.getPath().replaceAll(""String_Node_Str"",""String_Node_Str""));
  if (file.exists() == false) {
    file.createNewFile();
  }
  URL url=FileUtilities.nameToURL(ptdbParams,null,null);
  if (url == null) {
    throw new IOException(""String_Node_Str"" + ptdbParams);
  }
  String defaultDBClassName=""String_Node_Str"";
  props.load(url.openStream());
  String dbClassName=(String)props.getProperty(DBConnectorFactory._DB_CLASS_NAME);
  if (dbClassName == null || dbClassName.length() == 0) {
    dbClassName=defaultDBClassName;
  }
  props.setProperty(DBConnectorFactory._DB_CLASS_NAME,dbClassName);
  props.setProperty(DBConnectorFactory._DB_URL,params.getUrl());
  props.setProperty(DBConnectorFactory._XMLDB_CONTAINER_NAME,params.getContainerName());
  props.setProperty(DBConnectorFactory._CACHE_CONTAINER_NAME,params.getCacheContainerName());
  props.store(new FileOutputStream(url.getPath().replaceAll(""String_Node_Str"",""String_Node_Str"")),null);
  DBConnectorFactory.loadDBProperties();
}"
73689,"private void updateCache(XMLDBModel xmlDBModel) throws DBConnectionException, DBExecutionException {
  ArrayList<XMLDBModel> hierarchy=new ArrayList();
  ArrayList<XMLDBModel> modelsToRemoveList=new ArrayList();
  DBConnection dbConnection=null;
  try {
    dbConnection=DBConnectorFactory.getSyncConnection(false);
    ArrayList<XMLDBModel> modelList=new ArrayList();
    modelList.add(xmlDBModel);
    FetchHierarchyTask fetchHierarchyTask=new FetchHierarchyTask();
    fetchHierarchyTask.setModelsList(modelList);
    hierarchy=dbConnection.executeFetchHierarchyTask(fetchHierarchyTask);
    if (hierarchy != null && hierarchy.size() > 0) {
      if (hierarchy.get(0) != null) {
        if (hierarchy.get(0).getParents() != null) {
          for (          List<XMLDBModel> branch : hierarchy.get(0).getParents()) {
            for (            XMLDBModel modelToRemove : branch) {
              if (!modelsToRemoveList.contains(modelToRemove)) {
                modelsToRemoveList.add(modelToRemove);
              }
            }
          }
        }
      }
    }
  }
 catch (  DBExecutionException dbEx) {
    throw dbEx;
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  modelsToRemoveList.add(xmlDBModel);
  HashSet set=new HashSet();
  for (int i=0; i < modelsToRemoveList.size(); i++) {
    boolean val=set.add(modelsToRemoveList.get(i).getModel());
    if (val == false) {
      modelsToRemoveList.remove(i);
    }
  }
  CacheManager.removeFromCache(modelsToRemoveList);
}","private void updateCache(XMLDBModel xmlDBModel) throws DBConnectionException, DBExecutionException {
  ArrayList<XMLDBModel> hierarchy=new ArrayList();
  ArrayList<XMLDBModel> modelsToRemoveList=new ArrayList();
  DBConnection dbConnection=null;
  try {
    dbConnection=DBConnectorFactory.getSyncConnection(false);
    ArrayList<XMLDBModel> modelList=new ArrayList();
    modelList.add(xmlDBModel);
    FetchHierarchyTask fetchHierarchyTask=new FetchHierarchyTask();
    fetchHierarchyTask.setModelsList(modelList);
    hierarchy=dbConnection.executeFetchHierarchyTask(fetchHierarchyTask);
    if (hierarchy != null && hierarchy.size() > 0) {
      if (hierarchy.get(0) != null) {
        if (hierarchy.get(0).getParents() != null) {
          for (          List<XMLDBModel> branch : hierarchy.get(0).getParents()) {
            for (            XMLDBModel modelToRemove : branch) {
              if (!modelsToRemoveList.contains(modelToRemove)) {
                modelsToRemoveList.add(modelToRemove);
              }
            }
          }
        }
      }
    }
  }
 catch (  DBExecutionException dbEx) {
    throw dbEx;
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  modelsToRemoveList.add(xmlDBModel);
  CacheManager.removeFromCache(modelsToRemoveList);
}"
73690,"/** 
 * Perform the actual pattern match for the passed models. 
 * @exception DBConnectionException Thrown from the database layer if the connection to database cannot be obtained. 
 * @exception DBExecutionException Thrown from the database layer if erroroccurs during some execution. 
 */
@Override protected void _search() throws DBConnectionException, DBExecutionException {
  Pattern pattern=_dbGraphSearchCriteria.getPattern();
  GraphMatcher matcher=new GraphMatcher();
  _parser=new MoMLParser();
  int count=0;
  ArrayList<XMLDBModel> modelsBatch=new ArrayList<XMLDBModel>();
  int fetchedCount=0;
  for (  XMLDBModel model : _previousResults) {
    modelsBatch.add(model);
    count++;
    fetchedCount++;
    if (count == 5 || fetchedCount == _previousResults.size()) {
      count=0;
      List<XMLDBModel> fullModels=DBModelFetcher.load(modelsBatch);
      for (      XMLDBModel fullModel : fullModels) {
        if (isSearchCancelled()) {
          return;
        }
        CompositeEntity modelNamedObj;
        try {
          modelNamedObj=(CompositeEntity)_parser.parse(fullModel.getModel());
        }
 catch (        Exception e) {
          _addErrorModel(fullModel);
          continue;
        }
        MatchResultRecorder recorder=new MatchResultRecorder();
        matcher.setMatchCallback(recorder);
        matcher.match(pattern,modelNamedObj);
        List<MatchResult> matchResults=recorder.getResults();
        if (!matchResults.isEmpty()) {
          ArrayList<XMLDBModel> tempResultsList=new ArrayList<XMLDBModel>();
          tempResultsList.add(fullModel);
          _nextResultHandler.handleResults(tempResultsList);
        }
      }
      modelsBatch=new ArrayList<XMLDBModel>();
    }
  }
  passErrorModels(_errorModels);
  wholeSearchDone();
}","/** 
 * Perform the actual pattern match for the passed models. 
 * @exception DBConnectionException Thrown from the database layer if the connection to database cannot be obtained. 
 * @exception DBExecutionException Thrown from the database layer if erroroccurs during some execution. 
 */
@Override protected void _search() throws DBConnectionException, DBExecutionException {
  Pattern pattern=_dbGraphSearchCriteria.getPattern();
  _parser=new MoMLParser();
  GraphMatcher matcher=new GraphMatcher();
  int count=0;
  ArrayList<XMLDBModel> modelsBatch=new ArrayList<XMLDBModel>();
  int fetchedCount=0;
  for (  XMLDBModel model : _previousResults) {
    modelsBatch.add(model);
    count++;
    fetchedCount++;
    if (count == 5 || fetchedCount == _previousResults.size()) {
      count=0;
      List<XMLDBModel> fullModels=DBModelFetcher.load(modelsBatch);
      for (      XMLDBModel fullModel : fullModels) {
        if (isSearchCancelled()) {
          return;
        }
        CompositeEntity modelNamedObj;
        try {
          _parser.resetAll();
          modelNamedObj=(CompositeEntity)_parser.parse(fullModel.getModel());
        }
 catch (        Exception e) {
          _addErrorModel(fullModel);
          continue;
        }
        MatchResultRecorder recorder=new MatchResultRecorder();
        matcher.setMatchCallback(recorder);
        matcher.match(pattern,modelNamedObj);
        List<MatchResult> matchResults=recorder.getResults();
        if (!matchResults.isEmpty()) {
          ArrayList<XMLDBModel> tempResultsList=new ArrayList<XMLDBModel>();
          tempResultsList.add(fullModel);
          _nextResultHandler.handleResults(tempResultsList);
        }
      }
      modelsBatch=new ArrayList<XMLDBModel>();
    }
  }
  passErrorModels(_errorModels);
  wholeSearchDone();
}"
73691,"/** 
 * Validate whether the search criteria that the user has input is valid or  not. 
 * @return true - the search criteria is valid.<br>false - the search criteria is invalid. 
 * @exception NameDuplicationException Thrown if attributes with duplicatednames are found in the search criteria. 
 * @exception IllegalActionException Thrown if the intend action is illegal. 
 */
private boolean _isValid() throws NameDuplicationException, IllegalActionException {
  if (_attributesListPanel.getAttributeCount() == 0 && _attributesListPanel.getModelName().trim().isEmpty()) {
    return true;
  }
  if (!_attributesListPanel.getModelName().trim().isEmpty()) {
    if (!_attributesListPanel.getModelName().matches(""String_Node_Str"")) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      return false;
    }
  }
  if (_attributesListPanel.containsDuplicates()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeNamesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeValuesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  return true;
}","/** 
 * Validate whether the search criteria that the user has input is valid or  not. 
 * @return true - the search criteria is valid.<br>false - the search criteria is invalid. 
 * @exception NameDuplicationException Thrown if attributes with duplicatednames are found in the search criteria. 
 * @exception IllegalActionException Thrown if the intend action is illegal. 
 */
private boolean _isValid() throws NameDuplicationException, IllegalActionException {
  if (_attributesListPanel.getAttributeCount() == 0 && _attributesListPanel.getModelName().trim().isEmpty()) {
    return true;
  }
  if (!_attributesListPanel.getModelName().trim().isEmpty()) {
    if (!Utilities.checkAttributeModelName(_attributesListPanel.getModelName())) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      return false;
    }
  }
  if (_attributesListPanel.containsDuplicates()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeNamesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeValuesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  return true;
}"
73692,"/** 
 * Validate whether the added item is valid to add to the list. 
 * @return true - It is valid to add that item.<br>false - It is invalid to add that item.
 */
private boolean _validate(){
  ArrayModelList modelList=((ArrayModelList)_itemsJList.getModel());
  for (int i=0; i < modelList.getSize(); i++) {
    if (_listItemTextField.getText().equals(modelList.getElementAt(i))) {
      return false;
    }
  }
  return true;
}","/** 
 * Validate whether the added item is valid to add to the list. 
 * @return true - It is valid to add that item.<br>false - It is invalid to add that item.
 */
private boolean _validate(){
  if (!Utilities.checkAttributeModelName(_listItemTextField.getText())) {
    return false;
  }
  ArrayModelList modelList=((ArrayModelList)_itemsJList.getModel());
  for (int i=0; i < modelList.getSize(); i++) {
    if (_listItemTextField.getText().equals(modelList.getElementAt(i))) {
      return false;
    }
  }
  return true;
}"
73693,"private void _saveModel() throws Exception {
  try {
    _modelToSave.setName(_attributesListPanel.getModelName());
    if (_initialModelName != null && _initialModelName.length() > 0) {
      if (!_modelToSave.getName().equals(_initialModelName)) {
        Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int n=JOptionPane.showOptionDialog(this,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
        if (n != JOptionPane.YES_OPTION) {
          return;
        }
      }
    }
    String id=null;
    if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) != null) {
      id=((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).getExpression();
    }
    _commitSave(_isNew(),id);
  }
 catch (  DBConnectionException exception) {
    throw exception;
  }
catch (  DBExecutionException exception) {
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    throw exception;
  }
}","private void _saveModel() throws Exception {
  try {
    _modelToSave.setName(_attributesListPanel.getModelName());
    if (_initialModelName != null && _initialModelName.length() > 0) {
      if (!_modelToSave.getName().equals(_initialModelName)) {
        Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int n=JOptionPane.showOptionDialog(this,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
        if (n != JOptionPane.YES_OPTION) {
          return;
        }
      }
    }
    String id=null;
    if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) != null) {
      id=((StringConstantParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).getExpression();
    }
    _commitSave(_isNew(),id);
  }
 catch (  DBConnectionException exception) {
    throw exception;
  }
catch (  DBExecutionException exception) {
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    throw exception;
  }
}"
73694,"private void _commitSave(boolean isNew,String id) throws Exception {
  _updateDisplayedModel();
  if (isNew || id == null) {
    if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) != null) {
      _modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR).setContainer(null);
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
      }
 catch (      Exception e) {
        throw e;
      }
    }
  }
  xmlModel=new XMLDBModel(_modelToSave.getName());
  xmlModel.setModel(_modelToSave.exportMoML());
  xmlModel.setIsNew(isNew);
  xmlModel.setModelId(id);
  SaveModelManager saveModelManager=new SaveModelManager();
  try {
    String modelId=saveModelManager.save(xmlModel);
    if (modelId != null) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) == null) {
        StringConstantParameter dbModelParam=new StringConstantParameter(_modelToSave,XMLDBModel.DB_MODEL_ID_ATTR);
        dbModelParam.setExpression(modelId);
        dbModelParam.setContainer(_modelToSave);
      }
 else       if (!((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).getExpression().equals(modelId)) {
        ((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).setExpression(modelId);
      }
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
      }
 catch (      Exception e) {
        throw e;
      }
      setVisible(false);
    }
 else {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    }
  }
 catch (  DBConnectionException exception) {
    throw exception;
  }
catch (  DBExecutionException exception) {
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    throw exception;
  }
catch (  ModelAlreadyExistException exception) {
    Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    int n=JOptionPane.showOptionDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
    if (n == JOptionPane.YES_OPTION) {
      saveModelManager=null;
      _commitSave(false,null);
    }
 else {
      _rollbackModel();
    }
  }
}","private void _commitSave(boolean isNew,String id) throws Exception {
  _updateDisplayedModel();
  if (isNew || id == null) {
    if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) != null) {
      _modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR).setContainer(null);
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
      }
 catch (      Exception e) {
        throw e;
      }
    }
  }
  xmlModel=new XMLDBModel(_modelToSave.getName());
  xmlModel.setModel(_modelToSave.exportMoML());
  xmlModel.setIsNew(isNew);
  xmlModel.setModelId(id);
  SaveModelManager saveModelManager=new SaveModelManager();
  try {
    String modelId=saveModelManager.save(xmlModel);
    if (modelId != null) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) == null) {
        StringConstantParameter dbModelParam=new StringConstantParameter(_modelToSave,XMLDBModel.DB_MODEL_ID_ATTR);
        dbModelParam.setExpression(modelId);
        dbModelParam.setContainer(_modelToSave);
      }
 else       if (!((StringConstantParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).getExpression().equals(modelId)) {
        ((StringConstantParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).setExpression(modelId);
      }
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
      }
 catch (      Exception e) {
        throw e;
      }
      setVisible(false);
    }
 else {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    }
  }
 catch (  DBConnectionException exception) {
    throw exception;
  }
catch (  DBExecutionException exception) {
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    throw exception;
  }
catch (  ModelAlreadyExistException exception) {
    Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    int n=JOptionPane.showOptionDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
    if (n == JOptionPane.YES_OPTION) {
      saveModelManager=null;
      _commitSave(false,null);
    }
 else {
      _rollbackModel();
    }
  }
}"
73695,"/** 
 * Construct a XMLDBModel instance with the given model name.
 * @param modelName the name for the given model.
 */
public XMLDBModel(String modelName){
  this._modelName=modelName;
}","/** 
 * Construct a XMLDBModel instance with the given model name.
 * @param modelName Name for the given model.
 * @param modelId Id for the given model.
 */
public XMLDBModel(String modelName,String modelId){
  this._modelName=modelName;
  this._modelId=modelId;
}"
73696,"/** 
 * Populate the referenced child models list and update the model XML by  replacing the referenced models with place holder.  
 * @param model Model with references to be resolved.
 * @return The updates model containing the list of child models and updated content.
 * @throws XMLDBModelParsingException If thrown while parsing the XML. 
 */
public XMLDBModel populateChildModelsList(XMLDBModel model) throws XMLDBModelParsingException {
  if (model.getModel() == null) {
    return model;
  }
  model.setReferencedChildren(new ArrayList<String>());
  Document modelDocument=(Document)Utilities.parseXML(model.getModel());
  Node topEntityNode=modelDocument.getElementsByTagName(""String_Node_Str"").item(0);
  NodeList entityList=topEntityNode.getChildNodes();
  boolean isChanged=false;
  if (entityList != null) {
    for (int i=0; i < entityList.getLength(); i++) {
      Node entity=entityList.item(i);
      if (!""String_Node_Str"".equals(entity.getNodeName())) {
        continue;
      }
      NodeList parameterList=entity.getChildNodes();
      String referencedModelId=null;
      boolean isReferenced=false;
      int noOfParametersFound=0;
      for (int j=0; j < parameterList.getLength(); j++) {
        Node parameter=parameterList.item(j);
        if (""String_Node_Str"".equals(parameter.getNodeName())) {
          String name=Utilities.getValueForAttribute(parameter,""String_Node_Str"");
          if (XMLDBModel.DB_MODEL_ID_ATTR.equals(name)) {
            referencedModelId=Utilities.getValueForAttribute(parameter,""String_Node_Str"");
            noOfParametersFound++;
          }
 else           if (XMLDBModel.DB_REFERENCE_ATTR.equals(name)) {
            String value=Utilities.getValueForAttribute(parameter,""String_Node_Str"");
            isReferenced=""String_Node_Str"".equals(value);
            noOfParametersFound++;
          }
          if (noOfParametersFound == 2) {
            break;
          }
        }
      }
      if (isReferenced && referencedModelId != null) {
        Element entityElement=(Element)entity.cloneNode(false);
        NodeList childNodesList=entity.getChildNodes();
        for (int k=0; k < childNodesList.getLength(); k++) {
          Node childNode=childNodesList.item(k);
          if (""String_Node_Str"".equals(childNode.getNodeName())) {
            String name=Utilities.getValueForAttribute(childNode,""String_Node_Str"");
            if (name != null && (name.startsWith(""String_Node_Str"") || XMLDBModel.DB_REFERENCE_ATTR.equals(name) || XMLDBModel.DB_MODEL_ID_ATTR.equals(name))) {
              entityElement.appendChild(childNode);
            }
          }
        }
        entityElement.setAttribute(XMLDBModel.DB_MODEL_ID_ATTR,referencedModelId);
        topEntityNode.replaceChild(entityElement,entity);
        model.addReferencedChild(referencedModelId);
        isChanged=true;
      }
    }
  }
  if (isChanged) {
    String newModelContent=Utilities.getDocumentXMLString(modelDocument);
    model.setModel(newModelContent);
  }
  return model;
}","/** 
 * Populate the referenced child models list and update the model XML by  replacing the referenced models with place holder.  
 * @param model Model with references to be resolved.
 * @return The updates model containing the list of child models and updated content.
 * @throws XMLDBModelParsingException If thrown while parsing the XML. 
 */
public XMLDBModel populateChildModelsList(XMLDBModel model) throws XMLDBModelParsingException {
  if (model.getModel() == null) {
    return model;
  }
  model.setReferencedChildren(new ArrayList<String>());
  Document modelDocument=(Document)Utilities.parseXML(model.getModel());
  Node topEntityNode=modelDocument.getElementsByTagName(""String_Node_Str"").item(0);
  NodeList entityList=topEntityNode.getChildNodes();
  boolean isChanged=false;
  if (entityList != null) {
    for (int i=0; i < entityList.getLength(); i++) {
      Node entity=entityList.item(i);
      if (!""String_Node_Str"".equals(entity.getNodeName())) {
        continue;
      }
      NodeList parameterList=entity.getChildNodes();
      String referencedModelId=null;
      boolean isReferenced=false;
      boolean isReferencedFound=false;
      boolean dbModelIdFound=false;
      for (int j=0; j < parameterList.getLength(); j++) {
        Node parameter=parameterList.item(j);
        if (""String_Node_Str"".equals(parameter.getNodeName())) {
          String name=Utilities.getValueForAttribute(parameter,""String_Node_Str"");
          if (XMLDBModel.DB_MODEL_ID_ATTR.equals(name) && !dbModelIdFound) {
            referencedModelId=Utilities.getValueForAttribute(parameter,""String_Node_Str"");
            dbModelIdFound=true;
          }
 else           if (XMLDBModel.DB_REFERENCE_ATTR.equals(name) && !isReferencedFound) {
            String value=Utilities.getValueForAttribute(parameter,""String_Node_Str"");
            isReferenced=""String_Node_Str"".equals(value);
            isReferencedFound=true;
          }
          if (isReferencedFound && dbModelIdFound) {
            break;
          }
        }
      }
      if (isReferenced && referencedModelId != null) {
        Element entityElement=(Element)entity.cloneNode(false);
        NodeList childNodesList=entity.getChildNodes();
        for (int k=0; k < childNodesList.getLength(); k++) {
          Node childNode=childNodesList.item(k);
          if (""String_Node_Str"".equals(childNode.getNodeName())) {
            String name=Utilities.getValueForAttribute(childNode,""String_Node_Str"");
            if (name != null && (name.startsWith(""String_Node_Str"") || XMLDBModel.DB_REFERENCE_ATTR.equals(name) || XMLDBModel.DB_MODEL_ID_ATTR.equals(name))) {
              entityElement.appendChild(childNode);
            }
          }
        }
        entityElement.setAttribute(XMLDBModel.DB_MODEL_ID_ATTR,referencedModelId);
        topEntityNode.replaceChild(entityElement,entity);
        model.addReferencedChild(referencedModelId);
        isChanged=true;
      }
    }
  }
  if (isChanged) {
    String newModelContent=Utilities.getDocumentXMLString(modelDocument);
    model.setModel(newModelContent);
  }
  return model;
}"
73697,"/** 
 * Abort the connection and roll back the transaction Invoke in case of errors.
 * @exception DBConnectionException If thrown while aborting transaction inthe database.
 */
public void abortConnection() throws DBConnectionException {
  try {
    _checkConnectionAlive();
    if (_xmlTransaction != null) {
      _checkTransactionActive();
      _xmlTransaction.abort();
      _isTransactionActive=false;
    }
  }
 catch (  XmlException e) {
    throw new DBConnectionException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Abort the connection and roll back the transaction Invoke in case of errors.
 * @exception DBConnectionException If thrown while aborting transaction inthe database.
 */
public void abortConnection() throws DBConnectionException {
  try {
    _checkConnectionAlive();
    if (_xmlTransaction != null) {
      _checkTransactionActive();
      _xmlTransaction.getTransaction().abort();
      _isTransactionActive=false;
    }
  }
 catch (  XmlException e) {
    throw new DBConnectionException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  DatabaseException e) {
    throw new DBConnectionException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
73698,"/** 
 * Fetch the parent hierarchies for the given model.
 * @param model The model for which the parent hierarchies are required.
 * @exception DBExecutionException If thrown while fetching model hierarchy.
 * @throws XMLDBModelParsingException If thrown while parsing the model.
 */
private XMLDBModel _fetchHierarchyForModel(XMLDBModel model) throws DBExecutionException, XMLDBModelParsingException {
  String referencesXML=_getParentHierarchiesForModelFromDB(model);
  if (referencesXML != null) {
    Document document=(Document)Utilities.parseXML(referencesXML);
    Node firstNode=document.getElementsByTagName(""String_Node_Str"").item(0);
    if (firstNode != null) {
      HashMap<String,DBModel> dBModelsMap=new HashMap<String,DBModel>();
      String modelName=model.getModelName();
      dBModelsMap.put(modelName,new DBModel(modelName));
      NodeList children=firstNode.getChildNodes();
      for (int i=0; i < children.getLength(); i++) {
        if (children.item(i).getNodeType() == Node.ELEMENT_NODE) {
          Node child=children.item(i);
          _createParentHierarchy(child,null,dBModelsMap,model);
        }
      }
      DBModel baseDBModel=dBModelsMap.get(model.getModelName());
      _populateParentList(model,baseDBModel,new LinkedList<XMLDBModel>(),model);
    }
  }
  return model;
}","/** 
 * Fetch the parent hierarchies for the given model.
 * @param model The model for which the parent hierarchies are required.
 * @exception DBExecutionException If thrown while fetching model hierarchy.
 * @throws XMLDBModelParsingException If thrown while parsing the model.
 */
private XMLDBModel _fetchHierarchyForModel(XMLDBModel model) throws DBExecutionException, XMLDBModelParsingException {
  String referencesXML=_getParentHierarchiesForModelFromDB(model);
  if (referencesXML != null) {
    Document document=(Document)Utilities.parseXML(referencesXML);
    Node firstNode=document.getElementsByTagName(""String_Node_Str"").item(0);
    if (firstNode != null) {
      HashMap<String,DBModel> dBModelsMap=new HashMap<String,DBModel>();
      String modelId=model.getModelId();
      dBModelsMap.put(modelId,new DBModel(model.getModelName(),modelId));
      NodeList children=firstNode.getChildNodes();
      for (int i=0; i < children.getLength(); i++) {
        if (children.item(i).getNodeType() == Node.ELEMENT_NODE) {
          Node child=children.item(i);
          _createParentHierarchy(child,null,dBModelsMap,model);
        }
      }
      DBModel baseDBModel=dBModelsMap.get(model.getModelId());
      _populateParentList(model,baseDBModel,new LinkedList<XMLDBModel>(),model);
    }
  }
  return model;
}"
73699,"/** 
 * Execute the attribute search on the database for the given attribute clause.
 * @param attributeClause Attribute sub-query for which search needs to bedone.
 * @return List of models matching the attribute search.
 * @exception XmlException If thrown while executing query.
 * @exception DBExecutionException Thrown if the query context is notinitialized properly.
 */
private ArrayList<String> _executeSingleAttributeMatch(String attributeClause) throws XmlException, DBExecutionException {
  ArrayList<String> modelsList=new ArrayList<String>();
  String attributeSearchQuery=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ attributeClause+ ""String_Node_Str""+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + attributeSearchQuery);
  XmlQueryContext context=_xmlManager.createQueryContext();
  if (context == null)   throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
  context.setEvaluationType(XmlQueryContext.Lazy);
  XmlResults results=_xmlManager.query(attributeSearchQuery,context,null);
  if (results != null) {
    XmlValue value;
    while (results.hasNext()) {
      value=results.next();
      modelsList.add(value.asString());
    }
  }
  return modelsList;
}","/** 
 * Execute the attribute search on the database for the given attribute clause.
 * @param attributeClause Attribute sub-query for which search needs to bedone.
 * @return List of models matching the attribute search.
 * @exception XmlException If thrown while executing query.
 * @exception DBExecutionException Thrown if the query context is notinitialized properly.
 */
private ArrayList<String> _executeSingleAttributeMatch(String attributeClause) throws XmlException, DBExecutionException {
  ArrayList<String> modelsList=new ArrayList<String>();
  String attributeSearchQuery=""String_Node_Str"" + _params.getContainerName() + ""String_Node_Str""+ attributeClause+ ""String_Node_Str""+ ""String_Node_Str"";
  XmlQueryContext context=_xmlManager.createQueryContext();
  if (context == null)   throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
  context.setEvaluationType(XmlQueryContext.Lazy);
  XmlResults results=_xmlManager.query(attributeSearchQuery,context,null);
  if (results != null) {
    XmlValue value;
    while (results.hasNext()) {
      value=results.next();
      modelsList.add(value.asString());
    }
  }
  return modelsList;
}"
73700,"/** 
 * Extract model name from the given string.
 * @param completeModelName Model name with container name.
 * @return Model name 
 */
public String _extractModelName(String completeModelName){
  if (completeModelName != null) {
    return completeModelName.substring(completeModelName.lastIndexOf(""String_Node_Str"") + 1);
  }
 else   return completeModelName;
}","/** 
 * Extract model name from the given string.
 * @param completeModelName Model name with container name.
 * @return Model name 
 */
private String _extractModelName(String completeModelName){
  if (completeModelName != null) {
    return completeModelName.substring(completeModelName.lastIndexOf(""String_Node_Str"") + 1);
  }
 else   return completeModelName;
}"
73701,"/** 
 * Create a database environment with the given configuration.
 * @param url Database URL
 * @throws DBConnectionException If thrown while creating the environment.
 */
public static void initializeDatabase(String url) throws DBConnectionException {
  if (!Utilities.checkFileExists(url)) {
    throw new DBConnectionException(""String_Node_Str"");
  }
  EnvironmentConfig config=new EnvironmentConfig();
  config.setRunRecovery(true);
  config.setCacheSize(5 * 1024 * 1024);
  config.setAllowCreate(true);
  config.setInitializeCache(true);
  config.setTransactional(true);
  config.setInitializeLocking(true);
  config.setInitializeLogging(true);
  config.setErrorStream(System.err);
  config.setMaxLockers(1000);
  config.setMaxLocks(1000);
  config.setMaxLockObjects(1000);
  config.setLockDetectMode(LockDetectMode.DEFAULT);
  File dbFile=new File(url);
  try {
    try {
      if (_environment != null)       _environment.close();
    }
 catch (    Exception e) {
    }
    _environment=new Environment(dbFile,config);
    _environmentPath=url;
  }
 catch (  FileNotFoundException e) {
    throw new DBConnectionException(""String_Node_Str"" + e.getMessage());
  }
catch (  DatabaseException e) {
    throw new DBConnectionException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Create a database environment with the given configuration.
 * @param url Database URL
 * @throws DBConnectionException If thrown while creating the environment.
 */
public static void initializeDatabase(String url) throws DBConnectionException {
  if (!Utilities.checkFileExists(url)) {
    throw new DBConnectionException(""String_Node_Str"");
  }
  EnvironmentConfig config=new EnvironmentConfig();
  config.setRunRecovery(true);
  config.setCacheSize(5 * 1024 * 1024);
  config.setAllowCreate(true);
  config.setInitializeCache(true);
  config.setTransactional(true);
  config.setInitializeLocking(true);
  config.setInitializeLogging(true);
  config.setErrorStream(System.err);
  config.setJoinEnvironment(true);
  config.setNoLocking(true);
  File dbFile=new File(url);
  try {
    try {
      if (_environment != null)       _environment.close();
    }
 catch (    Exception e) {
    }
    _environment=new Environment(dbFile,config);
    _environmentPath=url;
  }
 catch (  FileNotFoundException e) {
    throw new DBConnectionException(""String_Node_Str"" + e.getMessage());
  }
catch (  DatabaseException e) {
    throw new DBConnectionException(""String_Node_Str"" + e.getMessage());
  }
}"
73702,"/** 
 * @param query Search xQuery that needs to be executed.  
 * @param matchedModelsList Models within which we need to search for the given query criterion.
 * @return Returns a List of matching model names.
 * @throws DBExecutionException If thrown while searching in the database.
 */
private ArrayList<String> _executeGraphSearchQuery(String query,ArrayList<String> matchedModelsList) throws DBExecutionException {
  ArrayList<String> modelsList=new ArrayList<String>();
  System.out.println(""String_Node_Str"" + query);
  XmlQueryContext context;
  try {
    context=_xmlManager.createQueryContext();
    if (context == null)     throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    context.setEvaluationType(XmlQueryContext.Lazy);
    XmlResults results=_xmlManager.query(query,context,null);
    if (results != null) {
      XmlValue value;
      while (results.hasNext()) {
        value=results.next();
        modelsList.add(value.asString());
      }
    }
    if (matchedModelsList != null) {
      modelsList.retainAll(matchedModelsList);
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
  return modelsList;
}","/** 
 * @param query Search xQuery that needs to be executed.  
 * @param matchedModelsList Models within which we need to search for the given query criterion.
 * @return Returns a List of matching model names.
 * @throws DBExecutionException If thrown while searching in the database.
 */
private ArrayList<String> _executeGraphSearchQuery(String query,ArrayList<String> matchedModelsList) throws DBExecutionException {
  ArrayList<String> modelsList=new ArrayList<String>();
  XmlQueryContext context;
  try {
    context=_xmlManager.createQueryContext();
    if (context == null)     throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    context.setEvaluationType(XmlQueryContext.Lazy);
    XmlResults results=_xmlManager.query(query,context,null);
    if (results != null) {
      XmlValue value;
      while (results.hasNext()) {
        value=results.next();
        modelsList.add(value.asString());
      }
    }
    if (matchedModelsList != null) {
      modelsList.retainAll(matchedModelsList);
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
  return modelsList;
}"
73703,"/** 
 * Populate the base model with the maximal parent hierarchies.
 * @param model XMLDBModel in the hierarchy.
 * @param dbModel DBModel for the above XMLDBModel.
 * @param childHierarchy List that contains the list if previous modelsvisited in the hierarchy.
 * @param baseModel Base model for which the parent hierarchies need to bepopulated.
 */
private void _populateParentList(XMLDBModel model,DBModel dbModel,LinkedList<XMLDBModel> childHierarchy,XMLDBModel baseModel){
  ArrayList<DBModel> parentsList=dbModel._parentsList;
  if (parentsList != null && parentsList.size() > 0) {
    childHierarchy.addFirst(model);
    for (    DBModel parentDBModel : parentsList) {
      XMLDBModel parentXMLDBModel=new XMLDBModel(parentDBModel._modelName);
      _populateParentList(parentXMLDBModel,parentDBModel,childHierarchy,baseModel);
    }
    childHierarchy.removeFirst();
  }
 else {
    LinkedList<XMLDBModel> xmlDBModelParentsList=new LinkedList<XMLDBModel>();
    xmlDBModelParentsList.addAll(childHierarchy);
    xmlDBModelParentsList.addFirst(model);
    baseModel.addParentList(xmlDBModelParentsList);
  }
}","/** 
 * Populate the base model with the maximal parent hierarchies.
 * @param model XMLDBModel in the hierarchy.
 * @param dbModel DBModel for the above XMLDBModel.
 * @param childHierarchy List that contains the list if previous modelsvisited in the hierarchy.
 * @param baseModel Base model for which the parent hierarchies need to bepopulated.
 */
private void _populateParentList(XMLDBModel model,DBModel dbModel,LinkedList<XMLDBModel> childHierarchy,XMLDBModel baseModel){
  ArrayList<DBModel> parentsList=dbModel._parentsList;
  if (parentsList != null && parentsList.size() > 0) {
    childHierarchy.addFirst(model);
    for (    DBModel parentDBModel : parentsList) {
      XMLDBModel parentXMLDBModel=new XMLDBModel(parentDBModel._modelName,parentDBModel._modelId);
      _populateParentList(parentXMLDBModel,parentDBModel,childHierarchy,baseModel);
    }
    childHierarchy.removeFirst();
  }
 else {
    LinkedList<XMLDBModel> xmlDBModelParentsList=new LinkedList<XMLDBModel>();
    xmlDBModelParentsList.addAll(childHierarchy);
    xmlDBModelParentsList.addFirst(model);
    xmlDBModelParentsList.removeLast();
    baseModel.addParentList(xmlDBModelParentsList);
  }
}"
73704,"/** 
 * Create the parent hierarchy for the given base model.
 * @param currentNode Current node for which processing needs to be done.
 * @param parentNodeName Parent node for the current node.
 * @param dBModelsMap Map that contains all the DBModels as they are createdso that their parent lists can be populated.
 * @param baseModel Base model for which the hierarchy is being created.
 */
private void _createParentHierarchy(Node currentNode,String parentNodeName,HashMap<String,DBModel> dBModelsMap,XMLDBModel baseModel){
  String currentNodeName=Utilities.getValueForAttribute(currentNode,XMLDBModel.DB_MODEL_ID_ATTR);
  if (currentNodeName != null) {
    if (!dBModelsMap.containsKey(currentNodeName) && currentNode.hasChildNodes()) {
      NodeList children=currentNode.getChildNodes();
      for (int i=0; i < children.getLength(); i++) {
        if (children.item(i).getNodeType() == Node.ELEMENT_NODE) {
          Node child=children.item(i);
          _createParentHierarchy(child,currentNodeName,dBModelsMap,baseModel);
        }
      }
    }
    if (parentNodeName != null && dBModelsMap.containsKey(currentNodeName)) {
      DBModel currentDBModel=dBModelsMap.get(currentNodeName);
      DBModel parentDBModel=new DBModel(parentNodeName);
      currentDBModel.addParent(parentDBModel);
      dBModelsMap.put(parentNodeName,parentDBModel);
    }
  }
}","/** 
 * Create the parent hierarchy for the given base model.
 * @param currentNode Current node for which processing needs to be done.
 * @param parentNodeId Parent node for the current node.
 * @param dBModelsMap Map that contains all the DBModels as they are createdso that their parent lists can be populated.
 * @param baseModel Base model for which the hierarchy is being created.
 * @throws DBExecutionException 
 */
private void _createParentHierarchy(Node currentNode,String parentNodeId,HashMap<String,DBModel> dBModelsMap,XMLDBModel baseModel) throws DBExecutionException {
  String currentNodeId=Utilities.getValueForAttribute(currentNode,XMLDBModel.DB_MODEL_ID_ATTR);
  if (currentNodeId != null) {
    if (!dBModelsMap.containsKey(currentNodeId) && currentNode.hasChildNodes()) {
      NodeList children=currentNode.getChildNodes();
      for (int i=0; i < children.getLength(); i++) {
        if (children.item(i).getNodeType() == Node.ELEMENT_NODE) {
          Node child=children.item(i);
          _createParentHierarchy(child,currentNodeId,dBModelsMap,baseModel);
        }
      }
    }
    if (parentNodeId != null && dBModelsMap.containsKey(currentNodeId)) {
      DBModel currentDBModel=dBModelsMap.get(currentNodeId);
      String modelName=_getModelNameFromModelId(parentNodeId);
      DBModel parentDBModel=new DBModel(modelName,parentNodeId);
      currentDBModel.addParent(parentDBModel);
      dBModelsMap.put(parentNodeId,parentDBModel);
    }
  }
}"
73705,"/** 
 * Construct an instance with the given model name.
 */
DBModel(String modelName){
  _modelName=modelName;
}","/** 
 * Construct an instance with the given model name.
 */
DBModel(String modelName,String modelId){
  _modelId=modelId;
  _modelName=modelName;
}"
73706,"private void _commitSave(boolean isNew,String id) throws Exception {
  _updateDisplayedModel();
  xmlModel=new XMLDBModel(_modelToSave.getName());
  xmlModel.setModel(_modelToSave.exportMoML());
  xmlModel.setIsNew(isNew);
  xmlModel.setModelId(id);
  SaveModelManager saveModelManager=new SaveModelManager();
  try {
    String modelId=saveModelManager.save(xmlModel);
    if (modelId != null) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) == null) {
        StringParameter dbModelParam=new StringParameter(_modelToSave,XMLDBModel.DB_MODEL_ID_ATTR);
        dbModelParam.setExpression(modelId);
        dbModelParam.setContainer(_modelToSave);
      }
 else       if (!((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).getExpression().equals(modelId)) {
        ((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).setExpression(modelId);
      }
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
      }
 catch (      Exception e) {
        throw e;
      }
      setVisible(false);
    }
 else {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    }
  }
 catch (  DBConnectionException exception) {
    throw exception;
  }
catch (  DBExecutionException exception) {
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    throw exception;
  }
catch (  ModelAlreadyExistException exception) {
    Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    int n=JOptionPane.showOptionDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
    if (n == JOptionPane.YES_OPTION) {
      saveModelManager=null;
      _commitSave(false,null);
    }
 else {
      _rollbackModel();
    }
  }
}","private void _commitSave(boolean isNew,String id) throws Exception {
  _updateDisplayedModel();
  xmlModel=new XMLDBModel(_modelToSave.getName());
  xmlModel.setModel(_modelToSave.exportMoML());
  xmlModel.setIsNew(isNew);
  xmlModel.setModelId(id);
  SaveModelManager saveModelManager=new SaveModelManager();
  try {
    String modelId=saveModelManager.save(xmlModel);
    if (modelId != null) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) == null) {
        StringParameter dbModelParam=new StringParameter(_modelToSave,XMLDBModel.DB_MODEL_ID_ATTR);
        dbModelParam.setExpression(modelId);
        dbModelParam.setContainer(_modelToSave);
      }
 else       if (!((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).getExpression().equals(modelId)) {
        ((StringParameter)_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR)).setExpression(modelId);
      }
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
      }
 catch (      Exception e) {
        throw e;
      }
      setVisible(false);
    }
 else {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    }
  }
 catch (  DBConnectionException exception) {
    throw exception;
  }
catch (  DBExecutionException exception) {
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    throw exception;
  }
catch (  ModelAlreadyExistException exception) {
    Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    int n=JOptionPane.showOptionDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
    if (n == JOptionPane.YES_OPTION) {
      if (_modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR) != null) {
        _modelToSave.getAttribute(XMLDBModel.DB_MODEL_ID_ATTR).setContainer(null);
        try {
          MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
          change.setUndoable(true);
          _modelToSave.requestChange(change);
        }
 catch (        Exception e) {
          throw e;
        }
      }
      saveModelManager=null;
      _commitSave(false,null);
    }
 else {
      _rollbackModel();
    }
  }
}"
73707,"private void updateCache(XMLDBModel xmlDBModel) throws DBConnectionException, DBExecutionException {
  ArrayList<XMLDBModel> hierarchy=new ArrayList();
  ArrayList<XMLDBModel> modelsToRemoveList=new ArrayList();
  DBConnection dbConnection=null;
  try {
    dbConnection=DBConnectorFactory.getSyncConnection(false);
    ArrayList<XMLDBModel> modelList=new ArrayList();
    modelList.add(xmlDBModel);
    FetchHierarchyTask fetchHierarchyTask=new FetchHierarchyTask();
    fetchHierarchyTask.setModelsList(modelList);
    hierarchy=dbConnection.executeFetchHierarchyTask(fetchHierarchyTask);
    if (hierarchy != null && hierarchy.size() > 0) {
      if (hierarchy.get(0) != null) {
        if (hierarchy.get(0).getParents() != null) {
          for (          List<XMLDBModel> branch : hierarchy.get(0).getParents()) {
            for (            XMLDBModel modelToRemove : branch) {
              if (!modelsToRemoveList.contains(modelToRemove)) {
                modelsToRemoveList.add(modelToRemove);
              }
            }
          }
        }
      }
    }
  }
 catch (  DBExecutionException dbEx) {
    throw dbEx;
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  modelsToRemoveList.add(xmlDBModel);
  HashSet set=new HashSet();
  for (int i=0; i < modelsToRemoveList.size(); i++) {
    boolean val=set.add(modelsToRemoveList.get(i).getModel());
    if (val == false) {
      modelsToRemoveList.remove(i);
    }
  }
  CacheManager.removeFromCache(hierarchy);
}","private void updateCache(XMLDBModel xmlDBModel) throws DBConnectionException, DBExecutionException {
  ArrayList<XMLDBModel> hierarchy=new ArrayList();
  ArrayList<XMLDBModel> modelsToRemoveList=new ArrayList();
  DBConnection dbConnection=null;
  try {
    dbConnection=DBConnectorFactory.getSyncConnection(false);
    ArrayList<XMLDBModel> modelList=new ArrayList();
    modelList.add(xmlDBModel);
    FetchHierarchyTask fetchHierarchyTask=new FetchHierarchyTask();
    fetchHierarchyTask.setModelsList(modelList);
    hierarchy=dbConnection.executeFetchHierarchyTask(fetchHierarchyTask);
    if (hierarchy != null && hierarchy.size() > 0) {
      if (hierarchy.get(0) != null) {
        if (hierarchy.get(0).getParents() != null) {
          for (          List<XMLDBModel> branch : hierarchy.get(0).getParents()) {
            for (            XMLDBModel modelToRemove : branch) {
              if (!modelsToRemoveList.contains(modelToRemove)) {
                modelsToRemoveList.add(modelToRemove);
              }
            }
          }
        }
      }
    }
  }
 catch (  DBExecutionException dbEx) {
    throw dbEx;
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  modelsToRemoveList.add(xmlDBModel);
  HashSet set=new HashSet();
  for (int i=0; i < modelsToRemoveList.size(); i++) {
    boolean val=set.add(modelsToRemoveList.get(i).getModel());
    if (val == false) {
      modelsToRemoveList.remove(i);
    }
  }
  CacheManager.removeFromCache(modelsToRemoveList);
}"
73708,"/** 
 * Called from within the constructor to initialize the form.
 */
@SuppressWarnings(""String_Node_Str"") private void _initComponents(){
  _listItemTextField=new JTextField();
  _jScrollPane1=new JScrollPane();
  _itemsJList=new JList();
  _addButton=new JButton();
  _deleteButton=new JButton();
  _editListItemsLabel=new JLabel();
  _saveButton=new JButton();
  setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
  _itemsJList.setModel(new ArrayModelList(_storedListItems));
  _itemsJList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      _deleteButton.setEnabled(true);
    }
  }
);
  _jScrollPane1.setViewportView(_itemsJList);
  _addButton.setText(""String_Node_Str"");
  _addButton.setEnabled(false);
  _addButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (!_validate()) {
        JOptionPane.showMessageDialog(AttributeListEditFrame.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
 else {
        ((ArrayModelList)_itemsJList.getModel()).addItem(_listItemTextField.getText());
        _addButton.setEnabled(false);
        _listItemTextField.setText(""String_Node_Str"");
      }
    }
  }
);
  _deleteButton.setText(""String_Node_Str"");
  _deleteButton.setEnabled(false);
  _deleteButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      ((ArrayModelList)_itemsJList.getModel()).removeItem((String)_itemsJList.getSelectedValue());
      _deleteButton.setEnabled(false);
    }
  }
);
  _editListItemsLabel.setFont(new Font(""String_Node_Str"",1,18));
  _editListItemsLabel.setText(""String_Node_Str"");
  _saveButton.setText(""String_Node_Str"");
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(getContentPane());
  getContentPane().setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap(50,Short.MAX_VALUE).addComponent(_listItemTextField,javax.swing.GroupLayout.PREFERRED_SIZE,143,javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18,18,18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING,false).addComponent(_deleteButton,0,0,Short.MAX_VALUE).addComponent(_addButton,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE)).addGap(18,18,18).addComponent(_jScrollPane1,javax.swing.GroupLayout.PREFERRED_SIZE,156,javax.swing.GroupLayout.PREFERRED_SIZE).addGap(62,62,62)).addGroup(layout.createSequentialGroup().addGap(28,28,28).addComponent(_editListItemsLabel).addContainerGap(380,Short.MAX_VALUE)).addGroup(layout.createSequentialGroup().addGap(224,224,224).addComponent(_saveButton,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE).addGap(241,241,241)));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(38,38,38).addComponent(_editListItemsLabel).addGap(76,76,76).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(_listItemTextField,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_addButton)).addGap(30,30,30).addComponent(_deleteButton).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,79,Short.MAX_VALUE).addComponent(_saveButton).addGap(48,48,48)).addGroup(layout.createSequentialGroup().addGap(74,74,74).addComponent(_jScrollPane1,javax.swing.GroupLayout.PREFERRED_SIZE,202,javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(105,Short.MAX_VALUE)));
  _listItemTextField.addKeyListener(new KeyListener(){
    @Override public void keyTyped(    KeyEvent e){
    }
    @Override public void keyReleased(    KeyEvent e){
      if (_listItemTextField.getText().isEmpty()) {
        _addButton.setEnabled(false);
      }
 else {
        _addButton.setEnabled(true);
      }
    }
    @Override public void keyPressed(    KeyEvent e){
    }
  }
);
  _saveButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      _parentFrame.setEnabled(true);
      AttributeListEditFrame.this.dispose();
    }
  }
);
  pack();
}","/** 
 * Called from within the constructor to initialize the form.
 */
@SuppressWarnings(""String_Node_Str"") private void _initComponents(){
  _listItemTextField=new JTextField();
  _jScrollPane1=new JScrollPane();
  _itemsJList=new JList();
  _addButton=new JButton();
  _deleteButton=new JButton();
  _editListItemsLabel=new JLabel();
  _saveButton=new JButton();
  addWindowListener(new WindowListener(){
    @Override public void windowOpened(    WindowEvent e){
    }
    @Override public void windowIconified(    WindowEvent e){
    }
    @Override public void windowDeiconified(    WindowEvent e){
    }
    @Override public void windowDeactivated(    WindowEvent e){
    }
    @Override public void windowClosing(    WindowEvent e){
      _parentFrame.setEnabled(true);
      AttributeListEditFrame.this.dispose();
    }
    @Override public void windowClosed(    WindowEvent e){
      _parentFrame.setEnabled(true);
      AttributeListEditFrame.this.dispose();
    }
    @Override public void windowActivated(    WindowEvent e){
    }
  }
);
  _itemsJList.setModel(new ArrayModelList(_storedListItems));
  _itemsJList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      _deleteButton.setEnabled(true);
    }
  }
);
  _jScrollPane1.setViewportView(_itemsJList);
  _addButton.setText(""String_Node_Str"");
  _addButton.setEnabled(false);
  _addButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (!_validate()) {
        JOptionPane.showMessageDialog(AttributeListEditFrame.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
 else {
        ((ArrayModelList)_itemsJList.getModel()).addItem(_listItemTextField.getText());
        _addButton.setEnabled(false);
        _listItemTextField.setText(""String_Node_Str"");
      }
    }
  }
);
  _deleteButton.setText(""String_Node_Str"");
  _deleteButton.setEnabled(false);
  _deleteButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      ((ArrayModelList)_itemsJList.getModel()).removeItem((String)_itemsJList.getSelectedValue());
      _deleteButton.setEnabled(false);
    }
  }
);
  _editListItemsLabel.setFont(new Font(""String_Node_Str"",1,18));
  _editListItemsLabel.setText(""String_Node_Str"");
  _saveButton.setText(""String_Node_Str"");
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(getContentPane());
  getContentPane().setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addContainerGap(50,Short.MAX_VALUE).addComponent(_listItemTextField,javax.swing.GroupLayout.PREFERRED_SIZE,143,javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18,18,18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING,false).addComponent(_deleteButton,0,0,Short.MAX_VALUE).addComponent(_addButton,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE)).addGap(18,18,18).addComponent(_jScrollPane1,javax.swing.GroupLayout.PREFERRED_SIZE,156,javax.swing.GroupLayout.PREFERRED_SIZE).addGap(62,62,62)).addGroup(layout.createSequentialGroup().addGap(28,28,28).addComponent(_editListItemsLabel).addContainerGap(380,Short.MAX_VALUE)).addGroup(layout.createSequentialGroup().addGap(224,224,224).addComponent(_saveButton,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE).addGap(241,241,241)));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(38,38,38).addComponent(_editListItemsLabel).addGap(76,76,76).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(_listItemTextField,javax.swing.GroupLayout.PREFERRED_SIZE,javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(_addButton)).addGap(30,30,30).addComponent(_deleteButton).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,79,Short.MAX_VALUE).addComponent(_saveButton).addGap(48,48,48)).addGroup(layout.createSequentialGroup().addGap(74,74,74).addComponent(_jScrollPane1,javax.swing.GroupLayout.PREFERRED_SIZE,202,javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(105,Short.MAX_VALUE)));
  _listItemTextField.addKeyListener(new KeyListener(){
    @Override public void keyTyped(    KeyEvent e){
    }
    @Override public void keyReleased(    KeyEvent e){
      if (_listItemTextField.getText().isEmpty()) {
        _addButton.setEnabled(false);
      }
 else {
        _addButton.setEnabled(true);
      }
    }
    @Override public void keyPressed(    KeyEvent e){
    }
  }
);
  _saveButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      _parentFrame.setEnabled(true);
      AttributeListEditFrame.this.dispose();
    }
  }
);
  pack();
}"
73709,"/** 
 * Construct a panel associated with the search result.  The panel layout is taken care of in the constructor.  A listener is added for _modelLink, which is a button used to open the model in a new editing frame.
 * @param dbModel The model returned as a search result.
 * @param configuration The configuration under which an effigy of this model would be generated.
 */
public ModelPanel(XMLDBModel dbModel,Configuration configuration){
  setLayout(new FlowLayout(FlowLayout.LEADING));
  setAlignmentX(LEFT_ALIGNMENT);
  setMinimumSize(getMaximumSize());
  Border border=BorderFactory.createEmptyBorder(0,3,0,0);
  setBorder(border);
  _modelName=dbModel.getModelName();
  _configuration=configuration;
  JLabel modelLabel=new JLabel(""String_Node_Str"");
  add(modelLabel);
  _loadCheck=new JCheckBox();
  _loadCheck.setSelected(false);
  add(_loadCheck);
  _modelLink=new JButton(""String_Node_Str"" + _modelName + ""String_Node_Str"");
  _modelLink.setForeground(Color.BLUE);
  _modelLink.setMaximumSize(getMinimumSize());
  add(_modelLink);
  _modelLink.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      _loadModel();
    }
  }
);
}","/** 
 * Construct a panel associated with the search result.  The panel layout is taken care of in the constructor.  A listener is added for _modelLink, which is a button used to open the model in a new editing frame.
 * @param dbModel The model returned as a search result.
 * @param configuration The configuration under which an effigy of this model would be generated.
 */
public ModelPanel(XMLDBModel dbModel,Configuration configuration){
  setLayout(new FlowLayout(FlowLayout.LEADING));
  setAlignmentX(LEFT_ALIGNMENT);
  setMaximumSize(new Dimension(getMaximumSize().width,30));
  setMinimumSize(getMaximumSize());
  Border border=BorderFactory.createEmptyBorder(0,3,0,0);
  setBorder(border);
  _modelName=dbModel.getModelName();
  _configuration=configuration;
  JLabel modelLabel=new JLabel(""String_Node_Str"");
  add(modelLabel);
  _loadCheck=new JCheckBox();
  _loadCheck.setSelected(false);
  add(_loadCheck);
  _modelLink=new JButton(""String_Node_Str"" + _modelName + ""String_Node_Str"");
  _modelLink.setForeground(Color.BLUE);
  _modelLink.setMaximumSize(getMinimumSize());
  add(_modelLink);
  _modelLink.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      _loadModel();
    }
  }
);
}"
73710,"private void _saveModel() throws Exception {
  try {
    _modelToSave.setName(_attributesListPanel.getModelName());
    if (_initialModelName != null && _initialModelName.length() > 0) {
      if (!_modelToSave.getName().equals(_initialModelName)) {
        Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int n=JOptionPane.showOptionDialog(this,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
        if (n != JOptionPane.YES_OPTION) {
          return;
        }
 else {
          if (_modelToSave.getAttribute(""String_Node_Str"") != null) {
            java.util.Date time=new java.util.Date();
            ((StringParameter)_modelToSave.getAttribute(""String_Node_Str"")).setExpression(_modelToSave.getName() + ""String_Node_Str"" + String.valueOf(time.getTime()));
            System.out.println(""String_Node_Str"");
          }
        }
      }
    }
    _commitSave(_isNew());
  }
 catch (  DBConnectionException exception) {
    throw exception;
  }
catch (  DBExecutionException exception) {
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    throw exception;
  }
}","private void _saveModel() throws Exception {
  try {
    _modelToSave.setName(_attributesListPanel.getModelName());
    if (_initialModelName != null && _initialModelName.length() > 0) {
      if (!_modelToSave.getName().equals(_initialModelName)) {
        Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int n=JOptionPane.showOptionDialog(this,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
        if (n != JOptionPane.YES_OPTION) {
          return;
        }
      }
    }
    String id=null;
    if (_modelToSave.getAttribute(""String_Node_Str"") != null) {
      id=((StringParameter)_modelToSave.getAttribute(""String_Node_Str"")).getExpression();
    }
    _commitSave(_isNew(),id);
  }
 catch (  DBConnectionException exception) {
    throw exception;
  }
catch (  DBExecutionException exception) {
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    throw exception;
  }
}"
73711,"private void _commitSave(boolean isNew) throws Exception {
  _updateDisplayedModel();
  xmlModel=new XMLDBModel(_modelToSave.getName());
  xmlModel.setModel(_modelToSave.exportMoML());
  xmlModel.setIsNew(isNew);
  xmlModel.setModelId(((StringParameter)_modelToSave.getAttribute(""String_Node_Str"")).getExpression());
  SaveModelManager saveModelManager=new SaveModelManager();
  try {
    if (saveModelManager.save(xmlModel)) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      setVisible(false);
    }
 else {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    }
  }
 catch (  DBConnectionException exception) {
    throw exception;
  }
catch (  DBExecutionException exception) {
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    throw exception;
  }
catch (  ModelAlreadyExistException exception) {
    Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    int n=JOptionPane.showOptionDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
    if (n == JOptionPane.YES_OPTION) {
      saveModelManager=null;
      _commitSave(false);
    }
 else {
      _rollbackModel();
    }
  }
}","private void _commitSave(boolean isNew,String id) throws Exception {
  _updateDisplayedModel();
  xmlModel=new XMLDBModel(_modelToSave.getName());
  xmlModel.setModel(_modelToSave.exportMoML());
  xmlModel.setIsNew(isNew);
  xmlModel.setModelId(id);
  SaveModelManager saveModelManager=new SaveModelManager();
  try {
    String modelId=saveModelManager.save(xmlModel);
    if (modelId != null) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
      if (_modelToSave.getAttribute(""String_Node_Str"") == null) {
        StringParameter dbModelParam=new StringParameter(_modelToSave,""String_Node_Str"");
        dbModelParam.setExpression(modelId);
        dbModelParam.setContainer(_modelToSave);
      }
 else       if (!((StringParameter)_modelToSave.getAttribute(""String_Node_Str"")).getExpression().equals(modelId)) {
        ((StringParameter)_modelToSave.getAttribute(""String_Node_Str"")).setExpression(modelId);
      }
      try {
        MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
        change.setUndoable(true);
        _modelToSave.requestChange(change);
      }
 catch (      Exception e) {
        throw e;
      }
      setVisible(false);
    }
 else {
      JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    }
  }
 catch (  DBConnectionException exception) {
    throw exception;
  }
catch (  DBExecutionException exception) {
    throw exception;
  }
catch (  IllegalArgumentException exception) {
    throw exception;
  }
catch (  ModelAlreadyExistException exception) {
    Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    int n=JOptionPane.showOptionDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[2]);
    if (n == JOptionPane.YES_OPTION) {
      saveModelManager=null;
      _commitSave(false,null);
    }
 else {
      _rollbackModel();
    }
  }
}"
73712,"/** 
 * Construct a SaveModelToDBFrame. Add swing Components to the frame. Add listeners for the ""Save"" and ""Cancel"" buttons.
 * @param model The model that is being saved to the database.
 */
public SaveModelToDBFrame(NamedObj model){
  super(""String_Node_Str"");
  setLayout(new BoxLayout(this.getContentPane(),BoxLayout.Y_AXIS));
  _modelToSave=model;
  _initialModelName=model.getName();
  _orignialAttributes=new ArrayList();
  _attributesListPanel=new AttributesListPanel(_modelToSave);
  _tabbedPane=new JTabbedPane();
  for (  Object attribute : _modelToSave.attributeList()) {
    if (attribute instanceof StringParameter) {
      if (((StringParameter)attribute).getName() != ""String_Node_Str"" && ((StringParameter)attribute).getName() != ""String_Node_Str"" && ((StringParameter)attribute).getName() != ""String_Node_Str"" && _attributesListPanel.isDBAttribute(((StringParameter)attribute).getName())) {
        _orignialAttributes.add((StringParameter)attribute);
      }
    }
  }
  JPanel topPanel=new JPanel();
  JPanel bottomPanel=new JPanel();
  _attributesListPanel.setAlignmentX(LEFT_ALIGNMENT);
  _tabbedPane.setAlignmentX(LEFT_ALIGNMENT);
  topPanel.setAlignmentX(LEFT_ALIGNMENT);
  bottomPanel.setAlignmentX(LEFT_ALIGNMENT);
  _attributesListPanel.setAlignmentY(TOP_ALIGNMENT);
  _tabbedPane.setAlignmentY(TOP_ALIGNMENT);
  topPanel.setAlignmentY(TOP_ALIGNMENT);
  bottomPanel.setAlignmentY(TOP_ALIGNMENT);
  topPanel.setLayout(new BoxLayout(topPanel,BoxLayout.Y_AXIS));
  _tabbedPane.setLayout(new BoxLayout(_tabbedPane,BoxLayout.Y_AXIS));
  topPanel.setBorder(BorderFactory.createEmptyBorder());
  _tabbedPane.addTab(""String_Node_Str"",_attributesListPanel);
  _tabbedPane.setMnemonicAt(0,KeyEvent.VK_1);
  _tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);
  JButton save_Button;
  JButton cancel_Button;
  save_Button=new JButton(""String_Node_Str"");
  cancel_Button=new JButton(""String_Node_Str"");
  save_Button.setMnemonic(KeyEvent.VK_ENTER);
  cancel_Button.setMnemonic(KeyEvent.VK_ESCAPE);
  save_Button.setActionCommand(""String_Node_Str"");
  cancel_Button.setActionCommand(""String_Node_Str"");
  save_Button.setHorizontalTextPosition(SwingConstants.CENTER);
  cancel_Button.setHorizontalTextPosition(SwingConstants.CENTER);
  for (  Object stringParameter : _modelToSave.attributeList()) {
    if (stringParameter instanceof StringParameter && ((StringParameter)stringParameter).getName() != ""String_Node_Str"" && ((StringParameter)stringParameter).getName() != ""String_Node_Str"" && ((StringParameter)stringParameter).getName() != ""String_Node_Str"" && _attributesListPanel.isDBAttribute(((StringParameter)stringParameter).getName())) {
      _attributesListPanel.addAttribute((StringParameter)stringParameter);
    }
  }
  save_Button.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      try {
        if (!_isValid()) {
          _rollbackModel();
          return;
        }
        _saveModel();
      }
 catch (      NameDuplicationException e) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
        _rollbackModel();
      }
catch (      IllegalActionException e) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
        _rollbackModel();
      }
catch (      Exception e) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
        _rollbackModel();
      }
    }
  }
);
  cancel_Button.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      _rollbackModel();
      setVisible(false);
    }
  }
);
  topPanel.add(_tabbedPane);
  bottomPanel.add(save_Button);
  bottomPanel.add(cancel_Button);
  add(topPanel);
  add(bottomPanel);
  validate();
  repaint();
}","/** 
 * Construct a SaveModelToDBFrame. Add swing Components to the frame. Add listeners for the ""Save"" and ""Cancel"" buttons.
 * @param model The model that is being saved to the database.
 */
public SaveModelToDBFrame(NamedObj model){
  super(""String_Node_Str"");
  setLayout(new BoxLayout(this.getContentPane(),BoxLayout.Y_AXIS));
  _modelToSave=model;
  _initialModelName=model.getName();
  _orignialAttributes=new ArrayList();
  _attributesListPanel=new AttributesListPanel(_modelToSave);
  _tabbedPane=new JTabbedPane();
  for (  Object attribute : _modelToSave.attributeList()) {
    if (attribute instanceof StringParameter) {
      if (((StringParameter)attribute).getName() != ""String_Node_Str"" && ((StringParameter)attribute).getName() != ""String_Node_Str"" && _attributesListPanel.isDBAttribute(((StringParameter)attribute).getName())) {
        _orignialAttributes.add((StringParameter)attribute);
      }
    }
  }
  JPanel topPanel=new JPanel();
  JPanel bottomPanel=new JPanel();
  _attributesListPanel.setAlignmentX(LEFT_ALIGNMENT);
  _tabbedPane.setAlignmentX(LEFT_ALIGNMENT);
  topPanel.setAlignmentX(LEFT_ALIGNMENT);
  bottomPanel.setAlignmentX(LEFT_ALIGNMENT);
  _attributesListPanel.setAlignmentY(TOP_ALIGNMENT);
  _tabbedPane.setAlignmentY(TOP_ALIGNMENT);
  topPanel.setAlignmentY(TOP_ALIGNMENT);
  bottomPanel.setAlignmentY(TOP_ALIGNMENT);
  topPanel.setLayout(new BoxLayout(topPanel,BoxLayout.Y_AXIS));
  _tabbedPane.setLayout(new BoxLayout(_tabbedPane,BoxLayout.Y_AXIS));
  topPanel.setBorder(BorderFactory.createEmptyBorder());
  _tabbedPane.addTab(""String_Node_Str"",_attributesListPanel);
  _tabbedPane.setMnemonicAt(0,KeyEvent.VK_1);
  _tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);
  JButton save_Button;
  JButton cancel_Button;
  save_Button=new JButton(""String_Node_Str"");
  cancel_Button=new JButton(""String_Node_Str"");
  save_Button.setMnemonic(KeyEvent.VK_ENTER);
  cancel_Button.setMnemonic(KeyEvent.VK_ESCAPE);
  save_Button.setActionCommand(""String_Node_Str"");
  cancel_Button.setActionCommand(""String_Node_Str"");
  save_Button.setHorizontalTextPosition(SwingConstants.CENTER);
  cancel_Button.setHorizontalTextPosition(SwingConstants.CENTER);
  for (  Object stringParameter : _modelToSave.attributeList()) {
    if (stringParameter instanceof StringParameter && ((StringParameter)stringParameter).getName() != ""String_Node_Str"" && ((StringParameter)stringParameter).getName() != ""String_Node_Str"" && _attributesListPanel.isDBAttribute(((StringParameter)stringParameter).getName())) {
      _attributesListPanel.addAttribute((StringParameter)stringParameter);
    }
  }
  save_Button.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      try {
        if (!_isValid()) {
          _rollbackModel();
          return;
        }
        _saveModel();
      }
 catch (      NameDuplicationException e) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
        _rollbackModel();
      }
catch (      IllegalActionException e) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
        _rollbackModel();
      }
catch (      Exception e) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
        _rollbackModel();
      }
    }
  }
);
  cancel_Button.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      _rollbackModel();
      setVisible(false);
    }
  }
);
  topPanel.add(_tabbedPane);
  bottomPanel.add(save_Button);
  bottomPanel.add(cancel_Button);
  add(topPanel);
  add(bottomPanel);
  validate();
  repaint();
}"
73713,"private void _updateDisplayedModel() throws Exception {
  try {
    if (_modelToSave.getAttribute(""String_Node_Str"") == null) {
      StringParameter dbModelParam=new StringParameter(_modelToSave,""String_Node_Str"");
      dbModelParam.setExpression(""String_Node_Str"");
      dbModelParam.setContainer(_modelToSave);
    }
    if (_modelToSave.getAttribute(""String_Node_Str"") == null) {
      StringParameter dbModelParam=new StringParameter(_modelToSave,""String_Node_Str"");
      dbModelParam.setExpression(_modelToSave.getName());
      dbModelParam.setContainer(_modelToSave);
    }
 else {
      ((StringParameter)_modelToSave.getAttribute(""String_Node_Str"")).setExpression(_modelToSave.getName());
    }
    if (_modelToSave.getAttribute(""String_Node_Str"") == null) {
      java.util.Date time=new java.util.Date();
      StringParameter dbModelParam=new StringParameter(_modelToSave,""String_Node_Str"");
      dbModelParam.setExpression(_modelToSave.getName() + ""String_Node_Str"" + String.valueOf(time.getTime()));
      dbModelParam.setContainer(_modelToSave);
    }
    ArrayList<StringParameter> attributesList=new ArrayList();
    for (    Object a : _modelToSave.attributeList()) {
      if (a instanceof StringParameter) {
        attributesList.add((StringParameter)a);
      }
    }
    for (    StringParameter attribute : attributesList) {
      if (attribute.getName() != ""String_Node_Str"" && attribute.getName() != ""String_Node_Str"" && attribute.getName() != ""String_Node_Str"" && _attributesListPanel.isDBAttribute(attribute.getName())) {
        attribute.setContainer(null);
      }
    }
    for (    Attribute attributeToAdd : _attributesListPanel.getAttributes()) {
      attributeToAdd.setContainer(_modelToSave);
      SingletonAttribute sa=new SingletonAttribute(attributeToAdd.workspace());
      sa.setContainer(attributeToAdd);
      sa.setName(""String_Node_Str"");
      ValueIcon vi=new ValueIcon(attributeToAdd,""String_Node_Str"");
      vi.setContainer(attributeToAdd);
      ColorAttribute ca=new ColorAttribute(vi,""String_Node_Str"");
      ca.setContainer(vi);
      ca.setExpression(""String_Node_Str"");
      SingletonConfigurableAttribute sca=new SingletonConfigurableAttribute(attributeToAdd.workspace());
      sca.setContainer(attributeToAdd);
      sca.configure(null,attributeToAdd.getSource(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      VisibleParameterEditorFactory vpef=new VisibleParameterEditorFactory(attributeToAdd,""String_Node_Str"");
      vpef.setContainer(attributeToAdd);
      double[] xy={250,170};
      Location l=new Location(attributeToAdd,""String_Node_Str"");
      l.setLocation(xy);
    }
    try {
      MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
      change.setUndoable(true);
      _modelToSave.requestChange(change);
    }
 catch (    Exception e) {
      throw e;
    }
  }
 catch (  NameDuplicationException exception) {
    throw exception;
  }
catch (  IllegalActionException exception) {
    throw exception;
  }
}","private void _updateDisplayedModel() throws Exception {
  try {
    if (_modelToSave.getAttribute(""String_Node_Str"") == null) {
      StringParameter dbModelParam=new StringParameter(_modelToSave,""String_Node_Str"");
      dbModelParam.setExpression(""String_Node_Str"");
      dbModelParam.setContainer(_modelToSave);
    }
    ArrayList<StringParameter> attributesList=new ArrayList();
    for (    Object a : _modelToSave.attributeList()) {
      if (a instanceof StringParameter) {
        attributesList.add((StringParameter)a);
      }
    }
    for (    StringParameter attribute : attributesList) {
      if (attribute.getName() != ""String_Node_Str"" && attribute.getName() != ""String_Node_Str"" && _attributesListPanel.isDBAttribute(attribute.getName())) {
        attribute.setContainer(null);
      }
    }
    for (    Attribute attributeToAdd : _attributesListPanel.getAttributes()) {
      attributeToAdd.setContainer(_modelToSave);
      SingletonAttribute sa=new SingletonAttribute(attributeToAdd.workspace());
      sa.setContainer(attributeToAdd);
      sa.setName(""String_Node_Str"");
      ValueIcon vi=new ValueIcon(attributeToAdd,""String_Node_Str"");
      vi.setContainer(attributeToAdd);
      ColorAttribute ca=new ColorAttribute(vi,""String_Node_Str"");
      ca.setContainer(vi);
      ca.setExpression(""String_Node_Str"");
      SingletonConfigurableAttribute sca=new SingletonConfigurableAttribute(attributeToAdd.workspace());
      sca.setContainer(attributeToAdd);
      sca.configure(null,attributeToAdd.getSource(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      VisibleParameterEditorFactory vpef=new VisibleParameterEditorFactory(attributeToAdd,""String_Node_Str"");
      vpef.setContainer(attributeToAdd);
      double[] xy={250,170};
      Location l=new Location(attributeToAdd,""String_Node_Str"");
      l.setLocation(xy);
    }
    try {
      MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
      change.setUndoable(true);
      _modelToSave.requestChange(change);
    }
 catch (    Exception e) {
      throw e;
    }
  }
 catch (  NameDuplicationException exception) {
    throw exception;
  }
catch (  IllegalActionException exception) {
    throw exception;
  }
}"
73714,"private void _rollbackModel(){
  try {
    ArrayList<StringParameter> attributesList=new ArrayList();
    for (    Object a : _modelToSave.attributeList()) {
      if (a instanceof StringParameter) {
        attributesList.add((StringParameter)a);
      }
    }
    for (    StringParameter attribute : attributesList) {
      if (attribute.getName() != ""String_Node_Str"" && attribute.getName() != ""String_Node_Str"" && attribute.getName() != ""String_Node_Str"" && _attributesListPanel.isDBAttribute(attribute.getName())) {
        attribute.setContainer(null);
      }
    }
    for (    StringParameter attribute : _orignialAttributes) {
      attribute.setContainer(_modelToSave);
    }
    MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
    change.setUndoable(true);
    _modelToSave.requestChange(change);
  }
 catch (  Exception e) {
  }
}","private void _rollbackModel(){
  try {
    ArrayList<StringParameter> attributesList=new ArrayList();
    for (    Object a : _modelToSave.attributeList()) {
      if (a instanceof StringParameter) {
        attributesList.add((StringParameter)a);
      }
    }
    for (    StringParameter attribute : attributesList) {
      if (attribute.getName() != ""String_Node_Str"" && attribute.getName() != ""String_Node_Str"" && _attributesListPanel.isDBAttribute(attribute.getName())) {
        attribute.setContainer(null);
      }
    }
    for (    StringParameter attribute : _orignialAttributes) {
      attribute.setContainer(_modelToSave);
    }
    MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
    change.setUndoable(true);
    _modelToSave.requestChange(change);
  }
 catch (  Exception e) {
  }
}"
73715,"private boolean updateCache(XMLDBModel xmlDBModel) throws DBConnectionException, DBExecutionException {
  boolean isSuccessful=false;
  ArrayList<XMLDBModel> hierarchy=new ArrayList();
  ArrayList<XMLDBModel> modelsToRemoveList=new ArrayList();
  DBConnection dbConnection=null;
  try {
    dbConnection=DBConnectorFactory.getSyncConnection(false);
    ArrayList<XMLDBModel> modelList=new ArrayList();
    modelList.add(xmlDBModel);
    FetchHierarchyTask fetchHierarchyTask=new FetchHierarchyTask();
    fetchHierarchyTask.setModelsList(modelList);
    hierarchy=dbConnection.executeFetchHierarchyTask(fetchHierarchyTask);
    if (hierarchy != null && hierarchy.size() > 0) {
      if (hierarchy.get(0) != null) {
        if (hierarchy.get(0).getParents() != null) {
          for (          List<XMLDBModel> branch : hierarchy.get(0).getParents()) {
            for (            XMLDBModel modelToRemove : branch) {
              if (!modelsToRemoveList.contains(modelToRemove)) {
                modelsToRemoveList.add(modelToRemove);
              }
            }
          }
        }
      }
    }
  }
 catch (  DBExecutionException dbEx) {
    throw dbEx;
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  modelsToRemoveList.add(xmlDBModel);
  HashSet set=new HashSet();
  for (int i=0; i < modelsToRemoveList.size(); i++) {
    boolean val=set.add(modelsToRemoveList.get(i).getModel());
    if (val == false) {
      modelsToRemoveList.remove(i);
    }
  }
  isSuccessful=CacheManager.removeFromCache(hierarchy);
  return isSuccessful;
}","private void updateCache(XMLDBModel xmlDBModel) throws DBConnectionException, DBExecutionException {
  ArrayList<XMLDBModel> hierarchy=new ArrayList();
  ArrayList<XMLDBModel> modelsToRemoveList=new ArrayList();
  DBConnection dbConnection=null;
  try {
    dbConnection=DBConnectorFactory.getSyncConnection(false);
    ArrayList<XMLDBModel> modelList=new ArrayList();
    modelList.add(xmlDBModel);
    FetchHierarchyTask fetchHierarchyTask=new FetchHierarchyTask();
    fetchHierarchyTask.setModelsList(modelList);
    hierarchy=dbConnection.executeFetchHierarchyTask(fetchHierarchyTask);
    if (hierarchy != null && hierarchy.size() > 0) {
      if (hierarchy.get(0) != null) {
        if (hierarchy.get(0).getParents() != null) {
          for (          List<XMLDBModel> branch : hierarchy.get(0).getParents()) {
            for (            XMLDBModel modelToRemove : branch) {
              if (!modelsToRemoveList.contains(modelToRemove)) {
                modelsToRemoveList.add(modelToRemove);
              }
            }
          }
        }
      }
    }
  }
 catch (  DBExecutionException dbEx) {
    throw dbEx;
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  modelsToRemoveList.add(xmlDBModel);
  HashSet set=new HashSet();
  for (int i=0; i < modelsToRemoveList.size(); i++) {
    boolean val=set.add(modelsToRemoveList.get(i).getModel());
    if (val == false) {
      modelsToRemoveList.remove(i);
    }
  }
  CacheManager.removeFromCache(hierarchy);
}"
73716,"/** 
 * Save the changes of an existing model in the database or create a new model in the database.  Remove all prior entries to the saved model from the cache, including any other models that reference it.
 * @param xmlDBModel The model object that is required to be saved orcreated in the database.
 * @return A boolean indicator of weather the operation was successful ornot.
 * @exception DBConnectionException Thrown if there is a database connection error.
 * @exception DBExecutionException Thrown if the execution failed.
 * @exception IllegalArgumentException Thrown if the parameters were not right.
 * @exception ModelAlreadyExistException Thrown if the model being created already exists.
 * @throws XMLDBModelParsingException Thrown if the model is parsed incorrectly.
 */
public boolean save(XMLDBModel xmlDBModel) throws DBConnectionException, DBExecutionException, IllegalArgumentException, ModelAlreadyExistException, XMLDBModelParsingException {
  boolean isSuccessful=false;
  DBConnection dbConnection=null;
  try {
    if (xmlDBModel == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    xmlDBModel=populateChildModelsList(xmlDBModel);
    dbConnection=DBConnectorFactory.getSyncConnection(true);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    if (xmlDBModel.getIsNew()) {
      CreateModelTask createModelTask=new CreateModelTask(xmlDBModel);
      dbConnection.executeCreateModelTask(createModelTask);
      isSuccessful=true;
      dbConnection.commitConnection();
    }
 else {
      SaveModelTask saveModelTask=new SaveModelTask(xmlDBModel);
      dbConnection.executeSaveModelTask(saveModelTask);
      isSuccessful=true;
      dbConnection.commitConnection();
    }
  }
 catch (  DBExecutionException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  isSuccessful=(isSuccessful && updateCache(xmlDBModel));
  return isSuccessful;
}","/** 
 * Save the changes of an existing model in the database or create a new model in the database.  Remove all prior entries to the saved model from the cache, including any other models that reference it.
 * @param xmlDBModel The model object that is required to be saved orcreated in the database.
 * @return A boolean indicator of weather the operation was successful ornot.
 * @exception DBConnectionException Thrown if there is a database connection error.
 * @exception DBExecutionException Thrown if the execution failed.
 * @exception IllegalArgumentException Thrown if the parameters were not right.
 * @exception ModelAlreadyExistException Thrown if the model being created already exists.
 * @throws XMLDBModelParsingException Thrown if the model is parsed incorrectly.
 */
public String save(XMLDBModel xmlDBModel) throws DBConnectionException, DBExecutionException, IllegalArgumentException, ModelAlreadyExistException, XMLDBModelParsingException {
  String returnString=null;
  DBConnection dbConnection=null;
  try {
    if (xmlDBModel == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    xmlDBModel=populateChildModelsList(xmlDBModel);
    dbConnection=DBConnectorFactory.getSyncConnection(true);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    if (xmlDBModel.getIsNew()) {
      CreateModelTask createModelTask=new CreateModelTask(xmlDBModel);
      returnString=dbConnection.executeCreateModelTask(createModelTask);
      dbConnection.commitConnection();
    }
 else {
      SaveModelTask saveModelTask=new SaveModelTask(xmlDBModel);
      returnString=dbConnection.executeSaveModelTask(saveModelTask);
      dbConnection.commitConnection();
    }
  }
 catch (  DBExecutionException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  updateCache(xmlDBModel);
  return returnString;
}"
73717,"/** 
 * Test the SaveManager.save() method. <p> The condition for this test case: <br>- The model being saved is an existing model and should be updated in the database. </p>
 * @exception Exception Thrown if the test fails and the exception was nothandled.
 */
@Test public void testSave_SaveModel() throws Exception {
  SaveModelManager saveManager=new SaveModelManager();
  PowerMock.mockStatic(DBConnectorFactory.class);
  DBConnection dBConnectionMock=PowerMock.createMock(DBConnection.class);
  EasyMock.expect(DBConnectorFactory.getSyncConnection(true)).andReturn(dBConnectionMock);
  XMLDBModel modelMock=PowerMock.createPartialMock(XMLDBModel.class,""String_Node_Str"");
  EasyMock.expect(modelMock.getIsNew()).andReturn(false);
  SaveModelTask saveModelTaskMock=PowerMock.createMock(SaveModelTask.class);
  PowerMock.expectNew(SaveModelTask.class,modelMock).andReturn(saveModelTaskMock);
  dBConnectionMock.executeSaveModelTask(saveModelTaskMock);
  dBConnectionMock.commitConnection();
  dBConnectionMock.closeConnection();
  PowerMock.replayAll();
  boolean isSuccess=saveManager.save(modelMock);
  assertTrue(isSuccess);
  PowerMock.verifyAll();
}","/** 
 * Test the SaveManager.save() method. <p> The condition for this test case: <br>- The model being saved is an existing model and should be updated in the database. </p>
 * @exception Exception Thrown if the test fails and the exception was nothandled.
 */
@Test public void testSave_SaveModel() throws Exception {
  SaveModelManager saveManager=new SaveModelManager();
  PowerMock.mockStatic(DBConnectorFactory.class);
  DBConnection dBConnectionMock=PowerMock.createMock(DBConnection.class);
  EasyMock.expect(DBConnectorFactory.getSyncConnection(true)).andReturn(dBConnectionMock);
  XMLDBModel modelMock=PowerMock.createPartialMock(XMLDBModel.class,""String_Node_Str"");
  EasyMock.expect(modelMock.getIsNew()).andReturn(false);
  SaveModelTask saveModelTaskMock=PowerMock.createMock(SaveModelTask.class);
  PowerMock.expectNew(SaveModelTask.class,modelMock).andReturn(saveModelTaskMock);
  EasyMock.expect(dBConnectionMock.executeSaveModelTask(saveModelTaskMock)).andReturn(""String_Node_Str"");
  dBConnectionMock.commitConnection();
  dBConnectionMock.closeConnection();
  PowerMock.replayAll();
  boolean isSuccess=(saveManager.save(modelMock) != null);
  assertTrue(isSuccess);
  PowerMock.verifyAll();
}"
73718,"/** 
 * Test the SaveManager.save() method. <p> The condition for this test case:<br/> - The model being saved is a new model and should be created in the database. </p>
 * @exception Exception Thrown if the test fails and the exception was nothandled.
 */
@Test public void testSave_CreateModel() throws Exception {
  SaveModelManager saveManager=new SaveModelManager();
  PowerMock.mockStatic(DBConnectorFactory.class);
  DBConnection dBConnectionMock=PowerMock.createMock(DBConnection.class);
  EasyMock.expect(DBConnectorFactory.getSyncConnection(true)).andReturn(dBConnectionMock);
  XMLDBModel modelMock=PowerMock.createPartialMock(XMLDBModel.class,""String_Node_Str"");
  EasyMock.expect(modelMock.getIsNew()).andReturn(true);
  CreateModelTask createModelTaskMock=PowerMock.createMock(CreateModelTask.class);
  PowerMock.expectNew(CreateModelTask.class,modelMock).andReturn(createModelTaskMock);
  dBConnectionMock.executeCreateModelTask(createModelTaskMock);
  dBConnectionMock.commitConnection();
  dBConnectionMock.closeConnection();
  PowerMock.replayAll();
  boolean isSuccess=saveManager.save(modelMock);
  assertTrue(isSuccess);
  PowerMock.verifyAll();
}","/** 
 * Test the SaveManager.save() method. <p> The condition for this test case:<br/> - The model being saved is a new model and should be created in the database. </p>
 * @exception Exception Thrown if the test fails and the exception was nothandled.
 */
@Test public void testSave_CreateModel() throws Exception {
  SaveModelManager saveManager=new SaveModelManager();
  PowerMock.mockStatic(DBConnectorFactory.class);
  DBConnection dBConnectionMock=PowerMock.createMock(DBConnection.class);
  EasyMock.expect(DBConnectorFactory.getSyncConnection(true)).andReturn(dBConnectionMock);
  XMLDBModel modelMock=PowerMock.createPartialMock(XMLDBModel.class,""String_Node_Str"");
  EasyMock.expect(modelMock.getIsNew()).andReturn(true);
  CreateModelTask createModelTaskMock=PowerMock.createMock(CreateModelTask.class);
  PowerMock.expectNew(CreateModelTask.class,modelMock).andReturn(createModelTaskMock);
  EasyMock.expect(dBConnectionMock.executeCreateModelTask(createModelTaskMock)).andReturn(""String_Node_Str"");
  dBConnectionMock.commitConnection();
  dBConnectionMock.closeConnection();
  PowerMock.replayAll();
  boolean isSuccess=(saveManager.save(modelMock) != null);
  assertTrue(isSuccess);
  PowerMock.verifyAll();
}"
73719,"/** 
 * Given a model name, load a model from the cache.
 * @param modelName The name of the model to be loaded form the cache.
 * @return An XMLDBModel populated with the model's MoML string.
 * @exception DBConnectionException Thrown if a problem occurs with the cache connection.
 * @exception DBExecutionException Thrown if a problem occurs retrieving the  MoML from the database.
 */
public static XMLDBModel loadFromCache(String modelName) throws DBConnectionException, DBExecutionException {
  XMLDBModel returnXMLDBModel=null;
  DBConnection dbConnection=null;
  try {
    if (modelName.equals(null)) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    dbConnection=DBConnectorFactory.getCacheConnection(false);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    GetModelTask getModelTask=new GetModelTask(modelName);
    returnXMLDBModel=dbConnection.executeGetModelTask(getModelTask);
  }
 catch (  DBExecutionException e) {
    throw e;
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  return returnXMLDBModel;
}","/** 
 * Given a model name, load a model from the cache.
 * @param modelName The name of the model to be loaded form the cache.
 * @return An XMLDBModel populated with the model's MoML string.
 * @exception DBConnectionException Thrown if a problem occurs with the cache connection.
 * @exception DBExecutionException Thrown if a problem occurs retrieving the  MoML from the database.
 */
public static XMLDBModel loadFromCache(String modelName) throws DBConnectionException, DBExecutionException {
  XMLDBModel returnXMLDBModel=null;
  DBConnection dbConnection=null;
  try {
    if (modelName == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    dbConnection=DBConnectorFactory.getCacheConnection(false);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    GetModelTask getModelTask=new GetModelTask(modelName);
    returnXMLDBModel=dbConnection.executeGetModelTask(getModelTask);
  }
 catch (  DBExecutionException e) {
    throw e;
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
  return returnXMLDBModel;
}"
73720,"/** 
 * Update a collection of models in the cache.  If a model is not in the cache, add it.  If it is, update it.
 * @param assemblies A HashMap that maps a collection of models names to  their respective MoML strings.  These are the models to be  updated in the cache.
 * @exception DBConnectionException Thrown if a problem occurs with the cache connection.
 * @exception DBExecutionException Thrown if a problem occurs updating the cache.
 */
public static void updateCache(HashMap assemblies) throws DBConnectionException, DBExecutionException {
  DBConnection dbConnection=null;
  try {
    if (assemblies == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    dbConnection=DBConnectorFactory.getCacheConnection(true);
    Iterator iterator=assemblies.keySet().iterator();
    while (iterator.hasNext()) {
      String modelName=(String)iterator.next();
      XMLDBModel cacheModel=new XMLDBModel(modelName);
      cacheModel.setModel((String)assemblies.get(modelName));
      try {
        CreateModelTask createModelTask=new CreateModelTask(cacheModel);
        dbConnection.executeCreateModelTask(createModelTask);
      }
 catch (      ModelAlreadyExistException e) {
        SaveModelTask saveModelTask=new SaveModelTask(cacheModel);
        dbConnection.executeSaveModelTask(saveModelTask);
      }
    }
  }
 catch (  DBExecutionException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
}","/** 
 * Update a collection of models in the cache.  If a model is not in the cache, add it.  If it is, update it.
 * @param assemblies A HashMap that maps a collection of models names to  their respective MoML strings.  These are the models to be  updated in the cache.
 * @exception DBConnectionException Thrown if a problem occurs with the cache connection.
 * @exception DBExecutionException Thrown if a problem occurs updating the cache.
 */
public static void updateCache(HashMap assemblies) throws DBConnectionException, DBExecutionException {
  DBConnection dbConnection=null;
  try {
    if (assemblies == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    dbConnection=DBConnectorFactory.getCacheConnection(true);
    if (dbConnection == null) {
      throw new DBConnectionException(""String_Node_Str"");
    }
    Iterator iterator=assemblies.keySet().iterator();
    while (iterator.hasNext()) {
      String modelName=(String)iterator.next();
      XMLDBModel cacheModel=new XMLDBModel(modelName);
      cacheModel.setModel((String)assemblies.get(modelName));
      try {
        CreateModelTask createModelTask=new CreateModelTask(cacheModel);
        dbConnection.executeCreateModelTask(createModelTask);
      }
 catch (      ModelAlreadyExistException e) {
        SaveModelTask saveModelTask=new SaveModelTask(cacheModel);
        dbConnection.executeSaveModelTask(saveModelTask);
      }
    }
    dbConnection.commitConnection();
  }
 catch (  DBExecutionException e) {
    if (dbConnection != null) {
      dbConnection.abortConnection();
    }
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    if (dbConnection != null) {
      dbConnection.closeConnection();
    }
  }
}"
73721,"/** 
 * Unregister a ""published port"" coming from a publisher. The name is the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the same name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param name The name is being used in the matching processto match publisher and subscriber. This will be the port that should be removed
 * @param publisherPort The publisher port.
 * @param global If true, unregister the port all the way up the hierarchy.
 */
public void unregisterPublisherPort(String name,IOPort publisherPort,boolean global){
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).unregisterPublisherPort(name,publisherPort);
  }
 else {
    if (_publishedPorts != null) {
      List<IOPort> ports=_publishedPorts.get(name);
      ports.remove(publisherPort);
      if (ports.isEmpty()) {
        _publishedPorts.remove(name);
      }
    }
    if (_publisherRelations != null) {
      IORelation relation=_publisherRelations.get(name);
      if (relation != null) {
        try {
          relation.setContainer(null);
        }
 catch (        IllegalActionException e) {
          throw new IllegalStateException(e);
        }
catch (        NameDuplicationException e) {
          throw new IllegalStateException(e);
        }
        _publisherRelations.remove(name);
      }
    }
    if (global && container instanceof CompositeActor) {
      ((CompositeActor)container).unregisterPublisherPort(name,publisherPort,global);
    }
  }
}","/** 
 * Unregister a ""published port"" coming from a publisher. The name is the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the same name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param name The name is being used in the matching processto match publisher and subscriber. This will be the port that should be removed
 * @param publisherPort The publisher port.
 * @param global If true, unregister the port all the way up the hierarchy.
 */
public void unregisterPublisherPort(String name,IOPort publisherPort,boolean global){
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).unregisterPublisherPort(name,publisherPort);
  }
 else {
    if (_publishedPorts != null) {
      List<IOPort> ports=_publishedPorts.get(name);
      ports.remove(publisherPort);
      if (ports.isEmpty()) {
        _publishedPorts.remove(name);
      }
    }
    if (_publisherRelations != null) {
      IORelation relation=_publisherRelations.get(name);
      if (relation != null) {
        try {
          relation.setContainer(null);
          notifyConnectivityChange();
        }
 catch (        IllegalActionException e) {
          throw new IllegalStateException(e);
        }
catch (        NameDuplicationException e) {
          throw new IllegalStateException(e);
        }
        _publisherRelations.remove(name);
      }
    }
    if (global && container instanceof CompositeActor) {
      ((CompositeActor)container).unregisterPublisherPort(name,publisherPort,global);
    }
  }
}"
73722,"/** 
 * Link the subscriberPort with a already registered ""published port"" coming from a publisher. The pattern represents the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the  name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param pattern The pattern is being used in the matching processto match publisher and subscriber.
 * @param subscriberPort The subscribed port. 
 * @exception NameDuplicationException If there are name conflictsas a result of the added relations or ports. 
 * @exception IllegalActionException If the published port cannot be found.
 */
public void linkToPublishedPort(Pattern pattern,TypedIOPort subscriberPort,boolean global) throws IllegalActionException, NameDuplicationException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).linkToPublishedPort(pattern,subscriberPort,global);
  }
 else {
    if (_publishedPorts != null) {
      for (      String name : _publishedPorts.keySet()) {
        Matcher matcher=pattern.matcher(name);
        if (matcher.matches()) {
          linkToPublishedPort(name,subscriberPort);
        }
      }
      if (global && this != toplevel()) {
        String portName=""String_Node_Str"" + StringUtilities.sanitizeName(pattern.toString());
        IOPort port=(IOPort)getPort(portName);
        if (port == null) {
          port=(IOPort)newPort(portName);
          new Parameter(port,""String_Node_Str"",BooleanToken.TRUE);
          port.setPersistent(false);
          port.setInput(true);
          port.setMultiport(true);
          port.setDefaultWidth(0);
          IORelation relation=null;
          try {
            relation=(IORelation)newRelation(uniqueName(subscriberPort.getContainer().getName() + ""String_Node_Str""));
          }
 catch (          NameDuplicationException e) {
            throw new IllegalStateException(e);
          }
          relation.setPersistent(false);
          new Parameter(relation,""String_Node_Str"",BooleanToken.TRUE);
          port.liberalLink(relation);
          if (!subscriberPort.isLinked(relation)) {
            subscriberPort.liberalLink(relation);
          }
        }
        if (container instanceof CompositeActor) {
          ((CompositeActor)container).linkToPublishedPort(pattern,(TypedIOPort)port,global);
        }
      }
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + subscriberPort.getContainer().getFullName());
    }
  }
}","/** 
 * Link the subscriberPort with a already registered ""published port"" coming from a publisher. The pattern represents the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the  name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param pattern The pattern is being used in the matching processto match publisher and subscriber.
 * @param subscriberPort The subscribed port. 
 * @exception NameDuplicationException If there are name conflictsas a result of the added relations or ports. 
 * @exception IllegalActionException If the published port cannot be found.
 */
public void linkToPublishedPort(Pattern pattern,TypedIOPort subscriberPort,boolean global) throws IllegalActionException, NameDuplicationException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).linkToPublishedPort(pattern,subscriberPort,global);
  }
 else {
    if (_publishedPorts != null) {
      for (      String name : _publishedPorts.keySet()) {
        Matcher matcher=pattern.matcher(name);
        if (matcher.matches()) {
          linkToPublishedPort(name,subscriberPort);
        }
      }
      if (global && this != toplevel()) {
        String portName=""String_Node_Str"" + StringUtilities.sanitizeName(pattern.toString());
        IOPort port=(IOPort)getPort(portName);
        if (port == null) {
          port=(IOPort)newPort(portName);
          new Parameter(port,""String_Node_Str"",BooleanToken.TRUE);
          port.setPersistent(false);
          port.setInput(true);
          port.setMultiport(true);
          port.setDefaultWidth(0);
          IORelation relation=null;
          try {
            relation=(IORelation)newRelation(uniqueName(subscriberPort.getContainer().getName() + ""String_Node_Str""));
          }
 catch (          NameDuplicationException e) {
            throw new IllegalStateException(e);
          }
          relation.setPersistent(false);
          new Parameter(relation,""String_Node_Str"",BooleanToken.TRUE);
          port.liberalLink(relation);
          if (!subscriberPort.isLinked(relation)) {
            subscriberPort.liberalLink(relation);
            notifyConnectivityChange();
          }
        }
        if (container instanceof CompositeActor) {
          ((CompositeActor)container).linkToPublishedPort(pattern,(TypedIOPort)port,global);
        }
      }
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + subscriberPort.getContainer().getFullName());
    }
  }
}"
73723,"/** 
 * Register a ""published port"" coming from a publisher. The name is the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the same name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param name The name is being used in the matching processto match publisher and subscriber.
 * @param port The published port. 
 * @param global If true, publish globally. If false, publishonly to subscribers that are fired by the same director.
 * @exception NameDuplicationException If the published portis already registered.
 * @exception IllegalActionException If the published port can'tbe added.
 */
public void registerPublisherPort(String name,IOPort port,boolean global) throws NameDuplicationException, IllegalActionException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).registerPublisherPort(name,port,global);
  }
 else {
    if (_publishedPorts == null) {
      _publishedPorts=new HashMap<String,List<IOPort>>();
    }
    List<IOPort> portList=_publishedPorts.get(name);
    if (portList == null) {
      portList=new LinkedList<IOPort>();
      _publishedPorts.put(name,portList);
    }
    if (!portList.contains(port))     portList.add(port);
    if (global && this != toplevel()) {
      String portName=""String_Node_Str"" + StringUtilities.sanitizeName(name);
      IOPort publisherPort=(IOPort)getPort(portName);
      if (publisherPort == null) {
        publisherPort=(IOPort)newPort(portName);
        new Parameter(publisherPort,""String_Node_Str"",BooleanToken.TRUE);
        publisherPort.setPersistent(false);
        publisherPort.setOutput(true);
        publisherPort.setMultiport(true);
      }
      linkToPublishedPort(name,publisherPort);
      if (container instanceof CompositeActor) {
        ((CompositeActor)container).registerPublisherPort(name,publisherPort,global);
      }
    }
  }
}","/** 
 * Register a ""published port"" coming from a publisher. The name is the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the same name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param name The name is being used in the matching processto match publisher and subscriber.
 * @param port The published port. 
 * @param global If true, publish globally. If false, publishonly to subscribers that are fired by the same director.
 * @exception NameDuplicationException If the published portis already registered.
 * @exception IllegalActionException If the published port can'tbe added.
 */
public void registerPublisherPort(String name,IOPort port,boolean global) throws NameDuplicationException, IllegalActionException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).registerPublisherPort(name,port,global);
  }
 else {
    if (_publishedPorts == null) {
      _publishedPorts=new HashMap<String,List<IOPort>>();
    }
    List<IOPort> portList=_publishedPorts.get(name);
    if (portList == null) {
      portList=new LinkedList<IOPort>();
      _publishedPorts.put(name,portList);
    }
    if (!portList.contains(port))     portList.add(port);
    if (global && this != toplevel()) {
      String portName=""String_Node_Str"" + StringUtilities.sanitizeName(name);
      IOPort publisherPort=(IOPort)getPort(portName);
      if (publisherPort == null) {
        publisherPort=(IOPort)newPort(portName);
        new Parameter(publisherPort,""String_Node_Str"",BooleanToken.TRUE);
        publisherPort.setPersistent(false);
        publisherPort.setOutput(true);
        publisherPort.setMultiport(true);
      }
      linkToPublishedPort(name,publisherPort);
      if (container instanceof CompositeActor) {
        ((CompositeActor)container).registerPublisherPort(name,publisherPort,global);
      }
    }
    if (global && this == toplevel()) {
      TypedIOPort discardPort=null;
      if (discardPort == null) {
        Discard discard=new Discard(this,uniqueName(""String_Node_Str""));
        discard.setPersistent(false);
        new Parameter(discard,""String_Node_Str"",BooleanToken.TRUE);
        discardPort=discard.input;
      }
      IORelation relation=_publisherRelations != null ? _publisherRelations.get(name) : null;
      if (relation == null) {
        IOPort publishedPort=getPublishedPort(name);
        try {
          relation=(IORelation)newRelation(uniqueName(""String_Node_Str""));
        }
 catch (        NameDuplicationException e) {
          throw new IllegalStateException(e);
        }
        relation.setPersistent(false);
        new Parameter(relation,""String_Node_Str"",BooleanToken.TRUE);
        publishedPort.liberalLink(relation);
        if (_publisherRelations == null) {
          _publisherRelations=new HashMap<String,IORelation>();
        }
        _publisherRelations.put(name,relation);
      }
      if (!discardPort.isLinked(relation)) {
        discardPort.liberalLink(relation);
        notifyConnectivityChange();
        Director director=getDirector();
        if (director != null) {
          director.invalidateSchedule();
          director.invalidateResolvedTypes();
        }
      }
    }
  }
}"
73724,"/** 
 * Link the subscriberPort with a already registered ""published port"" coming from a publisher. The pattern represents the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the  name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param pattern The pattern is being used in the matching processto match publisher and subscriber.
 * @param subscriberPort The subscribed port. 
 * @exception NameDuplicationException If there are name conflictsas a result of the added relations or ports. 
 * @exception IllegalActionException If the published port cannot be found.
 */
public void linkToPublishedPort(Pattern pattern,TypedIOPort subscriberPort,boolean global) throws IllegalActionException, NameDuplicationException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).linkToPublishedPort(pattern,subscriberPort,global);
  }
 else {
    if (_publishedPorts != null) {
      for (      String name : _publishedPorts.keySet()) {
        Matcher matcher=pattern.matcher(name);
        if (matcher.matches()) {
          linkToPublishedPort(name,subscriberPort);
        }
      }
      if (global && this != toplevel()) {
        String portName=""String_Node_Str"" + StringUtilities.sanitizeName(pattern.toString());
        IOPort port=(IOPort)getPort(portName);
        if (port == null) {
          port=(IOPort)newPort(portName);
          new Parameter(port,""String_Node_Str"",BooleanToken.TRUE);
          port.setPersistent(false);
          port.setInput(true);
          port.setMultiport(true);
          port.setDefaultWidth(0);
          IORelation relation=null;
          try {
            relation=(IORelation)newRelation(uniqueName(subscriberPort.getContainer().getName() + ""String_Node_Str""));
          }
 catch (          NameDuplicationException e) {
            throw new IllegalStateException(e);
          }
          relation.setPersistent(false);
          new Parameter(relation,""String_Node_Str"",BooleanToken.TRUE);
          port.liberalLink(relation);
          if (!subscriberPort.isLinked(relation)) {
            subscriberPort.liberalLink(relation);
            notifyConnectivityChange();
          }
        }
        if (container instanceof CompositeActor) {
          ((CompositeActor)container).linkToPublishedPort(pattern,(TypedIOPort)port,global);
        }
      }
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + subscriberPort.getContainer().getFullName());
    }
  }
}","/** 
 * Link the subscriberPort with a already registered ""published port"" coming from a publisher. The pattern represents the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the  name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param pattern The pattern is being used in the matching processto match publisher and subscriber.
 * @param subscriberPort The subscribed port. 
 * @exception NameDuplicationException If there are name conflictsas a result of the added relations or ports. 
 * @exception IllegalActionException If the published port cannot be found.
 */
public void linkToPublishedPort(Pattern pattern,TypedIOPort subscriberPort,boolean global) throws IllegalActionException, NameDuplicationException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).linkToPublishedPort(pattern,subscriberPort,global);
  }
 else {
    if (_publishedPorts != null) {
      for (      String name : _publishedPorts.keySet()) {
        Matcher matcher=pattern.matcher(name);
        if (matcher.matches()) {
          linkToPublishedPort(name,subscriberPort);
        }
      }
    }
    if (global && this != toplevel()) {
      String portName=""String_Node_Str"" + StringUtilities.sanitizeName(pattern.toString());
      IOPort port=(IOPort)getPort(portName);
      if (port == null) {
        port=(IOPort)newPort(portName);
        new Parameter(port,""String_Node_Str"",BooleanToken.TRUE);
        port.setPersistent(false);
        port.setInput(true);
        port.setMultiport(true);
        port.setDefaultWidth(0);
        IORelation relation=null;
        try {
          relation=(IORelation)newRelation(uniqueName(subscriberPort.getContainer().getName() + ""String_Node_Str""));
        }
 catch (        NameDuplicationException e) {
          throw new IllegalStateException(e);
        }
        relation.setPersistent(false);
        new Parameter(relation,""String_Node_Str"",BooleanToken.TRUE);
        port.liberalLink(relation);
        if (!subscriberPort.isLinked(relation)) {
          subscriberPort.liberalLink(relation);
          notifyConnectivityChange();
        }
      }
      if (container instanceof CompositeActor) {
        ((CompositeActor)container).linkToPublishedPort(pattern,(TypedIOPort)port,global);
      }
    }
  }
}"
73725,"public void actionPerformed(ActionEvent e){
  super.actionPerformed(e);
  SearchResultsFrame searchResultsFrame=new SearchResultsFrame(new NamedObj(),DbSearchFrame.this,DbSearchFrame.this.getConfiguration());
  SearchResultBuffer searchResultBuffer=new SearchResultBuffer();
  searchResultBuffer.addObserver(searchResultsFrame);
  SearchCriteria searchCriteria=new SearchCriteria();
  TransformationRule rule=getFrameController().getTransformationRule();
  Pattern pattern=rule.getPattern();
  ArrayList<Attribute> attributesList=new ArrayList<Attribute>();
  List<NamedObj> attributes=pattern.attributeList();
  for (Iterator iterator=attributes.iterator(); iterator.hasNext(); ) {
    NamedObj attribute=(NamedObj)iterator.next();
    if (attribute instanceof Variable) {
      attributesList.add((Variable)attribute);
    }
  }
  searchCriteria.setAttributes(attributesList);
  DBGraphSearchCriteria dbGraphSearchCriteria=new DBGraphSearchCriteria();
  List<Port> portsList=pattern.portList();
  ArrayList<Port> ports=new ArrayList<Port>();
  for (Iterator iterator=portsList.iterator(); iterator.hasNext(); ) {
    Port port=(Port)iterator.next();
    ports.add(port);
  }
  dbGraphSearchCriteria.setPortsList(ports);
  List<Relation> relationsList=pattern.relationList();
  ArrayList<Relation> relations=new ArrayList<Relation>();
  for (Iterator iterator=relationsList.iterator(); iterator.hasNext(); ) {
    Relation relation=(Relation)iterator.next();
    relations.add(relation);
  }
  dbGraphSearchCriteria.setRelationsList(relations);
  ArrayList<ComponentEntity> componentEntities=new ArrayList<ComponentEntity>();
  ArrayList<CompositeEntity> compositeEntities=new ArrayList<CompositeEntity>();
  for (Iterator iterator=pattern.entityList().iterator(); iterator.hasNext(); ) {
    Entity entity=(Entity)iterator.next();
    if (entity instanceof CompositeEntity) {
      compositeEntities.add((CompositeEntity)entity);
    }
 else     if (entity instanceof ComponentEntity) {
      componentEntities.add((ComponentEntity)entity);
    }
  }
  dbGraphSearchCriteria.setComponentEntitiesList(componentEntities);
  dbGraphSearchCriteria.setCompositeEntities(compositeEntities);
  searchCriteria.setDBGraphSearchCriteria(dbGraphSearchCriteria);
  if (attributesList.size() == 0 && pattern.portList().isEmpty() && pattern.relationList().isEmpty() && pattern.entityList().isEmpty()) {
    JOptionPane.showMessageDialog(DbSearchFrame.this,""String_Node_Str"");
  }
 else {
    searchResultsFrame.pack();
    searchResultsFrame.setVisible(true);
    SearchManager searchManager=new SearchManager();
    try {
      searchManager.search(searchCriteria,searchResultBuffer);
    }
 catch (    DBConnectionException e1) {
      searchResultsFrame.setVisible(false);
      searchResultsFrame.dispose();
      MessageHandler.error(""String_Node_Str"",e1);
    }
catch (    DBExecutionException e2) {
      searchResultsFrame.setVisible(false);
      searchResultsFrame.dispose();
      MessageHandler.error(""String_Node_Str"",e2);
    }
  }
}","public void actionPerformed(ActionEvent e){
  super.actionPerformed(e);
  SearchResultsFrame searchResultsFrame=new SearchResultsFrame(new NamedObj(),DbSearchFrame.this,DbSearchFrame.this.getConfiguration());
  SearchResultBuffer searchResultBuffer=new SearchResultBuffer();
  searchResultBuffer.addObserver(searchResultsFrame);
  SearchCriteria searchCriteria=new SearchCriteria();
  TransformationRule rule=getFrameController().getTransformationRule();
  Pattern pattern=rule.getPattern();
  ArrayList<Attribute> attributesList=new ArrayList<Attribute>();
  List<NamedObj> attributes=pattern.attributeList();
  for (Iterator iterator=attributes.iterator(); iterator.hasNext(); ) {
    NamedObj attribute=(NamedObj)iterator.next();
    if (attribute instanceof Variable) {
      attributesList.add((Variable)attribute);
    }
  }
  searchCriteria.setAttributes(attributesList);
  DBGraphSearchCriteria dbGraphSearchCriteria=new DBGraphSearchCriteria();
  List<Port> portsList=pattern.portList();
  ArrayList<Port> ports=new ArrayList<Port>();
  for (Iterator iterator=portsList.iterator(); iterator.hasNext(); ) {
    Port port=(Port)iterator.next();
    ports.add(port);
  }
  dbGraphSearchCriteria.setPortsList(ports);
  List<Relation> relationsList=pattern.relationList();
  ArrayList<Relation> relations=new ArrayList<Relation>();
  for (Iterator iterator=relationsList.iterator(); iterator.hasNext(); ) {
    Relation relation=(Relation)iterator.next();
    relations.add(relation);
  }
  dbGraphSearchCriteria.setRelationsList(relations);
  ArrayList<ComponentEntity> componentEntities=new ArrayList<ComponentEntity>();
  ArrayList<CompositeEntity> compositeEntities=new ArrayList<CompositeEntity>();
  for (Iterator iterator=pattern.entityList().iterator(); iterator.hasNext(); ) {
    Entity entity=(Entity)iterator.next();
    if (entity instanceof CompositeEntity) {
      compositeEntities.add((CompositeEntity)entity);
    }
 else     if (entity instanceof ComponentEntity) {
      componentEntities.add((ComponentEntity)entity);
    }
  }
  dbGraphSearchCriteria.setComponentEntitiesList(componentEntities);
  dbGraphSearchCriteria.setCompositeEntities(compositeEntities);
  dbGraphSearchCriteria.setPattern(pattern);
  searchCriteria.setDBGraphSearchCriteria(dbGraphSearchCriteria);
  if (attributesList.size() == 0 && pattern.portList().isEmpty() && pattern.relationList().isEmpty() && pattern.entityList().isEmpty()) {
    JOptionPane.showMessageDialog(DbSearchFrame.this,""String_Node_Str"");
  }
 else {
    searchResultsFrame.pack();
    searchResultsFrame.setVisible(true);
    SearchManager searchManager=new SearchManager();
    try {
      searchManager.search(searchCriteria,searchResultBuffer);
    }
 catch (    DBConnectionException e1) {
      searchResultsFrame.setVisible(false);
      searchResultsFrame.dispose();
      MessageHandler.error(""String_Node_Str"",e1);
    }
catch (    DBExecutionException e2) {
      searchResultsFrame.setVisible(false);
      searchResultsFrame.dispose();
      MessageHandler.error(""String_Node_Str"",e2);
    }
  }
}"
73726,"@Override protected boolean _isSearchCriteriaSet(){
  if (_commandSearchCriteria != null) {
    return true;
  }
  return false;
}","@Override protected boolean _isSearchCriteriaSet(){
  if (_commandSearchCriteria == null || _commandSearchCriteria.equals(""String_Node_Str"")) {
    return false;
  }
  return true;
}"
73727,"@Override protected boolean _isSearchCriteriaSet(){
  if (_dbGraphSearchCriteria != null) {
    return true;
  }
  return false;
}","@Override protected boolean _isSearchCriteriaSet(){
  if (_dbGraphSearchCriteria != null && (!_dbGraphSearchCriteria.getPortsList().isEmpty() || !_dbGraphSearchCriteria.getComponentEntitiesList().isEmpty() || !_dbGraphSearchCriteria.getCompositeEntities().isEmpty())) {
    return true;
  }
  return false;
}"
73728,"/** 
 * Link the subscriberPort with a already registered ""published port"" coming from a publisher. The pattern represents the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the  name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param pattern The pattern is being used in the matching processto match publisher and subscriber.
 * @param subscriberPort The subscribed port. 
 * @exception NameDuplicationException If there are name conflictsas a result of the added relations or ports. 
 * @exception IllegalActionException If the published port cannot be found.
 */
public void linkToPublishedPort(Pattern pattern,TypedIOPort subscriberPort,boolean global) throws IllegalActionException, NameDuplicationException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).linkToPublishedPort(pattern,subscriberPort,global);
  }
 else {
    if (_publishedPorts != null) {
      for (      String name : _publishedPorts.keySet()) {
        Matcher matcher=pattern.matcher(name);
        if (matcher.matches()) {
          linkToPublishedPort(name,subscriberPort);
        }
      }
      if (global && this != toplevel()) {
        String portName=""String_Node_Str"" + StringUtilities.sanitizeName(pattern.toString());
        IOPort port=(IOPort)getPort(portName);
        if (port == null) {
          port=(IOPort)newPort(portName);
          new Parameter(port,""String_Node_Str"",BooleanToken.TRUE);
          port.setPersistent(false);
          port.setInput(true);
          port.setMultiport(true);
          port.setDefaultWidth(0);
          IORelation relation=null;
          try {
            relation=(IORelation)newRelation(uniqueName(subscriberPort.getContainer().getName() + ""String_Node_Str""));
          }
 catch (          NameDuplicationException e) {
            throw new IllegalStateException(e);
          }
          relation.setPersistent(false);
          new Parameter(relation,""String_Node_Str"",BooleanToken.TRUE);
          port.liberalLink(relation);
          if (!subscriberPort.isLinked(relation)) {
            subscriberPort.liberalLink(relation);
          }
        }
        if (container instanceof CompositeActor) {
          ((CompositeActor)container).linkToPublishedPort(pattern,subscriberPort,global);
        }
      }
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + subscriberPort.getContainer().getFullName());
    }
  }
}","/** 
 * Link the subscriberPort with a already registered ""published port"" coming from a publisher. The pattern represents the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the  name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param pattern The pattern is being used in the matching processto match publisher and subscriber.
 * @param subscriberPort The subscribed port. 
 * @exception NameDuplicationException If there are name conflictsas a result of the added relations or ports. 
 * @exception IllegalActionException If the published port cannot be found.
 */
public void linkToPublishedPort(Pattern pattern,TypedIOPort subscriberPort,boolean global) throws IllegalActionException, NameDuplicationException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).linkToPublishedPort(pattern,subscriberPort,global);
  }
 else {
    if (_publishedPorts != null) {
      for (      String name : _publishedPorts.keySet()) {
        Matcher matcher=pattern.matcher(name);
        if (matcher.matches()) {
          linkToPublishedPort(name,subscriberPort);
        }
      }
      if (global && this != toplevel()) {
        String portName=""String_Node_Str"" + StringUtilities.sanitizeName(pattern.toString());
        IOPort port=(IOPort)getPort(portName);
        if (port == null) {
          port=(IOPort)newPort(portName);
          new Parameter(port,""String_Node_Str"",BooleanToken.TRUE);
          port.setPersistent(false);
          port.setInput(true);
          port.setMultiport(true);
          port.setDefaultWidth(0);
          IORelation relation=null;
          try {
            relation=(IORelation)newRelation(uniqueName(subscriberPort.getContainer().getName() + ""String_Node_Str""));
          }
 catch (          NameDuplicationException e) {
            throw new IllegalStateException(e);
          }
          relation.setPersistent(false);
          new Parameter(relation,""String_Node_Str"",BooleanToken.TRUE);
          port.liberalLink(relation);
          if (!subscriberPort.isLinked(relation)) {
            subscriberPort.liberalLink(relation);
          }
        }
        if (container instanceof CompositeActor) {
          ((CompositeActor)container).linkToPublishedPort(pattern,(TypedIOPort)port,global);
        }
      }
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + subscriberPort.getContainer().getFullName());
    }
  }
}"
73729,"private boolean _isValid() throws NameDuplicationException, IllegalActionException {
  if (_attributesListPanel.getModelName().length() == 0) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.getModelName().matches(""String_Node_Str"")) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (_attributesListPanel.containsDuplicates()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeNamesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (_attributesListPanel.allAttributeValuesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  return true;
}","private boolean _isValid() throws NameDuplicationException, IllegalActionException {
  if (_attributesListPanel.getModelName().length() == 0) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.getModelName().matches(""String_Node_Str"")) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (_attributesListPanel.containsDuplicates()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeNamesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeValuesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  return true;
}"
73730,"/** 
 * Get an indication if all attributes in the panel have names.
 * @return An indication if all attributes in the panel have names. (true they do. false if they do not).
 */
public boolean allAttributeNamesSet(){
  Component[] componentArray1=_attListPanel.getComponents();
  for (int i=0; i < componentArray1.length; i++) {
    if (componentArray1[i] instanceof JPanel) {
      Component[] componentArray2=((JPanel)componentArray1[i]).getComponents();
      for (int j=0; j < componentArray2.length; j++) {
        if (componentArray2[j] instanceof ModelAttributePanel) {
          if (((ModelAttributePanel)componentArray2[j]).getAttributeName().length() <= 0) {
            return false;
          }
        }
      }
    }
  }
  return true;
}","/** 
 * Get an indication if all attributes in the panel have names.
 * @return An indication if all attributes in the panel have names. (true they do. false if they do not).
 */
public boolean allAttributeNamesSet(){
  Component[] componentArray1=_attListPanel.getComponents();
  for (int i=0; i < componentArray1.length; i++) {
    if (componentArray1[i] instanceof JPanel) {
      Component[] componentArray2=((JPanel)componentArray1[i]).getComponents();
      for (int j=0; j < componentArray2.length; j++) {
        if (componentArray2[j] instanceof ModelAttributePanel) {
          if (((ModelAttributePanel)componentArray2[j]).getAttributeName().equals(""String_Node_Str"")) {
            return false;
          }
        }
      }
    }
  }
  return true;
}"
73731,"/** 
 * Get the value of this attribute.
 * @return The string value of the attribute, It is obtained from the applicable form Component based on the type mapped to the selected attribute.
 * @see #setValue
 */
public String getValue(){
  if (((XMLDBAttribute)_attributeMap.get(_attributeName.getSelectedItem().toString())).getAttributeType().equals(XMLDBAttribute.ATTRIBUTE_TYPE_STRING)) {
    return _textValue.getText();
  }
 else   if (((XMLDBAttribute)_attributeMap.get(_attributeName.getSelectedItem().toString())).getAttributeType().equals(XMLDBAttribute.ATTRIBUTE_TYPE_LIST)) {
    if (_listValue.getSelectedItem() != null) {
      return _listValue.getSelectedItem().toString();
    }
 else {
      return ""String_Node_Str"";
    }
  }
 else   if (((XMLDBAttribute)_attributeMap.get(_attributeName.getSelectedItem().toString())).getAttributeType().equals(XMLDBAttribute.ATTRIBUTE_TYPE_BOOLEAN)) {
    if (_booleanValue.isSelected()) {
      return ""String_Node_Str"";
    }
 else {
      return ""String_Node_Str"";
    }
  }
 else {
    return null;
  }
}","/** 
 * Get the value of this attribute.
 * @return The string value of the attribute, It is obtained from the applicable form Component based on the type mapped to the selected attribute.
 * @see #setValue
 */
public String getValue(){
  try {
    if (((XMLDBAttribute)_attributeMap.get(_attributeName.getSelectedItem().toString())).getAttributeType().equals(XMLDBAttribute.ATTRIBUTE_TYPE_STRING)) {
      return _textValue.getText();
    }
 else     if (((XMLDBAttribute)_attributeMap.get(_attributeName.getSelectedItem().toString())).getAttributeType().equals(XMLDBAttribute.ATTRIBUTE_TYPE_LIST)) {
      if (_listValue.getSelectedItem() != null) {
        return _listValue.getSelectedItem().toString();
      }
 else {
        return ""String_Node_Str"";
      }
    }
 else     if (((XMLDBAttribute)_attributeMap.get(_attributeName.getSelectedItem().toString())).getAttributeType().equals(XMLDBAttribute.ATTRIBUTE_TYPE_BOOLEAN)) {
      if (_booleanValue.isSelected()) {
        return ""String_Node_Str"";
      }
 else {
        return ""String_Node_Str"";
      }
    }
 else {
      return ""String_Node_Str"";
    }
  }
 catch (  NullPointerException e) {
    return ""String_Node_Str"";
  }
}"
73732,"private boolean _isValid() throws NameDuplicationException, IllegalActionException {
  if (_attributesListPanel.getModelName().length() == 0) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.getModelName().matches(""String_Node_Str"")) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (_attributesListPanel.containsDuplicates()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeNamesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  return true;
}","private boolean _isValid() throws NameDuplicationException, IllegalActionException {
  if (_attributesListPanel.getModelName().length() == 0) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.getModelName().matches(""String_Node_Str"")) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (_attributesListPanel.containsDuplicates()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (!_attributesListPanel.allAttributeNamesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  if (_attributesListPanel.allAttributeValuesSet()) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
    return false;
  }
  return true;
}"
73733,"/** 
 * Construct a SaveModelToDBFrame. Add swing Components to the frame. Add listeners for the ""Save"" and ""Cancel"" buttons.
 * @param model The model that is being saved to the database.
 */
public SaveModelToDBFrame(NamedObj model){
  super(""String_Node_Str"");
  setLayout(new BoxLayout(this.getContentPane(),BoxLayout.Y_AXIS));
  _modelToSave=model;
  _initialModelName=model.getName();
  _orignialAttributes=new ArrayList();
  _attributesListPanel=new AttributesListPanel(_modelToSave);
  _tabbedPane=new JTabbedPane();
  for (  Object attribute : _modelToSave.attributeList()) {
    if (attribute instanceof StringParameter) {
      if (((StringParameter)attribute).getName() != ""String_Node_Str"" && ((StringParameter)attribute).getName() != ""String_Node_Str"" && _attributesListPanel.isDBAttribute(((StringParameter)attribute).getName())) {
        _orignialAttributes.add((StringParameter)attribute);
      }
    }
  }
  JPanel topPanel=new JPanel();
  JPanel bottomPanel=new JPanel();
  _attributesListPanel.setAlignmentX(LEFT_ALIGNMENT);
  _tabbedPane.setAlignmentX(LEFT_ALIGNMENT);
  topPanel.setAlignmentX(LEFT_ALIGNMENT);
  bottomPanel.setAlignmentX(LEFT_ALIGNMENT);
  _attributesListPanel.setAlignmentY(TOP_ALIGNMENT);
  _tabbedPane.setAlignmentY(TOP_ALIGNMENT);
  topPanel.setAlignmentY(TOP_ALIGNMENT);
  bottomPanel.setAlignmentY(TOP_ALIGNMENT);
  topPanel.setLayout(new BoxLayout(topPanel,BoxLayout.Y_AXIS));
  _tabbedPane.setLayout(new BoxLayout(_tabbedPane,BoxLayout.Y_AXIS));
  topPanel.setBorder(BorderFactory.createEmptyBorder());
  _tabbedPane.addTab(""String_Node_Str"",_attributesListPanel);
  _tabbedPane.setMnemonicAt(0,KeyEvent.VK_1);
  _tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);
  JButton save_Button;
  JButton cancel_Button;
  save_Button=new JButton(""String_Node_Str"");
  cancel_Button=new JButton(""String_Node_Str"");
  save_Button.setMnemonic(KeyEvent.VK_ENTER);
  cancel_Button.setMnemonic(KeyEvent.VK_ESCAPE);
  save_Button.setActionCommand(""String_Node_Str"");
  cancel_Button.setActionCommand(""String_Node_Str"");
  save_Button.setHorizontalTextPosition(SwingConstants.CENTER);
  cancel_Button.setHorizontalTextPosition(SwingConstants.CENTER);
  for (  Object stringParameter : _modelToSave.attributeList()) {
    if (stringParameter instanceof StringParameter && ((StringParameter)stringParameter).getName() != ""String_Node_Str"" && ((StringParameter)stringParameter).getName() != ""String_Node_Str"" && _attributesListPanel.isDBAttribute(((StringParameter)stringParameter).getName())) {
      _attributesListPanel.addAttribute((StringParameter)stringParameter);
    }
  }
  save_Button.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      try {
        if (!_isValid()) {
          _rollbackModel();
          return;
        }
        _saveModel();
      }
 catch (      NameDuplicationException e) {
        JOptionPane.showMessageDialog((Component)event.getSource(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
        _rollbackModel();
      }
catch (      IllegalActionException e) {
        JOptionPane.showMessageDialog((Component)event.getSource(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
        _rollbackModel();
      }
catch (      Exception e) {
        JOptionPane.showMessageDialog((Component)event.getSource(),""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null);
        _rollbackModel();
      }
    }
  }
);
  cancel_Button.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      _rollbackModel();
      setVisible(false);
    }
  }
);
  topPanel.add(_tabbedPane);
  bottomPanel.add(save_Button);
  bottomPanel.add(cancel_Button);
  add(topPanel);
  add(bottomPanel);
  validate();
  repaint();
}","/** 
 * Construct a SaveModelToDBFrame. Add swing Components to the frame. Add listeners for the ""Save"" and ""Cancel"" buttons.
 * @param model The model that is being saved to the database.
 */
public SaveModelToDBFrame(NamedObj model){
  super(""String_Node_Str"");
  setLayout(new BoxLayout(this.getContentPane(),BoxLayout.Y_AXIS));
  _modelToSave=model;
  _initialModelName=model.getName();
  _orignialAttributes=new ArrayList();
  _attributesListPanel=new AttributesListPanel(_modelToSave);
  _tabbedPane=new JTabbedPane();
  for (  Object attribute : _modelToSave.attributeList()) {
    if (attribute instanceof StringParameter) {
      if (((StringParameter)attribute).getName() != ""String_Node_Str"" && ((StringParameter)attribute).getName() != ""String_Node_Str"" && _attributesListPanel.isDBAttribute(((StringParameter)attribute).getName())) {
        _orignialAttributes.add((StringParameter)attribute);
      }
    }
  }
  JPanel topPanel=new JPanel();
  JPanel bottomPanel=new JPanel();
  _attributesListPanel.setAlignmentX(LEFT_ALIGNMENT);
  _tabbedPane.setAlignmentX(LEFT_ALIGNMENT);
  topPanel.setAlignmentX(LEFT_ALIGNMENT);
  bottomPanel.setAlignmentX(LEFT_ALIGNMENT);
  _attributesListPanel.setAlignmentY(TOP_ALIGNMENT);
  _tabbedPane.setAlignmentY(TOP_ALIGNMENT);
  topPanel.setAlignmentY(TOP_ALIGNMENT);
  bottomPanel.setAlignmentY(TOP_ALIGNMENT);
  topPanel.setLayout(new BoxLayout(topPanel,BoxLayout.Y_AXIS));
  _tabbedPane.setLayout(new BoxLayout(_tabbedPane,BoxLayout.Y_AXIS));
  topPanel.setBorder(BorderFactory.createEmptyBorder());
  _tabbedPane.addTab(""String_Node_Str"",_attributesListPanel);
  _tabbedPane.setMnemonicAt(0,KeyEvent.VK_1);
  _tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);
  JButton save_Button;
  JButton cancel_Button;
  save_Button=new JButton(""String_Node_Str"");
  cancel_Button=new JButton(""String_Node_Str"");
  save_Button.setMnemonic(KeyEvent.VK_ENTER);
  cancel_Button.setMnemonic(KeyEvent.VK_ESCAPE);
  save_Button.setActionCommand(""String_Node_Str"");
  cancel_Button.setActionCommand(""String_Node_Str"");
  save_Button.setHorizontalTextPosition(SwingConstants.CENTER);
  cancel_Button.setHorizontalTextPosition(SwingConstants.CENTER);
  for (  Object stringParameter : _modelToSave.attributeList()) {
    if (stringParameter instanceof StringParameter && ((StringParameter)stringParameter).getName() != ""String_Node_Str"" && ((StringParameter)stringParameter).getName() != ""String_Node_Str"" && _attributesListPanel.isDBAttribute(((StringParameter)stringParameter).getName())) {
      _attributesListPanel.addAttribute((StringParameter)stringParameter);
    }
  }
  save_Button.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      try {
        if (!_isValid()) {
          _rollbackModel();
          return;
        }
        _saveModel();
      }
 catch (      NameDuplicationException e) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
        _rollbackModel();
      }
catch (      IllegalActionException e) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
        _rollbackModel();
      }
catch (      Exception e) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
        _rollbackModel();
      }
    }
  }
);
  cancel_Button.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      _rollbackModel();
      setVisible(false);
    }
  }
);
  topPanel.add(_tabbedPane);
  bottomPanel.add(save_Button);
  bottomPanel.add(cancel_Button);
  add(topPanel);
  add(bottomPanel);
  validate();
  repaint();
}"
73734,"private void _importByValue(){
  ArrayList<String> modelNames=new ArrayList();
  for (  SearchResultPanel panel : _resultPanelList) {
    modelNames.addAll(panel.getSelections());
  }
  for (  String modelName : modelNames) {
    try {
      Entity modelToImport=LoadManager.importModel(modelName,false);
      if (modelToImport != null) {
        MoMLChangeRequest change=new MoMLChangeRequest(this,_containerModel,modelToImport.exportMoML());
        change.setUndoable(true);
        _containerModel.requestChange(change);
      }
 else {
        throw new Exception();
      }
    }
 catch (    Exception e) {
      MessageHandler.error(""String_Node_Str"",e);
    }
  }
}","private void _importByValue(){
  ArrayList<String> modelNames=new ArrayList();
  for (  SearchResultPanel panel : _resultPanelList) {
    modelNames.addAll(panel.getSelections());
  }
  for (  String modelName : modelNames) {
    try {
      Entity modelToImport=LoadManager.importModel(modelName,false,_containerModel);
      if (modelToImport != null) {
        MoMLChangeRequest change=new MoMLChangeRequest(this,_containerModel,modelToImport.exportMoML());
        change.setUndoable(true);
        _containerModel.requestChange(change);
      }
 else {
        throw new Exception();
      }
    }
 catch (    Exception e) {
      MessageHandler.error(""String_Node_Str"",e);
    }
  }
}"
73735,"private void _importByReference(){
  ArrayList<String> modelNames=new ArrayList();
  for (  SearchResultPanel panel : _resultPanelList) {
    modelNames.addAll(panel.getSelections());
  }
  for (  String modelName : modelNames) {
    try {
      Entity modelToImport=LoadManager.importModel(modelName,true);
      if (modelToImport != null) {
        MoMLChangeRequest change=new MoMLChangeRequest(this,_containerModel,modelToImport.exportMoML());
        change.setUndoable(true);
        _containerModel.requestChange(change);
      }
 else {
        throw new Exception();
      }
    }
 catch (    Exception e) {
      MessageHandler.error(""String_Node_Str"",e);
    }
  }
}","private void _importByReference(){
  ArrayList<String> modelNames=new ArrayList();
  for (  SearchResultPanel panel : _resultPanelList) {
    modelNames.addAll(panel.getSelections());
  }
  for (  String modelName : modelNames) {
    try {
      Entity modelToImport=LoadManager.importModel(modelName,true,_containerModel);
      if (modelToImport != null) {
        MoMLChangeRequest change=new MoMLChangeRequest(this,_containerModel,modelToImport.exportMoML());
        change.setUndoable(true);
        _containerModel.requestChange(change);
      }
 else {
        throw new Exception();
      }
    }
 catch (    Exception e) {
      MessageHandler.error(""String_Node_Str"",e);
    }
  }
}"
73736,"private void _simpleSearch() throws DBConnectionException, DBExecutionException {
  SearchResultsFrame searchResultsFrame=new SearchResultsFrame(_containerModel,_sourceFrame,_configuration);
  SearchResultBuffer searchResultBuffer=new SearchResultBuffer();
  searchResultBuffer.addObserver(searchResultsFrame);
  SearchCriteria searchCriteria=new SearchCriteria();
  ArrayList<Attribute> attributesList=new ArrayList<Attribute>();
  Component[] componentArray1=_attListPanel.getComponents();
  for (int i=0; i < componentArray1.length; i++) {
    if (componentArray1[i] instanceof JPanel) {
      Component[] componentArray2=((JPanel)componentArray1[i]).getComponents();
      for (int j=0; j < componentArray2.length; j++) {
        if (componentArray2[j] instanceof ModelAttributePanel) {
          try {
            StringParameter attributeToAdd=new StringParameter(_containerModel,((ModelAttributePanel)componentArray2[j]).getAttributeName());
            attributeToAdd.setExpression(((ModelAttributePanel)componentArray2[j]).getValue());
            attributesList.add(attributeToAdd);
          }
 catch (          Exception e) {
          }
        }
      }
    }
  }
  try {
    StringParameter attributeToAdd=new StringParameter(_containerModel,""String_Node_Str"");
    attributeToAdd.setExpression(_modelName.getText());
    attributesList.add(attributeToAdd);
  }
 catch (  Exception e) {
  }
  searchCriteria.setAttributes(attributesList);
  searchResultsFrame.pack();
  searchResultsFrame.setVisible(true);
  SearchManager searchManager=new SearchManager();
  try {
    searchManager.search(searchCriteria,searchResultBuffer);
  }
 catch (  DBConnectionException e1) {
    searchResultsFrame.setVisible(false);
    searchResultsFrame.dispose();
    MessageHandler.error(""String_Node_Str"",e1);
  }
catch (  DBExecutionException e2) {
    searchResultsFrame.setVisible(false);
    searchResultsFrame.dispose();
    MessageHandler.error(""String_Node_Str"",e2);
  }
  setVisible(false);
}","private void _simpleSearch() throws DBConnectionException, DBExecutionException {
  SearchResultsFrame searchResultsFrame=new SearchResultsFrame(_containerModel,_sourceFrame,_configuration);
  SearchResultBuffer searchResultBuffer=new SearchResultBuffer();
  searchResultBuffer.addObserver(searchResultsFrame);
  SearchCriteria searchCriteria=new SearchCriteria();
  ArrayList<Attribute> attributesList=new ArrayList<Attribute>();
  Component[] componentArray1=_attListPanel.getComponents();
  for (int i=0; i < componentArray1.length; i++) {
    if (componentArray1[i] instanceof JPanel) {
      Component[] componentArray2=((JPanel)componentArray1[i]).getComponents();
      for (int j=0; j < componentArray2.length; j++) {
        if (componentArray2[j] instanceof ModelAttributePanel) {
          try {
            StringParameter attributeToAdd=new StringParameter(null,((ModelAttributePanel)componentArray2[j]).getAttributeName());
            attributeToAdd.setExpression(((ModelAttributePanel)componentArray2[j]).getValue());
            attributesList.add(attributeToAdd);
          }
 catch (          Exception e) {
          }
        }
      }
    }
  }
  try {
    StringParameter attributeToAdd=new StringParameter(_containerModel,""String_Node_Str"");
    attributeToAdd.setExpression(_modelName.getText());
    attributesList.add(attributeToAdd);
  }
 catch (  Exception e) {
  }
  searchCriteria.setAttributes(attributesList);
  searchResultsFrame.pack();
  searchResultsFrame.setVisible(true);
  SearchManager searchManager=new SearchManager();
  try {
    searchManager.search(searchCriteria,searchResultBuffer);
  }
 catch (  DBConnectionException e1) {
    searchResultsFrame.setVisible(false);
    searchResultsFrame.dispose();
    MessageHandler.error(""String_Node_Str"",e1);
  }
catch (  DBExecutionException e2) {
    searchResultsFrame.setVisible(false);
    searchResultsFrame.dispose();
    MessageHandler.error(""String_Node_Str"",e2);
  }
  setVisible(false);
}"
73737,"/** 
 * Given a model name, return an Entity object.
 * @param name The model name.  An alphanumeric string without special characters. If no model with the given name is found, return null.
 * @param byReference Indication that the model should be included by reference.
 * @return An Entity object that the GUI can display.
 * @exception DBConnectionException Thrown by DBModelFetcher if a problem occurs with the database connection.
 * @exception DBExecutionException Thrown by DBModelFetcher if a problem while executing a  command.
 * @exception Exception Thrown if a problem occurs creating an effigy from the MoML.
 */
public static Entity importModel(String name,boolean byReference) throws DBConnectionException, DBExecutionException, Exception {
  XMLDBModel dbModel=DBModelFetcher.load(name);
  if (dbModel == null)   return null;
  Entity returnEntity=_getEntity(dbModel);
  if (byReference) {
    if (returnEntity.getAttribute(""String_Node_Str"") == null) {
      String referenceTag=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
      MoMLChangeRequest change=new MoMLChangeRequest(null,returnEntity,referenceTag);
      change.setUndoable(true);
      returnEntity.requestChange(change);
    }
 else {
      ((StringParameter)returnEntity.getAttribute(""String_Node_Str"")).setExpression(""String_Node_Str"");
    }
  }
 else {
    if (returnEntity.getAttribute(""String_Node_Str"") == null) {
      String referenceTag=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
      MoMLChangeRequest change=new MoMLChangeRequest(null,returnEntity,referenceTag);
      change.setUndoable(true);
      returnEntity.requestChange(change);
    }
 else {
      ((StringParameter)returnEntity.getAttribute(""String_Node_Str"")).setExpression(""String_Node_Str"");
    }
  }
  return returnEntity;
}","/** 
 * Given a model name, return an Entity object.
 * @param name The model name.  An alphanumeric string without special characters. If no model with the given name is found, return null.
 * @param byReference Indication that the model should be included by reference.
 * @param container The NamedObj that will contain this imported model. It is used here to obtain a unique name.
 * @return An Entity object that the GUI can display.
 * @exception DBConnectionException Thrown by DBModelFetcher if a problem occurs with the database connection.
 * @exception DBExecutionException Thrown by DBModelFetcher if a problem while executing a  command.
 * @exception Exception Thrown if a problem occurs creating an effigy from the MoML.
 */
public static Entity importModel(String name,boolean byReference,NamedObj container) throws DBConnectionException, DBExecutionException, Exception {
  XMLDBModel dbModel=DBModelFetcher.load(name);
  if (dbModel == null)   return null;
  Entity returnEntity=_getEntity(dbModel);
  if (byReference) {
    if (returnEntity.getAttribute(""String_Node_Str"") == null) {
      String referenceTag=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
      MoMLChangeRequest change=new MoMLChangeRequest(null,returnEntity,referenceTag);
      change.setUndoable(true);
      returnEntity.requestChange(change);
    }
 else {
      ((StringParameter)returnEntity.getAttribute(""String_Node_Str"")).setExpression(""String_Node_Str"");
    }
  }
 else {
    if (returnEntity.getAttribute(""String_Node_Str"") == null) {
      String referenceTag=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
      MoMLChangeRequest change=new MoMLChangeRequest(null,returnEntity,referenceTag);
      change.setUndoable(true);
      returnEntity.requestChange(change);
    }
 else {
      ((StringParameter)returnEntity.getAttribute(""String_Node_Str"")).setExpression(""String_Node_Str"");
    }
  }
  if (returnEntity.getAttribute(""String_Node_Str"") == null) {
    String dbNameTag=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + returnEntity.getName() + ""String_Node_Str"";
    MoMLChangeRequest change=new MoMLChangeRequest(null,returnEntity,dbNameTag);
    change.setUndoable(true);
    returnEntity.requestChange(change);
  }
 else {
    ((StringParameter)returnEntity.getAttribute(""String_Node_Str"")).setExpression(returnEntity.getName());
  }
  returnEntity.setName(container.uniqueName(returnEntity.getName()));
  return returnEntity;
}"
73738,"/** 
 * create a setup parameter object that contains the database setup parameters and return that setup parameter object to the caller.
 * @return The setup parameter object.
 */
public static SetupParameters getSetupParameters(){
  if (_isDBSetupDone == true) {
    SetupParameters setupParameters=new SetupParameters(_DB_URL,_dbContainerName,_cacheContainerName);
    return setupParameters;
  }
 else {
    return null;
  }
}","/** 
 * create a setup parameter object that contains the database setup parameters and return that setup parameter object to the caller.
 * @return The setup parameter object.
 */
public static SetupParameters getSetupParameters(){
  if (_isDBSetupDone == true) {
    SetupParameters setupParameters=new SetupParameters(_dbUrl,_dbContainerName,_cacheContainerName);
    return setupParameters;
  }
 else {
    return null;
  }
}"
73739,"/** 
 * Test the database connection with the parameters given.
 * @param params The parameters for the database connection. 
 * @exception DBConnectionException Thrown if the connection fails.
 */
public void testConnection(SetupParameters params) throws DBConnectionException {
  if (params == null) {
    throw new DBConnectionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String url=params.getUrl();
  String containerName=params.getContainerName();
  String cacheContainerName=params.getCacheContainerName();
  DBConnectionParameters dbMainConnParams=new DBConnectionParameters(url,containerName,false);
  DBConnectionParameters dbCacheConnParams=new DBConnectionParameters(url,cacheContainerName,false);
  try {
    DBConnection mainConnection=new OracleXMLDBConnection(dbMainConnParams);
    if (mainConnection == null) {
      throw new DBConnectionException(""String_Node_Str"" + ""String_Node_Str"" + url + ""String_Node_Str""+ containerName);
    }
 else {
      mainConnection.closeConnection();
    }
    DBConnection cacheConnection=new OracleXMLDBConnection(dbCacheConnParams);
    if (cacheConnection == null) {
      throw new DBConnectionException(""String_Node_Str"" + ""String_Node_Str"" + url + ""String_Node_Str""+ cacheContainerName);
    }
 else {
      cacheConnection.closeConnection();
    }
  }
 catch (  DBConnectionException e) {
    throw new DBConnectionException(""String_Node_Str"" + ""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Test the database connection with the parameters given.
 * @param params The parameters for the database connection.
 * @exception DBConnectionException Thrown if the connection fails.
 */
public void testConnection(SetupParameters params) throws DBConnectionException {
  if (params == null) {
    throw new DBConnectionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String url=params.getUrl();
  String containerName=params.getContainerName();
  String cacheContainerName=params.getCacheContainerName();
  DBConnectionParameters dbMainConnParams=new DBConnectionParameters(url,containerName,false);
  DBConnectionParameters dbCacheConnParams=new DBConnectionParameters(url,cacheContainerName,false);
  try {
    DBConnection mainConnection=new OracleXMLDBConnection(dbMainConnParams);
    mainConnection.closeConnection();
    DBConnection cacheConnection=new OracleXMLDBConnection(dbCacheConnParams);
    cacheConnection.closeConnection();
  }
 catch (  DBConnectionException e) {
    throw new DBConnectionException(""String_Node_Str"" + ""String_Node_Str"" + e.getMessage(),e);
  }
}"
73740,"/** 
 * Update the existing database connection parameters with the given parameters.
 * @param params The new database connection parameters.
 * @exception DBConnectionException Thrown if the connection fails.
 * @exception IOException Thrown if an error occurs while writing the newparameters.
 */
public void updateConnection(SetupParameters params) throws DBConnectionException, IOException {
  if (params == null) {
    throw new DBConnectionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String ptdbParams=""String_Node_Str"";
  Properties props=new Properties();
  File propertiesFile=new File(ptdbParams);
  URL url=null;
  if (propertiesFile.exists() == false) {
    propertiesFile.createNewFile();
    url=FileUtilities.nameToURL(ptdbParams,null,null);
  }
 else {
    url=FileUtilities.nameToURL(ptdbParams,null,null);
  }
  if (url == null) {
    throw new IOException(""String_Node_Str"" + ptdbParams);
  }
  props.setProperty(""String_Node_Str"",params.getUrl());
  props.setProperty(""String_Node_Str"",params.getContainerName());
  props.setProperty(""String_Node_Str"",params.getCacheContainerName());
  props.store(url.openConnection().getOutputStream(),null);
  DBConnectorFactory.loadDBProperties();
}","/** 
 * Update the existing database connection parameters with the given parameters.
 * @param params The new database connection parameters.
 * @exception DBConnectionException Thrown if the connection fails.
 * @exception IOException Thrown if an error occurs while writing the newparameters.
 */
public void updateConnection(SetupParameters params) throws DBConnectionException, IOException {
  if (params == null) {
    throw new DBConnectionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String ptdbParams=DBConnectorFactory._PROPERTIES_FILE_PATH;
  Properties props=new Properties();
  File file=FileUtilities.nameToFile(ptdbParams,null);
  if (file.exists() == false) {
    file.createNewFile();
  }
  URL url=FileUtilities.nameToURL(ptdbParams,null,null);
  if (url == null) {
    throw new IOException(""String_Node_Str"" + ptdbParams);
  }
  String defaultDBClassName=""String_Node_Str"";
  props.load(url.openStream());
  String DBClassName=(String)props.getProperty(DBConnectorFactory._DB_CLASS_NAME);
  if (DBClassName == null || DBClassName.length() == 0) {
    DBClassName=defaultDBClassName;
  }
  props.setProperty(DBConnectorFactory._DB_CLASS_NAME,DBClassName);
  props.setProperty(DBConnectorFactory._DB_URL,params.getUrl());
  props.setProperty(DBConnectorFactory._XMLDB_CONTAINER_NAME,params.getContainerName());
  props.setProperty(DBConnectorFactory._CACHE_CONTAINER_NAME,params.getCacheContainerName());
  props.store(new FileOutputStream(url.getPath()),null);
  DBConnectorFactory.loadDBProperties();
}"
73741,"/** 
 * Create a graph with dependencies caused by sequence numbers and data flow constraints.
 * @param All sequence attributes to be considered when building the graph.
 */
private void _createGraph(List<SequenceAttribute> independentList){
  _initSequenceEstimation();
  CompositeEntity composite=(CompositeEntity)_director.getContainer();
  Iterator entities=composite.deepEntityList().iterator();
  while (entities.hasNext()) {
    Actor actor=(Actor)entities.next();
    Node actorNode=(Node)_actorNodeMap.get(actor);
    HashSet preds=_getPredecessors(independentList,actor);
    int numPreds=preds.size();
    Iterator predsIterator=preds.iterator();
    while (predsIterator.hasNext()) {
      Actor pred=(Actor)predsIterator.next();
      if (pred == composite) {
        numPreds--;
      }
 else {
        Node predNode=(Node)_actorNodeMap.get(pred);
        _graph.addEdge(predNode,actorNode);
      }
    }
    _unscheduledPredecessors.put(actorNode,new Integer(numPreds));
    if (numPreds == 0) {
      _ready.add(actorNode);
    }
  }
}","/** 
 * Create a graph with dependencies caused by sequence numbers and data flow constraints.
 * @param independentList All sequence attributes to be considered when building the graph.
 */
private void _createGraph(List<SequenceAttribute> independentList){
  _initSequenceEstimation();
  CompositeEntity composite=(CompositeEntity)_director.getContainer();
  Iterator entities=composite.deepEntityList().iterator();
  while (entities.hasNext()) {
    Actor actor=(Actor)entities.next();
    Node actorNode=(Node)_actorNodeMap.get(actor);
    HashSet preds=_getPredecessors(independentList,actor);
    int numPreds=preds.size();
    Iterator predsIterator=preds.iterator();
    while (predsIterator.hasNext()) {
      Actor pred=(Actor)predsIterator.next();
      if (pred == composite) {
        numPreds--;
      }
 else {
        Node predNode=(Node)_actorNodeMap.get(pred);
        _graph.addEdge(predNode,actorNode);
      }
    }
    _unscheduledPredecessors.put(actorNode,Integer.valueOf(numPreds));
    if (numPreds == 0) {
      _ready.add(actorNode);
    }
  }
}"
73742,"public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
  Actor actor=null;
  if (value instanceof Actor) {
    actor=(Actor)value;
  }
  if (actor != null) {
    String name=actor.getDisplayName();
    List<SequenceAttribute> seqAttributes=((Entity)actor).attributeList(SequenceAttribute.class);
    if (seqAttributes.size() > 0) {
      name+=""String_Node_Str"" + seqAttributes.get(0).getSequenceNumber() + ""String_Node_Str"";
    }
    this.setText(name);
  }
  return this;
}","public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
  Actor actor=null;
  if (value instanceof Actor) {
    actor=(Actor)value;
  }
  if (actor != null) {
    String name=actor.getDisplayName();
    List<SequenceAttribute> seqAttributes=((Entity)actor).attributeList(SequenceAttribute.class);
    if (seqAttributes.size() > 0) {
      try {
        name+=""String_Node_Str"" + seqAttributes.get(0).getSequenceNumber() + ""String_Node_Str"";
      }
 catch (      IllegalActionException e) {
        MessageHandler.error(""String_Node_Str"" + actor.getName() + ""String_Node_Str"",e);
      }
    }
    this.setText(name);
  }
  return this;
}"
73743,"/** 
 * Get the size of the array in memory this token is pointing to. Do  not check, if the array in the memory is of that size.
 * @return The size of the array in memory this token is pointing to.
 */
public int getSize(){
  return _size;
}","/** 
 * Get the size of the array in memory this token is pointing to. Do  not check, if the array in the memory is of that size.
 * @see #setSize(int)
 * @return The size of the array in memory this token is pointing to.
 */
public int getSize(){
  return _size;
}"
73744,"/** 
 * Set the size of the array in memory this token is pointing to. Do not  change the actual content or size of the memory nor the array in the memory.
 * @param size The size of the array in memory this token is pointing to.
 */
public void setSize(int size){
  this._size=size;
}","/** 
 * Set the size of the array in memory this token is pointing to. Do not  change the actual content or size of the memory nor the array in the memory.
 * @see #getSize()
 * @param size The size of the array in memory this token is pointing to.
 */
public void setSize(int size){
  this._size=size;
}"
73745,"/** 
 * Set the address in memory this token should point to. Do not change the position of the array in the memory.
 * @param addr The address in memory this token should point to.
 */
public void setAddress(int addr){
  this._addr=addr;
}","/** 
 * Set the address in memory this token should point to. Do not change the position of the array in the memory.
 * @see #getAddress()
 * @param addr The address in memory this token should point to.
 */
public void setAddress(int addr){
  this._addr=addr;
}"
73746,"/** 
 * Get the address in memory this token is pointing to. Do  not check, if there actually is something at that memory address.
 * @return The address in memory this token is pointing to.
 */
public int getAddress(){
  return _addr;
}","/** 
 * Get the address in memory this token is pointing to. Do  not check, if there actually is something at that memory address.
 * @see #setAddress(int)
 * @return The address in memory this token is pointing to.
 */
public int getAddress(){
  return _addr;
}"
73747,"protected void _init() throws IllegalActionException, NameDuplicationException {
  super._init();
  if (_memory == null) {
    _memory=new Memory();
  }
  iterations.setExpression(""String_Node_Str"");
}","/** 
 * Initialize the shared memory for the actors and set the  iterations for this director to one.
 * @throws IllegalActionException If there is a problem instantiatingthe director's parameters.
 * @throws NameDuplicationException If there is a problem instantiatingthe director's parameters.
 */
protected void _init() throws IllegalActionException, NameDuplicationException {
  super._init();
  if (_memory == null) {
    _memory=new Memory();
  }
  iterations.setExpression(""String_Node_Str"");
}"
73748,"protected void _setInitialValues() throws IllegalActionException {
  _clearReceivers();
}","/** 
 * Set the initial Tokens present on the inputs of the actors. In this case do not set any initial tokens. Remove already present tokens.
 * @throws IllegalActionException If already present tokens cannot beremoved.
 */
protected void _setInitialValues() throws IllegalActionException {
  _clearReceivers();
}"
73749,"/** 
 * Read the PtrToken present on <i>input</i> and produce a new PtrToken on <i>output</i> with address = address of the token present <i>input</i>  plus addressOffset and size = size of the token present at <i>input</i> plus sizeOffset.
 * @throws NoTokenException If there is no token.
 * @throws IllegalActionException If there is no director, and henceno receivers have been created, if the port is not an input port, or if the channel index is out of range.
 */
public void fire() throws NoTokenException, IllegalActionException {
  Token token=input.get(0);
  if (token instanceof PtrToken) {
    PtrToken in=(PtrToken)token;
    addressOffset.update();
    int addr=in.getAddress() + ((IntToken)addressOffset.getToken()).intValue();
    sizeOffset.update();
    int sz=in.getSize() + +((IntToken)sizeOffset.getToken()).intValue();
    if (sz < 1) {
      new IllegalActionException(""String_Node_Str"");
    }
    PtrToken result=new PtrToken(addr,sz);
    output.broadcast(result);
  }
  return;
}","/** 
 * Read the PtrToken present on <i>input</i> and produce a new PtrToken on <i>output</i> with address = address of the token present <i>input</i>  plus addressOffset and size = size of the token present at <i>input</i> plus sizeOffset.
 * @throws NoTokenException If there is no token.
 * @throws IllegalActionException If there is no director, and henceno receivers have been created, if the port is not an input port, or if the channel index is out of range.
 */
public void fire() throws NoTokenException, IllegalActionException {
  Token token=input.get(0);
  if (token instanceof PtrToken) {
    PtrToken in=(PtrToken)token;
    addressOffset.update();
    int addr=in.getAddress() + ((IntToken)addressOffset.getToken()).intValue();
    sizeOffset.update();
    int sz=in.getSize() + +((IntToken)sizeOffset.getToken()).intValue();
    if (sz < 1) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    PtrToken result=new PtrToken(addr,sz);
    output.broadcast(result);
  }
  return;
}"
73750,"/** 
 * Allocate a slot in the memory (currently at the end)
 * @param size The size of the slot to be allocated.
 * @return A pointer to the address allocated in the memory.
 */
public PtrToken allocate(int size){
  int addr=_buffer.size();
  _buffer.setSize(addr + size);
  PtrToken result=new PtrToken(addr,size);
  return result;
}","/** 
 * Allocate a slot in the memory (currently at the end).
 * @param size The size of the slot to be allocated.
 * @return A pointer to the address allocated in the memory.
 */
public PtrToken allocate(int size){
  int addr=_buffer.size();
  _buffer.setSize(addr + size);
  PtrToken result=new PtrToken(addr,size);
  return result;
}"
73751,"/** 
 * Remove all entries from the memory 
 */
public void clear(){
  _buffer.clear();
}","/** 
 * Remove all entries from the memory. 
 */
public void clear(){
  _buffer.clear();
}"
73752,"/** 
 * Set the attribute list value only when the attribute type is list
 * @param attributeValues The list of attribute values.
 * @see #getAttributeValue
 */
public void setAttributeValue(List<String> attributeValues){
  if (_attributeType.equals(XMLDBAttribute.ATTRIBUTE_TYPE_LIST)) {
    _attributeValues=attributeValues;
  }
}","/** 
 * Set the attribute list value only when the attribute type is list.
 * @param attributeValues The list of attribute values.
 * @see #getAttributeValue
 */
public void setAttributeValue(List<String> attributeValues){
  if (_attributeType.equals(XMLDBAttribute.ATTRIBUTE_TYPE_LIST)) {
    _attributeValues=attributeValues;
  }
}"
73753,"/** 
 * Construct a XMLDBAttribute instance with the given attribute name.
 * @param attributeName the name for the given attribute.
 */
public XMLDBAttribute(String attributeName,String attributeType){
  this._attributeName=attributeName;
  this._attributeType=attributeType;
}","/** 
 * Construct a XMLDBAttribute instance with the given attribute name.
 * @param attributeName The name for the given attribute.
 * @param attributeType The type for the given attribute.
 */
public XMLDBAttribute(String attributeName,String attributeType){
  this._attributeName=attributeName;
  this._attributeType=attributeType;
}"
73754,"/** 
 * Set the parents for the current model
 * @param listParents List of parents for this model.
 * @see #getParents
 */
public void setParents(List<List<XMLDBModel>> listParents){
  _listParents=listParents;
}","/** 
 * Set the parents for the current model.
 * @param listParents List of parents for this model.
 * @see #getParents
 */
public void setParents(List<List<XMLDBModel>> listParents){
  _listParents=listParents;
}"
73755,"public PushMatrix(GraphicsDirector director){
  _director=director;
}","public PushMatrix(JoglDirector director){
  _director=director;
}"
73756,"/** 
 * Most of the constructor initialization is relegated to this method. Initialization process includes : - create a new actor table to cache all actors contained - create a new receiver table to cache all receivers contained - set default number of iterations - set period value
 */
private void _init(){
  try {
    Scheduler scheduler=new GraphicsScheduler(workspace());
    setScheduler(scheduler);
  }
 catch (  Exception ex) {
    throw new InternalErrorException(this,ex,""String_Node_Str"");
  }
  try {
    iterationInterval=new Parameter(this,""String_Node_Str"");
    iterationInterval.setExpression(""String_Node_Str"");
    iterationInterval.setTypeEquals(new ArrayType(BaseType.INT,2));
    iterationTimeLowerBound=new Parameter(this,""String_Node_Str"",new IntToken(33));
    iterationTimeLowerBound.setTypeEquals(BaseType.INT);
  }
 catch (  Throwable throwable) {
    throw new InternalErrorException(this,throwable,""String_Node_Str"");
  }
  try {
    pushMatrix=new PushMatrix(this);
    popMatrix=new PopMatrix(this);
  }
 catch (  Throwable throwable) {
    throw new InternalErrorException(this,throwable,""String_Node_Str"");
  }
  _reset();
}","/** 
 * Most of the constructor initialization is relegated to this method. Initialization process includes : - create a new actor table to cache all actors contained - create a new receiver table to cache all receivers contained - set default number of iterations - set period value
 */
private void _init(){
  try {
    Scheduler scheduler=new JoglScheduler(workspace());
    setScheduler(scheduler);
  }
 catch (  Exception ex) {
    throw new InternalErrorException(this,ex,""String_Node_Str"");
  }
  try {
    iterationInterval=new Parameter(this,""String_Node_Str"");
    iterationInterval.setExpression(""String_Node_Str"");
    iterationInterval.setTypeEquals(new ArrayType(BaseType.INT,2));
    iterationTimeLowerBound=new Parameter(this,""String_Node_Str"",new IntToken(33));
    iterationTimeLowerBound.setTypeEquals(BaseType.INT);
  }
 catch (  Throwable throwable) {
    throw new InternalErrorException(this,throwable,""String_Node_Str"");
  }
  try {
    pushMatrix=new PushMatrix(this);
    popMatrix=new PopMatrix(this);
  }
 catch (  Throwable throwable) {
    throw new InternalErrorException(this,throwable,""String_Node_Str"");
  }
  _reset();
}"
73757,"public PopMatrix(GraphicsDirector director){
  _director=director;
}","public PopMatrix(JoglDirector director){
  _director=director;
}"
73758,"/** 
 * Clone the director into the specified workspace. This calls the base class and then copies the parameter of this director. The new actor will have the same parameter values as the old.
 * @param workspace The workspace for the new object.
 * @return A new object.
 * @exception CloneNotSupportedException If one of the attributes cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  _reset();
  GraphicsDirector newObject=(GraphicsDirector)(super.clone(workspace));
  return newObject;
}","/** 
 * Clone the director into the specified workspace. This calls the base class and then copies the parameter of this director. The new actor will have the same parameter values as the old.
 * @param workspace The workspace for the new object.
 * @return A new object.
 * @exception CloneNotSupportedException If one of the attributes cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  _reset();
  JoglDirector newObject=(JoglDirector)(super.clone(workspace));
  return newObject;
}"
73759,"/** 
 * Construct a depth-first firing schedule recursively. It first creates a new firing to add to the given schedule for the given actor. Then, it make a recursive call on each of the successors (sinks connected to the given actor). The successors are specified in the given directed acyclic graph constructed previously. If the given actor is null, return and do nothing.
 * @param schedule The given schedule to add the firings to.
 * @param dag The given directed acyclic graph of the model.
 * @param actorToAdd The given actor to add a firing to theschedule.
 */
private void _constructDepthFirstSchedule(Schedule schedule,DirectedAcyclicGraph dag,Object actorToAdd){
  JoglDirector director=(JoglDirector)getContainer();
  if (actorToAdd == null) {
    return;
  }
  Firing firing=new Firing();
  firing.setActor((Actor)actorToAdd);
  schedule.add(firing);
  for (  Object node : dag.successors(dag.node(actorToAdd))) {
    _constructDepthFirstSchedule(schedule,dag,((Node)node).getWeight());
  }
}","/** 
 * Construct a depth-first firing schedule recursively. It first creates a new firing to add to the given schedule for the given actor. Then, it make a recursive call on each of the successors (sinks connected to the given actor). The successors are specified in the given directed acyclic graph constructed previously. If the given actor is null, return and do nothing.
 * @param schedule The given schedule to add the firings to.
 * @param dag The given directed acyclic graph of the model.
 * @param actorToAdd The given actor to add a firing to theschedule.
 */
private void _constructDepthFirstSchedule(Schedule schedule,DirectedAcyclicGraph dag,Object actorToAdd){
  if (actorToAdd == null) {
    return;
  }
  Firing firing=new Firing();
  firing.setActor((Actor)actorToAdd);
  schedule.add(firing);
  for (  Object node : dag.successors(dag.node(actorToAdd))) {
    _constructDepthFirstSchedule(schedule,dag,((Node)node).getWeight());
  }
}"
73760,"private void _updateDisplayedModel() throws Exception {
  try {
    if (_modelToSave.getAttribute(""String_Node_Str"") == null) {
      Variable dbModel=new Variable(_modelToSave.workspace());
      dbModel.setContainer(_modelToSave);
      dbModel.setName(""String_Node_Str"");
    }
    ArrayList<DBAttribute> attributesList=new ArrayList();
    for (    Object a : _modelToSave.attributeList()) {
      if (a instanceof DBAttribute) {
        attributesList.add((DBAttribute)a);
      }
    }
    for (    DBAttribute attribute : attributesList) {
      attribute.setContainer(null);
    }
    Component[] componentArray1=_attListPanel.getComponents();
    for (int i=0; i < componentArray1.length; i++) {
      if (componentArray1[i] instanceof JPanel) {
        Component[] componentArray2=((JPanel)componentArray1[i]).getComponents();
        for (int j=0; j < componentArray2.length; j++) {
          if (componentArray2[j] instanceof ModelAttributePanel) {
            DBAttribute attributeToAdd=new DBAttribute(_modelToSave,((ModelAttributePanel)componentArray2[j]).getAttributeName());
            attributeToAdd.setExpression(((ModelAttributePanel)componentArray2[j]).getValue());
            attributeToAdd.setContainer(_modelToSave);
            SingletonAttribute sa=new SingletonAttribute(attributeToAdd.workspace());
            sa.setContainer(attributeToAdd);
            sa.setName(""String_Node_Str"");
            ValueIcon vi=new ValueIcon(attributeToAdd,""String_Node_Str"");
            vi.setContainer(attributeToAdd);
            ColorAttribute ca=new ColorAttribute(vi,""String_Node_Str"");
            ca.setContainer(vi);
            ca.setExpression(""String_Node_Str"");
            SingletonConfigurableAttribute sca=new SingletonConfigurableAttribute(attributeToAdd.workspace());
            sca.setContainer(attributeToAdd);
            sca.configure(null,attributeToAdd.getSource(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            VisibleParameterEditorFactory vpef=new VisibleParameterEditorFactory(attributeToAdd,""String_Node_Str"");
            vpef.setContainer(attributeToAdd);
            double[] xy={250,170};
            Location l=new Location(attributeToAdd,""String_Node_Str"");
            l.setLocation(xy);
            try {
              MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
              change.setUndoable(true);
              _modelToSave.requestChange(change);
            }
 catch (            Exception e) {
              throw e;
            }
          }
        }
      }
    }
  }
 catch (  NameDuplicationException exception) {
    throw exception;
  }
catch (  IllegalActionException exception) {
    throw exception;
  }
}","private void _updateDisplayedModel() throws Exception {
  try {
    if (_modelToSave.getAttribute(""String_Node_Str"") == null) {
      StringParameter dbModelParam=new StringParameter(_modelToSave,""String_Node_Str"");
      dbModelParam.setExpression(""String_Node_Str"");
    }
    ArrayList<DBAttribute> attributesList=new ArrayList();
    for (    Object a : _modelToSave.attributeList()) {
      if (a instanceof DBAttribute) {
        attributesList.add((DBAttribute)a);
      }
    }
    for (    DBAttribute attribute : attributesList) {
      attribute.setContainer(null);
    }
    Component[] componentArray1=_attListPanel.getComponents();
    for (int i=0; i < componentArray1.length; i++) {
      if (componentArray1[i] instanceof JPanel) {
        Component[] componentArray2=((JPanel)componentArray1[i]).getComponents();
        for (int j=0; j < componentArray2.length; j++) {
          if (componentArray2[j] instanceof ModelAttributePanel) {
            DBAttribute attributeToAdd=new DBAttribute(_modelToSave,((ModelAttributePanel)componentArray2[j]).getAttributeName());
            attributeToAdd.setExpression(((ModelAttributePanel)componentArray2[j]).getValue());
            attributeToAdd.setContainer(_modelToSave);
            SingletonAttribute sa=new SingletonAttribute(attributeToAdd.workspace());
            sa.setContainer(attributeToAdd);
            sa.setName(""String_Node_Str"");
            ValueIcon vi=new ValueIcon(attributeToAdd,""String_Node_Str"");
            vi.setContainer(attributeToAdd);
            ColorAttribute ca=new ColorAttribute(vi,""String_Node_Str"");
            ca.setContainer(vi);
            ca.setExpression(""String_Node_Str"");
            SingletonConfigurableAttribute sca=new SingletonConfigurableAttribute(attributeToAdd.workspace());
            sca.setContainer(attributeToAdd);
            sca.configure(null,attributeToAdd.getSource(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            VisibleParameterEditorFactory vpef=new VisibleParameterEditorFactory(attributeToAdd,""String_Node_Str"");
            vpef.setContainer(attributeToAdd);
            double[] xy={250,170};
            Location l=new Location(attributeToAdd,""String_Node_Str"");
            l.setLocation(xy);
            try {
              MoMLChangeRequest change=new MoMLChangeRequest(this,null,_modelToSave.exportMoML());
              change.setUndoable(true);
              _modelToSave.requestChange(change);
            }
 catch (            Exception e) {
              throw e;
            }
          }
        }
      }
    }
  }
 catch (  NameDuplicationException exception) {
    throw exception;
  }
catch (  IllegalActionException exception) {
    throw exception;
  }
}"
73761,"/** 
 * Get the component entities from the Graph search pattern.
 * @return The component entities from the graph search pattern.
 */
public ArrayList<ComponentEntity> getComponentEntitiesList(){
  return _componentEntitiesList;
}","/** 
 * Get the component entities from the Graph search pattern.
 * @see #setComponentEntitiesList
 * @return The component entities from the graph search pattern.
 */
public ArrayList<ComponentEntity> getComponentEntitiesList(){
  return _componentEntitiesList;
}"
73762,"/** 
 * Set the relations from the Graph search pattern.
 * @param relationsList The relations from the graph search pattern.
 */
public void setRelationsList(ArrayList<Relation> relationsList){
  _relationsList=relationsList;
}","/** 
 * Set the relations from the Graph search pattern.
 * @see #getRelationsList
 * @param relationsList The relations from the graph search pattern.
 */
public void setRelationsList(ArrayList<Relation> relationsList){
  _relationsList=relationsList;
}"
73763,"/** 
 * Get the relations from the Graph search pattern.
 * @return The relations from the graph search pattern.
 */
public ArrayList<Relation> getRelationsList(){
  return _relationsList;
}","/** 
 * Get the relations from the Graph search pattern.
 * @see #setRelationsList
 * @return The relations from the graph search pattern.
 */
public ArrayList<Relation> getRelationsList(){
  return _relationsList;
}"
73764,"/** 
 * Set the component entities from the Graph search pattern.
 * @param componentEntitiesList The component entities from the graphsearch pattern.
 */
public void setComponentEntitiesList(ArrayList<ComponentEntity> componentEntitiesList){
  _componentEntitiesList=componentEntitiesList;
}","/** 
 * Set the component entities from the Graph search pattern.
 * @see #getComponentEntitiesList
 * @param componentEntitiesList The component entities from the graphsearch pattern.
 */
public void setComponentEntitiesList(ArrayList<ComponentEntity> componentEntitiesList){
  _componentEntitiesList=componentEntitiesList;
}"
73765,"/** 
 * Set the composite entities from the graph search pattern. 
 * @param compositeEntitiesList The composite entities from the graph searchpattern.
 */
public void setCompositeEntities(ArrayList<CompositeEntity> compositeEntitiesList){
  _compositeEntitiesList=compositeEntitiesList;
}","/** 
 * Set the composite entities from the graph search pattern. 
 * @see #getCompositeEntities
 * @param compositeEntitiesList The composite entities from the graph searchpattern.
 */
public void setCompositeEntities(ArrayList<CompositeEntity> compositeEntitiesList){
  _compositeEntitiesList=compositeEntitiesList;
}"
73766,"/** 
 * Get the composite entities form the graph search pattern. 
 * @return The composite entities from the graph search pattern. 
 */
public ArrayList<CompositeEntity> getCompositeEntities(){
  return _compositeEntitiesList;
}","/** 
 * Get the composite entities form the graph search pattern. 
 * @see #setCompositeEntities
 * @return The composite entities from the graph search pattern. 
 */
public ArrayList<CompositeEntity> getCompositeEntities(){
  return _compositeEntitiesList;
}"
73767,"/** 
 * Get the ports from the Graph search pattern.
 * @return The ports from the graph search pattern.
 */
public ArrayList<Port> getPortsList(){
  return _portsList;
}","/** 
 * Get the ports from the Graph search pattern.
 * @see #setPortsList
 * @return The ports from the graph search pattern.
 */
public ArrayList<Port> getPortsList(){
  return _portsList;
}"
73768,"/** 
 * Set the ports from the Graph search pattern.
 * @param portsList The ports from the graph search pattern.
 */
public void setPortsList(ArrayList<Port> portsList){
  _portsList=portsList;
}","/** 
 * Set the ports from the Graph search pattern.
 * @see #getPortsList
 * @param portsList The ports from the graph search pattern.
 */
public void setPortsList(ArrayList<Port> portsList){
  _portsList=portsList;
}"
73769,"/** 
 * Get the search command criteria from the search criteria.
 * @return The XQuery search command input by the user.
 */
public String getSearchCommand(){
  return _searchCommand;
}","/** 
 * Get the search command criteria from the search criteria.
 * @see #setSearchCommand
 * @return The XQuery search command input by the user.
 */
public String getSearchCommand(){
  return _searchCommand;
}"
73770,"/** 
 * Get the attributes criteria from the search criteria.
 * @return All the attributes input by the user as the search criteria.
 */
public ArrayList<Attribute> getAttributes(){
  return _attributes;
}","/** 
 * Get the attributes criteria from the search criteria.
 * @see #setAttributes
 * @return All the attributes input by the user as the search criteria.
 */
public ArrayList<Attribute> getAttributes(){
  return _attributes;
}"
73771,"/** 
 * Set the XQuery search command for the search criteria.
 * @param searchCommand The XQuery search command to set in the searchcriteria.
 */
public void setSearchCommand(String searchCommand){
  this._searchCommand=searchCommand;
}","/** 
 * Set the XQuery search command for the search criteria.
 * @see #getSearchCommand
 * @param searchCommand The XQuery search command to set in the searchcriteria.
 */
public void setSearchCommand(String searchCommand){
  this._searchCommand=searchCommand;
}"
73772,"/** 
 * Get the graph search criteria from the search criteria.
 * @return The graph search criteria input by the user.
 */
public DBGraphSearchCriteria getDBGraphSearchCriteria(){
  return _dbGraphSearchCriteria;
}","/** 
 * Get the graph search criteria from the search criteria.
 * @see #setDBGraphSearchCriteria
 * @return The graph search criteria input by the user.
 */
public DBGraphSearchCriteria getDBGraphSearchCriteria(){
  return _dbGraphSearchCriteria;
}"
73773,"/** 
 * Set the attribute criteria for the search criteria.
 * @param attributes The attributes input by the user to set in thesearch criteria.
 */
public void setAttributes(ArrayList<Attribute> attributes){
  this._attributes=attributes;
}","/** 
 * Set the attribute criteria for the search criteria.
 * @see #getAttributes
 * @param attributes The attributes input by the user to set in thesearch criteria.
 */
public void setAttributes(ArrayList<Attribute> attributes){
  this._attributes=attributes;
}"
73774,"/** 
 * Set the graph search criteria for the search criteria.
 * @param dbGraphSearchCriteria The graph search criteria input by the userto set in the search criteria.
 */
public void setDBGraphSearchCriteria(DBGraphSearchCriteria dbGraphSearchCriteria){
  _dbGraphSearchCriteria=dbGraphSearchCriteria;
}","/** 
 * Set the graph search criteria for the search criteria.
 * @see #getDBGraphSearchCriteria
 * @param dbGraphSearchCriteria The graph search criteria input by the userto set in the search criteria.
 */
public void setDBGraphSearchCriteria(DBGraphSearchCriteria dbGraphSearchCriteria){
  _dbGraphSearchCriteria=dbGraphSearchCriteria;
}"
73775,"private void _update(Actor actor) throws NotSchedulableException {
  _SequenceInfo actorSeqInfo=_sequenceInfos.get(actor);
  int actorDistance=actorSeqInfo.distance;
  Iterator ports=actor.outputPortList().iterator();
  if (ports.hasNext() && _maxDistance <= actorDistance) {
    _maxDistance=actorDistance + 1;
  }
  while (ports.hasNext()) {
    IOPort port=(IOPort)ports.next();
    Iterator deepConnectedInPortList=port.deepConnectedInPortList().iterator();
    while (deepConnectedInPortList.hasNext()) {
      Port deepConnectedPort=(Port)deepConnectedInPortList.next();
      Actor connectedActor=(Actor)deepConnectedPort.getContainer();
      _SequenceInfo _SequenceInfo=_sequenceInfos.get(connectedActor);
      if (_SequenceInfo == null) {
        _sequenceInfos.put(connectedActor,new _SequenceInfo(actorDistance + 1,false,true));
        _unsettled.add(connectedActor);
      }
 else       if (_SequenceInfo.distance < actorDistance + 1) {
        _unsettled.add(connectedActor);
        _SequenceInfo.distance=actorDistance + 1;
        if (_SequenceInfo.isFixed) {
          _SequenceInfo.changed=true;
        }
      }
    }
  }
  _unsettled.remove(actor);
}","private void _update(Actor actor) throws NotSchedulableException {
  _SequenceInfo actorSeqInfo=_sequenceInfos.get(actor);
  int actorDistance=actorSeqInfo.distance;
  List portList=actor.outputPortList();
  if (portList != null) {
    Iterator ports=portList.iterator();
    if (ports.hasNext() && _maxDistance <= actorDistance) {
      _maxDistance=actorDistance + 1;
    }
    while (ports.hasNext()) {
      IOPort port=(IOPort)ports.next();
      Iterator deepConnectedInPortList=port.deepConnectedInPortList().iterator();
      while (deepConnectedInPortList.hasNext()) {
        Port deepConnectedPort=(Port)deepConnectedInPortList.next();
        Actor connectedActor=(Actor)deepConnectedPort.getContainer();
        _SequenceInfo _SequenceInfo=_sequenceInfos.get(connectedActor);
        if (_SequenceInfo == null) {
          _sequenceInfos.put(connectedActor,new _SequenceInfo(actorDistance + 1,false,true));
          _unsettled.add(connectedActor);
        }
 else         if (_SequenceInfo.distance < actorDistance + 1) {
          _unsettled.add(connectedActor);
          _SequenceInfo.distance=actorDistance + 1;
          if (_SequenceInfo.isFixed) {
            _SequenceInfo.changed=true;
          }
        }
      }
    }
  }
  _unsettled.remove(actor);
}"
73776,"private void _initSequencedActors(List<SequenceAttribute> independentList){
  Iterator sequenceAttributes=independentList.iterator();
  while (sequenceAttributes.hasNext()) {
    SequenceAttribute attribute=(SequenceAttribute)sequenceAttributes.next();
    int sequenceNumber=attribute.getSequenceNumber();
    _SequenceInfo info=new _SequenceInfo(sequenceNumber,true,false);
    info.original=sequenceNumber;
    Actor actor=(Actor)attribute.getContainer();
    _sequenceInfos.put(actor,info);
    _unsettled.add(actor);
  }
}","private void _initSequencedActors(List<SequenceAttribute> independentList){
  if (independentList != null) {
    Iterator sequenceAttributes=independentList.iterator();
    while (sequenceAttributes.hasNext()) {
      SequenceAttribute attribute=(SequenceAttribute)sequenceAttributes.next();
      int sequenceNumber=attribute.getSequenceNumber();
      _SequenceInfo info=new _SequenceInfo(sequenceNumber,true,false);
      info.original=sequenceNumber;
      Actor actor=(Actor)attribute.getContainer();
      _sequenceInfos.put(actor,info);
      _unsettled.add(actor);
    }
  }
}"
73777,"private Actor _selectActor(){
  Iterator it=_unsettled.iterator();
  int max=0;
  Actor result=null;
  while (it.hasNext()) {
    Actor actor=(Actor)it.next();
    _SequenceInfo info=_sequenceInfos.get(actor);
    int dist=info.distance;
    if (actor == null || dist > max) {
      result=actor;
      max=dist;
    }
  }
  return result;
}","private Actor _selectActor(){
  Iterator it=_unsettled.iterator();
  int max=-1;
  Actor result=null;
  while (it.hasNext()) {
    Actor actor=(Actor)it.next();
    _SequenceInfo info=_sequenceInfos.get(actor);
    int dist=info.distance;
    if (actor == null || dist > max) {
      result=actor;
      max=dist;
    }
  }
  return result;
}"
73778,"/** 
 * Estimate a sequenced schedule. Currently only supports basic Dijkstra  algorithm for getting the maximal distances. Thus, it cannot deal with cyclic graphs.
 * @param independentList The already present SequenceAttributes for theActors controlled by this scheduler.
 * @return A vector with the ordered actors. Note that the sequence numbersare not changed. This has to be done somewhere else.
 * @exception NotSchedulableException If the schedule is acyclic.
 */
public Vector<Actor> estimateSequencedSchedule(List<SequenceAttribute> independentList) throws NotSchedulableException {
  if (_actorGraph.isAcyclic()) {
    return _estimator.estimateSequencedSchedule(independentList);
  }
 else {
    throw new NotSchedulableException(""String_Node_Str"");
  }
}","/** 
 * Estimate a sequenced schedule. Currently only supports basic Dijkstra  algorithm for getting the maximal distances. Thus, it cannot deal with cyclic graphs.
 * @param independentList The already present SequenceAttributes for theActors controlled by this scheduler.
 * @return A vector with the ordered actors. Note that the sequence numbersare not changed. This has to be done somewhere else.
 * @exception NotSchedulableException If the schedule is acyclic.
 */
public Vector<Actor> estimateSequencedSchedule(List<SequenceAttribute> independentList) throws NotSchedulableException {
  if (_actorGraph == null) {
    return _estimator.estimateSequencedSchedule(independentList);
  }
 else   if (_actorGraph.isAcyclic()) {
    return _estimator.estimateSequencedSchedule(independentList);
  }
 else {
    throw new NotSchedulableException(""String_Node_Str"");
  }
}"
73779,"/** 
 * Execute the necessary commands to save/update a model in the database according to the model specification given in the task parameter.
 * @param task a SaveModelTask to be completed.
 * @exception DBExecutionException Thrown if there is a problem executingthe task.
 */
public void executeSaveModelTask(SaveModelTask task) throws DBExecutionException {
  try {
    if (_xmlContainer == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_xmlTransaction == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (task == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XMLDBModel xmlDBModel=task.getXMLDBModel();
    if (xmlDBModel == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlDocument currentDbModel=null;
    try {
      currentDbModel=_xmlContainer.getDocument(_xmlTransaction,xmlDBModel.getModelName());
    }
 catch (    XmlException e) {
    }
    if (currentDbModel == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      String modelBody=xmlDBModel.getModel();
      modelBody=modelBody.substring(modelBody.indexOf(""String_Node_Str""));
      currentDbModel.setContent(modelBody);
      _xmlContainer.updateDocument(_xmlTransaction,currentDbModel);
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Execute the necessary commands to save/update a model in the database according to the model specification given in the task parameter.
 * @param task a SaveModelTask to be completed.
 * @exception DBExecutionException Thrown if there is a problem executingthe task.
 */
public void executeSaveModelTask(SaveModelTask task) throws DBExecutionException {
  try {
    if (_xmlContainer == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_xmlTransaction == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (task == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XMLDBModel xmlDBModel=task.getXMLDBModel();
    if (xmlDBModel == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlDocument currentDbModel=null;
    try {
      currentDbModel=_xmlContainer.getDocument(_xmlTransaction,xmlDBModel.getModelName());
    }
 catch (    XmlException e) {
    }
    if (currentDbModel == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      String modelBody=xmlDBModel.getModel();
      if (modelBody.indexOf(""String_Node_Str"") >= 0) {
        modelBody=modelBody.substring(modelBody.indexOf(""String_Node_Str""));
        modelBody=modelBody.substring(modelBody.indexOf(""String_Node_Str"") + 1);
      }
      _xmlContainer.deleteDocument(_xmlTransaction,currentDbModel);
      _xmlContainer.putDocument(_xmlTransaction,xmlDBModel.getModelName(),modelBody);
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
73780,"/** 
 * Execute the necessary commands to create a new model in the database according to the model specification given in the task parameter.
 * @param task The task to be completed. In this case, CreateModelTask. Thiswill tell the DB layer to create a new model in the database.
 * @exception DBExecutionException Thrown if there is a problem executingthe task.
 * @exception ModelAlreadyExistException Thrown if the model being createdalready exists.
 */
public void executeCreateModelTask(CreateModelTask task) throws DBExecutionException, ModelAlreadyExistException {
  try {
    if (_xmlContainer == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_xmlTransaction == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (task == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XMLDBModel model=task.getXMLDBModel();
    if (model == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlDocument doc=null;
    try {
      doc=_xmlContainer.getDocument(model.getModelName());
    }
 catch (    XmlException e) {
    }
    if (doc != null) {
      throw new ModelAlreadyExistException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      String modelBody=model.getModel();
      modelBody=modelBody.substring(modelBody.indexOf(""String_Node_Str""));
      _xmlContainer.putDocument(_xmlTransaction,model.getModelName(),modelBody);
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Execute the necessary commands to create a new model in the database according to the model specification given in the task parameter.
 * @param task The task to be completed. In this case, CreateModelTask. Thiswill tell the DB layer to create a new model in the database.
 * @exception DBExecutionException Thrown if there is a problem executingthe task.
 * @exception ModelAlreadyExistException Thrown if the model being createdalready exists.
 */
public void executeCreateModelTask(CreateModelTask task) throws DBExecutionException, ModelAlreadyExistException {
  try {
    if (_xmlContainer == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_xmlTransaction == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (task == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XMLDBModel model=task.getXMLDBModel();
    if (model == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlDocument doc=null;
    try {
      doc=_xmlContainer.getDocument(model.getModelName());
    }
 catch (    XmlException e) {
    }
    if (doc != null) {
      throw new ModelAlreadyExistException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      String modelBody=model.getModel();
      if (modelBody.indexOf(""String_Node_Str"") >= 0) {
        modelBody=modelBody.substring(modelBody.indexOf(""String_Node_Str""));
        modelBody=modelBody.substring(modelBody.indexOf(""String_Node_Str"") + 1);
      }
      _xmlContainer.putDocument(_xmlTransaction,model.getModelName(),modelBody);
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
73781,"public SequentialScheduleEditorPane(Schedule schedule){
  super(new BorderLayout());
  _init();
  Iterator firings=schedule.actorIterator();
  while (firings.hasNext()) {
    Object actor=firings.next();
    _listModel.addElement(actor);
  }
}","/** 
 * Construct a SequentialScheduleEditorPane displaying the actors  contained in the given schedule and in the order given by the schedule. 
 * @param schedule The schedule for the actors to be displayed in the pane.
 */
public SequentialScheduleEditorPane(Schedule schedule){
  super(new BorderLayout());
  _init();
  Iterator firings=schedule.actorIterator();
  while (firings.hasNext()) {
    Object actor=firings.next();
    _listModel.addElement(actor);
  }
}"
73782,"private void _updateSchedule(SequentialScheduleEditorPane pane){
  Iterator oActors=pane.getOrderedActors().iterator();
  int i=1;
  String newScheduleText=new String(""String_Node_Str"");
  while (oActors.hasNext()) {
    if (i > 1) {
      newScheduleText+=""String_Node_Str"";
    }
    Actor oActor=(Actor)oActors.next();
    List<SequenceAttribute> seqAttributes=((Entity)oActor).attributeList(SequenceAttribute.class);
    if (seqAttributes.size() > 0) {
      SequenceAttribute seqAttribute=seqAttributes.get(0);
      seqAttribute.setExpression(Integer.toString(i));
    }
 else {
      try {
        SequenceAttribute seqAttribute=new SequenceAttribute((NamedObj)oActor,uniqueName(""String_Node_Str""));
        seqAttribute.setExpression(Integer.toString(i));
      }
 catch (      IllegalActionException e) {
        e.printStackTrace();
      }
catch (      NameDuplicationException e) {
        e.printStackTrace();
      }
    }
    newScheduleText+=""String_Node_Str"" + oActor.getDisplayName() + ""String_Node_Str""+ i+ ""String_Node_Str"";
    i++;
  }
  newScheduleText+=""String_Node_Str"";
  scheduleText.setExpression(newScheduleText);
}","private void _updateSchedule(SequentialScheduleEditorPane pane){
  Iterator oActors=pane.getOrderedActors().iterator();
  int i=1;
  StringBuffer newScheduleText=new StringBuffer();
  newScheduleText.append(""String_Node_Str"");
  while (oActors.hasNext()) {
    if (i > 1) {
      newScheduleText.append(""String_Node_Str"");
    }
    Actor oActor=(Actor)oActors.next();
    List<SequenceAttribute> seqAttributes=((Entity)oActor).attributeList(SequenceAttribute.class);
    if (seqAttributes.size() > 0) {
      SequenceAttribute seqAttribute=seqAttributes.get(0);
      seqAttribute.setExpression(Integer.toString(i));
    }
 else {
      try {
        SequenceAttribute seqAttribute=new SequenceAttribute((NamedObj)oActor,uniqueName(""String_Node_Str""));
        seqAttribute.setExpression(Integer.toString(i));
      }
 catch (      IllegalActionException e) {
        e.printStackTrace();
      }
catch (      NameDuplicationException e) {
        e.printStackTrace();
      }
    }
    newScheduleText.append(""String_Node_Str"");
    newScheduleText.append(oActor.getDisplayName());
    newScheduleText.append(""String_Node_Str"");
    newScheduleText.append(i);
    newScheduleText.append(""String_Node_Str"");
    i++;
  }
  newScheduleText.append(""String_Node_Str"");
  scheduleText.setExpression(newScheduleText.toString());
}"
73783,"public Vector<Actor> estimateSequencedSchedule(List<SequenceAttribute> independentList){
  _init();
  _initSources();
  _initSequencedActors(independentList);
  while (!_unsettled.isEmpty()) {
    Actor actor=_selectActor();
    _update(actor);
  }
  Vector<Actor> result=_getResult();
  return result;
}","/** 
 * Estimate a sequenced schedule. This uses a basic Dijkstra algorithm for getting the maximal distances. FIXME: If the graph is cyclic, this method runs forever! Currently this has to (or at least should) be checked before.
 * @param independentList The already present SequenceAttributes for theActors controlled by this scheduler.
 * @return A vector with the ordered actors. Note that the sequence numbersare not changed. This has to be done somewhere else.
 * @exception NotSchedulableException If the schedule is acyclic.
 */
public Vector<Actor> estimateSequencedSchedule(List<SequenceAttribute> independentList){
  _init();
  _initSources();
  _initSequencedActors(independentList);
  while (!_unsettled.isEmpty()) {
    Actor actor=_selectActor();
    _update(actor);
  }
  Vector<Actor> result=_getResult();
  return result;
}"
73784,"public Vector<Actor> estimateSequencedSchedule(List<SequenceAttribute> independentList) throws NotSchedulableException {
  if (_actorGraph.isAcyclic()) {
    return _estimator.estimateSequencedSchedule(independentList);
  }
 else {
    throw new NotSchedulableException(""String_Node_Str"");
  }
}","/** 
 * Estimate a sequenced schedule. Currently only supports basic Dijkstra  algorithm for getting the maximal distances. Thus, it cannot deal with cyclic graphs.
 * @param independentList The already present SequenceAttributes for theActors controlled by this scheduler.
 * @return A vector with the ordered actors. Note that the sequence numbersare not changed. This has to be done somewhere else.
 * @exception NotSchedulableException If the schedule is acyclic.
 */
public Vector<Actor> estimateSequencedSchedule(List<SequenceAttribute> independentList) throws NotSchedulableException {
  if (_actorGraph.isAcyclic()) {
    return _estimator.estimateSequencedSchedule(independentList);
  }
 else {
    throw new NotSchedulableException(""String_Node_Str"");
  }
}"
73785,"/** 
 * Instantiate the analysis model from the core model.
 * @param firingVector contains repetition vector information
 * @throws IllegalActionException if model information inconsistent
 */
protected void _instantiateAnalysisModel(Map firingVector) throws IllegalActionException {
}","/** 
 * Instantiate the analysis model from the core model.
 * @param firingVector contains repetition vector information
 * @throws IllegalActionException if model information inconsistent
 */
protected void _instantiateAnalysisModel(Map firingVector) throws IllegalActionException {
  _actors=new _ListOfActors();
  _actorMap=new _TwoWayHashMap();
  _channels=new _ListOfChannels();
  _channelMap=new _TwoWayHashMap();
  Iterator actorIterator=firingVector.entrySet().iterator();
  while (actorIterator.hasNext()) {
    int sharedBuffers, exclusiveBuffers, sharedExecutionTime, exclusiveExecutionTime;
    Map.Entry pair=(Map.Entry)actorIterator.next();
    ptolemy.actor.Actor actor=(ptolemy.actor.Actor)pair.getKey();
    if (actor instanceof BufferingProfile) {
      BufferingProfile actorWithBufferingProfile=(BufferingProfile)actor;
      sharedBuffers=actorWithBufferingProfile.sharedBuffers();
      exclusiveBuffers=actorWithBufferingProfile.exclusiveBuffers();
      sharedExecutionTime=actorWithBufferingProfile.sharedExecutionTime();
      exclusiveExecutionTime=actorWithBufferingProfile.exclusiveExecutionTime();
    }
 else {
      sharedBuffers=0;
      exclusiveBuffers=0;
      sharedExecutionTime=0;
      exclusiveExecutionTime=0;
    }
    _Actor modelActor=new _Actor(actor.getName(),(Integer)pair.getValue(),sharedBuffers,exclusiveBuffers,sharedExecutionTime,exclusiveExecutionTime);
    _actors.add(modelActor);
    _actorMap.put(modelActor,actor);
    List portList=actor.outputPortList();
    Iterator portIterator=portList.iterator();
    while (portIterator.hasNext()) {
      TypedIOPort port=(TypedIOPort)portIterator.next();
      _Channel channel=new _Channel();
      channel.initialTokens=DFUtilities.getTokenInitProduction(port);
      _channels.add(channel);
      _channelMap.put(port,channel);
    }
  }
  actorIterator=firingVector.keySet().iterator();
  while (actorIterator.hasNext()) {
    ptolemy.actor.Actor actor=(ptolemy.actor.Actor)actorIterator.next();
    _Actor modelActor=(_Actor)_actorMap.getBW(actor);
    List portList=actor.outputPortList();
    Iterator portIterator=portList.iterator();
    while (portIterator.hasNext()) {
      TypedIOPort port=(TypedIOPort)portIterator.next();
      int rate=DFUtilities.getRate(port);
      _Channel channel=(_Channel)_channelMap.getFW(port);
      _Port modelPort=new _Port(rate,channel);
      modelActor.addPort(modelPort);
    }
    portList=actor.inputPortList();
    portIterator=portList.iterator();
    while (portIterator.hasNext()) {
      TypedIOPort port=(TypedIOPort)portIterator.next();
      int rate=DFUtilities.getRate(port);
      List sourcePortList=port.sourcePortList();
      for (int i=0; i < sourcePortList.size(); i++) {
        _Channel channel=(_Channel)_channelMap.getFW(sourcePortList.get(i));
        if (channel != null) {
          _Port modelPort=new _Port(-rate,channel);
          modelActor.addPort(modelPort);
        }
      }
    }
  }
}"
73786,"/** 
 * Create an optimal schedule for a set of actors.   FIXME: contains a lot of duplicated code from same method in SDFScheduler Would be good to factor out common code, but I do not want to touch SDFScheduler
 * @param externalRates Map from external port to an Integerrepresenting the number of tokens produced or consumed from that port during the course of an iteration.
 * @param actorList The actors that need to be scheduled.
 * @param container The container.
 * @return An instance of the Schedule class, indicating the orderin which actors should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
private Schedule _scheduleConnectedActors(Map externalRates,List actorList,CompositeActor container) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  Schedule optimizedSchedule;
  Map firingsRemainingVector=new HashMap();
  firingsRemainingVector.putAll(_firingVector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator actorsIterator=actorList.iterator();
    while (actorsIterator.hasNext()) {
      Actor actor=(Actor)actorsIterator.next();
      Iterator inputPorts=actor.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort inputPort=(IOPort)inputPorts.next();
        Receiver[][] receivers=inputPort.getReceivers();
        if (receivers != null) {
          for (int m=0; m < receivers.length; m++) {
            for (int n=0; n < receivers[m].length; n++) {
              ((SDFReceiver)receivers[m][n])._waitingTokens=0;
            }
          }
        }
      }
    }
    Iterator externalOutputPorts=container.outputPortList().iterator();
    while (externalOutputPorts.hasNext()) {
      IOPort outputPort=(IOPort)externalOutputPorts.next();
      Receiver[][] receivers=outputPort.getInsideReceivers();
      if (receivers != null) {
        for (int m=0; m < receivers.length; m++) {
          for (int n=0; n < receivers[m].length; n++) {
            ((SDFReceiver)receivers[m][n])._waitingTokens=0;
          }
        }
      }
    }
    Iterator actors=actorList.iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      Iterator outputPorts=actor.outputPortList().iterator();
      while (outputPorts.hasNext()) {
        IOPort outputPort=(IOPort)outputPorts.next();
        int count=DFUtilities.getTokenInitProduction(outputPort);
        if (count > 0) {
          _simulateTokensCreated(outputPort,count);
        }
      }
    }
    for (Iterator inputPorts=container.inputPortList().iterator(); inputPorts.hasNext(); ) {
      IOPort port=(IOPort)inputPorts.next();
      int count=((Integer)externalRates.get(port)).intValue();
      if (count > 0) {
        _simulateExternalInputs(port,count,actorList,readyToScheduleActorList);
      }
    }
    OptimalScheduleFinder finder=new OptimalScheduleFinder(this,optimizationCriterion);
    HashMap repVec=new HashMap();
    Iterator rvi=_firingVector.keySet().iterator();
    while (rvi.hasNext()) {
      Actor rva=(Actor)rvi.next();
      if (rva != container) {
        repVec.put(rva,_firingVector.get(rva));
      }
    }
    optimizedSchedule=finder.makeSchedule(repVec);
    Iterator si=optimizedSchedule.iterator();
    while (si.hasNext()) {
      Firing firing=(Firing)si.next();
      Actor firingActor=firing.getActor();
      _simulateInputConsumption(firingActor,1);
      for (Iterator outputPorts=firingActor.outputPortList().iterator(); outputPorts.hasNext(); ) {
        IOPort outputPort=(IOPort)outputPorts.next();
        int count=DFUtilities.getTokenProductionRate(outputPort);
        _simulateTokensCreated(outputPort,count);
      }
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(this,ex,""String_Node_Str"");
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(optimizedSchedule.toString());
  }
  return optimizedSchedule;
}","/** 
 * Create an optimal schedule for a set of actors.   FIXME: contains a lot of duplicated code from same method in SDFScheduler Would be good to factor out common code, but I do not want to touch SDFScheduler
 * @param externalRates Map from external port to an Integerrepresenting the number of tokens produced or consumed from that port during the course of an iteration.
 * @param actorList The actors that need to be scheduled.
 * @param container The container.
 * @return An instance of the Schedule class, indicating the orderin which actors should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
private Schedule _scheduleConnectedActors(Map externalRates,List actorList,CompositeActor container) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  Schedule optimizedSchedule;
  Map firingsRemainingVector=new HashMap();
  firingsRemainingVector.putAll(_firingVector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator actorsIterator=actorList.iterator();
    while (actorsIterator.hasNext()) {
      Actor actor=(Actor)actorsIterator.next();
      Iterator inputPorts=actor.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort inputPort=(IOPort)inputPorts.next();
        Receiver[][] receivers=inputPort.getReceivers();
        if (receivers != null) {
          for (int m=0; m < receivers.length; m++) {
            for (int n=0; n < receivers[m].length; n++) {
              ((SDFReceiver)receivers[m][n])._waitingTokens=0;
            }
          }
        }
      }
    }
    Iterator externalOutputPorts=container.outputPortList().iterator();
    while (externalOutputPorts.hasNext()) {
      IOPort outputPort=(IOPort)externalOutputPorts.next();
      Receiver[][] receivers=outputPort.getInsideReceivers();
      if (receivers != null) {
        for (int m=0; m < receivers.length; m++) {
          for (int n=0; n < receivers[m].length; n++) {
            ((SDFReceiver)receivers[m][n])._waitingTokens=0;
          }
        }
      }
    }
    Iterator actors=actorList.iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      Iterator outputPorts=actor.outputPortList().iterator();
      while (outputPorts.hasNext()) {
        IOPort outputPort=(IOPort)outputPorts.next();
        int count=DFUtilities.getTokenInitProduction(outputPort);
        if (count > 0) {
          _simulateTokensCreated(outputPort,count);
        }
      }
    }
    for (Iterator inputPorts=container.inputPortList().iterator(); inputPorts.hasNext(); ) {
      IOPort port=(IOPort)inputPorts.next();
      int count=((Integer)externalRates.get(port)).intValue();
      if (count > 0) {
        _simulateExternalInputs(port,count,actorList,readyToScheduleActorList);
      }
    }
    OptimalScheduleFinder finder=new OptimalScheduleFinder(this,optimizationCriterion);
    HashMap repVec=new HashMap();
    Iterator rvi=_firingVector.keySet().iterator();
    while (rvi.hasNext()) {
      Actor rva=(Actor)rvi.next();
      if (rva != container) {
        repVec.put(rva,_firingVector.get(rva));
      }
    }
    optimizedSchedule=finder.makeScheduleGreedy(repVec);
    Iterator si=optimizedSchedule.iterator();
    while (si.hasNext()) {
      Firing firing=(Firing)si.next();
      Actor firingActor=firing.getActor();
      _simulateInputConsumption(firingActor,1);
      for (Iterator outputPorts=firingActor.outputPortList().iterator(); outputPorts.hasNext(); ) {
        IOPort outputPort=(IOPort)outputPorts.next();
        int count=DFUtilities.getTokenProductionRate(outputPort);
        _simulateTokensCreated(outputPort,count);
      }
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(this,ex,""String_Node_Str"");
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(optimizedSchedule.toString());
  }
  return optimizedSchedule;
}"
73787,"private void _init() throws IllegalActionException, NameDuplicationException {
  setClassName(""String_Node_Str"");
  stateDependentCausality=new Parameter(this,""String_Node_Str"");
  stateDependentCausality.setTypeEquals(BaseType.BOOLEAN);
  stateDependentCausality.setExpression(""String_Node_Str"");
  _controller=new ModalController(this,""String_Node_Str"");
  _controller.stateDependentCausality.setExpression(""String_Node_Str"");
  directorClass=new StringParameter(this,""String_Node_Str"");
  FSMDirector defaultFSMDirector=new FSMDirector(this,""String_Node_Str"");
  defaultFSMDirector.controllerName.setExpression(""String_Node_Str"");
  Director executiveDirector=getExecutiveDirector();
  if (executiveDirector != null) {
    String[] suggestions=executiveDirector.suggestedModalModelDirectors();
    for (int i=0; i < suggestions.length; i++) {
      suggestions[i]=suggestions[i].replace(""String_Node_Str"",""String_Node_Str"");
      directorClass.addChoice(suggestions[i]);
      if (i == 0) {
        directorClass.setExpression(suggestions[i]);
      }
    }
  }
 else {
    directorClass.setExpression(""String_Node_Str"");
  }
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  try {
    modelError=new Parameter(this,""String_Node_Str"");
    modelError.setTypeEquals(BaseType.BOOLEAN);
    modelError.setExpression(""String_Node_Str"");
    modelError.setVisibility(null);
  }
 catch (  IllegalActionException ex) {
    ex.printStackTrace();
  }
catch (  NameDuplicationException ex) {
    ex.printStackTrace();
  }
}","private void _init() throws IllegalActionException, NameDuplicationException {
  setClassName(""String_Node_Str"");
  stateDependentCausality=new Parameter(this,""String_Node_Str"");
  stateDependentCausality.setTypeEquals(BaseType.BOOLEAN);
  stateDependentCausality.setExpression(""String_Node_Str"");
  _controller=new ModalController(this,""String_Node_Str"");
  _controller.stateDependentCausality.setExpression(""String_Node_Str"");
  directorClass=new StringParameter(this,""String_Node_Str"");
  FSMDirector defaultFSMDirector=new FSMDirector(this,""String_Node_Str"");
  defaultFSMDirector.controllerName.setExpression(""String_Node_Str"");
  Director executiveDirector=getExecutiveDirector();
  if (executiveDirector != null) {
    String[] suggestions=executiveDirector.suggestedModalModelDirectors();
    for (int i=0; i < suggestions.length; i++) {
      suggestions[i]=suggestions[i].replace(""String_Node_Str"",""String_Node_Str"");
      directorClass.addChoice(suggestions[i]);
      if (i == 0) {
        directorClass.setExpression(suggestions[i]);
      }
    }
  }
 else {
    directorClass.setExpression(""String_Node_Str"");
  }
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  try {
    modelError=new Parameter(this,""String_Node_Str"");
    modelError.setTypeEquals(BaseType.BOOLEAN);
    modelError.setExpression(""String_Node_Str"");
    modelError.setVisibility(null);
  }
 catch (  IllegalActionException ex) {
    throw ex;
  }
catch (  NameDuplicationException ex) {
    throw ex;
  }
}"
73788,"/** 
 * Return the parents for the current model
 * @return ArrayList<ArrayList<XMLDBModel>> - list of parents models for the current model
 */
public List<List<XMLDBModel>> getParents(){
  return _m_listParents;
}","/** 
 * Return the parents for the current model.
 * @return List of parents models for the current model.
 */
public List<List<XMLDBModel>> getParents(){
  return _listParents;
}"
73789,"/** 
 * Add the given parent list to the model's parent list.
 * @param list List of parents to be added.
 */
public void addParentList(List<XMLDBModel> list){
  if (_m_listParents == null) {
    _m_listParents=new ArrayList<List<XMLDBModel>>();
  }
  _m_listParents.add(list);
}","/** 
 * Add the given parent list to the model's parent list.
 * @param List of parents to be added.
 */
public void addParentList(List<XMLDBModel> list){
  if (_listParents == null) {
    _listParents=new ArrayList<List<XMLDBModel>>();
  }
  _listParents.add(list);
}"
73790,"/** 
 * Construct a XMLDBModel instance with the given model name.
 * @param modelName Name for the given model.
 */
public XMLDBModel(String modelName){
  this._m_strModelName=modelName;
}","/** 
 * Construct a XMLDBModel instance with the given model name.
 * @param Name for the given model.
 */
public XMLDBModel(String modelName){
  this._modelName=modelName;
}"
73791,"/** 
 * Return the model content.
 * @return String - string representation of the model content
 */
public String getModel(){
  return _m_strModel;
}","/** 
 * Return the model content.
 * @return A string representation of the model content.
 */
public String getModel(){
  return _modelContent;
}"
73792,"/** 
 * Set the parents for the current model
 * @param ArrayList<ArrayList<XMLDBModel>> p_listParents - list of parents for that need to be set as parents for the current model.
 */
public void setParents(List<List<XMLDBModel>> p_listParents){
  _m_listParents=p_listParents;
}","/** 
 * Set the parents for the current model
 * @param List of parents for this model.
 */
public void setParents(List<List<XMLDBModel>> listParents){
  _listParents=listParents;
}"
73793,"/** 
 * Set the model name
 * @param String p_strModelName - the model name to be set.
 */
public void setModelName(String p_strModelName){
  _m_strModelName=p_strModelName;
}","/** 
 * Set the model name.
 * @param The model name.
 */
public void setModelName(String modelName){
  _modelName=modelName;
}"
73794,"/** 
 * Set the model content
 * @param String p_strModel - this is the model content to be set.
 */
public void setModel(String p_strModel){
  _m_strModel=p_strModel;
}","/** 
 * Set the model content.
 * @param The model content in xml format.
 */
public void setModel(String modelContent){
  _modelContent=modelContent;
}"
73795,"/** 
 * Return the is new.
 * @return boolean True or false based on if the model is new or it exists in the database.
 */
public boolean getIsNew(){
  return _m_bIsNew;
}","/** 
 * Return True or false based on if the model is new or it exists in the database.
 * @return True or false based on if the model is new or it exists in the database.
 */
public boolean getIsNew(){
  return _isNew;
}"
73796,"/** 
 * Return the model name
 * @return string - the model name
 */
public String getModelName(){
  return _m_strModelName;
}","/** 
 * Return the model name.
 * @return The model name.
 */
public String getModelName(){
  return _modelName;
}"
73797,"/** 
 * Set the isNew variable
 * @param boolean p_bIsNew - variable that holds true or false to set the isNew member variable
 */
public void setIsNew(boolean p_bIsNew){
  _m_bIsNew=p_bIsNew;
}","/** 
 * Set the isNew variable which indicates if the model is in the database or it is new model.
 * @param True or false value to set the isNew member variable.
 */
public void setIsNew(boolean isNew){
  _isNew=isNew;
}"
73798,"/** 
 * Generate variable declarations for inputs and outputs and parameters. Append the declarations to the given string buffer.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableDeclaration() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(super.generateVariableDeclaration());
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    if (actor instanceof ModularCodeGenTypedCompositeActor || actor instanceof ModularCompiledSDFTypedCompositeActor) {
      String className=NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor);
      String actorName=ModularCodeGenTypedCompositeActor.classToActorName(className);
      code.append(className + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ _eol);
    }
  }
  return code.toString();
}","/** 
 * Generate variable declarations for inputs and outputs and parameters. Append the declarations to the given string buffer.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableDeclaration() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=(CompositeActor)_director.getContainer();
  GenericCodeGenerator codeGenerator=getCodeGenerator();
{
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(container);
    code.append(_generateVariableDeclaration(adapterObject));
  }
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    code.append(_generateVariableDeclaration(adapterObject));
  }
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    if (actor instanceof ModularCodeGenTypedCompositeActor || actor instanceof ModularCompiledSDFTypedCompositeActor) {
      String className=NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor);
      String actorName=ModularCodeGenTypedCompositeActor.classToActorName(className);
      code.append(className + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ _eol);
    }
  }
  return code.toString();
}"
73799,"/** 
 * Generate variable initialization for the referenced parameters.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableInitialization() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(super.generateVariableInitialization());
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    if (actor instanceof ModularCodeGenTypedCompositeActor || actor instanceof ModularCompiledSDFTypedCompositeActor) {
      String className=NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor);
      String actorName=ModularCodeGenTypedCompositeActor.classToActorName(className);
      code.append(actorName + ""String_Node_Str"" + className+ ""String_Node_Str""+ _eol);
      code.append(actorName + ""String_Node_Str"" + _eol);
    }
  }
  return code.toString();
}","/** 
 * Generate variable initialization for the referenced parameters.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableInitialization() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=(CompositeActor)_director.getContainer();
  GenericCodeGenerator codeGenerator=getCodeGenerator();
{
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(container);
    code.append(_generateVariableInitialization(adapterObject));
  }
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    code.append(_generateVariableInitialization(adapterObject));
  }
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    if (actor instanceof ModularCodeGenTypedCompositeActor || actor instanceof ModularCompiledSDFTypedCompositeActor) {
      String className=NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor);
      String actorName=ModularCodeGenTypedCompositeActor.classToActorName(className);
      code.append(actorName + ""String_Node_Str"" + className+ ""String_Node_Str""+ _eol);
      code.append(actorName + ""String_Node_Str"" + _eol);
    }
  }
  return code.toString();
}"
73800,"/** 
 * Run concept inference and check the values match those trained. This simply looks through the conceptable objects and checks that their resolved concepts match the value contained in the <i>_trainedConcept</i> attribute.  Conceptables without a <i>_trainedConcept</i> attribute are just ignored, and do not cause the test to fail.
 * @exception IllegalActionException If inference fails or the testresolves to the wrong values.
 */
public void test() throws IllegalActionException {
  try {
    workspace().getWriteAccess();
    resetAll();
    invokeSolver();
  }
  finally {
    workspace().doneWriting();
  }
  for (  NamedObj conceptable : getAllConceptableNamedObjs()) {
    StringParameter trained=(StringParameter)conceptable.getAttribute(""String_Node_Str"");
    if (trained == null) {
      continue;
    }
    String inferred=getResolvedProperty(conceptable).toString();
    if (!inferred.equals(trained.stringValue())) {
      throw new IllegalActionException(conceptable,""String_Node_Str"" + conceptable.toString() + '\n'+ ""String_Node_Str""+ trained.stringValue()+ ""String_Node_Str""+ inferred+ ""String_Node_Str"");
    }
  }
}","/** 
 * Run concept inference and check the values match those trained. This simply looks through the conceptable objects and checks that their resolved concepts match the value contained in the <i>_trainedConcept</i> attribute.  Conceptables without a <i>_trainedConcept</i> attribute are just ignored, and do not cause the test to fail.
 * @exception IllegalActionException If inference fails or the testresolves to the wrong values.
 */
public void test() throws IllegalActionException {
  try {
    workspace().getWriteAccess();
    resetAll();
    invokeSolver();
  }
  finally {
    workspace().doneWriting();
  }
  for (  NamedObj conceptable : getAllConceptableNamedObjs()) {
    StringParameter trained=(StringParameter)conceptable.getAttribute(""String_Node_Str"");
    if (trained == null) {
      continue;
    }
    Concept inferredConcept=getResolvedProperty(conceptable);
    if (inferredConcept == null) {
      throw new IllegalActionException(conceptable,""String_Node_Str"" + conceptable.toString() + '\n'+ ""String_Node_Str""+ trained.stringValue()+ ""String_Node_Str"");
    }
    String inferred=inferredConcept.toString();
    if (!inferred.equals(trained.stringValue())) {
      throw new IllegalActionException(conceptable,""String_Node_Str"" + conceptable.toString() + '\n'+ ""String_Node_Str""+ trained.stringValue()+ ""String_Node_Str""+ inferred+ ""String_Node_Str"");
    }
  }
}"
73801,"/** 
 * Generate variable declarations for inputs and outputs and parameters. Append the declarations to the given string buffer.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableDeclaration() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=(CompositeActor)_director.getContainer();
  GenericCodeGenerator codeGenerator=getCodeGenerator();
{
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(container);
    code.append(_generateVariableDeclaration(adapterObject));
  }
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    code.append(_generateVariableDeclaration(adapterObject));
  }
  return code.toString();
}","/** 
 * Generate variable declarations for inputs and outputs and parameters. Append the declarations to the given string buffer.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableDeclaration() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=(CompositeActor)_director.getContainer();
  GenericCodeGenerator codeGenerator=getCodeGenerator();
{
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(container);
    code.append(_generateVariableDeclaration(adapterObject));
  }
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    if (actor instanceof CompositeActor && ((CompositeActor)actor).isOpaque())     code.append(adapterObject.generateVariableDeclaration());
 else     code.append(_generateVariableDeclaration(adapterObject));
  }
  return code.toString();
}"
73802,"/** 
 * Generate variable initialization for the referenced parameters.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableInitialization() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=(CompositeActor)_director.getContainer();
  GenericCodeGenerator codeGenerator=getCodeGenerator();
{
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(container);
    code.append(_generateVariableInitialization(adapterObject));
  }
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    code.append(_generateVariableInitialization(adapterObject));
  }
  return code.toString();
}","/** 
 * Generate variable initialization for the referenced parameters.
 * @return code The generated code.
 * @exception IllegalActionException If the adapter class for the modeldirector cannot be found.
 */
@Override public String generateVariableInitialization() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=(CompositeActor)_director.getContainer();
  GenericCodeGenerator codeGenerator=getCodeGenerator();
{
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(container);
    code.append(_generateVariableInitialization(adapterObject));
  }
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    NamedProgramCodeGeneratorAdapter adapterObject=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    code.append(adapterObject.generateVariableInitialization());
    code.append(_generateVariableInitialization(adapterObject));
  }
  return code.toString();
}"
73803,"/** 
 * Execute the get models task which basically accesses the  database and returns the model requested as XMLDBModel object
 * @throws DBExecutionException Thrown if there is a problem executing the task.
 * @param task this is the get models task that contain the model name
 * @return XMLDBModel this is the model fetched from the database	
 */
public XMLDBModel executeGetModelsTask(GetModelsTask task) throws DBExecutionException {
  try {
    if (task == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlDocument dbModel=_xmlContainer.getDocument(_xmlTransaction,task.getModelName());
    XMLDBModel completeXMLDBModel=null;
    if (dbModel != null) {
      completeXMLDBModel=new XMLDBModel();
      completeXMLDBModel.setModelName(dbModel.getName());
      String strCompleteModelBody=""String_Node_Str"";
      String strReferences=_getModelReferences(dbModel.getName());
      if (strReferences != null && strReferences.length() > 0) {
        Node modelNode=_parseXML(strReferences);
        strCompleteModelBody=_buildCompleteModel(modelNode);
      }
 else {
        strCompleteModelBody=dbModel.getContentAsString();
      }
      completeXMLDBModel.setModel(strCompleteModelBody);
      completeXMLDBModel.setIsNew(false);
      completeXMLDBModel.setParents(null);
    }
    return completeXMLDBModel;
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Execute the get models task which basically accesses the  database and returns the model requested as XMLDBModel object
 * @throws DBExecutionException Thrown if there is a problem executing the task.
 * @param task this is the get models task that contain the model name
 * @return XMLDBModel this is the model fetched from the database	
 */
public XMLDBModel executeGetModelsTask(GetModelsTask task) throws DBExecutionException {
  try {
    if (task == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlDocument dbModel;
    try {
      dbModel=_xmlContainer.getDocument(_xmlTransaction,task.getModelName());
    }
 catch (    XmlException e) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XMLDBModel completeXMLDBModel=null;
    if (dbModel != null) {
      completeXMLDBModel=new XMLDBModel();
      completeXMLDBModel.setModelName(dbModel.getName());
      String strCompleteModelBody=""String_Node_Str"";
      String strReferences=_getModelReferences(dbModel.getName());
      if (strReferences != null && strReferences.length() > 0) {
        Node modelNode=_parseXML(strReferences);
        strCompleteModelBody=_buildCompleteModel(modelNode);
      }
 else {
        strCompleteModelBody=dbModel.getContentAsString();
      }
      completeXMLDBModel.setModel(strCompleteModelBody);
      completeXMLDBModel.setIsNew(false);
      completeXMLDBModel.setParents(null);
    }
    return completeXMLDBModel;
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
73804,"/** 
 */
public ArrayList executeGetAttributesTask(GetAttributesTask task) throws DBExecutionException {
  return null;
}","/** 
 * Get the attributes defined from the database. 
 * @param task The criteria to get the attribute.   
 * @return List of attributes stored in the database.
 * @throws DBExecutionException
 */
public ArrayList executeGetAttributesTask(GetAttributesTask task) throws DBExecutionException {
  return null;
}"
73805,"private String _buildCompleteModel(Node p_currentNode) throws DBExecutionException {
  if (_xmlModelHerarichyMap == null) {
    _xmlModelHerarichyMap=new HashMap<String,String>();
  }
  NamedNodeMap attributes=p_currentNode.getAttributes();
  String strCurrentModelName=""String_Node_Str"";
  if (attributes != null) {
    for (int i=0; i < attributes.getLength(); i++) {
      Node node=attributes.item(i);
      if (node.getNodeName().equalsIgnoreCase(""String_Node_Str"")) {
        strCurrentModelName=node.getNodeValue();
        break;
      }
    }
  }
  if (strCurrentModelName != null && strCurrentModelName.length() > 0) {
    if (_xmlModelHerarichyMap.containsKey(strCurrentModelName)) {
      return (String)_xmlModelHerarichyMap.get(strCurrentModelName);
    }
    if (_xmlContainer == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlDocument currentDbModel;
    String strCurrentModelContent=""String_Node_Str"";
    try {
      currentDbModel=_xmlContainer.getDocument(strCurrentModelName);
      if (currentDbModel == null) {
        throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + strCurrentModelName + ""String_Node_Str"");
      }
      strCurrentModelContent=currentDbModel.getContentAsString();
    }
 catch (    XmlException e) {
      throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
    if (p_currentNode.hasChildNodes()) {
      NodeList children=p_currentNode.getChildNodes();
      for (int i=0; i < children.getLength(); i++) {
        if (children.item(i).getNodeType() == Node.ELEMENT_NODE) {
          Node child=children.item(i);
          String strChildContent=_buildCompleteModel(child);
          strChildContent=strChildContent.substring(strChildContent.indexOf(""String_Node_Str""));
          String strChildNode=_getParentEntityNodeAsString(strChildContent);
          if (strChildNode != null && strChildNode.length() > 0) {
            strCurrentModelContent=strCurrentModelContent.replaceAll(strChildNode,strChildContent);
          }
          strCurrentModelContent=strCurrentModelContent.replaceAll(""String_Node_Str"",""String_Node_Str"");
        }
      }
      _xmlModelHerarichyMap.put(strCurrentModelName,strCurrentModelContent);
      return strCurrentModelContent;
    }
 else {
      _xmlModelHerarichyMap.put(strCurrentModelName,strCurrentModelContent);
      return strCurrentModelContent;
    }
  }
 else {
    return ""String_Node_Str"";
  }
}","/** 
 * Build the complete model by resolving all the references in it.
 * @param p_currentNode the node in the reference file that points to the model
 * @return String that represents the model body without references
 * @throws DBExecutionException Thrown if there is a problem executing the task.
 */
private String _buildCompleteModel(Node p_currentNode) throws DBExecutionException {
  if (_xmlModelHerarichyMap == null) {
    _xmlModelHerarichyMap=new HashMap<String,String>();
  }
  NamedNodeMap attributes=p_currentNode.getAttributes();
  String strCurrentModelName=""String_Node_Str"";
  if (attributes != null) {
    for (int i=0; i < attributes.getLength(); i++) {
      Node node=attributes.item(i);
      if (node.getNodeName().equalsIgnoreCase(""String_Node_Str"")) {
        strCurrentModelName=node.getNodeValue();
        break;
      }
    }
  }
  if (strCurrentModelName != null && strCurrentModelName.length() > 0) {
    if (_xmlModelHerarichyMap.containsKey(strCurrentModelName)) {
      return (String)_xmlModelHerarichyMap.get(strCurrentModelName);
    }
    if (_xmlContainer == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlDocument currentDbModel;
    String strCurrentModelContent=""String_Node_Str"";
    try {
      currentDbModel=_xmlContainer.getDocument(strCurrentModelName);
      if (currentDbModel == null) {
        throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"" + strCurrentModelName + ""String_Node_Str"");
      }
      strCurrentModelContent=currentDbModel.getContentAsString();
    }
 catch (    XmlException e) {
      throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
    if (p_currentNode.hasChildNodes()) {
      NodeList children=p_currentNode.getChildNodes();
      for (int i=0; i < children.getLength(); i++) {
        if (children.item(i).getNodeType() == Node.ELEMENT_NODE) {
          Node child=children.item(i);
          String strChildContent=_buildCompleteModel(child);
          strChildContent=strChildContent.substring(strChildContent.indexOf(""String_Node_Str""));
          String strChildNode=_getParentEntityNodeAsString(strChildContent);
          if (strChildNode != null && strChildNode.length() > 0) {
            strCurrentModelContent=strCurrentModelContent.replaceAll(strChildNode,strChildContent);
          }
          strCurrentModelContent=strCurrentModelContent.replaceAll(""String_Node_Str"",""String_Node_Str"");
        }
      }
    }
    _xmlModelHerarichyMap.put(strCurrentModelName,strCurrentModelContent);
    return strCurrentModelContent;
  }
 else {
    return ""String_Node_Str"";
  }
}"
73806,"/** 
 * Execute the necessary commands to save/update a model in the database according to the model specification given in the task parameter
 * @param task The task to be completed.  In this case, SaveModelTask.  This will tell the DB layer to save/update a model already existing in the database.
 * @throws DBExecutionException Thrown if there is a problem executing the task.
 */
public void executeSaveModelTask(SaveModelTask task) throws DBExecutionException {
  try {
    if (_xmlContainer == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_xmlTransaction == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (task == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XMLDBModel model=task.getXMLDBModel();
    if (model == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlDocument currentDbModel=_xmlContainer.getDocument(model.getModelName());
    if (currentDbModel == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      currentDbModel.setContent(model.getModel());
      _xmlContainer.updateDocument(_xmlTransaction,currentDbModel);
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Execute the necessary commands to save/update a model in the database according to the model specification given in the task parameter
 * @param task The task to be completed.  In this case, SaveModelTask.  This will tell the DB layer to save/update a model already existing in the database.
 * @throws DBExecutionException Thrown if there is a problem executing the task.
 */
public void executeSaveModelTask(SaveModelTask task) throws DBExecutionException {
  try {
    if (_xmlContainer == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_xmlTransaction == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (task == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XMLDBModel model=task.getXMLDBModel();
    if (model == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlDocument currentDbModel=null;
    try {
      currentDbModel=_xmlContainer.getDocument(model.getModelName());
    }
 catch (    XmlException e) {
    }
    if (currentDbModel == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      currentDbModel.setContent(model.getModel());
      _xmlContainer.updateDocument(_xmlTransaction,currentDbModel);
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
73807,"/** 
 * retrieve the references inside a model from the reference file in the database.
 * @param p_strModelName - the model name for which the references are required.
 * @return String representation of all the references in the given model in xml format.
 * @throws DBExecutionException thrown if there is an execution exception.
 */
private String _getModelReferences(String p_strModelName) throws DBExecutionException {
  String strReference=""String_Node_Str"";
  try {
    if (_xmlContainer == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_xmlManager == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlQueryContext xmlContext=_xmlManager.createQueryContext();
    if (xmlContext == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    String strQuery=""String_Node_Str"" + _xmlContainer.getName() + ""String_Node_Str""+ p_strModelName+ ""String_Node_Str"";
    XmlQueryExpression queryExpression=_xmlManager.prepare(strQuery,xmlContext);
    if (queryExpression == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlResults results=queryExpression.execute(xmlContext);
    if (results != null && results.size() > 0) {
      XmlValue result=results.next();
      strReference=result.asString();
    }
    return strReference;
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * retrieve the references inside a model from the reference file in the database.
 * @param p_strModelName - the model name for which the references are required.
 * @return String representation of all the references in the given model in xml format.
 * @throws DBExecutionException thrown if there is an execution exception.
 */
private String _getModelReferences(String p_strModelName) throws DBExecutionException {
  String strReference=""String_Node_Str"";
  try {
    if (_xmlContainer == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_xmlManager == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlQueryContext xmlContext=_xmlManager.createQueryContext();
    if (xmlContext == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    String strQuery=""String_Node_Str"" + _xmlContainer.getName() + ""String_Node_Str""+ ""String_Node_Str""+ p_strModelName+ ""String_Node_Str"";
    XmlQueryExpression queryExpression=_xmlManager.prepare(strQuery,xmlContext);
    if (queryExpression == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlResults results=queryExpression.execute(xmlContext);
    if (results != null && results.size() > 0) {
      XmlValue result=results.next();
      strReference=result.asString();
    }
    return strReference;
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
73808,"/** 
 * Parse the xml string that is passed to it and returns the upper node of that xml.
 * @param p_strXML the xml string that needs to be parsed
 * @return Node - the upper node for the xml string after parsing it.
 * @throws DBExecutionException used as wrapper to the parser exceptions
 */
private Node _parseXML(String p_strXML) throws DBExecutionException {
  if (p_strXML == null || p_strXML.length() == 0) {
    throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  DocumentBuilder docBuilder;
  Node firstNode=null;
  DocumentBuilderFactory docBuilderFactory=DocumentBuilderFactory.newInstance();
  if (docBuilderFactory == null) {
    throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  docBuilderFactory.setIgnoringElementContentWhitespace(true);
  try {
    docBuilder=docBuilderFactory.newDocumentBuilder();
    if (docBuilder == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    InputSource is=new InputSource();
    is.setCharacterStream(new StringReader(p_strXML));
    firstNode=docBuilder.parse(is);
  }
 catch (  ParserConfigurationException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  SAXException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  IOException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
  return firstNode;
}","/** 
 * Parse the xml string that is passed to it and returns the upper node of that xml.
 * @param p_strXML the xml string that needs to be parsed
 * @return Node - the upper node for the xml string after parsing it.
 * @throws DBExecutionException used as wrapper to the parser exceptions
 */
private Node _parseXML(String p_strXML) throws DBExecutionException {
  if (p_strXML == null || p_strXML.length() == 0) {
    throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  DocumentBuilder docBuilder;
  Node firstNode=null;
  DocumentBuilderFactory docBuilderFactory=DocumentBuilderFactory.newInstance();
  if (docBuilderFactory == null) {
    throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  docBuilderFactory.setIgnoringElementContentWhitespace(true);
  try {
    docBuilder=docBuilderFactory.newDocumentBuilder();
    if (docBuilder == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    InputSource is=new InputSource();
    is.setCharacterStream(new StringReader(p_strXML));
    firstNode=docBuilder.parse(is);
    firstNode=firstNode.getChildNodes().item(0);
  }
 catch (  ParserConfigurationException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  SAXException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  IOException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
  return firstNode;
}"
73809,"/** 
 * Execute the necessary commands to create a new model in the database according to the model specification given in the task parameter
 * @param task The task to be completed.  In this case, CreateModelTask.  This will tell the DB layer to create a new model in the database.
 * @throws DBExecutionException Thrown if there is a problem executing the task.
 */
public void executeCreateModelTask(CreateModelTask task) throws DBExecutionException {
  try {
    if (_xmlContainer == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_xmlTransaction == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (task == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XMLDBModel model=task.getXMLDBModel();
    if (model == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlDocument doc=_xmlContainer.getDocument(model.getModelName());
    if (doc != null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      _xmlContainer.putDocument(_xmlTransaction,model.getModelName(),model.getModel());
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Execute the necessary commands to create a new model in the database according to the model specification given in the task parameter
 * @param task The task to be completed.  In this case, CreateModelTask.  This will tell the DB layer to create a new model in the database.
 * @throws DBExecutionException Thrown if there is a problem executing the task.
 */
public void executeCreateModelTask(CreateModelTask task) throws DBExecutionException {
  try {
    if (_xmlContainer == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_xmlTransaction == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (task == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XMLDBModel model=task.getXMLDBModel();
    if (model == null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    XmlDocument doc=null;
    try {
      doc=_xmlContainer.getDocument(model.getModelName());
    }
 catch (    XmlException e) {
    }
    if (doc != null) {
      throw new DBExecutionException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      _xmlContainer.putDocument(_xmlTransaction,model.getModelName(),model.getModel());
    }
  }
 catch (  XmlException e) {
    throw new DBExecutionException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
73810,"/** 
 * If the destination port is the only input port of the actor, or if the port does not have a minDelay parameter, or if there doesn't exist a destination port (in case of pure event) then the event is always safe to process. Otherwise: If the current physical time has passed the timestamp of the event minus minDelay of the port, then the event is safe to process. Otherwise the event is not safe to process, and we calculate the physical time when the event is safe to process and setup a timed interrupt.
 * @param event The event checked for safe to process
 * @return True if the event is safe to process, otherwise return false.
 * @exception IllegalActionException
 * @see #_setTimedInterrupt(Time)
 */
protected boolean _safeToProcess(PtidesEvent event) throws IllegalActionException {
  IOPort port=event.ioPort();
  if (port == null) {
    if (!event.isPureEvent()) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    return true;
  }
  if (port.isOutput()) {
    return true;
  }
  double minDelay=_getMinDelay(port,((PtidesEvent)event).channel(),event.isPureEvent());
  Time waitUntilPhysicalTime=event.timeStamp().subtract(minDelay);
  if (getPhysicalTime().subtract(waitUntilPhysicalTime).compareTo(_zero) >= 0) {
    return true;
  }
 else {
    _setTimedInterrupt(waitUntilPhysicalTime);
    return false;
  }
}","/** 
 * If the destination port is the only input port of the actor, or if the port does not have a minDelay parameter, or if there doesn't exist a destination port (in case of pure event) then the event is always safe to process. Otherwise: If the current physical time has passed the timestamp of the event minus minDelay of the port, then the event is safe to process. Otherwise the event is not safe to process, and we calculate the physical time when the event is safe to process and setup a timed interrupt.
 * @param event The event checked for safe to process
 * @return True if the event is safe to process, otherwise return false.
 * @exception IllegalActionException
 * @see #_setTimedInterrupt(Time)
 */
protected boolean _safeToProcess(PtidesEvent event) throws IllegalActionException {
  IOPort port=event.ioPort();
  if (port == null) {
    if (!event.isPureEvent()) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    return true;
  }
  if (port.isOutput()) {
    return true;
  }
  double minDelay=_getMinDelay(port,((PtidesEvent)event).channel(),event.isPureEvent());
  Time waitUntilPhysicalTime=event.timeStamp().subtract(minDelay);
  if (getPhysicalTag().timestamp.subtract(waitUntilPhysicalTime).compareTo(_zero) >= 0 && (getPhysicalTag().microstep - event.microstep() >= 0)) {
    return true;
  }
 else {
    _setTimedInterrupt(waitUntilPhysicalTime);
    return false;
  }
}"
73811,"/** 
 * Compares this RealTimeEvent with another. Compares the delivery times of these two events.
 * @param other The object comparing to.
 */
public int compareTo(Object other){
  return deliveryTime.compareTo(((RealTimeEvent)other).deliveryTime);
}","/** 
 * Compares this RealTimeEvent with another. Compares the delivery times of these two events.
 * @param other The object comparing to.
 */
public int compareTo(Object other){
  return deliveryTag.compareTo(((RealTimeEvent)other).deliveryTag);
}"
73812,"/** 
 * Return the actor to fire in this iteration, or null if no actor should be fired. In this base class, this method first checks whether the top event from the event queue is destined for an actuator. If it is, then we check if physical time has reached the timestamp of the actuation event. If it has, then we fire the actuator. If it has not, then we take the actuator event from the event queue and put it onto the _realTimeEventQueue, and call fireAt() of the executive director. We then check if a real-time event should be processed by looking at the top event of the _realTimeEventQueue. If there is on that should be fired, that actor is returned for firing. If not, we go on and considers two cases, depending whether there is an actor currently executing, as follows: <p> <b>Case 1</b>: If there is no actor currently executing, then this method checks the event queue and returns null if it is empty. If it is not empty, it checks the destination actor of the earliest event on the event queue, and if it has a non-zero execution time, then it pushes it onto the currently executing stack and returns null. Otherwise, if the execution time of the actor is zero, it sets the current model time to the time stamp of that earliest event and returns that actor. <p> <b>Case 2</b>: If there is an actor currently executing, then this method checks whether it has a remaining execution time of zero. If it does, then it returns the currently executing actor. If it does not, then it checks whether the earliest event on the event queue should preempt it (by invoking _preemptExecutingActor()), and if so, checks the destination actor of that event and removes the event from the event queue. If that destination actor has an execution time of zero, then it sets the current model time to the time stamp of that event, and returns that actor. Else if the destination actor has an execution time of bigger than zero, then it calls fireAt() on the enclosing director passing it the time it expects the currently executing actor to finish executing, and returns null. If there is no event on the event queue or that event should not preempt the currently executing actor, then it calls fireAt() on the enclosing director passing it the time it expects the currently executing actor to finish executing, and returns null.
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards, or if the enclosing director does not respect the fireAt call.
 * @see #_preemptExecutingActor()
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  Time physicalTime=getPhysicalTime();
  Actor container=(Actor)getContainer();
  Director executiveDirector=container.getExecutiveDirector();
  if (!_currentlyExecutingStack.isEmpty()) {
    DoubleTimedEvent currentEventList=(DoubleTimedEvent)_currentlyExecutingStack.peek();
    Time remainingExecutionTime=currentEventList.remainingExecutionTime;
    Time finishTime=_physicalTimeExecutionStarted.add(remainingExecutionTime);
    int comparison=finishTime.compareTo(physicalTime);
    if (comparison < 0) {
      throw new IllegalActionException(this,_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),""String_Node_Str"");
    }
 else     if (comparison == 0) {
      setTag(currentEventList.timeStamp,currentEventList.microstep);
      _currentlyExecutingStack.pop();
      _physicalTimeExecutionStarted=physicalTime;
      if (_debugging) {
        _debug(""String_Node_Str"" + _getActorFromEventList((List<PtidesEvent>)currentEventList.contents).getName(getContainer()) + ""String_Node_Str""+ physicalTime);
      }
      _setIcon(_getIdleIcon(),false);
      _clearHighlight(_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),false);
      _lastExecutingActor=null;
      executiveDirector.fireAtCurrentTime((Actor)container);
      return _getActorFromEventList((List<PtidesEvent>)currentEventList.contents);
    }
 else {
      Time nextEventOnStackFireTime=_currentlyExecutingStack.peek().remainingExecutionTime;
      Time expectedCompletionTime=nextEventOnStackFireTime.add(_physicalTimeExecutionStarted);
      Time fireAtTime=executiveDirector.fireAt(container,expectedCompletionTime);
      if (!fireAtTime.equals(expectedCompletionTime)) {
        throw new IllegalActionException(executiveDirector,""String_Node_Str"" + expectedCompletionTime + ""String_Node_Str""+ fireAtTime);
      }
      if (_eventQueue.isEmpty() || !_preemptExecutingActor()) {
        return null;
      }
    }
  }
  if (_eventQueue.isEmpty()) {
    _setIcon(_getIdleIcon(),false);
    return null;
  }
  PtidesEvent eventFromQueue=_getNextSafeEvent();
  if (eventFromQueue == null) {
    return null;
  }
  Time timeStampOfEventFromQueue=eventFromQueue.timeStamp();
  int microstepOfEventFromQueue=eventFromQueue.microstep();
  _trackLastTagConsumedByActor(eventFromQueue);
  List<PtidesEvent> eventsToProcess=_takeAllSameTagEventsFromQueue(eventFromQueue);
  Actor actorToFire=_getNextActorToFireForTheseEvents(eventsToProcess);
  IOPort ioPort=eventFromQueue.ioPort();
  if (ioPort == null) {
    List<IOPort> inPortList=eventFromQueue.actor().inputPortList();
    if (inPortList.size() > 0) {
      ioPort=inPortList.get(0);
    }
  }
  _saveEventInformation(eventsToProcess);
  Time executionTime=new Time(this,_getExecutionTime(ioPort,actorToFire));
  if (executionTime.compareTo(_zero) == 0) {
    setTag(timeStampOfEventFromQueue,microstepOfEventFromQueue);
    executiveDirector.fireAtCurrentTime((Actor)container);
    return actorToFire;
  }
 else {
    Time expectedCompletionTime=physicalTime.add(executionTime);
    Time fireAtTime=executiveDirector.fireAt(container,expectedCompletionTime);
    if (!fireAtTime.equals(expectedCompletionTime)) {
      throw new IllegalActionException(actorToFire,executiveDirector,""String_Node_Str"" + expectedCompletionTime + ""String_Node_Str""+ fireAtTime);
    }
    if (!_currentlyExecutingStack.isEmpty()) {
      DoubleTimedEvent currentEventList=_currentlyExecutingStack.peek();
      Time elapsedTime=physicalTime.subtract(_physicalTimeExecutionStarted);
      currentEventList.remainingExecutionTime=currentEventList.remainingExecutionTime.subtract(elapsedTime);
      if (currentEventList.remainingExecutionTime.compareTo(_zero) < 0) {
        throw new IllegalActionException(this,_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + _getActorFromEventList((List<PtidesEvent>)currentEventList.contents).getName((NamedObj)container) + ""String_Node_Str""+ physicalTime+ ""String_Node_Str""+ currentEventList.remainingExecutionTime);
      }
    }
    _currentlyExecutingStack.push(new DoubleTimedEvent(timeStampOfEventFromQueue,microstepOfEventFromQueue,eventsToProcess,executionTime));
    _physicalTimeExecutionStarted=physicalTime;
    _setIcon(_getExecutingIcon(actorToFire),false);
    _lastExecutingActor=actorToFire;
    return null;
  }
}","/** 
 * Return the actor to fire in this iteration, or null if no actor should be fired. In this base class, this method first checks whether the top event from the event queue is destined for an actuator. If it is, then we check if physical time has reached the timestamp of the actuation event. If it has, then we fire the actuator. If it has not, then we take the actuator event from the event queue and put it onto the _realTimeEventQueue, and call fireAt() of the executive director. We then check if a real-time event should be processed by looking at the top event of the _realTimeEventQueue. If there is on that should be fired, that actor is returned for firing. If not, we go on and considers two cases, depending whether there is an actor currently executing, as follows: <p> <b>Case 1</b>: If there is no actor currently executing, then this method checks the event queue and returns null if it is empty. If it is not empty, it checks the destination actor of the earliest event on the event queue, and if it has a non-zero execution time, then it pushes it onto the currently executing stack and returns null. Otherwise, if the execution time of the actor is zero, it sets the current model time to the time stamp of that earliest event and returns that actor. <p> <b>Case 2</b>: If there is an actor currently executing, then this method checks whether it has a remaining execution time of zero. If it does, then it returns the currently executing actor. If it does not, then it checks whether the earliest event on the event queue should preempt it (by invoking _preemptExecutingActor()), and if so, checks the destination actor of that event and removes the event from the event queue. If that destination actor has an execution time of zero, then it sets the current model time to the time stamp of that event, and returns that actor. Else if the destination actor has an execution time of bigger than zero, then it calls fireAt() on the enclosing director passing it the time it expects the currently executing actor to finish executing, and returns null. If there is no event on the event queue or that event should not preempt the currently executing actor, then it calls fireAt() on the enclosing director passing it the time it expects the currently executing actor to finish executing, and returns null.
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards, or if the enclosing director does not respect the fireAt call.
 * @see #_preemptExecutingActor()
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  Tag physicalTag=getPhysicalTag();
  Actor container=(Actor)getContainer();
  Director executiveDirector=container.getExecutiveDirector();
  if (!_currentlyExecutingStack.isEmpty()) {
    DoubleTimedEvent currentEventList=(DoubleTimedEvent)_currentlyExecutingStack.peek();
    Time remainingExecutionTime=currentEventList.remainingExecutionTime;
    Time finishTime=_physicalTimeExecutionStarted.add(remainingExecutionTime);
    int comparison=finishTime.compareTo(physicalTag.timestamp);
    if (comparison < 0) {
      throw new IllegalActionException(this,_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),""String_Node_Str"");
    }
 else     if (comparison == 0) {
      setTag(currentEventList.timeStamp,currentEventList.microstep);
      _currentlyExecutingStack.pop();
      _physicalTimeExecutionStarted=physicalTag.timestamp;
      if (_debugging) {
        _debug(""String_Node_Str"" + _getActorFromEventList((List<PtidesEvent>)currentEventList.contents).getName(getContainer()) + ""String_Node_Str""+ physicalTag.timestamp);
      }
      _setIcon(_getIdleIcon(),false);
      _clearHighlight(_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),false);
      _lastExecutingActor=null;
      executiveDirector.fireAtCurrentTime((Actor)container);
      return _getActorFromEventList((List<PtidesEvent>)currentEventList.contents);
    }
 else {
      Time nextEventOnStackFireTime=_currentlyExecutingStack.peek().remainingExecutionTime;
      Time expectedCompletionTime=nextEventOnStackFireTime.add(_physicalTimeExecutionStarted);
      Time fireAtTime=executiveDirector.fireAt(container,expectedCompletionTime);
      if (!fireAtTime.equals(expectedCompletionTime)) {
        throw new IllegalActionException(executiveDirector,""String_Node_Str"" + expectedCompletionTime + ""String_Node_Str""+ fireAtTime);
      }
      if (_eventQueue.isEmpty() || !_preemptExecutingActor()) {
        return null;
      }
    }
  }
  if (_eventQueue.isEmpty()) {
    _setIcon(_getIdleIcon(),false);
    return null;
  }
  PtidesEvent eventFromQueue=_getNextSafeEvent();
  if (eventFromQueue == null) {
    return null;
  }
  Time timeStampOfEventFromQueue=eventFromQueue.timeStamp();
  int microstepOfEventFromQueue=eventFromQueue.microstep();
  _trackLastTagConsumedByActor(eventFromQueue);
  List<PtidesEvent> eventsToProcess=_takeAllSameTagEventsFromQueue(eventFromQueue);
  Actor actorToFire=_getNextActorToFireForTheseEvents(eventsToProcess);
  IOPort ioPort=eventFromQueue.ioPort();
  if (ioPort == null) {
    List<IOPort> inPortList=eventFromQueue.actor().inputPortList();
    if (inPortList.size() > 0) {
      ioPort=inPortList.get(0);
    }
  }
  _saveEventInformation(eventsToProcess);
  Time executionTime=new Time(this,_getExecutionTime(ioPort,actorToFire));
  if (executionTime.compareTo(_zero) == 0) {
    setTag(timeStampOfEventFromQueue,microstepOfEventFromQueue);
    executiveDirector.fireAtCurrentTime((Actor)container);
    return actorToFire;
  }
 else {
    Time expectedCompletionTime=physicalTag.timestamp.add(executionTime);
    Time fireAtTime=executiveDirector.fireAt(container,expectedCompletionTime);
    if (!fireAtTime.equals(expectedCompletionTime)) {
      throw new IllegalActionException(actorToFire,executiveDirector,""String_Node_Str"" + expectedCompletionTime + ""String_Node_Str""+ fireAtTime);
    }
    if (!_currentlyExecutingStack.isEmpty()) {
      DoubleTimedEvent currentEventList=_currentlyExecutingStack.peek();
      Time elapsedTime=physicalTag.timestamp.subtract(_physicalTimeExecutionStarted);
      currentEventList.remainingExecutionTime=currentEventList.remainingExecutionTime.subtract(elapsedTime);
      if (currentEventList.remainingExecutionTime.compareTo(_zero) < 0) {
        throw new IllegalActionException(this,_getActorFromEventList((List<PtidesEvent>)currentEventList.contents),""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + _getActorFromEventList((List<PtidesEvent>)currentEventList.contents).getName((NamedObj)container) + ""String_Node_Str""+ physicalTag.timestamp+ ""String_Node_Str""+ currentEventList.remainingExecutionTime);
      }
    }
    _currentlyExecutingStack.push(new DoubleTimedEvent(timeStampOfEventFromQueue,microstepOfEventFromQueue,eventsToProcess,executionTime));
    _physicalTimeExecutionStarted=physicalTag.timestamp;
    _setIcon(_getExecutingIcon(actorToFire),false);
    _lastExecutingActor=actorToFire;
    return null;
  }
}"
73813,"/** 
 * For all events in the sensorEventQueue, transfer input events that are ready. For all events that are currently sitting at the input port, if the realTimeDelay is 0.0, then transfer them into the platform, otherwise move them into the sensorEventQueue and call fireAt() of the executive director. In either case, if the input port is a networkPort, we make sure the timestamp of the data token transmitted is set to the timestamp of the local event associated with this token.
 * @exception IllegalActionException If the port is not an opaqueinput port.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 */
protected boolean _transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferInputs(port);
  }
  boolean result=false;
  Time physicalTime=getPhysicalTime();
  while (true) {
    if (_realTimeInputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent realTimeEvent=(RealTimeEvent)_realTimeInputEventQueue.peek();
    int compare=realTimeEvent.deliveryTime.compareTo(physicalTime);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      Parameter parameter=(Parameter)((NamedObj)realTimeEvent.port).getAttribute(""String_Node_Str"");
      double realTimeDelay=0.0;
      if (parameter != null) {
        realTimeDelay=((DoubleToken)parameter.getToken()).doubleValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"");
      }
      Time lastModelTime=_currentTime;
      if (_isNetworkPort(realTimeEvent.port)) {
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
      }
 else {
        int lastMicrostep=_microstep;
        setTag(realTimeEvent.deliveryTime.subtract(realTimeDelay),0);
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
        setTag(lastModelTime,lastMicrostep);
      }
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + realTimeEvent.port.getName());
      }
      result=true;
    }
 else {
      throw new IllegalActionException(realTimeEvent.port,""String_Node_Str"" + ""String_Node_Str"" + realTimeEvent.deliveryTime + ""String_Node_Str""+ physicalTime);
    }
  }
  if (_isNetworkPort(port)) {
    while (true) {
      if (!super._transferInputs(port)) {
        break;
      }
 else {
        result=true;
      }
    }
  }
  Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
  double realTimeDelay=0.0;
  if (parameter != null) {
    realTimeDelay=((DoubleToken)parameter.getToken()).doubleValue();
  }
  if (realTimeDelay == 0.0) {
    Time lastModelTime=_currentTime;
    setTag(physicalTime,0);
    result=result || super._transferInputs(port);
    setTag(lastModelTime,0);
  }
 else {
    for (int i=0; i < port.getWidth(); i++) {
      try {
        if (i < port.getWidthInside()) {
          if (port.hasToken(i)) {
            Token t=port.get(i);
            Time waitUntilTime=physicalTime.add(realTimeDelay);
            RealTimeEvent realTimeEvent=new RealTimeEvent(port,i,t,waitUntilTime);
            _realTimeInputEventQueue.add(realTimeEvent);
            result=true;
            Actor container=(Actor)getContainer();
            container.getExecutiveDirector().fireAt((Actor)container,waitUntilTime);
          }
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
  }
  return result;
}","/** 
 * For all events in the sensorEventQueue, transfer input events that are ready. For all events that are currently sitting at the input port, if the realTimeDelay is 0.0, then transfer them into the platform, otherwise move them into the sensorEventQueue and call fireAt() of the executive director. In either case, if the input port is a networkPort, we make sure the timestamp of the data token transmitted is set to the timestamp of the local event associated with this token.
 * @exception IllegalActionException If the port is not an opaqueinput port.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 */
protected boolean _transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferInputs(port);
  }
  boolean result=false;
  Tag physicalTag=getPhysicalTag();
  while (true) {
    if (_realTimeInputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent realTimeEvent=(RealTimeEvent)_realTimeInputEventQueue.peek();
    int compare=realTimeEvent.deliveryTag.compareTo(physicalTag);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      Parameter parameter=(Parameter)((NamedObj)realTimeEvent.port).getAttribute(""String_Node_Str"");
      double realTimeDelay=0.0;
      if (parameter != null) {
        realTimeDelay=((DoubleToken)parameter.getToken()).doubleValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"");
      }
      Time lastModelTime=_currentTime;
      if (_isNetworkPort(realTimeEvent.port)) {
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
      }
 else {
        int lastMicrostep=_microstep;
        setTag(realTimeEvent.deliveryTag.timestamp.subtract(realTimeDelay),realTimeEvent.deliveryTag.microstep);
        _realTimeInputEventQueue.poll();
        realTimeEvent.port.sendInside(realTimeEvent.channel,realTimeEvent.token);
        setTag(lastModelTime,lastMicrostep);
      }
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + realTimeEvent.port.getName());
      }
      result=true;
    }
 else {
      throw new IllegalActionException(realTimeEvent.port,""String_Node_Str"" + ""String_Node_Str"" + realTimeEvent.deliveryTag.timestamp + ""String_Node_Str""+ realTimeEvent.deliveryTag.microstep+ ""String_Node_Str""+ physicalTag.timestamp+ ""String_Node_Str""+ physicalTag.microstep);
    }
  }
  if (_isNetworkPort(port)) {
    while (true) {
      if (!super._transferInputs(port)) {
        break;
      }
 else {
        result=true;
      }
    }
  }
  Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
  double realTimeDelay=0.0;
  if (parameter != null) {
    realTimeDelay=((DoubleToken)parameter.getToken()).doubleValue();
  }
  if (realTimeDelay == 0.0) {
    Time lastModelTime=_currentTime;
    int lastMicrostep=_microstep;
    setTag(physicalTag.timestamp,physicalTag.microstep);
    result=result || super._transferInputs(port);
    setTag(lastModelTime,lastMicrostep);
  }
 else {
    for (int i=0; i < port.getWidth(); i++) {
      try {
        if (i < port.getWidthInside()) {
          if (port.hasToken(i)) {
            Token t=port.get(i);
            Time waitUntilTime=physicalTag.timestamp.add(realTimeDelay);
            RealTimeEvent realTimeEvent=new RealTimeEvent(port,i,t,new Tag(waitUntilTime,physicalTag.microstep));
            _realTimeInputEventQueue.add(realTimeEvent);
            result=true;
            Actor container=(Actor)getContainer();
            container.getExecutiveDirector().fireAt((Actor)container,waitUntilTime);
          }
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
  }
  return result;
}"
73814,"/** 
 * Overwrite the _transferOutputs() function. First, for tokens that are stored in the actuator event queue and send them to the outside of the platform if physical time has arrived. The second step is to check if this port is a networkedOutput port, if it is, transfer data tokens immediately to the outside by calling super._transferOutputs(port). Finally, we check for current model time, if the current model time is equal to the physical time, we can send the tokens to the outside. Else if current model time has exceeded the physical time, and we still have tokens to transfer, then we have missed the deadline. Else if current model time has not arrived at the physical time, then we put the token along with the port and channel into the actuator event queue, and call fireAt of the executive director so we could send it at a later physical time.
 */
protected boolean _transferOutputs(IOPort port) throws IllegalActionException {
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferOutputs(port);
  }
  boolean result=false;
  Time physicalTime=getPhysicalTime();
  int compare=0;
  while (true) {
    if (_realTimeOutputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent tokenEvent=(RealTimeEvent)_realTimeOutputEventQueue.peek();
    compare=tokenEvent.deliveryTime.compareTo(physicalTime);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      if (_isNetworkPort(tokenEvent.port)) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
      _realTimeOutputEventQueue.poll();
      tokenEvent.port.send(tokenEvent.channel,tokenEvent.token);
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + tokenEvent.token + ""String_Node_Str""+ tokenEvent.port.getName());
      }
      result=true;
    }
 else     if (compare < 0) {
      throw new IllegalActionException(tokenEvent.port,""String_Node_Str"" + tokenEvent.deliveryTime + ""String_Node_Str""+ physicalTime);
    }
  }
  if (_isNetworkPort(port) || _transferImmediately(port)) {
    while (true) {
      if (!super._transferOutputs(port)) {
        break;
      }
 else {
        result=true;
      }
    }
  }
  compare=_currentTime.compareTo(physicalTime);
  if (compare == 0) {
    result=result || super._transferOutputs(port);
  }
 else   if (compare < 0) {
    for (int i=0; i < port.getWidthInside(); i++) {
      if (port.hasTokenInside(i)) {
        throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + _currentTime + ""String_Node_Str""+ physicalTime);
      }
    }
  }
 else {
    for (int i=0; i < port.getWidthInside(); i++) {
      try {
        if (port.hasTokenInside(i)) {
          Token t=port.getInside(i);
          RealTimeEvent tokenEvent=new RealTimeEvent(port,i,t,_currentTime);
          _realTimeOutputEventQueue.add(tokenEvent);
          Actor container=(Actor)getContainer();
          container.getExecutiveDirector().fireAt((Actor)container,_currentTime);
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
  }
  return result;
}","/** 
 * Overwrite the _transferOutputs() function. First, for tokens that are stored in the actuator event queue and send them to the outside of the platform if physical time has arrived. The second step is to check if this port is a networkedOutput port, if it is, transfer data tokens immediately to the outside by calling super._transferOutputs(port). Finally, we check for current model time, if the current model time is equal to the physical time, we can send the tokens to the outside. Else if current model time has exceeded the physical time, and we still have tokens to transfer, then we have missed the deadline. Else if current model time has not arrived at the physical time, then we put the token along with the port and channel into the actuator event queue, and call fireAt of the executive director so we could send it at a later physical time.
 */
protected boolean _transferOutputs(IOPort port) throws IllegalActionException {
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferOutputs(port);
  }
  boolean result=false;
  Tag physicalTag=getPhysicalTag();
  int compare=0;
  while (true) {
    if (_realTimeOutputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent tokenEvent=(RealTimeEvent)_realTimeOutputEventQueue.peek();
    compare=tokenEvent.deliveryTag.compareTo(physicalTag);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      if (_isNetworkPort(tokenEvent.port)) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
      _realTimeOutputEventQueue.poll();
      tokenEvent.port.send(tokenEvent.channel,tokenEvent.token);
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + tokenEvent.token + ""String_Node_Str""+ tokenEvent.port.getName());
      }
      result=true;
    }
 else     if (compare < 0) {
      throw new IllegalActionException(tokenEvent.port,""String_Node_Str"" + tokenEvent.deliveryTag.timestamp + ""String_Node_Str""+ tokenEvent.deliveryTag.microstep+ ""String_Node_Str""+ physicalTag.timestamp);
    }
  }
  if (_isNetworkPort(port) || _transferImmediately(port)) {
    while (true) {
      if (!super._transferOutputs(port)) {
        break;
      }
 else {
        result=true;
      }
    }
  }
  compare=_currentTime.compareTo(physicalTag.timestamp);
  if (compare == 0) {
    result=result || super._transferOutputs(port);
  }
 else   if (compare < 0) {
    for (int i=0; i < port.getWidthInside(); i++) {
      if (port.hasTokenInside(i)) {
        throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + _currentTime + ""String_Node_Str""+ physicalTag.timestamp);
      }
    }
  }
 else {
    for (int i=0; i < port.getWidthInside(); i++) {
      try {
        if (port.hasTokenInside(i)) {
          Token t=port.getInside(i);
          RealTimeEvent tokenEvent=new RealTimeEvent(port,i,t,new Tag(_currentTime,_microstep));
          _realTimeOutputEventQueue.add(tokenEvent);
          Actor container=(Actor)getContainer();
          container.getExecutiveDirector().fireAt((Actor)container,_currentTime);
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
  }
  return result;
}"
73815,"/** 
 * Construct a structure that holds a real-time event. This event saves the token to be transmitted, the port and channel this token should be deliverd to, and the time this token should be delivered at.
 * @param port The destination port.
 * @param channel The destination channel.
 * @param token The token to be delivered.
 * @param timestamp The time of delivery of this token.
 */
public RealTimeEvent(IOPort port,int channel,Token token,Time timestamp){
  this.port=port;
  this.channel=channel;
  this.token=token;
  this.deliveryTime=timestamp;
}","/** 
 * Construct a structure that holds a real-time event. This event saves the token to be transmitted, the port and channel this token should be deliverd to, and the time this token should be delivered at.
 * @param port The destination port.
 * @param channel The destination channel.
 * @param token The token to be delivered.
 * @param timestamp The time of delivery of this token.
 */
public RealTimeEvent(IOPort port,int channel,Token token,Tag tag){
  this.port=port;
  this.channel=channel;
  this.token=token;
  this.deliveryTag=tag;
}"
73816,"/** 
 * Return whether we want to preempt the currently executing actor and instead execute the earliest event on the event queue.
 * @return whether we want to preempt the executing event.
 * @exception IllegalActionException
 */
protected boolean _preemptExecutingActor() throws IllegalActionException {
  PtidesEvent event=(PtidesEvent)_eventQueue.get();
  if (event.isPureEvent()) {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + event.actor());
    }
    return true;
  }
  Time absNextDeadline=_getAbsoluteDeadline(event);
  DoubleTimedEvent doubleTimedEvent=_currentlyExecutingStack.peek();
  List eventList=(List<PtidesEvent>)(doubleTimedEvent.contents);
  for (int i=0; i < eventList.size(); i++) {
    Time absExecutingDeadline=_getAbsoluteDeadline((PtidesEvent)eventList.get(i));
    if (absExecutingDeadline.compareTo(absNextDeadline) <= 0) {
      return false;
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + ""String_Node_Str"" + ((PtidesEvent)eventList.get(0)).actor() + ""String_Node_Str""+ event.actor()+ ""String_Node_Str""+ getPhysicalTime());
  }
  return true;
}","/** 
 * Return whether we want to preempt the currently executing actor and instead execute the earliest event on the event queue.
 * @return whether we want to preempt the executing event.
 * @exception IllegalActionException
 */
protected boolean _preemptExecutingActor() throws IllegalActionException {
  PtidesEvent event=(PtidesEvent)_eventQueue.get();
  if (event.isPureEvent()) {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + event.actor());
    }
    return true;
  }
  Time absNextDeadline=_getAbsoluteDeadline(event);
  DoubleTimedEvent doubleTimedEvent=_currentlyExecutingStack.peek();
  List eventList=(List<PtidesEvent>)(doubleTimedEvent.contents);
  for (int i=0; i < eventList.size(); i++) {
    Time absExecutingDeadline=_getAbsoluteDeadline((PtidesEvent)eventList.get(i));
    if (absExecutingDeadline.compareTo(absNextDeadline) <= 0) {
      return false;
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + ""String_Node_Str"" + ((PtidesEvent)eventList.get(0)).actor() + ""String_Node_Str""+ event.actor()+ ""String_Node_Str""+ getPhysicalTag().timestamp+ ""String_Node_Str""+ getPhysicalTag().microstep);
  }
  return true;
}"
73817,"/** 
 * Return whether we want to preempt the currently executing actor and instead execute another event from the event queue. This method iterate through all events in the event queue, and finds the event in the queue that is both safe, and also has the smallest deadline. This event is then stored in _eventToProcess, and returned in _getNextSafeEvent(). If there are several safe events with the smallest deadline, then the event of smallest tag + depth is stored in _eventToProcess.
 * @return whether we want to preempt the executing event.
 * @exception IllegalActionException
 * @see #_getNextSafeEvent()
 */
protected boolean _preemptExecutingActor() throws IllegalActionException {
  if (!_getSmallestDeadlineSafeEventFromQueue()) {
    return false;
  }
  Time smallestStackDeadline=new Time(this,Double.POSITIVE_INFINITY);
  DoubleTimedEvent doubleTimedEvent=_currentlyExecutingStack.peek();
  List eventList=(List<PtidesEvent>)(doubleTimedEvent.contents);
  PtidesEvent executingEvent=(PtidesEvent)eventList.get(0);
  for (int i=0; i < eventList.size(); i++) {
    Time absExecutingDeadline=_getAbsoluteDeadline(((PtidesEvent)eventList.get(i)));
    if (absExecutingDeadline.compareTo(smallestStackDeadline) <= 0) {
      smallestStackDeadline=absExecutingDeadline;
    }
  }
  Time smallestQueueDeadline=_getAbsoluteDeadline(_eventToProcess);
  if (smallestQueueDeadline.compareTo(smallestStackDeadline) > 0) {
    _eventToProcess=null;
  }
 else   if (smallestQueueDeadline.compareTo(smallestStackDeadline) == 0) {
    if (_eventToProcess.compareTo(executingEvent) >= 0) {
      _eventToProcess=null;
    }
  }
  if (_eventToProcess == null) {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + executingEvent.actor() + ""String_Node_Str""+ getPhysicalTime());
    }
    return false;
  }
 else {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + executingEvent.actor() + ""String_Node_Str""+ _eventToProcess.actor()+ ""String_Node_Str""+ getPhysicalTime());
    }
    return true;
  }
}","/** 
 * Return whether we want to preempt the currently executing actor and instead execute another event from the event queue. This method iterate through all events in the event queue, and finds the event in the queue that is both safe, and also has the smallest deadline. This event is then stored in _eventToProcess, and returned in _getNextSafeEvent(). If there are several safe events with the smallest deadline, then the event of smallest tag + depth is stored in _eventToProcess.
 * @return whether we want to preempt the executing event.
 * @exception IllegalActionException
 * @see #_getNextSafeEvent()
 */
protected boolean _preemptExecutingActor() throws IllegalActionException {
  if (!_getSmallestDeadlineSafeEventFromQueue()) {
    return false;
  }
  Time smallestStackDeadline=new Time(this,Double.POSITIVE_INFINITY);
  DoubleTimedEvent doubleTimedEvent=_currentlyExecutingStack.peek();
  List eventList=(List<PtidesEvent>)(doubleTimedEvent.contents);
  PtidesEvent executingEvent=(PtidesEvent)eventList.get(0);
  for (int i=0; i < eventList.size(); i++) {
    Time absExecutingDeadline=_getAbsoluteDeadline(((PtidesEvent)eventList.get(i)));
    if (absExecutingDeadline.compareTo(smallestStackDeadline) <= 0) {
      smallestStackDeadline=absExecutingDeadline;
    }
  }
  Time smallestQueueDeadline=_getAbsoluteDeadline(_eventToProcess);
  if (smallestQueueDeadline.compareTo(smallestStackDeadline) > 0) {
    _eventToProcess=null;
  }
 else   if (smallestQueueDeadline.compareTo(smallestStackDeadline) == 0) {
    if (_eventToProcess.compareTo(executingEvent) >= 0) {
      _eventToProcess=null;
    }
  }
  if (_eventToProcess == null) {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + executingEvent.actor() + ""String_Node_Str""+ getPhysicalTag().timestamp+ ""String_Node_Str""+ getPhysicalTag().microstep);
    }
    return false;
  }
 else {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + executingEvent.actor() + ""String_Node_Str""+ _eventToProcess.actor()+ ""String_Node_Str""+ getPhysicalTag().timestamp+ ""String_Node_Str""+ getPhysicalTag().microstep);
    }
    return true;
  }
}"
73818,"/** 
 * Construct a Tag.
 * @param timestamp The timestamp.
 * @param microstep The microstep.
 */
public Tag(Time timestamp,int microstep){
  this.timestamp=timestamp;
  this.microstep=microstep;
}","/** 
 * Construct an empty Tag.
 */
public Tag(){
}"
73819,"/** 
 * Register a ""published port"" coming from a publisher. The name is the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the same name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param name The name is being used in the matching processto match publisher and subscriber.
 * @param port The published port. 
 * @exception NameDuplicationException If the published portis already registered.
 * @exception IllegalActionException If the published port can'tbe added.
 */
public void registerPublisherPort(String name,IOPort port) throws NameDuplicationException, IllegalActionException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).registerPublisherPort(name,port);
  }
 else {
    if (_publishedPorts == null) {
      _publishedPorts=new HashMap<String,List<IOPort>>();
    }
    List<IOPort> portList=_publishedPorts.get(name);
    if (portList == null) {
      portList=new LinkedList<IOPort>();
      _publishedPorts.put(name,portList);
    }
    portList.add(port);
    boolean exportPorts=false;
    if (exportPorts) {
      String portName=""String_Node_Str"" + name;
      IOPort publisherPort=(IOPort)getPort(portName);
      if (publisherPort == null) {
        publisherPort=(IOPort)newPort(portName);
      }
      publisherPort.setPersistent(false);
      publisherPort.setOutput(true);
      linkToPublishedPort(name,publisherPort);
      if (container instanceof CompositeActor) {
        ((CompositeActor)container).registerPublisherPort(name,publisherPort);
      }
    }
  }
}","/** 
 * Register a ""published port"" coming from a publisher. The name is the name being used in the matching process to match publisher and subscriber. A subscriber interested in the output of this publisher uses the same name. This registration process of publisher typically happens before the model is preinitialized, for example when opening the model. The subscribers will look for publishers during the preinitialization phase.
 * @param name The name is being used in the matching processto match publisher and subscriber.
 * @param port The published port. 
 * @exception NameDuplicationException If the published portis already registered.
 * @exception IllegalActionException If the published port can'tbe added.
 */
public void registerPublisherPort(String name,IOPort port) throws NameDuplicationException, IllegalActionException {
  NamedObj container=getContainer();
  if (!isOpaque() && container instanceof CompositeActor && !((CompositeActor)container).isClassDefinition()) {
    ((CompositeActor)container).registerPublisherPort(name,port);
  }
 else {
    if (_publishedPorts == null) {
      _publishedPorts=new HashMap<String,List<IOPort>>();
    }
    List<IOPort> portList=_publishedPorts.get(name);
    if (portList == null) {
      portList=new LinkedList<IOPort>();
      _publishedPorts.put(name,portList);
    }
    portList.add(port);
    boolean exportPorts=false;
    if (exportPorts) {
      String portName=""String_Node_Str"" + StringUtilities.sanitizeName(name);
      IOPort publisherPort=(IOPort)getPort(portName);
      if (publisherPort == null) {
        publisherPort=(IOPort)newPort(portName);
      }
      publisherPort.setPersistent(false);
      publisherPort.setOutput(true);
      publisherPort.setMultiport(true);
      linkToPublishedPort(name,publisherPort);
      if (container instanceof CompositeActor) {
        ((CompositeActor)container).registerPublisherPort(name,publisherPort);
      }
    }
  }
}"
73820,"/** 
 * Generate code for replacing the get() macro. This delegates to the receiver adapter for the specified channel and asks it to generate the get code.
 * @param channel The channel for which to generate the get code.
 * @param offset The offset in the array representation of the port.
 * @return The code that gets data from the specified channel.
 * @exception IllegalActionException If the receiver adapter is not found or it encounters an error while generating the get code.
 */
public String generateGetCode(String channel,String offset) throws IllegalActionException {
  Receiver[][] receivers=getReceiverAdapters();
  int channelIndex=Integer.parseInt(channel);
  if (receivers.length != 0) {
    if (receivers[channelIndex].length > 1) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channelIndex].length > 0) {
      return receivers[channelIndex][0].generateGetCode(offset);
    }
  }
  Type type=((TypedIOPort)getComponent()).getType();
  if (((TypedIOPort)getComponent()) instanceof ParameterPort) {
    if (type == BaseType.STRING) {
      return ""String_Node_Str"";
    }
  }
  String typeString=getCodeGenerator().codeGenType(type);
  return ""String_Node_Str"" + getCodeGenerator().codeGenType(BaseType.INT) + ""String_Node_Str""+ typeString+ ""String_Node_Str"";
}","/** 
 * Generate code for replacing the get() macro. This delegates to the receiver adapter for the specified channel and asks it to generate the get code.
 * @param channel The channel for which to generate the get code.
 * @param offset The offset in the array representation of the port.
 * @return The code that gets data from the specified channel.
 * @exception IllegalActionException If the receiver adapter is not found or it encounters an error while generating the get code.
 */
public String generateGetCode(String channel,String offset) throws IllegalActionException {
  Receiver[][] receivers=getReceiverAdapters();
  int channelIndex=Integer.parseInt(channel);
  if (receivers.length != 0) {
    if (receivers[channelIndex].length > 1) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channelIndex].length > 0) {
      return receivers[channelIndex][0].generateGetCode(offset);
    }
  }
  Type type=((TypedIOPort)getComponent()).getType();
  if (((TypedIOPort)getComponent()) instanceof ParameterPort) {
    return ((ParameterPort)getComponent()).getParameter().getValueAsString();
  }
  String typeString=getCodeGenerator().codeGenType(type);
  return ""String_Node_Str"" + getCodeGenerator().codeGenType(BaseType.INT) + ""String_Node_Str""+ typeString+ ""String_Node_Str"";
}"
73821,"/** 
 * Generate code to check if the receiver has a token.    This delegates to the receiver adapter for the specified channel and asks it to generate the hasToken code.
 * @param channel The channel for which to generate the hasToken code.
 * @param offset The offset in the array representation of the port.
 * @return The code that checks whether there is data in the specified channel.
 * @exception IllegalActionException If the receiver adapter isnot found or it encounters an error while generating the hasToken code.
 */
public String generateHasTokenCode(String channel,String offset) throws IllegalActionException {
  Receiver[][] receivers=getReceiverAdapters();
  int channelNumber=0;
  channelNumber=Integer.parseInt(channel);
  if (receivers.length != 0) {
    if (receivers[channelNumber].length > 1) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channelNumber].length > 0) {
      return receivers[channelNumber][0].generateHasTokenCode(offset);
    }
  }
  return ""String_Node_Str"";
}","/** 
 * Generate code to check if the receiver has a token. This delegates to the receiver adapter for the specified channel and asks it to generate the hasToken code.
 * @param channel The channel for which to generate the hasToken code.
 * @param offset The offset in the array representation of the port.
 * @return The code that checks whether there is data in the specifiedchannel.
 * @exception IllegalActionException If the receiver adapter is not found or it encounters an error while generating the hasToken code.
 */
public String generateHasTokenCode(String channel,String offset) throws IllegalActionException {
  Receiver[][] receivers=getReceiverAdapters();
  int channelNumber=0;
  channelNumber=Integer.parseInt(channel);
  if (receivers.length != 0) {
    if (receivers[channelNumber].length > 1) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channelNumber].length > 0) {
      return receivers[channelNumber][0].generateHasTokenCode(offset);
    }
  }
  return ""String_Node_Str"";
}"
73822,"/** 
 * Get the adapters for the remote receivers connected to this port.
 * @return The adapters.
 * @exception IllegalActionException Thrown if {@link #getAdapter(Object)}throws it.
 */
public Receiver[][] getRemoteReceiverAdapters() throws IllegalActionException {
  ptolemy.actor.IOPort port=(ptolemy.actor.IOPort)getComponent();
  ptolemy.actor.Receiver[][] farReceivers=port.getRemoteReceivers();
  Receiver[][] receiverAdapters=new Receiver[farReceivers.length][];
  for (int i=0; i < farReceivers.length; i++) {
    if (farReceivers[i] != null) {
      receiverAdapters[i]=new Receiver[farReceivers[i].length];
      for (int j=0; j < farReceivers[i].length; j++) {
        receiverAdapters[i][j]=(Receiver)getAdapter(farReceivers[i][j]);
      }
    }
  }
  return receiverAdapters;
}","/** 
 * Get the adapters for the remote receivers connected to this port.
 * @return The adapters.
 * @exception IllegalActionException Thrown if  {@link #getAdapter(Object)} throws it.
 */
public Receiver[][] getRemoteReceiverAdapters() throws IllegalActionException {
  ptolemy.actor.IOPort port=(ptolemy.actor.IOPort)getComponent();
  ptolemy.actor.Receiver[][] farReceivers=port.getRemoteReceivers();
  Receiver[][] receiverAdapters=new Receiver[farReceivers.length][];
  for (int i=0; i < farReceivers.length; i++) {
    if (farReceivers[i] != null) {
      receiverAdapters[i]=new Receiver[farReceivers[i].length];
      for (int j=0; j < farReceivers[i].length; j++) {
        receiverAdapters[i][j]=(Receiver)getAdapter(farReceivers[i][j]);
      }
    }
  }
  return receiverAdapters;
}"
73823,"/** 
 * Generate code for replacing the get() macro. This delegates to the receiver adapter for the specified channel and asks it to generate the get code.
 * @param channel The channel for which to generate the get code.
 * @param offset The offset in the array representation of the port.
 * @return The code that gets data from the specified channel.
 * @exception IllegalActionException If the receiver adapter isnot found or it encounters an error while generating the get code.
 */
public String generateGetCode(String channel,String offset) throws IllegalActionException {
  Receiver[][] receivers=getReceiverAdapters();
  int channelIndex=Integer.parseInt(channel);
  if (receivers.length != 0) {
    if (receivers[channelIndex].length > 1) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channelIndex].length > 0) {
      return receivers[channelIndex][0].generateGetCode(offset);
    }
  }
  Type type=((TypedIOPort)getComponent()).getType();
  String typeString=getCodeGenerator().codeGenType(type);
  return ""String_Node_Str"" + getCodeGenerator().codeGenType(BaseType.INT) + ""String_Node_Str""+ typeString+ ""String_Node_Str"";
}","/** 
 * Generate code for replacing the get() macro. This delegates to the receiver adapter for the specified channel and asks it to generate the get code.
 * @param channel The channel for which to generate the get code.
 * @param offset The offset in the array representation of the port.
 * @return The code that gets data from the specified channel.
 * @exception IllegalActionException If the receiver adapter is not found or it encounters an error while generating the get code.
 */
public String generateGetCode(String channel,String offset) throws IllegalActionException {
  Receiver[][] receivers=getReceiverAdapters();
  int channelIndex=Integer.parseInt(channel);
  if (receivers.length != 0) {
    if (receivers[channelIndex].length > 1) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channelIndex].length > 0) {
      return receivers[channelIndex][0].generateGetCode(offset);
    }
  }
  Type type=((TypedIOPort)getComponent()).getType();
  if (((TypedIOPort)getComponent()) instanceof ParameterPort) {
    if (type == BaseType.STRING) {
      return ""String_Node_Str"";
    }
  }
  String typeString=getCodeGenerator().codeGenType(type);
  return ""String_Node_Str"" + getCodeGenerator().codeGenType(BaseType.INT) + ""String_Node_Str""+ typeString+ ""String_Node_Str"";
}"
73824,"/** 
 * Get the adapters for receiver contained in this port.
 * @return The adapters.
 * @exception IllegalActionException Thrown if {@link #getAdapter(Object)}throws it.
 */
public Receiver[][] getReceiverAdapters() throws IllegalActionException {
  ptolemy.actor.IOPort port=(ptolemy.actor.IOPort)getComponent();
  ptolemy.actor.Receiver[][] receivers=port.getReceivers();
  Receiver[][] receiverAdapters=new Receiver[receivers.length][];
  for (int i=0; i < receivers.length; i++) {
    receiverAdapters[i]=new Receiver[receivers[i].length];
    for (int j=0; j < receivers[i].length; j++) {
      receiverAdapters[i][j]=(Receiver)getAdapter(receivers[i][j]);
    }
  }
  return receiverAdapters;
}","/** 
 * Get the adapters for receiver contained in this port.
 * @return The adapters.
 * @exception IllegalActionException Thrown if  {@link #getAdapter(Object)} throws it.
 */
public Receiver[][] getReceiverAdapters() throws IllegalActionException {
  ptolemy.actor.IOPort port=(ptolemy.actor.IOPort)getComponent();
  ptolemy.actor.Receiver[][] receivers=port.getReceivers();
  Receiver[][] receiverAdapters=new Receiver[receivers.length][];
  for (int i=0; i < receivers.length; i++) {
    receiverAdapters[i]=new Receiver[receivers[i].length];
    for (int j=0; j < receivers[i].length; j++) {
      receiverAdapters[i][j]=(Receiver)getAdapter(receivers[i][j]);
    }
  }
  return receiverAdapters;
}"
73825,"/** 
 * Generate code for replacing the send() macro. This delegates to the receiver adapter for the specified channel and asks it to generate the send code.
 * @param channel The channel for which to generate the send code.
 * @param offset The offset in the array representation of the port.
 * @param dataToken The token to be sent.
 * @return The code that sends data to the specified channel.
 * @exception IllegalActionException If the receiver adapter isnot found or it encounters an error while generating the send code.
 */
public String generatePutCode(String channel,String offset,String dataToken) throws IllegalActionException {
  Receiver[][] remoteReceivers=getRemoteReceiverAdapters();
  int channelIndex=Integer.parseInt(channel);
  if ((remoteReceivers == null) || (remoteReceivers.length <= channelIndex) || (remoteReceivers[channelIndex] == null)) {
    return ""String_Node_Str"";
  }
  StringBuffer code=new StringBuffer();
  for (int i=0; i < remoteReceivers[channelIndex].length; i++) {
    code.append(remoteReceivers[channelIndex][i].generatePutCode((ptolemy.actor.IOPort)this.getComponent(),offset,dataToken));
  }
  return code.toString();
}","/** 
 * Generate code for replacing the send() macro. This delegates to the receiver adapter for the specified channel and asks it to generate the send code.
 * @param channel The channel for which to generate the send code.
 * @param offset The offset in the array representation of the port.
 * @param dataToken The token to be sent.
 * @return The code that sends data to the specified channel.
 * @exception IllegalActionException If the receiver adapter is not found or it encounters an error while generating the send code.
 */
public String generatePutCode(String channel,String offset,String dataToken) throws IllegalActionException {
  Receiver[][] remoteReceivers=getRemoteReceiverAdapters();
  int channelIndex=Integer.parseInt(channel);
  if ((remoteReceivers == null) || (remoteReceivers.length <= channelIndex) || (remoteReceivers[channelIndex] == null)) {
    return ""String_Node_Str"";
  }
  StringBuffer code=new StringBuffer();
  for (int i=0; i < remoteReceivers[channelIndex].length; i++) {
    code.append(remoteReceivers[channelIndex][i].generatePutCode((ptolemy.actor.IOPort)this.getComponent(),offset,dataToken));
  }
  return code.toString();
}"
73826,"/** 
 * Generate the initialize code for this IOPort. The initialize code is generated by appending the initialize code for each receiver contained by this IOPort.
 * @return The generated initialize code.
 * @exception IllegalActionException If an error occurs whengetting the receiver adapters or generating their initialize code.
 */
public String generateInitializeCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  Receiver[][] receivers=getReceiverAdapters();
  for (int i=0; i < receivers.length; i++) {
    for (int j=0; j < receivers[i].length; j++) {
      code.append(receivers[i][j].generateInitializeCode());
    }
  }
  return code.toString();
}","/** 
 * Generate the initialize code for this IOPort. The initialize code is generated by appending the initialize code for each receiver contained by this IOPort.
 * @return The generated initialize code.
 * @exception IllegalActionException If an error occurs when getting the receiver adapters or generating their initialize code.
 */
public String generateInitializeCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  Receiver[][] receivers=getReceiverAdapters();
  for (int i=0; i < receivers.length; i++) {
    for (int j=0; j < receivers[i].length; j++) {
      code.append(receivers[i][j].generateInitializeCode());
    }
  }
  return code.toString();
}"
73827,"/** 
 * Generate fire code. The method generates code that loops through each input [multi-ports] and combines (add or subtract) them.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.MultiplyDivide actor=(ptolemy.actor.lib.MultiplyDivide)getComponent();
  String outputType=getCodeGenerator().codeGenType(actor.output.getType());
  String multiplyType=getCodeGenerator().codeGenType(actor.multiply.getType());
  String divideType=getCodeGenerator().codeGenType(actor.divide.getType());
  ArrayList args=new ArrayList();
  CodeStream codeStream=getTemplateParser().getCodeStream();
  codeStream.appendCodeBlock(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(outputType);
  args.add(multiplyType);
  for (int i=0; i < actor.multiply.getWidth(); i++) {
    args.set(0,Integer.toString(i));
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
  for (int i=0; i < actor.divide.getWidth(); i++) {
    args.set(0,Integer.toString(i));
    args.set(2,divideType);
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
  codeStream.appendCodeBlock(""String_Node_Str"");
  return processCode(codeStream.toString());
}","/** 
 * Generate fire code. The method generates code that loops through each input [multi-ports] and combines (add or subtract) them.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.MultiplyDivide actor=(ptolemy.actor.lib.MultiplyDivide)getComponent();
  String outputType=getCodeGenerator().codeGenType(actor.output.getType());
  String multiplyType=getCodeGenerator().codeGenType(actor.multiply.getType());
  String divideType=getCodeGenerator().codeGenType(actor.divide.getType());
  boolean divideOnly=!actor.multiply.isOutsideConnected();
  ArrayList<String> args=new ArrayList<String>();
  ArrayList<String> initArgs=new ArrayList<String>();
  if (divideOnly) {
    initArgs.add(divideType);
  }
 else {
    initArgs.add(multiplyType);
    initArgs.add(outputType);
  }
  CodeStream codeStream=getTemplateParser().getCodeStream();
  codeStream.appendCodeBlock(divideOnly ? ""String_Node_Str"" : ""String_Node_Str"",initArgs);
  args.add(""String_Node_Str"");
  args.add(outputType);
  args.add(multiplyType);
  for (int i=1; i < actor.multiply.getWidth(); i++) {
    args.set(0,Integer.toString(i));
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
  for (int i=divideOnly ? 1 : 0; i < actor.divide.getWidth(); i++) {
    args.set(0,Integer.toString(i));
    args.set(2,divideType);
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
  codeStream.appendCodeBlock(""String_Node_Str"");
  return processCode(codeStream.toString());
}"
73828,"/** 
 * Create receivers and invoke the preinitialize() method of the local director. If this actor is not opaque, throw an exception.  This method also resets the protected variable _stopRequested to false, so if a derived class overrides this method, then it should also do that.  This method is read-synchronized on the workspace, so the preinitialize() method of the director need not be, assuming it is only called from here.
 * @exception IllegalActionException If there is no director, or ifthe director's preinitialize() method throws it, or if this actor is not opaque.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  try {
    _generatingCode=true;
    _createCodeGenerator();
    if (_modelChanged()) {
      _generateCode();
    }
    String className=NamedProgramCodeGeneratorAdapter.generateName(this);
    Class<?> classInstance=null;
    URL url=_codeGenerator.codeDirectory.asFile().toURI().toURL();
    URL[] urls=new URL[]{url};
    ClassLoader classLoader=new URLClassLoader(urls);
    try {
      classInstance=classLoader.loadClass(className);
    }
 catch (    ClassNotFoundException ex) {
      _generateCode();
      classInstance=classLoader.loadClass(className);
    }
    _objectWrapper=classInstance.newInstance();
    Method[] methods=classInstance.getMethods();
    Method intializeMethod=null;
    for (int i=0; i < methods.length; i++) {
      String name=methods[i].getName();
      if (name.equals(""String_Node_Str"")) {
        _fireMethod=methods[i];
      }
      if (name.equals(""String_Node_Str"")) {
        intializeMethod=methods[i];
      }
    }
    if (_fireMethod == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (intializeMethod == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    intializeMethod.invoke(_objectWrapper,(Object[])null);
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    recompileThisLevel.setToken(new BooleanToken(false));
    recompileHierarchy.setToken(new BooleanToken(false));
  }
 catch (  Throwable throwable) {
    _objectWrapper=null;
    _fireMethod=null;
    throw new IllegalActionException(this,throwable,""String_Node_Str"");
  }
 finally {
    _generatingCode=false;
  }
}","/** 
 * Create receivers and invoke the preinitialize() method of the local director. If this actor is not opaque, throw an exception.  This method also resets the protected variable _stopRequested to false, so if a derived class overrides this method, then it should also do that.  This method is read-synchronized on the workspace, so the preinitialize() method of the director need not be, assuming it is only called from here.
 * @exception IllegalActionException If there is no director, or ifthe director's preinitialize() method throws it, or if this actor is not opaque.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  try {
    _generatingCode=true;
    _createCodeGenerator();
    if (_modelChanged()) {
      super.preinitialize();
      executeChangeRequests();
      _generateCode();
    }
    String className=NamedProgramCodeGeneratorAdapter.generateName(this);
    Class<?> classInstance=null;
    URL url=_codeGenerator.codeDirectory.asFile().toURI().toURL();
    URL[] urls=new URL[]{url};
    ClassLoader classLoader=new URLClassLoader(urls);
    try {
      classInstance=classLoader.loadClass(className);
    }
 catch (    ClassNotFoundException ex) {
      _generateCode();
      classInstance=classLoader.loadClass(className);
    }
    _objectWrapper=classInstance.newInstance();
    Method[] methods=classInstance.getMethods();
    Method intializeMethod=null;
    for (int i=0; i < methods.length; i++) {
      String name=methods[i].getName();
      if (name.equals(""String_Node_Str"")) {
        _fireMethod=methods[i];
      }
      if (name.equals(""String_Node_Str"")) {
        intializeMethod=methods[i];
      }
    }
    if (_fireMethod == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (intializeMethod == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    intializeMethod.invoke(_objectWrapper,(Object[])null);
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    recompileThisLevel.setToken(new BooleanToken(false));
    recompileHierarchy.setToken(new BooleanToken(false));
  }
 catch (  Throwable throwable) {
    _objectWrapper=null;
    _fireMethod=null;
    throw new IllegalActionException(this,throwable,""String_Node_Str"");
  }
 finally {
    _generatingCode=false;
  }
}"
73829,"/** 
 * Output an Ipl image.
 * @exception IllegalActionException If thrown while writing to the port.   
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    ObjectToken inputToken=(ObjectToken)input.get(0);
    Image inputObject=inputToken.getValue();
    if (!(inputObject instanceof Image)) {
      throw new IllegalActionException(this,""String_Node_Str"" + inputObject.getClass());
    }
    _frame=new IplImage();
    output.send(0,new ObjectToken(_frame));
  }
}","/** 
 * Output an Ipl image.
 * @exception IllegalActionException If thrown while writing to the port.   
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    ObjectToken inputToken=(ObjectToken)input.get(0);
    Image inputObject=(Image)inputToken.getValue();
    if (!(inputObject instanceof Image)) {
      throw new IllegalActionException(this,""String_Node_Str"" + inputObject.getClass());
    }
    _frame=new IplImage();
    output.send(0,new ObjectToken(_frame));
  }
}"
73830,"/** 
 * Create a Kieler KNode for a Ptolemy inner port. That is the graphical representation for a port of a CompositeActor if you see the contents of this CompositeActor. It is represented by a node where the connection may touch the node corresponding to its type (input, output, both) on the right, left or top. For now this results a crude approximation of the node, because the figure of the original Ptolemy port cannot be obtained by the layout target. Hence we cannot ask the port for its original bounds.
 * @param node The Ptolemy inner port.
 * @return A new Kieler KNode corresponding to the Ptolemy inner port.
 */
private KNode _createKNodeForPort(Port node){
  KNode knode=KimlLayoutUtil.createInitializedNode();
  KShapeLayout layout=KimlLayoutUtil.getShapeLayout(knode);
  layout.setHeight(DEFAULT_INNER_PORT_HEIGHT);
  layout.setWidth(DEFAULT_INNER_PORT_WIDTH);
  LayoutOptions.setFixedSize(layout,true);
  return knode;
}","/** 
 * Create a Kieler KNode for a Ptolemy inner port. That is the graphical representation for a port of a CompositeActor if you see the contents of this CompositeActor. It is represented by a node where the connection may touch the node corresponding to its type (input, output, both) on the right, left or top. For now this results a crude approximation of the node, because the figure of the original Ptolemy port cannot be obtained by the layout target. Hence we cannot ask the port for its original bounds.
 * @param divaLocation Diva Representation of an inner port 
 * @param port The Ptolemy inner port.
 * @return A new Kieler KNode corresponding to the Ptolemy inner port.
 */
private KNode _createKNodeForPort(Object divaLocation,Port port){
  KNode knode=KimlLayoutUtil.createInitializedNode();
  KShapeLayout layout=KimlLayoutUtil.getShapeLayout(knode);
  Rectangle2D bounds=this.getLayoutTarget().getBounds(divaLocation);
  layout.setHeight((float)bounds.getHeight() + INNER_PORT_HEIGHT_OFFSET);
  layout.setWidth((float)bounds.getWidth());
  LayoutOptions.setFixedSize(layout,true);
  return knode;
}"
73831,"/** 
 * Creates a graph for the KIELER API from a ptolemy model. Will traverse the low level GraphModel given by the composite and record all found elements in the mapping fields of this object that keep a mapping between Ptolemy/Diva objects and Kieler objects. New Kieler objects (KEdge, KNode, KPort) get created for their respective Ptolemy counterparts and initialized with the initial sizes and positions and are put in a composite KNode (the graph Kieler will perform the layout on later). To obtain the right mappings, multiple abstraction levels of Ptolemy are considered here: Diva, as this was the intended original way to do automatic layout (e.g. by GlobalAbstractLayout) and Ptolemy, as Diva lacks certain concepts that are relevant for a proper layout, as for example exact port locations for considering port constraints in the model, supported by Kieler.
 * @param composite The GraphModel composite object to retrieve the model information from
 * @param boxLayoutNode Kieler subgraph to receive all unconnected model elements
 * @param hierarchicalLayoutNode Kieler subgraph to receive all connected model elements
 */
private void _createGraph(Object composite,KNode hierarchicalLayoutNode,KNode boxLayoutNode){
  _ptolemy2KielerNodes=new HashMap<Object,KNode>();
  _kieler2ptolemyDivaNodes=new HashMap<KNode,Object>();
  _kieler2ptolemyEntityNodes=new HashMap<KNode,NamedObj>();
  _ptolemyDiva2KielerEdges=new HashMap<Object,KEdge>();
  _kieler2PtolemyDivaEdges=new HashMap<KEdge,Object>();
  _ptolemy2KielerPorts=new HashMap<Port,List<KPort>>();
  _kieler2PtolemyPorts=new HashMap<KPort,Port>();
  _divaEdgeSource=new HashMap<Object,Object>();
  _divaEdgeTarget=new HashMap<Object,Object>();
  float globalX=Float.MAX_VALUE, globalY=Float.MAX_VALUE;
  LayoutTarget target=this.getLayoutTarget();
  GraphModel graph=target.getGraphModel();
  if (graph instanceof ActorGraphModel) {
    ActorGraphModel aGraph=(ActorGraphModel)graph;
    for (Iterator iterator=aGraph.nodes(composite); iterator.hasNext(); ) {
      Object node=iterator.next();
      Object semanticNode=aGraph.getSemanticObject(node);
      if (semanticNode instanceof Actor || semanticNode instanceof Attribute) {
        KNode knode=_createKNode(node,semanticNode);
        if (PtolemyModelUtil._isConnected((NamedObj)semanticNode)) {
          knode.setParent(hierarchicalLayoutNode);
          KShapeLayout layout=KimlLayoutUtil.getShapeLayout(knode);
          if (layout.getXpos() < globalX) {
            globalX=layout.getXpos();
          }
          if (layout.getYpos() < globalY) {
            globalY=layout.getYpos();
          }
        }
 else {
          knode.setParent(boxLayoutNode);
        }
        if (semanticNode instanceof Actor && semanticNode instanceof Entity) {
          Actor actor=(Actor)semanticNode;
          List<Port> inputs=actor.inputPortList();
          List<Port> outputs=actor.outputPortList();
          _createKPorts(knode,inputs,KPortType.INPUT);
          _createKPorts(knode,outputs,KPortType.OUTPUT);
        }
      }
 else       if (semanticNode instanceof Relation) {
        KNode kVertexNode=_createKNodeForVertex((Vertex)node);
        kVertexNode.setParent(hierarchicalLayoutNode);
        KShapeLayout layout=KimlLayoutUtil.getShapeLayout(kVertexNode);
        if (layout.getXpos() < globalX) {
          globalX=layout.getXpos();
        }
        if (layout.getYpos() < globalY) {
          globalY=layout.getYpos();
        }
        _ptolemy2KielerNodes.put(node,kVertexNode);
        _kieler2ptolemyDivaNodes.put(kVertexNode,node);
        _kieler2ptolemyEntityNodes.put(kVertexNode,(NamedObj)semanticNode);
      }
 else       if (semanticNode instanceof Port) {
        KNode kPortNode=_createKNodeForPort((Port)semanticNode);
        kPortNode.setParent(hierarchicalLayoutNode);
        KShapeLayout layout=KimlLayoutUtil.getShapeLayout(kPortNode);
        if (layout.getXpos() < globalX) {
          globalX=layout.getXpos();
        }
        if (layout.getYpos() < globalY) {
          globalY=layout.getYpos();
        }
        _ptolemy2KielerNodes.put(node,kPortNode);
        _kieler2ptolemyDivaNodes.put(kPortNode,node);
        _kieler2ptolemyEntityNodes.put(kPortNode,(NamedObj)semanticNode);
      }
      Iterator portIter=null;
      List portList=new ArrayList();
      if (semanticNode instanceof Relation) {
        portList.add(node);
        portIter=portList.iterator();
      }
 else       if (semanticNode instanceof Actor) {
        portIter=aGraph.nodes(node);
      }
 else       if (semanticNode instanceof Port) {
        portList.add(node);
        portIter=portList.iterator();
      }
      if (portIter != null) {
        for (; portIter.hasNext(); ) {
          Object divaPort=portIter.next();
          Iterator edgeIterator=aGraph.outEdges(divaPort);
          if (semanticNode instanceof Port) {
            edgeIterator=aGraph.getExternalPortModel().outEdges(node);
          }
          for (; edgeIterator.hasNext(); ) {
            Object divaEdge=edgeIterator.next();
            _ptolemyDiva2KielerEdges.put(divaEdge,null);
          }
        }
      }
    }
    _storeEndpoints();
    for (    Object divaEdge : _ptolemyDiva2KielerEdges.keySet()) {
      _createKEdge(divaEdge);
    }
  }
  KShapeLayout layout=KimlLayoutUtil.getShapeLayout(hierarchicalLayoutNode);
  layout.setXpos(globalX);
  layout.setYpos(globalY);
}","/** 
 * Creates a graph for the KIELER API from a ptolemy model. Will traverse the low level GraphModel given by the composite and record all found elements in the mapping fields of this object that keep a mapping between Ptolemy/Diva objects and Kieler objects. New Kieler objects (KEdge, KNode, KPort) get created for their respective Ptolemy counterparts and initialized with the initial sizes and positions and are put in a composite KNode (the graph Kieler will perform the layout on later). To obtain the right mappings, multiple abstraction levels of Ptolemy are considered here: Diva, as this was the intended original way to do automatic layout (e.g. by GlobalAbstractLayout) and Ptolemy, as Diva lacks certain concepts that are relevant for a proper layout, as for example exact port locations for considering port constraints in the model, supported by Kieler.
 * @param composite The GraphModel composite object to retrieve the model information from
 * @param boxLayoutNode Kieler subgraph to receive all unconnected model elements
 * @param hierarchicalLayoutNode Kieler subgraph to receive all connected model elements
 */
private void _createGraph(Object composite,KNode hierarchicalLayoutNode,KNode boxLayoutNode){
  _ptolemy2KielerNodes=new HashMap<Object,KNode>();
  _kieler2ptolemyDivaNodes=new HashMap<KNode,Object>();
  _kieler2ptolemyEntityNodes=new HashMap<KNode,NamedObj>();
  _ptolemyDiva2KielerEdges=new HashMap<Object,KEdge>();
  _kieler2PtolemyDivaEdges=new HashMap<KEdge,Object>();
  _ptolemy2KielerPorts=new HashMap<Port,List<KPort>>();
  _kieler2PtolemyPorts=new HashMap<KPort,Port>();
  _divaEdgeSource=new HashMap<Object,Object>();
  _divaEdgeTarget=new HashMap<Object,Object>();
  float globalX=Float.MAX_VALUE, globalY=Float.MAX_VALUE;
  LayoutTarget target=this.getLayoutTarget();
  GraphModel graph=target.getGraphModel();
  if (graph instanceof ActorGraphModel) {
    ActorGraphModel aGraph=(ActorGraphModel)graph;
    for (Iterator iterator=aGraph.nodes(composite); iterator.hasNext(); ) {
      Object node=iterator.next();
      Object semanticNode=aGraph.getSemanticObject(node);
      if (semanticNode instanceof Actor || semanticNode instanceof Attribute) {
        KNode knode=_createKNode(node,semanticNode);
        if (PtolemyModelUtil._isConnected((NamedObj)semanticNode)) {
          knode.setParent(hierarchicalLayoutNode);
          KShapeLayout layout=KimlLayoutUtil.getShapeLayout(knode);
          if (layout.getXpos() < globalX) {
            globalX=layout.getXpos();
          }
          if (layout.getYpos() < globalY) {
            globalY=layout.getYpos();
          }
        }
 else {
          knode.setParent(boxLayoutNode);
        }
        if (semanticNode instanceof Actor && semanticNode instanceof Entity) {
          Actor actor=(Actor)semanticNode;
          List<Port> inputs=actor.inputPortList();
          List<Port> outputs=actor.outputPortList();
          _createKPorts(knode,inputs,KPortType.INPUT);
          _createKPorts(knode,outputs,KPortType.OUTPUT);
        }
      }
 else       if (semanticNode instanceof Relation) {
        KNode kVertexNode=_createKNodeForVertex((Vertex)node);
        kVertexNode.setParent(hierarchicalLayoutNode);
        KShapeLayout layout=KimlLayoutUtil.getShapeLayout(kVertexNode);
        if (layout.getXpos() < globalX) {
          globalX=layout.getXpos();
        }
        if (layout.getYpos() < globalY) {
          globalY=layout.getYpos();
        }
        _ptolemy2KielerNodes.put(node,kVertexNode);
        _kieler2ptolemyDivaNodes.put(kVertexNode,node);
        _kieler2ptolemyEntityNodes.put(kVertexNode,(NamedObj)semanticNode);
      }
 else       if (semanticNode instanceof Port) {
        KNode kPortNode=_createKNodeForPort(node,(Port)semanticNode);
        kPortNode.setParent(hierarchicalLayoutNode);
        KShapeLayout layout=KimlLayoutUtil.getShapeLayout(kPortNode);
        if (layout.getXpos() < globalX) {
          globalX=layout.getXpos();
        }
        if (layout.getYpos() < globalY) {
          globalY=layout.getYpos();
        }
        _ptolemy2KielerNodes.put(node,kPortNode);
        _kieler2ptolemyDivaNodes.put(kPortNode,node);
        _kieler2ptolemyEntityNodes.put(kPortNode,(NamedObj)semanticNode);
      }
      Iterator portIter=null;
      List portList=new ArrayList();
      if (semanticNode instanceof Relation) {
        portList.add(node);
        portIter=portList.iterator();
      }
 else       if (semanticNode instanceof Actor) {
        portIter=aGraph.nodes(node);
      }
 else       if (semanticNode instanceof Port) {
        portList.add(node);
        portIter=portList.iterator();
      }
      if (portIter != null) {
        for (; portIter.hasNext(); ) {
          Object divaPort=portIter.next();
          Iterator edgeIterator=aGraph.outEdges(divaPort);
          if (semanticNode instanceof Port) {
            edgeIterator=aGraph.getExternalPortModel().outEdges(node);
          }
          for (; edgeIterator.hasNext(); ) {
            Object divaEdge=edgeIterator.next();
            _ptolemyDiva2KielerEdges.put(divaEdge,null);
          }
        }
      }
    }
    _storeEndpoints();
    for (    Object divaEdge : _ptolemyDiva2KielerEdges.keySet()) {
      _createKEdge(divaEdge);
    }
  }
  KShapeLayout layout=KimlLayoutUtil.getShapeLayout(hierarchicalLayoutNode);
  layout.setXpos(globalX);
  layout.setYpos(globalY);
}"
73832,"/** 
 * Traverse a composite KNode containing corresponding Kieler nodes, ports and edges for the Ptolemy model and apply all layout information contained by it back to the Ptolemy model. Do most changes to the Ptolemy model via MoMLChangeRequests. Set location attributes for all visible Ptolemy nodes. So far Ptolemy does not support setting of connection bendpoints explicitly. The Ptolemy connection router does not consider obstruction avoidance so there are likely to be connection overlappings in the diagram. <p> Optionally route edges explicitly by inserting new relation vertices for each bend point.
 * @see #setApplyEdgeLayout(boolean)
 * @param kgraph The Kieler graph object containing all layout information to apply to the Ptolemy model
 * @exception IllegalActionException Exception can be thrown if routing of edges fails due to not allowed unlinking or linking of new relations.
 */
private void _applyLayout(KNode kgraph) throws IllegalActionException {
  GraphModel graph=this.getLayoutTarget().getGraphModel();
  if (graph instanceof ActorGraphModel) {
    Collection<KNode> kNodes=kgraph.getChildren();
    if (_doBoxLayout) {
      kNodes=_kieler2ptolemyEntityNodes.keySet();
    }
    for (    KNode knode : kNodes) {
      KShapeLayout absoluteLayout=KielerGraphUtil._getAbsoluteLayout(knode);
      NamedObj namedObj=_kieler2ptolemyEntityNodes.get(knode);
      _kNode2Ptolemy(absoluteLayout,knode);
      if (namedObj instanceof Relation) {
        Vertex vertex=(Vertex)_kieler2ptolemyDivaNodes.get(knode);
        PtolemyModelUtil._setLocation(vertex,(Relation)namedObj,absoluteLayout.getXpos(),absoluteLayout.getYpos());
      }
 else {
        PtolemyModelUtil._setLocation(namedObj,absoluteLayout.getXpos(),absoluteLayout.getYpos());
      }
    }
    if (_doApplyEdgeLayout) {
      Set<Relation> relationsToDelete=new HashSet<Relation>();
      for (      KEdge kedge : _kieler2PtolemyDivaEdges.keySet()) {
        Relation oldRelation=_applyEdgeLayout(kedge);
        if (oldRelation != null) {
          relationsToDelete.add(oldRelation);
        }
      }
      _ptolemyModelUtil._removeRelations(relationsToDelete);
    }
  }
  _ptolemyModelUtil._performChangeRequest(_compositeActor);
}","/** 
 * Traverse a composite KNode containing corresponding Kieler nodes, ports and edges for the Ptolemy model and apply all layout information contained by it back to the Ptolemy model. Do most changes to the Ptolemy model via MoMLChangeRequests. Set location attributes for all visible Ptolemy nodes. So far Ptolemy does not support setting of connection bendpoints explicitly. The Ptolemy connection router does not consider obstruction avoidance so there are likely to be connection overlappings in the diagram. <p> Optionally route edges explicitly by inserting new relation vertices for each bend point.
 * @see #setApplyEdgeLayout(boolean)
 * @param kgraph The Kieler graph object containing all layout information to apply to the Ptolemy model
 * @exception IllegalActionException Exception can be thrown if routing of edges fails due to not allowed unlinking or linking of new relations.
 */
private void _applyLayout(KNode kgraph) throws IllegalActionException {
  GraphModel graph=this.getLayoutTarget().getGraphModel();
  if (graph instanceof ActorGraphModel) {
    Collection<KNode> kNodes=kgraph.getChildren();
    if (_doBoxLayout) {
      kNodes=_kieler2ptolemyEntityNodes.keySet();
    }
    for (    KNode knode : kNodes) {
      KShapeLayout absoluteLayout=KielerGraphUtil._getAbsoluteLayout(knode);
      NamedObj namedObj=_kieler2ptolemyEntityNodes.get(knode);
      _kNode2Ptolemy(absoluteLayout,knode);
      if (namedObj instanceof Relation) {
        Vertex vertex=(Vertex)_kieler2ptolemyDivaNodes.get(knode);
        _ptolemyModelUtil._setLocation(vertex,(Relation)namedObj,absoluteLayout.getXpos(),absoluteLayout.getYpos());
      }
 else {
        _ptolemyModelUtil._setLocation(namedObj,absoluteLayout.getXpos(),absoluteLayout.getYpos());
      }
    }
    if (_doApplyEdgeLayout) {
      Set<Relation> relationsToDelete=new HashSet<Relation>();
      for (      KEdge kedge : _kieler2PtolemyDivaEdges.keySet()) {
        Relation oldRelation=_applyEdgeLayout(kedge);
        if (oldRelation != null) {
          relationsToDelete.add(oldRelation);
        }
      }
      _ptolemyModelUtil._removeRelations(relationsToDelete);
    }
  }
  _ptolemyModelUtil._performChangeRequest(_compositeActor);
}"
73833,"/** 
 * Flush all buffered change requests to the given Actor. Reset the buffer afterwards.
 * @param actor The target of the change request, e.g. the composite actorcontaining the objects for which changes are requested.
 */
protected void _performChangeRequest(CompositeActor actor){
  if (_momlChangeRequest.toString().trim().equals(""String_Node_Str"")) {
    return;
  }
  _momlChangeRequest.insert(0,""String_Node_Str"");
  _momlChangeRequest.append(""String_Node_Str"");
  MoMLChangeRequest request=new MoMLChangeRequest(this,actor,_momlChangeRequest.toString());
  request.setUndoable(true);
  request.setMergeWithPreviousUndo(true);
  actor.requestChange(request);
  _momlChangeRequest=new StringBuffer();
}","/** 
 * Flush all buffered change requests to the given Actor. Reset the buffer afterwards.
 * @param actor The target of the change request, e.g. the composite actorcontaining the objects for which changes are requested.
 */
protected void _performChangeRequest(CompositeActor actor){
  if (_momlChangeRequest.toString().trim().equals(""String_Node_Str"")) {
    return;
  }
  _momlChangeRequest.insert(0,""String_Node_Str"");
  _momlChangeRequest.append(""String_Node_Str"");
  MoMLChangeRequest request=new MoMLChangeRequest(this,actor,_momlChangeRequest.toString());
  request.setUndoable(true);
  if (_anyRequestsSoFar) {
    request.setMergeWithPreviousUndo(true);
  }
  actor.requestChange(request);
  _momlChangeRequest=new StringBuffer();
  _anyRequestsSoFar=true;
}"
73834,"/** 
 * Create a MoMLChangeRequest to move a Ptolemy model object and schedule it immediately. The request is addressed to a specific NamedObj in the Ptolemy model and hence does not get buffered because there is only exactly one move request per layout run per node.
 * @param vertex Ptolemy node to be moved
 * @param relation Ptolemy Relation to be moved
 * @param x new coordinate
 * @param y new coordinate
 */
protected static void _setLocation(Vertex vertex,Relation relation,double x,double y){
  String moml=""String_Node_Str"" + vertex.getName() + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"";
  MoMLChangeRequest request=new MoMLChangeRequest(vertex,relation,moml);
  request.setUndoable(true);
  request.setMergeWithPreviousUndo(true);
  relation.requestChange(request);
}","/** 
 * Create a MoMLChangeRequest to move a Ptolemy model object and schedule it immediately. The request is addressed to a specific NamedObj in the Ptolemy model and hence does not get buffered because there is only exactly one move request per layout run per node.
 * @param vertex Ptolemy node to be moved
 * @param relation Ptolemy Relation to be moved
 * @param x new coordinate
 * @param y new coordinate
 */
protected void _setLocation(Vertex vertex,Relation relation,double x,double y){
  String moml=""String_Node_Str"" + vertex.getName() + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"";
  MoMLChangeRequest request=new MoMLChangeRequest(vertex,relation,moml);
  request.setUndoable(true);
  if (_anyRequestsSoFar) {
    request.setMergeWithPreviousUndo(true);
  }
  relation.requestChange(request);
  _anyRequestsSoFar=true;
}"
73835,"/** 
 * Generate the fire code. In this base class, add the name of the associated component in the comment. It checks the inline parameter of the code generator. If the value is true, it generates the actor fire code and the necessary type conversion code. Otherwise, it generate an invocation to the actor function that is generated by generateFireFunctionCode.
 * @return The generated code.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateFireCode() throws IllegalActionException {
  List args=new LinkedList();
  CodeStream _codeStream=_templateParser.getCodeStream();
  ptolemy.domains.ptides.lib.luminary.GPOutputDevice actor=(ptolemy.domains.ptides.lib.luminary.GPOutputDevice)getComponent();
  PtidesBasicDirector adapter=(PtidesBasicDirector)getAdapter(actor.getDirector());
  args.add((adapter.actuators.get(actor)).toString());
  _codeStream.clear();
  _codeStream.appendCodeBlock(""String_Node_Str"",args);
  return processCode(_codeStream.toString());
}","/** 
 * Generate the fire code. In this base class, add the name of the associated component in the comment. It checks the inline parameter of the code generator. If the value is true, it generates the actor fire code and the necessary type conversion code. Otherwise, it generate an invocation to the actor function that is generated by generateFireFunctionCode.
 * @return The generated code.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateFireCode() throws IllegalActionException {
  List args=new LinkedList();
  CodeStream _codeStream=_templateParser.getCodeStream();
  ptolemy.domains.ptides.lib.ActuatorOutputDevice actor=(ptolemy.domains.ptides.lib.ActuatorOutputDevice)getComponent();
  PtidesBasicDirector adapter=(PtidesBasicDirector)getAdapter(actor.getDirector());
  args.add((adapter.actuators.get(actor)).toString());
  _codeStream.clear();
  _codeStream.appendCodeBlock(""String_Node_Str"",args);
  return processCode(_codeStream.toString());
}"
73836,"/** 
 * Resizes the screen.
 * @see javax.media.opengl.GLEventListener#reshape(javax.media.opengl.GLAutoDrawable,int,int,int,int)
 */
public void reshape(GLAutoDrawable gLDrawable,int x,int y,int width,int height){
  final GL gl=drawable.getGL();
  gl.glViewport(0,0,width,height);
  if (height <= 0) {
    height=1;
  }
}","/** 
 * Resizes the screen.
 * @see javax.media.opengl.GLEventListener#reshape(javax.media.opengl.GLAutoDrawable,int,int,int,int)
 */
public void reshape(GLAutoDrawable gLDrawable,int x,int y,int width,int height){
  final GL gl=gLDrawable.getGL();
  gl.glViewport(0,0,width,height);
  if (height <= 0) {
    height=1;
  }
}"
73837,"/** 
 * Generate code for transferring enough tokens to fulfill the output production rate.
 * @param outputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferOutputsCode(IOPort outputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenProductionRate(outputPort);
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if ((container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) || (container instanceof CompositeActor)) {
    ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.actor.IOPort portAdapter=(ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.actor.IOPort)getAdapter(outputPort);
    String offset=""String_Node_Str"";
    for (int i=0; i < outputPort.getWidth(); i++) {
      StringBuffer outputCode=new StringBuffer();
      outputCode.append(NamedProgramCodeGeneratorAdapter.generateName(outputPort));
      if (outputPort.isMultiport()) {
        outputCode.append(""String_Node_Str"" + Integer.toString(i) + ""String_Node_Str"");
      }
      int bufferSize=_ports.getBufferSize(outputPort);
      if (bufferSize > 1) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      code.append(portAdapter.generatePutCode(Integer.toString(i),offset,outputCode.toString()));
    }
  }
 else {
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      if (i < outputPort.getWidth()) {
        String name=outputPort.getName();
        if (outputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(CodeStream.indent(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k)));
          code.append(""String_Node_Str"" + _eol);
          code.append(CodeStream.indent(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k)));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  _updatePortOffset(outputPort,code,rate);
}","/** 
 * Generate code for transferring enough tokens to fulfill the output production rate.
 * @param outputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferOutputsCode(IOPort outputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenProductionRate(outputPort);
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if ((container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) || (container instanceof CompositeActor)) {
    ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.actor.IOPort portAdapter=(ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.actor.IOPort)getAdapter(outputPort);
    String offset=""String_Node_Str"";
    for (int i=0; i < outputPort.getWidth(); i++) {
      StringBuffer outputCode=new StringBuffer();
      outputCode.append(NamedProgramCodeGeneratorAdapter.generateName(outputPort));
      if (outputPort.isMultiport()) {
        outputCode.append(""String_Node_Str"" + Integer.toString(i) + ""String_Node_Str"");
      }
      int bufferSize=_ports.getBufferSize(outputPort);
      if (bufferSize > 1) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      code.append(portAdapter.generatePutCode(Integer.toString(i),offset,outputCode.toString()));
    }
  }
 else {
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      if (i < outputPort.getWidth()) {
        String name=outputPort.getName();
        if (outputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(CodeStream.indent(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k,false)));
          code.append(""String_Node_Str"" + _eol);
          code.append(CodeStream.indent(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k,false)));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  _updatePortOffset(outputPort,code,rate);
}"
73838,"/** 
 * Generate code for transferring enough tokens to complete an internal iteration.
 * @param inputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferInputsCode(IOPort inputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenConsumptionRate(inputPort);
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if ((container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) || (container instanceof CompositeActor)) {
    if (!(inputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(inputPort,null,""String_Node_Str"");
    }
    ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.actor.IOPort portAdapter=(ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.actor.IOPort)getAdapter(inputPort);
    String offset=""String_Node_Str"";
    for (int i=0; i < inputPort.getWidth(); i++) {
      code.append(""String_Node_Str"");
      code.append(portAdapter.generateHasTokenCode(Integer.toString(i),offset));
      code.append(""String_Node_Str"" + _eol);
      StringBuffer inputCode=new StringBuffer();
      boolean dynamicReferencesAllowed=allowDynamicMultiportReference();
      inputCode.append(NamedProgramCodeGeneratorAdapter.generateName(inputPort));
      int bufferSize=_ports.getBufferSize(inputPort);
      if (inputPort.isMultiport()) {
        inputCode.append(""String_Node_Str"" + Integer.toString(i) + ""String_Node_Str"");
        if (bufferSize > 1 || dynamicReferencesAllowed) {
          throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 else {
        if (bufferSize > 1) {
          throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      code.append(inputCode);
      code.append(""String_Node_Str"");
      code.append(portAdapter.generateGetCode(Integer.toString(i),offset));
      code.append(""String_Node_Str"" + _eol);
      code.append(""String_Node_Str"" + _eol);
    }
  }
 else {
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String name=inputPort.getName();
        if (inputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k));
          code.append(""String_Node_Str"" + _eol);
          code.append(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  code.append(compositeActorAdapter.generateTypeConvertFireCode(true));
  _updateConnectedPortsOffset(inputPort,code,rate);
}","/** 
 * Generate code for transferring enough tokens to complete an internal iteration.
 * @param inputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferInputsCode(IOPort inputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenConsumptionRate(inputPort);
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if ((container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) || (container instanceof CompositeActor)) {
    if (!(inputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(inputPort,null,""String_Node_Str"");
    }
    ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.actor.IOPort portAdapter=(ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.actor.IOPort)getAdapter(inputPort);
    String offset=""String_Node_Str"";
    for (int i=0; i < inputPort.getWidth(); i++) {
      code.append(""String_Node_Str"");
      code.append(portAdapter.generateHasTokenCode(Integer.toString(i),offset));
      code.append(""String_Node_Str"" + _eol);
      StringBuffer inputCode=new StringBuffer();
      boolean dynamicReferencesAllowed=allowDynamicMultiportReference();
      inputCode.append(NamedProgramCodeGeneratorAdapter.generateName(inputPort));
      int bufferSize=_ports.getBufferSize(inputPort);
      if (inputPort.isMultiport()) {
        inputCode.append(""String_Node_Str"" + Integer.toString(i) + ""String_Node_Str"");
        if (bufferSize > 1 || dynamicReferencesAllowed) {
          throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 else {
        if (bufferSize > 1) {
          throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      code.append(inputCode);
      code.append(""String_Node_Str"");
      code.append(portAdapter.generateGetCode(Integer.toString(i),offset));
      code.append(""String_Node_Str"" + _eol);
      code.append(""String_Node_Str"" + _eol);
    }
  }
 else {
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String name=inputPort.getName();
        if (inputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k,false));
          code.append(""String_Node_Str"" + _eol);
          code.append(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k,false));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  code.append(compositeActorAdapter.generateTypeConvertFireCode(true));
  _updateConnectedPortsOffset(inputPort,code,rate);
}"
73839,"/** 
 * Generate the fire code of the associated composite actor. This method first generates code for transferring any data from the input ports of this composite to the ports connected on the inside by calling the generateTransferInputsCode() method of the local director adapter. It then invokes the generateFireCode() method of its local director adapter.  After the generateFireCode() method of the director adapter returns, generate code for transferring any output data created by calling the local director adapter's generateTransferOutputsCode() method.
 * @return The generated fire code.
 * @exception IllegalActionException If the adapter associatedwith an actor throws it while generating fire code for the actor, or the director adapter throws it while generating code for transferring data.
 */
@Override protected String _generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(getCodeGenerator().comment(2,""String_Node_Str"" + getComponent().getName()));
  Director directorAdapter=(Director)getCodeGenerator().getAdapter(((ptolemy.actor.CompositeActor)getComponent()).getDirector());
  Iterator<?> inputPorts=((ptolemy.actor.CompositeActor)getComponent()).inputPortList().iterator();
  StringBuffer tempCode=new StringBuffer();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    if (inputPort instanceof ParameterPort && inputPort.isOutsideConnected()) {
      PortParameter portParameter=((ParameterPort)inputPort).getParameter();
      tempCode.append(CodeStream.indent(getCodeGenerator().generateVariableName(portParameter)));
      tempCode.append(""String_Node_Str"");
      tempCode.append(getReference(inputPort.getName()));
      tempCode.append(""String_Node_Str"" + _eol);
    }
  }
  if (tempCode.length() > 0) {
    code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + getComponent().getName() + ""String_Node_Str"")));
    code.append(tempCode);
  }
  inputPorts=((ptolemy.actor.CompositeActor)getComponent()).inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    if (!(inputPort instanceof ParameterPort)) {
      directorAdapter.generateTransferInputsCode(inputPort,code);
    }
  }
  code.append(directorAdapter.generateFireCode());
  Iterator<?> outputPorts=((ptolemy.actor.CompositeActor)getComponent()).outputPortList().iterator();
  while (outputPorts.hasNext()) {
    IOPort outputPort=(IOPort)outputPorts.next();
    directorAdapter.generateTransferOutputsCode(outputPort,code);
  }
  return processCode(code.toString());
}","/** 
 * Generate the fire code of the associated composite actor. This method first generates code for transferring any data from the input ports of this composite to the ports connected on the inside by calling the generateTransferInputsCode() method of the local director adapter. It then invokes the generateFireCode() method of its local director adapter.  After the generateFireCode() method of the director adapter returns, generate code for transferring any output data created by calling the local director adapter's generateTransferOutputsCode() method.
 * @return The generated fire code.
 * @exception IllegalActionException If the adapter associatedwith an actor throws it while generating fire code for the actor, or the director adapter throws it while generating code for transferring data.
 */
@Override protected String _generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(getCodeGenerator().comment(2,""String_Node_Str"" + getComponent().getName()));
  Director directorAdapter=(Director)getCodeGenerator().getAdapter(((ptolemy.actor.CompositeActor)getComponent()).getDirector());
  Iterator<?> inputPorts=((ptolemy.actor.CompositeActor)getComponent()).inputPortList().iterator();
  StringBuffer tempCode=new StringBuffer();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    if (inputPort instanceof ParameterPort && inputPort.isOutsideConnected()) {
      PortParameter portParameter=((ParameterPort)inputPort).getParameter();
      tempCode.append(CodeStream.indent(getCodeGenerator().generateVariableName(portParameter)));
      tempCode.append(""String_Node_Str"");
      tempCode.append(getReference(inputPort.getName(),false));
      tempCode.append(""String_Node_Str"" + _eol);
    }
  }
  if (tempCode.length() > 0) {
    code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + getComponent().getName() + ""String_Node_Str"")));
    code.append(tempCode);
  }
  inputPorts=((ptolemy.actor.CompositeActor)getComponent()).inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    if (!(inputPort instanceof ParameterPort)) {
      directorAdapter.generateTransferInputsCode(inputPort,code);
    }
  }
  code.append(directorAdapter.generateFireCode());
  Iterator<?> outputPorts=((ptolemy.actor.CompositeActor)getComponent()).outputPortList().iterator();
  while (outputPorts.hasNext()) {
    IOPort outputPort=(IOPort)outputPorts.next();
    directorAdapter.generateTransferOutputsCode(outputPort,code);
  }
  return processCode(code.toString());
}"
73840,"/** 
 * Generate the initialize code for the associated SDF director.
 * @return The generated initialize code.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating initialize code for the actor.
 */
public String generateInitializeCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(super.generateInitializeCode());
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)getComponent().getContainer();
  NamedProgramCodeGeneratorAdapter containerAdapter=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(container);
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    NamedObj actor=(NamedObj)actors.next();
    ProgramCodeGeneratorAdapter actorAdapter=(ProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
    StringBuffer resetCode=new StringBuffer();
    Iterator<?> inputPorts=((Actor)actorAdapter.getComponent()).inputPortList().iterator();
    while (inputPorts.hasNext()) {
      IOPort port=(IOPort)inputPorts.next();
      resetCode.append(_ports.initializeOffsets(port));
    }
    if (resetCode.length() > 0) {
      resetCode.append(_eol + getCodeGenerator().comment(1,actor.getName() + ""String_Node_Str""));
      code.append(resetCode);
    }
  }
  String resetCode=_resetOutputPortsOffset();
  if (resetCode.length() > 0) {
    code.append(_eol + getCodeGenerator().comment(getComponent().getName() + ""String_Node_Str""));
    code.append(resetCode);
  }
  Iterator<?> outputPorts=container.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    IOPort outputPort=(IOPort)outputPorts.next();
    int rate=DFUtilities.getTokenInitProduction(outputPort);
    if (rate > 0) {
      for (int i=0; i < outputPort.getWidthInside(); i++) {
        if (i < outputPort.getWidth()) {
          String name=outputPort.getName();
          if (outputPort.isMultiport()) {
            name=name + '#' + i;
          }
          for (int k=0; k < rate; k++) {
            code.append(containerAdapter.getReference(name + ""String_Node_Str"" + k));
            code.append(""String_Node_Str"");
            code.append(containerAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k));
            code.append(""String_Node_Str"" + _eol);
          }
        }
      }
      _updatePortOffset(outputPort,code,rate);
    }
  }
  return code.toString();
}","/** 
 * Generate the initialize code for the associated SDF director.
 * @return The generated initialize code.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating initialize code for the actor.
 */
public String generateInitializeCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(super.generateInitializeCode());
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)getComponent().getContainer();
  NamedProgramCodeGeneratorAdapter containerAdapter=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(container);
  Iterator<?> actors=container.deepEntityList().iterator();
  while (actors.hasNext()) {
    NamedObj actor=(NamedObj)actors.next();
    ProgramCodeGeneratorAdapter actorAdapter=(ProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
    StringBuffer resetCode=new StringBuffer();
    Iterator<?> inputPorts=((Actor)actorAdapter.getComponent()).inputPortList().iterator();
    while (inputPorts.hasNext()) {
      IOPort port=(IOPort)inputPorts.next();
      resetCode.append(_ports.initializeOffsets(port));
    }
    if (resetCode.length() > 0) {
      resetCode.append(_eol + getCodeGenerator().comment(1,actor.getName() + ""String_Node_Str""));
      code.append(resetCode);
    }
  }
  String resetCode=_resetOutputPortsOffset();
  if (resetCode.length() > 0) {
    code.append(_eol + getCodeGenerator().comment(getComponent().getName() + ""String_Node_Str""));
    code.append(resetCode);
  }
  Iterator<?> outputPorts=container.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    IOPort outputPort=(IOPort)outputPorts.next();
    int rate=DFUtilities.getTokenInitProduction(outputPort);
    if (rate > 0) {
      for (int i=0; i < outputPort.getWidthInside(); i++) {
        if (i < outputPort.getWidth()) {
          String name=outputPort.getName();
          if (outputPort.isMultiport()) {
            name=name + '#' + i;
          }
          for (int k=0; k < rate; k++) {
            code.append(containerAdapter.getReference(name + ""String_Node_Str"" + k,true));
            code.append(""String_Node_Str"");
            code.append(containerAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k,false));
            code.append(""String_Node_Str"" + _eol);
          }
        }
      }
      _updatePortOffset(outputPort,code,rate);
    }
  }
  return code.toString();
}"
73841,"/** 
 * Each receiver is associated with a director, return that director.
 * @return The director associated with this receiver.
 * @exception IllegalActionException FIXME: this is not exactly correct.
 */
protected StaticSchedulingDirector _getDirectorForReceiver() throws IllegalActionException {
  return (StaticSchedulingDirector)super._getDirectorForReceiver();
}","/** 
 * Each receiver is associated with a director, return that director.
 * @return The director associated with this receiver.
 * @exception IllegalActionException FIXME: this is not exactly correct. This is probably because the information of the receiver is in the director of  the container?
 */
protected StaticSchedulingDirector _getDirectorForReceiver() throws IllegalActionException {
  return (StaticSchedulingDirector)super._getDirectorForReceiver();
}"
73842,"/** 
 * Generate code for putting tokens from the receiver.
 * @param sourcePort The source port.
 * @param offset The offset of the port.
 * @param token The token.    
 * @return The generated put code.
 * @exception IllegalActionException If thrown while getting the component,getting the adapter, getting the director or getting the port reference.
 */
public String generatePutCode(IOPort sourcePort,String offset,String token) throws IllegalActionException {
  TypedIOPort port=(TypedIOPort)getComponent().getContainer();
  int channel=port.getChannelForReceiver(getComponent());
  NamedProgramCodeGeneratorAdapter containingActorAdapter=(NamedProgramCodeGeneratorAdapter)getAdapter(getComponent().getContainer().getContainer());
  ProgramCodeGeneratorAdapter.Channel source=new Channel(sourcePort,0);
  ProgramCodeGeneratorAdapter.Channel sink=new Channel(port,channel);
  token=((NamedProgramCodeGeneratorAdapter)getAdapter(getComponent().getContainer().getContainer())).getTemplateParser().generateTypeConvertStatement(source,sink,0,token);
  token=_removeSink(token);
  boolean forComposite=_forComposite;
  if (getComponent().getContainer().getContainer() instanceof ModularCodeGenTypedCompositeActor && port.isInput()) {
    forComposite=false;
  }
  return _getDirectorForReceiver().getReference(port,new String[]{Integer.toString(channel),offset},forComposite,true,containingActorAdapter) + ""String_Node_Str"" + token+ ""String_Node_Str""+ _eol;
}","/** 
 * Generate code for putting tokens from the receiver.
 * @param sourcePort The source port.
 * @param offset The offset of the port.
 * @param token The token.    
 * @return The generated put code.
 * @exception IllegalActionException If thrown while getting the component,getting the adapter, getting the director or getting the port reference.
 */
public String generatePutCode(IOPort sourcePort,String offset,String token) throws IllegalActionException {
  TypedIOPort port=(TypedIOPort)getComponent().getContainer();
  int channel=port.getChannelForReceiver(getComponent());
  NamedProgramCodeGeneratorAdapter containingActorAdapter=(NamedProgramCodeGeneratorAdapter)getAdapter(getComponent().getContainer().getContainer());
  ProgramCodeGeneratorAdapter.Channel source=new Channel(sourcePort,0);
  ProgramCodeGeneratorAdapter.Channel sink=new Channel(port,channel);
  token=((NamedProgramCodeGeneratorAdapter)getAdapter(getComponent().getContainer().getContainer())).getTemplateParser().generateTypeConvertStatement(source,sink,0,token);
  token=_removeSink(token);
  boolean forComposite=_forComposite;
  if (getComponent().getContainer().getContainer() instanceof ModularCodeGenTypedCompositeActor && port.isInput()) {
    forComposite=false;
  }
  String result=null;
  try {
    result=_getDirectorForReceiver().getReference(port,new String[]{Integer.toString(channel),offset},forComposite,true,containingActorAdapter) + ""String_Node_Str"" + token+ ""String_Node_Str""+ _eol;
  }
 catch (  Exception ex) {
    result=_getExecutiveDirectorForReceiver().getReference(port,new String[]{Integer.toString(channel),offset},forComposite,true,containingActorAdapter) + ""String_Node_Str"" + token+ ""String_Node_Str""+ _eol;
  }
  return result;
}"
73843,"/** 
 * Generate the type conversion statement for the particular offset of the two given channels. This assumes that the offset is the same for both channel. Advancing the offset of one has to advance the offset of the other.
 * @param source The given source channel.
 * @param sink The given sink channel.
 * @param offset The given offset.
 * @return The type convert statement for assigning the converted sourcevariable to the sink variable with the given offset.
 * @exception IllegalActionException If there is a problem getting theadapters for the ports or if the conversion cannot be handled.
 */
protected String _generateTypeConvertStatement(ProgramCodeGeneratorAdapter.Channel source,ProgramCodeGeneratorAdapter.Channel sink,int offset) throws IllegalActionException {
  Type sourceType=((TypedIOPort)source.port).getType();
  Type sinkType=((TypedIOPort)sink.port).getType();
  if (sourceType == BaseType.UNKNOWN) {
    return ""String_Node_Str"";
  }
  String sourcePortChannel=NamedProgramCodeGeneratorAdapter.generateName(source.port) + ""String_Node_Str"" + source.channelNumber+ ""String_Node_Str""+ offset;
  String sourceRef=((NamedProgramCodeGeneratorAdapter)(getCodeGenerator().getAdapter(source.port.getContainer()))).getReference(sourcePortChannel);
  String sinkPortChannel=NamedProgramCodeGeneratorAdapter.generateName(sink.port) + ""String_Node_Str"" + sink.channelNumber+ ""String_Node_Str""+ offset;
  if (sink.port.getContainer() instanceof CompositeActor && sink.port.isOutput()) {
    sinkPortChannel=""String_Node_Str"" + sinkPortChannel;
  }
  String sinkRef=((NamedProgramCodeGeneratorAdapter)(getCodeGenerator().getAdapter(sink.port.getContainer()))).getReference(sinkPortChannel,true);
  if (sink.port.getContainer() instanceof ModalController) {
    sinkRef=NamedProgramCodeGeneratorAdapter.generateName(sink.port);
    if (sink.port.isMultiport()) {
      sinkRef=sinkRef + ""String_Node_Str"" + sink.channelNumber+ ""String_Node_Str"";
    }
  }
  String result=sourceRef;
  String sourceCodeGenType=getCodeGenerator().codeGenType(sourceType);
  String sinkCodeGenType=getCodeGenerator().codeGenType(sinkType);
  if (!sinkCodeGenType.equals(sourceCodeGenType)) {
    result=""String_Node_Str"" + sourceCodeGenType + ""String_Node_Str""+ sinkCodeGenType+ ""String_Node_Str""+ result+ ""String_Node_Str"";
  }
  return sinkRef + ""String_Node_Str"" + result+ ""String_Node_Str""+ _eol;
}","/** 
 * Generate the type conversion statement for the particular offset of the two given channels. This assumes that the offset is the same for both channel. Advancing the offset of one has to advance the offset of the other.
 * @param source The given source channel.
 * @param sink The given sink channel.
 * @param offset The given offset.
 * @return The type convert statement for assigning the converted sourcevariable to the sink variable with the given offset.
 * @exception IllegalActionException If there is a problem getting theadapters for the ports or if the conversion cannot be handled.
 */
protected String _generateTypeConvertStatement(ProgramCodeGeneratorAdapter.Channel source,ProgramCodeGeneratorAdapter.Channel sink,int offset) throws IllegalActionException {
  Type sourceType=((TypedIOPort)source.port).getType();
  Type sinkType=((TypedIOPort)sink.port).getType();
  if (sourceType == BaseType.UNKNOWN) {
    return ""String_Node_Str"";
  }
  String sourcePortChannel=NamedProgramCodeGeneratorAdapter.generateName(source.port) + ""String_Node_Str"" + source.channelNumber+ ""String_Node_Str""+ offset;
  String sourceRef=((NamedProgramCodeGeneratorAdapter)(getCodeGenerator().getAdapter(source.port.getContainer()))).getReference(sourcePortChannel,false);
  String sinkPortChannel=NamedProgramCodeGeneratorAdapter.generateName(sink.port) + ""String_Node_Str"" + sink.channelNumber+ ""String_Node_Str""+ offset;
  if (sink.port.getContainer() instanceof CompositeActor && sink.port.isOutput()) {
    sinkPortChannel=""String_Node_Str"" + sinkPortChannel;
  }
  String sinkRef=((NamedProgramCodeGeneratorAdapter)(getCodeGenerator().getAdapter(sink.port.getContainer()))).getReference(sinkPortChannel,true);
  if (sink.port.getContainer() instanceof ModalController) {
    sinkRef=NamedProgramCodeGeneratorAdapter.generateName(sink.port);
    if (sink.port.isMultiport()) {
      sinkRef=sinkRef + ""String_Node_Str"" + sink.channelNumber+ ""String_Node_Str"";
    }
  }
  String result=sourceRef;
  String sourceCodeGenType=getCodeGenerator().codeGenType(sourceType);
  String sinkCodeGenType=getCodeGenerator().codeGenType(sinkType);
  if (!sinkCodeGenType.equals(sourceCodeGenType)) {
    result=""String_Node_Str"" + sourceCodeGenType + ""String_Node_Str""+ sinkCodeGenType+ ""String_Node_Str""+ result+ ""String_Node_Str"";
  }
  return sinkRef + ""String_Node_Str"" + result+ ""String_Node_Str""+ _eol;
}"
73844,"/** 
 * Generate code for transferring enough tokens to fulfill the output production rate.
 * @param outputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferOutputsCode(IOPort outputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenProductionRate(outputPort);
  boolean targetCpp=((BooleanToken)((CCodeGenerator)getCodeGenerator()).generateCpp.getToken()).booleanValue();
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if (container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) {
    if (_portNumber == 0) {
      int numberOfOutputPorts=container.outputPortList().size();
      code.append(""String_Node_Str"" + _eol);
      code.append(""String_Node_Str"" + _objClass + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
      code.append(""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfOutputPorts),""String_Node_Str"",targetCpp) + ""String_Node_Str""+ _eol);
    }
    String portName=outputPort.getName();
    String tokensToThisPort=""String_Node_Str"" + portName;
    if (!(outputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(outputPort,null,""String_Node_Str"");
    }
    Type type=((TypedIOPort)outputPort).getType();
    int numberOfChannels=outputPort.getWidthInside();
    code.append(""String_Node_Str"" + tokensToThisPort + ""String_Node_Str""+ _eol);
    if (type == BaseType.INT) {
      if (!_intFlag) {
        code.append(""String_Node_Str"" + _objClassI + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
        _intFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),_objClassI,targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else     if (type == BaseType.DOUBLE) {
      if (!_doubleFlag) {
        code.append(""String_Node_Str"" + _objClassD + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
        _doubleFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),_objClassD,targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else     if (type == PointerToken.POINTER) {
      if (!_intFlag) {
        code.append(""String_Node_Str"" + _objClassI + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
        _intFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),_objClassI,targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else     if (type == BaseType.BOOLEAN) {
      if (!_booleanFlag) {
        code.append(""String_Node_Str"" + CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp) + ""String_Node_Str""+ _eol);
        _booleanFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else {
    }
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      String tokensToOneChannel=""String_Node_Str"" + portName;
      if (i == 0) {
        if (type == BaseType.INT) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else         if (type == PointerToken.POINTER) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else {
        }
      }
      String portNameWithChannelNumber=portName;
      if (outputPort.isMultiport()) {
        portNameWithChannelNumber=portName + '#' + i;
      }
      for (int k=0; k < rate; k++) {
        String portReference=compositeActorAdapter.getReference(""String_Node_Str"" + portNameWithChannelNumber + ""String_Node_Str""+ k);
        if (type == PointerToken.POINTER) {
          code.append(tokensToOneChannel + ""String_Node_Str"" + k+ ""String_Node_Str""+ ""String_Node_Str""+ portReference+ ""String_Node_Str""+ _eol);
        }
 else {
          code.append(tokensToOneChannel + ""String_Node_Str"" + k+ ""String_Node_Str""+ portReference+ ""String_Node_Str""+ _eol);
        }
      }
      String tokensToOneChannelArray=""String_Node_Str"" + portName + i;
      if (type == BaseType.INT) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else       if (type == BaseType.DOUBLE) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else       if (type == PointerToken.POINTER) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else       if (type == BaseType.BOOLEAN) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else {
      }
      code.append(CCodegenUtilities.jniSetObjectArrayElement(tokensToThisPort,String.valueOf(i),tokensToOneChannelArray,targetCpp) + ""String_Node_Str"" + _eol);
      code.append(CCodegenUtilities.jniDeleteLocalRef(tokensToOneChannelArray,targetCpp) + ""String_Node_Str"" + _eol);
    }
    code.append(CCodegenUtilities.jniSetObjectArrayElement(""String_Node_Str"",String.valueOf(_portNumber),tokensToThisPort,targetCpp) + ""String_Node_Str"" + _eol);
    code.append(CCodegenUtilities.jniDeleteLocalRef(tokensToThisPort,targetCpp) + ""String_Node_Str"" + _eol);
    _portNumber++;
  }
 else {
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      if (i < outputPort.getWidth()) {
        String name=outputPort.getName();
        if (outputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(CodeStream.indent(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k)));
          code.append(""String_Node_Str"" + _eol);
          code.append(CodeStream.indent(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k)));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  _updatePortOffset(outputPort,code,rate);
}","/** 
 * Generate code for transferring enough tokens to fulfill the output production rate.
 * @param outputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferOutputsCode(IOPort outputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenProductionRate(outputPort);
  boolean targetCpp=((BooleanToken)((CCodeGenerator)getCodeGenerator()).generateCpp.getToken()).booleanValue();
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if (container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) {
    if (_portNumber == 0) {
      int numberOfOutputPorts=container.outputPortList().size();
      code.append(""String_Node_Str"" + _eol);
      code.append(""String_Node_Str"" + _objClass + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
      code.append(""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfOutputPorts),""String_Node_Str"",targetCpp) + ""String_Node_Str""+ _eol);
    }
    String portName=outputPort.getName();
    String tokensToThisPort=""String_Node_Str"" + portName;
    if (!(outputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(outputPort,null,""String_Node_Str"");
    }
    Type type=((TypedIOPort)outputPort).getType();
    int numberOfChannels=outputPort.getWidthInside();
    code.append(""String_Node_Str"" + tokensToThisPort + ""String_Node_Str""+ _eol);
    if (type == BaseType.INT) {
      if (!_intFlag) {
        code.append(""String_Node_Str"" + _objClassI + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
        _intFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),_objClassI,targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else     if (type == BaseType.DOUBLE) {
      if (!_doubleFlag) {
        code.append(""String_Node_Str"" + _objClassD + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
        _doubleFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),_objClassD,targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else     if (type == PointerToken.POINTER) {
      if (!_intFlag) {
        code.append(""String_Node_Str"" + _objClassI + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
        _intFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),_objClassI,targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else     if (type == BaseType.BOOLEAN) {
      if (!_booleanFlag) {
        code.append(""String_Node_Str"" + CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp) + ""String_Node_Str""+ _eol);
        _booleanFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else {
    }
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      String tokensToOneChannel=""String_Node_Str"" + portName;
      if (i == 0) {
        if (type == BaseType.INT) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else         if (type == PointerToken.POINTER) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else {
        }
      }
      String portNameWithChannelNumber=portName;
      if (outputPort.isMultiport()) {
        portNameWithChannelNumber=portName + '#' + i;
      }
      for (int k=0; k < rate; k++) {
        String portReference=compositeActorAdapter.getReference(""String_Node_Str"" + portNameWithChannelNumber + ""String_Node_Str""+ k,false);
        if (type == PointerToken.POINTER) {
          code.append(tokensToOneChannel + ""String_Node_Str"" + k+ ""String_Node_Str""+ ""String_Node_Str""+ portReference+ ""String_Node_Str""+ _eol);
        }
 else {
          code.append(tokensToOneChannel + ""String_Node_Str"" + k+ ""String_Node_Str""+ portReference+ ""String_Node_Str""+ _eol);
        }
      }
      String tokensToOneChannelArray=""String_Node_Str"" + portName + i;
      if (type == BaseType.INT) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else       if (type == BaseType.DOUBLE) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else       if (type == PointerToken.POINTER) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else       if (type == BaseType.BOOLEAN) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else {
      }
      code.append(CCodegenUtilities.jniSetObjectArrayElement(tokensToThisPort,String.valueOf(i),tokensToOneChannelArray,targetCpp) + ""String_Node_Str"" + _eol);
      code.append(CCodegenUtilities.jniDeleteLocalRef(tokensToOneChannelArray,targetCpp) + ""String_Node_Str"" + _eol);
    }
    code.append(CCodegenUtilities.jniSetObjectArrayElement(""String_Node_Str"",String.valueOf(_portNumber),tokensToThisPort,targetCpp) + ""String_Node_Str"" + _eol);
    code.append(CCodegenUtilities.jniDeleteLocalRef(tokensToThisPort,targetCpp) + ""String_Node_Str"" + _eol);
    _portNumber++;
  }
 else {
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      if (i < outputPort.getWidth()) {
        String name=outputPort.getName();
        if (outputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(CodeStream.indent(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k,false)));
          code.append(""String_Node_Str"" + _eol);
          code.append(CodeStream.indent(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k,false)));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  _updatePortOffset(outputPort,code,rate);
}"
73845,"/** 
 * Generate code for transferring enough tokens to complete an internal iteration.
 * @param inputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferInputsCode(IOPort inputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenConsumptionRate(inputPort);
  boolean targetCpp=((BooleanToken)((CCodeGenerator)getCodeGenerator()).generateCpp.getToken()).booleanValue();
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if (container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) {
    if (!(inputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(inputPort,null,""String_Node_Str"");
    }
    Type type=((TypedIOPort)inputPort).getType();
    String portName=inputPort.getName();
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String tokensFromOneChannel=""String_Node_Str"" + portName + i;
        String pointerToTokensFromOneChannel=""String_Node_Str"" + tokensFromOneChannel;
        code.append(""String_Node_Str"" + tokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetObjectArrayElement(portName,String.valueOf(i),targetCpp)+ ""String_Node_Str""+ _eol);
        if (type == BaseType.INT) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == PointerToken.POINTER) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else {
        }
        String portNameWithChannelNumber=portName;
        if (inputPort.isMultiport()) {
          portNameWithChannelNumber=portName + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(compositeActorAdapter.getReference(""String_Node_Str"" + portNameWithChannelNumber + ""String_Node_Str""+ k));
          if (type == PointerToken.POINTER) {
            code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ k+ ""String_Node_Str""+ _eol);
          }
 else {
            code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ k+ ""String_Node_Str""+ _eol);
          }
        }
        if (type == BaseType.INT) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else         if (type == PointerToken.POINTER) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else {
        }
      }
    }
  }
 else {
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String name=inputPort.getName();
        if (inputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k));
          code.append(""String_Node_Str"" + _eol);
          code.append(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  code.append(compositeActorAdapter.generateTypeConvertFireCode(true));
  _updateConnectedPortsOffset(inputPort,code,rate);
}","/** 
 * Generate code for transferring enough tokens to complete an internal iteration.
 * @param inputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferInputsCode(IOPort inputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenConsumptionRate(inputPort);
  boolean targetCpp=((BooleanToken)((CCodeGenerator)getCodeGenerator()).generateCpp.getToken()).booleanValue();
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if (container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) {
    if (!(inputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(inputPort,null,""String_Node_Str"");
    }
    Type type=((TypedIOPort)inputPort).getType();
    String portName=inputPort.getName();
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String tokensFromOneChannel=""String_Node_Str"" + portName + i;
        String pointerToTokensFromOneChannel=""String_Node_Str"" + tokensFromOneChannel;
        code.append(""String_Node_Str"" + tokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetObjectArrayElement(portName,String.valueOf(i),targetCpp)+ ""String_Node_Str""+ _eol);
        if (type == BaseType.INT) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == PointerToken.POINTER) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else {
        }
        String portNameWithChannelNumber=portName;
        if (inputPort.isMultiport()) {
          portNameWithChannelNumber=portName + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(compositeActorAdapter.getReference(""String_Node_Str"" + portNameWithChannelNumber + ""String_Node_Str""+ k,false));
          if (type == PointerToken.POINTER) {
            code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ k+ ""String_Node_Str""+ _eol);
          }
 else {
            code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ k+ ""String_Node_Str""+ _eol);
          }
        }
        if (type == BaseType.INT) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else         if (type == PointerToken.POINTER) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else {
        }
      }
    }
  }
 else {
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String name=inputPort.getName();
        if (inputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k,false));
          code.append(""String_Node_Str"" + _eol);
          code.append(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k,false));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  code.append(compositeActorAdapter.generateTypeConvertFireCode(true));
  _updateConnectedPortsOffset(inputPort,code,rate);
}"
73846,"/** 
 * Generate code for transferring enough tokens to fulfill the output production rate.
 * @param outputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferOutputsCode(IOPort outputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenProductionRate(outputPort);
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if (container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) {
    if (_portNumber == 0) {
      int numberOfOutputPorts=container.outputPortList().size();
      code.append(""String_Node_Str"" + ""String_Node_Str"" + String.valueOf(numberOfOutputPorts) + ""String_Node_Str""+ _eol);
    }
    String portName=outputPort.getName();
    String tokensToThisPort=""String_Node_Str"" + portName;
    if (!(outputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(outputPort,null,""String_Node_Str"");
    }
    Type type=((TypedIOPort)outputPort).getType();
    int numberOfChannels=outputPort.getWidthInside();
    if (type == BaseType.INT) {
      code.append(""String_Node_Str"" + tokensToThisPort + ""String_Node_Str""+ ""String_Node_Str""+ String.valueOf(numberOfChannels)+ ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
    }
 else     if (type == BaseType.DOUBLE) {
      code.append(""String_Node_Str"" + tokensToThisPort + ""String_Node_Str""+ ""String_Node_Str""+ String.valueOf(numberOfChannels)+ ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
    }
 else     if (type == BaseType.BOOLEAN) {
      code.append(""String_Node_Str"" + tokensToThisPort + ""String_Node_Str""+ ""String_Node_Str""+ String.valueOf(numberOfChannels)+ ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
    }
 else {
    }
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      String portNameWithChannelNumber=portName;
      if (outputPort.isMultiport()) {
        portNameWithChannelNumber=portName + '#' + i;
      }
      for (int k=0; k < rate; k++) {
        String portReference=compositeActorAdapter.getReference(""String_Node_Str"" + portNameWithChannelNumber + ""String_Node_Str""+ k);
        code.append(tokensToThisPort + ""String_Node_Str"" + i+ ""String_Node_Str""+ k+ ""String_Node_Str""+ portReference+ ""String_Node_Str""+ _eol);
      }
    }
    code.append(""String_Node_Str"" + String.valueOf(_portNumber) + ""String_Node_Str""+ tokensToThisPort+ ""String_Node_Str""+ _eol);
    _portNumber++;
  }
 else {
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      if (i < outputPort.getWidth()) {
        String name=outputPort.getName();
        if (outputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(CodeStream.indent(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k)));
          code.append(""String_Node_Str"" + _eol);
          code.append(CodeStream.indent(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k)));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  _updatePortOffset(outputPort,code,rate);
}","/** 
 * Generate code for transferring enough tokens to fulfill the output production rate.
 * @param outputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferOutputsCode(IOPort outputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenProductionRate(outputPort);
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if (container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) {
    if (_portNumber == 0) {
      int numberOfOutputPorts=container.outputPortList().size();
      code.append(""String_Node_Str"" + ""String_Node_Str"" + String.valueOf(numberOfOutputPorts) + ""String_Node_Str""+ _eol);
    }
    String portName=outputPort.getName();
    String tokensToThisPort=""String_Node_Str"" + portName;
    if (!(outputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(outputPort,null,""String_Node_Str"");
    }
    Type type=((TypedIOPort)outputPort).getType();
    int numberOfChannels=outputPort.getWidthInside();
    if (type == BaseType.INT) {
      code.append(""String_Node_Str"" + tokensToThisPort + ""String_Node_Str""+ ""String_Node_Str""+ String.valueOf(numberOfChannels)+ ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
    }
 else     if (type == BaseType.DOUBLE) {
      code.append(""String_Node_Str"" + tokensToThisPort + ""String_Node_Str""+ ""String_Node_Str""+ String.valueOf(numberOfChannels)+ ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
    }
 else     if (type == BaseType.BOOLEAN) {
      code.append(""String_Node_Str"" + tokensToThisPort + ""String_Node_Str""+ ""String_Node_Str""+ String.valueOf(numberOfChannels)+ ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
    }
 else {
    }
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      String portNameWithChannelNumber=portName;
      if (outputPort.isMultiport()) {
        portNameWithChannelNumber=portName + '#' + i;
      }
      for (int k=0; k < rate; k++) {
        String portReference=compositeActorAdapter.getReference(""String_Node_Str"" + portNameWithChannelNumber + ""String_Node_Str""+ k,false);
        code.append(tokensToThisPort + ""String_Node_Str"" + i+ ""String_Node_Str""+ k+ ""String_Node_Str""+ portReference+ ""String_Node_Str""+ _eol);
      }
    }
    code.append(""String_Node_Str"" + String.valueOf(_portNumber) + ""String_Node_Str""+ tokensToThisPort+ ""String_Node_Str""+ _eol);
    _portNumber++;
  }
 else {
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      if (i < outputPort.getWidth()) {
        String name=outputPort.getName();
        if (outputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(CodeStream.indent(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k,false)));
          code.append(""String_Node_Str"" + _eol);
          code.append(CodeStream.indent(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k,false)));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  _updatePortOffset(outputPort,code,rate);
}"
73847,"/** 
 * Generate code for transferring enough tokens to complete an internal iteration.
 * @param inputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferInputsCode(IOPort inputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenConsumptionRate(inputPort);
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if (container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) {
    if (!(inputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(inputPort,null,""String_Node_Str"");
    }
    Type type=((TypedIOPort)inputPort).getType();
    String portName=inputPort.getName();
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String tokensFromOneChannel=""String_Node_Str"" + portName + i;
        if (type == BaseType.INT) {
          code.append(""String_Node_Str"" + tokensFromOneChannel + ""String_Node_Str""+ portName+ ""String_Node_Str""+ String.valueOf(i)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(""String_Node_Str"" + tokensFromOneChannel + ""String_Node_Str""+ portName+ ""String_Node_Str""+ String.valueOf(i)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(""String_Node_Str"" + tokensFromOneChannel + ""String_Node_Str""+ portName+ ""String_Node_Str""+ String.valueOf(i)+ ""String_Node_Str""+ _eol);
        }
 else {
        }
        String portNameWithChannelNumber=portName;
        if (inputPort.isMultiport()) {
          portNameWithChannelNumber=portName + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(compositeActorAdapter.getReference(""String_Node_Str"" + portNameWithChannelNumber + ""String_Node_Str""+ k));
          code.append(""String_Node_Str"" + tokensFromOneChannel + ""String_Node_Str""+ k+ ""String_Node_Str""+ _eol);
        }
      }
    }
  }
 else {
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String name=inputPort.getName();
        if (inputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k));
          code.append(""String_Node_Str"" + _eol);
          code.append(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  code.append(compositeActorAdapter.generateTypeConvertFireCode(true));
  _updateConnectedPortsOffset(inputPort,code,rate);
}","/** 
 * Generate code for transferring enough tokens to complete an internal iteration.
 * @param inputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferInputsCode(IOPort inputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenConsumptionRate(inputPort);
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if (container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) {
    if (!(inputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(inputPort,null,""String_Node_Str"");
    }
    Type type=((TypedIOPort)inputPort).getType();
    String portName=inputPort.getName();
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String tokensFromOneChannel=""String_Node_Str"" + portName + i;
        if (type == BaseType.INT) {
          code.append(""String_Node_Str"" + tokensFromOneChannel + ""String_Node_Str""+ portName+ ""String_Node_Str""+ String.valueOf(i)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(""String_Node_Str"" + tokensFromOneChannel + ""String_Node_Str""+ portName+ ""String_Node_Str""+ String.valueOf(i)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(""String_Node_Str"" + tokensFromOneChannel + ""String_Node_Str""+ portName+ ""String_Node_Str""+ String.valueOf(i)+ ""String_Node_Str""+ _eol);
        }
 else {
        }
        String portNameWithChannelNumber=portName;
        if (inputPort.isMultiport()) {
          portNameWithChannelNumber=portName + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(compositeActorAdapter.getReference(""String_Node_Str"" + portNameWithChannelNumber + ""String_Node_Str""+ k,false));
          code.append(""String_Node_Str"" + tokensFromOneChannel + ""String_Node_Str""+ k+ ""String_Node_Str""+ _eol);
        }
      }
    }
  }
 else {
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String name=inputPort.getName();
        if (inputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k,false));
          code.append(""String_Node_Str"" + _eol);
          code.append(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k,false));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  code.append(compositeActorAdapter.generateTypeConvertFireCode(true));
  _updateConnectedPortsOffset(inputPort,code,rate);
}"
73848,"/** 
 * Generate the code for the firing of actors according to the SDF schedule.
 * @return The generated fire code.
 * @exception IllegalActionException If the SDF director does not have anattribute called ""iterations"" or a valid schedule, or the actor to be fired cannot find its associated adapter.
 */
public String generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"")));
  boolean inline=((BooleanToken)getCodeGenerator().inline.getToken()).booleanValue();
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    NamedProgramCodeGeneratorAdapter adapter=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
    if (actor instanceof ModularCodeGenTypedCompositeActor || actor instanceof ModularCompiledSDFTypedCompositeActor) {
      String className=NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor);
      String actorName=ModularCodeGenTypedCompositeActor.classToActorName(className);
      NamedProgramCodeGeneratorAdapter codegeneratorAdaptor=(NamedProgramCodeGeneratorAdapter)getAdapter((NamedObj)actor);
      code.append(""String_Node_Str"" + _eol);
      Iterator<?> inputPorts=actor.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
        String type=ptolemy.cg.kernel.generic.program.procedural.java.JavaCodeGenerator.codeGenType2(inputPort.getType());
        for (int i=0; i < inputPort.getWidth(); i++) {
          if (DFUtilities.getTokenConsumptionRate(inputPort) > 1) {
            code.append(type + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ i+ ""String_Node_Str""+ type+ ""String_Node_Str""+ DFUtilities.getTokenConsumptionRate(inputPort)+ ""String_Node_Str""+ _eol);
          }
 else {
            code.append(type + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ i+ ""String_Node_Str""+ _eol);
          }
        }
      }
      for (int j=0; j < firing.getIterationCount(); j++) {
        inputPorts=actor.inputPortList().iterator();
        while (inputPorts.hasNext()) {
          TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
          String portName=inputPort.getName();
          int rate=DFUtilities.getTokenConsumptionRate(inputPort);
          for (int i=0; i < inputPort.getWidth(); i++) {
            if (i < inputPort.getWidthInside()) {
              String portNameWithChannelNumber=portName;
              if (inputPort.isMultiport()) {
                portNameWithChannelNumber=portName + '#' + i;
              }
              if (rate > 1) {
                for (int k=0; k < rate; k++) {
                  code.append(actorName + ""String_Node_Str"" + portName+ ""String_Node_Str""+ i+ ""String_Node_Str""+ k+ ""String_Node_Str"");
                  code.append(codegeneratorAdaptor.getReference(portNameWithChannelNumber + ""String_Node_Str"" + k,true));
                  code.append(""String_Node_Str"" + _eol);
                }
              }
 else {
                code.append(actorName + ""String_Node_Str"" + portName+ ""String_Node_Str""+ i);
                code.append(""String_Node_Str"" + codegeneratorAdaptor.getReference(portNameWithChannelNumber,true) + ""String_Node_Str""+ _eol);
              }
            }
          }
        }
        code.append(actorName + ""String_Node_Str"");
        inputPorts=actor.inputPortList().iterator();
        boolean addComma=false;
        while (inputPorts.hasNext()) {
          TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
          for (int i=0; i < inputPort.getWidth(); i++) {
            if (addComma) {
              code.append(""String_Node_Str"");
            }
            code.append(actorName + ""String_Node_Str"" + inputPort.getName()+ ""String_Node_Str""+ i);
            addComma=true;
          }
        }
        code.append(""String_Node_Str"" + _eol);
        _generateUpdatePortOffsetCode(code,actor);
        Iterator<?> outputPorts=actor.outputPortList().iterator();
        while (outputPorts.hasNext()) {
          TypedIOPort outputPort=(TypedIOPort)outputPorts.next();
          int rate=DFUtilities.getTokenProductionRate(outputPort);
          for (int i=0; i < outputPort.getWidth(); i++) {
            if (rate <= 1) {
              code.append(codegeneratorAdaptor.getReference(outputPort.getName() + ""String_Node_Str"" + i,true) + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ codegeneratorAdaptor.getReference(""String_Node_Str"" + outputPort.getName() + ""String_Node_Str""+ i,false)+ ""String_Node_Str""+ _eol);
            }
 else {
              for (int k=0; k < rate; k++) {
                code.append(codegeneratorAdaptor.getReference(outputPort.getName() + ""String_Node_Str"" + i+ ""String_Node_Str""+ k,true) + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ codegeneratorAdaptor.getReference(""String_Node_Str"" + outputPort.getName() + ""String_Node_Str""+ i+ ""String_Node_Str""+ k,false)+ ""String_Node_Str""+ _eol);
              }
            }
          }
        }
      }
      code.append(""String_Node_Str"" + _eol);
    }
 else {
      if (inline) {
        for (int i=0; i < firing.getIterationCount(); i++) {
          code.append(adapter.generateFireCode());
          _generateUpdatePortOffsetCode(code,actor);
        }
      }
 else {
        int count=firing.getIterationCount();
        if (count > 1) {
          code.append(""String_Node_Str"" + count + ""String_Node_Str""+ _eol);
        }
        code.append(generateName((NamedObj)actor) + ""String_Node_Str"" + _eol);
        _generateUpdatePortOffsetCode(code,actor);
        if (count > 1) {
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  return code.toString();
}","/** 
 * Generate the code for the firing of actors according to the SDF schedule.
 * @return The generated fire code.
 * @exception IllegalActionException If the SDF director does not have anattribute called ""iterations"" or a valid schedule, or the actor to be fired cannot find its associated adapter.
 */
public String generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"")));
  boolean inline=((BooleanToken)getCodeGenerator().inline.getToken()).booleanValue();
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    NamedProgramCodeGeneratorAdapter adapter=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
    if (actor instanceof ModularCodeGenTypedCompositeActor || actor instanceof ModularCompiledSDFTypedCompositeActor) {
      String className=NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor);
      String actorName=ModularCodeGenTypedCompositeActor.classToActorName(className);
      NamedProgramCodeGeneratorAdapter codegeneratorAdaptor=(NamedProgramCodeGeneratorAdapter)getAdapter((NamedObj)actor);
      code.append(""String_Node_Str"" + _eol);
      Iterator<?> inputPorts=actor.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
        String type=ptolemy.cg.kernel.generic.program.procedural.java.JavaCodeGenerator.codeGenType2(inputPort.getType());
        for (int i=0; i < inputPort.getWidth(); i++) {
          if (DFUtilities.getTokenConsumptionRate(inputPort) > 1) {
            code.append(type + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ i+ ""String_Node_Str""+ type+ ""String_Node_Str""+ DFUtilities.getTokenConsumptionRate(inputPort)+ ""String_Node_Str""+ _eol);
          }
 else {
            code.append(type + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ i+ ""String_Node_Str""+ _eol);
          }
        }
      }
      for (int j=0; j < firing.getIterationCount(); j++) {
        inputPorts=actor.inputPortList().iterator();
        while (inputPorts.hasNext()) {
          TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
          String portName=inputPort.getName();
          int rate=DFUtilities.getTokenConsumptionRate(inputPort);
          for (int i=0; i < inputPort.getWidth(); i++) {
            if (i < inputPort.getWidthInside()) {
              String portNameWithChannelNumber=portName;
              if (inputPort.isMultiport()) {
                portNameWithChannelNumber=portName + '#' + i;
              }
              if (rate > 1) {
                for (int k=0; k < rate; k++) {
                  code.append(actorName + ""String_Node_Str"" + portName+ ""String_Node_Str""+ i+ ""String_Node_Str""+ k+ ""String_Node_Str"");
                  code.append(codegeneratorAdaptor.getReference(portNameWithChannelNumber + ""String_Node_Str"" + k,true));
                  code.append(""String_Node_Str"" + _eol);
                }
              }
 else {
                code.append(actorName + ""String_Node_Str"" + portName+ ""String_Node_Str""+ i);
                code.append(""String_Node_Str"" + codegeneratorAdaptor.getReference(portNameWithChannelNumber,true) + ""String_Node_Str""+ _eol);
              }
            }
          }
        }
        code.append(actorName + ""String_Node_Str"");
        inputPorts=actor.inputPortList().iterator();
        boolean addComma=false;
        while (inputPorts.hasNext()) {
          TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
          for (int i=0; i < inputPort.getWidth(); i++) {
            if (addComma) {
              code.append(""String_Node_Str"");
            }
            code.append(actorName + ""String_Node_Str"" + inputPort.getName()+ ""String_Node_Str""+ i);
            addComma=true;
          }
        }
        code.append(""String_Node_Str"" + _eol);
        Iterator<?> outputPorts=actor.outputPortList().iterator();
        while (outputPorts.hasNext()) {
          TypedIOPort outputPort=(TypedIOPort)outputPorts.next();
          int rate=DFUtilities.getTokenProductionRate(outputPort);
          for (int i=0; i < outputPort.getWidth(); i++) {
            if (rate <= 1) {
              code.append(codegeneratorAdaptor.getReference(outputPort.getName() + ""String_Node_Str"" + i,true) + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ codegeneratorAdaptor.getReference(""String_Node_Str"" + outputPort.getName() + ""String_Node_Str""+ i,false)+ ""String_Node_Str""+ _eol);
            }
 else {
              for (int k=0; k < rate; k++) {
                code.append(codegeneratorAdaptor.getReference(outputPort.getName() + ""String_Node_Str"" + i+ ""String_Node_Str""+ k,true) + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ codegeneratorAdaptor.getReference(""String_Node_Str"" + outputPort.getName() + ""String_Node_Str""+ i+ ""String_Node_Str""+ k,false)+ ""String_Node_Str""+ _eol);
              }
            }
          }
        }
        _generateUpdatePortOffsetCode(code,actor);
      }
      code.append(""String_Node_Str"" + _eol);
    }
 else {
      if (inline) {
        for (int i=0; i < firing.getIterationCount(); i++) {
          code.append(adapter.generateFireCode());
          _generateUpdatePortOffsetCode(code,actor);
        }
      }
 else {
        int count=firing.getIterationCount();
        if (count > 1) {
          code.append(""String_Node_Str"" + count + ""String_Node_Str""+ _eol);
        }
        code.append(generateName((NamedObj)actor) + ""String_Node_Str"" + _eol);
        _generateUpdatePortOffsetCode(code,actor);
        if (count > 1) {
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  return code.toString();
}"
73849,"/** 
 * Generate the code for the firing of actors according to the SDF schedule.
 * @return The generated fire code.
 * @exception IllegalActionException If the SDF director does not have anattribute called ""iterations"" or a valid schedule, or the actor to be fired cannot find its associated adapter.
 */
public String generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"")));
  boolean inline=((BooleanToken)getCodeGenerator().inline.getToken()).booleanValue();
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    NamedProgramCodeGeneratorAdapter adapter=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
    if (actor instanceof ModularCodeGenTypedCompositeActor || actor instanceof ModularCompiledSDFTypedCompositeActor) {
      String className=NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor);
      String actorName=ModularCodeGenTypedCompositeActor.classToActorName(className);
      code.append(actorName + ""String_Node_Str"");
      NamedProgramCodeGeneratorAdapter codegeneratorAdaptor=(NamedProgramCodeGeneratorAdapter)getAdapter((NamedObj)actor);
      Iterator<?> inputPorts=actor.inputPortList().iterator();
      boolean addComma=false;
      while (inputPorts.hasNext()) {
        TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
        for (int i=0; i < inputPort.getWidth(); i++) {
          if (addComma) {
            code.append(""String_Node_Str"");
          }
          code.append(codegeneratorAdaptor.getReference(inputPort.getName() + ""String_Node_Str"" + i));
          addComma=true;
        }
      }
      code.append(""String_Node_Str"" + _eol);
      Iterator<?> outputPorts=actor.outputPortList().iterator();
      while (outputPorts.hasNext()) {
        TypedIOPort outputPort=(TypedIOPort)outputPorts.next();
        int rate=DFUtilities.getTokenProductionRate(outputPort);
        for (int i=0; i < outputPort.getWidth(); i++) {
          if (rate <= 1) {
            code.append(codegeneratorAdaptor.getReference(outputPort.getName() + ""String_Node_Str"" + i) + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ codegeneratorAdaptor.getReference(""String_Node_Str"" + outputPort.getName() + ""String_Node_Str""+ i)+ ""String_Node_Str""+ _eol);
          }
 else {
            for (int k=0; k < rate; k++) {
              code.append(codegeneratorAdaptor.getReference(outputPort.getName() + ""String_Node_Str"" + i) + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ codegeneratorAdaptor.getReference(""String_Node_Str"" + outputPort.getName() + ""String_Node_Str""+ i)+ ""String_Node_Str""+ _eol);
            }
          }
        }
      }
    }
 else {
      if (inline) {
        for (int i=0; i < firing.getIterationCount(); i++) {
          code.append(adapter.generateFireCode());
          _generateUpdatePortOffsetCode(code,actor);
        }
      }
 else {
        int count=firing.getIterationCount();
        if (count > 1) {
          code.append(""String_Node_Str"" + count + ""String_Node_Str""+ _eol);
        }
        code.append(generateName((NamedObj)actor) + ""String_Node_Str"" + _eol);
        _generateUpdatePortOffsetCode(code,actor);
        if (count > 1) {
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  return code.toString();
}","/** 
 * Generate the code for the firing of actors according to the SDF schedule.
 * @return The generated fire code.
 * @exception IllegalActionException If the SDF director does not have anattribute called ""iterations"" or a valid schedule, or the actor to be fired cannot find its associated adapter.
 */
public String generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"")));
  boolean inline=((BooleanToken)getCodeGenerator().inline.getToken()).booleanValue();
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    NamedProgramCodeGeneratorAdapter adapter=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
    if (actor instanceof ModularCodeGenTypedCompositeActor || actor instanceof ModularCompiledSDFTypedCompositeActor) {
      String className=NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor);
      String actorName=ModularCodeGenTypedCompositeActor.classToActorName(className);
      code.append(actorName + ""String_Node_Str"");
      NamedProgramCodeGeneratorAdapter codegeneratorAdaptor=(NamedProgramCodeGeneratorAdapter)getAdapter((NamedObj)actor);
      Iterator<?> inputPorts=actor.inputPortList().iterator();
      boolean addComma=false;
      while (inputPorts.hasNext()) {
        TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
        for (int i=0; i < inputPort.getWidth(); i++) {
          if (addComma) {
            code.append(""String_Node_Str"");
          }
          code.append(codegeneratorAdaptor.getReference(inputPort.getName() + ""String_Node_Str"" + i));
          addComma=true;
        }
      }
      code.append(""String_Node_Str"" + _eol);
      Iterator<?> outputPorts=actor.outputPortList().iterator();
      while (outputPorts.hasNext()) {
        TypedIOPort outputPort=(TypedIOPort)outputPorts.next();
        int rate=DFUtilities.getTokenProductionRate(outputPort);
        for (int i=0; i < outputPort.getWidth(); i++) {
          if (rate <= 1) {
            code.append(codegeneratorAdaptor.getReference(outputPort.getName() + ""String_Node_Str"" + i) + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ codegeneratorAdaptor.getReference(""String_Node_Str"" + outputPort.getName() + ""String_Node_Str""+ i)+ ""String_Node_Str""+ _eol);
          }
 else {
            for (int k=0; k < rate; k++) {
              code.append(codegeneratorAdaptor.getReference(outputPort.getName() + ""String_Node_Str"" + i+ ""String_Node_Str""+ k) + ""String_Node_Str"" + actorName+ ""String_Node_Str""+ codegeneratorAdaptor.getReference(""String_Node_Str"" + outputPort.getName() + ""String_Node_Str""+ i+ ""String_Node_Str""+ k)+ ""String_Node_Str""+ _eol);
            }
          }
        }
      }
    }
 else {
      if (inline) {
        for (int i=0; i < firing.getIterationCount(); i++) {
          code.append(adapter.generateFireCode());
          _generateUpdatePortOffsetCode(code,actor);
        }
      }
 else {
        int count=firing.getIterationCount();
        if (count > 1) {
          code.append(""String_Node_Str"" + count + ""String_Node_Str""+ _eol);
        }
        code.append(generateName((NamedObj)actor) + ""String_Node_Str"" + _eol);
        _generateUpdatePortOffsetCode(code,actor);
        if (count > 1) {
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  return code.toString();
}"
73850,"/** 
 * Return the WCET of the actors. The Worst-Case Execution Time (WCET) of an actor is the maximum length of time  the task could take to execute on a particular platform
 */
public double _getWCET() throws IllegalActionException {
  double wcet=0;
  double actorFrequency=0;
  double actorWCET=0;
  int actorCount=0;
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)this.getContainer()).deepEntityList()) {
    actorCount++;
    Attribute frequency=((Entity)actor).getAttribute(""String_Node_Str"");
    actor.getDirector();
    Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
    if (!(actor instanceof ptolemy.domains.giotto.lib.GiottoError)) {
      if (actor instanceof CompositeActor) {
        if (_debugging) {
        }
        Director dir=actor.getDirector();
        if (_debugging) {
        }
        if (dir == null) {
          if (_debugging) {
          }
        }
 else {
          double dummyWCET=0.0011;
          Attribute dirWCET=dir.getAttribute(""String_Node_Str"");
          if (dirWCET != null) {
            dummyWCET=((DoubleToken)((Variable)dirWCET).getToken()).doubleValue();
          }
          if (_debugging) {
          }
          wcet+=dummyWCET;
        }
      }
 else {
        if (WCET == null) {
          actorWCET=0.0;
        }
 else {
          try {
            actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
          }
 catch (          Exception e2) {
            actorWCET=((IntToken)((Variable)WCET).getToken()).intValue();
          }
        }
        if (frequency == null) {
          actorFrequency=1;
        }
 else {
          actorFrequency=((IntToken)((Variable)frequency).getToken()).intValue();
        }
        wcet+=(actorFrequency * actorWCET);
      }
    }
    if (_debugging) {
    }
  }
  return wcet;
}","/** 
 * Return the WCET of the actors. The Worst-Case Execution Time (WCET) of an actor is the maximum length of time  the task could take to execute on a particular platform
 * @return A double containing the WCET of the actors
 * @throws IllegalActionException If an error occurs
 */
public double _getWCET() throws IllegalActionException {
  double wcet=0;
  double actorFrequency=0;
  double actorWCET=0;
  int actorCount=0;
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)this.getContainer()).deepEntityList()) {
    actorCount++;
    Attribute frequency=((Entity)actor).getAttribute(""String_Node_Str"");
    actor.getDirector();
    Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
    if (!(actor instanceof ptolemy.domains.giotto.lib.GiottoError)) {
      if (actor instanceof CompositeActor) {
        if (_debugging) {
        }
        Director dir=actor.getDirector();
        if (_debugging) {
        }
        if (dir == null) {
          if (_debugging) {
          }
        }
 else {
          double dummyWCET=0.0011;
          Attribute dirWCET=dir.getAttribute(""String_Node_Str"");
          if (dirWCET != null) {
            dummyWCET=((DoubleToken)((Variable)dirWCET).getToken()).doubleValue();
          }
          if (_debugging) {
          }
          wcet+=dummyWCET;
        }
      }
 else {
        if (WCET == null) {
          actorWCET=0.0;
        }
 else {
          try {
            actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
          }
 catch (          Exception e2) {
            actorWCET=((IntToken)((Variable)WCET).getToken()).intValue();
          }
        }
        if (frequency == null) {
          actorFrequency=1;
        }
 else {
          actorFrequency=((IntToken)((Variable)frequency).getToken()).intValue();
        }
        wcet+=(actorFrequency * actorWCET);
      }
    }
    if (_debugging) {
    }
  }
  return wcet;
}"
73851,"/** 
 * Invoke the Yices SMT solver on the given formula, saving the results in the given file. This method attempts to interface with the solver using the Yices Java API Lite.  We use reflection here to ensure the code will compile even without Yices installed. If we encounter a problem here, we assume it is because Yices is not installed and notify the user accordingly.
 * @param formula The formula to be checked for satisfiability.
 * @param tmpfile The file to save the results in.
 */
private void runYices(final String formula,final File tmpfile){
  final String fileName=tmpfile.getAbsolutePath();
  try {
    ClassLoader myClassLoader=ClassLoader.getSystemClassLoader();
    Class<?> yicesClass=myClassLoader.loadClass(""String_Node_Str"");
    Object yicesLite=yicesClass.newInstance();
    Method makeContext=yicesClass.getMethod(""String_Node_Str"",new Class[]{});
    Method setOutputFile=yicesClass.getMethod(""String_Node_Str"",new Class[]{String.class});
    Method readFormula=yicesClass.getMethod(""String_Node_Str"",new Class[]{Integer.class,String.class});
    Method deleteContext=yicesClass.getMethod(""String_Node_Str"",new Class[]{Integer.class});
    final int ctx=(Integer)makeContext.invoke(yicesLite,new Object[]{});
    setOutputFile.invoke(yicesLite,new Object[]{fileName});
    readFormula.invoke(yicesLite,new Object[]{ctx,formula});
    deleteContext.invoke(yicesLite,new Object[]{ctx});
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    e.printStackTrace();
  }
}","/** 
 * Invoke the Yices SMT solver on the given formula, saving the results in the given file. This method attempts to interface with the solver using the Yices Java API Lite.  We use reflection here to ensure the code will compile even without Yices installed. If we encounter a problem here, we assume it is because Yices is not installed and notify the user accordingly.
 * @param formula The formula to be checked for satisfiability.
 * @param tmpfile The file to save the results in.
 */
private void runYices(final String formula,final File tmpfile){
  final String fileName=tmpfile.getAbsolutePath();
  try {
    ClassLoader myClassLoader=ClassLoader.getSystemClassLoader();
    Class<?> yicesClass=myClassLoader.loadClass(""String_Node_Str"");
    Object yicesLite=yicesClass.newInstance();
    Method makeContext=yicesClass.getMethod(""String_Node_Str"",new Class[]{});
    Method setOutputFile=yicesClass.getMethod(""String_Node_Str"",new Class[]{String.class});
    Method readFormula=yicesClass.getMethod(""String_Node_Str"",new Class[]{int.class,String.class});
    Method deleteContext=yicesClass.getMethod(""String_Node_Str"",new Class[]{int.class});
    final int ctx=(Integer)makeContext.invoke(yicesLite,new Object[]{});
    setOutputFile.invoke(yicesLite,new Object[]{fileName});
    readFormula.invoke(yicesLite,new Object[]{ctx,formula});
    deleteContext.invoke(yicesLite,new Object[]{ctx});
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    e.printStackTrace();
  }
}"
73852,"/** 
 * Returns the LCM value.
 */
public int getLCM(){
  return _lcm;
}","/** 
 * Returns the LCM value.
 * @return an int representing the LCM value
 */
public int getLCM(){
  return _lcm;
}"
73853,"/** 
 * Called each time the SAX parser sees the beginning of an element
 * @param uri The Namespace Uniform Resource Identifier(URI)
 * @param name Is the elements local name
 * @param qName Is the XML 1.0 name 
 */
public void startElement(String uri,String name,String qName,Attributes atts){
  String tempString;
  if (""String_Node_Str"".equals(uri)) {
    if (""String_Node_Str"".equals(qName) || ""String_Node_Str"".equals(qName)) {
      _startVar=true;
      if (""String_Node_Str"".equals(qName)) {
        _toDefuzzyify=_currentIndex;
      }
      int index=atts.getIndex(""String_Node_Str"");
      if (""String_Node_Str"".equals(qName)) {
        _fuzzyVar.name=atts.getValue(index);
      }
      _linguisticVarArray.add(new LinguisticVariable(atts.getValue(index)));
    }
    if (""String_Node_Str"".equals(qName)) {
      if (_startVar == true) {
        String localName=atts.getValue(0);
        StringTokenizer st=new StringTokenizer(atts.getValue(1),""String_Node_Str"");
        double a=Double.valueOf(st.nextToken().trim()).doubleValue();
        double b=Double.valueOf(st.nextToken().trim()).doubleValue();
        double c=Double.valueOf(st.nextToken().trim()).doubleValue();
        double d=Double.valueOf(st.nextToken().trim()).doubleValue();
        (_linguisticVarArray.get(_currentIndex)).add(localName,a,b,c,d);
        tempString=localName + ""String_Node_Str"" + (a + d) / 2;
        _fuzzyVar.termNames.add(tempString);
      }
    }
    if (""String_Node_Str"".equals(qName)) {
      _myRules.add(atts.getValue(1));
    }
  }
 else {
    if (_debugging) {
      System.out.println(""String_Node_Str"" + uri + ""String_Node_Str""+ name);
    }
  }
}","/** 
 * Called each time the SAX parser sees the beginning of an element.
 * @param uri The Namespace Uniform Resource Identifier(URI)
 * @param name Is the elements local name
 * @param qName Is the XML 1.0 name 
 * @param atts An Attributes object
 */
public void startElement(String uri,String name,String qName,Attributes atts){
  String tempString;
  if (""String_Node_Str"".equals(uri)) {
    if (""String_Node_Str"".equals(qName) || ""String_Node_Str"".equals(qName)) {
      _startVar=true;
      if (""String_Node_Str"".equals(qName)) {
        _toDefuzzyify=_currentIndex;
      }
      int index=atts.getIndex(""String_Node_Str"");
      if (""String_Node_Str"".equals(qName)) {
        _fuzzyVar.name=atts.getValue(index);
      }
      _linguisticVarArray.add(new LinguisticVariable(atts.getValue(index)));
    }
    if (""String_Node_Str"".equals(qName)) {
      if (_startVar == true) {
        String localName=atts.getValue(0);
        StringTokenizer st=new StringTokenizer(atts.getValue(1),""String_Node_Str"");
        double a=Double.valueOf(st.nextToken().trim()).doubleValue();
        double b=Double.valueOf(st.nextToken().trim()).doubleValue();
        double c=Double.valueOf(st.nextToken().trim()).doubleValue();
        double d=Double.valueOf(st.nextToken().trim()).doubleValue();
        (_linguisticVarArray.get(_currentIndex)).add(localName,a,b,c,d);
        tempString=localName + ""String_Node_Str"" + (a + d) / 2;
        _fuzzyVar.termNames.add(tempString);
      }
    }
    if (""String_Node_Str"".equals(qName)) {
      _myRules.add(atts.getValue(1));
    }
  }
 else {
    if (_debugging) {
      System.out.println(""String_Node_Str"" + uri + ""String_Node_Str""+ name);
    }
  }
}"
73854,"/** 
 * Called once when the SAX driver sees the end of a document, even if errors occured.
 */
public void endDocument(){
}","/** 
 * Called once when the SAX driver sees the end of a document, even if errors occurred.
 */
public void endDocument(){
}"
73855,"/** 
 * Return the array list index of the variable to be defuzzified. 
 */
public int getIndexToDefuzzify(){
  return _toDefuzzyify;
}","/** 
 * Return the array list index of the variable to be defuzzified. 
 * @return Return the array list index of the variable to be defuzzified.
 */
public int getIndexToDefuzzify(){
  return _toDefuzzyify;
}"
73856,"/** 
 * Called each time the SAX parser sees the end of an element
 * @param uri The Namespace Uniform Resource Identifier(URI)
 * @param name Is the elements local name
 * @param qName Is the XML 1.0 name 
 */
public void endElement(String uri,String name,String qName){
  if (""String_Node_Str"".equals(uri)) {
    if (""String_Node_Str"".equals(qName) || ""String_Node_Str"".equals(qName)) {
      _startVar=false;
      _currentIndex++;
      if (""String_Node_Str"".equals(qName)) {
        _fuzzyLogicVariableArray.add(_fuzzyVar);
        _fuzzyVar=new FuzzyLogicVar();
      }
    }
    if (""String_Node_Str"".equals(qName)) {
    }
  }
 else {
    if (_debugging) {
      System.out.println(""String_Node_Str"" + uri + ""String_Node_Str""+ name);
    }
  }
}","/** 
 * Called each time the SAX parser sees the end of an element.
 * @param uri The Namespace Uniform Resource Identifier(URI)
 * @param name Is the elements local name
 * @param qName Is the XML 1.0 name 
 */
public void endElement(String uri,String name,String qName){
  if (""String_Node_Str"".equals(uri)) {
    if (""String_Node_Str"".equals(qName) || ""String_Node_Str"".equals(qName)) {
      _startVar=false;
      _currentIndex++;
      if (""String_Node_Str"".equals(qName)) {
        _fuzzyLogicVariableArray.add(_fuzzyVar);
        _fuzzyVar=new FuzzyLogicVar();
      }
    }
    if (""String_Node_Str"".equals(qName)) {
    }
  }
 else {
    if (_debugging) {
      System.out.println(""String_Node_Str"" + uri + ""String_Node_Str""+ name);
    }
  }
}"
73857,"/** 
 * Return an array of fuzzy logic variables read from the xml file. 
 */
public ArrayList<FuzzyLogicVar> getFuzzyLogicVariableArray(){
  return _fuzzyLogicVariableArray;
}","/** 
 * Return an array of fuzzy logic variables read from the xml file. 
 * @return Return an array of fuzzy logic variables read from the xml file.
 */
public ArrayList<FuzzyLogicVar> getFuzzyLogicVariableArray(){
  return _fuzzyLogicVariableArray;
}"
73858,"/** 
 * Return a string representation of the rules specified in the xml file.
 */
public ArrayList<String> getRules(){
  return _myRules;
}","/** 
 * Return a string representation of the rules specified in the xml file.
 * @return Return a string representation of the rules specified inthe xml file.
 */
public ArrayList<String> getRules(){
  return _myRules;
}"
73859,"/** 
 * Return the name of the architecture. 
 */
public String getName(){
  return name;
}","/** 
 * Return the name of the architecture.
 * @return The name of the architecture 
 */
public String getName(){
  return name;
}"
73860,"/** 
 * Called each time the SAX parser sees the beginning of an element.
 * @param uri The Namespace Uniform Resource Identifier(URI)
 * @param name Is the elements local name
 * @param qName Is the XML 1.0 name 
 * @param atts   an Attributes object
 */
public void startElement(String uri,String name,String qName,Attributes atts){
  if (""String_Node_Str"".equals(uri)) {
    if (_debugging) {
      System.out.println(""String_Node_Str"" + qName);
    }
    if (""String_Node_Str"".equals(qName)) {
      _startArchitecture=true;
    }
 else     if (""String_Node_Str"".equals(qName)) {
      _startOption=true;
    }
 else     if (""String_Node_Str"".equals(qName)) {
      _startDimension=true;
    }
  }
 else {
    if (""String_Node_Str"".equals(name)) {
      _startArchitecture=true;
    }
 else     if (""String_Node_Str"".equals(name)) {
      _startOption=true;
    }
 else     if (""String_Node_Str"".equals(name)) {
      _startDimension=true;
    }
    if (_debugging) {
      System.out.println(""String_Node_Str"" + uri + ""String_Node_Str""+ name);
      System.out.println(""String_Node_Str"");
    }
  }
}","/** 
 * Called each time the SAX parser sees the beginning of an element.
 * @param uri The Namespace Uniform Resource Identifier(URI)
 * @param name Is the elements local name
 * @param qName Is the XML 1.0 name 
 * @param atts  An Attributes object
 */
public void startElement(String uri,String name,String qName,Attributes atts){
  if (""String_Node_Str"".equals(uri)) {
    if (_debugging) {
      System.out.println(""String_Node_Str"" + qName);
    }
    if (""String_Node_Str"".equals(qName)) {
      _startArchitecture=true;
    }
 else     if (""String_Node_Str"".equals(qName)) {
      _startOption=true;
    }
 else     if (""String_Node_Str"".equals(qName)) {
      _startDimension=true;
    }
  }
 else {
    if (""String_Node_Str"".equals(name)) {
      _startArchitecture=true;
    }
 else     if (""String_Node_Str"".equals(name)) {
      _startOption=true;
    }
 else     if (""String_Node_Str"".equals(name)) {
      _startDimension=true;
    }
    if (_debugging) {
      System.out.println(""String_Node_Str"" + uri + ""String_Node_Str""+ name);
      System.out.println(""String_Node_Str"");
    }
  }
}"
73861,"/** 
 * Return the display name for the option. 
 */
public String displayName(){
  return _name;
}","/** 
 * Return the display name for the option.
 * @return The display name for the option. 
 */
public String displayName(){
  return _name;
}"
73862,"/** 
 * Parse the XML output from the Trade Space Specification Tool and create a MoML representation of the architecture model. <p>To run this application: <pre> java -classpath $PTII ptolemy.actor.lib.logic.fuzzy.CombinedFile TSSTOutput.xml </pre> where <code>TSSTOutput.xml</code> is the output from the Trade  Space Specification Tool. Note: This argument is optional. If it is not provided the user  will be prompted for a filename. </p>
 * @param args with inputs to the main method.Inputs are currently not used
 */
public static void main(String args[]) throws IllegalActionException {
  BufferedReader reader=null;
  String fileName=null;
  try {
    if (args.length < 1) {
      System.out.println(""String_Node_Str"");
      try {
        reader=new BufferedReader(new InputStreamReader(System.in));
        fileName=reader.readLine();
      }
 catch (      IOException ex) {
        throw new IllegalActionException(null,ex,""String_Node_Str"");
      }
 finally {
        if (reader != null) {
          try {
            reader.close();
          }
 catch (          IOException ex) {
            throw new IllegalActionException(null,ex,""String_Node_Str"");
          }
        }
      }
    }
 else {
      fileName=args[0];
    }
    if (fileName != null) {
      ModelCreator cF=new ModelCreator(fileName);
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(1);
  }
 finally {
    if (reader != null) {
      try {
        reader.close();
      }
 catch (      IOException ex) {
        throw new IllegalActionException(null,ex,""String_Node_Str"" + fileName + ""String_Node_Str"");
      }
    }
  }
  System.exit(0);
}","/** 
 * Parse the XML output from the Trade Space Specification Tool and create a MoML representation of the architecture model. <p>To run this application: <pre> java -classpath $PTII ptolemy.actor.lib.logic.fuzzy.CombinedFile TSSTOutput.xml </pre> where <code>TSSTOutput.xml</code> is the output from the Trade  Space Specification Tool. Note: This argument is optional. If it is not provided the user  will be prompted for a filename. </p>
 * @param args with inputs to the main method.
 * @exception Exception If the input file cannot be read orparsed. Inputs are currently not used
 */
public static void main(String args[]) throws IllegalActionException {
  BufferedReader reader=null;
  String fileName=null;
  try {
    if (args.length < 1) {
      System.out.println(""String_Node_Str"");
      try {
        reader=new BufferedReader(new InputStreamReader(System.in));
        fileName=reader.readLine();
      }
 catch (      IOException ex) {
        throw new IllegalActionException(null,ex,""String_Node_Str"");
      }
 finally {
        if (reader != null) {
          try {
            reader.close();
          }
 catch (          IOException ex) {
            throw new IllegalActionException(null,ex,""String_Node_Str"");
          }
        }
      }
    }
 else {
      fileName=args[0];
    }
    if (fileName != null) {
      ModelCreator cF=new ModelCreator(fileName);
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(1);
  }
 finally {
    if (reader != null) {
      try {
        reader.close();
      }
 catch (      IOException ex) {
        throw new IllegalActionException(null,ex,""String_Node_Str"" + fileName + ""String_Node_Str"");
      }
    }
  }
  System.exit(0);
}"
73863,"/** 
 * Return an array list consisting of the components/options in the architecture. 
 */
public ArrayList<String> getComponents(){
  ArrayList<String> componentNames=new ArrayList<String>();
  Option option;
  for (int i=0; i < this.myOptions.size(); i++) {
    option=(Option)myOptions.get(i);
    componentNames.add(option._name + ""String_Node_Str"" + option._relatedDimensions.get(0).toString());
  }
  return componentNames;
}","/** 
 * Return an array list consisting of the components/options in the architecture.
 * @return An array list consisting of the components/options in the architecture. 
 */
public ArrayList<String> getComponents(){
  ArrayList<String> componentNames=new ArrayList<String>();
  Option option;
  for (int i=0; i < this.myOptions.size(); i++) {
    option=(Option)myOptions.get(i);
    componentNames.add(option._name + ""String_Node_Str"" + option._relatedDimensions.get(0).toString());
  }
  return componentNames;
}"
73864,"/** 
 * Generate the assembly file associated for this PtidyOS program. Here we return an empty string, but the target specific adapter should overwrite it.
 * @return The generated assembly file code.
 * @exception IllegalActionException
 */
public StringBuffer generateAsseblyFile() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  Map devices=new HashMap<Actor,String>();
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)getComponent().getContainer()).deepEntityList()) {
    if (actor instanceof LuminarySensorInputDevice) {
      devices.put(actor,new String(""String_Node_Str"" + NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor)));
    }
  }
  List args=new LinkedList();
  StringBuffer externs=new StringBuffer();
  for (  Actor actor : (Set<Actor>)devices.keySet()) {
    externs.append(""String_Node_Str"" + devices.get(actor) + _eol);
  }
  args.add(externs.toString());
  int configurationSize=LuminarySensorInputDevice.numberOfSupportedInputDeviceConfigurations;
  String[] GPHandlers=new String[configurationSize];
  boolean foundConfig=false;
  for (  LuminarySensorInputDevice actor : (Set<LuminarySensorInputDevice>)devices.keySet()) {
    for (int i=0; i < actor.supportedConfigurations().size(); i++) {
      if (actor.configuration().compareTo(actor.supportedConfigurations().get(i)) == 0) {
        if (1 == 1) {
          throw new RuntimeException(""String_Node_Str"");
        }
        foundConfig=true;
        break;
      }
    }
    if (foundConfig == false) {
      throw new IllegalActionException(actor,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  for (int i=0; i < configurationSize; i++) {
    if (GPHandlers[i] == null) {
      args.add(""String_Node_Str"");
    }
 else {
      args.add(GPHandlers[i]);
    }
  }
  code.append(_templateParser.getCodeStream().getCodeBlock(""String_Node_Str"",args));
  return code;
}","/** 
 * Generate the assembly file associated for this PtidyOS program. Here we return an empty string, but the target specific adapter should overwrite it.
 * @return The generated assembly file code.
 * @exception IllegalActionException
 */
public StringBuffer generateAsseblyFile() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  Map devices=new HashMap<Actor,String>();
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)getComponent().getContainer()).deepEntityList()) {
    if (actor instanceof LuminarySensorInputDevice) {
      devices.put(actor,new String(""String_Node_Str"" + NamedProgramCodeGeneratorAdapter.generateName((NamedObj)actor)));
    }
  }
  List args=new LinkedList();
  StringBuffer externs=new StringBuffer();
  for (  Actor actor : (Set<Actor>)devices.keySet()) {
    externs.append(""String_Node_Str"" + devices.get(actor) + _eol);
  }
  args.add(externs.toString());
  int configurationSize=LuminarySensorInputDevice.numberOfSupportedInputDeviceConfigurations;
  String[] GPHandlers=new String[configurationSize];
  boolean foundConfig=false;
  for (  LuminarySensorInputDevice actor : (Set<LuminarySensorInputDevice>)devices.keySet()) {
    for (int i=0; i < actor.supportedConfigurations().size(); i++) {
      if (actor.configuration().compareTo(actor.supportedConfigurations().get(i)) == 0) {
        GPHandlers[i + Integer.parseInt(actor.startingConfiguration())]=(String)devices.get(actor);
        foundConfig=true;
        break;
      }
    }
    if (foundConfig == false) {
      throw new IllegalActionException(actor,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  for (int i=0; i < configurationSize; i++) {
    if (GPHandlers[i] == null) {
      args.add(""String_Node_Str"");
    }
 else {
      args.add(GPHandlers[i]);
    }
  }
  code.append(_templateParser.getCodeStream().getCodeBlock(""String_Node_Str"",args));
  return code;
}"
73865,"/** 
 * There is a default configuration, which is returned.
 * @return The default configuration.
 */
abstract String startingConfiguration();","/** 
 * There is a default configuration, which is returned.
 * @return The default configuration.
 */
abstract public String startingConfiguration();"
73866,"/** 
 * Returns the RTMmodule value.
 */
public Map<String,String> getRTMmodule(){
  return RTMmodule;
}","/** 
 * Returns the RTMmodule value.
 * @return a Map object representing the RTMmodule value
 */
public Map<String,String> getRTMmodule(){
  return RTMmodule;
}"
73867,"/** 
 * Returns the id table value.
 */
public Map<String,Set<String>> getIdTable(){
  return idTable;
}","/** 
 * Returns the id table value.
 * @return a Map object representing the id table value
 */
public Map<String,Set<String>> getIdTable(){
  return idTable;
}"
73868,"/** 
 * Called by the SAX parser to report regular characters.
 * @param ch[] The array containing characters
 * @param start Is the starting point in the character array
 * @param lenght Is length of the character array 
 */
public void characters(char ch[],int start,int length){
  if (_startArchitecture == true) {
    _startArchitecture=false;
    StringBuffer tempBuff=new StringBuffer();
    tempBuff.append(ch,start,length);
    architecture.name=tempBuff.toString();
    if (_debugging) {
      System.out.println(""String_Node_Str"" + architecture.name);
    }
  }
 else   if (_startOption == true) {
    _startOption=false;
    StringBuffer tempBuff=new StringBuffer();
    tempBuff.append(ch,start,length);
    _option._name=tempBuff.toString();
    if (_debugging) {
      System.out.println(""String_Node_Str"" + _option._name);
    }
  }
 else   if (_startDimension == true) {
    _startDimension=false;
    StringBuffer tempBuff=new StringBuffer();
    tempBuff.append(ch,start,length);
    _option._relatedDimensions.add(tempBuff.toString());
    if (_debugging) {
      System.out.println(""String_Node_Str"" + tempBuff.toString());
      System.out.println(""String_Node_Str"" + _option._relatedDimensions.size());
    }
  }
  if (_debugging) {
    System.out.print(""String_Node_Str"");
  }
  for (int i=start; i < start + length; i++) {
switch (ch[i]) {
case '\\':
      if (_debugging) {
        System.out.print(""String_Node_Str"");
      }
    break;
case '""':
  if (_debugging) {
    System.out.print(""String_Node_Str"");
  }
break;
case '\n':
if (_debugging) {
System.out.print(""String_Node_Str"");
}
break;
case '\r':
if (_debugging) {
System.out.print(""String_Node_Str"");
}
break;
case '\t':
if (_debugging) {
System.out.print(""String_Node_Str"");
}
break;
default :
if (_debugging) {
System.out.print(ch[i]);
}
break;
}
}
if (_debugging) {
System.out.print(""String_Node_Str"");
}
}","/** 
 * Called by the SAX parser to report regular characters.
 * @param ch The array containing characters
 * @param start Is the starting point in the character array
 * @param length Is length of the character array 
 */
public void characters(char ch[],int start,int length){
  if (_startArchitecture == true) {
    _startArchitecture=false;
    StringBuffer tempBuff=new StringBuffer();
    tempBuff.append(ch,start,length);
    architecture.name=tempBuff.toString();
    if (_debugging) {
      System.out.println(""String_Node_Str"" + architecture.name);
    }
  }
 else   if (_startOption == true) {
    _startOption=false;
    StringBuffer tempBuff=new StringBuffer();
    tempBuff.append(ch,start,length);
    _option._name=tempBuff.toString();
    if (_debugging) {
      System.out.println(""String_Node_Str"" + _option._name);
    }
  }
 else   if (_startDimension == true) {
    _startDimension=false;
    StringBuffer tempBuff=new StringBuffer();
    tempBuff.append(ch,start,length);
    _option._relatedDimensions.add(tempBuff.toString());
    if (_debugging) {
      System.out.println(""String_Node_Str"" + tempBuff.toString());
      System.out.println(""String_Node_Str"" + _option._relatedDimensions.size());
    }
  }
  if (_debugging) {
    System.out.print(""String_Node_Str"");
  }
  for (int i=start; i < start + length; i++) {
switch (ch[i]) {
case '\\':
      if (_debugging) {
        System.out.print(""String_Node_Str"");
      }
    break;
case '""':
  if (_debugging) {
    System.out.print(""String_Node_Str"");
  }
break;
case '\n':
if (_debugging) {
System.out.print(""String_Node_Str"");
}
break;
case '\r':
if (_debugging) {
System.out.print(""String_Node_Str"");
}
break;
case '\t':
if (_debugging) {
System.out.print(""String_Node_Str"");
}
break;
default :
if (_debugging) {
System.out.print(ch[i]);
}
break;
}
}
if (_debugging) {
System.out.print(""String_Node_Str"");
}
}"
73869,"/** 
 * Called by the SAX parser to report regular characters.
 * @param ch[] The array containing characters
 * @param start Is the starting point in the character array
 * @param lenght Is length of the character array 
 */
public void characters(char ch[],int start,int length){
}","/** 
 * Called by the SAX parser to report regular characters.
 * @param ch The array containing characters
 * @param start Is the starting point in the character array
 * @param length Is length of the character array 
 */
public void characters(char ch[],int start,int length){
}"
73870,"/** 
 * Set the next sampling time and return true.
 * @return True.
 * @exception IllegalActionException If the superclass throws it.
 */
public boolean postfire() throws IllegalActionException {
  Director director=getDirector();
  if (director.getModelTime().compareTo(_nextSamplingTime) == 0) {
    int width=Math.min(input.getWidth(),output.getWidth());
    if (_recordedInputs == null || _recordedInputs.length != width) {
      _recordedInputs=new Token[width];
    }
    _inputIsComplete=true;
    for (int i=0; i < width; i++) {
      if (input.hasToken(i)) {
        _recordedInputs[i]=input.get(i);
        if (_debugging) {
          _debug(""String_Node_Str"" + _recordedInputs[i] + ""String_Node_Str""+ director.getModelTime());
        }
      }
    }
    double samplePeriodValue=((DoubleToken)samplePeriod.getToken()).doubleValue();
    _nextSamplingTime=_nextSamplingTime.add(samplePeriodValue);
    if (_debugging) {
      _debug(""String_Node_Str"" + _nextSamplingTime);
    }
    _fireAt(director.getModelTime());
    _fireAt(_nextSamplingTime);
  }
 else {
    _inputIsComplete=false;
  }
  return super.postfire();
}","/** 
 * Set the next sampling time and return true.
 * @return True.
 * @exception IllegalActionException If the superclass throws it.
 */
public boolean postfire() throws IllegalActionException {
  Director director=getDirector();
  if (director.getModelTime().compareTo(_nextSamplingTime) == 0) {
    int width=Math.min(input.getWidth(),output.getWidth());
    if (_recordedInputs == null || _recordedInputs.length != width) {
      _recordedInputs=new Token[width];
    }
    _inputIsComplete=true;
    for (int i=0; i < width; i++) {
      if (input.hasToken(i)) {
        _recordedInputs[i]=input.get(i);
        if (_debugging) {
          _debug(""String_Node_Str"" + _recordedInputs[i] + ""String_Node_Str""+ director.getModelTime());
        }
      }
 else {
        _recordedInputs[i]=null;
      }
    }
    double samplePeriodValue=((DoubleToken)samplePeriod.getToken()).doubleValue();
    _nextSamplingTime=_nextSamplingTime.add(samplePeriodValue);
    if (_debugging) {
      _debug(""String_Node_Str"" + _nextSamplingTime);
    }
    _fireAt(director.getModelTime());
    _fireAt(_nextSamplingTime);
  }
 else {
    _inputIsComplete=false;
  }
  return super.postfire();
}"
73871,"public GiottoError(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  errorAction=new StringParameter(this,""String_Node_Str"");
  errorAction.setExpression(""String_Node_Str"");
  errorAction.addChoice(""String_Node_Str"");
  errorAction.addChoice(""String_Node_Str"");
  errorAction.addChoice(""String_Node_Str"");
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Constructs a GiottoError object.
 * @param container  a CompositeEntity object
 * @param name       a String ...
 * @throws IllegalActionException ...
 * @throws NameDuplicationException ...
 */
public GiottoError(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  errorAction=new StringParameter(this,""String_Node_Str"");
  errorAction.setExpression(""String_Node_Str"");
  errorAction.addChoice(""String_Node_Str"");
  errorAction.addChoice(""String_Node_Str"");
  errorAction.addChoice(""String_Node_Str"");
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
73872,"public double _getWCET() throws IllegalActionException {
  double wcet=0;
  double actorFrequency=0;
  double actorWCET=0;
  int actorCount=0;
  CodeGeneratorHelper directorHelper;
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)this.getContainer()).deepEntityList()) {
    actorCount++;
    Attribute frequency=((Entity)actor).getAttribute(""String_Node_Str"");
    ptolemy.actor.Director dd=actor.getDirector();
    Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
    if (!(actor instanceof ptolemy.domains.giotto.lib.GiottoError)) {
      if (actor instanceof CompositeActor) {
        if (_debugging) {
        }
        Director dir=actor.getDirector();
        if (_debugging) {
        }
        if (dir == null) {
          if (_debugging) {
          }
        }
 else {
          double dummyWCET=0.0011;
          Attribute dirWCET=dir.getAttribute(""String_Node_Str"");
          if (dirWCET != null) {
            dummyWCET=((DoubleToken)((Variable)dirWCET).getToken()).doubleValue();
          }
          if (_debugging) {
          }
          wcet+=dummyWCET;
        }
      }
 else {
        if (WCET == null) {
          actorWCET=0.0;
        }
 else {
          try {
            actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
          }
 catch (          Exception e2) {
            actorWCET=((IntToken)((Variable)WCET).getToken()).intValue();
          }
        }
        if (frequency == null) {
          actorFrequency=1;
        }
 else {
          actorFrequency=((IntToken)((Variable)frequency).getToken()).intValue();
        }
        wcet+=(actorFrequency * actorWCET);
      }
    }
    if (_debugging) {
    }
  }
  return wcet;
}","/** 
 * Returns the WCET seen by the director
 */
public double _getWCET() throws IllegalActionException {
  double wcet=0;
  double actorFrequency=0;
  double actorWCET=0;
  int actorCount=0;
  CodeGeneratorHelper directorHelper;
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)this.getContainer()).deepEntityList()) {
    actorCount++;
    Attribute frequency=((Entity)actor).getAttribute(""String_Node_Str"");
    ptolemy.actor.Director dd=actor.getDirector();
    Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
    if (!(actor instanceof ptolemy.domains.giotto.lib.GiottoError)) {
      if (actor instanceof CompositeActor) {
        if (_debugging) {
        }
        Director dir=actor.getDirector();
        if (_debugging) {
        }
        if (dir == null) {
          if (_debugging) {
          }
        }
 else {
          double dummyWCET=0.0011;
          Attribute dirWCET=dir.getAttribute(""String_Node_Str"");
          if (dirWCET != null) {
            dummyWCET=((DoubleToken)((Variable)dirWCET).getToken()).doubleValue();
          }
          if (_debugging) {
          }
          wcet+=dummyWCET;
        }
      }
 else {
        if (WCET == null) {
          actorWCET=0.0;
        }
 else {
          try {
            actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
          }
 catch (          Exception e2) {
            actorWCET=((IntToken)((Variable)WCET).getToken()).intValue();
          }
        }
        if (frequency == null) {
          actorFrequency=1;
        }
 else {
          actorFrequency=((IntToken)((Variable)frequency).getToken()).intValue();
        }
        wcet+=(actorFrequency * actorWCET);
      }
    }
    if (_debugging) {
    }
  }
  return wcet;
}"
73873,"public int getLCM(){
  return _lcm;
}","/** 
 * Returns the LCM value.
 */
public int getLCM(){
  return _lcm;
}"
73874,"/** 
 * This indicates that a processing instruction (other than the XML declaration) has been encountered.</p>
 * @param target <code>String</code> target of PI
 * @param data <code>String</code containing all data sent to the PI. This typically looks like one or more attribute value pairs.
 * @throws <code>SAXException</code> when things go wrong
 */
public void processingInstruction(String target,String data){
  if (_debugging) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + target + ""String_Node_Str""+ data);
  }
}","/** 
 * This indicates that a processing instruction (other than the XML declaration) has been encountered.
 * @param target <code>String</code> target of PI
 * @param data <code>String</code containing all data sent to the PI. This typically looks like one or more attribute value pairs.
 * @throws <code>SAXException</code> when things go wrong
 */
public void processingInstruction(String target,String data){
  if (_debugging) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + target + ""String_Node_Str""+ data);
  }
}"
73875,"/** 
 * Clone the actor into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a composite actor with clones of the ports of the original actor, the contained actors, and the contained relations. The ports of the returned actor are not connected to anything. The connections of the relations are duplicated in the new composite, unless they cross levels, in which case an exception is thrown. The local director is cloned, if there is one. The executive director is not cloned. NOTE: This will not work if there are level-crossing transitions.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If the actor containslevel crossing transitions so that its connections cannot be cloned, or if one of the attributes cannot be cloned.
 * @return A new CompositeActor.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  List<Initializable> oldInitializables=_initializables;
  _initializables=null;
  Map<String,List<IOPort>> oldPublishedPorts=_publishedPorts;
  _publishedPorts=null;
  Map<String,IORelation> oldPublisherRelations=_publisherRelations;
  Director oldDirector=_director;
  _director=null;
  List<Executable> oldPiggybacks=_piggybacks;
  _piggybacks=null;
  CompositeActor newObject=(CompositeActor)super.clone(workspace);
  _initializables=oldInitializables;
  _publishedPorts=oldPublishedPorts;
  _publisherRelations=oldPublisherRelations;
  _director=oldDirector;
  _piggybacks=oldPiggybacks;
  newObject._actorFiringListeners=null;
  newObject._causalityInterface=null;
  newObject._derivedPiggybacks=null;
  newObject._manager=null;
  newObject._inputPortsVersion=-1;
  newObject._outputPortsVersion=-1;
  newObject._causalityInterfaceDirector=null;
  newObject._receiversVersion=-1L;
  newObject._relationWidthInference=null;
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a composite actor with clones of the ports of the original actor, the contained actors, and the contained relations. The ports of the returned actor are not connected to anything. The connections of the relations are duplicated in the new composite, unless they cross levels, in which case an exception is thrown. The local director is cloned, if there is one. The executive director is not cloned. NOTE: This will not work if there are level-crossing transitions.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If the actor containslevel crossing transitions so that its connections cannot be cloned, or if one of the attributes cannot be cloned.
 * @return A new CompositeActor.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  List<Initializable> oldInitializables=_initializables;
  _initializables=null;
  Map<String,List<IOPort>> oldPublishedPorts=_publishedPorts;
  _publishedPorts=null;
  Map<String,IORelation> oldPublisherRelations=_publisherRelations;
  Director oldDirector=_director;
  _director=null;
  List<Executable> oldPiggybacks=_piggybacks;
  _piggybacks=null;
  CompositeActor newObject=(CompositeActor)super.clone(workspace);
  _initializables=oldInitializables;
  _publishedPorts=oldPublishedPorts;
  _publisherRelations=oldPublisherRelations;
  _director=oldDirector;
  _piggybacks=oldPiggybacks;
  newObject._actorFiringListeners=null;
  newObject._causalityInterface=null;
  newObject._derivedPiggybacks=null;
  newObject._manager=null;
  newObject._inputPortsVersion=-1;
  newObject._outputPortsVersion=-1;
  newObject._causalityInterfaceDirector=null;
  newObject._receiversVersion=-1L;
  newObject._relationWidthInference=new RelationWidthInference(newObject);
  return newObject;
}"
73876,"/** 
 * Request a firing of the given actor at the given absolute time.  This method calculates the period of invocation of the specified actor (which is the period of this director divided by the actor's frequency), and if the requested time is ahead of current time by some multiple of the actor's period, then return the requested time.
 * @param actor The actor scheduled to be fired.
 * @param time The requested time.
 * @return The time at which the actor passed as an argumentwill be fired.
 * @exception IllegalActionException If the operation is notpermissible (e.g. the given time is in the past).
 */
public Time fireAt(Actor actor,Time time) throws IllegalActionException {
  System.out.println(""String_Node_Str"" + actor.getFullName());
  Time currentTime=getModelTime();
  int frequencyValue=_getActorFrequency((NamedObj)actor);
  double actorPeriod=_periodValue / frequencyValue;
  Time nextFiringTime=currentTime.add(actorPeriod);
  NamedObj container=getContainer();
  if (container != null) {
    Manager manager=((CompositeActor)container).getManager();
    if (manager.getState().equals(Manager.INITIALIZING)) {
      return currentTime;
    }
  }
  if (time.equals(currentTime) || time.equals(nextFiringTime)) {
    return nextFiringTime;
  }
  if (time.isInfinite() || currentTime.compareTo(time) > 0) {
    return currentTime.add(nextFiringTime);
  }
  Time futureTime=currentTime;
  while (time.compareTo(futureTime) > 0) {
    futureTime=futureTime.add(actorPeriod);
    if (futureTime.equals(time)) {
      return time;
    }
  }
  return currentTime.add(nextFiringTime);
}","/** 
 * Request a firing of the given actor at the given absolute time.  This method calculates the period of invocation of the specified actor (which is the period of this director divided by the actor's frequency), and if the requested time is ahead of current time by some multiple of the actor's period, then return the requested time.
 * @param actor The actor scheduled to be fired.
 * @param time The requested time.
 * @return The time at which the actor passed as an argumentwill be fired.
 * @exception IllegalActionException If the operation is notpermissible (e.g. the given time is in the past).
 */
public Time fireAt(Actor actor,Time time) throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + actor.getFullName());
  }
  Time currentTime=getModelTime();
  int frequencyValue=_getActorFrequency((NamedObj)actor);
  double actorPeriod=_periodValue / frequencyValue;
  if (_debugging) {
    _debug(""String_Node_Str"" + frequencyValue);
    _debug(""String_Node_Str"" + actorPeriod);
  }
  Time nextFiringTime=currentTime.add(actorPeriod);
  if (_debugging) {
    _debug(""String_Node_Str"" + currentTime.getDoubleValue());
    _debug(""String_Node_Str"" + nextFiringTime.getDoubleValue());
    _debug(""String_Node_Str"" + time.getDoubleValue());
  }
  NamedObj container=getContainer();
  if (container != null) {
    Manager manager=((CompositeActor)container).getManager();
    if (manager.getState().equals(Manager.INITIALIZING)) {
      return currentTime;
    }
  }
  if (time.equals(currentTime) || time.equals(nextFiringTime)) {
    return nextFiringTime;
  }
  if (time.isInfinite() || currentTime.compareTo(time) > 0) {
    return currentTime.add(nextFiringTime);
  }
  Time futureTime=currentTime;
  while (time.compareTo(futureTime) > 0) {
    futureTime=futureTime.add(actorPeriod);
    if (futureTime.equals(time)) {
      return time;
    }
  }
  return currentTime.add(nextFiringTime);
}"
73877,"public double _getWCET() throws IllegalActionException {
  double wcet=0;
  double actorFrequency=0;
  double actorWCET=0;
  int actorCount=0;
  CodeGeneratorHelper directorHelper;
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)this.getContainer()).deepEntityList()) {
    actorCount++;
    Attribute frequency=((Entity)actor).getAttribute(""String_Node_Str"");
    ptolemy.actor.Director dd=actor.getDirector();
    Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
    if (!(actor instanceof ptolemy.domains.giotto.lib.GiottoError)) {
      if (actor instanceof CompositeActor) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        Director dir=actor.getDirector();
        System.out.println(dir.getFullName());
        if (dir == null) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
        }
 else {
          double dummyWCET=0.0011;
          Attribute dirWCET=dir.getAttribute(""String_Node_Str"");
          if (dirWCET != null) {
            dummyWCET=((DoubleToken)((Variable)dirWCET).getToken()).doubleValue();
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str""+ dummyWCET);
          }
          wcet+=dummyWCET;
        }
      }
 else {
        if (WCET == null) {
          actorWCET=0.0011;
        }
 else {
          actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
        }
        if (frequency == null) {
          actorFrequency=1;
        }
 else {
          actorFrequency=((IntToken)((Variable)frequency).getToken()).intValue();
        }
        wcet+=(actorFrequency * actorWCET);
      }
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str""+ wcet);
    }
    System.out.println(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str""+ wcet);
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + actorCount);
  }
  return wcet;
}","public double _getWCET() throws IllegalActionException {
  double wcet=0;
  double actorFrequency=0;
  double actorWCET=0;
  int actorCount=0;
  CodeGeneratorHelper directorHelper;
  for (  Actor actor : (List<Actor>)((TypedCompositeActor)this.getContainer()).deepEntityList()) {
    actorCount++;
    Attribute frequency=((Entity)actor).getAttribute(""String_Node_Str"");
    ptolemy.actor.Director dd=actor.getDirector();
    Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
    if (!(actor instanceof ptolemy.domains.giotto.lib.GiottoError)) {
      if (actor instanceof CompositeActor) {
        if (_debugging) {
        }
        Director dir=actor.getDirector();
        if (_debugging) {
        }
        if (dir == null) {
          if (_debugging) {
          }
        }
 else {
          double dummyWCET=0.0011;
          Attribute dirWCET=dir.getAttribute(""String_Node_Str"");
          if (dirWCET != null) {
            dummyWCET=((DoubleToken)((Variable)dirWCET).getToken()).doubleValue();
          }
          if (_debugging) {
          }
          wcet+=dummyWCET;
        }
      }
 else {
        if (WCET == null) {
          actorWCET=0.0;
        }
 else {
          try {
            actorWCET=((DoubleToken)((Variable)WCET).getToken()).doubleValue();
          }
 catch (          Exception e2) {
            actorWCET=((IntToken)((Variable)WCET).getToken()).intValue();
          }
        }
        if (frequency == null) {
          actorFrequency=1;
        }
 else {
          actorFrequency=((IntToken)((Variable)frequency).getToken()).intValue();
        }
        wcet+=(actorFrequency * actorWCET);
      }
    }
    if (_debugging) {
    }
  }
  return wcet;
}"
73878,"/** 
 * Preinitialize the actors associated with this director. Generate the giotto schedule.
 * @exception IllegalActionException If the preinitialize() method ofone of the associated actors throws it.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  CompositeActor compositeActor=(CompositeActor)(getContainer());
  if (_isEmbedded()) {
    Director executiveDirector=compositeActor.getExecutiveDirector();
    if (executiveDirector instanceof GiottoDirector) {
      double periodValue=((GiottoDirector)executiveDirector).getPeriod();
      int frequencyValue=_getActorFrequency(compositeActor);
      _periodValue=periodValue / frequencyValue;
      period.setExpression(Double.toString(_periodValue));
    }
  }
  GiottoScheduler scheduler=(GiottoScheduler)getScheduler();
  _schedule=scheduler.getSchedule();
  _unitTimeIncrement=scheduler._getMinTimeStep(_periodValue);
  _lcm=scheduler.getLCM();
  CompositeActor localCompositeActor=(CompositeActor)(getContainer());
  List actorList=compositeActor.deepEntityList();
  ListIterator actors=actorList.listIterator();
  Actor actor;
  double wcet=0;
  boolean errorHandlerSet=false;
  try {
    createDecoratedAttributes(this);
    System.out.println(""String_Node_Str"");
  }
 catch (  NameDuplicationException e) {
    e.printStackTrace();
  }
  Attribute dirWCET=this.getContainer().getAttribute(""String_Node_Str"");
  if (dirWCET != null) {
    wcet=((DoubleToken)((Variable)dirWCET).getToken()).doubleValue();
  }
  System.out.println(""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue);
  if (wcet > _periodValue) {
    System.out.println(""String_Node_Str"");
    handleModelError(this,new IllegalActionException(this,""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue+ ""String_Node_Str""+ ((CompositeActor)(getContainer())).getDisplayName()));
  }
}","/** 
 * Preinitialize the actors associated with this director. Generate the giotto schedule.
 * @exception IllegalActionException If the preinitialize() method ofone of the associated actors throws it.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  super.preinitialize();
  CompositeActor compositeActor=(CompositeActor)(getContainer());
  if (_isEmbedded()) {
    Director executiveDirector=compositeActor.getExecutiveDirector();
    if (executiveDirector instanceof GiottoDirector) {
      double periodValue=((GiottoDirector)executiveDirector).getPeriod();
      int frequencyValue=_getActorFrequency(compositeActor);
      _periodValue=periodValue / frequencyValue;
      period.setExpression(Double.toString(_periodValue));
    }
  }
  GiottoScheduler scheduler=(GiottoScheduler)getScheduler();
  _schedule=scheduler.getSchedule();
  _unitTimeIncrement=scheduler._getMinTimeStep(_periodValue);
  Actor actor;
  double wcet=0;
  boolean errorHandlerSet=false;
  try {
    createDecoratedAttributes(this);
  }
 catch (  NameDuplicationException e) {
    e.printStackTrace();
  }
  Attribute dirWCET=this.getContainer().getAttribute(""String_Node_Str"");
  if (dirWCET != null) {
    wcet=((DoubleToken)((Variable)dirWCET).getToken()).doubleValue();
  }
  if (wcet > _periodValue) {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    handleModelError(this,new IllegalActionException(this,""String_Node_Str"" + wcet + ""String_Node_Str""+ _periodValue+ ""String_Node_Str""+ ((CompositeActor)(getContainer())).getDisplayName()));
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}"
73879,"private void _requestFiring() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + _expectedNextIterationTime);
  }
  System.out.println(""String_Node_Str"" + _expectedNextIterationTime);
  _fireContainerAt(_expectedNextIterationTime);
}","private void _requestFiring() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + _expectedNextIterationTime);
  }
  _fireContainerAt(_expectedNextIterationTime);
}"
73880,"/** 
 * Fire a complete iteration and advance time to the current time plus the period value. A complete iteration consists of several minor cycles. At each minor cycle, iterate actors in the corresponding minor cycle schedule. After iterating the actors, increment time by the minor cycle time. Also, update the receivers that are destinations of all actors that will be invoked in the next minor cycle of the schedule. This works because all actors in Giotto are invoked periodically, and the ones that will be invoked in the next cycle are the ones that are completing invocation at the end of this cycle.
 * @exception IllegalActionException If this director does not have acontainer.
 */
public void fire() throws IllegalActionException {
  TypedCompositeActor container=(TypedCompositeActor)getContainer();
  if (container == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (!_readyToFire) {
    return;
  }
  while ((_unitIndex < _schedule.size()) && !_stopRequested) {
    setModelTime(_expectedNextIterationTime);
    Schedule unitSchedule=(Schedule)_schedule.get(_unitIndex);
    if (_synchronizeToRealTime) {
      long elapsedTime=System.currentTimeMillis() - _realStartTime;
      double elapsedTimeInSeconds=elapsedTime / 1000.0;
      if (_expectedNextIterationTime.getDoubleValue() > elapsedTimeInSeconds) {
        long timeToWait=(long)((_expectedNextIterationTime.getDoubleValue() - elapsedTimeInSeconds) * 1000.0);
        if (timeToWait > 0) {
          if (_debugging) {
            _debug(""String_Node_Str"" + timeToWait);
          }
          Scheduler scheduler=getScheduler();
synchronized (scheduler) {
            try {
              scheduler.wait(timeToWait);
            }
 catch (            InterruptedException ex) {
            }
          }
        }
      }
    }
    Iterator scheduleIterator=unitSchedule.iterator();
    while (scheduleIterator.hasNext()) {
      Actor actor=((Firing)scheduleIterator.next()).getActor();
      System.out.println(""String_Node_Str"" + actor.getFullName());
      Time thistime=getModelTime();
      System.out.println(""String_Node_Str"" + thistime.toString() + ""String_Node_Str""+ thistime.getDoubleValue());
      if (_debugging) {
        _debug(""String_Node_Str"" + ((NamedObj)actor).getFullName());
      }
      List outputPortList=actor.outputPortList();
      Iterator outputPorts=outputPortList.iterator();
      while (outputPorts.hasNext()) {
        IOPort port=(IOPort)outputPorts.next();
        System.out.print(""String_Node_Str"" + port.getDisplayName());
        Receiver[][] channelArray=port.getRemoteReceivers();
        for (int i=0; i < channelArray.length; i++) {
          Receiver[] receiverArray=channelArray[i];
          for (int j=0; j < receiverArray.length; j++) {
            GiottoReceiver receiver=(GiottoReceiver)receiverArray[j];
            receiver.update();
          }
        }
      }
    }
    scheduleIterator=unitSchedule.iterator();
    while (scheduleIterator.hasNext()) {
      Actor actor=((Firing)scheduleIterator.next()).getActor();
      Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
      if (WCET == null) {
        System.out.println(actor.getFullName() + ""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"" + ((DoubleToken)((Variable)WCET).getToken()).doubleValue());
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + ((NamedObj)actor).getFullName());
      }
      if (actor.iterate(1) == STOP_ITERATING) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"" + actor.getFullName() + ""String_Node_Str"");
      }
    }
    System.out.println(""String_Node_Str"" + _unitIndex);
    _unitIndex++;
    _expectedNextIterationTime=_expectedNextIterationTime.add(_unitTimeIncrement);
    if (_unitIndex == _lcm) {
      _expectedNextIterationTime=new Time(this,_periodValue * (_iterationCount + 1));
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + _expectedNextIterationTime + ""String_Node_Str"");
    }
  }
  if (_unitIndex >= _schedule.size()) {
    _unitIndex=0;
    if (_debugging) {
      _debug(""String_Node_Str"" + _iterationCount);
    }
    _iterationCount++;
  }
}","/** 
 * Fire a complete iteration and advance time to the current time plus the period value. A complete iteration consists of several minor cycles. At each minor cycle, iterate actors in the corresponding minor cycle schedule. After iterating the actors, increment time by the minor cycle time. Also, update the receivers that are destinations of all actors that will be invoked in the next minor cycle of the schedule. This works because all actors in Giotto are invoked periodically, and the ones that will be invoked in the next cycle are the ones that are completing invocation at the end of this cycle.
 * @exception IllegalActionException If this director does not have acontainer.
 */
public void fire() throws IllegalActionException {
  TypedCompositeActor container=(TypedCompositeActor)getContainer();
  if (container == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (!_readyToFire) {
    return;
  }
  while ((_unitIndex < _schedule.size()) && !_stopRequested) {
    setModelTime(_expectedNextIterationTime);
    Schedule unitSchedule=(Schedule)_schedule.get(_unitIndex);
    if (_synchronizeToRealTime) {
      long elapsedTime=System.currentTimeMillis() - _realStartTime;
      double elapsedTimeInSeconds=elapsedTime / 1000.0;
      if (_expectedNextIterationTime.getDoubleValue() > elapsedTimeInSeconds) {
        long timeToWait=(long)((_expectedNextIterationTime.getDoubleValue() - elapsedTimeInSeconds) * 1000.0);
        if (timeToWait > 0) {
          if (_debugging) {
            _debug(""String_Node_Str"" + timeToWait);
          }
          Scheduler scheduler=getScheduler();
synchronized (scheduler) {
            try {
              scheduler.wait(timeToWait);
            }
 catch (            InterruptedException ex) {
            }
          }
        }
      }
    }
    Iterator scheduleIterator=unitSchedule.iterator();
    while (scheduleIterator.hasNext()) {
      Actor actor=((Firing)scheduleIterator.next()).getActor();
      if (_debugging) {
        _debug(""String_Node_Str"" + actor.getFullName());
      }
      Time thistime=getModelTime();
      if (_debugging) {
        _debug(""String_Node_Str"" + thistime.toString());
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + ((NamedObj)actor).getFullName());
      }
      List outputPortList=actor.outputPortList();
      Iterator outputPorts=outputPortList.iterator();
      while (outputPorts.hasNext()) {
        IOPort port=(IOPort)outputPorts.next();
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getDisplayName());
        }
        Receiver[][] channelArray=port.getRemoteReceivers();
        for (int i=0; i < channelArray.length; i++) {
          Receiver[] receiverArray=channelArray[i];
          for (int j=0; j < receiverArray.length; j++) {
            GiottoReceiver receiver=(GiottoReceiver)receiverArray[j];
            receiver.update();
          }
        }
      }
    }
    scheduleIterator=unitSchedule.iterator();
    while (scheduleIterator.hasNext()) {
      Actor actor=((Firing)scheduleIterator.next()).getActor();
      Attribute WCET=((Entity)actor).getAttribute(""String_Node_Str"");
      if (_debugging) {
        _debug(""String_Node_Str"" + ((NamedObj)actor).getFullName());
      }
      if (actor.iterate(1) == STOP_ITERATING) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"" + actor.getFullName() + ""String_Node_Str"");
      }
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + _unitIndex);
    }
    _unitIndex++;
    _expectedNextIterationTime=_expectedNextIterationTime.add(_unitTimeIncrement);
    if (_unitIndex == _lcm) {
      _expectedNextIterationTime=new Time(this,_iterationCount + (_periodValue * (_unitIndex)));
      if (_debugging) {
        _debug(""String_Node_Str"");
        _debug(""String_Node_Str"" + _iterationCount);
      }
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + _expectedNextIterationTime + ""String_Node_Str"");
    }
  }
  if (_unitIndex >= _schedule.size()) {
    _unitIndex=0;
    if (_debugging) {
      _debug(""String_Node_Str"" + _iterationCount);
    }
    _iterationCount++;
  }
}"
73881,"/** 
 * Writing out the profile for the composite actor and print out the dot file.
 * @param container The composite actor whose profile to be generated.
 * @param actorFirings 
 * @param firingClusters
 * @param esdf
 * @throws IllegalActionException
 */
private void _generateProfile(CompositeActor container,List actorFirings,List<FiringCluster> firingClusters,StringBuffer esdf) throws IllegalActionException {
  esdf.append(INDENT1 + ""String_Node_Str"" + _eol);
  esdf.append(INDENT2 + ""String_Node_Str"" + _eol);
  esdf.append(INDENT2 + ""String_Node_Str"" + _eol+ _eol);
  for (  FiringCluster cluster : firingClusters) {
    int index=firingClusters.indexOf(cluster);
    esdf.append(INDENT2 + ""String_Node_Str"" + index+ ""String_Node_Str""+ _eol);
    String externalPortName;
    for (    IOPort inputPort : cluster.inputPorts) {
      externalPortName=""String_Node_Str"";
      for (      Object connectedPort : inputPort.connectedPortList()) {
        if (container.portList().contains(connectedPort)) {
          externalPortName=((IOPort)connectedPort).getName();
          break;
        }
      }
      if (!externalPortName.equals(""String_Node_Str"")) {
        esdf.append(INDENT2 + ""String_Node_Str"" + inputPort.getName()+ ""String_Node_Str""+ externalPortName+ ""String_Node_Str""+ DFUtilities.getTokenConsumptionRate(inputPort)+ ""String_Node_Str""+ inputPort.isInput()+ ""String_Node_Str""+ _eol);
      }
    }
    for (    IOPort outputPort : cluster.outputPorts) {
      externalPortName=""String_Node_Str"";
      for (      Object connectedPort : outputPort.connectedPortList()) {
        if (container.portList().contains(connectedPort)) {
          externalPortName=((IOPort)connectedPort).getName();
          break;
        }
      }
      if (!externalPortName.equals(""String_Node_Str""))       esdf.append(INDENT2 + ""String_Node_Str"" + outputPort.getName()+ ""String_Node_Str""+ externalPortName+ ""String_Node_Str""+ DFUtilities.getTokenProductionRate(outputPort)+ ""String_Node_Str""+ outputPort.isInput()+ ""String_Node_Str""+ _eol);
    }
    for (    FiringCluster nextCluster : cluster.nextClusters) {
      esdf.append(INDENT2 + ""String_Node_Str"" + firingClusters.indexOf(nextCluster)+ ""String_Node_Str""+ _eol);
    }
    for (    FiringCluster previousCluster : cluster.previousClusters) {
      esdf.append(INDENT2 + ""String_Node_Str"" + firingClusters.indexOf(previousCluster)+ ""String_Node_Str""+ _eol);
    }
    for (    FiringCluster nextCluster : cluster.nextIterationClusters) {
      esdf.append(INDENT2 + ""String_Node_Str"" + firingClusters.indexOf(nextCluster)+ ""String_Node_Str""+ _eol);
    }
    for (    FiringCluster previousCluster : cluster.previousIterationClusters) {
      esdf.append(INDENT2 + ""String_Node_Str"" + firingClusters.indexOf(previousCluster)+ ""String_Node_Str""+ _eol);
    }
    esdf.append(INDENT2 + ""String_Node_Str"" + _eol+ _eol);
  }
  StringBuffer graph=new StringBuffer();
  System.out.println(""String_Node_Str"" + actorFirings.size());
  graph.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
  for (Iterator firings=actorFirings.iterator(); firings.hasNext(); ) {
    Firing firing=(Firing)firings.next();
    for (Iterator nextFirings=firing.nextActorFirings.iterator(); nextFirings.hasNext(); ) {
      Firing nextFiring=(Firing)nextFirings.next();
      graph.append(""String_Node_Str"" + firing.actor.getName() + ""String_Node_Str""+ firing.firingIndex+ ""String_Node_Str""+ firing.firingFunction+ ""String_Node_Str""+ nextFiring.actor.getName()+ ""String_Node_Str""+ nextFiring.firingIndex+ ""String_Node_Str""+ nextFiring.firingFunction+ ""String_Node_Str""+ _eol);
    }
  }
  for (  FiringCluster cluster : firingClusters) {
    graph.append(""String_Node_Str"" + ""String_Node_Str"" + firingClusters.indexOf(cluster) + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ firingClusters.indexOf(cluster)+ ""String_Node_Str""+ _eol);
    for (    Firing firing : cluster.actorFirings) {
      graph.append(""String_Node_Str"" + firing.actor.getName() + ""String_Node_Str""+ firing.firingIndex+ ""String_Node_Str""+ firing.firingFunction+ ""String_Node_Str""+ _eol);
    }
    graph.append(""String_Node_Str"" + _eol);
  }
  StringBuffer clustersGraph=new StringBuffer();
  clustersGraph.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  for (  FiringCluster cluster : firingClusters) {
    int index=firingClusters.indexOf(cluster);
    for (    FiringCluster nextCluster : cluster.nextClusters) {
      clustersGraph.append(""String_Node_Str"" + ""String_Node_Str"" + index + ""String_Node_Str""+ ""String_Node_Str""+ firingClusters.indexOf(nextCluster)+ ""String_Node_Str""+ _eol);
    }
    for (    FiringCluster nextCluster : cluster.nextIterationClusters) {
      clustersGraph.append(""String_Node_Str"" + ""String_Node_Str"" + index + ""String_Node_Str""+ ""String_Node_Str""+ firingClusters.indexOf(nextCluster)+ ""String_Node_Str""+ _eol);
    }
  }
  graph.append(""String_Node_Str"" + _eol);
  clustersGraph.append(""String_Node_Str"");
  String modelName=NamedProgramCodeGeneratorAdapter.generateName(_model);
  _writeCodeFileName(graph,modelName + ""String_Node_Str"",true,true);
  _writeCodeFileName(clustersGraph,modelName + ""String_Node_Str"",true,true);
  esdf.append(INDENT2 + ""String_Node_Str"" + _eol);
  esdf.append(INDENT1 + ""String_Node_Str"" + _eol);
}","/** 
 * Writing out the profile for the composite actor and print out the dot file.
 * @param container The composite actor whose profile to be generated.
 * @param actorFirings 
 * @param firingClusters
 * @param esdf
 * @throws IllegalActionException
 */
private void _generateProfile(CompositeActor container,List actorFirings,List<FiringCluster> firingClusters,StringBuffer esdf) throws IllegalActionException {
  esdf.append(INDENT1 + ""String_Node_Str"" + _eol);
  esdf.append(INDENT2 + ""String_Node_Str"" + _eol);
  esdf.append(INDENT2 + ""String_Node_Str"" + _eol+ _eol);
  for (  FiringCluster cluster : firingClusters) {
    int index=firingClusters.indexOf(cluster);
    esdf.append(INDENT2 + ""String_Node_Str"" + index+ ""String_Node_Str""+ _eol);
    String externalPortName;
    for (    IOPort inputPort : cluster.inputPorts) {
      externalPortName=""String_Node_Str"";
      for (      Object connectedPort : inputPort.connectedPortList()) {
        if (container.portList().contains(connectedPort)) {
          externalPortName=((IOPort)connectedPort).getName();
          break;
        }
      }
      if (!externalPortName.equals(""String_Node_Str"")) {
        esdf.append(INDENT2 + ""String_Node_Str"" + inputPort.getName()+ ""String_Node_Str""+ externalPortName+ ""String_Node_Str""+ DFUtilities.getTokenConsumptionRate(inputPort)+ ""String_Node_Str""+ inputPort.isInput()+ ""String_Node_Str""+ _eol);
      }
    }
    for (    IOPort outputPort : cluster.outputPorts) {
      externalPortName=""String_Node_Str"";
      for (      Object connectedPort : outputPort.connectedPortList()) {
        if (container.portList().contains(connectedPort)) {
          externalPortName=((IOPort)connectedPort).getName();
          break;
        }
      }
      if (!externalPortName.equals(""String_Node_Str""))       esdf.append(INDENT2 + ""String_Node_Str"" + outputPort.getName()+ ""String_Node_Str""+ externalPortName+ ""String_Node_Str""+ DFUtilities.getTokenProductionRate(outputPort)+ ""String_Node_Str""+ outputPort.isInput()+ ""String_Node_Str""+ _eol);
    }
    for (    FiringCluster nextCluster : cluster.nextClusters) {
      esdf.append(INDENT2 + ""String_Node_Str"" + firingClusters.indexOf(nextCluster)+ ""String_Node_Str""+ _eol);
    }
    for (    FiringCluster previousCluster : cluster.previousClusters) {
      esdf.append(INDENT2 + ""String_Node_Str"" + firingClusters.indexOf(previousCluster)+ ""String_Node_Str""+ _eol);
    }
    for (    FiringCluster nextCluster : cluster.nextIterationClusters) {
      esdf.append(INDENT2 + ""String_Node_Str"" + firingClusters.indexOf(nextCluster)+ ""String_Node_Str""+ _eol);
    }
    for (    FiringCluster previousCluster : cluster.previousIterationClusters) {
      esdf.append(INDENT2 + ""String_Node_Str"" + firingClusters.indexOf(previousCluster)+ ""String_Node_Str""+ _eol);
    }
    esdf.append(INDENT2 + ""String_Node_Str"" + _eol+ _eol);
  }
  StringBuffer graph=new StringBuffer();
  System.out.println(""String_Node_Str"" + actorFirings.size());
  graph.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol);
  for (Iterator firings=actorFirings.iterator(); firings.hasNext(); ) {
    Firing firing=(Firing)firings.next();
    graph.append(""String_Node_Str"" + firing.actor.getName() + ""String_Node_Str""+ firing.firingIndex+ ""String_Node_Str""+ firing.firingFunction+ ""String_Node_Str""+ _eol);
    for (Iterator nextFirings=firing.nextActorFirings.iterator(); nextFirings.hasNext(); ) {
      Firing nextFiring=(Firing)nextFirings.next();
      graph.append(""String_Node_Str"" + firing.actor.getName() + ""String_Node_Str""+ firing.firingIndex+ ""String_Node_Str""+ firing.firingFunction+ ""String_Node_Str""+ nextFiring.actor.getName()+ ""String_Node_Str""+ nextFiring.firingIndex+ ""String_Node_Str""+ nextFiring.firingFunction+ ""String_Node_Str""+ _eol);
    }
  }
  for (  FiringCluster cluster : firingClusters) {
    graph.append(""String_Node_Str"" + ""String_Node_Str"" + firingClusters.indexOf(cluster) + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ firingClusters.indexOf(cluster)+ ""String_Node_Str""+ _eol);
    for (    Firing firing : cluster.actorFirings) {
      graph.append(""String_Node_Str"" + firing.actor.getName() + ""String_Node_Str""+ firing.firingIndex+ ""String_Node_Str""+ firing.firingFunction+ ""String_Node_Str""+ _eol);
    }
    graph.append(""String_Node_Str"" + _eol);
  }
  StringBuffer clustersGraph=new StringBuffer();
  clustersGraph.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  for (  FiringCluster cluster : firingClusters) {
    int index=firingClusters.indexOf(cluster);
    clustersGraph.append(""String_Node_Str"" + ""String_Node_Str"" + index + ""String_Node_Str""+ _eol);
    for (    FiringCluster nextCluster : cluster.nextClusters) {
      clustersGraph.append(""String_Node_Str"" + ""String_Node_Str"" + index + ""String_Node_Str""+ ""String_Node_Str""+ firingClusters.indexOf(nextCluster)+ ""String_Node_Str""+ _eol);
    }
    for (    FiringCluster nextCluster : cluster.nextIterationClusters) {
      clustersGraph.append(""String_Node_Str"" + ""String_Node_Str"" + index + ""String_Node_Str""+ ""String_Node_Str""+ firingClusters.indexOf(nextCluster)+ ""String_Node_Str""+ _eol);
    }
  }
  graph.append(""String_Node_Str"" + _eol);
  clustersGraph.append(""String_Node_Str"");
  String modelName=NamedProgramCodeGeneratorAdapter.generateName(_model);
  _writeCodeFileName(graph,modelName + ""String_Node_Str"",true,true);
  _writeCodeFileName(clustersGraph,modelName + ""String_Node_Str"",true,true);
  esdf.append(INDENT2 + ""String_Node_Str"" + _eol);
  esdf.append(INDENT1 + ""String_Node_Str"" + _eol);
}"
73882,"public List<Inequality> constraintList() throws IllegalActionException {
  ptolemy.actor.lib.RecordAssembler actor=(ptolemy.actor.lib.RecordAssembler)getComponent();
  Object[] portArray=actor.inputPortList().toArray();
  int size=portArray.length;
  String[] labels=new String[size];
  LatticeProperty[] properties=new LatticeProperty[size];
  for (int i=0; i < size; i++) {
    labels[i]=((Port)portArray[i]).getName();
    properties[i]=_lattice.getElement(""String_Node_Str"");
  }
  RecordProperty declaredProperty=new RecordProperty(_lattice,labels,properties);
  setEquals(actor.output,declaredProperty);
  RecordProperty outputProperty=(RecordProperty)_solver.getProperty(actor.output);
  Iterator inputPorts=actor.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
    String label=inputPort.getName();
    setAtLeast(outputProperty.getPropertyTerm(label),inputPort);
  }
  return super.constraintList();
}","public List<Inequality> constraintList() throws IllegalActionException {
  ptolemy.actor.lib.RecordAssembler actor=(ptolemy.actor.lib.RecordAssembler)getComponent();
  Object[] portArray=actor.inputPortList().toArray();
  int size=portArray.length;
  String[] labels=new String[size];
  LatticeProperty[] properties=new LatticeProperty[size];
  for (int i=0; i < size; i++) {
    labels[i]=((Port)portArray[i]).getName();
    properties[i]=_lattice.getElement(""String_Node_Str"");
  }
  RecordProperty declaredProperty=new RecordProperty(_lattice,labels,properties);
  setAtLeast(actor.output,declaredProperty);
  RecordProperty outputProperty=(RecordProperty)_solver.getProperty(actor.output);
  Iterator inputPorts=actor.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
    String label=inputPort.getName();
    setAtLeast(outputProperty.getPropertyTerm(label),inputPort);
  }
  return super.constraintList();
}"
73883,"/** 
 * Override the base class to declare that the <i>initialState</i> and <i>impulse</i> inputs are equivalent, but not the <i>derivative</i> input port. This is because to react to inputs at either <i>initialState</i> or <i>impulse</i>, we have to know what the input at the other is.  But the input at <i>derivative</i> does not need to be known.  It will affect the future only.
 * @param input The port to find the equivalence class of.
 * @exception IllegalArgumentException If the argument is notcontained by the associated actor.
 */
public Collection<IOPort> equivalentPorts(IOPort input){
  if (input == derivative) {
    return _derivativeEquivalents;
  }
  return _otherEquivalents;
}","/** 
 * Override the base class to declare that the <i>initialState</i> and <i>impulse</i> inputs are equivalent, but not the <i>derivative</i> input port. This is because to react to inputs at either <i>initialState</i> or <i>impulse</i>, we have to know what the input at the other is.  But the input at <i>derivative</i> does not need to be known.  It will affect the future only.
 * @param input The port to find the equivalence class of.
 * @exception IllegalArgumentException If the argument is notcontained by the associated actor.
 */
public Collection<IOPort> equivalentPorts(IOPort input){
  if (input == _actor.derivative) {
    return _derivativeEquivalents;
  }
  return _otherEquivalents;
}"
73884,"public IntegratorCausalityInterface(Actor actor,Dependency defaultDependency){
  super(actor,defaultDependency);
  _derivativeEquivalents.add(derivative);
  _otherEquivalents.add(impulse);
  _otherEquivalents.add(initialState.getPort());
  removeDependency(derivative,state);
}","public IntegratorCausalityInterface(ContinuousIntegrator actor,Dependency defaultDependency){
  super(actor,defaultDependency);
  _actor=actor;
  _derivativeEquivalents.add(actor.derivative);
  _otherEquivalents.add(actor.impulse);
  _otherEquivalents.add(actor.initialState.getPort());
  removeDependency(actor.derivative,actor.state);
}"
73885,"/** 
 * Return the interface of a given actor. In the case that the given actor is a CompositeActor, we will try to infer the interface from the contained actors. Otherwise, we will simply look for annotations of the interface contract, and chose the inputs and outputs of the actor as inputs and outputs of the interface.
 * @param actor The actor whose interface we are querying.
 * @return The overall interface.
 * @throws IllegalActionException
 */
private RelationalInterface _getInterface(Actor actor) throws IllegalActionException {
  if (actor instanceof CompositeActor) {
    RelationalInterface compositeInterface=_getCompositeInterface((CompositeActor)actor);
    System.out.println(""String_Node_Str"" + compositeInterface.getContract());
    return compositeInterface;
  }
  final String contract=_getSMTFormula(actor);
  return new RelationalInterface(actor.inputPortList(),actor.outputPortList(),contract);
}","/** 
 * Return the interface of a given actor. To find the contract, this method first checks for a parameter named _interfaceExpr that is a Ptolemy expression. If that doesn't exist, it looks for a parameter named _interfaceStr that is a string representation. In the case that neither of those two options work, and the given actor is a CompositeActor, we can try to infer the interface from those of the contained actors.
 * @param actor The actor whose interface we are querying.
 * @return The overall interface.
 * @throws IllegalActionException
 */
private RelationalInterface _getInterface(Actor actor) throws IllegalActionException {
  final Parameter interfaceExpr=(Parameter)((Entity)actor).getAttribute(""String_Node_Str"");
  final Parameter interfaceStr=(Parameter)((Entity)actor).getAttribute(""String_Node_Str"");
  String contract;
  if (interfaceExpr != null) {
    final String expression=interfaceExpr.getExpression();
    final PtParser parser=new PtParser();
    ASTPtRootNode parseTree;
    parseTree=parser.generateParseTree(expression);
    final SMTFormulaBuilder formulaBuilder=new SMTFormulaBuilder();
    contract=formulaBuilder.parseTreeToSMTFormula(parseTree);
  }
 else   if (interfaceStr != null) {
    contract=((StringToken)interfaceStr.getToken()).stringValue();
  }
 else   if (actor instanceof CompositeActor) {
    RelationalInterface compositeInterface=_getCompositeInterface((CompositeActor)actor);
    System.out.println(""String_Node_Str"" + compositeInterface.getContract());
    return compositeInterface;
  }
 else {
    throw new IllegalActionException(actor,""String_Node_Str"" + actor.toString());
  }
  return new RelationalInterface(actor.inputPortList(),actor.outputPortList(),contract);
}"
73886,"/** 
 * Infer the interface of a composite actor from its contained actors.
 * @param container The composite actor whose interface we are querying.
 * @return The inferred interface.
 * @throws IllegalActionException 
 */
private RelationalInterface _getCompositeInterface(CompositeActor container) throws IllegalActionException {
  final Set<String> newConstraints=new HashSet<String>();
  final Set<String> inputNames=new HashSet<String>();
  final List<IOPort> inputPorts=container.inputPortList();
  for (  final IOPort compositeIn : inputPorts) {
    inputNames.add(compositeIn.getName());
    for (    final IOPort insideIn : compositeIn.insideSinkPortList()) {
      newConstraints.add(""String_Node_Str"" + insideIn.getName() + ""String_Node_Str""+ compositeIn.getName()+ ""String_Node_Str"");
    }
  }
  final Set<String> outputNames=new HashSet<String>();
  final List<IOPort> outputPorts=container.outputPortList();
  for (  final IOPort compositeOut : outputPorts) {
    outputNames.add(compositeOut.getName());
    for (    final IOPort insideOut : compositeOut.insideSourcePortList()) {
      newConstraints.add(""String_Node_Str"" + insideOut.getName() + ""String_Node_Str""+ compositeOut.getName()+ ""String_Node_Str"");
    }
  }
  List<Entity> actors=container.entityList();
  if (actors.size() == 1) {
    final Actor actor=(Actor)actors.get(0);
    Set<Connection> connections=_getConnectionsBetween(actor,actor);
    RelationalInterface actorInterface=_getInterface(actor);
    System.err.println(""String_Node_Str"");
    if (!connections.isEmpty()) {
      actorInterface.addFeedback(connections);
    }
    newConstraints.add(actorInterface.getContract());
    outputNames.addAll(actorInterface.getVariables());
  }
 else   if (actors.size() == 2) {
    Set<Connection> selfLoop1=_getConnectionsBetween((Actor)actors.get(0),(Actor)actors.get(0));
    Set<Connection> selfLoop2=_getConnectionsBetween((Actor)actors.get(1),(Actor)actors.get(1));
    Set<Connection> connection1=_getConnectionsBetween((Actor)actors.get(0),(Actor)actors.get(1));
    Set<Connection> connection2=_getConnectionsBetween((Actor)actors.get(0),(Actor)actors.get(1));
    if (!selfLoop1.isEmpty() || !selfLoop2.isEmpty() || (!connection1.isEmpty() && !connection2.isEmpty())) {
      throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"");
    }
    final Actor actor0;
    final Actor actor1;
    if (connection2.isEmpty()) {
      actor0=(Actor)actors.get(0);
      actor1=(Actor)actors.get(1);
    }
 else {
      actor0=(Actor)actors.get(1);
      actor1=(Actor)actors.get(0);
    }
    Set<Connection> connections=_getConnectionsBetween(actor0,actor1);
    RelationalInterface compositeInterface;
    if (connections.isEmpty()) {
      compositeInterface=_getInterface(actor0).cascadeComposeWith(_getInterface(actor1),connections);
    }
 else {
      compositeInterface=_getInterface(actor0).parallelComposeWith(_getInterface(actor1));
    }
    newConstraints.add(compositeInterface.getContract());
    outputNames.addAll(compositeInterface.getVariables());
  }
 else   if (actors.size() > 2) {
    throw new IllegalActionException(container,""String_Node_Str"");
  }
  final String contract=LispExpression.conjunction(newConstraints);
  return new RelationalInterface(inputNames,outputNames,contract);
}","/** 
 * Infer the interface of a composite actor from its contained actors.
 * @param container The composite actor whose interface we are querying.
 * @return The inferred interface.
 * @throws IllegalActionException 
 */
private RelationalInterface _getCompositeInterface(CompositeActor container) throws IllegalActionException {
  final Set<String> newConstraints=new HashSet<String>();
  final Set<String> inputNames=new HashSet<String>();
  final List<IOPort> inputPorts=container.inputPortList();
  for (  final IOPort compositeIn : inputPorts) {
    inputNames.add(compositeIn.getName());
    final List<IOPort> linkedPorts=compositeIn.insidePortList();
    for (    final IOPort insideIn : linkedPorts) {
      newConstraints.add(""String_Node_Str"" + insideIn.getName() + ""String_Node_Str""+ compositeIn.getName()+ ""String_Node_Str"");
    }
  }
  final Set<String> outputNames=new HashSet<String>();
  final List<IOPort> outputPorts=container.outputPortList();
  for (  final IOPort compositeOut : outputPorts) {
    outputNames.add(compositeOut.getName());
    final List<IOPort> linkedPorts=compositeOut.insidePortList();
    for (    final IOPort insideOut : linkedPorts) {
      newConstraints.add(""String_Node_Str"" + insideOut.getName() + ""String_Node_Str""+ compositeOut.getName()+ ""String_Node_Str"");
    }
  }
  List<Entity> actors=container.entityList();
  if (actors.size() == 1) {
    final Actor actor=(Actor)actors.get(0);
    Set<Connection> connections=_getConnectionsBetween(actor,actor);
    RelationalInterface actorInterface=_getInterface(actor);
    if (!connections.isEmpty()) {
      actorInterface.addFeedback(connections);
    }
    newConstraints.add(actorInterface.getContract());
    outputNames.addAll(actorInterface.getVariables());
  }
 else   if (actors.size() == 2) {
    Set<Connection> selfLoop1=_getConnectionsBetween((Actor)actors.get(0),(Actor)actors.get(0));
    Set<Connection> selfLoop2=_getConnectionsBetween((Actor)actors.get(1),(Actor)actors.get(1));
    Set<Connection> connection1=_getConnectionsBetween((Actor)actors.get(0),(Actor)actors.get(1));
    Set<Connection> connection2=_getConnectionsBetween((Actor)actors.get(0),(Actor)actors.get(1));
    if (!selfLoop1.isEmpty() || !selfLoop2.isEmpty() || (!connection1.isEmpty() && !connection2.isEmpty())) {
      throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"");
    }
    final Actor actor0;
    final Actor actor1;
    if (connection2.isEmpty()) {
      actor0=(Actor)actors.get(0);
      actor1=(Actor)actors.get(1);
    }
 else {
      actor0=(Actor)actors.get(1);
      actor1=(Actor)actors.get(0);
    }
    Set<Connection> connections=_getConnectionsBetween(actor0,actor1);
    RelationalInterface compositeInterface;
    if (connections.isEmpty()) {
      compositeInterface=_getInterface(actor0).cascadeComposeWith(_getInterface(actor1),connections);
    }
 else {
      compositeInterface=_getInterface(actor0).parallelComposeWith(_getInterface(actor1));
    }
    newConstraints.add(compositeInterface.getContract());
    outputNames.addAll(compositeInterface.getVariables());
  }
 else   if (actors.size() > 2) {
    throw new IllegalActionException(container,""String_Node_Str"");
  }
  final String contract=LispExpression.conjunction(newConstraints);
  return new RelationalInterface(inputNames,outputNames,contract);
}"
73887,"/** 
 * Infer the interface of a composite actor from its contained actors.
 * @param container The composite actor whose interface we are querying.
 * @return The inferred interface.
 * @throws IllegalActionException 
 */
private RelationalInterface _getCompositeInterface(CompositeActor container) throws IllegalActionException {
  final Set<String> newConstraints=new HashSet<String>();
  final Set<String> inputNames=new HashSet<String>();
  final List<IOPort> inputPorts=container.inputPortList();
  for (  final IOPort compositeIn : inputPorts) {
    inputNames.add(compositeIn.getName());
    final List<IOPort> linkedPorts=compositeIn.insidePortList();
    for (    final IOPort insideIn : linkedPorts) {
      newConstraints.add(""String_Node_Str"" + insideIn.getName() + ""String_Node_Str""+ compositeIn.getName()+ ""String_Node_Str"");
    }
  }
  final Set<String> outputNames=new HashSet<String>();
  final List<IOPort> outputPorts=container.outputPortList();
  for (  final IOPort compositeOut : outputPorts) {
    outputNames.add(compositeOut.getName());
    final List<IOPort> linkedPorts=compositeOut.insidePortList();
    for (    final IOPort insideOut : linkedPorts) {
      newConstraints.add(""String_Node_Str"" + insideOut.getName() + ""String_Node_Str""+ compositeOut.getName()+ ""String_Node_Str"");
    }
  }
  List<Entity> actors=container.entityList();
  if (actors.size() == 1) {
    final Actor actor=(Actor)actors.get(0);
    Set<Connection> connections=_getConnectionsBetween(actor,actor);
    RelationalInterface actorInterface=_getInterface(actor);
    if (!connections.isEmpty()) {
      actorInterface.addFeedback(connections);
    }
    newConstraints.add(actorInterface.getContract());
    outputNames.addAll(actorInterface.getVariables());
  }
 else   if (actors.size() == 2) {
    Set<Connection> selfLoop1=_getConnectionsBetween((Actor)actors.get(0),(Actor)actors.get(0));
    Set<Connection> selfLoop2=_getConnectionsBetween((Actor)actors.get(1),(Actor)actors.get(1));
    Set<Connection> connection1=_getConnectionsBetween((Actor)actors.get(0),(Actor)actors.get(1));
    Set<Connection> connection2=_getConnectionsBetween((Actor)actors.get(0),(Actor)actors.get(1));
    if (!selfLoop1.isEmpty() || !selfLoop2.isEmpty() || (!connection1.isEmpty() && !connection2.isEmpty())) {
      throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"");
    }
    final Actor actor0;
    final Actor actor1;
    if (connection2.isEmpty()) {
      actor0=(Actor)actors.get(0);
      actor1=(Actor)actors.get(1);
    }
 else {
      actor0=(Actor)actors.get(1);
      actor1=(Actor)actors.get(0);
    }
    Set<Connection> connections=_getConnectionsBetween(actor0,actor1);
    RelationalInterface compositeInterface;
    if (connections.isEmpty()) {
      compositeInterface=_getInterface(actor0).cascadeComposeWith(_getInterface(actor1),connections);
    }
 else {
      compositeInterface=_getInterface(actor0).parallelComposeWith(_getInterface(actor1));
    }
    newConstraints.add(compositeInterface.getContract());
    outputNames.addAll(compositeInterface.getVariables());
  }
 else   if (actors.size() > 2) {
    throw new IllegalActionException(container,""String_Node_Str"");
  }
  final String contract=LispExpression.conjunction(newConstraints);
  return new RelationalInterface(inputNames,outputNames,contract);
}","/** 
 * Infer the interface of a composite actor from its contained actors.
 * @param container The composite actor whose interface we are querying.
 * @return The inferred interface.
 * @throws IllegalActionException 
 */
private RelationalInterface _getCompositeInterface(CompositeActor container) throws IllegalActionException {
  final Set<String> newConstraints=new HashSet<String>();
  final Set<String> inputNames=new HashSet<String>();
  final List<IOPort> inputPorts=container.inputPortList();
  for (  final IOPort compositeIn : inputPorts) {
    inputNames.add(compositeIn.getName());
    final List<IOPort> linkedPorts=compositeIn.insidePortList();
    for (    final IOPort insideIn : linkedPorts) {
      newConstraints.add(""String_Node_Str"" + insideIn.getName() + ""String_Node_Str""+ compositeIn.getName()+ ""String_Node_Str"");
    }
  }
  final Set<String> outputNames=new HashSet<String>();
  final List<IOPort> outputPorts=container.outputPortList();
  for (  final IOPort compositeOut : outputPorts) {
    outputNames.add(compositeOut.getName());
    final List<IOPort> linkedPorts=compositeOut.insidePortList();
    for (    final IOPort insideOut : linkedPorts) {
      newConstraints.add(""String_Node_Str"" + insideOut.getName() + ""String_Node_Str""+ compositeOut.getName()+ ""String_Node_Str"");
    }
  }
  List<Entity> actors=container.entityList();
  if (actors.size() == 1) {
    final Actor actor=(Actor)actors.get(0);
    Set<Connection> connections=_getConnectionsBetween(actor,actor);
    RelationalInterface actorInterface=_getInterface(actor);
    if (!connections.isEmpty()) {
      actorInterface.addFeedback(connections);
    }
    newConstraints.add(actorInterface.getContract());
    outputNames.addAll(actorInterface.getVariables());
  }
 else   if (actors.size() == 2) {
    Set<Connection> selfLoop1=_getConnectionsBetween((Actor)actors.get(0),(Actor)actors.get(0));
    Set<Connection> selfLoop2=_getConnectionsBetween((Actor)actors.get(1),(Actor)actors.get(1));
    Set<Connection> connection1=_getConnectionsBetween((Actor)actors.get(0),(Actor)actors.get(1));
    Set<Connection> connection2=_getConnectionsBetween((Actor)actors.get(1),(Actor)actors.get(0));
    System.err.println(""String_Node_Str"" + selfLoop1 + ""String_Node_Str""+ selfLoop2);
    System.err.println(""String_Node_Str"" + connection1 + ""String_Node_Str""+ connection2);
    if (!selfLoop1.isEmpty() || !selfLoop2.isEmpty() || (!connection1.isEmpty() && !connection2.isEmpty())) {
      throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"");
    }
    final Actor actor0;
    final Actor actor1;
    Set<Connection> connections;
    if (connection2.isEmpty()) {
      actor0=(Actor)actors.get(0);
      actor1=(Actor)actors.get(1);
      connections=connection1;
    }
 else {
      assert(connection1.isEmpty());
      actor0=(Actor)actors.get(1);
      actor1=(Actor)actors.get(0);
      connections=connection2;
    }
    RelationalInterface compositeInterface;
    if (connections.isEmpty()) {
      compositeInterface=_getInterface(actor0).parallelComposeWith(_getInterface(actor1));
    }
 else {
      compositeInterface=_getInterface(actor0).cascadeComposeWith(_getInterface(actor1),connections);
    }
    newConstraints.add(compositeInterface.getContract());
    outputNames.addAll(compositeInterface.getVariables());
  }
 else   if (actors.size() > 2) {
    throw new IllegalActionException(container,""String_Node_Str"");
  }
  final String contract=LispExpression.conjunction(newConstraints);
  return new RelationalInterface(inputNames,outputNames,contract);
}"
73888,"/** 
 * Return an interface that results from the cascade composition of this interface and the given interface. Note that this is not commutative.  The outputs of this interface must be connected to the inputs of the given interface.
 * @param rhs The interface to compose with.
 * @param connections The connections from this to rhs.
 * @return The comosition's interface.
 */
public RelationalInterface cascadeComposeWith(final RelationalInterface rhs,final Set<Connection> connections){
  final Set<String> newInputs=new HashSet<String>();
  newInputs.addAll(_inputPorts);
  newInputs.addAll(rhs._inputPorts);
  for (  final Connection c : connections) {
    newInputs.remove(c._inputPort);
  }
  final Set<String> newOutputs=new HashSet<String>();
  newOutputs.addAll(_outputPorts);
  newOutputs.addAll(rhs._outputPorts);
  for (  final Connection c : connections) {
    newOutputs.add(c._inputPort);
  }
  final String connectionContracts=Connection.getContract(connections);
  final Set<String> newConstraints=new HashSet<String>();
  newConstraints.add(_contract);
  newConstraints.add(rhs._contract);
  newConstraints.add(connectionContracts);
  final StringBuffer y=new StringBuffer(""String_Node_Str"");
  for (  final Connection c : connections) {
    y.append(c._inputPort + ""String_Node_Str"" + c._outputPort+ ""String_Node_Str"");
  }
  for (  final String firstInterfaceOutputVariable : _outputPorts) {
    y.append(firstInterfaceOutputVariable + ""String_Node_Str"");
  }
  y.append(""String_Node_Str"");
  final String phi=""String_Node_Str"" + _contract + ""String_Node_Str""+ connectionContracts+ ""String_Node_Str""+ rhs.inContract()+ ""String_Node_Str"";
  newConstraints.add(""String_Node_Str"" + y.toString() + ""String_Node_Str""+ phi+ ""String_Node_Str"");
  return new RelationalInterface(newInputs,newOutputs,LispExpression.conjunction(newConstraints));
}","/** 
 * Return an interface that results from the cascade composition of this interface and the given interface. Note that this is not commutative.  The outputs of this interface must be connected to the inputs of the given interface.
 * @param rhs The interface to compose with.
 * @param connections The connections from this to rhs.
 * @return The comosition's interface.
 */
public RelationalInterface cascadeComposeWith(final RelationalInterface rhs,final Set<Connection> connections){
  final Set<String> newInputs=new HashSet<String>();
  newInputs.addAll(_inputPorts);
  newInputs.addAll(rhs._inputPorts);
  for (  final Connection c : connections) {
    newInputs.remove(c._inputPort);
  }
  final Set<String> newOutputs=new HashSet<String>();
  newOutputs.addAll(_outputPorts);
  newOutputs.addAll(rhs._outputPorts);
  for (  final Connection c : connections) {
    newOutputs.add(c._inputPort);
  }
  final String connectionContracts=Connection.getContract(connections);
  final Set<String> newConstraints=new HashSet<String>();
  newConstraints.add(_contract);
  newConstraints.add(rhs._contract);
  newConstraints.add(connectionContracts);
  Set<String> quantifiedOutputs=new HashSet<String>();
  for (  final Connection c : connections) {
    quantifiedOutputs.add(c._inputPort + ""String_Node_Str"");
    quantifiedOutputs.add(c._outputPort + ""String_Node_Str"");
  }
  for (  final String firstInterfaceOutputVariable : _outputPorts) {
    quantifiedOutputs.add(firstInterfaceOutputVariable + ""String_Node_Str"");
  }
  final String y=LispExpression.node(""String_Node_Str"",quantifiedOutputs);
  final String phi=""String_Node_Str"" + _contract + ""String_Node_Str""+ connectionContracts+ ""String_Node_Str""+ rhs.inContract()+ ""String_Node_Str"";
  newConstraints.add(""String_Node_Str"" + y.toString() + ""String_Node_Str""+ phi+ ""String_Node_Str"");
  return new RelationalInterface(newInputs,newOutputs,LispExpression.conjunction(newConstraints));
}"
73889,"/** 
 * Create clusters of actor firing based on the dependencies on input firings.
 * @param outputFiringFunctions The list of firings that produces tokens to external actors.
 * @param inputFiringFunctions The list of firings that consumes external tokens.
 * @param clusteredOutputs The map from groups of input firings to the group of output firingsthat depend on the input firings.
 * @param outputInputDependence The map from each each output firing to the set of input firingsthat it depends on.
 * @param inInputConnectedPorts
 * @param inOutputConnectedPorts
 * @param firingClusters The cluster of frings.
 * @param clusters 
 * @throws IllegalActionException
 */
private void _clusterActorFirings(List<SimulationFiringFunction> outputFiringFunctions,List<SimulationFiringFunction> inputFiringFunctions,Map clusteredOutputs,Map outputInputDependence,Set<IOPort> inInputConnectedPorts,Set<IOPort> inOutputConnectedPorts,List<FiringCluster> firingClusters,Set clusters) throws IllegalActionException {
  for (Iterator firings=clusteredOutputs.keySet().iterator(); firings.hasNext(); ) {
    Set inputFirings=(Set)firings.next();
    Set clusteredFirings=new HashSet();
    FiringCluster firingCluster=new FiringCluster();
    Set searchedFirings=new HashSet();
    Set ouputFirings=(Set)clusteredOutputs.get(inputFirings);
    for (    Object ouputFiring : ouputFirings) {
      _clusterFirings((Firing)ouputFiring,clusteredFirings,searchedFirings,inputFirings,inputFiringFunctions,outputFiringFunctions,outputInputDependence);
    }
    List sortedFirings=new LinkedList(clusteredFirings);
    if (sortedFirings.size() > 0) {
      Set visitedFirings=new HashSet();
      _computeFiringDepth((Firing)sortedFirings.get(0),visitedFirings);
      FiringComparator comparator=new FiringComparator();
      Collections.sort(sortedFirings,comparator);
    }
    System.out.println(""String_Node_Str"");
    for (    Object f : sortedFirings) {
      firingCluster.actorFirings.add((Firing)f);
      ((Firing)f).cluster=firingCluster;
      Actor actor=((Firing)f).actor;
      if (actor instanceof ModularCompiledSDFTypedCompositeActor) {
        if (_getFiringFunction(inputFiringFunctions,actor,((Firing)f).firingFunction) != null) {
          Set<IOPort> inputPorts=new HashSet(actor.inputPortList());
          inputPorts.retainAll(inInputConnectedPorts);
          List<FiringFunctionPort> inputFiringPorts=((ModularCompiledSDFTypedCompositeActor)actor).getProfile().firings().get(((Firing)f).firingFunction).ports;
          for (          IOPort inputPort : inputPorts) {
            for (            FiringFunctionPort firingPort : inputFiringPorts) {
              if (firingPort.isInput && firingPort.externalPortName.equals(inputPort.getName())) {
                firingCluster.inputPorts.add(inputPort);
                break;
              }
            }
          }
        }
        if (_getFiringFunction(outputFiringFunctions,actor,((Firing)f).firingFunction) != null) {
          Set<IOPort> outputPorts=new HashSet(actor.outputPortList());
          outputPorts.retainAll(inOutputConnectedPorts);
          List<FiringFunctionPort> outputFiringPorts=((ModularCompiledSDFTypedCompositeActor)actor).getProfile().firings().get(((Firing)f).firingFunction).ports;
          for (          IOPort outputPort : outputPorts) {
            for (            FiringFunctionPort firingPort : outputFiringPorts) {
              if (!firingPort.isInput && firingPort.externalPortName.equals(outputPort.getName())) {
                firingCluster.outputPorts.add(outputPort);
                break;
              }
            }
          }
          firingCluster.outputPorts.addAll(outputPorts);
        }
      }
 else {
        if (_getFiringFunction(inputFiringFunctions,actor,((Firing)f).firingFunction) != null) {
          Set inputPorts=new HashSet(actor.inputPortList());
          inputPorts.retainAll(inInputConnectedPorts);
          firingCluster.inputPorts.addAll(inputPorts);
        }
        if (_getFiringFunction(outputFiringFunctions,actor,((Firing)f).firingFunction) != null) {
          Set outputPorts=new HashSet(actor.outputPortList());
          outputPorts.retainAll(inOutputConnectedPorts);
          firingCluster.outputPorts.addAll(outputPorts);
        }
      }
      System.out.println(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str""+ ((Firing)f).firingIndex+ ""String_Node_Str""+ ((Firing)f).firingFunction);
    }
    firingClusters.add(firingCluster);
    clusters.add(sortedFirings);
  }
}","/** 
 * Create clusters of actor firing based on the dependencies on input firings.
 * @param outputFiringFunctions The list of firings that produces tokens to external actors.
 * @param inputFiringFunctions The list of firings that consumes external tokens.
 * @param clusteredOutputs The map from groups of input firings to the group of output firingsthat depend on the input firings.
 * @param outputInputDependence The map from each each output firing to the set of input firingsthat it depends on.
 * @param inInputConnectedPorts
 * @param inOutputConnectedPorts
 * @param firingClusters The cluster of frings.
 * @param clusters 
 * @throws IllegalActionException
 */
private void _clusterActorFirings(List<SimulationFiringFunction> outputFiringFunctions,List<SimulationFiringFunction> inputFiringFunctions,Map clusteredOutputs,Map outputInputDependence,Set<IOPort> inInputConnectedPorts,Set<IOPort> inOutputConnectedPorts,List<FiringCluster> firingClusters,Set clusters) throws IllegalActionException {
  for (Iterator firings=clusteredOutputs.keySet().iterator(); firings.hasNext(); ) {
    Set inputFirings=(Set)firings.next();
    Set clusteredFirings=new HashSet();
    FiringCluster firingCluster=new FiringCluster();
    Set searchedFirings=new HashSet();
    Set outputFirings=(Set)clusteredOutputs.get(inputFirings);
    for (    Object outputFiring : outputFirings) {
      _clusterFirings((Firing)outputFiring,clusteredFirings,searchedFirings,inputFirings,inputFiringFunctions,outputFiringFunctions,outputInputDependence);
    }
    List sortedFirings=new LinkedList(clusteredFirings);
    if (sortedFirings.size() > 0) {
      Set visitedFirings=new HashSet();
      _computeFiringDepth((Firing)sortedFirings.get(0),visitedFirings);
      FiringComparator comparator=new FiringComparator();
      Collections.sort(sortedFirings,comparator);
    }
    System.out.println(""String_Node_Str"");
    for (    Object f : sortedFirings) {
      firingCluster.actorFirings.add((Firing)f);
      ((Firing)f).cluster=firingCluster;
      Actor actor=((Firing)f).actor;
      if (actor instanceof ModularCompiledSDFTypedCompositeActor) {
        if (_getFiringFunction(inputFiringFunctions,actor,((Firing)f).firingFunction) != null) {
          Set<IOPort> inputPorts=new HashSet(actor.inputPortList());
          inputPorts.retainAll(inInputConnectedPorts);
          List<FiringFunctionPort> inputFiringPorts=((ModularCompiledSDFTypedCompositeActor)actor).getProfile().firings().get(((Firing)f).firingFunction).ports;
          for (          IOPort inputPort : inputPorts) {
            for (            FiringFunctionPort firingPort : inputFiringPorts) {
              if (firingPort.isInput && firingPort.externalPortName.equals(inputPort.getName())) {
                firingCluster.inputPorts.add(inputPort);
                break;
              }
            }
          }
        }
        if (_getFiringFunction(outputFiringFunctions,actor,((Firing)f).firingFunction) != null) {
          Set<IOPort> outputPorts=new HashSet(actor.outputPortList());
          outputPorts.retainAll(inOutputConnectedPorts);
          List<FiringFunctionPort> outputFiringPorts=((ModularCompiledSDFTypedCompositeActor)actor).getProfile().firings().get(((Firing)f).firingFunction).ports;
          for (          IOPort outputPort : outputPorts) {
            for (            FiringFunctionPort firingPort : outputFiringPorts) {
              if (!firingPort.isInput && firingPort.externalPortName.equals(outputPort.getName())) {
                firingCluster.outputPorts.add(outputPort);
                break;
              }
            }
          }
          firingCluster.outputPorts.addAll(outputPorts);
        }
      }
 else {
        if (_getFiringFunction(inputFiringFunctions,actor,((Firing)f).firingFunction) != null) {
          Set inputPorts=new HashSet(actor.inputPortList());
          inputPorts.retainAll(inInputConnectedPorts);
          firingCluster.inputPorts.addAll(inputPorts);
        }
        if (_getFiringFunction(outputFiringFunctions,actor,((Firing)f).firingFunction) != null) {
          Set outputPorts=new HashSet(actor.outputPortList());
          outputPorts.retainAll(inOutputConnectedPorts);
          firingCluster.outputPorts.addAll(outputPorts);
        }
      }
      System.out.println(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str""+ ((Firing)f).firingIndex+ ""String_Node_Str""+ ((Firing)f).firingFunction);
    }
    firingClusters.add(firingCluster);
    clusters.add(sortedFirings);
  }
}"
73890,"/** 
 * Return the output port (source port) that connects to an input port.
 * @param inputPort The input port.
 * @return Return the output port (source port) that connects toan input port.
 */
private IOPort _getConnectedOutputPort(IOPort inputPort){
  IOPort outputPort=null;
  for (Iterator inputPorts=inputPort.connectedPortList().iterator(); inputPorts.hasNext(); ) {
    IOPort port=(IOPort)inputPorts.next();
    if (port.isOutput()) {
      if (port.getContainer() instanceof SampleDelay) {
        outputPort=_getConnectedOutputPort(((SampleDelay)port.getContainer()).input);
      }
 else       outputPort=port;
      break;
    }
  }
  return outputPort;
}","/** 
 * Return the output port (source port) that connects to an input port.
 * @param inputPort The input port.
 * @return Return the output port (source port) that connects toan input port.
 */
private IOPort _getConnectedOutputPort(IOPort inputPort){
  IOPort outputPort=null;
  for (Iterator inputPorts=inputPort.sourcePortList().iterator(); inputPorts.hasNext(); ) {
    IOPort port=(IOPort)inputPorts.next();
    if (port.isOutput()) {
      if (port.getContainer() instanceof SampleDelay) {
        outputPort=_getConnectedOutputPort(((SampleDelay)port.getContainer()).input);
      }
 else       outputPort=port;
      break;
    }
  }
  return outputPort;
}"
73891,"/** 
 * Compute the depths of clusters to obtain cluster firing order.
 * @param cluster
 * @param visitedClusters
 */
private void _computeClusterDepth(FiringCluster cluster,Map visitedClusters){
  for (  FiringCluster nextCluster : cluster.nextClusters) {
    if (nextCluster.index <= cluster.index) {
      nextCluster.index=cluster.index + 1;
    }
    if (visitedClusters.get(cluster.hashCode() ^ nextCluster.hashCode()) == null) {
      Integer value=1;
      visitedClusters.put(cluster.hashCode() ^ nextCluster.hashCode(),value);
      _computeClusterDepth(nextCluster,visitedClusters);
    }
  }
  for (  FiringCluster previousCluster : cluster.previousClusters) {
    if (previousCluster.index >= cluster.index) {
      previousCluster.index=cluster.index - 1;
    }
    if (visitedClusters.get(cluster.hashCode() ^ previousCluster.hashCode()) == null) {
      Integer value=1;
      visitedClusters.put(cluster.hashCode() ^ previousCluster.hashCode(),value);
      _computeClusterDepth(previousCluster,visitedClusters);
    }
  }
}","/** 
 * Compute the depths of clusters to obtain cluster firing order.
 * @param cluster The cluster whose depth is computed.
 * @param visitedClusters the list of visited clusters.
 */
private void _computeClusterDepth(FiringCluster cluster,Map visitedClusters){
  for (  FiringCluster nextCluster : cluster.nextClusters) {
    if (nextCluster.index <= cluster.index) {
      nextCluster.index=cluster.index + 1;
    }
    if (visitedClusters.get(cluster.hashCode() ^ nextCluster.hashCode()) == null) {
      Integer value=1;
      visitedClusters.put(cluster.hashCode() ^ nextCluster.hashCode(),value);
      _computeClusterDepth(nextCluster,visitedClusters);
    }
  }
  for (  FiringCluster previousCluster : cluster.previousClusters) {
    if (previousCluster.index >= cluster.index) {
      previousCluster.index=cluster.index - 1;
    }
    if (visitedClusters.get(cluster.hashCode() ^ previousCluster.hashCode()) == null) {
      Integer value=1;
      visitedClusters.put(cluster.hashCode() ^ previousCluster.hashCode(),value);
      _computeClusterDepth(previousCluster,visitedClusters);
    }
  }
}"
73892,"/** 
 * Cluster firings together so that there is no false dependency.
 * @param currentFiring
 * @param clusteredFirings
 * @param searchedFirings
 * @param inputFirings
 * @param inputActors
 * @param outputActors
 * @param outputInputDependence The map form each output firing to a set of input firingsthat its depend on.
 */
private void _clusterFirings(Firing currentFiring,Set clusteredFirings,Set searchedFirings,Set inputFirings,List inputActors,List outputActors,Map outputInputDependence){
  searchedFirings.add(currentFiring);
  Set currentSearchedFirings=new HashSet();
  Set outputFirings=new HashSet();
  _getDependentForwardFiring(currentFiring,outputFirings,currentSearchedFirings,inputActors,outputActors);
  boolean validFiring=true;
  for (  Object outputFiring : outputFirings) {
    Set inputDependentFirings=(Set)outputInputDependence.get(outputFiring);
    Set tmpInputFiring=new HashSet(inputFirings);
    tmpInputFiring.removeAll(inputDependentFirings);
    if (!tmpInputFiring.isEmpty()) {
      validFiring=false;
      break;
    }
  }
  if (validFiring) {
    clusteredFirings.add(currentFiring);
    for (Iterator previousFirings=currentFiring.previousActorFirings.iterator(); previousFirings.hasNext(); ) {
      Firing previousFiring=(Firing)previousFirings.next();
      if (!searchedFirings.contains(previousFiring)) {
        _clusterFirings(previousFiring,clusteredFirings,searchedFirings,inputFirings,inputActors,outputActors,outputInputDependence);
      }
    }
  }
}","/** 
 * Cluster firings together so that there is no false dependency.
 * @param currentFiring Pointer to current node in the firing graph.
 * @param clusteredFirings The output set of clustered firings.
 * @param searchedFirings The set of searched firing used for searching.
 * @param inputFirings The set of output firings (produce external tokens).
 * @param inputActors The set of actors that consume external tokens.
 * @param outputActors The set of actors that produce external tokens.
 * @param outputInputDependence The map form each output firing to a set of input firingsthat its depend on.
 */
private void _clusterFirings(Firing currentFiring,Set clusteredFirings,Set searchedFirings,Set inputFirings,List inputActors,List outputActors,Map outputInputDependence){
  searchedFirings.add(currentFiring);
  Set currentSearchedFirings=new HashSet();
  Set outputFirings=new HashSet();
  _getDependentForwardFiring(currentFiring,outputFirings,currentSearchedFirings,inputActors,outputActors);
  boolean validFiring=true;
  for (  Object outputFiring : outputFirings) {
    Set inputDependentFirings=(Set)outputInputDependence.get(outputFiring);
    Set tmpInputFiring=new HashSet(inputFirings);
    tmpInputFiring.removeAll(inputDependentFirings);
    if (!tmpInputFiring.isEmpty()) {
      validFiring=false;
      break;
    }
  }
  if (validFiring) {
    clusteredFirings.add(currentFiring);
    for (Iterator previousFirings=currentFiring.previousActorFirings.iterator(); previousFirings.hasNext(); ) {
      Firing previousFiring=(Firing)previousFirings.next();
      if (!searchedFirings.contains(previousFiring)) {
        _clusterFirings(previousFiring,clusteredFirings,searchedFirings,inputFirings,inputActors,outputActors,outputInputDependence);
      }
    }
    for (Iterator nextFirings=currentFiring.nextActorFirings.iterator(); nextFirings.hasNext(); ) {
      Firing nextFiring=(Firing)nextFirings.next();
      if (!searchedFirings.contains(nextFiring)) {
        _clusterFirings(nextFiring,clusteredFirings,searchedFirings,inputFirings,inputActors,outputActors,outputInputDependence);
      }
    }
  }
}"
73893,"/** 
 * Return the property lattice for this constraint solver.
 * @return The property lattice for this constraint solver.
 */
public PropertyLattice getLattice(){
  String propertyLatticeValue=propertyLattice.getExpression();
  _lattice=PropertyLattice.getPropertyLattice(propertyLatticeValue);
  if (_lattice == null && propertyLatticeValue.startsWith(_USER_DEFINED_LATTICE)) {
    String latticeName=propertyLatticeValue.replace(_USER_DEFINED_LATTICE,""String_Node_Str"");
    PropertyLatticeAttribute latticeAttribute=(PropertyLatticeAttribute)((CompositeEntity)getContainer()).getAttribute(latticeName);
    _lattice=latticeAttribute.getPropertyLattice();
    PropertyLattice.storeLattice(_lattice,latticeName);
  }
  return _lattice;
}","/** 
 * Return the property lattice for this constraint solver.
 * @return The property lattice for this constraint solver.
 */
public PropertyLattice getLattice(){
  String propertyLatticeValue=propertyLattice.getExpression();
  return _lattice;
}"
73894,"/** 
 * Resolve the properties of the given top-level container, subject to the given constraint list.
 * @param toplevel The top-level container
 * @param toplevelHelper Must be toplevel.getHelper()
 * @param constraintList The constraint list that we are solving
 * @throws TypeConflictException If an unacceptable solution is reached
 * @throws PropertyResolutionException If constraints are unsatisfiable
 */
protected void _resolveProperties(NamedObj toplevel,PropertyConstraintHelper toplevelHelper,List<Inequality> constraintList) throws TypeConflictException, PropertyResolutionException {
  Writer writer=null;
  List<Inequality> conflicts=new LinkedList<Inequality>();
  List<Inequality> unacceptable=new LinkedList<Inequality>();
  try {
    if (constraintList.size() > 0) {
      CPO cpo=getLattice();
      InequalitySolver solver=new InequalitySolver(cpo,this);
      solver.addInequalities(constraintList.iterator());
      _constraintManager.setConstraints(constraintList);
      getStats().put(""String_Node_Str"",constraintList.size());
      getStats().put(""String_Node_Str"",_propertyTermManager.terms().size());
      File file=null;
      Date date=new Date();
      String timestamp=date.toString().replace(""String_Node_Str"",""String_Node_Str"");
      String logFilename=getContainer().getName() + ""String_Node_Str"" + getUseCaseName()+ ""String_Node_Str""+ timestamp.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
      if (super.isResolve() && isLogMode()) {
        String directoryPath=logDirectory.getExpression();
        directoryPath+=directoryPath.endsWith(""String_Node_Str"") || directoryPath.endsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
        if (directoryPath.startsWith(""String_Node_Str"")) {
          URI directory=new File(URIAttribute.getModelURI(this)).getParentFile().toURI();
          file=FileUtilities.nameToFile(directoryPath.substring(11) + logFilename,directory);
        }
 else {
          if (!logDirectory.asFile().exists()) {
            if (!logDirectory.asFile().mkdirs()) {
              throw new IllegalActionException(this,""String_Node_Str"" + logDirectory.asFile().getAbsolutePath() + ""String_Node_Str"");
            }
          }
          file=FileUtilities.nameToFile(logFilename,logDirectory.asFile().toURI());
        }
        try {
          if (!file.exists()) {
            if (!file.getParentFile().exists()) {
              if (!file.getParentFile().mkdirs()) {
                throw new IllegalActionException(this,""String_Node_Str"" + file.getParentFile().getAbsolutePath() + ""String_Node_Str"");
              }
            }
            if (!file.createNewFile()) {
              throw new IllegalActionException(this,""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
            }
          }
          writer=new FileWriter(file);
          writer.write(_getStatsAsString(""String_Node_Str""));
          writer.write(_getConstraintsAsLogFileString(constraintList,""String_Node_Str""));
        }
 catch (        IOException ex) {
          throw new PropertyResolutionException(this,ex,""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
        }
      }
      if (super.isResolve() && isLogMode()) {
        String constraintFilename=_getTrainedConstraintFilename() + ""String_Node_Str"";
        _logHelperConstraints(toplevelHelper);
        _updateConstraintFile(constraintFilename);
      }
      if (!isCollectConstraints()) {
        if (solvingFixedPoint.stringValue().equals(""String_Node_Str"")) {
          solver.solveGreatest(isInitializeSolver());
        }
 else {
          solver.solveLeast(isInitializeSolver());
        }
      }
      if (super.isResolve() && isLogMode()) {
        try {
          writer.write(_getConstraintsAsLogFileString(constraintList,""String_Node_Str""));
          writer.close();
        }
 catch (        IOException ex) {
          throw new PropertyResolutionException(this,ex,""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
        }
      }
      for (      Inequality inequality : constraintList) {
        if (!inequality.isSatisfied(_lattice)) {
          conflicts.add(inequality);
        }
 else {
          boolean isAcceptable=true;
          InequalityTerm[] lesserVariables=inequality.getLesserTerm().getVariables();
          InequalityTerm[] greaterVariables=inequality.getGreaterTerm().getVariables();
          for (          InequalityTerm variable : lesserVariables) {
            if (!variable.isValueAcceptable()) {
              unacceptable.add(inequality);
              isAcceptable=false;
              break;
            }
          }
          if (isAcceptable) {
            for (            InequalityTerm variable : greaterVariables) {
              if (!variable.isValueAcceptable()) {
                unacceptable.add(inequality);
                break;
              }
            }
          }
        }
      }
    }
    if (!isInitializeSolver() && !isCollectConstraints()) {
      if (conflicts.size() > 0) {
        throw new PropertyResolutionException(this,toplevel(),""String_Node_Str"" + toplevel().getFullName() + ""String_Node_Str""+ conflicts);
      }
      if (unacceptable.size() > 0) {
        throw new TypeConflictException(unacceptable,""String_Node_Str"" + toplevel.getFullName() + ""String_Node_Str"");
      }
    }
  }
 catch (  IllegalActionException ex) {
    throw new PropertyResolutionException(this,toplevel,ex,""String_Node_Str"" + ""String_Node_Str"");
  }
 finally {
    if (writer != null) {
      try {
        writer.close();
      }
 catch (      IOException ex) {
        throw new PropertyResolutionException(this,toplevel(),ex,""String_Node_Str"");
      }
    }
  }
}","/** 
 * Resolve the properties of the given top-level container, subject to the given constraint list.
 * @param toplevel The top-level container
 * @param toplevelHelper Must be toplevel.getHelper()
 * @param constraintList The constraint list that we are solving
 * @throws TypeConflictException If an unacceptable solution is reached
 * @throws PropertyResolutionException If constraints are unsatisfiable
 */
protected void _resolveProperties(NamedObj toplevel,PropertyConstraintHelper toplevelHelper,List<Inequality> constraintList) throws TypeConflictException, PropertyResolutionException {
  Writer writer=null;
  List<Inequality> conflicts=new LinkedList<Inequality>();
  List<Inequality> unacceptable=new LinkedList<Inequality>();
  try {
    if (constraintList.size() > 0) {
      CPO cpo=getLattice();
      ptolemy.graph.InequalitySolver solver=new ptolemy.graph.InequalitySolver(cpo);
      solver.addInequalities(constraintList.iterator());
      _constraintManager.setConstraints(constraintList);
      getStats().put(""String_Node_Str"",constraintList.size());
      getStats().put(""String_Node_Str"",_propertyTermManager.terms().size());
      File file=null;
      Date date=new Date();
      String timestamp=date.toString().replace(""String_Node_Str"",""String_Node_Str"");
      String logFilename=getContainer().getName() + ""String_Node_Str"" + getUseCaseName()+ ""String_Node_Str""+ timestamp.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
      if (super.isResolve() && isLogMode()) {
        String directoryPath=logDirectory.getExpression();
        directoryPath+=directoryPath.endsWith(""String_Node_Str"") || directoryPath.endsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
        if (directoryPath.startsWith(""String_Node_Str"")) {
          URI directory=new File(URIAttribute.getModelURI(this)).getParentFile().toURI();
          file=FileUtilities.nameToFile(directoryPath.substring(11) + logFilename,directory);
        }
 else {
          if (!logDirectory.asFile().exists()) {
            if (!logDirectory.asFile().mkdirs()) {
              throw new IllegalActionException(this,""String_Node_Str"" + logDirectory.asFile().getAbsolutePath() + ""String_Node_Str"");
            }
          }
          file=FileUtilities.nameToFile(logFilename,logDirectory.asFile().toURI());
        }
        try {
          if (!file.exists()) {
            if (!file.getParentFile().exists()) {
              if (!file.getParentFile().mkdirs()) {
                throw new IllegalActionException(this,""String_Node_Str"" + file.getParentFile().getAbsolutePath() + ""String_Node_Str"");
              }
            }
            if (!file.createNewFile()) {
              throw new IllegalActionException(this,""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
            }
          }
          writer=new FileWriter(file);
          writer.write(_getStatsAsString(""String_Node_Str""));
          writer.write(_getConstraintsAsLogFileString(constraintList,""String_Node_Str""));
        }
 catch (        IOException ex) {
          throw new PropertyResolutionException(this,ex,""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
        }
      }
      if (super.isResolve() && isLogMode()) {
        String constraintFilename=_getTrainedConstraintFilename() + ""String_Node_Str"";
        _logHelperConstraints(toplevelHelper);
        _updateConstraintFile(constraintFilename);
      }
      if (!isCollectConstraints()) {
        if (solvingFixedPoint.stringValue().equals(""String_Node_Str"")) {
          solver.solveGreatest();
        }
 else {
          solver.solveLeast();
        }
      }
      if (super.isResolve() && isLogMode()) {
        try {
          writer.write(_getConstraintsAsLogFileString(constraintList,""String_Node_Str""));
          writer.close();
        }
 catch (        IOException ex) {
          throw new PropertyResolutionException(this,ex,""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
        }
      }
      for (      Inequality inequality : constraintList) {
        if (!inequality.isSatisfied(_lattice)) {
          conflicts.add(inequality);
        }
 else {
          boolean isAcceptable=true;
          InequalityTerm[] lesserVariables=inequality.getLesserTerm().getVariables();
          InequalityTerm[] greaterVariables=inequality.getGreaterTerm().getVariables();
          for (          InequalityTerm variable : lesserVariables) {
            if (!variable.isValueAcceptable()) {
              unacceptable.add(inequality);
              isAcceptable=false;
              break;
            }
          }
          if (isAcceptable) {
            for (            InequalityTerm variable : greaterVariables) {
              if (!variable.isValueAcceptable()) {
                unacceptable.add(inequality);
                break;
              }
            }
          }
        }
      }
    }
    if (!isInitializeSolver() && !isCollectConstraints()) {
      if (conflicts.size() > 0) {
        throw new PropertyResolutionException(this,toplevel(),""String_Node_Str"" + toplevel().getFullName() + ""String_Node_Str""+ conflicts);
      }
      if (unacceptable.size() > 0) {
        throw new TypeConflictException(unacceptable,""String_Node_Str"" + toplevel.getFullName() + ""String_Node_Str"");
      }
    }
  }
 catch (  IllegalActionException ex) {
    throw new PropertyResolutionException(this,toplevel,ex,""String_Node_Str"" + ""String_Node_Str"");
  }
 finally {
    if (writer != null) {
      try {
        writer.close();
      }
 catch (      IOException ex) {
        throw new PropertyResolutionException(this,toplevel(),ex,""String_Node_Str"");
      }
    }
  }
}"
73895,"private void _readConstraintFile(String filename) throws PropertyFailedRegressionTestException {
  File file=new File(filename);
  try {
    BufferedReader reader=null;
    try {
      reader=new BufferedReader(new FileReader(file));
      String line=reader.readLine();
      while (line != null) {
        _trainedConstraints.add(line);
        line=reader.readLine();
      }
      getStats().put(""String_Node_Str"",_trainedConstraints.size());
    }
  finally {
      if (reader != null) {
        reader.close();
      }
    }
  }
 catch (  IOException ex) {
    throw new PropertyFailedRegressionTestException(this,""String_Node_Str"" + filename + ""String_Node_Str"");
  }
}","private void _readConstraintFile(String filename){
  File file=new File(filename);
  try {
    BufferedReader reader=null;
    try {
      reader=new BufferedReader(new FileReader(file));
      String line=reader.readLine();
      while (line != null) {
        _trainedConstraints.add(line);
        line=reader.readLine();
      }
      getStats().put(""String_Node_Str"",_trainedConstraints.size());
    }
  finally {
      if (reader != null) {
        reader.close();
      }
    }
  }
 catch (  IOException ex) {
  }
}"
73896,"/** 
 * Return the property value associated with the specified object.
 * @param object The specified object.
 * @return The property of the specified object.
 */
public Property getProperty(Object object){
  try {
    return (Property)getPropertyTerm(object).getValue();
  }
 catch (  IllegalActionException ex) {
    return null;
  }
}","/** 
 * Return the property value associated with the specified object.
 * @param object The specified object.
 * @return The property of the specified object.
 */
public Concept getProperty(Object object){
  try {
    return (Concept)getPropertyTerm(object).getValue();
  }
 catch (  IllegalActionException ex) {
    return null;
  }
}"
73897,"/** 
 * @param container The given container.
 * @param name The given name
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
public PropertyConstraintSolver(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  propertyLattice=new StringParameter(this,""String_Node_Str"");
  propertyLattice.setExpression(""String_Node_Str"");
  solvingFixedPoint=new StringParameter(this,""String_Node_Str"");
  solvingFixedPoint.setExpression(""String_Node_Str"");
  actorConstraintType=new StringParameter(this,""String_Node_Str"");
  actorConstraintType.setExpression(""String_Node_Str"");
  connectionConstraintType=new StringParameter(this,""String_Node_Str"");
  connectionConstraintType.setExpression(""String_Node_Str"");
  compositeConnectionConstraintType=new StringParameter(this,""String_Node_Str"");
  compositeConnectionConstraintType.setExpression(""String_Node_Str"");
  fsmConstraintType=new StringParameter(this,""String_Node_Str"");
  fsmConstraintType.setExpression(""String_Node_Str"");
  expressionASTNodeConstraintType=new StringParameter(this,""String_Node_Str"");
  expressionASTNodeConstraintType.setExpression(""String_Node_Str"");
  logMode=new Parameter(this,""String_Node_Str"");
  logMode.setTypeEquals(BaseType.BOOLEAN);
  logMode.setExpression(""String_Node_Str"");
  logDirectory=new FileParameter(this,""String_Node_Str"");
  logDirectory.setExpression(""String_Node_Str"");
  trainedConstraintDirectory=new FileParameter(this,""String_Node_Str"");
  trainedConstraintDirectory.setExpression(""String_Node_Str"");
  _addChoices();
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  new PropertySolverGUIFactory(this,""String_Node_Str"");
}","/** 
 * @param container The given container.
 * @param name The given name
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
public PropertyConstraintSolver(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  propertyLattice=new StringParameter(this,""String_Node_Str"");
  propertyLattice.setExpression(""String_Node_Str"");
  solvingFixedPoint=new StringParameter(this,""String_Node_Str"");
  solvingFixedPoint.setExpression(""String_Node_Str"");
  actorConstraintType=new StringParameter(this,""String_Node_Str"");
  actorConstraintType.setExpression(""String_Node_Str"");
  connectionConstraintType=new StringParameter(this,""String_Node_Str"");
  connectionConstraintType.setExpression(""String_Node_Str"");
  compositeConnectionConstraintType=new StringParameter(this,""String_Node_Str"");
  compositeConnectionConstraintType.setExpression(""String_Node_Str"");
  fsmConstraintType=new StringParameter(this,""String_Node_Str"");
  fsmConstraintType.setExpression(""String_Node_Str"");
  expressionASTNodeConstraintType=new StringParameter(this,""String_Node_Str"");
  expressionASTNodeConstraintType.setExpression(""String_Node_Str"");
  logMode=new Parameter(this,""String_Node_Str"");
  logMode.setTypeEquals(BaseType.BOOLEAN);
  logMode.setExpression(""String_Node_Str"");
  logDirectory=new FileParameter(this,""String_Node_Str"");
  logDirectory.setExpression(""String_Node_Str"");
  trainedConstraintDirectory=new FileParameter(this,""String_Node_Str"");
  trainedConstraintDirectory.setExpression(""String_Node_Str"");
  _addChoices();
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
73898,"protected PropertyHelper _getHelper(Object component) throws IllegalActionException {
  PropertyHelper adapter=null;
  try {
    adapter=super._getHelper(component);
  }
 catch (  IllegalActionException ex) {
  }
  if (adapter == null) {
    if (component instanceof FSMActor) {
      adapter=new PropertyConstraintFSMHelper(this,(FSMActor)component);
    }
 else     if (component instanceof ptolemy.domains.modal.kernel.FSMActor) {
      adapter=new PropertyConstraintModalFSMHelper(this,(ptolemy.domains.modal.kernel.FSMActor)component);
    }
 else     if (component instanceof CompositeEntity) {
      adapter=new PropertyConstraintCompositeHelper(this,(CompositeEntity)component);
    }
 else     if (component instanceof ASTPtRootNode) {
      adapter=new PropertyConstraintASTNodeHelper(this,(ASTPtRootNode)component);
    }
 else {
      adapter=new PropertyConstraintHelper(this,component);
    }
  }
  _adapterStore.put(component,adapter);
  return adapter;
}","protected PropertyHelper _getHelper(Object component) throws IllegalActionException {
  PropertyHelper adapter=null;
  try {
    adapter=super._getHelper(component);
  }
 catch (  IllegalActionException ex) {
  }
  if (adapter == null) {
    if (component instanceof FSMActor) {
    }
 else {
      adapter=new PropertyConstraintHelper(this,component);
    }
  }
  _adapterStore.put(component,adapter);
  return adapter;
}"
73899,"/** 
 * Resolve the property values for the toplevel entity that contains this solver, given the model analyzer that invokes this.
 * @param analyzer The given model analyzer.
 */
protected void _resolveProperties(NamedObj analyzer) throws KernelException {
  NamedObj toplevel=_toplevel();
  PropertyConstraintHelper toplevelHelper=(PropertyConstraintHelper)getHelper(toplevel);
  toplevelHelper.reinitialize();
  toplevelHelper._addDefaultConstraints(_getConstraintType(actorConstraintType.stringValue()));
  toplevelHelper._setConnectionConstraintType(_getConstraintType(connectionConstraintType.stringValue()),_getConstraintType(compositeConnectionConstraintType.stringValue()),_getConstraintType(fsmConstraintType.stringValue()),_getConstraintType(expressionASTNodeConstraintType.stringValue()));
  List<Inequality> constraintList=toplevelHelper.constraintList();
  _resolveProperties(toplevel,toplevelHelper,constraintList);
  if (errorsExist()) {
    _doDeltaIteration(toplevel,toplevelHelper,constraintList);
  }
}","/** 
 * Resolve the property values for the toplevel entity that contains this solver, given the model analyzer that invokes this.
 * @param analyzer The given model analyzer.
 * @throws KernelException If the superclass throws it.
 */
protected void _resolveProperties(NamedObj analyzer) throws KernelException {
  NamedObj toplevel=_toplevel();
  PropertyConstraintHelper toplevelHelper=(PropertyConstraintHelper)getHelper(toplevel);
  toplevelHelper.reinitialize();
  toplevelHelper._addDefaultConstraints(_getConstraintType(actorConstraintType.stringValue()));
  toplevelHelper._setConnectionConstraintType(_getConstraintType(connectionConstraintType.stringValue()),_getConstraintType(compositeConnectionConstraintType.stringValue()),_getConstraintType(fsmConstraintType.stringValue()),_getConstraintType(expressionASTNodeConstraintType.stringValue()));
  List<Inequality> constraintList=toplevelHelper.constraintList();
  _resolveProperties(toplevel,toplevelHelper,constraintList);
  if (errorsExist()) {
    _doDeltaIteration(toplevel,toplevelHelper,constraintList);
  }
}"
73900,"public DeltaConstraintSolver(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
}","/** 
 * Constructs a DeltaConstraintSolver with the given name contained by the specified entity. 
 * @param container  The container.
 * @param name       The name of this DeltaConstraintSolver
 * @throws IllegalActionException If the superclass throws it.
 * @throws NameDuplicationException If the superclass throws it.
 */
public DeltaConstraintSolver(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
}"
73901,"/** 
 * Construct a matrix containing the children nodes. The specified node ends up with a MatrixToken value.
 * @param node The specified node.
 * @exception IllegalActionException If an parse error occurs.
 */
public void visitMatrixConstructNode(ASTPtMatrixConstructNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    _evaluatedChildToken=node.getToken();
    _childCode=_evaluatedChildToken.toString();
    return;
  }
  int row=node.getRowCount();
  int column=node.getColumnCount();
  ptolemy.data.Token[] tokens=new ptolemy.data.Token[row * column];
  StringBuffer result=new StringBuffer(row + ""String_Node_Str"" + column+ ""String_Node_Str""+ row * column);
  ptolemy.data.Token childToken=null;
  ptolemy.data.type.Type elementType=BaseType.UNKNOWN;
  if (node.getForm() == 1) {
    for (int i=0; i < row; i++) {
      for (int j=0; j < column; j++) {
        result.append(""String_Node_Str"");
        int index=(i * column) + j;
        tokens[index]=_evaluateChild(node,index);
        Type valueType=tokens[index].getType();
        if (_isPrimitive(valueType)) {
          result.append(""String_Node_Str"" + _codeGenType(valueType) + ""String_Node_Str""+ _childCode+ ""String_Node_Str"");
        }
        if (!elementType.equals(valueType)) {
          elementType=TypeLattice.leastUpperBound(elementType,valueType);
        }
      }
    }
    String codegenType=_codeGenType(elementType);
    if (_targetType(elementType).equals(""String_Node_Str"")) {
      result.append(""String_Node_Str"");
    }
 else {
      result.append(""String_Node_Str"" + codegenType);
    }
    result.append(""String_Node_Str"" + ""String_Node_Str"" + result);
    _childCode=result.toString() + ""String_Node_Str"";
    childToken=MatrixToken.arrayToMatrix(tokens,node.getRowCount(),node.getColumnCount());
  }
 else   if (node.getForm() == 2) {
    try {
      int columnCount=MatrixToken.determineSequenceLength((ScalarToken)tokens[0],(ScalarToken)tokens[1],(ScalarToken)tokens[2]);
      for (int i=1; i < node.getRowCount(); ++i) {
        if (columnCount != MatrixToken.determineSequenceLength((ScalarToken)tokens[3 * i],(ScalarToken)tokens[(3 * i) + 1],(ScalarToken)tokens[(3 * i) + 2])) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      ptolemy.data.Token[] matrixTokens=new ptolemy.data.Token[node.getRowCount() * columnCount];
      for (int i=0; i < node.getRowCount(); i++) {
        ptolemy.data.Token[] newTokens=MatrixToken.createSequence(tokens[3 * i],tokens[(3 * i) + 1],columnCount);
        System.arraycopy(newTokens,0,matrixTokens,columnCount * i,columnCount);
      }
      childToken=MatrixToken.arrayToMatrix(matrixTokens,node.getRowCount(),columnCount);
    }
 catch (    IllegalActionException ex) {
      throw new IllegalActionException(null,null,ex,""String_Node_Str"");
    }
  }
  _evaluatedChildToken=(childToken);
}","/** 
 * Construct a matrix containing the children nodes. The specified node ends up with a MatrixToken value.
 * @param node The specified node.
 * @exception IllegalActionException If an parse error occurs.
 */
public void visitMatrixConstructNode(ASTPtMatrixConstructNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    _evaluatedChildToken=node.getToken();
    _childCode=_evaluatedChildToken.toString();
    return;
  }
  int row=node.getRowCount();
  int column=node.getColumnCount();
  ptolemy.data.Token[] tokens=new ptolemy.data.Token[row * column];
  StringBuffer result=new StringBuffer(row + ""String_Node_Str"" + column+ ""String_Node_Str""+ row * column);
  ptolemy.data.Token childToken=null;
  ptolemy.data.type.Type elementType=BaseType.UNKNOWN;
  if (node.getForm() == 1) {
    for (int i=0; i < row; i++) {
      for (int j=0; j < column; j++) {
        result.append(""String_Node_Str"");
        int index=(i * column) + j;
        tokens[index]=_evaluateChild(node,index);
        Type valueType=tokens[index].getType();
        if (_isPrimitive(valueType)) {
          result.append(""String_Node_Str"" + _codeGenType(valueType) + ""String_Node_Str""+ _childCode+ ""String_Node_Str"");
        }
        if (!elementType.equals(valueType)) {
          elementType=TypeLattice.leastUpperBound(elementType,valueType);
        }
      }
    }
    String codegenType=_codeGenType(elementType);
    if (_targetType(elementType).equals(""String_Node_Str"")) {
      result.append(""String_Node_Str"");
    }
 else {
      result.append(""String_Node_Str"" + codegenType);
    }
    result=new StringBuffer(""String_Node_Str"" + ""String_Node_Str"" + result.toString());
    _childCode=result.toString() + ""String_Node_Str"";
    childToken=MatrixToken.arrayToMatrix(tokens,node.getRowCount(),node.getColumnCount());
  }
 else   if (node.getForm() == 2) {
    try {
      int columnCount=MatrixToken.determineSequenceLength((ScalarToken)tokens[0],(ScalarToken)tokens[1],(ScalarToken)tokens[2]);
      for (int i=1; i < node.getRowCount(); ++i) {
        if (columnCount != MatrixToken.determineSequenceLength((ScalarToken)tokens[3 * i],(ScalarToken)tokens[(3 * i) + 1],(ScalarToken)tokens[(3 * i) + 2])) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      ptolemy.data.Token[] matrixTokens=new ptolemy.data.Token[node.getRowCount() * columnCount];
      for (int i=0; i < node.getRowCount(); i++) {
        ptolemy.data.Token[] newTokens=MatrixToken.createSequence(tokens[3 * i],tokens[(3 * i) + 1],columnCount);
        System.arraycopy(newTokens,0,matrixTokens,columnCount * i,columnCount);
      }
      childToken=MatrixToken.arrayToMatrix(matrixTokens,node.getRowCount(),columnCount);
    }
 catch (    IllegalActionException ex) {
      throw new IllegalActionException(null,null,ex,""String_Node_Str"");
    }
  }
  _evaluatedChildToken=(childToken);
}"
73902,"public boolean isEffective(){
  return true;
}","/** 
 * Return true if this property term is effective.
 * @return Always return true in this base class.
 * @see #setEffective(boolean)
 */
public boolean isEffective(){
  return true;
}"
73903,"/** 
 * Set the effectiveness of this property term to the specified value. Do nothing in this base by default.
 * @param isEffective The specified effective value.
 */
public void setEffective(boolean isEffective){
}","/** 
 * Set the effectiveness of this property term to the specified value. Do nothing in this base by default.
 * @param isEffective The specified effective value, ignored by this method
 */
public void setEffective(boolean isEffective){
}"
73904,"public MeetFunction(PropertyConstraintSolver solver,Object... objects){
  _solver=solver;
  for (  Object object : objects) {
    _terms.add(_solver.getPropertyTerm(object));
  }
}","/** 
 * Construct a MeetFunction.
 * @param solver The solver.
 * @param objects The objects.
 */
public MeetFunction(PropertyConstraintSolver solver,Object... objects){
  _solver=solver;
  for (  Object object : objects) {
    _terms.add(_solver.getPropertyTerm(object));
  }
}"
73905,"public void setEffective(boolean isEffective){
  throw new AssertionError(""String_Node_Str"");
}","/** 
 * Set the effectiveness of this property term to the specified value.  In this class, it is an assertion error to call this method as MeetFunction terms cannot be effective.
 * @param isEffective The specified effective value, not used by this class.
 */
public void setEffective(boolean isEffective){
  throw new AssertionError(""String_Node_Str"");
}"
73906,"public String toString(){
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  for (  PropertyTerm term : _terms) {
    if (term.isEffective()) {
      result.append(term);
      break;
    }
  }
  for (  PropertyTerm term : _terms) {
    if (term.isEffective()) {
      result.append(""String_Node_Str"" + term);
    }
  }
  result.append(""String_Node_Str"");
  return result.toString();
}","/** 
 * Return the string description of this object.
 * @return the string description of this object.
 */
public String toString(){
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  for (  PropertyTerm term : _terms) {
    if (term.isEffective()) {
      result.append(term);
      break;
    }
  }
  for (  PropertyTerm term : _terms) {
    if (term.isEffective()) {
      result.append(""String_Node_Str"" + term);
    }
  }
  result.append(""String_Node_Str"");
  return result.toString();
}"
73907,"public boolean isEffective(){
  for (  PropertyTerm term : _terms) {
    if (term.isEffective()) {
      return true;
    }
  }
  return false;
}","/** 
 * Return true if any of the meet function terms are effective. 
 * @return True if any of the meet function terms areeffective. 
 */
public boolean isEffective(){
  for (  PropertyTerm term : _terms) {
    if (term.isEffective()) {
      return true;
    }
  }
  return false;
}"
73908,"/** 
 * Construct the property constraint helper for the given property solver and AST node.
 * @param solver The given component.
 * @param node The given AST node.
 * @param useDefaultConstraints Indicate whether this helperuses the default actor constraints.
 * @exception IllegalActionException Thrown if the helper cannotbe initialized.
 */
public PropertyConstraintASTNodeHelper(PropertyConstraintSolver solver,ASTPtRootNode node,boolean useDefaultConstraints) throws IllegalActionException {
  super(solver,node,useDefaultConstraints);
}","/** 
 * Construct the property constraint helper for the given property solver and AST node.
 * @param solver The given component.
 * @param node The given AST node.
 * @param useDefaultConstraints Indicate whether this helperuses the default actor constraints.
 * @exception IllegalActionException If the helper cannotbe initialized.
 */
public PropertyConstraintASTNodeHelper(PropertyConstraintSolver solver,ASTPtRootNode node,boolean useDefaultConstraints) throws IllegalActionException {
  super(solver,node,useDefaultConstraints);
}"
73909,public Object getValue() throws IllegalActionException ;,"/** 
 * Get the value of this PropertyTerm.
 * @return the value of this PropertyTerm.   
 */
public Object getValue() throws IllegalActionException ;"
73910,public void setEffective(boolean isEffective);,"/** 
 * Set the effectiveness of this property term to the specified value.
 * @param isEffective The specified effective value.
 * @see #isEffective()
 */
public void setEffective(boolean isEffective);"
73911,public boolean isEffective();,"/** 
 * Return true if this property term is effective.
 * @return true if this property term is effective.
 * @see #setEffective(boolean)
 */
public boolean isEffective();"
73912,"/** 
 * Do nothing by default.
 * @param isEffective Not used.
 */
public void setEffective(boolean isEffective){
}","/** 
 * Set the effectiveness of this property term to the specified value. Do nothing in this base by default.
 * @param isEffective The specified effective value, not used by this class.
 */
public void setEffective(boolean isEffective){
}"
73913,"public ASTPtRootNode(PropertyConstraintSolver solver,ptolemy.data.expr.ASTPtRootNode node,boolean useDefaultConstraints) throws IllegalActionException {
  super(solver,node,useDefaultConstraints);
}","/** 
 * Construct an ASTPtRootNode helper for the given property solver and AST node.
 * @param solver The given component.
 * @param actor The given AST node.
 * @param useDefaultConstraints Indicate whether this helperuses the default actor constraints.
 * @exception IllegalActionException If the helper cannotbe initialized.
 */
public ASTPtRootNode(PropertyConstraintSolver solver,ptolemy.data.expr.ASTPtRootNode node,boolean useDefaultConstraints) throws IllegalActionException {
  super(solver,node,useDefaultConstraints);
}"
73914,"public List<Inequality> constraintList() throws IllegalActionException {
  ptolemy.actor.lib.Discard actor=(ptolemy.actor.lib.Discard)getComponent();
  Lattice lattice=(Lattice)getSolver().getLattice();
  setEquals(actor.input,lattice.FALSE);
  return super.constraintList();
}","/** 
 * Return the constraints of this component. The constraints are a list of inequalities.
 * @return The constraints of this component.
 * @exception IllegalActionException If thrown while manipulating the latticeor getting the solver.
 */
public List<Inequality> constraintList() throws IllegalActionException {
  ptolemy.actor.lib.Discard actor=(ptolemy.actor.lib.Discard)getComponent();
  Lattice lattice=(Lattice)getSolver().getLattice();
  setEquals(actor.input,lattice.FALSE);
  return super.constraintList();
}"
73915,"/** 
 * Construct an Discard helper.
 * @param actor the associated actor
 * @exception IllegalActionException
 */
public Discard(PropertyConstraintSolver solver,ptolemy.actor.lib.Discard actor) throws IllegalActionException {
  super(solver,actor,false);
}","/** 
 * Construct the Discard property constraint helper associated with the given component and solver. The constructed helper implicitly uses the default constraints set by the solver.
 * @param solver The given solver.
 * @param actor The given Discard actor
 * @exception IllegalActionException If the helper cannot beinitialized in the superclass.
 */
public Discard(PropertyConstraintSolver solver,ptolemy.actor.lib.Discard actor) throws IllegalActionException {
  super(solver,actor,false);
}"
73916,"/** 
 * Construct an MonitorValue helper.
 * @param actor the associated actor
 * @exception IllegalActionException
 */
public MonitorValue(PropertyConstraintSolver solver,ptolemy.actor.lib.MonitorValue actor) throws IllegalActionException {
  super(solver,actor,false);
}","/** 
 * Construct the Monitor property constraint helper associated with the given component and solver. The constructed helper implicitly uses the default constraints set by the solver.
 * @param solver The given solver.
 * @param actor The given Monitor actor
 * @exception IllegalActionException If the helper cannot beinitialized in the superclass.
 */
public MonitorValue(PropertyConstraintSolver solver,ptolemy.actor.lib.MonitorValue actor) throws IllegalActionException {
  super(solver,actor,false);
}"
73917,"public List<Inequality> constraintList() throws IllegalActionException {
  ptolemy.actor.lib.MonitorValue actor=(ptolemy.actor.lib.MonitorValue)getComponent();
  Lattice lattice=(Lattice)getSolver().getLattice();
  setEquals(actor.input,lattice.FALSE);
  return super.constraintList();
}","/** 
 * Return the constraints of this component. The constraints are a list of inequalities.
 * @return The constraints of this component.
 * @exception IllegalActionException If thrown while manipulating the latticeor getting the solver.
 */
public List<Inequality> constraintList() throws IllegalActionException {
  ptolemy.actor.lib.MonitorValue actor=(ptolemy.actor.lib.MonitorValue)getComponent();
  Lattice lattice=(Lattice)getSolver().getLattice();
  setEquals(actor.input,lattice.FALSE);
  return super.constraintList();
}"
73918,"public List<Inequality> constraintList() throws IllegalActionException {
  ptolemy.actor.lib.Recorder actor=(ptolemy.actor.lib.Recorder)getComponent();
  Lattice lattice=(Lattice)getSolver().getLattice();
  if (((IntToken)actor.capacity.getToken()).intValue() > 0) {
    setEquals(actor.input,lattice.TRUE);
  }
 else {
    setEquals(actor.input,lattice.FALSE);
  }
  return super.constraintList();
}","/** 
 * Return the constraints of this component. The constraints are a list of inequalities.
 * @return The constraints of this component.
 * @exception IllegalActionException If thrown while manipulating the latticeor getting the solver.
 */
public List<Inequality> constraintList() throws IllegalActionException {
  ptolemy.actor.lib.Recorder actor=(ptolemy.actor.lib.Recorder)getComponent();
  Lattice lattice=(Lattice)getSolver().getLattice();
  if (((IntToken)actor.capacity.getToken()).intValue() > 0) {
    setEquals(actor.input,lattice.TRUE);
  }
 else {
    setEquals(actor.input,lattice.FALSE);
  }
  return super.constraintList();
}"
73919,"/** 
 * Construct an Recorder helper.
 * @param actor the associated actor
 * @exception IllegalActionException
 */
public Recorder(PropertyConstraintSolver solver,ptolemy.actor.lib.Recorder actor) throws IllegalActionException {
  super(solver,actor,false);
}","/** 
 * Construct the Sink property constraint helper associated with the given component and solver. The constructed helper implicitly uses the default constraints set by the solver.
 * @param solver The given solver.
 * @param actor The given Recorder actor
 * @exception IllegalActionException If the helper cannot beinitialized in the superclass.
 */
public Recorder(PropertyConstraintSolver solver,ptolemy.actor.lib.Recorder actor) throws IllegalActionException {
  super(solver,actor,false);
}"
73920,"/** 
 * Initialize model after type resolution. In addition to calling the initialize() method of the super class, this method records the current system time as the ""real"" starting time of the execution. This starting time is used when the execution is synchronized to real time.
 * @exception IllegalActionException If the super class throws it.
 */
public void initialize() throws IllegalActionException {
  _isInitializing=true;
  super.initialize();
  _currentStepSize=0.0;
  if (_isEmbedded() && (_enclosingContinuousDirector() == null)) {
    _fireContainerAt(_startTime);
    if (!_stopTime.isInfinite()) {
      _fireContainerAt(_stopTime);
    }
  }
  _breakpoints.insert(new SuperdenseTime(_stopTime,0));
  _timeBase=System.currentTimeMillis();
  _commitIsPending=false;
  _postfireReturns=true;
  _isInitializing=false;
  _redoingSolverIteration=false;
  _accumulatedSuspendTime=_zeroTime;
  _lastSuspendTime=null;
}","/** 
 * Initialize model after type resolution. In addition to calling the initialize() method of the super class, this method records the current system time as the ""real"" starting time of the execution. This starting time is used when the execution is synchronized to real time.
 * @exception IllegalActionException If the super class throws it.
 */
public void initialize() throws IllegalActionException {
  _isInitializing=true;
  _breakpoints.clear();
  super.initialize();
  _currentStepSize=0.0;
  if (_isEmbedded() && (_enclosingContinuousDirector() == null)) {
    if (_startTime.compareTo(_currentTime) >= 0) {
      _fireContainerAt(_startTime);
    }
 else {
      _fireContainerAt(_currentTime);
    }
    if (!_stopTime.isInfinite() && _stopTime.compareTo(_currentTime) >= 0) {
      _fireContainerAt(_stopTime);
    }
  }
  if (!_stopTime.isInfinite() && _stopTime.compareTo(_currentTime) >= 0) {
    _breakpoints.insert(new SuperdenseTime(_stopTime,0));
  }
  _timeBase=System.currentTimeMillis();
  _commitIsPending=false;
  _postfireReturns=true;
  _isInitializing=false;
  _redoingSolverIteration=false;
  _accumulatedSuspendTime=_zeroTime;
  _lastSuspendTime=null;
}"
73921,"private static void _printLocalStats(Map<Object,Map> stats) throws IOException {
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(new File(_statsFilename),true));
    List headers=new LinkedList(_modelStatsHeaders);
    headers.addAll(_solverStatsHeaders);
    writer.append(""String_Node_Str"" + _separator);
    writer.append(""String_Node_Str"" + _separator);
    writer.append(""String_Node_Str"");
    for (    Object header : headers) {
      writer.append(_separator + header.toString());
    }
    writer.newLine();
    for (    Object key : stats.keySet()) {
      Map entry=stats.get(key);
      writer.append(key.toString());
      for (      Object header : headers) {
        writer.append(_separator);
        if (entry.containsKey(header)) {
          writer.append(entry.get(header).toString());
        }
      }
      writer.newLine();
    }
  }
  finally {
    if (writer != null) {
      writer.close();
    }
  }
}","private static void _printLocalStats(Map<Object,Map> stats) throws IOException {
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(new File(_statsFilename),true));
    List headers=new LinkedList(_modelStatsHeaders);
    headers.addAll(_solverStatsHeaders);
    writer.append(""String_Node_Str"" + _separator);
    writer.append(""String_Node_Str"" + _separator);
    writer.append(""String_Node_Str"");
    for (    Object header : headers) {
      writer.append(_separator + header.toString());
    }
    writer.newLine();
    for (    Object key : stats.keySet()) {
      Map.entry entry=stats.get(key);
      writer.append(key.toString());
      for (      Object header : headers) {
        writer.append(_separator);
        if (entry.containsKey(header)) {
          writer.append(entry.get(header).toString());
        }
      }
      writer.newLine();
    }
  }
  finally {
    if (writer != null) {
      writer.close();
    }
  }
}"
73922,"public static void main(String args[]) throws Exception {
  testPropertiesAndGenerateReports(args[0]);
}","/** 
 * Invoke the test harness.
 * @param args The arguments, only the first argument is passed tothe test harness.
 */
public static void main(String args[]) throws Exception {
  testPropertiesAndGenerateReports(args[0]);
}"
73923,"protected ParseTreeAnnotationEvaluator _annotationEvaluator(){
  return new ParseTreeAnnotationEvaluator();
}","/** 
 * Create an new ParseTreeAnnotationEvaluator that is tailored for the use-case.
 * @return A new ParseTreeAnnotationEvaluator.
 */
protected ParseTreeAnnotationEvaluator _annotationEvaluator(){
  return new ParseTreeAnnotationEvaluator();
}"
73924,"public void setEquals(Object object,Property property){
  super.setEquals(object,property);
  if (property != null) {
    getSolver().putToken(object,(PropertyToken)property);
  }
}","/** 
 * Set the property of specified object equal to the specified property.
 * @param object The specified object.
 * @param property The specified property.
 */
public void setEquals(Object object,Property property){
  super.setEquals(object,property);
  if (property != null && property instanceof PropertyToken) {
    getSolver().putToken(object,(PropertyToken)property);
  }
}"
73925,"public PropertyCombineHelper(PropertyCombineSolver solver,Object component){
  setComponent(component);
  _solver=solver;
}","/** 
 * Construct a PropertyCombinedHelper
 * @param solver The solver.
 * @param component The associated components.
 */
public PropertyCombineHelper(PropertyCombineSolver solver,Object component){
  setComponent(component);
  _solver=solver;
}"
73926,"public PropertyCombineSolver getSolver(){
  return (PropertyCombineSolver)_solver;
}","/** 
 * Return The PropertySolver that uses this helper.
 * @return The PropertySolver that uses this helper.
 */
public PropertyCombineSolver getSolver(){
  return (PropertyCombineSolver)_solver;
}"
73927,"protected List<PropertyHelper> _getSubHelpers() throws IllegalActionException {
  return new ArrayList<PropertyHelper>();
}","/** 
 * Return the list of sub-helpers.
 * @return The list of sub-helpers.
 * @exception IllegalActionException Not thrown in this class.
 */
protected List<PropertyHelper> _getSubHelpers() throws IllegalActionException {
  return new ArrayList<PropertyHelper>();
}"
73928,"public void determineProperty() throws IllegalActionException, NameDuplicationException {
  Iterator portIterator=getPropertyables().iterator();
  while (portIterator.hasNext()) {
    IOPort port=(IOPort)portIterator.next();
    PtParser parser=PropertySolverBase.getParser();
    ASTPtRootNode parseTree=parser.generateParseTree(getSolver().getPropertyExpression());
    PropertyCombineParseTreeEvaluator evaluator=new PropertyCombineParseTreeEvaluator(port,_solver);
    Token token=evaluator.evaluateParseTree(parseTree);
    PropertyToken property=new PropertyToken(token);
    if (!((getSolver().getUnconnectedPorts()) && port.connectedPortList().isEmpty())) {
      setEquals(port,property);
    }
  }
  Iterator helpers=_getSubHelpers().iterator();
  while (helpers.hasNext()) {
    PropertyCombineHelper helper=(PropertyCombineHelper)helpers.next();
    helper.determineProperty();
  }
}","/** 
 * Determine the property.
 * @exception IllegalActionException If thrown while generating  a parse tree for the solver, evaluating the parse tree or getting subhelpers.
 */
public void determineProperty() throws IllegalActionException {
  Iterator portIterator=getPropertyables().iterator();
  while (portIterator.hasNext()) {
    IOPort port=(IOPort)portIterator.next();
    PtParser parser=PropertySolverBase.getParser();
    ASTPtRootNode parseTree=parser.generateParseTree(getSolver().getPropertyExpression());
    PropertyCombineParseTreeEvaluator evaluator=new PropertyCombineParseTreeEvaluator(port,_solver);
    Token token=evaluator.evaluateParseTree(parseTree);
    PropertyToken property=new PropertyToken(token);
    if (!((getSolver().getUnconnectedPorts()) && port.connectedPortList().isEmpty())) {
      setEquals(port,property);
    }
  }
  Iterator helpers=_getSubHelpers().iterator();
  while (helpers.hasNext()) {
    PropertyCombineHelper helper=(PropertyCombineHelper)helpers.next();
    helper.determineProperty();
  }
}"
73929,"/** 
 * Return a MoML request string that creates or updates the _showInfo attribute of the given property-able object, according to the given property value. If the given property is null, this would issue delete request to remove the _showInfo attribute, if there exists any.
 * @param propertyable The given property-able object.
 * @param property The given property.
 */
private String _getMoMLShowInfoString(NamedObj propertyable,Property property){
  String request;
  String propertyString;
  if (property != null) {
    propertyString=property.toString();
  }
 else {
    propertyString=""String_Node_Str"";
  }
  StringParameter showAttribute=(StringParameter)propertyable.getAttribute(""String_Node_Str"");
  request=""String_Node_Str"" + propertyString + ""String_Node_Str"";
  request=_completeHierarchyInMoML(propertyable,request);
  return request;
}","/** 
 * Return a MoML request string that creates or updates the _showInfo attribute of the given property-able object, according to the given property value. If the given property is null, this would issue delete request to remove the _showInfo attribute, if there exists any.
 * @param propertyable The given property-able object.
 * @param property The given property.
 */
private String _getMoMLShowInfoString(NamedObj propertyable,Property property){
  String request;
  String propertyString;
  if (property != null) {
    propertyString=property.toString();
  }
 else {
    propertyString=""String_Node_Str"";
  }
  request=""String_Node_Str"" + propertyString + ""String_Node_Str"";
  request=_completeHierarchyInMoML(propertyable,request);
  return request;
}"
73930,"/** 
 * Add choices to the parameter where the choices are subdirectories of the directoryPath. DirectoryPaths in the file system and in Jar URLs are handled.
 * @param parameter The parameter to be updated with the subdirectories
 * @param directoryPath The directory to be searched for subdirectories.
 * @exception IllegalActionException If there is a problem reading thedirectory as a file or JAR URL.
 */
protected void _addChoices(Parameter parameter,String directoryPath) throws IllegalActionException {
  try {
    URI directoryURI=new URI(FileUtilities.nameToURL(directoryPath,null,null).toExternalForm().replaceAll(""String_Node_Str"",""String_Node_Str""));
    File directory=null;
    try {
      try {
        directory=new File(directoryURI);
      }
 catch (      Throwable throwable) {
        throw new InternalErrorException(this,throwable,""String_Node_Str"" + directoryURI + ""String_Node_Str"");
      }
      DirectoryNameFilter filter=new DirectoryNameFilter();
      File[] directories=directory.listFiles(filter);
      if (directories == null) {
        throw new InternalErrorException(this,null,""String_Node_Str"" + directoryPath + ""String_Node_Str"");
      }
 else {
        for (        File element : directories) {
          String directoryName=element.getName();
          parameter.addChoice(directoryName);
        }
      }
    }
 catch (    Throwable throwable) {
      try {
        if (!directoryURI.toString().startsWith(""String_Node_Str"")) {
          throw throwable;
        }
 else {
          List<String> directories=ClassUtilities.jarURLDirectories(directoryURI.toURL());
          for (          String directoryFullPath : directories) {
            String directoryName=directoryFullPath;
            if (directoryName.lastIndexOf(""String_Node_Str"") > -1) {
              if (directoryName.lastIndexOf(""String_Node_Str"") == directoryName.length() - 1) {
                directoryName=directoryName.substring(0,directoryName.length() - 1);
              }
              directoryName=directoryName.substring(directoryName.lastIndexOf(""String_Node_Str"") + 1);
            }
            parameter.addChoice(directoryName);
          }
        }
      }
 catch (      Throwable throwable2) {
        System.err.println(""String_Node_Str"");
        throwable2.printStackTrace();
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + directoryURI);
      }
    }
  }
 catch (  Exception ex) {
    throw new InternalErrorException(this,ex,""String_Node_Str"" + directoryPath + ""String_Node_Str""+ parameter.getFullName()+ ""String_Node_Str"");
  }
}","/** 
 * Add choices to the parameter where the choices are subdirectories of the directoryPath. DirectoryPaths in the file system and in Jar URLs are handled.
 * @param parameter The parameter to be updated with the subdirectories
 * @param directoryPath The directory to be searched for subdirectories.
 * @exception IllegalActionException If there is a problem reading thedirectory as a file or JAR URL.
 */
protected void _addChoices(Parameter parameter,String directoryPath) throws IllegalActionException {
  try {
    URI directoryURI=new URI(FileUtilities.nameToURL(directoryPath,null,null).toExternalForm().replaceAll(""String_Node_Str"",""String_Node_Str""));
    File directory=null;
    try {
      try {
        directory=new File(directoryURI);
      }
 catch (      Throwable throwable) {
        throw new InternalErrorException(this,throwable,""String_Node_Str"" + directoryURI + ""String_Node_Str"");
      }
      DirectoryNameFilter filter=new DirectoryNameFilter();
      File[] directories=directory.listFiles(filter);
      if (directories == null) {
        throw new InternalErrorException(this,null,""String_Node_Str"" + directoryPath + ""String_Node_Str"");
      }
 else {
        for (        File element : directories) {
          String directoryName=element.getName();
          parameter.addChoice(directoryName);
        }
      }
    }
 catch (    Throwable throwable) {
      try {
        if (!directoryURI.toString().startsWith(""String_Node_Str"")) {
          throw throwable;
        }
 else {
          List<String> directories=ClassUtilities.jarURLDirectories(directoryURI.toURL());
          for (          String directoryFullPath : directories) {
            String directoryName=directoryFullPath;
            if (directoryName.lastIndexOf(""String_Node_Str"") > -1) {
              if (directoryName.lastIndexOf(""String_Node_Str"") == directoryName.length() - 1) {
                directoryName=directoryName.substring(0,directoryName.length() - 1);
              }
              directoryName=directoryName.substring(directoryName.lastIndexOf(""String_Node_Str"") + 1);
            }
            parameter.addChoice(directoryName);
          }
        }
      }
 catch (      Throwable throwable2) {
        System.err.println(""String_Node_Str"");
        throwable2.printStackTrace();
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + directoryURI);
      }
    }
  }
 catch (  Throwable ex) {
    throw new InternalErrorException(this,ex,""String_Node_Str"" + directoryPath + ""String_Node_Str""+ parameter.getFullName()+ ""String_Node_Str"");
  }
}"
73931,"/** 
 * Reset every solver in the model.
 */
public void resetAll(){
  _parser=null;
  for (  PropertySolver solver : getAllSolvers(sharedUtilitiesWrapper)) {
    solver.reset();
  }
  getSharedUtilities().resetAll();
}","/** 
 * Reset every solver in the model.
 */
public void resetAll(){
  _resetParser();
  for (  PropertySolver solver : getAllSolvers(sharedUtilitiesWrapper)) {
    solver.reset();
  }
  getSharedUtilities().resetAll();
}"
73932,"private void _regressionTestConstraints(PropertyConstraintHelper helper) throws IllegalActionException {
  Object object=helper.getComponent();
  if (!(object instanceof NamedObj)) {
    return;
  }
  NamedObj namedObj=(NamedObj)object;
  String errorMessage=_eol + ""String_Node_Str"" + getUseCaseName()+ ""String_Node_Str""+ namedObj.getFullName()+ ""String_Node_Str""+ _eol;
  List<Inequality>[] constraintSet=new List[2];
  constraintSet[0]=helper._ownConstraints;
  constraintSet[1]=helper._subHelperConstraints;
  boolean hasError=false;
  for (int i=0; i < 2; i++) {
    String whichSet=i == 0 ? ""String_Node_Str"" : ""String_Node_Str"";
    for (    Inequality constraint : constraintSet[i]) {
      Iterator logConstraints=_getConstraintAsLogFileString(constraint,""String_Node_Str"").iterator();
      while (logConstraints.hasNext()) {
        String constraintString=(String)logConstraints.next();
        if (!_trainedConstraints.remove(constraintString)) {
          errorMessage+=""String_Node_Str"" + whichSet + ""String_Node_Str""+ constraintString+ ""String_Node_Str""+ _eol;
          hasError=true;
        }
 else {
          errorMessage+=""String_Node_Str"";
        }
      }
    }
  }
  if (hasError) {
    getSharedUtilities().addErrors(errorMessage);
  }
}","private void _regressionTestConstraints(PropertyConstraintHelper helper) throws IllegalActionException {
  Object object=helper.getComponent();
  if (!(object instanceof NamedObj)) {
    return;
  }
  NamedObj namedObj=(NamedObj)object;
  StringBuffer errorMessage=new StringBuffer(_eol + ""String_Node_Str"" + getUseCaseName()+ ""String_Node_Str""+ namedObj.getFullName()+ ""String_Node_Str""+ _eol);
  List<Inequality>[] constraintSet=new List[2];
  constraintSet[0]=helper._ownConstraints;
  constraintSet[1]=helper._subHelperConstraints;
  boolean hasError=false;
  for (int i=0; i < 2; i++) {
    String whichSet=i == 0 ? ""String_Node_Str"" : ""String_Node_Str"";
    for (    Inequality constraint : constraintSet[i]) {
      Iterator logConstraints=_getConstraintAsLogFileString(constraint,""String_Node_Str"").iterator();
      while (logConstraints.hasNext()) {
        String constraintString=(String)logConstraints.next();
        if (!_trainedConstraints.remove(constraintString)) {
          errorMessage.append(""String_Node_Str"" + whichSet + ""String_Node_Str""+ constraintString+ ""String_Node_Str""+ _eol);
          hasError=true;
        }
      }
    }
  }
  if (hasError) {
    getSharedUtilities().addErrors(errorMessage.toString());
  }
}"
73933,"private void _readConstraintFile(String filename) throws PropertyFailedRegressionTestException {
  File file=new File(filename);
  try {
    BufferedReader reader=null;
    try {
      reader=new BufferedReader(new FileReader(file));
      String line=reader.readLine();
      while (line != null) {
        _trainedConstraints.add(line);
        line=reader.readLine();
      }
      getStats().put(""String_Node_Str"",_trainedConstraints.size());
    }
  finally {
      if (reader != null) {
        reader.close();
      }
    }
  }
 catch (  Exception ex) {
    throw new PropertyFailedRegressionTestException(this,""String_Node_Str"" + filename + ""String_Node_Str"");
  }
}","private void _readConstraintFile(String filename) throws PropertyFailedRegressionTestException {
  File file=new File(filename);
  try {
    BufferedReader reader=null;
    try {
      reader=new BufferedReader(new FileReader(file));
      String line=reader.readLine();
      while (line != null) {
        _trainedConstraints.add(line);
        line=reader.readLine();
      }
      getStats().put(""String_Node_Str"",_trainedConstraints.size());
    }
  finally {
      if (reader != null) {
        reader.close();
      }
    }
  }
 catch (  IOException ex) {
    throw new PropertyFailedRegressionTestException(this,""String_Node_Str"" + filename + ""String_Node_Str"");
  }
}"
73934,"private String _getConstraintsAsLogFileString(List<Inequality> constraintList,String annotation) throws IllegalActionException {
  String output=""String_Node_Str"";
  for (  Inequality inequality : constraintList) {
    output+=_getConstraintAsLogFileString(inequality,annotation) + _eol;
  }
  return output;
}","private String _getConstraintsAsLogFileString(List<Inequality> constraintList,String annotation) throws IllegalActionException {
  StringBuffer output=new StringBuffer();
  for (  Inequality inequality : constraintList) {
    output.append(_getConstraintAsLogFileString(inequality,annotation) + _eol);
  }
  return output.toString();
}"
73935,public Token getMinValue();,"/** 
 * Minimum value of a this type.
 * @return The minimum value of this type.
 */
public Token getMinValue();"
73936,public boolean hasMinMaxValue();,"/** 
 * Return true if this element has minimum and maximum values.
 * @return Return true if this element has minimum and maximum values.
 */
public boolean hasMinMaxValue();"
73937,public Token getMaxValue();,"/** 
 * Maximum value of a this type.
 * @return The minimum value of this type.
 */
public Token getMaxValue();"
73938,"public Token getMinValue(){
  return new DoubleToken(2.2250738585072016E-308);
}","/** 
 * Minimum value of a double in System C. Note that this may or may not have the value equal to that of java.lang.Double.MIN_VALUE.
 * @return The minimum value of a double in System C.   
 */
public Token getMinValue(){
  return new DoubleToken(2.2250738585072016E-308);
}"
73939,"public Token getMaxValue(){
  return new DoubleToken(1.7976931348623157E308);
}","/** 
 * Maximum value of a double in System C. Note that this may or may not have the value equal to that of java.lang.Double.MAX_VALUE.
 * @return The maximum value of a double in System C.   
 */
public Token getMaxValue(){
  return new DoubleToken(1.7976931348623157E308);
}"
73940,"public boolean hasMinMaxValue(){
  return true;
}","/** 
 * Return true if this element has minimum and maximum values.
 * @return Always return true.
 */
public boolean hasMinMaxValue(){
  return true;
}"
73941,"public Double(PropertyLattice lattice){
  super(lattice,""String_Node_Str"");
}","/** 
 * Construct a node named ""Double"" in the lattice.
 * @param lattice The lattice in which the node is to be constructed.   
 */
public Double(PropertyLattice lattice){
  super(lattice,""String_Node_Str"");
}"
73942,"/** 
 * Assign any internal parameters in the order they were set.
 * @exception PtalonRuntimeException If there is any troubleassigning parameter values.
 */
public void assignInternalParameters() throws PtalonRuntimeException {
  try {
    while (!_unassignedParameters.isEmpty()) {
      PtalonParameter parameter=_unassignedParameters.remove(0);
      String expression=_unassignedParameterValues.remove(0);
      String oldExpression=parameter.getExpression();
      if (expression.equals(oldExpression)) {
        parameter.setToken(expression);
      }
    }
  }
 catch (  Exception ex) {
    throw new PtalonRuntimeException(""String_Node_Str"",ex);
  }
}","/** 
 * Assign any internal parameters in the order they were set.
 * @exception PtalonRuntimeException If there is any troubleassigning parameter values.
 */
public void assignInternalParameters() throws PtalonRuntimeException {
  try {
    while (!_unassignedParameters.isEmpty()) {
      PtalonParameter parameter=_unassignedParameters.remove(0);
      String expression=_unassignedParameterValues.remove(0);
      String oldExpression=parameter.getExpression();
      if (!expression.equals(oldExpression)) {
        parameter.setToken(expression);
      }
    }
  }
 catch (  Exception ex) {
    throw new PtalonRuntimeException(""String_Node_Str"",ex);
  }
}"
73943,"/** 
 * Return the list of property-able Attributes.
 * @return The list of property-able Attributes.
 */
protected List<Attribute> _getPropertyableAttributes(){
  List<Attribute> result=new LinkedList<Attribute>();
  Iterator attributes=((Entity)getComponent()).attributeList().iterator();
  while (attributes.hasNext()) {
    Attribute attribute=(Attribute)attributes.next();
    if (attribute.getClass().equals(ptolemy.kernel.util.StringAttribute.class)) {
      if ((((StringAttribute)attribute).getName().equalsIgnoreCase(""String_Node_Str"")) || ((((StringAttribute)attribute).getContainer() instanceof Expression)) && ((StringAttribute)attribute).getName().equalsIgnoreCase(""String_Node_Str"")) {
        result.add(attribute);
      }
    }
 else     if (attribute instanceof Variable) {
      if (((Variable)attribute).getVisibility() == Settable.FULL) {
        if (attribute instanceof PortParameter) {
          result.add(attribute);
        }
 else         if ((attribute.getClass().equals(ptolemy.data.expr.Parameter.class)) || (attribute.getClass().equals(ptolemy.data.expr.StringParameter.class))) {
          if (((Parameter)attribute).getName().equals(""String_Node_Str"") || ((Parameter)attribute).getName().equals(""String_Node_Str"") || ((Parameter)attribute).getName().equals(""String_Node_Str"")|| ((Parameter)attribute).getName().equals(""String_Node_Str"")|| ((Parameter)attribute).getName().equals(""String_Node_Str"")|| ((Parameter)attribute).getName().equals(""String_Node_Str"")|| ((Parameter)attribute).getName().equals(""String_Node_Str"")|| ((Parameter)attribute).getName().equals(""String_Node_Str"")|| ((Parameter)attribute).getName().equals(""String_Node_Str"")) {
          }
 else {
            result.add(attribute);
          }
        }
      }
    }
  }
  return result;
}","/** 
 * Return the list of property-able Attributes. A property-able Attribute is a StringAttribute with the name ""guardTransition"", a StringAttribute in an Expression actor, a StringAttribute with the name ""expression"" or a Variable with full visibility.  However, Variables with certain names are excluded.
 * @see ptolemy.data.properties.Propertyable
 * @return The list of property-able Attributes.
 */
protected List<Attribute> _getPropertyableAttributes(){
  List<Attribute> result=new LinkedList<Attribute>();
  Iterator attributes=((Entity)getComponent()).attributeList().iterator();
  while (attributes.hasNext()) {
    Attribute attribute=(Attribute)attributes.next();
    if (attribute.getClass().equals(ptolemy.kernel.util.StringAttribute.class)) {
      if ((((StringAttribute)attribute).getName().equalsIgnoreCase(""String_Node_Str"")) || ((((StringAttribute)attribute).getContainer() instanceof Expression)) && ((StringAttribute)attribute).getName().equalsIgnoreCase(""String_Node_Str"")) {
        result.add(attribute);
      }
    }
 else     if (attribute instanceof Variable) {
      if (((Variable)attribute).getVisibility() == Settable.FULL) {
        if (attribute instanceof PortParameter) {
          result.add(attribute);
        }
 else         if ((attribute.getClass().equals(ptolemy.data.expr.Parameter.class)) || (attribute.getClass().equals(ptolemy.data.expr.StringParameter.class))) {
          if (((Parameter)attribute).getName().equals(""String_Node_Str"") || ((Parameter)attribute).getName().equals(""String_Node_Str"") || ((Parameter)attribute).getName().equals(""String_Node_Str"")|| ((Parameter)attribute).getName().equals(""String_Node_Str"")|| ((Parameter)attribute).getName().equals(""String_Node_Str"")|| ((Parameter)attribute).getName().equals(""String_Node_Str"")|| ((Parameter)attribute).getName().equals(""String_Node_Str"")|| ((Parameter)attribute).getName().equals(""String_Node_Str"")|| ((Parameter)attribute).getName().equals(""String_Node_Str"")) {
          }
 else {
            result.add(attribute);
          }
        }
      }
    }
  }
  return result;
}"
73944,"/** 
 * Return the constraints of this component. The constraints is a list of inequalities. This base class returns a empty list.
 * @return A list of Inequality.
 * @exception IllegalActionException Not thrown in this base class.
 */
public List<Inequality> constraintList() throws IllegalActionException {
  _setEffectiveTerms();
  _constraintAttributes();
  _addSubHelperConstraints();
  return _union(_ownConstraints,_subHelperConstraints);
}","/** 
 * Return the constraints of this component. The constraints is a list of inequalities. This base class returns the union of the constraints of this component and the constraints for the subcomponents
 * @return The constraints of this component.
 * @exception IllegalActionException Not thrown in this base class.
 */
public List<Inequality> constraintList() throws IllegalActionException {
  _setEffectiveTerms();
  _constraintAttributes();
  _addSubHelperConstraints();
  return _union(_ownConstraints,_subHelperConstraints);
}"
73945,"protected List<Attribute> _getPropertyableAttributes(){
  return new LinkedList<Attribute>();
}","/** 
 * Return the list of property-able Attributes. In this base class, an empty list is returned. Derived classes should add Attributes and Variables to list.  Commonly, actors add their parameters to this list.
 * @see ptolemy.data.properties.Propertyable
 * @return The list of property-able Attributes.
 */
protected List<Attribute> _getPropertyableAttributes(){
  return new LinkedList<Attribute>();
}"
73946,"public AtomicActor(PropertyConstraintSolver solver,ptolemy.actor.AtomicActor actor,boolean useDefaultConstraints) throws IllegalActionException {
  super(solver,actor,useDefaultConstraints);
}","/** 
 * Construct a helper for the given AtomicActor. This is the helper class for any ActomicActor that does not have a specific defined helper class.
 * @param solver The given solver.
 * @param actor The given ActomicActor.
 * @param useDefaultConstraints Indicate whether this helper uses thedefault actor constraints.
 * @exception IllegalActionException Thrown if the helper cannot beinitialized.
 */
public AtomicActor(PropertyConstraintSolver solver,ptolemy.actor.AtomicActor actor,boolean useDefaultConstraints) throws IllegalActionException {
  super(solver,actor,useDefaultConstraints);
}"
73947,"protected List<Attribute> _getPropertyableAttributes(){
  List<Attribute> result=super._getPropertyableAttributes();
  result.add(_actor.value);
  result.remove(_actor.trigger);
  return result;
}","/** 
 * Return the list of property-able Attributes. A property-able Attribute is a StringAttribute with the name ""guardTransition"", a StringAttribute in an Expression actor, a StringAttribute with the name ""expression"" or a Variable with full visibility.  However, Variables with certain names are excluded.  This method adds the value Parameter of the Const actor to the list that is returned.
 * @see ptolemy.data.properties.Propertyable
 * @return The list of property-able Attributes.
 */
protected List<Attribute> _getPropertyableAttributes(){
  List<Attribute> result=super._getPropertyableAttributes();
  result.add(_actor.value);
  return result;
}"
73948,"/** 
 * Construct a Const helper for the dimensionSystem lattice.
 * @param solver The given solver.
 * @param actor The given Const actor
 * @exception IllegalActionException
 */
public Const(PropertyConstraintSolver solver,ptolemy.actor.lib.Const actor) throws IllegalActionException {
  super(solver,actor);
  _actor=actor;
}","/** 
 * Construct a Const helper for the dimensionSystem lattice.
 * @param solver The given solver.
 * @param actor The given Const actor
 * @exception IllegalActionException Thrown if the helper cannot beinitialized.
 */
public Const(PropertyConstraintSolver solver,ptolemy.actor.lib.Const actor) throws IllegalActionException {
  super(solver,actor);
  _actor=actor;
}"
73949,"public List<Inequality> constraintList() throws IllegalActionException {
  setAtLeast(_actor.output,_actor.value);
  return super.constraintList();
}","/** 
 * Return the constraints of this component. The constraints is a list of inequalities.  This method sets the constraint of the output to at least that of the value Parameter of the actor.
 * @return The constraints of this component.
 * @exception IllegalActionException Not thrown in this base class.
 */
public List<Inequality> constraintList() throws IllegalActionException {
  setAtLeast(_actor.output,_actor.value);
  return super.constraintList();
}"
73950,"protected List<Attribute> _getPropertyableAttributes(){
  List<Attribute> result=super._getPropertyableAttributes();
  result.remove(_actor.trigger);
  return result;
}","/** 
 * Return the list of property-able Attributes. A property-able Attribute is a StringAttribute with the name ""guardTransition"", a StringAttribute in an Expression actor, a StringAttribute with the name ""expression"" or a Variable with full visibility.  However, Variables with certain names are excluded.
 * @see ptolemy.data.properties.Propertyable
 * @return The list of property-able Attributes.
 */
protected List<Attribute> _getPropertyableAttributes(){
  List<Attribute> result=super._getPropertyableAttributes();
  return result;
}"
73951,"public List<Inequality> constraintList() throws IllegalActionException {
  setAtLeast(_actor.output,_lattice.getElement(""String_Node_Str""));
  return super.constraintList();
}","/** 
 * Return the constraints of this component. The constraints is a list of inequalities. This method sets the constraint of the output to at least the value of the ""TIME"" element in the   {@link ptolemy.data.properties.lattice#_lattice}
 * @return The constraints of this component.
 * @exception IllegalActionException If thrown while reading the lattice orif thrown by the superclass. 
 */
public List<Inequality> constraintList() throws IllegalActionException {
  setAtLeast(_actor.output,_lattice.getElement(""String_Node_Str""));
  return super.constraintList();
}"
73952,"/** 
 * Construct a Expression helper for the flatUnitSystem lattice.
 * @param solver The given solver.
 * @param actor The given Expression actor
 * @exception IllegalActionException
 */
public CurrentTime(PropertyConstraintSolver solver,ptolemy.actor.lib.CurrentTime actor) throws IllegalActionException {
  super(solver,actor,false);
  _actor=actor;
}","/** 
 * Construct a CurrentTime helper for the dimensionSystem lattice.
 * @param solver The given solver.
 * @param actor The given Expression actor
 * @exception IllegalActionException Thrown if the helper cannot beinitialized.
 */
public CurrentTime(PropertyConstraintSolver solver,ptolemy.actor.lib.CurrentTime actor) throws IllegalActionException {
  super(solver,actor,false);
  _actor=actor;
}"
73953,"protected List<Attribute> _getPropertyableAttributes(){
  List<Attribute> result=super._getPropertyableAttributes();
  result.remove(_actor.trigger);
  result.remove(_actor.period);
  return result;
}","/** 
 * Return the list of property-able Attributes. A property-able Attribute is a StringAttribute with the name ""guardTransition"", a StringAttribute in an Expression actor, a StringAttribute with the name ""expression"" or a Variable with full visibility.  However, Variables with certain names are excluded.
 * @see ptolemy.data.properties.Propertyable
 * @return The list of property-able Attributes.
 */
protected List<Attribute> _getPropertyableAttributes(){
  List<Attribute> result=super._getPropertyableAttributes();
  return result;
}"
73954,"public List<Inequality> constraintList() throws IllegalActionException {
  setAtLeast(_actor.output,_lattice.getElement(""String_Node_Str""));
  return super.constraintList();
}","/** 
 * Return the constraints of this component. The constraints is a list of inequalities. This method sets the constraint of the output to at least the value of the ""UNITLESS"" element in the   {@link ptolemy.data.properties.lattice#_lattice}
 * @return The constraints of this component.
 * @exception IllegalActionException Not thrown in this base class.
 */
public List<Inequality> constraintList() throws IllegalActionException {
  setAtLeast(_actor.output,_lattice.getElement(""String_Node_Str""));
  return super.constraintList();
}"
73955,"/** 
 * Construct a Integrator helper for the flatUnitSystem lattice.
 * @param solver The given solver.
 * @param actor The given Integrator actor
 * @exception IllegalActionException
 */
public DiscreteClock(PropertyConstraintSolver solver,ptolemy.actor.lib.DiscreteClock actor) throws IllegalActionException {
  super(solver,actor,false);
  _actor=actor;
}","/** 
 * Construct a Integrator helper for the flatUnitSystem lattice.
 * @param solver The given solver.
 * @param actor The given Integrator actor
 * @exception IllegalActionException Thrown if the helper cannot beinitialized.
 */
public DiscreteClock(PropertyConstraintSolver solver,ptolemy.actor.lib.DiscreteClock actor) throws IllegalActionException {
  super(solver,actor,false);
  _actor=actor;
}"
73956,"/** 
 * Record as an error for the given property-able object and its resolved property. If the given property is null, it does nothing. If the given property is unacceptable, an error is recorded for the given property-able object and the property.
 */
private void _recordUnacceptableSolution(Object propertyable,Property property){
  if (property != null && !property.isAcceptableSolution()) {
    addErrors(""String_Node_Str"" + property + ""String_Node_Str""+ propertyable+ ""String_Node_Str""+ _eol);
    clearResolvedProperty(propertyable);
  }
}","/** 
 * Record as an error for the given property-able object and its resolved property. If the given property is null, it does nothing. If the given property is unacceptable, an error is recorded for the given property-able object and the property.
 */
private void _recordUnacceptableSolution(Object propertyable,Property property){
  if (property != null && !property.isAcceptableSolution()) {
    addErrors(""String_Node_Str"" + property + ""String_Node_Str""+ propertyable+ ""String_Node_Str""+ _eol);
  }
}"
73957,"/** 
 * @param constraints
 */
public void setConstraints(List<Inequality> constraints){
  _greaterTermMap.clear();
  _lesserTermMap.clear();
  for (  Inequality constraint : constraints) {
    if (constraint.isBase()) {
      InequalityTerm greaterTerm=constraint.getGreaterTerm();
      InequalityTerm lesserTerm=constraint.getLesserTerm();
      _greaterTermMap.put(greaterTerm,lesserTerm);
      _lesserTermMap.put(lesserTerm,greaterTerm);
    }
  }
}","/** 
 * @param constraints
 */
public void setConstraints(List<Inequality> constraints){
  for (  Inequality constraint : constraints) {
    if (constraint.isBase()) {
      InequalityTerm greaterTerm=constraint.getGreaterTerm();
      InequalityTerm lesserTerm=constraint.getLesserTerm();
      _greaterTermMap.put(greaterTerm,lesserTerm);
      _lesserTermMap.put(lesserTerm,greaterTerm);
    }
  }
}"
73958,"/** 
 * Return a MoML request string that create or update the _highlightColor attribute of the given property-able object, according to the given property value. If the given property is null, this would issue delete request to remove the _highlightColor attribute, if there exists any.
 * @param propertyable The given property-able object.
 * @param property The given property.
 */
private String _getMoMLHighlightString(NamedObj propertyable,Property property){
  String request;
  String propertyString;
  if (property != null) {
    propertyString=property.toString();
  }
 else   if (getContainer() instanceof PropertyTokenSolver) {
    propertyString=""String_Node_Str"";
  }
 else {
    propertyString=""String_Node_Str"";
  }
  if (property != null && property.getColor().length() > 0) {
    request=""String_Node_Str"" + ""String_Node_Str"" + property.getColor() + ""String_Node_Str"";
    request=_completeHierarchyInMoML(propertyable,request);
    return request;
  }
  for (  ColorAttribute colorAttribute : (List<ColorAttribute>)attributeList(ColorAttribute.class)) {
    String colorAttrName=colorAttribute.getName();
    if (colorAttrName.endsWith(""String_Node_Str"")) {
      String propertyAttrName=colorAttrName.substring(0,colorAttrName.length() - 14);
      Attribute attribute=getAttribute(propertyAttrName);
      if (attribute != null && attribute instanceof StringAttribute) {
        String propertyToHighlight=((StringAttribute)attribute).getExpression();
        if (propertyToHighlight.equals(propertyString)) {
          ColorAttribute highlightAttribute=(ColorAttribute)propertyable.getAttribute(""String_Node_Str"");
          if (property == null && highlightAttribute != null) {
            request=""String_Node_Str"";
          }
 else {
            request=""String_Node_Str"" + ""String_Node_Str"" + colorAttribute.getExpression() + ""String_Node_Str"";
          }
          request=_completeHierarchyInMoML(propertyable,request);
          return request;
        }
      }
    }
  }
  return ""String_Node_Str"";
}","/** 
 * Return a MoML request string that create or update the _highlightColor attribute of the given property-able object, according to the given property value. If the given property is null, this would issue delete request to remove the _highlightColor attribute, if there exists any.
 * @param propertyable The given property-able object.
 * @param property The given property.
 */
private String _getMoMLHighlightString(NamedObj propertyable,Property property){
  String request;
  String propertyString;
  if (property != null) {
    propertyString=property.toString();
  }
 else {
    propertyString=""String_Node_Str"";
  }
  if (property != null && property.getColor().length() > 0) {
    request=""String_Node_Str"" + ""String_Node_Str"" + property.getColor() + ""String_Node_Str"";
    request=_completeHierarchyInMoML(propertyable,request);
    return request;
  }
  for (  ColorAttribute colorAttribute : (List<ColorAttribute>)attributeList(ColorAttribute.class)) {
    String colorAttrName=colorAttribute.getName();
    if (colorAttrName.endsWith(""String_Node_Str"")) {
      String propertyAttrName=colorAttrName.substring(0,colorAttrName.length() - 14);
      Attribute attribute=getAttribute(propertyAttrName);
      if (attribute != null && attribute instanceof StringAttribute) {
        String propertyToHighlight=((StringAttribute)attribute).getExpression();
        if (propertyToHighlight.equals(propertyString)) {
          ColorAttribute highlightAttribute=(ColorAttribute)propertyable.getAttribute(""String_Node_Str"");
          if (property == null && highlightAttribute != null) {
            request=""String_Node_Str"";
          }
 else {
            request=""String_Node_Str"" + ""String_Node_Str"" + colorAttribute.getExpression() + ""String_Node_Str"";
          }
          request=_completeHierarchyInMoML(propertyable,request);
          return request;
        }
      }
    }
  }
  return ""String_Node_Str"";
}"
73959,"/** 
 * Return a MoML request string that create or update the _showInfo attribute of the given property-able object, according to the given property value. If the given property is null, this would issue delete request to remove the _showInfo attribute, if there exists any.
 * @param propertyable The given property-able object.
 * @param property The given property.
 */
private String _getMoMLShowInfoString(NamedObj propertyable,Property property){
  String request;
  String propertyString;
  if (property != null) {
    propertyString=property.toString();
  }
 else   if (getContainer() instanceof PropertyTokenSolver) {
    propertyString=""String_Node_Str"";
  }
 else {
    propertyString=""String_Node_Str"";
  }
  StringParameter showAttribute=(StringParameter)propertyable.getAttribute(""String_Node_Str"");
  if (property == null && showAttribute != null) {
    request=""String_Node_Str"";
  }
 else {
    request=""String_Node_Str"" + propertyString + ""String_Node_Str"";
  }
  request=_completeHierarchyInMoML(propertyable,request);
  return request;
}","/** 
 * Return a MoML request string that create or update the _showInfo attribute of the given property-able object, according to the given property value. If the given property is null, this would issue delete request to remove the _showInfo attribute, if there exists any.
 * @param propertyable The given property-able object.
 * @param property The given property.
 */
private String _getMoMLShowInfoString(NamedObj propertyable,Property property){
  String request;
  String propertyString;
  if (property != null) {
    propertyString=property.toString();
  }
 else {
    propertyString=""String_Node_Str"";
  }
  StringParameter showAttribute=(StringParameter)propertyable.getAttribute(""String_Node_Str"");
  if (property == null && showAttribute != null) {
    request=""String_Node_Str"";
  }
 else {
    request=""String_Node_Str"" + propertyString + ""String_Node_Str"";
  }
  request=_completeHierarchyInMoML(propertyable,request);
  return request;
}"
73960,"public String toString(){
  String result=""String_Node_Str"";
  for (  PropertyTerm term : _terms) {
    if (term.isEffective()) {
      result+=term;
      break;
    }
  }
  for (  PropertyTerm term : _terms) {
    if (term.isEffective()) {
      result+=""String_Node_Str"" + term;
    }
  }
  return result + ""String_Node_Str"";
}","public String toString(){
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  for (  PropertyTerm term : _terms) {
    if (term.isEffective()) {
      result.append(term);
      break;
    }
  }
  for (  PropertyTerm term : _terms) {
    if (term.isEffective()) {
      result.append(""String_Node_Str"" + term);
    }
  }
  result.append(""String_Node_Str"");
  return result.toString();
}"
73961,"private void _checkMissingConstraints(){
  String errorMessage=_eol + ""String_Node_Str"" + getUseCaseName()+ ""String_Node_Str""+ _eol;
  boolean hasError=false;
  for (  String trainedValue : _trainedConstraints) {
    errorMessage+=""String_Node_Str"" + trainedValue + ""String_Node_Str""+ _eol;
    hasError=true;
  }
  if (hasError) {
    getSharedUtilities().addErrors(errorMessage);
  }
}","private void _checkMissingConstraints(){
  StringBuffer errorMessage=new StringBuffer(_eol + ""String_Node_Str"" + getUseCaseName()+ ""String_Node_Str""+ _eol);
  boolean hasError=false;
  for (  String trainedValue : _trainedConstraints) {
    errorMessage.append(""String_Node_Str"" + trainedValue + ""String_Node_Str""+ _eol);
    hasError=true;
  }
  if (hasError) {
    getSharedUtilities().addErrors(errorMessage.toString());
  }
}"
73962,"protected void _writeChacoInputFile(String code) throws IllegalActionException {
  BufferedWriter out=null;
  try {
    FileWriter fstream=new FileWriter(_codeFileName);
    out=new BufferedWriter(fstream);
    out.write(code);
  }
 catch (  Exception ex) {
    throw IllegalActionException(getContainer(),ex,""String_Node_Str"" + _codeFileName);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      Exception ex) {
        throw IllegalActionException(getContainer(),ex,""String_Node_Str"" + _codeFileName);
      }
    }
  }
}","protected void _writeChacoInputFile(String code) throws IllegalActionException {
  BufferedWriter out=null;
  try {
    FileWriter fstream=new FileWriter(_codeFileName);
    out=new BufferedWriter(fstream);
    out.write(code);
  }
 catch (  Exception ex) {
    throw new IllegalActionException(getContainer(),ex,""String_Node_Str"" + _codeFileName);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      Exception ex) {
        throw new IllegalActionException(getContainer(),ex,""String_Node_Str"" + _codeFileName);
      }
    }
  }
}"
73963,"/** 
 * Iterate on the given list of constraints to find a minimal subset that still contains an error. This can be done efficiently in a manner similar to binary search. The pseudocode is as follows: <pre> errorList = constraintList size = errorList.size()/2 while (size >= 1): for (testList of size size in errorList): (i.e. errorlist[0:size] , errorlist[size+1, 2*size], ...) if _resolveProperties(errorList - testList) == error: errorList = errorList - testList; size = errorList.size()/2 continue while loop; size = size/2; </pre>
 * @param toplevel
 * @param toplevelHelper
 * @param constraintList A list of constraints that causes an error
 * @throws TypeConflictException
 * @throws PropertyResolutionException
 * @throws IllegalActionException
 */
private void _doDeltaIteration(NamedObj toplevel,PropertyConstraintHelper toplevelHelper,List<Inequality> constraintList) throws TypeConflictException, PropertyResolutionException, IllegalActionException {
  List<Inequality> errorList=constraintList;
  int blockSize=errorList.size() / 2;
  WHILE_LOOP:   while (blockSize >= 1) {
    for (int i=0; i < errorList.size(); i+=blockSize) {
      List<Inequality> testList=new LinkedList<Inequality>(errorList);
      testList.removeAll(errorList.subList(i,Math.min(errorList.size(),i + blockSize)));
      if (testList.size() > 0) {
        _resolveProperties(toplevel,toplevelHelper,testList);
        if (checkForErrors()) {
          errorList=testList;
          blockSize=errorList.size() / 2;
          continue WHILE_LOOP;
        }
      }
    }
    blockSize/=2;
    System.err.println(""String_Node_Str"" + blockSize);
  }
  System.out.println(errorList);
  _resolveProperties(toplevel,toplevelHelper,errorList);
}","/** 
 * Iterate on the given list of constraints to find a minimal subset that still contains an error. This can be done efficiently in a manner similar to binary search. The pseudocode is as follows: <pre> errorList = constraintList size = errorList.size()/2 while (size >= 1): for (testList of size size in errorList): (i.e. errorlist[0:size] , errorlist[size+1, 2*size], ...) if _resolveProperties(errorList - testList) == error: errorList = errorList - testList; size = errorList.size()/2 continue while loop; size = size/2; </pre>
 * @param toplevel
 * @param toplevelHelper
 * @param constraintList A list of constraints that causes an error
 * @throws TypeConflictException
 * @throws PropertyResolutionException
 * @throws IllegalActionException
 */
private void _doDeltaIteration(NamedObj toplevel,PropertyConstraintHelper toplevelHelper,List<Inequality> constraintList) throws TypeConflictException, PropertyResolutionException, IllegalActionException {
  List<Inequality> errorList=constraintList;
  int blockSize=errorList.size() / 2;
  WHILE_LOOP:   while (blockSize >= 1) {
    for (int i=0; i < errorList.size(); i+=blockSize) {
      List<Inequality> testList=new LinkedList<Inequality>(errorList);
      testList.removeAll(errorList.subList(i,Math.min(errorList.size(),i + blockSize)));
      if (testList.size() > 0) {
        _resolvedProperties.clear();
        _resolveProperties(toplevel,toplevelHelper,testList);
        if (checkForErrors()) {
          errorList=testList;
          blockSize=errorList.size() / 2;
          continue WHILE_LOOP;
        }
      }
    }
    blockSize/=2;
    System.err.println(""String_Node_Str"" + blockSize);
  }
  System.out.println(errorList);
  _resolvedProperties.clear();
  _resolveProperties(toplevel,toplevelHelper,errorList);
}"
73964,"public boolean checkForErrors() throws IllegalActionException {
  boolean ret=false;
  for (  Object propertyable : getAllPropertyables()) {
    Property property=getProperty(propertyable);
    if (property != null && !property.isAcceptableSolution()) {
      ret=true;
    }
    clearResolvedProperty(propertyable);
  }
  return ret;
}","public boolean checkForErrors() throws IllegalActionException {
  boolean ret=false;
  for (  Object propertyable : getAllPropertyables()) {
    Property property=getProperty(propertyable);
    if (property != null && !property.isAcceptableSolution()) {
      ret=true;
    }
  }
  return ret;
}"
73965,"/** 
 * Record as an error for the given property-able object and its resolved property. If the given property is null, it does nothing. If the given property is unacceptable, an error is recorded for the given property-able object and the property.
 */
private void _recordUnacceptableSolution(Object propertyable,Property property){
  if (property != null && !property.isAcceptableSolution()) {
    addErrors(""String_Node_Str"" + property + ""String_Node_Str""+ propertyable+ ""String_Node_Str""+ _eol);
  }
}","/** 
 * Record as an error for the given property-able object and its resolved property. If the given property is null, it does nothing. If the given property is unacceptable, an error is recorded for the given property-able object and the property.
 */
private void _recordUnacceptableSolution(Object propertyable,Property property){
  if (property != null && !property.isAcceptableSolution()) {
    addErrors(""String_Node_Str"" + property + ""String_Node_Str""+ propertyable+ ""String_Node_Str""+ _eol);
    clearResolvedProperty(propertyable);
  }
}"
73966,"/** 
 * Resolve the property values for the toplevel entity that contains this solver, given the model analyzer that invokes this.
 * @param analyzer The given model analyzer.
 */
protected void _resolveProperties(NamedObj analyzer) throws KernelException {
  NamedObj toplevel=_toplevel();
  PropertyConstraintHelper toplevelHelper=(PropertyConstraintHelper)getHelper(toplevel);
  toplevelHelper.reinitialize();
  toplevelHelper._addDefaultConstraints(_getConstraintType(actorConstraintType.stringValue()));
  toplevelHelper._setConnectionConstraintType(_getConstraintType(connectionConstraintType.stringValue()),_getConstraintType(compositeConnectionConstraintType.stringValue()),_getConstraintType(fsmConstraintType.stringValue()),_getConstraintType(expressionASTNodeConstraintType.stringValue()));
  List<Inequality> constraintList=toplevelHelper.constraintList();
  List<Inequality> errorList=constraintList;
  List<Inequality> testList=errorList;
  _resolveProperties(toplevel,toplevelHelper,testList);
  int blockSize=errorList.size() / 2;
  WHILE_LOOP:   while (blockSize >= 1) {
    for (int i=0; i < errorList.size(); i+=blockSize) {
      Set<Inequality> tmpSet=new HashSet(errorList.subList(i,Math.min(errorList.size(),i + blockSize)));
      testList=new LinkedList(errorList);
      testList.removeAll(tmpSet);
      if (testList.size() > 0) {
        _resolveProperties(toplevel,toplevelHelper,testList);
        errorList=testList;
        if (blockSize > errorList.size())         blockSize=errorList.size() / 2;
        continue WHILE_LOOP;
      }
    }
    blockSize/=2;
    System.err.println(""String_Node_Str"" + blockSize);
  }
  System.out.println(errorList);
  _resolveProperties(toplevel,toplevelHelper,errorList);
}","/** 
 * Resolve the property values for the toplevel entity that contains this solver, given the model analyzer that invokes this.
 * @param analyzer The given model analyzer.
 */
protected void _resolveProperties(NamedObj analyzer) throws KernelException {
  NamedObj toplevel=_toplevel();
  PropertyConstraintHelper toplevelHelper=(PropertyConstraintHelper)getHelper(toplevel);
  toplevelHelper.reinitialize();
  toplevelHelper._addDefaultConstraints(_getConstraintType(actorConstraintType.stringValue()));
  toplevelHelper._setConnectionConstraintType(_getConstraintType(connectionConstraintType.stringValue()),_getConstraintType(compositeConnectionConstraintType.stringValue()),_getConstraintType(fsmConstraintType.stringValue()),_getConstraintType(expressionASTNodeConstraintType.stringValue()));
  List<Inequality> constraintList=toplevelHelper.constraintList();
  List<Inequality> errorList=constraintList;
  List<Inequality> testList=errorList;
  _resolveProperties(toplevel,toplevelHelper,testList);
  if (!checkForErrors()) {
    return;
  }
  int blockSize=errorList.size() / 2;
  WHILE_LOOP:   while (blockSize >= 1) {
    for (int i=0; i < errorList.size(); i+=blockSize) {
      Set<Inequality> tmpSet=new HashSet(errorList.subList(i,Math.min(errorList.size(),i + blockSize)));
      testList=new LinkedList(errorList);
      testList.removeAll(tmpSet);
      if (testList.size() > 0) {
        _resolveProperties(toplevel,toplevelHelper,testList);
        if (checkForErrors()) {
          errorList=testList;
          if (blockSize > errorList.size())           blockSize=errorList.size() / 2;
          continue WHILE_LOOP;
        }
      }
    }
    blockSize/=2;
    System.err.println(""String_Node_Str"" + blockSize);
  }
  System.out.println(errorList);
  _resolveProperties(toplevel,toplevelHelper,errorList);
}"
73967,"/** 
 * @param constraints
 */
public void setConstraints(List<Inequality> constraints){
  for (  Inequality constraint : constraints) {
    if (constraint.isBase()) {
      InequalityTerm greaterTerm=constraint.getGreaterTerm();
      InequalityTerm lesserTerm=constraint.getLesserTerm();
      _greaterTermMap.put(greaterTerm,lesserTerm);
      _lesserTermMap.put(lesserTerm,greaterTerm);
    }
  }
}","/** 
 * @param constraints
 */
public void setConstraints(List<Inequality> constraints){
  _greaterTermMap.clear();
  _lesserTermMap.clear();
  for (  Inequality constraint : constraints) {
    if (constraint.isBase()) {
      InequalityTerm greaterTerm=constraint.getGreaterTerm();
      InequalityTerm lesserTerm=constraint.getLesserTerm();
      _greaterTermMap.put(greaterTerm,lesserTerm);
      _lesserTermMap.put(lesserTerm,greaterTerm);
    }
  }
}"
73968,"/** 
 * Resolve the property values for the toplevel entity that contains this solver, given the model analyzer that invokes this.
 * @param analyzer The given model analyzer.
 */
protected void _resolveProperties(NamedObj analyzer) throws KernelException {
  NamedObj toplevel=_toplevel();
  PropertyConstraintHelper toplevelHelper=(PropertyConstraintHelper)getHelper(toplevel);
  toplevelHelper.reinitialize();
  toplevelHelper._addDefaultConstraints(_getConstraintType(actorConstraintType.stringValue()));
  toplevelHelper._setConnectionConstraintType(_getConstraintType(connectionConstraintType.stringValue()),_getConstraintType(compositeConnectionConstraintType.stringValue()),_getConstraintType(fsmConstraintType.stringValue()),_getConstraintType(expressionASTNodeConstraintType.stringValue()));
  List<Inequality> constraintList=toplevelHelper.constraintList();
  List<Inequality> errorList=constraintList;
  List<Inequality> testList=errorList;
  boolean exception=false;
  try {
    _resolveProperties(toplevel,toplevelHelper,testList);
    checkResolutionErrors();
  }
 catch (  TypeConflictException ex) {
    System.err.println(""String_Node_Str"");
    throw ex;
  }
catch (  PropertyResolutionException ex) {
    System.err.println(""String_Node_Str"");
    exception=true;
  }
  if (!exception)   return;
  int blockSize=errorList.size() / 2;
  WHILE_LOOP:   while (blockSize >= 1) {
    for (int i=0; i < errorList.size(); i+=blockSize) {
      try {
        Set<Inequality> tmpSet=new HashSet(errorList.subList(i,Math.min(errorList.size(),i + blockSize)));
        testList=new LinkedList(errorList);
        testList.removeAll(tmpSet);
        if (testList.size() > 0) {
          _resolveProperties(toplevel,toplevelHelper,testList);
          checkResolutionErrors();
        }
      }
 catch (      TypeConflictException ex) {
        System.err.println(""String_Node_Str"");
        throw ex;
      }
catch (      PropertyResolutionException ex) {
        System.err.println(""String_Node_Str"");
        errorList=testList;
        continue WHILE_LOOP;
      }
    }
    blockSize/=2;
  }
  System.out.println(errorList);
}","/** 
 * Resolve the property values for the toplevel entity that contains this solver, given the model analyzer that invokes this.
 * @param analyzer The given model analyzer.
 */
protected void _resolveProperties(NamedObj analyzer) throws KernelException {
  NamedObj toplevel=_toplevel();
  PropertyConstraintHelper toplevelHelper=(PropertyConstraintHelper)getHelper(toplevel);
  toplevelHelper.reinitialize();
  toplevelHelper._addDefaultConstraints(_getConstraintType(actorConstraintType.stringValue()));
  toplevelHelper._setConnectionConstraintType(_getConstraintType(connectionConstraintType.stringValue()),_getConstraintType(compositeConnectionConstraintType.stringValue()),_getConstraintType(fsmConstraintType.stringValue()),_getConstraintType(expressionASTNodeConstraintType.stringValue()));
  List<Inequality> constraintList=toplevelHelper.constraintList();
  List<Inequality> errorList=constraintList;
  List<Inequality> testList=errorList;
  _resolveProperties(toplevel,toplevelHelper,testList);
  if (!checkForErrors()) {
    return;
  }
  int blockSize=errorList.size() / 2;
  WHILE_LOOP:   while (blockSize >= 1) {
    for (int i=0; i < errorList.size(); i+=blockSize) {
      Set<Inequality> tmpSet=new HashSet(errorList.subList(i,Math.min(errorList.size(),i + blockSize)));
      testList=new LinkedList(errorList);
      testList.removeAll(tmpSet);
      if (testList.size() > 0) {
        _resolveProperties(toplevel,toplevelHelper,testList);
        if (checkForErrors()) {
          errorList=testList;
          if (blockSize > errorList.size())           blockSize=errorList.size() / 2;
          continue WHILE_LOOP;
        }
      }
    }
    blockSize/=2;
    System.err.println(""String_Node_Str"" + blockSize);
  }
  System.out.println(errorList);
  _resolveProperties(toplevel,toplevelHelper,errorList);
}"
73969,"/** 
 * Parse the given expression for an arbitrary Property.
 * @param lattice The lattice.
 * @param expression The expression
 * @return The LatticeProperty that corresponds with the lattice andexpression.
 * @exception IllegalActionException If thrown by{@link #_parseElementExpression(PropertyLattice,String)}
 */
private static LatticeProperty _parsePropertyExpression(PropertyLattice lattice,String expression) throws IllegalActionException {
  if (expression.startsWith(""String_Node_Str"") && expression.endsWith(""String_Node_Str"")) {
    List<String> fieldExpressions=_parseList(expression.substring(1,expression.length() - 1));
    int size=fieldExpressions.size();
    String[] labels=new String[size];
    LatticeProperty[] fieldProperties=new LatticeProperty[size];
    for (int i=0; i < size; i++) {
      String fieldExpression=fieldExpressions.get(i);
      String[] labelAndProperty=fieldExpression.split(""String_Node_Str"",2);
      labels[i]=labelAndProperty[0];
      fieldProperties[i]=_parsePropertyExpression(lattice,labelAndProperty[1]);
    }
    return new RecordProperty(lattice,labels,fieldProperties);
  }
  return _parseElementExpression(lattice,expression);
}","/** 
 * Parse the given expression for an arbitrary Property.
 * @param lattice The lattice.
 * @param expression The expression
 * @return The LatticeProperty that corresponds with the lattice andexpression.
 * @exception IllegalActionException If thrown by{@link #_parseElementExpression(PropertyLattice,String)}
 */
private static LatticeProperty _parsePropertyExpression(PropertyLattice lattice,String expression) throws IllegalActionException {
  if (expression.startsWith(""String_Node_Str"") && expression.endsWith(""String_Node_Str"")) {
    List<String> fieldExpressions=_parseList(expression.substring(1,expression.length() - 1));
    int size=fieldExpressions.size();
    String[] labels=new String[size];
    LatticeProperty[] fieldProperties=new LatticeProperty[size];
    for (int i=0; i < size; i++) {
      String fieldExpression=fieldExpressions.get(i);
      String[] labelAndProperty=fieldExpression.split(""String_Node_Str"",2);
      labels[i]=labelAndProperty[0].trim();
      fieldProperties[i]=_parsePropertyExpression(lattice,labelAndProperty[1].trim());
    }
    return new RecordProperty(lattice,labels,fieldProperties);
  }
  return _parseElementExpression(lattice,expression);
}"
73970,"/** 
 * Invoke postfire() on any state refinements that were fired, then execute the commit actions contained by the last chosen transition, if any, then invoke postfire() on any transition refinements that were fired, and finally set the current state to the destination state of the transition. This will return false if any refinement that is postfired returns false. <p> If any transition was taken in this iteration, and if there is an executive director, and if there is a transition from the new state that is currently enabled, then this method calls fireAtCurrentTime(Actor) on that executive director (this call occurs indirectly in the FSMActor controller). If there is an enabled transition, then the current state is transient, and we will want to spend zero time in it.
 * @return True if the mode controller wishes to be scheduled foranother iteration.
 * @exception IllegalActionException If thrown by any commit actionor there is no controller.
 */
public boolean postfire() throws IllegalActionException {
  boolean result=true;
  if (_debugging) {
    _debug(""String_Node_Str"",getModelTime().toString());
  }
  Time environmentTime=_getEnvironmentTime();
  for (  Actor stateRefinement : _stateRefinementsToPostfire) {
    if (_debugging) {
      _debug(""String_Node_Str"",stateRefinement.getName());
    }
    _setTimeForRefinement(stateRefinement);
    if (!stateRefinement.postfire()) {
      _disabledActors.add(stateRefinement);
    }
    setModelTime(environmentTime);
    if (_lastChosenTransition != null && stateRefinement instanceof Suspendable) {
      ((Suspendable)stateRefinement).suspend(environmentTime);
    }
  }
  if (_lastChosenTransition != null) {
    State destinationState=_lastChosenTransition.destinationState();
    if (destinationState != null) {
      TypedActor[] destinationRefinements=destinationState.getRefinement();
      if (destinationRefinements != null) {
        for (        TypedActor destinationRefinement : destinationRefinements) {
          if (destinationRefinement instanceof Suspendable) {
            ((Suspendable)destinationRefinement).resume(environmentTime);
          }
        }
      }
    }
  }
  FSMActor controller=getController();
  result&=controller.postfire();
  for (  Actor transitionRefinement : _transitionRefinementsToPostfire) {
    if (_debugging) {
      _debug(""String_Node_Str"",transitionRefinement.getName());
    }
    if (!transitionRefinement.postfire()) {
      _disabledActors.add(transitionRefinement);
    }
  }
  _currentLocalReceiverMap=(Map)_localReceiverMaps.get(controller.currentState());
  _resetOutputReceivers();
  return result && !_stopRequested && !_finishRequested;
}","/** 
 * Invoke postfire() on any state refinements that were fired, then execute the commit actions contained by the last chosen transition, if any, then invoke postfire() on any transition refinements that were fired, and finally set the current state to the destination state of the transition. This will return false if any refinement that is postfired returns false. <p> If any transition was taken in this iteration, and if there is an executive director, and if there is a transition from the new state that is currently enabled, then this method calls fireAtCurrentTime(Actor) on that executive director (this call occurs indirectly in the FSMActor controller). If there is an enabled transition, then the current state is transient, and we will want to spend zero time in it.
 * @return True if the mode controller wishes to be scheduled foranother iteration.
 * @exception IllegalActionException If thrown by any commit actionor there is no controller.
 */
public boolean postfire() throws IllegalActionException {
  boolean result=true;
  if (_debugging) {
    _debug(""String_Node_Str"",getModelTime().toString());
  }
  FSMActor controller=getController();
  Time environmentTime=_getEnvironmentTime();
  for (  Actor stateRefinement : _stateRefinementsToPostfire) {
    if (_debugging) {
      _debug(""String_Node_Str"",stateRefinement.getName());
    }
    _setTimeForRefinement(stateRefinement);
    if (!stateRefinement.postfire()) {
      _disabledActors.add(stateRefinement);
    }
    setModelTime(environmentTime);
  }
  for (  Actor stateRefinement : controller.currentState().getRefinement()) {
    if (_lastChosenTransition != null && stateRefinement instanceof Suspendable) {
      ((Suspendable)stateRefinement).suspend(environmentTime);
    }
  }
  if (_lastChosenTransition != null) {
    State destinationState=_lastChosenTransition.destinationState();
    if (destinationState != null) {
      TypedActor[] destinationRefinements=destinationState.getRefinement();
      if (destinationRefinements != null) {
        for (        TypedActor destinationRefinement : destinationRefinements) {
          if (destinationRefinement instanceof Suspendable) {
            ((Suspendable)destinationRefinement).resume(environmentTime);
          }
        }
      }
    }
  }
  result&=controller.postfire();
  for (  Actor transitionRefinement : _transitionRefinementsToPostfire) {
    if (_debugging) {
      _debug(""String_Node_Str"",transitionRefinement.getName());
    }
    if (!transitionRefinement.postfire()) {
      _disabledActors.add(transitionRefinement);
    }
  }
  _currentLocalReceiverMap=(Map)_localReceiverMaps.get(controller.currentState());
  _resetOutputReceivers();
  return result && !_stopRequested && !_finishRequested;
}"
73971,"/** 
 * Read the data from the server instance, which will read it from the client program.
 * @exception IllegalActionException If there was an error whenreading from the server.
 */
private void _readFromServer() throws IllegalActionException {
  try {
    server.read();
    int fla=server.getClientFlag();
    if (fla < 0) {
      final String em=""String_Node_Str"" + this.getFullName() + ""String_Node_Str""+ fla+ ""String_Node_Str""+ getDirector().getModelTime().getDoubleValue()+ ""String_Node_Str"";
      throw new IllegalActionException(this,em);
    }
    if (fla > 0) {
      final String msg=""String_Node_Str"" + this.getFullName() + ""String_Node_Str""+ fla+ ""String_Node_Str""+ getDirector().getModelTime().getDoubleValue()+ ""String_Node_Str""+ LS+ ""String_Node_Str"";
      new Thread(new WarningWindow(msg)).start();
      System.err.println(""String_Node_Str"" + msg);
    }
  }
 catch (  java.net.SocketTimeoutException e) {
    String em=""String_Node_Str"" + this.getFullName() + ""String_Node_Str""+ LS+ e.getMessage()+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ programName.getExpression()+ ""String_Node_Str""+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ programName.getExpression()+ ""String_Node_Str""+ programArguments.getExpression()+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str"";
    try {
      server.close();
    }
 catch (    java.io.IOException e2) {
    }
    em+=""String_Node_Str"";
    try {
      em+=cliPro.exitValue();
    }
 catch (    Throwable throwable) {
      em+=""String_Node_Str"" + throwable.getMessage();
    }
    ;
    throw new IllegalActionException(this,e,em);
  }
catch (  java.io.IOException e) {
    String em=""String_Node_Str"" + LS + e.getMessage();
    try {
      server.close();
    }
 catch (    java.io.IOException e2) {
    }
    ;
    throw new IllegalActionException(this,e,em);
  }
}","/** 
 * Read the data from the server instance, which will read it from the client program.
 * @exception IllegalActionException If there was an error whenreading from the server.
 */
private void _readFromServer() throws IllegalActionException {
  try {
    server.read();
    int fla=server.getClientFlag();
    if (fla < 0) {
      final String em=""String_Node_Str"" + this.getFullName() + ""String_Node_Str""+ fla+ ""String_Node_Str""+ getDirector().getModelTime().getDoubleValue()+ ""String_Node_Str"";
      throw new IllegalActionException(this,em);
    }
    if (fla > 0) {
      clientTerminated=true;
      terminationMessage=""String_Node_Str"" + this.getFullName() + ""String_Node_Str""+ fla+ ""String_Node_Str""+ getDirector().getModelTime().getDoubleValue()+ ""String_Node_Str""+ LS+ ""String_Node_Str"";
    }
  }
 catch (  java.net.SocketTimeoutException e) {
    String em=""String_Node_Str"" + this.getFullName() + ""String_Node_Str""+ LS+ e.getMessage()+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ programName.getExpression()+ ""String_Node_Str""+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ programName.getExpression()+ ""String_Node_Str""+ programArguments.getExpression()+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ LS+ ""String_Node_Str"";
    try {
      server.close();
    }
 catch (    java.io.IOException e2) {
    }
    em+=""String_Node_Str"";
    try {
      em+=cliPro.exitValue();
    }
 catch (    Throwable throwable) {
      em+=""String_Node_Str"" + throwable.getMessage();
    }
    ;
    throw new IllegalActionException(this,e,em);
  }
catch (  java.io.IOException e) {
    String em=""String_Node_Str"";
    try {
      server.close();
    }
 catch (    java.io.IOException e2) {
    }
    ;
    throw new IllegalActionException(this,e,em);
  }
}"
73972,"/** 
 * Initializes the data members and checks if the parameters of the actor are valid.
 * @exception IllegalActionException If the parameters of theactor are invalid, or if the file with the socket information cannot be written to disk.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  worDir=Simulator.resolveDirectory(getContainer(),cutQuotationMarks(workingDirectory.getExpression()));
  if (!new File(worDir).isDirectory()) {
    String em=""String_Node_Str"" + LS + ""String_Node_Str""+ worDir+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ this.getFullName()+ ""String_Node_Str"";
    throw new IllegalActionException(this,em);
  }
  final String simCon=socketConfigurationFile.stringValue();
  porNo=Integer.valueOf(socketPortNumber.getExpression());
  try {
    final int timOutMilSec=Integer.valueOf(socketTimeout.getExpression());
    if (timOutMilSec <= 0) {
      final String em=""String_Node_Str"" + LS + ""String_Node_Str""+ timOutMilSec+ ""String_Node_Str"";
      throw new IllegalActionException(this,em);
    }
    if (porNo < 0) {
      server=new Server(timOutMilSec);
    }
 else {
      server=new Server(porNo,timOutMilSec);
    }
    porNo=server.getLocalPort();
  }
 catch (  java.io.IOException e) {
    if (server != null) {
      try {
        server.close();
      }
 catch (      java.io.IOException e2) {
      }
    }
    throw new IllegalActionException(this,e,e.getMessage());
  }
  XMLWriter xmlWri=new XMLWriter(worDir,simCon,porNo);
  try {
    xmlWri.write();
  }
 catch (  java.io.FileNotFoundException e) {
    String em=""String_Node_Str"" + new File(worDir,simCon).getAbsolutePath() + ""String_Node_Str"";
    throw new IllegalActionException(this,e,em);
  }
catch (  java.io.IOException e) {
    throw new IllegalActionException(this,e,e.toString());
  }
}","/** 
 * Initializes the data members and checks if the parameters of the actor are valid.
 * @exception IllegalActionException If the parameters of theactor are invalid, or if the file with the socket information cannot be written to disk.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  clientTerminated=false;
  terminationMessage=""String_Node_Str"";
  warWin=null;
  worDir=Simulator.resolveDirectory(getContainer(),cutQuotationMarks(workingDirectory.getExpression()));
  if (!new File(worDir).isDirectory()) {
    String em=""String_Node_Str"" + LS + ""String_Node_Str""+ worDir+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ this.getFullName()+ ""String_Node_Str"";
    throw new IllegalActionException(this,em);
  }
  final String simCon=socketConfigurationFile.stringValue();
  porNo=Integer.valueOf(socketPortNumber.getExpression());
  try {
    final int timOutMilSec=Integer.valueOf(socketTimeout.getExpression());
    if (timOutMilSec <= 0) {
      final String em=""String_Node_Str"" + LS + ""String_Node_Str""+ timOutMilSec+ ""String_Node_Str"";
      throw new IllegalActionException(this,em);
    }
    if (porNo < 0) {
      server=new Server(timOutMilSec);
    }
 else {
      server=new Server(porNo,timOutMilSec);
    }
    porNo=server.getLocalPort();
  }
 catch (  java.io.IOException e) {
    if (server != null) {
      try {
        server.close();
      }
 catch (      java.io.IOException e2) {
      }
    }
    throw new IllegalActionException(this,e,e.getMessage());
  }
  XMLWriter xmlWri=new XMLWriter(worDir,simCon,porNo);
  try {
    xmlWri.write();
  }
 catch (  java.io.FileNotFoundException e) {
    String em=""String_Node_Str"" + new File(worDir,simCon).getAbsolutePath() + ""String_Node_Str"";
    throw new IllegalActionException(this,e,em);
  }
catch (  java.io.IOException e) {
    throw new IllegalActionException(this,e,e.toString());
  }
  _startSimulation();
}"
73973,"/** 
 * Send the input token to the client program and send the output from the client program to the output port.
 * @exception IllegalActionException If the simulation time between Ptolemy and the client program is not synchronized.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (input.hasToken(0)) {
    if (!firstFire && server.getClientFlag() == 0) {
      _writeToServer();
      _readFromServer();
      if (server.getClientFlag() == 0) {
        final double simTimRea=server.getSimulationTimeReadFromClient();
        final double simTim=getDirector().getModelTime().getDoubleValue();
        if (Math.abs(simTim - simTimRea) > 0.0001) {
          final String em=""String_Node_Str"" + this.getFullName() + ""String_Node_Str""+ LS+ ""String_Node_Str""+ simTim+ LS+ ""String_Node_Str""+ simTimRea;
          throw new IllegalActionException(this,em);
        }
        double[] dblRea=server.getDoubleArray();
        outTok=new DoubleMatrixToken(dblRea,dblRea.length,1);
      }
    }
 else {
      input.get(0);
      firstFire=false;
    }
  }
  output.send(0,outTok);
}","/** 
 * Send the input token to the client program and send the output from the client program to the output port.
 * @exception IllegalActionException If the simulation time between Ptolemy and the client program is not synchronized.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (input.hasToken(0)) {
    if (server.getClientFlag() == 0) {
      _writeToServer();
      _readFromServer();
      if (server.getClientFlag() == 0) {
        double[] dblRea=server.getDoubleArray();
        outTok=new DoubleMatrixToken(dblRea,dblRea.length,1);
        final double simTimRea=server.getSimulationTimeReadFromClient();
        final double simTim=getDirector().getModelTime().getDoubleValue();
        if (firstFire)         firstFire=false;
 else {
          if (Math.abs((simTimRea - simTimReaPre) - (simTim - simTimPre)) > 0.0001) {
            final String em=""String_Node_Str"" + this.getFullName() + ""String_Node_Str""+ LS+ ""String_Node_Str""+ (simTim - simTimPre)+ LS+ ""String_Node_Str""+ (simTimRea - simTimReaPre)+ LS+ ""String_Node_Str""+ simTimRea;
            throw new IllegalActionException(this,em);
          }
        }
        simTimReaPre=simTimRea;
        simTimPre=simTim;
      }
    }
 else {
      if (clientTerminated) {
        if (warWin == null) {
          warWin=new Thread(new WarningWindow(terminationMessage));
          warWin.start();
          System.err.println(""String_Node_Str"" + terminationMessage);
        }
      }
      input.get(0);
      final double simTimRea=server.getSimulationTimeReadFromClient();
      final double simTim=getDirector().getModelTime().getDoubleValue();
      simTimReaPre=simTimRea;
      simTimPre=simTim;
    }
  }
  output.send(0,outTok);
}"
73974,"/** 
 * Initialize state variables.
 * @exception IllegalActionException If the parent class throws it orif the server socket cannot be opened
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  tokTim=getDirector().getModelTime().getDoubleValue();
  firstFire=true;
  _startSimulation();
  _readFromServer();
  double[] dblRea=server.getDoubleArray();
  outTok=new DoubleMatrixToken(dblRea,dblRea.length,1);
  output.send(0,outTok);
}","/** 
 * Initialize state variables.
 * @exception IllegalActionException If the parent class throws it orif the server socket cannot be opened
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  tokTim=getDirector().getModelTime().getDoubleValue();
  firstFire=true;
  _readFromServer();
  double[] dblRea=server.getDoubleArray();
  outTok=new DoubleMatrixToken(dblRea,dblRea.length,1);
  output.send(0,outTok);
}"
73975,"/** 
 * Start the simulation program.
 * @exception IllegalActionException If the simulation process argumentsare invalid.
 */
private void _startSimulation() throws IllegalActionException {
  final String worDir=cutQuotationMarks(workingDirectory.getExpression());
  File commandFile=programName.asFile();
  final String comArg;
  if (commandFile.exists()) {
    comArg=commandFile.toString();
  }
 else {
    commandFile=new File(commandFile.toString() + ""String_Node_Str"");
    if (commandFile.exists()) {
      comArg=commandFile.toString();
    }
 else {
      comArg=programName.getExpression();
    }
  }
  final String argLin=cutQuotationMarks(programArguments.getExpression());
  List<String> com=new ArrayList<String>();
  com.add(comArg);
  StringTokenizer st=new StringTokenizer(argLin);
  while (st.hasMoreTokens()) {
    com.add(st.nextToken());
  }
  cliPro=new ClientProcess();
  cliPro.redirectErrorStream(true);
  cliPro.setProcessArguments(com,worDir);
  File slf=simulationLogFile.asFile();
  try {
    if (slf.exists()) {
      if (slf.delete()) {
        if (slf.exists()) {
          throw new Exception(""String_Node_Str"");
        }
      }
    }
    if (!slf.createNewFile()) {
      throw new Exception(""String_Node_Str"");
    }
    if (!slf.canWrite()) {
      throw new Exception(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    String em=""String_Node_Str"" + LS + ""String_Node_Str""+ slf.getAbsolutePath()+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ this.getFullName()+ ""String_Node_Str"";
    throw new IllegalActionException(this,e,em);
  }
  cliPro.setSimulationLogFile(slf);
  cliPro.run();
  if (!cliPro.processStarted()) {
    String em=""String_Node_Str"" + LS + cliPro.getErrorMessage()+ LS+ ""String_Node_Str""+ this.getFullName()+ ""String_Node_Str"";
    throw new IllegalActionException(this,em);
  }
}","/** 
 * Start the simulation program.
 * @exception IllegalActionException If the simulation process argumentsare invalid.
 */
private void _startSimulation() throws IllegalActionException {
  final String worDir=cutQuotationMarks(workingDirectory.getExpression());
  List<String> com=new ArrayList<String>();
  com.add(Simulator.resolveCommandName(programName.asFile()));
  final String argLin=cutQuotationMarks(programArguments.getExpression());
  StringTokenizer st=new StringTokenizer(argLin);
  while (st.hasMoreTokens()) {
    com.add(st.nextToken());
  }
  cliPro=new ClientProcess();
  cliPro.redirectErrorStream(true);
  cliPro.setProcessArguments(com,worDir);
  File slf=simulationLogFile.asFile();
  try {
    if (slf.exists()) {
      if (slf.delete()) {
        if (slf.exists()) {
          throw new Exception(""String_Node_Str"");
        }
      }
    }
    if (!slf.createNewFile()) {
      throw new Exception(""String_Node_Str"");
    }
    if (!slf.canWrite()) {
      throw new Exception(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    String em=""String_Node_Str"" + LS + ""String_Node_Str""+ slf.getAbsolutePath()+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ this.getFullName()+ ""String_Node_Str"";
    throw new IllegalActionException(this,e,em);
  }
  cliPro.setSimulationLogFile(slf);
  cliPro.run();
  if (!cliPro.processStarted()) {
    String em=""String_Node_Str"" + LS + cliPro.getErrorMessage()+ LS+ ""String_Node_Str""+ this.getFullName()+ ""String_Node_Str"";
    throw new IllegalActionException(this,em);
  }
}"
73976,"/** 
 * Starts the simulation program.
 * @exception IllegalActionException If the simulation process argumentsare invalid.
 */
private void _startSimulation() throws IllegalActionException {
  ArrayList<String> com=new ArrayList<String>();
  for (Iterator itc=commandList.iterator(); itc.hasNext(); ) {
    String comIte=(String)itc.next();
    for (    Map.Entry<String,Token> e : _tokenMap.entrySet()) {
      final String fin='$' + e.getKey();
      while (comIte.contains(fin))       comIte=comIte.replace(fin,cutQuotationMarks(e.getValue().toString()));
    }
    String fin=""String_Node_Str"";
    while (comIte.contains(fin))     comIte=comIte.replace(fin,cutQuotationMarks(getDirector().getModelTime().toString()));
    fin=""String_Node_Str"";
    while (comIte.contains(fin))     comIte=comIte.replace(fin,new Integer(_iterationCount).toString());
    com.add(comIte);
  }
  cliPro.setProcessArguments(com,worDir);
  System.gc();
  File slf=simulationLogFile.asFile();
  try {
    if (slf.exists()) {
      if (slf.delete()) {
        if (slf.exists()) {
          throw new Exception(""String_Node_Str"");
        }
      }
    }
    if (!slf.createNewFile()) {
      throw new Exception(""String_Node_Str"");
    }
    if (!slf.canWrite()) {
      throw new Exception(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    String em=""String_Node_Str"" + LS + ""String_Node_Str""+ slf.getAbsolutePath()+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ this.getFullName()+ ""String_Node_Str"";
    throw new IllegalActionException(this,e,em);
  }
  cliPro.setSimulationLogFile(slf);
  cliPro.run();
  if (!cliPro.processStarted()) {
    String em=""String_Node_Str"" + LS + cliPro.getErrorMessage()+ LS+ ""String_Node_Str""+ this.getFullName()+ ""String_Node_Str"";
    throw new IllegalActionException(this,em);
  }
}","/** 
 * Starts the simulation program.
 * @exception IllegalActionException If the simulation process argumentsare invalid.
 */
private void _startSimulation() throws IllegalActionException {
  ArrayList<String> com=new ArrayList<String>();
  for (Iterator itc=commandList.iterator(); itc.hasNext(); ) {
    String comIte=(String)itc.next();
    for (    Map.Entry<String,Token> e : _tokenMap.entrySet()) {
      final String fin='$' + e.getKey();
      while (comIte.contains(fin))       comIte=comIte.replace(fin,cutQuotationMarks(e.getValue().toString()));
    }
    String fin=""String_Node_Str"";
    while (comIte.contains(fin))     comIte=comIte.replace(fin,cutQuotationMarks(getDirector().getModelTime().toString()));
    fin=""String_Node_Str"";
    while (comIte.contains(fin))     comIte=comIte.replace(fin,new Integer(_iterationCount).toString());
    com.add(comIte);
  }
  com.set(0,Simulator.resolveCommandName(new File(com.get(0))));
  cliPro.setProcessArguments(com,worDir);
  System.gc();
  File slf=simulationLogFile.asFile();
  try {
    if (slf.exists()) {
      if (slf.delete()) {
        if (slf.exists()) {
          throw new Exception(""String_Node_Str"");
        }
      }
    }
    if (!slf.createNewFile()) {
      throw new Exception(""String_Node_Str"");
    }
    if (!slf.canWrite()) {
      throw new Exception(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    String em=""String_Node_Str"" + LS + ""String_Node_Str""+ slf.getAbsolutePath()+ ""String_Node_Str""+ LS+ ""String_Node_Str""+ this.getFullName()+ ""String_Node_Str"";
    throw new IllegalActionException(this,e,em);
  }
  cliPro.setSimulationLogFile(slf);
  cliPro.run();
  if (!cliPro.processStarted()) {
    String em=""String_Node_Str"" + LS + cliPro.getErrorMessage()+ LS+ ""String_Node_Str""+ this.getFullName()+ ""String_Node_Str"";
    throw new IllegalActionException(this,em);
  }
}"
73977,"/** 
 * Set the process arguments.
 * @param cmdarray array containing the command to call and its arguments.
 * @param dir the working directory of the subprocess.
 * @exception IllegalActionException if the canonical path name of the program filecannot be obtained.
 */
public void setProcessArguments(List<String> cmdarray,String dir) throws IllegalActionException {
  cmdArr=new ArrayList<String>();
  for (int i=0; i < cmdarray.size(); i++) {
    if (i == 0) {
      String s=cmdarray.get(i);
      File f=new File(s);
      if (f.exists()) {
        try {
          s=f.getCanonicalPath();
        }
 catch (        java.io.IOException exc) {
          String em=""String_Node_Str"" + s + ""String_Node_Str"";
          throw new IllegalActionException(em);
        }
      }
      cmdArr.add(s);
    }
 else {
      cmdArr.add(cmdarray.get(i));
    }
  }
  if (dir.equalsIgnoreCase(""String_Node_Str"")) {
    worDir=new File(System.getProperty(""String_Node_Str""));
  }
 else   if (dir.startsWith(""String_Node_Str"")) {
    worDir=new File(System.getProperty(""String_Node_Str"") + dir.substring(1));
  }
 else {
    worDir=new File(dir);
    if (!worDir.isAbsolute()) {
      worDir=new File(System.getProperty(""String_Node_Str"") + File.separator + dir);
    }
  }
}","/** 
 * Set the process arguments.
 * @param cmdarray array containing the command to call and its arguments.
 * @param dir the working directory of the subprocess.
 * @exception IllegalActionException if the canonical path name of the program filecannot be obtained.
 */
public void setProcessArguments(List<String> cmdarray,String dir) throws IllegalActionException {
  cmdArr=new ArrayList<String>();
  for (int i=0; i < cmdarray.size(); i++)   cmdArr.add(cmdarray.get(i));
  if (dir.equalsIgnoreCase(""String_Node_Str"")) {
    worDir=new File(System.getProperty(""String_Node_Str""));
  }
 else   if (dir.startsWith(""String_Node_Str"")) {
    worDir=new File(System.getProperty(""String_Node_Str"") + dir.substring(1));
  }
 else {
    worDir=new File(dir);
    if (!worDir.isAbsolute()) {
      worDir=new File(System.getProperty(""String_Node_Str"") + File.separator + dir);
    }
  }
}"
73978,"/** 
 * Resolve the command string. This method replaces $CLASSPATH, relative file names and adds .exe to the command (under Windows)
 * @param prgramName Name of program that starts the simulation.
 * @exception IllegalActionException If the simulation process argumentsare invalid.
 */
public static String resolveCommandName(final File programName) throws IllegalActionException {
  File commandFile=programName;
  if (System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    File winComFil=new File(commandFile.toString() + ""String_Node_Str"");
    if (winComFil.exists()) {
      commandFile=winComFil;
    }
  }
  if (commandFile.isDirectory())   return commandFile.getName();
  String comArg=commandFile.toString();
  commandFile=new File(comArg);
  if (commandFile.exists() && !commandFile.isDirectory()) {
    try {
      comArg=commandFile.getCanonicalPath();
    }
 catch (    java.io.IOException exc) {
      String em=""String_Node_Str"" + comArg + ""String_Node_Str"";
      throw new IllegalActionException(em);
    }
  }
 else   comArg=commandFile.getName();
  return comArg;
}","/** 
 * Resolve the command string. This method replaces $CLASSPATH, relative file names and adds .exe to the command (under Windows)
 * @param prgramName Name of program that starts the simulation.
 * @exception IllegalActionException If the simulation process argumentsare invalid.
 */
public static String resolveCommandName(final File programName) throws IllegalActionException {
  File commandFile=programName;
  if (System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    File winComFil=new File(commandFile.toString() + ""String_Node_Str"");
    if (winComFil.exists())     commandFile=winComFil;
  }
  if (commandFile.isDirectory())   return commandFile.getName();
  String comArg=commandFile.toString();
  commandFile=new File(comArg);
  if (commandFile.exists() && !commandFile.isDirectory()) {
    try {
      comArg=commandFile.getCanonicalPath();
    }
 catch (    java.io.IOException exc) {
      String em=""String_Node_Str"" + comArg + ""String_Node_Str"";
      throw new IllegalActionException(em);
    }
  }
 else   comArg=commandFile.getName();
  return comArg;
}"
73979,"/** 
 * Set the values of input variables. Choose the enabled transition among the outgoing transitions of the current state. Throw an exception if there is more than one transition enabled. Otherwise, execute the output actions contained by the chosen transition.
 * @exception IllegalActionException If there is more than onetransition enabled.
 */
public void fire() throws IllegalActionException {
  readInputs();
  List transitionList=_currentState.outgoingPort.linkedRelationList();
  chooseTransition(transitionList);
}","/** 
 * Set the values of input variables. Choose the enabled transition among the outgoing transitions of the current state. Throw an exception if there is more than one transition enabled. Otherwise, execute the output actions contained by the chosen transition.
 * @exception IllegalActionException If there is more than onetransition enabled.
 */
public void fire() throws IllegalActionException {
  readInputs();
  List transitionList=_currentState.outgoingPort.linkedRelationList();
  Transition chosenTransition=chooseTransition(transitionList);
  if (chosenTransition == null && !foundUnknown() && _currentState.getRefinement() == null) {
    List<IOPort> outputs=outputPortList();
    for (    IOPort port : outputs) {
      for (int channel=0; channel < port.getWidth(); channel++) {
        if (!port.isKnown(channel)) {
          port.sendClear(channel);
        }
      }
    }
  }
}"
73980,"/** 
 * Given a transition, find any input ports referenced in the guard expressions of the transitions, and if any of those input ports has status unknown, return false. FIXME: bogus: Also, if the port identifier does not end with ""_isPresent"", then return false if port identifier with ""_isPresent"" appended is false. There is no data on the port ""in"" then the identifier ""in"" will be undefined, or worse, will resolve to the port object itself. Otherwise, return true. These are the input ports whose status must be known for this transition to be enabled.
 * @param transition A transition
 * @return A set of input ports.
 * @exception IllegalActionException If the guard expression cannotbe parsed.
 */
private boolean _referencedInputPortsByGuardKnown(Transition transition) throws IllegalActionException {
  String string=transition.getGuardExpression();
  if (string.trim().equals(""String_Node_Str"")) {
    return true;
  }
  PtParser parser=new PtParser();
  ASTPtRootNode parseTree=parser.generateParseTree(string);
  ParseTreeFreeVariableCollector variableCollector=new ParseTreeFreeVariableCollector();
  ParserScope scope=getPortScope();
  Set<String> nameSet=variableCollector.collectFreeVariables(parseTree,scope);
  for (  String name : nameSet) {
    Port port=_getPortForIdentifier(name);
    if (port instanceof IOPort) {
      int channel=_getChannelForIdentifier(name);
      if (channel >= 0) {
        if (!((IOPort)port).isKnown(channel)) {
          return false;
        }
        if (!name.endsWith(""String_Node_Str"")) {
          Token token=scope.get(port.getName() + ""String_Node_Str"" + channel+ ""String_Node_Str"");
          if (!(token instanceof BooleanToken) || !((BooleanToken)token).booleanValue()) {
            return false;
          }
        }
      }
 else {
        if (!((IOPort)port).isKnown()) {
          return false;
        }
        if (!name.endsWith(""String_Node_Str"")) {
          Token token=scope.get(port.getName() + ""String_Node_Str"");
          if (!(token instanceof BooleanToken) || !((BooleanToken)token).booleanValue()) {
            return false;
          }
        }
      }
    }
  }
  return true;
}","/** 
 * Given a transition, find any input ports referenced in the guard expressions of the transition, and if any of those input ports has status unknown, return false. Otherwise, return true. These are the input ports whose status must be known for this transition to be enabled.
 * @param transition A transition
 * @return True if all input ports referenced by the guard onthe transition have known status.
 * @exception IllegalActionException If the guard expression cannotbe parsed.
 */
private boolean _referencedInputPortsByGuardKnown(Transition transition) throws IllegalActionException {
  String string=transition.getGuardExpression();
  if (string.trim().equals(""String_Node_Str"")) {
    return true;
  }
  PtParser parser=new PtParser();
  ASTPtRootNode parseTree=parser.generateParseTree(string);
  ParseTreeFreeVariableCollector variableCollector=new ParseTreeFreeVariableCollector();
  ParserScope scope=getPortScope();
  Set<String> nameSet=variableCollector.collectFreeVariables(parseTree,scope);
  for (  String name : nameSet) {
    Port port=_getPortForIdentifier(name);
    if (port instanceof IOPort) {
      int channel=_getChannelForIdentifier(name);
      if (channel >= 0) {
        if (!((IOPort)port).isKnown(channel)) {
          return false;
        }
      }
 else {
        if (!((IOPort)port).isKnown()) {
          return false;
        }
      }
    }
  }
  return true;
}"
73981,"/** 
 * Return a list of enabled transitions among the given list of transitions. This includes all transitions whose guards can can be evaluated and evaluate to true, plus, if all guards can be evaluated and evaluate to false, all default transitions.
 * @param transitionList A list of transitions.
 * @return A list of enabled transition.
 * @exception IllegalActionException If the guard expression of anytransition can not be evaluated.
 */
public List enabledTransitions(List transitionList) throws IllegalActionException {
  LinkedList enabledTransitions=new LinkedList();
  LinkedList defaultTransitions=new LinkedList();
  Iterator transitionRelations=transitionList.iterator();
  boolean foundUnknown=false;
  while (transitionRelations.hasNext() && !_stopRequested) {
    Transition transition=(Transition)transitionRelations.next();
    if (transition.isDefault()) {
      if (transition.isEnabled()) {
        defaultTransitions.add(transition);
      }
    }
 else {
      foundUnknown=foundUnknown || !_referencedInputPortsByGuardKnown(transition);
      try {
        if (transition.isEnabled()) {
          enabledTransitions.add(transition);
        }
      }
 catch (      RuntimeException ex) {
        if (!foundUnknown) {
          throw ex;
        }
      }
catch (      IllegalActionException ex) {
        if (!foundUnknown) {
          throw ex;
        }
      }
    }
  }
  if (enabledTransitions.size() > 0) {
    return enabledTransitions;
  }
 else {
    if (!foundUnknown) {
      if (defaultTransitions.size() == 0 && _currentState.getRefinement() == null) {
        List<IOPort> outputs=outputPortList();
        for (        IOPort port : outputs) {
          for (int channel=0; channel < port.getWidth(); channel++) {
            if (!port.isKnown(channel)) {
              port.sendClear(channel);
            }
          }
        }
      }
      return defaultTransitions;
    }
  }
  return new LinkedList();
}","/** 
 * Return a list of enabled transitions among the given list of transitions. This includes all transitions whose guards can can be evaluated and evaluate to true, plus, if all guards can be evaluated and evaluate to false, all default transitions. <p> After calling this method, you can call foundUnknown() to determine whether any guard expressions were found in the specified transition list that referred to input ports that are not currently known.
 * @param transitionList A list of transitions.
 * @return A list of enabled transition.
 * @exception IllegalActionException If the guard expression of anytransition can not be evaluated.
 */
public List enabledTransitions(List transitionList) throws IllegalActionException {
  LinkedList enabledTransitions=new LinkedList();
  LinkedList defaultTransitions=new LinkedList();
  Iterator transitionRelations=transitionList.iterator();
  _foundUnknown=false;
  while (transitionRelations.hasNext() && !_stopRequested) {
    Transition transition=(Transition)transitionRelations.next();
    if (transition.isDefault()) {
      if (transition.isEnabled()) {
        defaultTransitions.add(transition);
      }
    }
 else {
      _foundUnknown=_foundUnknown || !_referencedInputPortsByGuardKnown(transition);
      try {
        if (transition.isEnabled()) {
          enabledTransitions.add(transition);
        }
      }
 catch (      RuntimeException ex) {
        if (!_foundUnknown) {
          if (_referencedInputPortValuesByGuardPresent(transition)) {
            throw ex;
          }
        }
      }
catch (      IllegalActionException ex) {
        if (!_foundUnknown) {
          if (_referencedInputPortValuesByGuardPresent(transition)) {
            throw ex;
          }
        }
      }
    }
  }
  if (enabledTransitions.size() > 0) {
    if (_debugging) {
      _debug(""String_Node_Str"" + enabledTransitions);
    }
    return enabledTransitions;
  }
 else {
    if (!_foundUnknown) {
      if (_debugging) {
        if (defaultTransitions.size() > 0) {
          _debug(""String_Node_Str"" + defaultTransitions);
        }
 else {
          _debug(""String_Node_Str"");
        }
      }
      return defaultTransitions;
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return new LinkedList();
}"
73982,"/** 
 * Execute all set actions contained by the transition chosen during the last call to chooseTransition(). Change current state to the destination state of the transition. Reset the refinement of the destination state if the <i>reset</i> parameter of the transition is true.
 * @exception IllegalActionException If any commit action throws it,or the last chosen transition does not have a destination state.
 */
protected void _commitLastChosenTransition() throws IllegalActionException {
  if (_lastChosenTransition == null) {
    return;
  }
  if (_debugging) {
    _debug(""String_Node_Str"",_lastChosenTransition.getFullName() + ""String_Node_Str"" + getDirector().getModelTime());
    _debug(""String_Node_Str"" + _lastChosenTransition.guardExpression.getExpression());
  }
  if (_lastChosenTransition.destinationState() == null) {
    throw new IllegalActionException(this,_lastChosenTransition,""String_Node_Str"" + ""String_Node_Str"");
  }
  BooleanToken resetToken=(BooleanToken)_lastChosenTransition.reset.getToken();
  Actor[] actors=_lastChosenTransition.destinationState().getRefinement();
  if (actors != null) {
    Director executiveDirector=getExecutiveDirector();
    for (int i=0; i < actors.length; ++i) {
      if (resetToken.booleanValue()) {
        if (_debugging) {
          _debug(getFullName() + ""String_Node_Str"" + ((NamedObj)actors[i]).getName());
        }
        if (executiveDirector instanceof FSMDirector) {
          try {
            ((FSMDirector)executiveDirector)._indexOffset=1;
            actors[i].initialize();
          }
  finally {
            ((FSMDirector)executiveDirector)._indexOffset=0;
          }
        }
 else {
          actors[i].initialize();
        }
      }
 else {
        actors[i].getDirector().setModelTime(executiveDirector.getModelTime());
        Director destinationDirector=actors[i].getDirector();
        int index=1;
        if (executiveDirector instanceof SuperdenseTimeDirector) {
          index=((SuperdenseTimeDirector)executiveDirector).getIndex() + 1;
        }
        if (destinationDirector instanceof SuperdenseTimeDirector) {
          ((SuperdenseTimeDirector)destinationDirector).setIndex(index);
        }
      }
    }
  }
  Iterator actions=_lastChosenTransition.commitActionList().iterator();
  while (actions.hasNext() && !_stopRequested) {
    Action action=(Action)actions.next();
    action.execute();
  }
  boolean stateChanged=_currentState != _lastChosenTransition.destinationState();
  _currentState=_lastChosenTransition.destinationState();
  if (_debugging) {
    _debug(new StateEvent(this,_currentState));
  }
  if (((BooleanToken)_currentState.isFinalState.getToken()).booleanValue()) {
    _reachedFinalState=true;
  }
  _setCurrentConnectionMap();
  boolean stateDependent=((BooleanToken)stateDependentCausality.getToken()).booleanValue();
  if (stateDependent && stateChanged) {
    ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
      protected void _execute(){
        getDirector().invalidateSchedule();
      }
    }
;
    requestChange(request);
  }
  getDirector().fireAtCurrentTime(this);
}","/** 
 * Execute all set actions contained by the transition chosen during the last call to chooseTransition(). Change current state to the destination state of the transition. Reset the refinement of the destination state if the <i>reset</i> parameter of the transition is true.
 * @exception IllegalActionException If any commit action throws it,or the last chosen transition does not have a destination state.
 */
protected void _commitLastChosenTransition() throws IllegalActionException {
  if (_lastChosenTransition == null) {
    return;
  }
  if (_debugging) {
    _debug(""String_Node_Str"",_lastChosenTransition.getFullName() + ""String_Node_Str"" + getDirector().getModelTime());
    _debug(""String_Node_Str"" + _lastChosenTransition.guardExpression.getExpression());
  }
  if (_lastChosenTransition.destinationState() == null) {
    throw new IllegalActionException(this,_lastChosenTransition,""String_Node_Str"" + ""String_Node_Str"");
  }
  BooleanToken resetToken=(BooleanToken)_lastChosenTransition.reset.getToken();
  Actor[] actors=_lastChosenTransition.destinationState().getRefinement();
  if (actors != null) {
    Director executiveDirector=getExecutiveDirector();
    for (int i=0; i < actors.length; ++i) {
      if (resetToken.booleanValue()) {
        if (_debugging) {
          _debug(getFullName() + ""String_Node_Str"" + ((NamedObj)actors[i]).getName());
        }
        if (executiveDirector instanceof FSMDirector) {
          try {
            ((FSMDirector)executiveDirector)._indexOffset=1;
            actors[i].initialize();
          }
  finally {
            ((FSMDirector)executiveDirector)._indexOffset=0;
          }
        }
 else {
          actors[i].initialize();
        }
      }
    }
  }
  Iterator actions=_lastChosenTransition.commitActionList().iterator();
  while (actions.hasNext() && !_stopRequested) {
    Action action=(Action)actions.next();
    action.execute();
  }
  boolean stateChanged=_currentState != _lastChosenTransition.destinationState();
  _currentState=_lastChosenTransition.destinationState();
  if (_debugging) {
    _debug(new StateEvent(this,_currentState));
  }
  if (((BooleanToken)_currentState.isFinalState.getToken()).booleanValue()) {
    _reachedFinalState=true;
  }
  _setCurrentConnectionMap();
  boolean stateDependent=((BooleanToken)stateDependentCausality.getToken()).booleanValue();
  if (stateDependent && stateChanged) {
    ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
      protected void _execute(){
        getDirector().invalidateSchedule();
      }
    }
;
    requestChange(request);
  }
  getDirector().fireAtCurrentTime(this);
}"
73983,"/** 
 * Return an enabled transition among the given list of transitions for which both the guard expression and the output actions can be evaluated (the inputs referred by these are known). If there is only one transition enabled, return that transition. In case there are multiple enabled transitions, if any of them is not nondeterministic, throw an exception. See   {@link Transition}for the explanation of ""nondeterministic"". Otherwise, randomly choose one from the enabled transitions and return it if the output actions can be evaluated. Execute the output actions contained by the returned transition before returning.
 * @param transitionList A list of transitions.
 * @return An enabled transition, or null if none is enabled.
 * @exception IllegalActionException If there is more than onetransition enabled and not all of them are nondeterministic.
 */
public Transition chooseTransition(List transitionList) throws IllegalActionException {
  List<Transition> enabledTransitions=enabledTransitions(transitionList);
  int length=enabledTransitions.size();
  if (length > 1) {
    for (    Transition enabledTransition : enabledTransitions) {
      if (!enabledTransition.isNondeterministic()) {
        throw new MultipleEnabledTransitionsException(currentState(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + enabledTransition.getName() + ""String_Node_Str"");
      }
    }
  }
  if (_lastChosenTransition != null) {
    if (!enabledTransitions.contains(_lastChosenTransition)) {
      throw new IllegalActionException(this,_lastChosenTransition,""String_Node_Str"" + ""String_Node_Str"");
    }
    return _lastChosenTransition;
  }
  Transition result=null;
  if (length == 1) {
    result=(Transition)enabledTransitions.get(0);
  }
 else   if (length > 1) {
    while (enabledTransitions.size() > 0) {
      int randomChoice=(int)Math.floor(Math.random() * length);
      if (randomChoice == length) {
        randomChoice--;
      }
      result=(Transition)enabledTransitions.get(randomChoice);
      if (_referencedInputPortsByOutputKnown(result)) {
        break;
      }
 else {
        enabledTransitions.remove(result);
        result=null;
      }
    }
  }
  if (result != null) {
    if (_debugging) {
      _debug(""String_Node_Str"",result.getFullName());
    }
    Iterator actions=result.choiceActionList().iterator();
    while (actions.hasNext()) {
      Action action=(Action)actions.next();
      action.execute();
    }
    if (_currentState.getRefinement() == null) {
      List<IOPort> outputs=outputPortList();
      for (      IOPort port : outputs) {
        for (int channel=0; channel < port.getWidth(); channel++) {
          if (!port.isKnown(channel)) {
            port.sendClear(channel);
          }
        }
      }
    }
  }
  _lastChosenTransition=result;
  return result;
}","/** 
 * Return an enabled transition among the given list of transitions for which both the guard expression and the output actions can be evaluated (the inputs referred by these are known). If there is only one transition enabled, return that transition. In case there are multiple enabled transitions, if any of them is not nondeterministic, throw an exception. See   {@link Transition}for the explanation of ""nondeterministic"". Otherwise, randomly choose one from the enabled transitions and return it if the output actions can be evaluated. Execute the output actions contained by the returned transition before returning. <p> After calling this method, you can call foundUnknown() to determine whether any guard expressions or output value expressions on a transition whose guard evaluates to true were found in the specified transition list that referred to input ports that are not currently known.
 * @param transitionList A list of transitions.
 * @return An enabled transition, or null if none is enabled.
 * @exception IllegalActionException If there is more than onetransition enabled and not all of them are nondeterministic.
 */
public Transition chooseTransition(List transitionList) throws IllegalActionException {
  List<Transition> enabledTransitions=enabledTransitions(transitionList);
  int length=enabledTransitions.size();
  if (length > 1) {
    for (    Transition enabledTransition : enabledTransitions) {
      if (!enabledTransition.isNondeterministic()) {
        throw new MultipleEnabledTransitionsException(currentState(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + enabledTransition.getName() + ""String_Node_Str"");
      }
    }
  }
  if (_lastChosenTransition != null) {
    if (!enabledTransitions.contains(_lastChosenTransition)) {
      throw new IllegalActionException(this,_lastChosenTransition,""String_Node_Str"" + ""String_Node_Str"");
    }
    return _lastChosenTransition;
  }
  Transition result=null;
  if (length == 1) {
    result=(Transition)enabledTransitions.get(0);
  }
 else   if (length > 1) {
    while (enabledTransitions.size() > 0) {
      int randomChoice=(int)Math.floor(Math.random() * length);
      if (randomChoice == length) {
        randomChoice--;
      }
      result=(Transition)enabledTransitions.get(randomChoice);
      if (_referencedInputPortsByOutputKnown(result)) {
        _foundUnknown=true;
        break;
      }
 else {
        enabledTransitions.remove(result);
        result=null;
      }
    }
  }
  if (result != null) {
    if (_debugging) {
      _debug(""String_Node_Str"",result.getFullName());
    }
    Iterator actions=result.choiceActionList().iterator();
    while (actions.hasNext()) {
      Action action=(Action)actions.next();
      action.execute();
    }
    if (_currentState.getRefinement() == null) {
      List<IOPort> outputs=outputPortList();
      for (      IOPort port : outputs) {
        for (int channel=0; channel < port.getWidth(); channel++) {
          if (!port.isKnown(channel)) {
            port.sendClear(channel);
          }
        }
      }
    }
  }
  _lastChosenTransition=result;
  return result;
}"
73984,"/** 
 * Calculates the absolute deadline for the pure event. This uses information stored earlier. The exact calculation is done as follows: <p> If the new event(e') is produced due to the processing of a trigger event(e), then the absolute deadline of the new event AD(e') = AD(e) + (\tau(e') - \tau(e) - \delta). Here, \tau(e') and \tau(e) are the timestamps of e' and e, while \delta is the minimum dependency between the destination port of the trigger event and any of the output ports. </p><p> If the new event (e') is produced due to the processing of a earlier pure event, then the formula is the same, only \delta == 0;
 * @see #_saveEventInformation(List)
 */
private Time _absoluteDeadlineForPureEvent(Time nextTimestamp){
  Time timeDiff=(nextTimestamp.subtract(_lastTimestamp)).subtract(_lastDependency.timeValue());
  if (timeDiff.compareTo(_zero) < 0) {
    return _lastAbsoluteDeadline;
  }
  return _lastAbsoluteDeadline.add(timeDiff);
}","/** 
 * Calculates the absolute deadline for the pure event. This uses information stored earlier. The exact calculation is done as follows: <p> If the new event(e') is produced due to the processing of a trigger event(e), then the absolute deadline of the new event AD(e') = AD(e) + (\tau(e') - \tau(e) - \delta). Here, \tau(e') and \tau(e) are the timestamps of e' and e, while \delta is the minimum dependency between the destination port of the trigger event and any of the output ports. </p><p> If the new event (e') is produced due to the processing of a earlier pure event, then the formula is the same, only \delta == 0;
 * @see #_saveEventInformation(List)
 */
private Time _absoluteDeadlineForPureEvent(Time nextTimestamp){
  if (_lastTimestamp == null || _lastDependency == null) {
    return Time.NEGATIVE_INFINITY;
  }
  Time timeDiff=(nextTimestamp.subtract(_lastTimestamp)).subtract(_lastDependency.timeValue());
  if (timeDiff.compareTo(_zero) < 0) {
    return _lastAbsoluteDeadline;
  }
  return _lastAbsoluteDeadline.add(timeDiff);
}"
73985,"/** 
 * Initialize the actors and request a refiring at the current time of the executive director. This overrides the base class to throw an exception if there is no executive director.
 * @exception IllegalActionException If the superclass throwsit or if there is no executive director.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _currentlyExecutingStack=new Stack<DoubleTimedEvent>();
  _realTimeInputEventQueue=new PriorityQueue<RealTimeEvent>();
  _realTimeOutputEventQueue=new PriorityQueue<RealTimeEvent>();
  _lastConsumedTag=new HashMap<NamedObj,Tag>();
  _physicalTimeExecutionStarted=null;
  NamedObj container=getContainer();
  if (!(container instanceof Actor)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  if (executiveDirector == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  executiveDirector.fireAtCurrentTime((Actor)container);
  _setIcon(_getIdleIcon(),true);
}","/** 
 * Initialize the actors and request a refiring at the current time of the executive director. This overrides the base class to throw an exception if there is no executive director.
 * @exception IllegalActionException If the superclass throwsit or if there is no executive director.
 */
public void initialize() throws IllegalActionException {
  _currentlyExecutingStack=new Stack<DoubleTimedEvent>();
  _realTimeInputEventQueue=new PriorityQueue<RealTimeEvent>();
  _realTimeOutputEventQueue=new PriorityQueue<RealTimeEvent>();
  _lastConsumedTag=new HashMap<NamedObj,Tag>();
  _physicalTimeExecutionStarted=null;
  _lastAbsoluteDeadline=null;
  _lastDependency=null;
  _lastExecutingActor=null;
  _lastSourcePort=null;
  _lastTimestamp=null;
  super.initialize();
  NamedObj container=getContainer();
  if (!(container instanceof Actor)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  if (executiveDirector == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  executiveDirector.fireAtCurrentTime((Actor)container);
  _setIcon(_getIdleIcon(),true);
}"
73986,"/** 
 * Invoke a subprocess, read the <i>input</i> data (if any) and wait for the subprocess to terminate before sending any output or error data to the appropriate ports. <p>If there is no data on the <i>input</i> port, then the subprocess executes without reading any input. If there is no output or error data from the subprocess, then the empty string is sent to the appropriate port(s).</p>
 * @exception IllegalActionException If the subprocess cannot bestarted, if the input of the subprocess cannot be written, if the subprocess gets interrupted, or if the return value of the process is non-zero.
 */
public void fire() throws IllegalActionException {
  super.fire();
  String line=null;
  _exec();
  if ((input.numberOfSources() > 0) && input.hasToken(0)) {
    if ((line=((StringToken)input.get(0)).stringValue()) != null) {
      if (_debugging) {
        _debug(""String_Node_Str"" + line + ""String_Node_Str"");
      }
      if (_inputBufferedWriter != null) {
        try {
          _inputBufferedWriter.write(line);
          _inputBufferedWriter.flush();
        }
 catch (        IOException ex) {
          throw new IllegalActionException(this,ex,""String_Node_Str"" + command + ""String_Node_Str"");
        }
      }
    }
  }
  try {
    _process.getOutputStream().close();
    boolean waitForProcessValue=((BooleanToken)waitForProcess.getToken()).booleanValue();
    if (waitForProcessValue) {
      int processReturnCode=_process.waitFor();
      if (processReturnCode != 0) {
        String outputString=""String_Node_Str"";
        String errorString=""String_Node_Str"";
        try {
          errorString=_errorGobbler.getAndReset();
        }
 catch (        Exception ex) {
          errorString=ex.toString();
        }
        try {
          outputString=_outputGobbler.getAndReset();
        }
 catch (        Exception ex) {
          outputString=ex.toString();
        }
        boolean throwExceptionOnNonZeroReturnValue=((BooleanToken)throwExceptionOnNonZeroReturn.getToken()).booleanValue();
        if (throwExceptionOnNonZeroReturnValue) {
          throw new IllegalActionException(this,""String_Node_Str"" + ((StringToken)command.getToken()).stringValue() + ""String_Node_Str""+ processReturnCode+ ""String_Node_Str""+ line+ ""String_Node_Str""+ outputString+ ""String_Node_Str""+ errorString);
        }
 else {
          error.send(0,new StringToken(errorString));
          output.send(0,new StringToken(outputString));
        }
      }
      exitCode.send(0,new IntToken(processReturnCode));
    }
  }
 catch (  InterruptedException interrupted) {
    throw new InternalErrorException(this,interrupted,""String_Node_Str"");
  }
catch (  IOException io) {
    throw new IllegalActionException(this,io,""String_Node_Str"");
  }
  String outputString=_outputGobbler.getAndReset();
  String errorString=_errorGobbler.getAndReset();
  if (_debugging) {
    _debug(""String_Node_Str"" + errorString + ""String_Node_Str"");
    _debug(""String_Node_Str"" + outputString + ""String_Node_Str"");
  }
  error.send(0,new StringToken(errorString));
  output.send(0,new StringToken(outputString));
}","/** 
 * Invoke a subprocess, read the <i>input</i> data (if any) and wait for the subprocess to terminate before sending any output or error data to the appropriate ports. <p>If there is no data on the <i>input</i> port, then the subprocess executes without reading any input. If there is no output or error data from the subprocess, then the empty string is sent to the appropriate port(s).</p>
 * @exception IllegalActionException If the subprocess cannot bestarted, if the input of the subprocess cannot be written, if the subprocess gets interrupted, or if the return value of the process is non-zero.
 */
public void fire() throws IllegalActionException {
  super.fire();
  String line=null;
  _exec();
  if ((input.numberOfSources() > 0) && input.hasToken(0)) {
    if ((line=((StringToken)input.get(0)).stringValue()) != null) {
      if (_debugging) {
        _debug(""String_Node_Str"" + line + ""String_Node_Str"");
      }
      if (_inputBufferedWriter != null) {
        try {
          _inputBufferedWriter.write(line);
          _inputBufferedWriter.flush();
        }
 catch (        IOException ex) {
          throw new IllegalActionException(this,ex,""String_Node_Str"" + command + ""String_Node_Str"");
        }
      }
    }
  }
  boolean alreadySentOutput=false;
  try {
    _process.getOutputStream().close();
    boolean waitForProcessValue=((BooleanToken)waitForProcess.getToken()).booleanValue();
    if (waitForProcessValue) {
      int processReturnCode=_process.waitFor();
      if (processReturnCode != 0) {
        String outputString=""String_Node_Str"";
        String errorString=""String_Node_Str"";
        try {
          errorString=_errorGobbler.getAndReset();
        }
 catch (        Exception ex) {
          errorString=ex.toString();
        }
        try {
          outputString=_outputGobbler.getAndReset();
        }
 catch (        Exception ex) {
          outputString=ex.toString();
        }
        boolean throwExceptionOnNonZeroReturnValue=((BooleanToken)throwExceptionOnNonZeroReturn.getToken()).booleanValue();
        if (throwExceptionOnNonZeroReturnValue) {
          throw new IllegalActionException(this,""String_Node_Str"" + ((StringToken)command.getToken()).stringValue() + ""String_Node_Str""+ processReturnCode+ ""String_Node_Str""+ line+ ""String_Node_Str""+ outputString+ ""String_Node_Str""+ errorString);
        }
 else {
          error.send(0,new StringToken(errorString));
          output.send(0,new StringToken(outputString));
          alreadySentOutput=true;
        }
      }
      exitCode.send(0,new IntToken(processReturnCode));
    }
  }
 catch (  InterruptedException interrupted) {
    throw new InternalErrorException(this,interrupted,""String_Node_Str"");
  }
catch (  IOException io) {
    throw new IllegalActionException(this,io,""String_Node_Str"");
  }
  if (!alreadySentOutput) {
    String outputString=_outputGobbler.getAndReset();
    String errorString=_errorGobbler.getAndReset();
    if (_debugging) {
      _debug(""String_Node_Str"" + errorString + ""String_Node_Str"");
      _debug(""String_Node_Str"" + outputString + ""String_Node_Str"");
    }
    error.send(0,new StringToken(errorString));
    output.send(0,new StringToken(outputString));
  }
}"
73987,"/** 
 * Return a collection of ports that are finite equivalent ports of the input port. <p> A finite equivalence class is defined as follows. If input ports X and Y each have a dependency not equal to the default depenency's oPlusIdentity() on any common port or on two equivalent ports or on the state of the associated actor, then they are in a finite equivalence class. The returned Collection has no duplicate entries. If the port is not an input port, an exception is thrown.
 * @param input The input port.
 * @return Collection of finite equivalent ports.
 * @exception IllegalActionException
 */
protected static Collection<IOPort> _finiteEquivalentPorts(IOPort input) throws IllegalActionException {
  Collection<IOPort> result=new HashSet<IOPort>();
  Collection<IOPort> outputs=_finiteDependentPorts(input);
  for (  IOPort output : outputs) {
    result.addAll(_finiteDependentPorts(output));
  }
  return result;
}","/** 
 * Return a collection of ports that are finite equivalent ports of the input port. <p> A finite equivalence class is defined as follows. If input ports X and Y each have a dependency not equal to the default depenency's oPlusIdentity() on any common port or on two equivalent ports or on the state of the associated actor, then they are in a finite equivalence class. The returned Collection has no duplicate entries. If the port is not an input port, an exception is thrown.
 * @param input The input port.
 * @return Collection of finite equivalent ports.
 * @exception IllegalActionException
 */
protected static Collection<IOPort> _finiteEquivalentPorts(IOPort input) throws IllegalActionException {
  Collection<IOPort> result=new HashSet<IOPort>();
  result.add(input);
  Collection<IOPort> outputs=_finiteDependentPorts(input);
  for (  IOPort output : outputs) {
    result.addAll(_finiteDependentPorts(output));
  }
  return result;
}"
73988,"/** 
 * Overwrite the _transferOutputs() function. First, for tokens that are stored in the actuator event queue and send them to the outside of the platform if physical time has arrived. The second step is to check if this port is a networkedOutput port, if it is, transfer data tokens immediately to the outside by calling super._transferOutputs(port). Finally, we check for current model time, if the current model time is equal to the physical time, we can send the tokens to the outside. Else if current model time has exceeded the physical time, and we still have tokens to transfer, then we have missed the deadline. Else if current model time has not arrived at the physical time, then we put the token along with the port and channel into the actuator event queue, and call fireAt of the executive director so we could send it at a later physical time.
 */
protected boolean _transferOutputs(IOPort port) throws IllegalActionException {
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferOutputs(port);
  }
  boolean result=false;
  Time physicalTime=getPhysicalTime();
  int compare=0;
  while (true) {
    if (_realTimeOutputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent tokenEvent=(RealTimeEvent)_realTimeOutputEventQueue.peek();
    compare=tokenEvent.deliveryTime.compareTo(physicalTime);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      if (_isNetworkPort(tokenEvent.port)) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
      _realTimeOutputEventQueue.poll();
      tokenEvent.port.send(tokenEvent.channel,tokenEvent.token);
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + tokenEvent.token + ""String_Node_Str""+ tokenEvent.port.getName());
      }
      result=true;
    }
 else     if (compare < 0) {
      throw new IllegalActionException(tokenEvent.port,""String_Node_Str"" + tokenEvent.deliveryTime + ""String_Node_Str""+ physicalTime);
    }
  }
  if (_isNetworkPort(port)) {
    while (true) {
      if (!super._transferOutputs(port)) {
        break;
      }
 else {
        result=true;
      }
    }
  }
  compare=_currentTime.compareTo(physicalTime);
  if (compare == 0) {
    result=result || super._transferOutputs(port);
  }
 else   if (compare < 0) {
    for (int i=0; i < port.getWidthInside(); i++) {
      if (port.hasTokenInside(i)) {
        throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + _currentTime + ""String_Node_Str""+ physicalTime);
      }
    }
  }
 else {
    for (int i=0; i < port.getWidthInside(); i++) {
      try {
        if (port.hasTokenInside(i)) {
          Token t=port.getInside(i);
          RealTimeEvent tokenEvent=new RealTimeEvent(port,i,t,_currentTime);
          _realTimeOutputEventQueue.add(tokenEvent);
          Actor container=(Actor)getContainer();
          container.getExecutiveDirector().fireAt((Actor)container,_currentTime);
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
  }
  return result;
}","/** 
 * Overwrite the _transferOutputs() function. First, for tokens that are stored in the actuator event queue and send them to the outside of the platform if physical time has arrived. The second step is to check if this port is a networkedOutput port, if it is, transfer data tokens immediately to the outside by calling super._transferOutputs(port). Finally, we check for current model time, if the current model time is equal to the physical time, we can send the tokens to the outside. Else if current model time has exceeded the physical time, and we still have tokens to transfer, then we have missed the deadline. Else if current model time has not arrived at the physical time, then we put the token along with the port and channel into the actuator event queue, and call fireAt of the executive director so we could send it at a later physical time.
 */
protected boolean _transferOutputs(IOPort port) throws IllegalActionException {
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port instanceof RefinementPort) {
    return super._transferOutputs(port);
  }
  boolean result=false;
  Time physicalTime=getPhysicalTime();
  int compare=0;
  while (true) {
    if (_realTimeOutputEventQueue.isEmpty()) {
      break;
    }
    RealTimeEvent tokenEvent=(RealTimeEvent)_realTimeOutputEventQueue.peek();
    compare=tokenEvent.deliveryTime.compareTo(physicalTime);
    if (compare > 0) {
      break;
    }
 else     if (compare == 0) {
      if (_isNetworkPort(tokenEvent.port)) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
      _realTimeOutputEventQueue.poll();
      tokenEvent.port.send(tokenEvent.channel,tokenEvent.token);
      if (_debugging) {
        _debug(getName(),""String_Node_Str"" + tokenEvent.token + ""String_Node_Str""+ tokenEvent.port.getName());
      }
      result=true;
    }
 else     if (compare < 0) {
      throw new IllegalActionException(tokenEvent.port,""String_Node_Str"" + tokenEvent.deliveryTime + ""String_Node_Str""+ physicalTime);
    }
  }
  if (_isNetworkPort(port) || _transferImmediately(port)) {
    while (true) {
      if (!super._transferOutputs(port)) {
        break;
      }
 else {
        result=true;
      }
    }
  }
  compare=_currentTime.compareTo(physicalTime);
  if (compare == 0) {
    result=result || super._transferOutputs(port);
  }
 else   if (compare < 0) {
    for (int i=0; i < port.getWidthInside(); i++) {
      if (port.hasTokenInside(i)) {
        throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + _currentTime + ""String_Node_Str""+ physicalTime);
      }
    }
  }
 else {
    for (int i=0; i < port.getWidthInside(); i++) {
      try {
        if (port.hasTokenInside(i)) {
          Token t=port.getInside(i);
          RealTimeEvent tokenEvent=new RealTimeEvent(port,i,t,_currentTime);
          _realTimeOutputEventQueue.add(tokenEvent);
          Actor container=(Actor)getContainer();
          container.getExecutiveDirector().fireAt((Actor)container,_currentTime);
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
  }
  return result;
}"
73989,"/** 
 * If this actor is opaque, transfer any data from the input ports of this composite to the ports connected on the inside, and then invoke the fire() method of its local director. The transfer is accomplished by calling the transferInputs() method of the local director (the exact behavior of which depends on the domain).  If the actor is not opaque, throw an exception. This method is read-synchronized on the workspace, so the fire() method of the director need not be (assuming it is only called from here).  After the fire() method of the director returns, send any output data created by calling the local director's transferOutputs method.
 * @exception IllegalActionException If there is no director, or ifthe director's fire() method throws it, or if the actor is not opaque.
 */
public void fire() throws IllegalActionException {
  if (_fireMethod == null) {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
    super.fire();
    return;
  }
  try {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    List<Object> argList=new LinkedList<Object>();
    Iterator<?> inputPorts=inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort port=(TypedIOPort)inputPorts.next();
      int rate=DFUtilities.getTokenConsumptionRate(port);
      Type type=((TypedIOPort)port).getType();
      Object tokenHolder=null;
      int numberOfChannels=port.getWidth() < port.getWidthInside() ? port.getWidth() : port.getWidthInside();
      if (type == BaseType.INT) {
        tokenHolder=new int[numberOfChannels][];
      }
 else       if (type == BaseType.DOUBLE) {
        tokenHolder=new double[numberOfChannels][];
      }
 else       if (type == BaseType.BOOLEAN) {
        tokenHolder=new boolean[numberOfChannels][];
      }
 else {
      }
      for (int i=0; i < port.getWidth(); i++) {
        try {
          if (i < port.getWidthInside()) {
            if (port.hasToken(i,rate)) {
              Token[] tokens=port.get(i,rate);
              if (_debugging) {
                _debug(getName(),""String_Node_Str"" + port.getName());
              }
              if (type == BaseType.INT) {
                if (rate > 1) {
                  int[] intTokens=new int[rate];
                  for (int k=0; k < rate; k++) {
                    intTokens[k]=((IntToken)tokens[k]).intValue();
                  }
                  tokenHolder=intTokens;
                }
 else {
                  tokenHolder=((IntToken)tokens[0]).intValue();
                }
              }
 else               if (type == BaseType.DOUBLE) {
                if (rate > 1) {
                  for (int k=0; k < rate; k++) {
                    double[] doubleTokens=new double[rate];
                    doubleTokens[k]=((DoubleToken)tokens[k]).doubleValue();
                    tokenHolder=doubleTokens;
                  }
                }
 else {
                  tokenHolder=((DoubleToken)tokens[0]).doubleValue();
                }
              }
 else               if (type == BaseType.BOOLEAN) {
                if (rate > 1) {
                  boolean[] booleanTokens=new boolean[rate];
                  for (int k=0; k < rate; k++) {
                    booleanTokens[k]=((BooleanToken)tokens[k]).booleanValue();
                  }
                  tokenHolder=booleanTokens;
                }
 else {
                  tokenHolder=((BooleanToken)tokens[0]).booleanValue();
                }
              }
 else {
              }
              argList.add(tokenHolder);
            }
 else {
              throw new IllegalActionException(this,port,""String_Node_Str"" + rate + ""String_Node_Str""+ ""String_Node_Str"");
            }
          }
 else {
            if (_debugging) {
              _debug(getName(),""String_Node_Str"" + port.getName());
            }
            if (port.hasToken(i)) {
              port.get(i);
            }
          }
        }
 catch (        NoTokenException ex) {
          throw new InternalErrorException(this,ex,null);
        }
      }
    }
    Object[] tokensToAllOutputPorts;
    tokensToAllOutputPorts=(Object[])_fireMethod.invoke(_objectWrapper,argList.toArray());
    int portNumber=0;
    for (    Object port : outputPortList()) {
      IOPort iOPort=(IOPort)port;
      _transferOutputs(iOPort,tokensToAllOutputPorts[portNumber++]);
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
  }
 catch (  IllegalArgumentException e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
catch (  IllegalAccessException e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
catch (  InvocationTargetException e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
}","/** 
 * If this actor is opaque, transfer any data from the input ports of this composite to the ports connected on the inside, and then invoke the fire() method of its local director. The transfer is accomplished by calling the transferInputs() method of the local director (the exact behavior of which depends on the domain).  If the actor is not opaque, throw an exception. This method is read-synchronized on the workspace, so the fire() method of the director need not be (assuming it is only called from here).  After the fire() method of the director returns, send any output data created by calling the local director's transferOutputs method.
 * @exception IllegalActionException If there is no director, or ifthe director's fire() method throws it, or if the actor is not opaque.
 */
public void fire() throws IllegalActionException {
  if (_fireMethod == null) {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
    super.fire();
    return;
  }
  try {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    List<Object> argList=new LinkedList<Object>();
    Iterator<?> inputPorts=inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort port=(TypedIOPort)inputPorts.next();
      int rate=DFUtilities.getTokenConsumptionRate(port);
      Type type=((TypedIOPort)port).getType();
      Object tokenHolder=null;
      int numberOfChannels=port.getWidth() < port.getWidthInside() ? port.getWidth() : port.getWidthInside();
      if (type == BaseType.INT) {
        tokenHolder=new int[numberOfChannels][];
      }
 else       if (type == BaseType.DOUBLE) {
        tokenHolder=new double[numberOfChannels][];
      }
 else       if (type == BaseType.BOOLEAN) {
        tokenHolder=new boolean[numberOfChannels][];
      }
 else {
      }
      for (int i=0; i < port.getWidth(); i++) {
        try {
          if (i < port.getWidthInside()) {
            if (port.hasToken(i,rate)) {
              Token[] tokens=port.get(i,rate);
              if (_debugging) {
                _debug(getName(),""String_Node_Str"" + port.getName());
              }
              if (type == BaseType.INT) {
                if (rate > 1) {
                  Integer[] intTokens=new Integer[rate];
                  for (int k=0; k < rate; k++) {
                    intTokens[k]=((IntToken)tokens[k]).intValue();
                  }
                  tokenHolder=intTokens;
                }
 else {
                  tokenHolder=((IntToken)tokens[0]).intValue();
                }
              }
 else               if (type == BaseType.DOUBLE) {
                if (rate > 1) {
                  for (int k=0; k < rate; k++) {
                    Double[] doubleTokens=new Double[rate];
                    doubleTokens[k]=((DoubleToken)tokens[k]).doubleValue();
                    tokenHolder=doubleTokens;
                  }
                }
 else {
                  tokenHolder=((DoubleToken)tokens[0]).doubleValue();
                }
              }
 else               if (type == BaseType.BOOLEAN) {
                if (rate > 1) {
                  Boolean[] booleanTokens=new Boolean[rate];
                  for (int k=0; k < rate; k++) {
                    booleanTokens[k]=((BooleanToken)tokens[k]).booleanValue();
                  }
                  tokenHolder=booleanTokens;
                }
 else {
                  tokenHolder=((BooleanToken)tokens[0]).booleanValue();
                }
              }
 else {
              }
              argList.add(tokenHolder);
            }
 else {
              throw new IllegalActionException(this,port,""String_Node_Str"" + rate + ""String_Node_Str""+ ""String_Node_Str"");
            }
          }
 else {
            if (_debugging) {
              _debug(getName(),""String_Node_Str"" + port.getName());
            }
            if (port.hasToken(i)) {
              port.get(i);
            }
          }
        }
 catch (        NoTokenException ex) {
          throw new InternalErrorException(this,ex,null);
        }
      }
    }
    Object[] tokensToAllOutputPorts;
    tokensToAllOutputPorts=(Object[])_fireMethod.invoke(_objectWrapper,argList.toArray());
    int portNumber=0;
    for (    Object port : outputPortList()) {
      IOPort iOPort=(IOPort)port;
      _transferOutputs(iOPort,tokensToAllOutputPorts[portNumber++]);
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
  }
 catch (  IllegalArgumentException e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
catch (  IllegalAccessException e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
catch (  InvocationTargetException e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
}"
73990,"private void _addChoices() throws IllegalActionException {
  List<Class> solvers=getListOfSolverClass(""String_Node_Str"");
  if (solvers.size() > 0) {
    property.setExpression(solvers.get(0).getSimpleName());
  }
  for (  Class solver : solvers) {
    property.addChoice(solver.getSimpleName());
  }
  property.addChoice(""String_Node_Str"");
  PropertySolver._addActions(action);
}","private void _addChoices() throws IllegalActionException {
  _solvers.addAll(getListOfSolverClass(""String_Node_Str""));
  if (_solvers.size() > 0) {
    property.setExpression(_solvers.get(0).getSimpleName());
  }
  for (  Class solver : _solvers) {
    property.addChoice(solver.getSimpleName());
  }
  property.addChoice(""String_Node_Str"");
  PropertySolver._addActions(action);
}"
73991,"protected void _regressionTest(NamedObj namedObj,Property property) throws PropertyResolutionException {
  Property previousProperty=getPreviousProperty(namedObj);
  if (previousProperty != null) {
    try {
      PropertyAttribute attribute=_getPropertyAttribute(namedObj);
      _updatePropertyAttribute(attribute,previousProperty);
    }
 catch (    IllegalActionException ex) {
      throw new PropertyResolutionException(this,ex);
    }
  }
  if ((previousProperty == null && property != null) || (previousProperty != null && !previousProperty.equals(property))) {
    addErrors(_eol + ""String_Node_Str"" + getUseCaseName()+ ""String_Node_Str""+ namedObj.getFullName()+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ previousProperty+ ""String_Node_Str""+ property+ ""String_Node_Str"");
  }
}","protected void _regressionTest(NamedObj namedObj,Property property) throws PropertyResolutionException {
  Property previousProperty=getPreviousProperty(namedObj);
  if (previousProperty != null) {
    try {
      PropertyAttribute attribute=_getPropertyAttribute(namedObj);
      _updatePropertyAttribute(attribute,previousProperty);
    }
 catch (    IllegalActionException ex) {
      throw new PropertyResolutionException(this,ex);
    }
  }
  if ((previousProperty == null && property != null) || (previousProperty != null && !previousProperty.toString().equals(property.toString()))) {
    addErrors(_eol + ""String_Node_Str"" + getUseCaseName()+ ""String_Node_Str""+ namedObj.getFullName()+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ previousProperty+ ""String_Node_Str""+ property+ ""String_Node_Str"");
  }
}"
73992,"/** 
 * Return a list of enabled transitions among the given list of transitions. This includes all transitions whose guards can can be evaluated and evaluate to true, plus, if all guards can be evaluated and evaluate to false, all default transitions.
 * @param transitionList A list of transitions.
 * @return A list of enabled transition.
 * @exception IllegalActionException If the guard expression of anytransition can not be evaluated.
 */
public List enabledTransitions(List transitionList) throws IllegalActionException {
  LinkedList enabledTransitions=new LinkedList();
  LinkedList defaultTransitions=new LinkedList();
  Iterator transitionRelations=transitionList.iterator();
  boolean foundUnknown=false;
  while (transitionRelations.hasNext() && !_stopRequested) {
    Transition transition=(Transition)transitionRelations.next();
    if (transition.isDefault()) {
      defaultTransitions.add(transition);
    }
 else {
      foundUnknown=foundUnknown || !_referencedInputPortsByGuardKnown(transition);
      try {
        if (transition.isEnabled()) {
          enabledTransitions.add(transition);
        }
      }
 catch (      RuntimeException ex) {
        if (!foundUnknown) {
          throw ex;
        }
      }
catch (      IllegalActionException ex) {
        if (!foundUnknown) {
          throw ex;
        }
      }
    }
  }
  if (enabledTransitions.size() > 0) {
    return enabledTransitions;
  }
 else {
    if (!foundUnknown) {
      if (defaultTransitions.size() == 0 && _currentState.getRefinement() == null) {
        List<IOPort> outputs=outputPortList();
        for (        IOPort port : outputs) {
          for (int channel=0; channel < port.getWidth(); channel++) {
            if (!port.isKnown(channel)) {
              port.sendClear(channel);
            }
          }
        }
      }
      return defaultTransitions;
    }
  }
  return new LinkedList();
}","/** 
 * Return a list of enabled transitions among the given list of transitions. This includes all transitions whose guards can can be evaluated and evaluate to true, plus, if all guards can be evaluated and evaluate to false, all default transitions.
 * @param transitionList A list of transitions.
 * @return A list of enabled transition.
 * @exception IllegalActionException If the guard expression of anytransition can not be evaluated.
 */
public List enabledTransitions(List transitionList) throws IllegalActionException {
  LinkedList enabledTransitions=new LinkedList();
  LinkedList defaultTransitions=new LinkedList();
  Iterator transitionRelations=transitionList.iterator();
  boolean foundUnknown=false;
  while (transitionRelations.hasNext() && !_stopRequested) {
    Transition transition=(Transition)transitionRelations.next();
    if (transition.isDefault()) {
      if (transition.isEnabled()) {
        defaultTransitions.add(transition);
      }
    }
 else {
      foundUnknown=foundUnknown || !_referencedInputPortsByGuardKnown(transition);
      try {
        if (transition.isEnabled()) {
          enabledTransitions.add(transition);
        }
      }
 catch (      RuntimeException ex) {
        if (!foundUnknown) {
          throw ex;
        }
      }
catch (      IllegalActionException ex) {
        if (!foundUnknown) {
          throw ex;
        }
      }
    }
  }
  if (enabledTransitions.size() > 0) {
    return enabledTransitions;
  }
 else {
    if (!foundUnknown) {
      if (defaultTransitions.size() == 0 && _currentState.getRefinement() == null) {
        List<IOPort> outputs=outputPortList();
        for (        IOPort port : outputs) {
          for (int channel=0; channel < port.getWidth(); channel++) {
            if (!port.isKnown(channel)) {
              port.sendClear(channel);
            }
          }
        }
      }
      return defaultTransitions;
    }
  }
  return new LinkedList();
}"
73993,"/** 
 * Return an enabled transition among the given list of transitions for which both the guard expression and the output actions can be evaluated (the inputs referred by these are known). If there is only one transition enabled, return that transition. In case there are multiple enabled transitions, if any of them is not nondeterministic, throw an exception. See   {@link Transition}for the explanation of ""nondeterministic"". Otherwise, randomly choose one from the enabled transitions and return it if the output actions can be evaluated. Execute the output actions contained by the returned transition before returning.
 * @param transitionList A list of transitions.
 * @return An enabled transition, or null if none is enabled.
 * @exception IllegalActionException If there is more than onetransition enabled and not all of them are nondeterministic.
 */
public Transition chooseTransition(List transitionList) throws IllegalActionException {
  List<Transition> enabledTransitions=enabledTransitions(transitionList);
  int length=enabledTransitions.size();
  if (length > 1) {
    for (    Transition enabledTransition : enabledTransitions) {
      if (!enabledTransition.isNondeterministic()) {
        throw new MultipleEnabledTransitionsException(currentState(),""String_Node_Str"" + ""String_Node_Str"" + enabledTransition.getName() + ""String_Node_Str"");
      }
    }
  }
  if (_lastChosenTransition != null) {
    if (!enabledTransitions.contains(_lastChosenTransition)) {
      throw new IllegalActionException(this,_lastChosenTransition,""String_Node_Str"" + ""String_Node_Str"");
    }
    return _lastChosenTransition;
  }
  Transition result=null;
  if (length == 1) {
    result=(Transition)enabledTransitions.get(0);
  }
 else   if (length > 1) {
    while (enabledTransitions.size() > 0) {
      int randomChoice=(int)Math.floor(Math.random() * length);
      if (randomChoice == length) {
        randomChoice--;
      }
      result=(Transition)enabledTransitions.get(randomChoice);
      if (_referencedInputPortsByOutputKnown(result)) {
        break;
      }
 else {
        enabledTransitions.remove(result);
        result=null;
      }
    }
  }
  if (result != null) {
    if (_debugging) {
      _debug(""String_Node_Str"",result.getFullName());
    }
    Iterator actions=result.choiceActionList().iterator();
    while (actions.hasNext()) {
      Action action=(Action)actions.next();
      action.execute();
    }
    if (_currentState.getRefinement() == null) {
      List<IOPort> outputs=outputPortList();
      for (      IOPort port : outputs) {
        for (int channel=0; channel < port.getWidth(); channel++) {
          if (!port.isKnown(channel)) {
            port.sendClear(channel);
          }
        }
      }
    }
  }
  _lastChosenTransition=result;
  return result;
}","/** 
 * Return an enabled transition among the given list of transitions for which both the guard expression and the output actions can be evaluated (the inputs referred by these are known). If there is only one transition enabled, return that transition. In case there are multiple enabled transitions, if any of them is not nondeterministic, throw an exception. See   {@link Transition}for the explanation of ""nondeterministic"". Otherwise, randomly choose one from the enabled transitions and return it if the output actions can be evaluated. Execute the output actions contained by the returned transition before returning.
 * @param transitionList A list of transitions.
 * @return An enabled transition, or null if none is enabled.
 * @exception IllegalActionException If there is more than onetransition enabled and not all of them are nondeterministic.
 */
public Transition chooseTransition(List transitionList) throws IllegalActionException {
  List<Transition> enabledTransitions=enabledTransitions(transitionList);
  int length=enabledTransitions.size();
  if (length > 1) {
    for (    Transition enabledTransition : enabledTransitions) {
      if (!enabledTransition.isNondeterministic()) {
        throw new MultipleEnabledTransitionsException(currentState(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + enabledTransition.getName() + ""String_Node_Str"");
      }
    }
  }
  if (_lastChosenTransition != null) {
    if (!enabledTransitions.contains(_lastChosenTransition)) {
      throw new IllegalActionException(this,_lastChosenTransition,""String_Node_Str"" + ""String_Node_Str"");
    }
    return _lastChosenTransition;
  }
  Transition result=null;
  if (length == 1) {
    result=(Transition)enabledTransitions.get(0);
  }
 else   if (length > 1) {
    while (enabledTransitions.size() > 0) {
      int randomChoice=(int)Math.floor(Math.random() * length);
      if (randomChoice == length) {
        randomChoice--;
      }
      result=(Transition)enabledTransitions.get(randomChoice);
      if (_referencedInputPortsByOutputKnown(result)) {
        break;
      }
 else {
        enabledTransitions.remove(result);
        result=null;
      }
    }
  }
  if (result != null) {
    if (_debugging) {
      _debug(""String_Node_Str"",result.getFullName());
    }
    Iterator actions=result.choiceActionList().iterator();
    while (actions.hasNext()) {
      Action action=(Action)actions.next();
      action.execute();
    }
    if (_currentState.getRefinement() == null) {
      List<IOPort> outputs=outputPortList();
      for (      IOPort port : outputs) {
        for (int channel=0; channel < port.getWidth(); channel++) {
          if (!port.isKnown(channel)) {
            port.sendClear(channel);
          }
        }
      }
    }
  }
  _lastChosenTransition=result;
  return result;
}"
73994,"/** 
 * Prefire method when the enclosing director is not an instance of this same class.
 * @return True if it is OK to fire.
 */
private boolean _prefireWithEnclosingNonContinuousDirector() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  Time outTime=executiveDirector.getModelTime();
  int localTimeExceedsOutsideTime=_currentTime.compareTo(outTime);
  if (localTimeExceedsOutsideTime > 0) {
    if (!_commitIsPending) {
      throw new IllegalActionException(this,""String_Node_Str"" + container.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ outTime+ ""String_Node_Str""+ _currentTime);
    }
    _currentStepSize=outTime.subtract(_iterationBeginTime).getDoubleValue();
    if (_currentStepSize < 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + _iterationBeginTime + ""String_Node_Str""+ outTime+ ""String_Node_Str"");
    }
    rollBackToCommittedState();
    _commitIsPending=false;
    _redoingSolverIteration=true;
  }
 else   if (localTimeExceedsOutsideTime == 0 && _commitIsPending) {
    _currentStepSize=0.0;
    if (executiveDirector instanceof SuperdenseTimeDirector) {
      _index=((SuperdenseTimeDirector)executiveDirector).getIndex();
    }
    return true;
  }
 else   if (localTimeExceedsOutsideTime < 0) {
    if (_commitIsPending) {
      _commitIsPending=false;
      rollBackToCommittedState();
    }
    _currentTime=outTime;
    if (_debugging) {
      _debug(""String_Node_Str"" + _currentTime + ""String_Node_Str"");
    }
    _currentStepSize=0.0;
  }
 else {
    Time environmentNextIterationTime=executiveDirector.getModelNextIterationTime();
    Time localTargetTime=_iterationBeginTime.add(_currentStepSize);
    if (environmentNextIterationTime.compareTo(localTargetTime) < 0) {
      _currentStepSize=environmentNextIterationTime.subtract(_currentTime).getDoubleValue();
      if (_debugging) {
        _debug(""String_Node_Str"" + _currentStepSize);
      }
    }
    if (executiveDirector instanceof SuperdenseTimeDirector) {
      _index=((SuperdenseTimeDirector)executiveDirector).getIndex();
    }
  }
  if (!_breakpoints.isEmpty()) {
    SuperdenseTime nextBreakpoint=(SuperdenseTime)_breakpoints.first();
    Time breakpointTime=nextBreakpoint.timestamp();
    localTimeExceedsOutsideTime=breakpointTime.compareTo(_currentTime);
    while (localTimeExceedsOutsideTime < 0 || (localTimeExceedsOutsideTime == 0 && nextBreakpoint.index() < _index)) {
      if (_debugging) {
        _debug(""String_Node_Str"" + breakpointTime);
      }
      _fireAtSkipped(breakpointTime);
      _breakpoints.removeFirst();
      if (_breakpoints.isEmpty()) {
        break;
      }
      nextBreakpoint=(SuperdenseTime)_breakpoints.first();
      breakpointTime=nextBreakpoint.timestamp();
      localTimeExceedsOutsideTime=breakpointTime.compareTo(_currentTime);
    }
    if (localTimeExceedsOutsideTime == 0 && nextBreakpoint.index() == _index) {
      if (_debugging) {
        _debug(""String_Node_Str"" + nextBreakpoint + ""String_Node_Str"");
      }
      _breakpoints.removeFirst();
    }
  }
  _synchronizeToRealTime();
  _postfireReturns=true;
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return true;
}","/** 
 * Prefire method when the enclosing director is not an instance of this same class.
 * @return True if it is OK to fire.
 */
private boolean _prefireWithEnclosingNonContinuousDirector() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  Time outTime=executiveDirector.getModelTime();
  int localTimeExceedsOutsideTime=_currentTime.compareTo(outTime);
  if (localTimeExceedsOutsideTime > 0) {
    if (!_commitIsPending) {
      throw new IllegalActionException(this,""String_Node_Str"" + container.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ outTime+ ""String_Node_Str""+ _currentTime);
    }
    _currentStepSize=outTime.subtract(_iterationBeginTime).getDoubleValue();
    if (_currentStepSize < 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + _iterationBeginTime + ""String_Node_Str""+ outTime+ ""String_Node_Str"");
    }
    rollBackToCommittedState();
    _commitIsPending=false;
    if (_currentStepSize != 0.0) {
      _redoingSolverIteration=true;
    }
  }
 else   if (localTimeExceedsOutsideTime == 0 && _commitIsPending) {
    _currentStepSize=0.0;
    if (executiveDirector instanceof SuperdenseTimeDirector) {
      _index=((SuperdenseTimeDirector)executiveDirector).getIndex();
    }
    return true;
  }
 else   if (localTimeExceedsOutsideTime < 0) {
    if (_commitIsPending) {
      _commitIsPending=false;
      rollBackToCommittedState();
    }
    _currentTime=outTime;
    if (_debugging) {
      _debug(""String_Node_Str"" + _currentTime + ""String_Node_Str"");
    }
    _currentStepSize=0.0;
  }
 else {
    Time environmentNextIterationTime=executiveDirector.getModelNextIterationTime();
    Time localTargetTime=_iterationBeginTime.add(_currentStepSize);
    if (environmentNextIterationTime.compareTo(localTargetTime) < 0) {
      _currentStepSize=environmentNextIterationTime.subtract(_currentTime).getDoubleValue();
      if (_debugging) {
        _debug(""String_Node_Str"" + _currentStepSize);
      }
    }
    if (executiveDirector instanceof SuperdenseTimeDirector) {
      _index=((SuperdenseTimeDirector)executiveDirector).getIndex();
    }
  }
  if (!_breakpoints.isEmpty()) {
    SuperdenseTime nextBreakpoint=(SuperdenseTime)_breakpoints.first();
    Time breakpointTime=nextBreakpoint.timestamp();
    localTimeExceedsOutsideTime=breakpointTime.compareTo(_currentTime);
    while (localTimeExceedsOutsideTime < 0 || (localTimeExceedsOutsideTime == 0 && nextBreakpoint.index() < _index)) {
      if (_debugging) {
        _debug(""String_Node_Str"" + breakpointTime);
      }
      _fireAtSkipped(breakpointTime);
      _breakpoints.removeFirst();
      if (_breakpoints.isEmpty()) {
        break;
      }
      nextBreakpoint=(SuperdenseTime)_breakpoints.first();
      breakpointTime=nextBreakpoint.timestamp();
      localTimeExceedsOutsideTime=breakpointTime.compareTo(_currentTime);
    }
    if (localTimeExceedsOutsideTime == 0 && nextBreakpoint.index() == _index) {
      if (_debugging) {
        _debug(""String_Node_Str"" + nextBreakpoint + ""String_Node_Str"");
      }
      _breakpoints.removeFirst();
    }
  }
  _synchronizeToRealTime();
  _postfireReturns=true;
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return true;
}"
73995,"/** 
 * Read and display the input, then wait for user input and produce the user data on the output. If the user input is ""quit"" or ""exit"", then set a flag that causes postfire() to return false.
 * @exception IllegalActionException If producing the outputcauses an exception.
 */
public void fire() throws IllegalActionException {
  super.fire();
  prompt.update();
  shell.mainPrompt=((StringToken)prompt.getToken()).stringValue();
  if ((input.numberOfSources() > 0) && input.hasToken(0)) {
    String value=((StringToken)input.get(0)).stringValue();
    if (_firstTime) {
      _firstTime=false;
      shell.initialize(value);
    }
 else {
      shell.returnResult(value);
    }
  }
  shell.setEditable(true);
  String userCommand=getOutput();
  if (userCommand.trim().equalsIgnoreCase(""String_Node_Str"") || userCommand.trim().equalsIgnoreCase(""String_Node_Str"")) {
    _returnFalseInPostfire=true;
  }
  output.broadcast(new StringToken(userCommand));
}","/** 
 * Read and display the input, then wait for user input and produce the user data on the output. If the user input is ""quit"" or ""exit"", then set a flag that causes postfire() to return false.
 * @exception IllegalActionException If producing the outputcauses an exception.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (shell == null) {
    return;
  }
  prompt.update();
  shell.mainPrompt=((StringToken)prompt.getToken()).stringValue();
  String value=""String_Node_Str"";
  if ((input.numberOfSources() > 0) && input.hasToken(0)) {
    value=((StringToken)input.get(0)).stringValue();
  }
  if (_firstTime) {
    _firstTime=false;
    shell.initialize(value);
  }
 else {
    shell.returnResult(value);
  }
  Runnable doSetEditable=new Runnable(){
    public void run(){
      shell.setEditable(true);
    }
  }
;
  SwingUtilities.invokeLater(doSetEditable);
  String userCommand=getOutput();
  if (userCommand.trim().equalsIgnoreCase(""String_Node_Str"") || userCommand.trim().equalsIgnoreCase(""String_Node_Str"")) {
    _returnFalseInPostfire=true;
  }
  output.broadcast(new StringToken(userCommand));
}"
73996,"/** 
 * Generate fire code. The method generates code that loops through each input [multi-ports] and combines (add or subtract) them.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
@Override protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.AddSubtract actor=(ptolemy.actor.lib.AddSubtract)getComponent();
  String outputType=getCodeGenerator().codeGenType(actor.output.getType());
  String plusType=getCodeGenerator().codeGenType(actor.plus.getType());
  String minusType=getCodeGenerator().codeGenType(actor.minus.getType());
  boolean minusOnly=!actor.plus.isOutsideConnected();
  ArrayList<String> args=new ArrayList<String>();
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.appendCodeBlock(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(outputType);
  args.add(plusType);
  for (int i=1; i < actor.plus.getWidth(); i++) {
    args.set(0,Integer.valueOf(i).toString());
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
  for (int i=minusOnly ? 1 : 0; i < actor.minus.getWidth(); i++) {
    args.set(0,Integer.valueOf(i).toString());
    args.set(2,minusType);
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
  if (actor.output.isOutsideConnected() && actor.output.numberOfSinks() > 0) {
    codeStream.appendCodeBlock(""String_Node_Str"");
  }
  return processCode(codeStream.toString());
}","/** 
 * Generate fire code. The method generates code that loops through each input [multi-ports] and combines (add or subtract) them.
 * @return The generated code.
 * @exception IllegalActionException If the code stream encounters anerror in processing the specified code block(s).
 */
@Override protected String _generateFireCode() throws IllegalActionException {
  super._generateFireCode();
  ptolemy.actor.lib.AddSubtract actor=(ptolemy.actor.lib.AddSubtract)getComponent();
  String outputType=getCodeGenerator().codeGenType(actor.output.getType());
  String plusType=getCodeGenerator().codeGenType(actor.plus.getType());
  String minusType=getCodeGenerator().codeGenType(actor.minus.getType());
  ArrayList<String> args=new ArrayList<String>();
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.appendCodeBlock(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(outputType);
  args.add(plusType);
  for (int i=0; i < actor.plus.getWidth(); i++) {
    args.set(0,Integer.valueOf(i).toString());
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
  for (int i=0; i < actor.minus.getWidth(); i++) {
    args.set(0,Integer.valueOf(i).toString());
    args.set(2,minusType);
    codeStream.appendCodeBlock(""String_Node_Str"",args);
  }
  if (actor.output.isOutsideConnected() && actor.output.numberOfSinks() > 0) {
    codeStream.appendCodeBlock(""String_Node_Str"");
  }
  return processCode(codeStream.toString());
}"
73997,"/** 
 * Sign a jar file.
 */
private static void _signJarFile(String jarFileName,String signedJarFileName) throws Exception {
  String keystoreFileName=StringUtilities.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"";
  String storePassword=""String_Node_Str"";
  String keyPassword=""String_Node_Str"";
  String alias=""String_Node_Str"";
  String keystorePropertiesFileName=StringUtilities.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"";
  Properties properties=new Properties();
  try {
    properties.load(new FileInputStream(keystorePropertiesFileName));
    storePassword=properties.getProperty(""String_Node_Str"");
    keyPassword=properties.getProperty(""String_Node_Str"");
    alias=properties.getProperty(""String_Node_Str"");
  }
 catch (  IOException ex) {
    System.out.println(""String_Node_Str"" + keystorePropertiesFileName + ""String_Node_Str""+ ex);
  }
  System.out.println(""String_Node_Str"" + jarFileName + ""String_Node_Str""+ signedJarFileName+ ""String_Node_Str"");
  File signedJarFile=new File(signedJarFileName);
  File parent=signedJarFile.getParentFile();
  if (parent != null) {
    if (!parent.mkdirs()) {
      if (!parent.isDirectory()) {
        throw new IOException(""String_Node_Str"" + signedJarFileName + ""String_Node_Str"");
      }
    }
  }
  JarSigner.sign(jarFileName,signedJarFileName,keystoreFileName,alias,storePassword.toCharArray(),keyPassword.toCharArray());
}","/** 
 * Sign a jar file.
 */
private static void _signJarFile(String jarFileName,String signedJarFileName) throws Exception {
  String keystoreFileName=StringUtilities.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"";
  String storePassword=""String_Node_Str"";
  String keyPassword=""String_Node_Str"";
  String alias=""String_Node_Str"";
  String keystorePropertiesFileName=StringUtilities.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"";
  Properties properties=new Properties();
  try {
    FileInputStream fileInputStream=null;
    try {
      fileInputStream=new FileInputStream(keystorePropertiesFileName);
      properties.load(fileInputStream);
      storePassword=properties.getProperty(""String_Node_Str"");
      keyPassword=properties.getProperty(""String_Node_Str"");
      alias=properties.getProperty(""String_Node_Str"");
    }
  finally {
      if (fileInputStream != null) {
        fileInputStream.close();
      }
    }
  }
 catch (  IOException ex) {
    System.out.println(""String_Node_Str"" + keystorePropertiesFileName + ""String_Node_Str""+ ex);
  }
  System.out.println(""String_Node_Str"" + jarFileName + ""String_Node_Str""+ signedJarFileName+ ""String_Node_Str"");
  File signedJarFile=new File(signedJarFileName);
  File parent=signedJarFile.getParentFile();
  if (parent != null) {
    if (!parent.mkdirs()) {
      if (!parent.isDirectory()) {
        throw new IOException(""String_Node_Str"" + signedJarFileName + ""String_Node_Str"");
      }
    }
  }
  JarSigner.sign(jarFileName,signedJarFileName,keystoreFileName,alias,storePassword.toCharArray(),keyPassword.toCharArray());
}"
73998,"public Component getComponent() throws Exception {
  ComponentBuilder builder=(ComponentBuilder)typeCombo.getSelectedItem();
  Component instance=builder.getInstance(controlProperties);
  return instance;
}","public Component getComponent(){
  return component;
}"
73999,"/** 
 * Return true if this is a 32bit JVM.
 * @return true if this is a 32bit JVM.
 */
static boolean _is32Bit(){
  String dataModelProperty=StringUtilities.getProperty(""String_Node_Str"");
  boolean result=true;
  if (dataModelProperty.indexOf(""String_Node_Str"") != -1) {
    return false;
  }
 else {
    String javaVmNameProperty=StringUtilities.getProperty(""String_Node_Str"");
    if (javaVmNameProperty.indexOf(""String_Node_Str"") != -1) {
      return false;
    }
  }
  return true;
}","/** 
 * Return true if this is a 32bit JVM.
 * @return true if this is a 32bit JVM.
 */
static boolean _is32Bit(){
  String dataModelProperty=StringUtilities.getProperty(""String_Node_Str"");
  if (dataModelProperty.indexOf(""String_Node_Str"") != -1) {
    return false;
  }
 else {
    String javaVmNameProperty=StringUtilities.getProperty(""String_Node_Str"");
    if (javaVmNameProperty.indexOf(""String_Node_Str"") != -1) {
      return false;
    }
  }
  return true;
}"
74000,"/** 
 * Get the name of the set checkpoint method.
 * @param isAnonymous Whether the current class is an anonymous class.
 * @return The name of the set checkoint method.
 */
private String _getSetCheckpointMethodName(boolean isAnonymous){
  return SET_CHECKPOINT_NAME + (isAnonymous ? ""String_Node_Str"" : ""String_Node_Str"");
}","/** 
 * Get the name of the set checkpoint method.
 * @param isAnonymous Whether the current class is an anonymous class.
 * @return The name of the set checkpoint method.
 */
private String _getSetCheckpointMethodName(boolean isAnonymous){
  return SET_CHECKPOINT_NAME + (isAnonymous ? ""String_Node_Str"" : ""String_Node_Str"");
}"
