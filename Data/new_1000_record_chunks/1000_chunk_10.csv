record_number,buggy_code,fixed_code
9001,"@Override public boolean isDirectory() throws IOException {
  return getKind().equals(SVNNodeKind.DIR);
}","@Override public boolean isDirectory(){
  return getKind().equals(SVNNodeKind.DIR);
}"
9002,"private ClientInfo exchangeCapabilities(SvnServerParser parser,SvnServerWriter writer) throws IOException, SVNException {
  writer.listBegin().word(""String_Node_Str"").listBegin().number(2).number(2).listBegin().listEnd().listBegin().word(""String_Node_Str"").word(""String_Node_Str"").word(""String_Node_Str"").word(""String_Node_Str"").listEnd().listEnd().listEnd();
  final ClientInfo clientInfo=MessageParser.parse(ClientInfo.class,parser);
  if (clientInfo.getProtocolVersion() != 2) {
    throw new SVNException(SVNErrorMessage.create(SVNErrorCode.VERSION_MISMATCH,""String_Node_Str"" + clientInfo.getProtocolVersion() + ""String_Node_Str""));
  }
  return clientInfo;
}","private ClientInfo exchangeCapabilities(SvnServerParser parser,SvnServerWriter writer) throws IOException, SVNException {
  writer.listBegin().word(""String_Node_Str"").listBegin().number(2).number(2).listBegin().listEnd().listBegin().word(""String_Node_Str"").word(""String_Node_Str"").word(""String_Node_Str"").word(""String_Node_Str"").word(""String_Node_Str"").listEnd().listEnd().listEnd();
  final ClientInfo clientInfo=MessageParser.parse(ClientInfo.class,parser);
  if (clientInfo.getProtocolVersion() != 2) {
    throw new SVNException(SVNErrorMessage.create(SVNErrorCode.VERSION_MISMATCH,""String_Node_Str"" + clientInfo.getProtocolVersion() + ""String_Node_Str""));
  }
  return clientInfo;
}"
9003,"private void updateEntry(@NotNull SessionContext context,@NotNull String wcPath,@Nullable VcsFile oldFile,@Nullable VcsFile newFile,@NotNull String parentTokenId,boolean rootDir) throws IOException, SVNException {
  if (oldFile != null)   if (newFile == null || !oldFile.getKind().equals(newFile.getKind()))   removeEntry(context,wcPath,oldFile.getLastChange().getId(),parentTokenId);
  if (newFile == null)   return;
  if (newFile.isDirectory())   updateDir(context,wcPath,oldFile,newFile,parentTokenId,rootDir);
 else   updateFile(context,wcPath,oldFile,newFile,parentTokenId);
}","private void updateEntry(@NotNull SessionContext context,@NotNull String wcPath,@Nullable VcsFile oldFile,@Nullable VcsFile newFile,@NotNull String parentTokenId,boolean rootDir,@NotNull Depth wcDepth,@NotNull Depth requestedDepth) throws IOException, SVNException {
  if (oldFile != null)   if (newFile == null || !oldFile.getKind().equals(newFile.getKind()))   removeEntry(context,wcPath,oldFile.getLastChange().getId(),parentTokenId);
  if (newFile == null)   return;
  if (newFile.isDirectory())   updateDir(context,wcPath,oldFile,newFile,parentTokenId,rootDir,wcDepth,requestedDepth);
 else   updateFile(context,wcPath,oldFile,newFile,parentTokenId);
}"
9004,"protected void sendResponse(@NotNull SessionContext context,@NotNull String path,int rev) throws IOException, SVNException {
  final SvnServerWriter writer=context.getWriter();
  writer.listBegin().word(""String_Node_Str"").listBegin().number(rev).listEnd().listEnd();
  final String tokenId=createTokenId();
  final SetPathParams rootParams=paths.get(wcPath(""String_Node_Str""));
  int rootRev=rootParams == null ? rev : rootParams.rev;
  writer.listBegin().word(""String_Node_Str"").listBegin().listBegin().number(rootRev).listEnd().string(tokenId).listEnd().listEnd();
  final String fullPath=context.getRepositoryPath(path);
  final String targetPath=params.getTargetPath();
  final VcsFile newFile=context.getFile(rev,targetPath == null ? fullPath : targetPath);
  final VcsFile oldFile=getPrevFile(context,path,context.getFile(rootRev,fullPath));
  updateEntry(context,path,oldFile,newFile,tokenId,path.isEmpty());
  writer.listBegin().word(""String_Node_Str"").listBegin().string(tokenId).listEnd().listEnd();
  writer.listBegin().word(""String_Node_Str"").listBegin().listEnd().listEnd();
  final SvnServerParser parser=context.getParser();
  parser.readToken(ListBeginToken.class);
  if (!""String_Node_Str"".equals(parser.readText())) {
    parser.readToken(ListBeginToken.class);
    parser.readToken(ListBeginToken.class);
    final int errorCode=parser.readNumber();
    final String errorMessage=parser.readText();
    parser.skipItems();
    parser.readToken(ListEndToken.class);
    parser.readToken(ListEndToken.class);
    log.error(""String_Node_Str"",errorCode,errorMessage);
    throw new EOFException(errorMessage);
  }
 else {
    parser.skipItems();
    writer.listBegin().word(""String_Node_Str"").listBegin().listEnd().listEnd();
  }
}","protected void sendResponse(@NotNull SessionContext context,@NotNull String path,int rev) throws IOException, SVNException {
  final SetPathParams rootParams=paths.get(wcPath(""String_Node_Str""));
  if (rootParams == null)   throw new SVNException(SVNErrorMessage.create(SVNErrorCode.STREAM_MALFORMED_DATA));
  final SvnServerWriter writer=context.getWriter();
  writer.listBegin().word(""String_Node_Str"").listBegin().number(rev).listEnd().listEnd();
  final String tokenId=createTokenId();
  final int rootRev=rootParams.rev;
  writer.listBegin().word(""String_Node_Str"").listBegin().listBegin().number(rootRev).listEnd().string(tokenId).listEnd().listEnd();
  final String fullPath=context.getRepositoryPath(path);
  final String targetPath=params.getTargetPath();
  final VcsFile newFile=context.getFile(rev,targetPath == null ? fullPath : targetPath);
  final VcsFile oldFile=getPrevFile(context,path,context.getFile(rootRev,fullPath));
  updateEntry(context,path,oldFile,newFile,tokenId,path.isEmpty(),rootParams.depth,params.getDepth());
  writer.listBegin().word(""String_Node_Str"").listBegin().string(tokenId).listEnd().listEnd();
  writer.listBegin().word(""String_Node_Str"").listBegin().listEnd().listEnd();
  final SvnServerParser parser=context.getParser();
  parser.readToken(ListBeginToken.class);
  if (!""String_Node_Str"".equals(parser.readText())) {
    parser.readToken(ListBeginToken.class);
    parser.readToken(ListBeginToken.class);
    final int errorCode=parser.readNumber();
    final String errorMessage=parser.readText();
    parser.skipItems();
    parser.readToken(ListEndToken.class);
    parser.readToken(ListEndToken.class);
    log.error(""String_Node_Str"",errorCode,errorMessage);
    throw new EOFException(errorMessage);
  }
 else {
    parser.skipItems();
    writer.listBegin().word(""String_Node_Str"").listBegin().listEnd().listEnd();
  }
}"
9005,"private void setPathReport(@NotNull SessionContext context,@NotNull SetPathParams args){
  context.push(this::reportCommand);
  final String wcPath=wcPath(args.path);
  forcePath(wcPath);
  paths.put(wcPath,args);
}","private void setPathReport(@NotNull SessionContext context,@NotNull SetPathParams args) throws SVNException {
  context.push(this::reportCommand);
  final String wcPath=wcPath(args.path);
  final SetPathParams prev=paths.putIfAbsent(wcPath,args);
  if (prev != null)   throw new SVNException(SVNErrorMessage.create(SVNErrorCode.UNKNOWN,""String_Node_Str"" + args.path));
  forcePath(wcPath);
}"
9006,"private void updateDir(@NotNull SessionContext context,@NotNull String wcPath,@Nullable VcsFile oldFile,@NotNull VcsFile newFile,@NotNull String parentTokenId,boolean rootDir) throws IOException, SVNException {
  final SvnServerWriter writer=context.getWriter();
  final String tokenId;
  if (rootDir) {
    tokenId=parentTokenId;
  }
 else {
    tokenId=createTokenId();
    if (oldFile == null) {
      sendStartEntry(writer,""String_Node_Str"",wcPath,parentTokenId,tokenId,null);
    }
 else {
      sendStartEntry(writer,""String_Node_Str"",wcPath,parentTokenId,tokenId,oldFile.getLastChange().getId());
    }
  }
  updateProps(writer,""String_Node_Str"",tokenId,oldFile,newFile);
  final Map<String,VcsFile> oldEntries;
  if (oldFile != null) {
    oldEntries=new HashMap<>();
    for (    VcsFile entry : oldFile.getEntries()) {
      oldEntries.put(entry.getFileName(),entry);
    }
  }
 else {
    oldEntries=Collections.emptyMap();
  }
  final Set<String> forced=new HashSet<>(forcedPaths.getOrDefault(wcPath,Collections.emptySet()));
  for (  VcsFile newEntry : newFile.getEntries()) {
    final String entryPath=joinPath(wcPath,newEntry.getFileName());
    final VcsFile oldEntry=getPrevFile(context,entryPath,oldEntries.remove(newEntry.getFileName()));
    if (!forced.remove(entryPath)) {
      if (newEntry.equals(oldEntry)) {
        continue;
      }
    }
    updateEntry(context,entryPath,oldEntry,newEntry,tokenId,false);
  }
  for (  VcsFile entry : oldEntries.values()) {
    final String entryPath=joinPath(wcPath,entry.getFileName());
    removeEntry(context,entryPath,entry.getLastChange().getId(),tokenId);
    forced.remove(entryPath);
  }
  for (  String removed : forced) {
    removeEntry(context,removed,newFile.getLastChange().getId(),tokenId);
  }
  if (!rootDir) {
    writer.listBegin().word(""String_Node_Str"").listBegin().string(tokenId).listEnd().listEnd();
  }
}","private void updateDir(@NotNull SessionContext context,@NotNull String wcPath,@Nullable VcsFile oldFile,@NotNull VcsFile newFile,@NotNull String parentTokenId,boolean rootDir,@NotNull Depth wcDepth,@NotNull Depth requestedDepth) throws IOException, SVNException {
  final SvnServerWriter writer=context.getWriter();
  final String tokenId;
  if (rootDir) {
    tokenId=parentTokenId;
  }
 else {
    tokenId=createTokenId();
    if (oldFile == null) {
      sendStartEntry(writer,""String_Node_Str"",wcPath,parentTokenId,tokenId,null);
    }
 else {
      sendStartEntry(writer,""String_Node_Str"",wcPath,parentTokenId,tokenId,oldFile.getLastChange().getId());
    }
  }
  updateProps(writer,""String_Node_Str"",tokenId,oldFile,newFile);
  final Depth.Action dirAction=wcDepth.determineAction(requestedDepth,true);
  final Depth.Action fileAction=wcDepth.determineAction(requestedDepth,false);
  final Map<String,VcsFile> oldEntries;
  if (oldFile != null) {
    oldEntries=new HashMap<>();
    for (    VcsFile entry : oldFile.getEntries()) {
      oldEntries.put(entry.getFileName(),entry);
    }
  }
 else {
    oldEntries=Collections.emptyMap();
  }
  final Set<String> forced=new HashSet<>(forcedPaths.getOrDefault(wcPath,Collections.emptySet()));
  for (  VcsFile newEntry : newFile.getEntries()) {
    final String entryPath=joinPath(wcPath,newEntry.getFileName());
    final VcsFile oldEntry=getPrevFile(context,entryPath,oldEntries.remove(newEntry.getFileName()));
    final Depth.Action action=newEntry.isDirectory() ? dirAction : fileAction;
    if (!forced.remove(entryPath) && newEntry.equals(oldEntry) && action == Depth.Action.Normal)     continue;
    if (action == Depth.Action.Skip)     continue;
    final Depth entryDepth=getWcDepth(entryPath,wcDepth);
    updateEntry(context,entryPath,action == Depth.Action.Upgrade ? null : oldEntry,newEntry,tokenId,false,entryDepth,requestedDepth.deepen());
  }
  for (  VcsFile entry : oldEntries.values()) {
    final String entryPath=joinPath(wcPath,entry.getFileName());
    removeEntry(context,entryPath,entry.getLastChange().getId(),tokenId);
    forced.remove(entryPath);
  }
  for (  String removed : forced) {
    removeEntry(context,removed,newFile.getLastChange().getId(),tokenId);
  }
  if (!rootDir) {
    writer.listBegin().word(""String_Node_Str"").listBegin().string(tokenId).listEnd().listEnd();
  }
}"
9007,"@Nullable private VcsFile getPrevFile(@NotNull SessionContext context,@NotNull String wcPath,@Nullable VcsFile oldFile) throws IOException, SVNException {
  if (deletedPaths.contains(wcPath)) {
    return null;
  }
  final SetPathParams pathParams=paths.get(wcPath);
  if (pathParams == null) {
    return oldFile;
  }
  if (pathParams.startEmpty || (pathParams.rev == 0)) {
    return null;
  }
  return context.getFile(pathParams.rev,wcPath);
}","@Nullable private VcsFile getPrevFile(@NotNull SessionContext context,@NotNull String wcPath,@Nullable VcsFile oldFile) throws IOException, SVNException {
  if (deletedPaths.contains(wcPath))   return null;
  final SetPathParams pathParams=paths.get(wcPath);
  if (pathParams == null)   return oldFile;
  if (pathParams.startEmpty || pathParams.rev == 0)   return null;
  return context.getFile(pathParams.rev,wcPath);
}"
9008,"public SetPathParams(@NotNull String path,int rev,boolean startEmpty,@NotNull String[] lockToken,@NotNull String depth){
  this.path=path;
  this.rev=rev;
  this.startEmpty=startEmpty;
  this.lockToken=lockToken;
  this.depth=DeltaParams.Depth.parse(depth);
}","public SetPathParams(@NotNull String path,int rev,boolean startEmpty,@NotNull String[] lockToken,@NotNull String depth){
  this.path=path;
  this.rev=rev;
  this.startEmpty=startEmpty;
  this.lockToken=lockToken;
  this.depth=Depth.parse(depth);
}"
9009,"@Override protected void processCommand(@NotNull SessionContext context,@NotNull Params args) throws IOException, SVNException {
  final SvnServerWriter writer=context.getWriter();
  final int head=context.getRepository().getLatestRevision();
  final Set<String> targetPaths=new HashSet<>();
  for (  String target : args.targetPath) {
    targetPaths.add(context.getRepositoryPath(target));
  }
  int startRev=getRevision(args.startRev,1);
  int endRev=getRevision(args.endRev,head);
  int step=startRev < endRev ? 1 : -1;
  if ((startRev > head) || (endRev > head)) {
    writer.word(""String_Node_Str"");
    sendError(writer,SVNErrorMessage.create(SVNErrorCode.FS_NO_SUCH_REVISION,""String_Node_Str"" + Math.max(startRev,endRev)));
    return;
  }
  int logLimit=args.limit;
  for (int rev=startRev; rev != endRev; rev+=step) {
    if (targetPaths.isEmpty()) {
      break;
    }
    final VcsRevision revisionInfo=context.getRepository().getRevisionInfo(rev);
    final Map<String,VcsLogEntry> changes=revisionInfo.getChanges();
    if (!hasTargets(changes,targetPaths))     continue;
    writer.listBegin().listBegin();
    if (args.changedPaths) {
      writer.separator();
      for (      Map.Entry<String,VcsLogEntry> entry : changes.entrySet()) {
        final VcsLogEntry logEntry=entry.getValue();
        final char change=logEntry.getChange();
        if (change == 0)         continue;
        writer.listBegin().string(entry.getKey()).word(change).listBegin().listEnd().listBegin().string(logEntry.getKind().toString()).bool(logEntry.isContentModified()).bool(logEntry.isPropertyModified()).listEnd().listEnd().separator();
      }
    }
    writer.listEnd().number(rev).listBegin().string(revisionInfo.getAuthor()).listEnd().listBegin().string(revisionInfo.getDate()).listEnd().listBegin().string(revisionInfo.getLog()).listEnd().bool(false).bool(false).number(0).listBegin().listEnd().listEnd().separator();
    if (--logLimit == 0)     break;
  }
  writer.word(""String_Node_Str"");
  writer.listBegin().word(""String_Node_Str"").listBegin().listEnd().listEnd();
}","@Override protected void processCommand(@NotNull SessionContext context,@NotNull Params args) throws IOException, SVNException {
  final SvnServerWriter writer=context.getWriter();
  final int head=context.getRepository().getLatestRevision();
  final Set<String> targetPaths=new HashSet<>();
  for (  String target : args.targetPath) {
    targetPaths.add(context.getRepositoryPath(target));
  }
  int startRev=getRevision(args.startRev,1);
  int endRev=getRevision(args.endRev,head);
  int step=startRev < endRev ? 1 : -1;
  if ((startRev > head) || (endRev > head)) {
    writer.word(""String_Node_Str"");
    sendError(writer,SVNErrorMessage.create(SVNErrorCode.FS_NO_SUCH_REVISION,""String_Node_Str"" + Math.max(startRev,endRev)));
    return;
  }
  int logLimit=args.limit;
  for (int rev=startRev; rev != endRev + step; rev+=step) {
    if (targetPaths.isEmpty()) {
      break;
    }
    final VcsRevision revisionInfo=context.getRepository().getRevisionInfo(rev);
    final Map<String,VcsLogEntry> changes=revisionInfo.getChanges();
    if (!hasTargets(changes,targetPaths))     continue;
    writer.listBegin().listBegin();
    if (args.changedPaths) {
      writer.separator();
      for (      Map.Entry<String,VcsLogEntry> entry : changes.entrySet()) {
        final VcsLogEntry logEntry=entry.getValue();
        final char change=logEntry.getChange();
        if (change == 0)         continue;
        writer.listBegin().string(entry.getKey()).word(change).listBegin().listEnd().listBegin().string(logEntry.getKind().toString()).bool(logEntry.isContentModified()).bool(logEntry.isPropertyModified()).listEnd().listEnd().separator();
      }
    }
    writer.listEnd().number(rev).listBegin().string(revisionInfo.getAuthor()).listEnd().listBegin().string(revisionInfo.getDate()).listEnd().listBegin().string(revisionInfo.getLog()).listEnd().bool(false).bool(false).number(0).listBegin().listEnd().listEnd().separator();
    if (--logLimit == 0)     break;
  }
  writer.word(""String_Node_Str"");
  writer.listBegin().word(""String_Node_Str"").listBegin().listEnd().listEnd();
}"
9010,"protected void sendResponse(@NotNull SessionContext context,@NotNull String path,int rev) throws IOException, ClientErrorException {
  final SvnServerWriter writer=context.getWriter();
  writer.listBegin().word(""String_Node_Str"").listBegin().number(rev).listEnd().listEnd();
  final String tokenId=createTokenId();
  final SetPathParams rootParams=paths.get(path);
  writer.listBegin().word(""String_Node_Str"").listBegin().listBegin().number(rootParams == null ? rev : rootParams.rev).listEnd().string(tokenId).listEnd().listEnd();
  FileInfo file=context.getRepository().getRevisionInfo(rev).getFile(context.getRepositoryPath(path));
  updateEntry(context,path,getPrevFile(context,path,file),file,tokenId,path.isEmpty());
  writer.listBegin().word(""String_Node_Str"").listBegin().string(tokenId).listEnd().listEnd();
  writer.listBegin().word(""String_Node_Str"").listBegin().listEnd().listEnd();
  final SvnServerParser parser=context.getParser();
  parser.readToken(ListBeginToken.class);
  if (!""String_Node_Str"".equals(parser.readText())) {
    parser.skipItems();
  }
 else {
    parser.skipItems();
    writer.listBegin().word(""String_Node_Str"").listBegin().listEnd().listEnd();
  }
}","protected void sendResponse(@NotNull SessionContext context,@NotNull String path,int rev) throws IOException, ClientErrorException {
  final SvnServerWriter writer=context.getWriter();
  writer.listBegin().word(""String_Node_Str"").listBegin().number(rev).listEnd().listEnd();
  final String tokenId=createTokenId();
  final SetPathParams rootParams=paths.get(path);
  writer.listBegin().word(""String_Node_Str"").listBegin().listBegin().number(rootParams == null ? rev : rootParams.rev).listEnd().string(tokenId).listEnd().listEnd();
  FileInfo file=context.getRepository().getRevisionInfo(rev).getFile(context.getRepositoryPath(path));
  updateEntry(context,path,getPrevFile(context,path,file),file,tokenId,path.isEmpty());
  writer.listBegin().word(""String_Node_Str"").listBegin().string(tokenId).listEnd().listEnd();
  writer.listBegin().word(""String_Node_Str"").listBegin().listEnd().listEnd();
  final SvnServerParser parser=context.getParser();
  parser.readToken(ListBeginToken.class);
  if (!""String_Node_Str"".equals(parser.readText())) {
    parser.readToken(ListBeginToken.class);
    parser.readToken(ListBeginToken.class);
    final int errorCode=parser.readNumber();
    final String errorMessage=parser.readText();
    parser.skipItems();
    parser.readToken(ListEndToken.class);
    parser.readToken(ListEndToken.class);
    log.error(""String_Node_Str"",errorCode,errorMessage);
    throw new EOFException(errorMessage);
  }
 else {
    parser.skipItems();
    writer.listBegin().word(""String_Node_Str"").listBegin().listEnd().listEnd();
  }
}"
9011,"public SvnServerParser(@NotNull InputStream stream){
  this.stream=stream;
}","public SvnServerParser(@NotNull InputStream stream){
  this(stream,DEFAULT_BUFFER_SIZE);
}"
9012,"@NotNull private StringToken readString(int length) throws IOException {
  int need=length;
  while (need > 0) {
    if (buffer.length == position) {
      buffer=Arrays.copyOf(buffer,buffer.length * 2);
    }
    final int readed=stream.read(buffer,position,Math.min(need,buffer.length - position));
    if (readed < 0) {
      throw new IOException(""String_Node_Str"");
    }
    need-=readed;
  }
  return new StringToken(Arrays.copyOf(buffer,length));
}","@NotNull private StringToken readString(int length) throws IOException {
  int need=length;
  byte[] localBuffer=buffer;
  while (need > 0) {
    if (localBuffer.length == position) {
      localBuffer=enlargeBuffer(localBuffer);
    }
    final int readed=stream.read(localBuffer,position,Math.min(need,localBuffer.length - position));
    if (readed < 0) {
      throw new IOException(""String_Node_Str"");
    }
    need-=readed;
    position+=readed;
  }
  return new StringToken(Arrays.copyOf(localBuffer,length));
}"
9013,"@NotNull private WordToken readWord(int first) throws IOException {
  buffer[position]=(byte)first;
  position++;
  while (true) {
    final int read=stream.read();
    if (read < 0) {
      throw new IOException(""String_Node_Str"");
    }
    if (isSpace(read)) {
      return new WordToken(new String(buffer,0,position,StandardCharsets.US_ASCII));
    }
    if (!(isAlpha(read) || isDigit(read) || (read == '-'))) {
      throw new IOException(""String_Node_Str"" + read + ""String_Node_Str"");
    }
    buffer[position]=(byte)read;
    position++;
  }
}","@NotNull private WordToken readWord(int first) throws IOException {
  byte[] localBuffer=buffer;
  localBuffer[position]=(byte)first;
  position++;
  while (true) {
    final int read=stream.read();
    if (read < 0) {
      throw new IOException(""String_Node_Str"");
    }
    if (isSpace(read)) {
      return new WordToken(new String(localBuffer,0,position,StandardCharsets.US_ASCII));
    }
    if (!(isAlpha(read) || isDigit(read) || (read == '-'))) {
      throw new IOException(""String_Node_Str"" + read + ""String_Node_Str"");
    }
    if (localBuffer.length == position) {
      localBuffer=enlargeBuffer(localBuffer);
    }
    localBuffer[position]=(byte)read;
    position++;
  }
}"
9014,"/** 
 * Rechunks the strings based on a regex pattern and works on infinite stream. <pre> split([""boo:an"", ""d:foo""], "":"") --> [""boo"", ""and"", ""foo""] split([""boo:an"", ""d:foo""], ""o"") --> [""b"", """", "":and:f"", """", """"] </pre> See   {@link Pattern}<p> <img width=""640"" src=""https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/St.split.png"" alt="""">
 * @param src the source that should be use for the split
 * @param pattern pre compiled regular expression pattern for the split functionality
 * @return the Observable streaming the split values
 */
public static Observable<String> split(final Observable<String> src,final Pattern pattern){
  return src.lift(new Operator<String,String>(){
    @Override public Subscriber<? super String> call(    final Subscriber<? super String> o){
      return new Subscriber<String>(o){
        private String leftOver=null;
        @Override public void onCompleted(){
          if (leftOver != null)           output(leftOver);
          if (!o.isUnsubscribed())           o.onCompleted();
        }
        @Override public void onError(        Throwable e){
          if (leftOver != null)           output(leftOver);
          if (!o.isUnsubscribed())           o.onError(e);
        }
        @Override public void onNext(        String segment){
          String[] parts=pattern.split(segment,-1);
          if (leftOver != null)           parts[0]=leftOver + parts[0];
          for (int i=0; i < parts.length - 1; i++) {
            String part=parts[i];
            output(part);
          }
          leftOver=parts[parts.length - 1];
        }
        private int emptyPartCount=0;
        /** 
 * when limit == 0 trailing empty parts are not emitted.
 * @param part
 */
        private void output(        String part){
          if (part.isEmpty()) {
            emptyPartCount++;
          }
 else {
            for (; emptyPartCount > 0; emptyPartCount--)             if (!o.isUnsubscribed())             o.onNext(""String_Node_Str"");
            if (!o.isUnsubscribed())             o.onNext(part);
          }
        }
      }
;
    }
  }
);
}","/** 
 * Rechunks the strings based on a regex pattern and works on infinite stream. <pre> split([""boo:an"", ""d:foo""], "":"") --> [""boo"", ""and"", ""foo""] split([""boo:an"", ""d:foo""], ""o"") --> [""b"", """", "":and:f"", """", """"] </pre> See   {@link Pattern}<p> <img width=""640"" src=""https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/St.split.png"" alt="""">
 * @param src the source that should be use for the split
 * @param pattern pre compiled regular expression pattern for the split functionality
 * @return the Observable streaming the split values
 */
public static Observable<String> split(final Observable<String> src,final Pattern pattern){
  return src.lift(new Operator<String,String>(){
    @Override public Subscriber<? super String> call(    final Subscriber<? super String> o){
      return new Subscriber<String>(o){
        private String leftOver=null;
        @Override public void onCompleted(){
          if (leftOver != null)           output(leftOver);
          if (!o.isUnsubscribed())           o.onCompleted();
        }
        @Override public void onError(        Throwable e){
          if (leftOver != null)           output(leftOver);
          if (!o.isUnsubscribed())           o.onError(e);
        }
        @Override public void onNext(        String segment){
          if (leftOver != null)           segment=leftOver + segment;
          String[] parts=pattern.split(segment,-1);
          for (int i=0; i < parts.length - 1; i++) {
            String part=parts[i];
            output(part);
          }
          leftOver=parts[parts.length - 1];
        }
        private int emptyPartCount=0;
        /** 
 * when limit == 0 trailing empty parts are not emitted.
 * @param part
 */
        private void output(        String part){
          if (part.isEmpty()) {
            emptyPartCount++;
          }
 else {
            for (; emptyPartCount > 0; emptyPartCount--)             if (!o.isUnsubscribed())             o.onNext(""String_Node_Str"");
            if (!o.isUnsubscribed())             o.onNext(part);
          }
        }
      }
;
    }
  }
);
}"
9015,"@Override public Subscriber<T> call(final Subscriber<? super String> o){
  return new Subscriber<T>(o){
    boolean mayAddSeparator;
    StringBuilder b=new StringBuilder();
    @Override public void onCompleted(){
      String str=b.toString();
      b=null;
      if (!o.isUnsubscribed())       o.onNext(str);
      if (!o.isUnsubscribed())       o.onCompleted();
    }
    @Override public void onError(    Throwable e){
      b=null;
      if (!o.isUnsubscribed())       o.onError(e);
    }
    @Override public void onNext(    Object t){
      if (mayAddSeparator) {
        b.append(separator);
      }
      mayAddSeparator=true;
      b.append(String.valueOf(t));
    }
  }
;
}","@Override public Line call(String text){
  return new Line(lineNumber++,text);
}"
9016,"public boolean process(byte[] next,ByteBuffer last,boolean endOfInput){
  ByteBuffer bb;
  if (last != null) {
    if (next != null) {
      bb=ByteBuffer.allocate(last.remaining() + next.length);
      bb.put(last);
      bb.put(next);
      bb.flip();
    }
 else {
      bb=last;
    }
  }
 else {
    if (next != null) {
      bb=ByteBuffer.wrap(next);
    }
 else {
      return true;
    }
  }
  CharBuffer cb=CharBuffer.allocate((int)(bb.limit() * charsetDecoder.averageCharsPerByte()));
  CoderResult cr=charsetDecoder.decode(bb,cb,endOfInput);
  cb.flip();
  if (cr.isError()) {
    try {
      cr.throwException();
    }
 catch (    CharacterCodingException e) {
      o.onError(e);
      return false;
    }
  }
  if (bb.remaining() > 0) {
    leftOver=bb;
  }
 else {
    leftOver=null;
  }
  String string=cb.toString();
  if (!string.isEmpty())   o.onNext(string);
  return true;
}","public boolean process(byte[] next,ByteBuffer last,boolean endOfInput){
  if (o.isUnsubscribed())   return false;
  ByteBuffer bb;
  if (last != null) {
    if (next != null) {
      bb=ByteBuffer.allocate(last.remaining() + next.length);
      bb.put(last);
      bb.put(next);
      bb.flip();
    }
 else {
      bb=last;
    }
  }
 else {
    if (next != null) {
      bb=ByteBuffer.wrap(next);
    }
 else {
      return true;
    }
  }
  CharBuffer cb=CharBuffer.allocate((int)(bb.limit() * charsetDecoder.averageCharsPerByte()));
  CoderResult cr=charsetDecoder.decode(bb,cb,endOfInput);
  cb.flip();
  if (cr.isError()) {
    try {
      cr.throwException();
    }
 catch (    CharacterCodingException e) {
      o.onError(e);
      return false;
    }
  }
  if (bb.remaining() > 0) {
    leftOver=bb;
  }
 else {
    leftOver=null;
  }
  String string=cb.toString();
  if (!string.isEmpty())   o.onNext(string);
  return true;
}"
9017,"/** 
 * Rechunks the strings based on a regex pattern and works on infinite stream. resplit([""boo:an"", ""d:foo""], "":"") --> [""boo"", ""and"", ""foo""] resplit([""boo:an"", ""d:foo""], ""o"") --> [""b"", """", "":and:f"", """", """"] See   {@link Pattern}
 * @param src
 * @param regex
 * @return
 */
public static Observable<String> split(final Observable<String> src,String regex){
  final Pattern pattern=Pattern.compile(regex);
  return src.lift(new Operator<String,String>(){
    @Override public Subscriber<? super String> call(    final Subscriber<? super String> o){
      return new Subscriber<String>(o){
        private String leftOver=null;
        @Override public void onCompleted(){
          output(leftOver);
          if (!o.isUnsubscribed())           o.onCompleted();
        }
        @Override public void onError(        Throwable e){
          output(leftOver);
          if (!o.isUnsubscribed())           o.onError(e);
        }
        @Override public void onNext(        String segment){
          String[] parts=pattern.split(segment,-1);
          if (leftOver != null)           parts[0]=leftOver + parts[0];
          for (int i=0; i < parts.length - 1; i++) {
            String part=parts[i];
            output(part);
          }
          leftOver=parts[parts.length - 1];
        }
        private int emptyPartCount=0;
        /** 
 * when limit == 0 trailing empty parts are not emitted.
 * @param part
 */
        private void output(        String part){
          if (part.isEmpty()) {
            emptyPartCount++;
          }
 else {
            for (; emptyPartCount > 0; emptyPartCount--)             if (!o.isUnsubscribed())             o.onNext(""String_Node_Str"");
            if (!o.isUnsubscribed())             o.onNext(part);
          }
        }
      }
;
    }
  }
);
}","/** 
 * Rechunks the strings based on a regex pattern and works on infinite stream. <pre> split([""boo:an"", ""d:foo""], "":"") --> [""boo"", ""and"", ""foo""] split([""boo:an"", ""d:foo""], ""o"") --> [""b"", """", "":and:f"", """", """"] </pre> See   {@link Pattern}
 * @param src
 * @param regex
 * @return
 */
public static Observable<String> split(final Observable<String> src,String regex){
  final Pattern pattern=Pattern.compile(regex);
  return src.lift(new Operator<String,String>(){
    @Override public Subscriber<? super String> call(    final Subscriber<? super String> o){
      return new Subscriber<String>(o){
        private String leftOver=null;
        @Override public void onCompleted(){
          output(leftOver);
          if (!o.isUnsubscribed())           o.onCompleted();
        }
        @Override public void onError(        Throwable e){
          output(leftOver);
          if (!o.isUnsubscribed())           o.onError(e);
        }
        @Override public void onNext(        String segment){
          String[] parts=pattern.split(segment,-1);
          if (leftOver != null)           parts[0]=leftOver + parts[0];
          for (int i=0; i < parts.length - 1; i++) {
            String part=parts[i];
            output(part);
          }
          leftOver=parts[parts.length - 1];
        }
        private int emptyPartCount=0;
        /** 
 * when limit == 0 trailing empty parts are not emitted.
 * @param part
 */
        private void output(        String part){
          if (part.isEmpty()) {
            emptyPartCount++;
          }
 else {
            for (; emptyPartCount > 0; emptyPartCount--)             if (!o.isUnsubscribed())             o.onNext(""String_Node_Str"");
            if (!o.isUnsubscribed())             o.onNext(part);
          }
        }
      }
;
    }
  }
);
}"
9018,"public static Observable<String> from(final Reader i,final int size){
  return Observable.create(new OnSubscribe<String>(){
    @Override public void call(    Subscriber<? super String> o){
      char[] buffer=new char[size];
      try {
        if (o.isUnsubscribed())         return;
        int n=0;
        n=i.read(buffer);
        while (n != -1 && !o.isUnsubscribed()) {
          o.onNext(new String(buffer));
          n=i.read(buffer);
        }
      }
 catch (      IOException e) {
        o.onError(e);
      }
      if (o.isUnsubscribed())       return;
      o.onCompleted();
    }
  }
);
}","/** 
 * Reads from the characters from a source   {@link Reader} and outputs {@link Observable} of{@link String}s
 * @param i Source  {@link Reader}
 * @param size internal buffer size
 * @return
 */
public static Observable<String> from(final Reader i,final int size){
  return Observable.create(new OnSubscribe<String>(){
    @Override public void call(    Subscriber<? super String> o){
      char[] buffer=new char[size];
      try {
        if (o.isUnsubscribed())         return;
        int n=0;
        n=i.read(buffer);
        while (n != -1 && !o.isUnsubscribed()) {
          o.onNext(new String(buffer,0,n));
          n=i.read(buffer);
        }
      }
 catch (      IOException e) {
        o.onError(e);
      }
      if (o.isUnsubscribed())       return;
      o.onCompleted();
    }
  }
);
}"
9019,"/** 
 * Decodes a stream the multibyte chunks into a stream of strings that works on infinite streams and where handles when a multibyte character spans two chunks. This method allows for more control over how malformed and unmappable characters are handled.
 * @param src
 * @param charsetDecoder
 * @return
 */
public static Observable<String> decode(final Observable<byte[]> src,final CharsetDecoder charsetDecoder){
  return src.lift(new Operator<String,byte[]>(){
    @Override public Subscriber<? super byte[]> call(    final Subscriber<? super String> o){
      return new Subscriber<byte[]>(o){
        private ByteBuffer leftOver=null;
        @Override public void onCompleted(){
          if (process(null,leftOver,true))           o.onCompleted();
        }
        @Override public void onError(        Throwable e){
          if (process(null,leftOver,true))           o.onError(e);
        }
        @Override public void onNext(        byte[] bytes){
          process(bytes,leftOver,false);
        }
        public boolean process(        byte[] next,        ByteBuffer last,        boolean endOfInput){
          ByteBuffer bb;
          if (last != null) {
            if (next != null) {
              bb=ByteBuffer.allocate(last.remaining() + next.length);
              bb.put(last);
              bb.put(next);
              bb.flip();
            }
 else {
              bb=last;
            }
          }
 else {
            if (next != null) {
              bb=ByteBuffer.wrap(next);
            }
 else {
              return true;
            }
          }
          CharBuffer cb=CharBuffer.allocate((int)(bb.limit() * charsetDecoder.averageCharsPerByte()));
          CoderResult cr=charsetDecoder.decode(bb,cb,endOfInput);
          cb.flip();
          if (cr.isError()) {
            try {
              cr.throwException();
            }
 catch (            CharacterCodingException e) {
              o.onError(e);
              return false;
            }
          }
          if (bb.remaining() > 0) {
            leftOver=bb;
          }
 else {
            leftOver=null;
          }
          String string=cb.toString();
          if (!string.isEmpty())           o.onNext(string);
          return true;
        }
      }
;
    }
  }
);
}","/** 
 * Decodes a stream the multibyte chunks into a stream of strings that works on infinite streams and where it handles when a multibyte character spans two chunks. This method allows for more control over how malformed and unmappable characters are handled.
 * @param src
 * @param charsetDecoder
 * @return
 */
public static Observable<String> decode(final Observable<byte[]> src,final CharsetDecoder charsetDecoder){
  return src.lift(new Operator<String,byte[]>(){
    @Override public Subscriber<? super byte[]> call(    final Subscriber<? super String> o){
      return new Subscriber<byte[]>(o){
        private ByteBuffer leftOver=null;
        @Override public void onCompleted(){
          if (process(null,leftOver,true))           o.onCompleted();
        }
        @Override public void onError(        Throwable e){
          if (process(null,leftOver,true))           o.onError(e);
        }
        @Override public void onNext(        byte[] bytes){
          process(bytes,leftOver,false);
        }
        public boolean process(        byte[] next,        ByteBuffer last,        boolean endOfInput){
          if (o.isUnsubscribed())           return false;
          ByteBuffer bb;
          if (last != null) {
            if (next != null) {
              bb=ByteBuffer.allocate(last.remaining() + next.length);
              bb.put(last);
              bb.put(next);
              bb.flip();
            }
 else {
              bb=last;
            }
          }
 else {
            if (next != null) {
              bb=ByteBuffer.wrap(next);
            }
 else {
              return true;
            }
          }
          CharBuffer cb=CharBuffer.allocate((int)(bb.limit() * charsetDecoder.averageCharsPerByte()));
          CoderResult cr=charsetDecoder.decode(bb,cb,endOfInput);
          cb.flip();
          if (cr.isError()) {
            try {
              cr.throwException();
            }
 catch (            CharacterCodingException e) {
              o.onError(e);
              return false;
            }
          }
          if (bb.remaining() > 0) {
            leftOver=bb;
          }
 else {
            leftOver=null;
          }
          String string=cb.toString();
          if (!string.isEmpty())           o.onNext(string);
          return true;
        }
      }
;
    }
  }
);
}"
9020,"public void stop(WebSocketSession session) throws IOException {
  UserSession stopperUser=registry.getBySession(session);
  UserSession stoppedUser=(stopperUser.getCallingFrom() != null) ? registry.getByName(stopperUser.getCallingFrom()) : registry.getByName(stopperUser.getCallingTo());
  JsonObject message=new JsonObject();
  message.addProperty(""String_Node_Str"",""String_Node_Str"");
  stoppedUser.sendMessage(message);
}","public void stop(WebSocketSession session) throws IOException {
  UserSession stopperUser=registry.getBySession(session);
  if (stopperUser != null) {
    UserSession stoppedUser=(stopperUser.getCallingFrom() != null) ? registry.getByName(stopperUser.getCallingFrom()) : stopperUser.getCallingTo() != null ? registry.getByName(stopperUser.getCallingTo()) : null;
    if (stoppedUser != null) {
      JsonObject message=new JsonObject();
      message.addProperty(""String_Node_Str"",""String_Node_Str"");
      stoppedUser.sendMessage(message);
      stoppedUser.clear();
    }
    stopperUser.clear();
  }
}"
9021,"public void stop(WebSocketSession session) throws IOException {
  UserSession stopperUser=registry.getBySession(session);
  UserSession stoppedUser=(stopperUser.getCallingFrom() != null) ? registry.getByName(stopperUser.getCallingFrom()) : registry.getByName(stopperUser.getCallingTo());
  JsonObject message=new JsonObject();
  message.addProperty(""String_Node_Str"",""String_Node_Str"");
  stoppedUser.sendMessage(message);
}","public void stop(WebSocketSession session) throws IOException {
  UserSession stopperUser=registry.getBySession(session);
  if (stopperUser != null) {
    UserSession stoppedUser=(stopperUser.getCallingFrom() != null) ? registry.getByName(stopperUser.getCallingFrom()) : stopperUser.getCallingTo() != null ? registry.getByName(stopperUser.getCallingTo()) : null;
    if (stoppedUser != null) {
      JsonObject message=new JsonObject();
      message.addProperty(""String_Node_Str"",""String_Node_Str"");
      stoppedUser.sendMessage(message);
      stoppedUser.clear();
    }
    stopperUser.clear();
  }
}"
9022,"public void stop(WebSocketSession session) throws IOException {
  String sessionId=session.getId();
  if (pipelines.containsKey(sessionId)) {
    pipelines.get(sessionId).release();
    CallMediaPipeline pipeline=pipelines.remove(sessionId);
    pipeline.release();
    UserSession stopperUser=registry.getBySession(session);
    UserSession stoppedUser=(stopperUser.getCallingFrom() != null) ? registry.getByName(stopperUser.getCallingFrom()) : registry.getByName(stopperUser.getCallingTo());
    JsonObject message=new JsonObject();
    message.addProperty(""String_Node_Str"",""String_Node_Str"");
    stoppedUser.sendMessage(message);
    stopperUser.clear();
    stoppedUser.clear();
  }
}","public void stop(WebSocketSession session) throws IOException {
  String sessionId=session.getId();
  if (pipelines.containsKey(sessionId)) {
    pipelines.get(sessionId).release();
    CallMediaPipeline pipeline=pipelines.remove(sessionId);
    pipeline.release();
    UserSession stopperUser=registry.getBySession(session);
    if (stopperUser != null) {
      UserSession stoppedUser=(stopperUser.getCallingFrom() != null) ? registry.getByName(stopperUser.getCallingFrom()) : stopperUser.getCallingTo() != null ? registry.getByName(stopperUser.getCallingTo()) : null;
      if (stoppedUser != null) {
        JsonObject message=new JsonObject();
        message.addProperty(""String_Node_Str"",""String_Node_Str"");
        stoppedUser.sendMessage(message);
        stoppedUser.clear();
      }
      stopperUser.clear();
    }
  }
}"
9023,"private void play(final UserSession session,JsonObject jsonMessage) throws IOException {
  String user=jsonMessage.get(""String_Node_Str"").getAsString();
  log.debug(""String_Node_Str"",user);
  JsonObject response=new JsonObject();
  response.addProperty(""String_Node_Str"",""String_Node_Str"");
  if (registry.getByName(user) != null && registry.getBySession(session.getSession()) != null) {
    PlayMediaPipeline playMediaPipeline=new PlayMediaPipeline(kurento,user,session.getSession());
    String sdpOffer=jsonMessage.get(""String_Node_Str"").getAsString();
    session.setPlayingWebRtcEndpoint(playMediaPipeline.getWebRtc());
    playMediaPipeline.getWebRtc().addOnIceCandidateListener(new EventListener<OnIceCandidateEvent>(){
      @Override public void onEvent(      OnIceCandidateEvent event){
        JsonObject response=new JsonObject();
        response.addProperty(""String_Node_Str"",""String_Node_Str"");
        response.add(""String_Node_Str"",JsonUtils.toJsonObject(event.getCandidate()));
        try {
synchronized (session) {
            session.getSession().sendMessage(new TextMessage(response.toString()));
          }
        }
 catch (        IOException e) {
          log.debug(e.getMessage());
        }
      }
    }
);
    String sdpAnswer=playMediaPipeline.generateSdpAnswer(sdpOffer);
    response.addProperty(""String_Node_Str"",""String_Node_Str"");
    response.addProperty(""String_Node_Str"",sdpAnswer);
    playMediaPipeline.play();
    pipelines.put(session.getSessionId(),playMediaPipeline.getPipeline());
synchronized (session.getSession()) {
      session.sendMessage(response);
    }
    playMediaPipeline.getWebRtc().gatherCandidates();
  }
 else {
    response.addProperty(""String_Node_Str"",""String_Node_Str"");
    response.addProperty(""String_Node_Str"",""String_Node_Str"" + user + ""String_Node_Str"");
    session.getSession().sendMessage(new TextMessage(response.toString()));
  }
}","private void play(final UserSession session,JsonObject jsonMessage) throws IOException {
  String user=jsonMessage.get(""String_Node_Str"").getAsString();
  log.debug(""String_Node_Str"",user);
  JsonObject response=new JsonObject();
  response.addProperty(""String_Node_Str"",""String_Node_Str"");
  if (registry.getByName(user) != null && registry.getBySession(session.getSession()) != null) {
    final PlayMediaPipeline playMediaPipeline=new PlayMediaPipeline(kurento,user,session.getSession());
    String sdpOffer=jsonMessage.get(""String_Node_Str"").getAsString();
    session.setPlayingWebRtcEndpoint(playMediaPipeline.getWebRtc());
    playMediaPipeline.getPlayer().addEndOfStreamListener(new EventListener<EndOfStreamEvent>(){
      @Override public void onEvent(      EndOfStreamEvent event){
        UserSession user=registry.getBySession(session.getSession());
        releasePipeline(user);
        playMediaPipeline.sendPlayEnd(session.getSession());
      }
    }
);
    playMediaPipeline.getWebRtc().addOnIceCandidateListener(new EventListener<OnIceCandidateEvent>(){
      @Override public void onEvent(      OnIceCandidateEvent event){
        JsonObject response=new JsonObject();
        response.addProperty(""String_Node_Str"",""String_Node_Str"");
        response.add(""String_Node_Str"",JsonUtils.toJsonObject(event.getCandidate()));
        try {
synchronized (session) {
            session.getSession().sendMessage(new TextMessage(response.toString()));
          }
        }
 catch (        IOException e) {
          log.debug(e.getMessage());
        }
      }
    }
);
    String sdpAnswer=playMediaPipeline.generateSdpAnswer(sdpOffer);
    response.addProperty(""String_Node_Str"",""String_Node_Str"");
    response.addProperty(""String_Node_Str"",sdpAnswer);
    playMediaPipeline.play();
    pipelines.put(session.getSessionId(),playMediaPipeline.getPipeline());
synchronized (session.getSession()) {
      session.sendMessage(response);
    }
    playMediaPipeline.getWebRtc().gatherCandidates();
  }
 else {
    response.addProperty(""String_Node_Str"",""String_Node_Str"");
    response.addProperty(""String_Node_Str"",""String_Node_Str"" + user + ""String_Node_Str"");
    session.getSession().sendMessage(new TextMessage(response.toString()));
  }
}"
9024,"public void releasePipeline(UserSession session) throws IOException {
  String sessionId=session.getSessionId();
  UserSession stoppedUser=(session.getCallingFrom() != null) ? registry.getByName(session.getCallingFrom()) : registry.getByName(session.getCallingTo());
  if (pipelines.containsKey(sessionId)) {
    pipelines.get(sessionId).release();
    pipelines.remove(sessionId);
  }
  session.setWebRtcEndpoint(null);
  session.setPlayingWebRtcEndpoint(null);
  stoppedUser.setWebRtcEndpoint(null);
  stoppedUser.setPlayingWebRtcEndpoint(null);
}","public void releasePipeline(UserSession session){
  String sessionId=session.getSessionId();
  UserSession stoppedUser=(session.getCallingFrom() != null) ? registry.getByName(session.getCallingFrom()) : registry.getByName(session.getCallingTo());
  if (pipelines.containsKey(sessionId)) {
    pipelines.get(sessionId).release();
    pipelines.remove(sessionId);
  }
  session.setWebRtcEndpoint(null);
  session.setPlayingWebRtcEndpoint(null);
  stoppedUser.setWebRtcEndpoint(null);
  stoppedUser.setPlayingWebRtcEndpoint(null);
}"
9025,"public PlayMediaPipeline(KurentoClient kurento,String user,final WebSocketSession session){
  pipeline=kurento.createMediaPipeline();
  webRtc=new WebRtcEndpoint.Builder(pipeline).build();
  player=new PlayerEndpoint.Builder(pipeline,RECORDING_PATH + user + RECORDING_EXT).build();
  player.connect(webRtc);
  player.addErrorListener(new EventListener<ErrorEvent>(){
    @Override public void onEvent(    ErrorEvent event){
      log.info(""String_Node_Str"",event.getDescription());
      sendPlayEnd(session);
    }
  }
);
  player.addEndOfStreamListener(new EventListener<EndOfStreamEvent>(){
    @Override public void onEvent(    EndOfStreamEvent event){
      sendPlayEnd(session);
    }
  }
);
}","public PlayMediaPipeline(KurentoClient kurento,String user,final WebSocketSession session){
  pipeline=kurento.createMediaPipeline();
  webRtc=new WebRtcEndpoint.Builder(pipeline).build();
  player=new PlayerEndpoint.Builder(pipeline,RECORDING_PATH + user + RECORDING_EXT).build();
  player.connect(webRtc);
  player.addErrorListener(new EventListener<ErrorEvent>(){
    @Override public void onEvent(    ErrorEvent event){
      log.info(""String_Node_Str"",event.getDescription());
      sendPlayEnd(session);
    }
  }
);
}"
9026,"@Override public void onEvent(EndOfStreamEvent event){
  sendPlayEnd(session);
}","@Override public void onEvent(ErrorEvent event){
  log.info(""String_Node_Str"",event.getDescription());
  sendPlayEnd(session);
}"
9027,"@Override protected void onDraw(Canvas canvas){
  boolean changed=mChanged;
  if (changed) {
    mChanged=false;
  }
  int availableWidth=getRight() - getLeft();
  int availableHeight=getBottom() - getTop();
  int x=availableWidth / 2;
  int y=availableHeight / 2;
  int w=getWidth();
  int h=getHeight();
  boolean scaled=false;
  if (availableWidth < w || availableHeight < h) {
    scaled=true;
    float scale=min(availableWidth / (float)w,(float)availableHeight / h);
    canvas.save();
    canvas.scale(scale,scale,x,y);
  }
  canvas.save();
  if (mIsProgressSetViaApi) {
    markPointX=mCircleCenterX - (float)(mOuterRadius * cos(toRadians((mProgress * 360.0d / mMaxProgress) + 90.0d)));
    markPointY=mCircleCenterY - (float)(mOuterRadius * sin(toRadians((mProgress * 360.0d / mMaxProgress) + 90.0d)));
  }
  mMarkerPositionX=getXFromAngle();
  mMarkerPositionY=getYFromAngle();
  canvas.drawCircle(mCircleCenterX,mCircleCenterY,mOuterRadius,mCirclePaint);
  drawMarkerAtProgress(canvas);
  if (mIsProgressSetViaApi) {
    mAngle=mProgress * 360.0f / mMaxProgress;
  }
  canvas.rotate(mProgress * 360.0f / mMaxProgress,x,y);
  final Drawable hourHand=mHourHand;
  if (changed) {
    w=hourHand.getIntrinsicWidth();
    h=hourHand.getIntrinsicHeight();
    hourHand.setBounds(x - (w / 2),y - (h / 2),x + (w / 2),y + (h / 2));
  }
  hourHand.draw(canvas);
  canvas.restore();
  canvas.save();
  canvas.rotate(0,x,y);
  final Drawable minuteHand=mMinuteHand;
  if (changed) {
    w=minuteHand.getIntrinsicWidth();
    h=minuteHand.getIntrinsicHeight();
    minuteHand.setBounds(x - (w / 2),y - (h / 2),x + (w / 2),y + (h / 2));
  }
  minuteHand.draw(canvas);
  canvas.restore();
  if (scaled) {
    canvas.restore();
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(Canvas canvas){
  boolean changed=mChanged;
  if (changed) {
    mChanged=false;
  }
  int availableWidth=getRight() - getLeft();
  int availableHeight=getBottom() - getTop();
  int x=availableWidth / 2;
  int y=availableHeight / 2;
  int w=getWidth();
  int h=getHeight();
  boolean scaled=false;
  if (availableWidth < w || availableHeight < h) {
    scaled=true;
    float scale=min(availableWidth / (float)w,(float)availableHeight / h);
    canvas.save();
    canvas.scale(scale,scale,x,y);
  }
  canvas.save();
  if (mIsProgressSetViaApi) {
    markPointX=mCircleCenterX - (float)(mOuterRadius * cos(toRadians((mProgress * 360.0d / mMaxProgress) + 90.0d)));
    markPointY=mCircleCenterY - (float)(mOuterRadius * sin(toRadians((mProgress * 360.0d / mMaxProgress) + 90.0d)));
  }
  mMarkerPositionX=getXFromAngle();
  mMarkerPositionY=getYFromAngle();
  canvas.drawCircle(mCircleCenterX,mCircleCenterY,mOuterRadius,mCirclePaint);
  drawMarkerAtProgress(canvas);
  canvas.rotate(mProgress * 360.0f / mMaxProgress,x,y);
  final Drawable hourHand=mHourHand;
  if (changed) {
    w=hourHand.getIntrinsicWidth();
    h=hourHand.getIntrinsicHeight();
    hourHand.setBounds(x - (w / 2),y - (h / 2),x + (w / 2),y + (h / 2));
  }
  hourHand.draw(canvas);
  canvas.restore();
  canvas.save();
  canvas.rotate(0,x,y);
  final Drawable minuteHand=mMinuteHand;
  if (changed) {
    w=minuteHand.getIntrinsicWidth();
    h=minuteHand.getIntrinsicHeight();
    minuteHand.setBounds(x - (w / 2),y - (h / 2),x + (w / 2),y + (h / 2));
  }
  minuteHand.draw(canvas);
  canvas.restore();
  if (scaled) {
    canvas.restore();
  }
  super.onDraw(canvas);
}"
9028,"private void setProgressInternal(int progress){
  if (this.mProgress != progress) {
    this.mProgress=progress;
    if (!mFromUser) {
      int newPercent=(this.mProgress / this.mMaxProgress) * mMaxProgress;
      int newAngle=(newPercent / mMaxProgress) * TOTAL_DEGREES_INT;
      this.setAngle(newAngle);
      mProgressPercent=newPercent;
    }
    mListener.onProgressChanged(this,mProgress,mFromUser);
    mFromUser=false;
  }
}","private void setProgressInternal(int progress){
  if (this.mProgress != progress) {
    this.mProgress=progress;
    if (!mFromUser) {
      int newPercent=(this.mProgress / this.mMaxProgress) * mMaxProgress;
      int newAngle=(newPercent / mMaxProgress) * TOTAL_DEGREES_INT;
      this.setAngle(newAngle);
      mProgressPercent=newPercent;
    }
    if (mIsProgressSetViaApi) {
      mAngle=mProgress * 360.0f / mMaxProgress;
    }
    mListener.onProgressChanged(this,mProgress,mFromUser);
    mFromUser=false;
  }
}"
9029,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View rootView=inflater.inflate(R.layout.fragment_main,container,false);
  final ClockView minDepartTime=(ClockView)rootView.findViewById(R.id.min_depart_time_clock_view);
  DateTime minTime=new DateTime(2014,4,25,7,0);
  DateTime maxTime=new DateTime(2014,4,26,4,0);
  minDepartTime.setBounds(minTime,maxTime,false);
  final ClockView maxDepartTime=(ClockView)rootView.findViewById(R.id.max_depart_time_clock_view);
  maxDepartTime.setBounds(minTime,maxTime,true);
  minDepartTime.setClockTimeUpdateListener(new ClockView.ClockTimeUpdateListener(){
    @Override public void onClockTimeUpdate(    ClockView clockView,    DateTime currentTime){
      Log.e(""String_Node_Str"",String.valueOf(currentTime));
    }
  }
);
  TimerTask timerTask=new TimerTask(){
    @Override public void run(){
      Handler handler=new Handler(Looper.getMainLooper());
      handler.post(new Runnable(){
        @Override public void run(){
          minDepartTime.setNewCurrentTime(new DateTime(2014,4,25,10,0));
        }
      }
);
    }
  }
;
  Timer timer=new Timer();
  timer.schedule(timerTask,5000);
  return rootView;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View rootView=inflater.inflate(R.layout.fragment_main,container,false);
  final ClockView minDepartTime=(ClockView)rootView.findViewById(R.id.min_depart_time_clock_view);
  DateTime minTime=new DateTime(2014,4,25,7,0);
  DateTime maxTime=new DateTime(2014,4,26,4,0);
  minDepartTime.setBounds(minTime,maxTime,false);
  minDepartTime.setNewCurrentTime(new DateTime(2014,4,25,10,0));
  final ClockView maxDepartTime=(ClockView)rootView.findViewById(R.id.max_depart_time_clock_view);
  maxDepartTime.setBounds(minTime,maxTime,true);
  minDepartTime.setClockTimeUpdateListener(new ClockView.ClockTimeUpdateListener(){
    @Override public void onClockTimeUpdate(    ClockView clockView,    DateTime currentTime){
      Log.e(""String_Node_Str"",String.valueOf(currentTime));
    }
  }
);
  TimerTask timerTask=new TimerTask(){
    @Override public void run(){
      Handler handler=new Handler(Looper.getMainLooper());
      handler.post(new Runnable(){
        @Override public void run(){
          minDepartTime.setNewCurrentTime(new DateTime(2014,4,25,12,0));
        }
      }
);
    }
  }
;
  Timer timer=new Timer();
  timer.schedule(timerTask,5000);
  return rootView;
}"
9030,"@Override public void run(){
  minDepartTime.setNewCurrentTime(new DateTime(2014,4,25,10,0));
}","@Override public void run(){
  minDepartTime.setNewCurrentTime(new DateTime(2014,4,25,12,0));
}"
9031,"private void checkJsonValues() throws ParseException {
  if (!statusFileJsonMap.containsKey(SOURCE_NAME_STATUS_FILE) || !statusFileJsonMap.containsKey(URL_STATUS_FILE) || !statusFileJsonMap.containsKey(LAST_INDEX_STATUS_FILE)) {
    LOG.error(""String_Node_Str"");
    throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
  }
  if (!statusFileJsonMap.get(URL_STATUS_FILE).equals(connectionURL)) {
    LOG.error(""String_Node_Str"");
    throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
  }
 else   if (!statusFileJsonMap.get(SOURCE_NAME_STATUS_FILE).equals(sourceName)) {
    LOG.error(""String_Node_Str"");
    throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
  }
  if (customQuery == null) {
    if (!statusFileJsonMap.containsKey(COLUMNS_TO_SELECT_STATUS_FILE) || !statusFileJsonMap.containsKey(TABLE_STATUS_FILE)) {
      LOG.error(""String_Node_Str"");
      throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
    }
    if (!statusFileJsonMap.get(COLUMNS_TO_SELECT_STATUS_FILE).equals(columnsToSelect)) {
      LOG.error(""String_Node_Str"");
      throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
    }
    if (!statusFileJsonMap.get(TABLE_STATUS_FILE).equals(table)) {
      LOG.error(""String_Node_Str"");
      throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
    }
    return;
  }
  if (customQuery != null) {
    if (!statusFileJsonMap.containsKey(QUERY_STATUS_FILE) || !statusFileJsonMap.containsKey(INCREMENTAL_COLUMN_NAME_STATUS_FILE)) {
      LOG.error(""String_Node_Str"");
      throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
    }
    if (!statusFileJsonMap.get(QUERY_STATUS_FILE).equals(customQuery)) {
      LOG.error(""String_Node_Str"");
      throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
    }
    return;
  }
}","private void checkJsonValues() throws ParseException {
  if (!statusFileJsonMap.containsKey(SOURCE_NAME_STATUS_FILE) || !statusFileJsonMap.containsKey(URL_STATUS_FILE) || !statusFileJsonMap.containsKey(LAST_INDEX_STATUS_FILE)) {
    LOG.error(""String_Node_Str"");
    throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
  }
  if (!statusFileJsonMap.get(URL_STATUS_FILE).equals(connectionURL)) {
    LOG.error(""String_Node_Str"");
    throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
  }
 else   if (!statusFileJsonMap.get(SOURCE_NAME_STATUS_FILE).equals(sourceName)) {
    LOG.error(""String_Node_Str"");
    throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
  }
  if (customQuery == null) {
    if (!statusFileJsonMap.containsKey(COLUMNS_TO_SELECT_STATUS_FILE) || !statusFileJsonMap.containsKey(TABLE_STATUS_FILE)) {
      LOG.error(""String_Node_Str"");
      throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
    }
    if (!statusFileJsonMap.get(COLUMNS_TO_SELECT_STATUS_FILE).equals(columnsToSelect)) {
      LOG.error(""String_Node_Str"");
      throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
    }
    if (!statusFileJsonMap.get(TABLE_STATUS_FILE).equals(table)) {
      LOG.error(""String_Node_Str"");
      throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
    }
    return;
  }
  if (customQuery != null) {
    if (!statusFileJsonMap.containsKey(QUERY_STATUS_FILE)) {
      LOG.error(""String_Node_Str"");
      throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
    }
    if (!statusFileJsonMap.get(QUERY_STATUS_FILE).equals(customQuery)) {
      LOG.error(""String_Node_Str"");
      throw new ParseException(ERROR_UNEXPECTED_EXCEPTION);
    }
    return;
  }
}"
9032,"/** 
 * Create status file
 */
public void createStatusFile(){
  statusFileJsonMap.put(SOURCE_NAME_STATUS_FILE,sourceName);
  statusFileJsonMap.put(URL_STATUS_FILE,connectionURL);
  statusFileJsonMap.put(COLUMNS_TO_SELECT_STATUS_FILE,columnsToSelect);
  statusFileJsonMap.put(TABLE_STATUS_FILE,table);
  statusFileJsonMap.put(LAST_INDEX_STATUS_FILE,currentIndex);
  try {
    Writer fileWriter=new FileWriter(file,false);
    JSONValue.writeJSONString(statusFileJsonMap,fileWriter);
    fileWriter.close();
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}","/** 
 * Create status file
 */
public void createStatusFile(){
  statusFileJsonMap.put(SOURCE_NAME_STATUS_FILE,sourceName);
  statusFileJsonMap.put(URL_STATUS_FILE,connectionURL);
  statusFileJsonMap.put(LAST_INDEX_STATUS_FILE,currentIndex);
  if (isCustomQuerySet()) {
    statusFileJsonMap.put(QUERY_STATUS_FILE,customQuery);
  }
 else {
    statusFileJsonMap.put(COLUMNS_TO_SELECT_STATUS_FILE,columnsToSelect);
    statusFileJsonMap.put(TABLE_STATUS_FILE,table);
  }
  try {
    Writer fileWriter=new FileWriter(file,false);
    JSONValue.writeJSONString(statusFileJsonMap,fileWriter);
    fileWriter.close();
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}"
9033,"/** 
 * Builds an SQLSourceHelper containing the configuration parameters and usefull utils for SQL Source
 * @param context Flume source context, contains the properties from configuration file
 */
public SQLSourceHelper(Context context,String sourceName){
  this.context=context;
  statusFilePath=context.getString(""String_Node_Str"",DEFAULT_STATUS_DIRECTORY);
  statusFileName=context.getString(""String_Node_Str"");
  table=context.getString(""String_Node_Str"");
  columnsToSelect=context.getString(""String_Node_Str"",""String_Node_Str"");
  runQueryDelay=context.getInteger(""String_Node_Str"",DEFAULT_QUERY_DELAY);
  directory=new File(statusFilePath);
  customQuery=context.getString(""String_Node_Str"");
  batchSize=context.getInteger(""String_Node_Str"",DEFAULT_BATCH_SIZE);
  maxRows=context.getInteger(""String_Node_Str"",DEFAULT_MAX_ROWS);
  connectionURL=context.getString(""String_Node_Str"");
  this.sourceName=sourceName;
  startFrom=context.getString(""String_Node_Str"",DEFAULT_INCREMENTAL_VALUE);
  statusFileJsonMap=new LinkedHashMap<String,String>();
  checkMandatoryProperties();
  if (!(isStatusDirectoryCreated())) {
    createDirectory();
  }
  file=new File(statusFilePath + ""String_Node_Str"" + statusFileName);
  if (!isStatusFileCreated()) {
    currentIndex=startFrom;
    createStatusFile();
  }
 else   currentIndex=getStatusFileIndex(startFrom);
  query=buildQuery();
}","/** 
 * Builds an SQLSourceHelper containing the configuration parameters and usefull utils for SQL Source
 * @param context Flume source context, contains the properties from configuration file
 */
public SQLSourceHelper(Context context,String sourceName){
  this.context=context;
  statusFilePath=context.getString(""String_Node_Str"",DEFAULT_STATUS_DIRECTORY);
  statusFileName=context.getString(""String_Node_Str"");
  table=context.getString(""String_Node_Str"");
  columnsToSelect=context.getString(""String_Node_Str"",""String_Node_Str"");
  runQueryDelay=context.getInteger(""String_Node_Str"",DEFAULT_QUERY_DELAY);
  directory=new File(statusFilePath);
  customQuery=context.getString(""String_Node_Str"");
  batchSize=context.getInteger(""String_Node_Str"",DEFAULT_BATCH_SIZE);
  maxRows=context.getInteger(""String_Node_Str"",DEFAULT_MAX_ROWS);
  connectionURL=context.getString(""String_Node_Str"");
  readOnlySession=context.getBoolean(""String_Node_Str"",false);
  this.sourceName=sourceName;
  startFrom=context.getString(""String_Node_Str"",DEFAULT_INCREMENTAL_VALUE);
  statusFileJsonMap=new LinkedHashMap<String,String>();
  checkMandatoryProperties();
  if (!(isStatusDirectoryCreated())) {
    createDirectory();
  }
  file=new File(statusFilePath + ""String_Node_Str"" + statusFileName);
  if (!isStatusFileCreated()) {
    currentIndex=startFrom;
    createStatusFile();
  }
 else   currentIndex=getStatusFileIndex(startFrom);
  query=buildQuery();
}"
9034,"/** 
 * Process a batch of events performing SQL Queries
 */
@Override public Status process() throws EventDeliveryException {
  try {
    sqlSourceCounter.startProcess();
    List<List<Object>> result=hibernateHelper.executeQuery();
    if (!result.isEmpty()) {
      csvWriter.writeAll(sqlSourceHelper.getAllRows(result));
      csvWriter.flush();
      sqlSourceCounter.incrementEventCount(result.size());
      sqlSourceHelper.updateStatusFile();
    }
    sqlSourceCounter.endProcess(result.size());
    if (result.size() < sqlSourceHelper.getMaxRows()) {
      Thread.sleep(sqlSourceHelper.getRunQueryDelay());
    }
    return Status.READY;
  }
 catch (  IOException|InterruptedException e) {
    LOG.error(""String_Node_Str"",e);
    return Status.BACKOFF;
  }
}","/** 
 * Process a batch of events performing SQL Queries
 */
@Override public Status process() throws EventDeliveryException {
  try {
    sqlSourceCounter.startProcess();
    List<List<Object>> result=hibernateHelper.executeQuery();
    if (!result.isEmpty()) {
      csvWriter.writeAll(sqlSourceHelper.getAllRows(result));
      csvWriter.flush();
      sqlSourceCounter.incrementEventCount(result.size());
      sqlSourceHelper.updateStatusFile();
    }
    sqlSourceCounter.endProcess(result.size());
    if (result.size() < sqlSourceHelper.getMaxRows()) {
      hibernateHelper.resetConnectionAndSleep();
    }
    return Status.READY;
  }
 catch (  IOException|InterruptedException e) {
    LOG.error(""String_Node_Str"",e);
    return Status.BACKOFF;
  }
}"
9035,"/** 
 * Connect to database using hibernate
 */
public void establishSession(){
  LOG.info(""String_Node_Str"");
  serviceRegistry=new StandardServiceRegistryBuilder().applySettings(config.getProperties()).build();
  factory=config.buildSessionFactory(serviceRegistry);
  session=factory.openSession();
}","/** 
 * Connect to database using hibernate
 */
public void establishSession(){
  LOG.info(""String_Node_Str"");
  serviceRegistry=new StandardServiceRegistryBuilder().applySettings(config.getProperties()).build();
  factory=config.buildSessionFactory(serviceRegistry);
  session=factory.openSession();
  session.setCacheMode(CacheMode.IGNORE);
  session.setDefaultReadOnly(sqlSourceHelper.isReadOnlySession());
}"
9036,"/** 
 * Execute the selection query in the database
 * @return The query result. Each Object is a cell content. <p>The cell contents use database types (date,int,string...),  keep in mind in case of future conversions/castings.
 */
@SuppressWarnings(""String_Node_Str"") public List<List<Object>> executeQuery(){
  List<List<Object>> rowsList;
  if (sqlSourceHelper.isCustomQuerySet()) {
    if (sqlSourceHelper.getMaxRows() == 0) {
      rowsList=session.createSQLQuery(sqlSourceHelper.buildQuery()).setResultTransformer(Transformers.TO_LIST).list();
    }
 else {
      rowsList=session.createSQLQuery(sqlSourceHelper.buildQuery()).setMaxResults(sqlSourceHelper.getMaxRows()).setResultTransformer(Transformers.TO_LIST).list();
    }
    if (!rowsList.isEmpty())     sqlSourceHelper.setCurrentIndex(rowsList.get(rowsList.size() - 1).get(0).toString());
  }
 else {
    if (sqlSourceHelper.getMaxRows() == 0) {
      rowsList=session.createSQLQuery(sqlSourceHelper.getQuery()).setFirstResult(Integer.parseInt(sqlSourceHelper.getCurrentIndex())).setResultTransformer(Transformers.TO_LIST).list();
    }
 else {
      rowsList=session.createSQLQuery(sqlSourceHelper.getQuery()).setFirstResult(Integer.parseInt(sqlSourceHelper.getCurrentIndex())).setMaxResults(sqlSourceHelper.getMaxRows()).setResultTransformer(Transformers.TO_LIST).list();
    }
    sqlSourceHelper.setCurrentIndex(Integer.toString((Integer.parseInt(sqlSourceHelper.getCurrentIndex()) + rowsList.size())));
  }
  return rowsList;
}","/** 
 * Execute the selection query in the database
 * @return The query result. Each Object is a cell content. <p>The cell contents use database types (date,int,string...),  keep in mind in case of future conversions/castings.
 * @throws InterruptedException 
 */
@SuppressWarnings(""String_Node_Str"") public List<List<Object>> executeQuery() throws InterruptedException {
  List<List<Object>> rowsList=new ArrayList<List<Object>>();
  Query query;
  if (!session.isConnected()) {
    resetConnection();
  }
  if (sqlSourceHelper.isCustomQuerySet()) {
    query=session.createSQLQuery(sqlSourceHelper.buildQuery());
    if (sqlSourceHelper.getMaxRows() != 0) {
      query=query.setMaxResults(sqlSourceHelper.getMaxRows());
    }
  }
 else {
    query=session.createSQLQuery(sqlSourceHelper.getQuery()).setFirstResult(Integer.parseInt(sqlSourceHelper.getCurrentIndex()));
    if (sqlSourceHelper.getMaxRows() != 0) {
      query=query.setMaxResults(sqlSourceHelper.getMaxRows());
    }
  }
  try {
    rowsList=query.setResultTransformer(Transformers.TO_LIST).list();
  }
 catch (  Exception e) {
    resetConnection();
  }
  if (!rowsList.isEmpty()) {
    if (sqlSourceHelper.isCustomQuerySet()) {
      sqlSourceHelper.setCurrentIndex(rowsList.get(rowsList.size() - 1).get(0).toString());
    }
 else {
      sqlSourceHelper.setCurrentIndex(Integer.toString((Integer.parseInt(sqlSourceHelper.getCurrentIndex()) + rowsList.size())));
    }
  }
  return rowsList;
}"
9037,"public void endProcess(int events){
  long runningTime=System.currentTimeMillis() - getStartTime();
  long processTime=System.currentTimeMillis() - startProcessTime;
  long throughput=0L;
  if (events > 0 && processTime > 0)   throughput=1000 * events / processTime;
  if (getMaxThroughput() < throughput)   set(MAX_THROUGHPUT,throughput);
  set(AVERAGE_THROUGHPUT,getEventCount() / (runningTime / 1000));
  set(CURRENT_THROUGHPUT,throughput);
}","public void endProcess(int events){
  long runningTime=TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - getStartTime());
  long processTime=TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startProcessTime);
  long throughput=0L;
  if (events > 0 && processTime > 0)   throughput=events / processTime;
  if (getMaxThroughput() < throughput)   set(MAX_THROUGHPUT,throughput);
  if (runningTime > 0 && getEventCount() > 0)   set(AVERAGE_THROUGHPUT,(getEventCount() / runningTime));
  set(CURRENT_THROUGHPUT,throughput);
}"
9038,"public List<String[]> getAllRows(List<List<Object>> queryResult){
  List<String[]> allRows=new ArrayList<String[]>(queryResult.size());
  if (queryResult == null || queryResult.isEmpty())   return allRows;
  String[] row=null;
  for (int i=0; i < queryResult.size(); i++) {
    List<Object> rawRow=queryResult.get(i);
    row=new String[rawRow.size()];
    for (int j=0; j < rawRow.size(); j++) {
      row[j]=rawRow.get(j).toString();
    }
    allRows.add(row);
  }
  return allRows;
}","public List<String[]> getAllRows(List<List<Object>> queryResult){
  List<String[]> allRows=new ArrayList<String[]>();
  if (queryResult == null || queryResult.isEmpty())   return allRows;
  String[] row=null;
  for (int i=0; i < queryResult.size(); i++) {
    List<Object> rawRow=queryResult.get(i);
    row=new String[rawRow.size()];
    for (int j=0; j < rawRow.size(); j++) {
      row[j]=rawRow.get(j).toString();
    }
    allRows.add(row);
  }
  return allRows;
}"
9039,"@Test public void chekGetAllRowsWithNullParam(){
  SQLSourceHelper sqlSourceHelper=new SQLSourceHelper(context);
  assertEquals(null,sqlSourceHelper.getAllRows(null));
}","@Test public void chekGetAllRowsWithNullParam(){
  SQLSourceHelper sqlSourceHelper=new SQLSourceHelper(context);
  assertEquals(new ArrayList<String>(),sqlSourceHelper.getAllRows(null));
}"
9040,"/** 
 * Converter from a List of Object List to a List of String arrays <p> Useful for csvWriter
 * @param queryResult Query Result from hibernate executeQuery method
 * @return A list of String arrays, ready for csvWriter.writeall method
 */
public List<String[]> getAllRows(List<List<Object>> queryResult){
  List<String[]> allRows=new ArrayList<String[]>();
  if (queryResult == null || queryResult.isEmpty())   return allRows;
  String[] row=null;
  for (int i=0; i < queryResult.size(); i++) {
    List<Object> rawRow=queryResult.get(i);
    row=new String[rawRow.size()];
    for (int j=0; j < rawRow.size(); j++) {
      row[j]=rawRow.get(j).toString();
    }
    allRows.add(row);
  }
  return allRows;
}","/** 
 * Converter from a List of Object List to a List of String arrays <p> Useful for csvWriter
 * @param queryResult Query Result from hibernate executeQuery method
 * @return A list of String arrays, ready for csvWriter.writeall method
 */
public List<String[]> getAllRows(List<List<Object>> queryResult){
  List<String[]> allRows=new ArrayList<String[]>();
  if (queryResult == null || queryResult.isEmpty())   return allRows;
  String[] row=null;
  for (int i=0; i < queryResult.size(); i++) {
    List<Object> rawRow=queryResult.get(i);
    row=new String[rawRow.size()];
    for (int j=0; j < rawRow.size(); j++) {
      if (rawRow.get(j) != null)       row[j]=rawRow.get(j).toString();
 else       row[j]=""String_Node_Str"";
    }
    allRows.add(row);
  }
  return allRows;
}"
9041,"/** 
 * Runs the query and returns a Vector of Vectors as a result
 * @param mQuery
 * @return Vector<Vector<String>>
 * @throws SQLException
 */
public Vector<Vector<String>> runQuery(String mQuery) throws SQLException {
  Vector<Vector<String>> mResults=new Vector<Vector<String>>();
  Statement mStatement=(Statement)this.mConnection.createStatement();
  ResultSet mResultSet=mStatement.executeQuery(mQuery);
  mMetaData=mResultSet.getMetaData();
  int mNumColumns=mMetaData.getColumnCount();
  setColumns(mNumColumns,mMetaData);
  while (mResultSet.next()) {
    Vector<String> mRow=new Vector<String>();
    for (int i=1; i <= mNumColumns; i++) {
      mRow.add(mResultSet.getString(i));
    }
    mResults.add(mRow);
  }
  return mResults;
}","/** 
 * Runs the query and returns a Vector of Vectors as a result
 * @param mQuery
 * @return Vector<Vector<String>>
 * @throws SQLException
 */
public ResultSet runQuery(String mQuery) throws SQLException {
  Statement mStatement=(Statement)this.mConnection.createStatement();
  ResultSet mResultSet=mStatement.executeQuery(mQuery);
  mMetaData=mResultSet.getMetaData();
  int mNumColumns=mMetaData.getColumnCount();
  setColumns(mNumColumns,mMetaData);
  return mResultSet;
}"
9042,"public Status process() throws EventDeliveryException {
  List<Event> eventList=new ArrayList<Event>();
  byte[] message;
  Event event;
  Map<String,String> headers;
  try {
    String where=""String_Node_Str"" + incrementalColumnName + ""String_Node_Str""+ incrementalValue;
    String query=""String_Node_Str"" + columnsToSelect + ""String_Node_Str""+ table+ where+ ""String_Node_Str""+ incrementalColumnName+ ""String_Node_Str"";
    log.debug(""String_Node_Str"" + query);
    Vector<Vector<String>> queryResult=mDAO.runQuery(query);
    Vector<String> columns=mDAO.getColumns();
    boolean columnPosFind;
    String queryResultRow;
    columnPosFind=false;
    int incrementalColumnPosition=0;
    do {
      if (columns.get(incrementalColumnPosition).equals(incrementalColumnName))       columnPosFind=true;
 else       incrementalColumnPosition++;
    }
 while (!columnPosFind);
    if (!queryResult.isEmpty()) {
      incrementalValue=Long.parseLong(queryResult.lastElement().get(incrementalColumnPosition),10);
      log.info(""String_Node_Str"" + queryResult.toString());
      for (int i=0; i < queryResult.size(); i++) {
        queryResultRow=queryResult.get(i).toString();
        queryResultRow=queryResultRow.substring(1,queryResultRow.length() - 1);
        message=queryResultRow.getBytes();
        event=new SimpleEvent();
        headers=new HashMap<String,String>();
        headers.put(""String_Node_Str"",String.valueOf(System.currentTimeMillis()));
        log.debug(""String_Node_Str"",new String(message));
        event.setBody(message);
        event.setHeaders(headers);
        eventList.add(event);
      }
      getChannelProcessor().processEventBatch(eventList);
      log.info(""String_Node_Str"" + incrementalValue + ""String_Node_Str"");
      sqlSourceUtils.updateStatusFile(incrementalValue);
    }
    Thread.sleep(runQueryDelay);
    return Status.READY;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"");
    e.printStackTrace();
    return Status.BACKOFF;
  }
catch (  InterruptedException e) {
    e.printStackTrace();
    return Status.BACKOFF;
  }
}","public Status process() throws EventDeliveryException {
  byte[] message;
  Event event;
  Map<String,String> headers;
  try {
    String where=""String_Node_Str"" + incrementalColumnName + ""String_Node_Str""+ incrementalValue;
    String query=""String_Node_Str"" + columnsToSelect + ""String_Node_Str""+ table+ where+ ""String_Node_Str""+ incrementalColumnName+ ""String_Node_Str"";
    log.info(""String_Node_Str"" + query);
    ResultSet queryResult=mDAO.runQuery(query);
    String queryResultRow;
    ResultSetMetaData mMetaData=queryResult.getMetaData();
    int mNumColumns=mMetaData.getColumnCount();
    int a=0;
    while (queryResult.next()) {
      a++;
      queryResultRow=""String_Node_Str"";
      for (int i=1; i <= mNumColumns - 1; i++) {
        queryResultRow=queryResultRow + queryResult.getString(i) + ""String_Node_Str"";
      }
      queryResultRow=queryResultRow + queryResult.getString(mNumColumns);
      message=queryResultRow.getBytes();
      event=new SimpleEvent();
      headers=new HashMap<String,String>();
      headers.put(""String_Node_Str"",String.valueOf(System.currentTimeMillis()));
      event.setBody(message);
      event.setHeaders(headers);
      getChannelProcessor().processEvent(event);
    }
    if (queryResult.last()) {
      incrementalValue=Long.parseLong(queryResult.getString(incrementalColumnName),10);
      log.info(""String_Node_Str"" + incrementalValue + ""String_Node_Str"");
      sqlSourceUtils.updateStatusFile(incrementalValue);
    }
    Thread.sleep(runQueryDelay);
    return Status.READY;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"");
    e.printStackTrace();
    return Status.BACKOFF;
  }
catch (  InterruptedException e) {
    e.printStackTrace();
    return Status.BACKOFF;
  }
}"
9043,"/** 
 * Gets the image's pixels via BufferedImage.getRGB(..). Slow, but the fast method doesn't work for all color models.
 * @param sourceImage the source image
 * @param quality 1 is the highest quality settings. 10 is the default. There is a trade-off between quality and speed. The bigger the number, the faster the palette generation but the greater the likelihood that colors will be missed.
 * @param ignoreWhite if <code>true</code>, white pixels are ignored
 * @return an array of pixels (each an RGB int array)
 */
private static int[][] getPixelsSlow(BufferedImage sourceImage,int quality,boolean ignoreWhite){
  int width=sourceImage.getWidth();
  int height=sourceImage.getHeight();
  int pixelCount=width * height;
  int numRegardedPixels=(pixelCount + quality - 1) / quality;
  int numUsedPixels=0;
  int[][] res=new int[numRegardedPixels][];
  int r, g, b;
  for (int i=0; i < pixelCount; i+=quality) {
    int row=i / width;
    int col=i % width;
    int rgb=sourceImage.getRGB(col,row);
    r=(rgb >> 16) & 0xFF;
    g=(rgb >> 8) & 0xFF;
    b=(rgb) & 0xFF;
    if (!(ignoreWhite && r > 250 && r > 250 && r > 250)) {
      res[numUsedPixels]=new int[]{r,g,b};
      numUsedPixels++;
    }
  }
  return Arrays.copyOfRange(res,0,numUsedPixels);
}","/** 
 * Gets the image's pixels via BufferedImage.getRGB(..). Slow, but the fast method doesn't work for all color models.
 * @param sourceImage the source image
 * @param quality 1 is the highest quality settings. 10 is the default. There is a trade-off between quality and speed. The bigger the number, the faster the palette generation but the greater the likelihood that colors will be missed.
 * @param ignoreWhite if <code>true</code>, white pixels are ignored
 * @return an array of pixels (each an RGB int array)
 */
private static int[][] getPixelsSlow(BufferedImage sourceImage,int quality,boolean ignoreWhite){
  int width=sourceImage.getWidth();
  int height=sourceImage.getHeight();
  int pixelCount=width * height;
  int numRegardedPixels=(pixelCount + quality - 1) / quality;
  int numUsedPixels=0;
  int[][] res=new int[numRegardedPixels][];
  int r, g, b;
  for (int i=0; i < pixelCount; i+=quality) {
    int row=i / width;
    int col=i % width;
    int rgb=sourceImage.getRGB(col,row);
    r=(rgb >> 16) & 0xFF;
    g=(rgb >> 8) & 0xFF;
    b=(rgb) & 0xFF;
    if (!(ignoreWhite && r > 250 && g > 250 && b > 250)) {
      res[numUsedPixels]=new int[]{r,g,b};
      numUsedPixels++;
    }
  }
  return Arrays.copyOfRange(res,0,numUsedPixels);
}"
9044,"@Override public int compare(VBox a,VBox b){
  int aCount=a.count(false);
  int bCount=b.count(false);
  int aVolume=a.volume(false);
  int bVolume=b.volume(false);
  if (aCount == bCount) {
    return aVolume - bVolume;
  }
  return aCount * aVolume - bCount * bVolume;
}","@Override public int compare(VBox a,VBox b){
  int aCount=a.count(false);
  int bCount=b.count(false);
  int aVolume=a.volume(false);
  int bVolume=b.volume(false);
  if (aCount == bCount) {
    return aVolume - bVolume;
  }
  return Long.compare((long)aCount * aVolume,(long)bCount * bVolume);
}"
9045,"@DataProvider(name=""String_Node_Str"") public Object[][] getRelativeCases(){
  return new Object[][]{{""String_Node_Str"",true},{""String_Node_Str"",true},{""String_Node_Str"",true},{""String_Node_Str"",true},{""String_Node_Str"",true},{""String_Node_Str"",false}};
}","@DataProvider(name=""String_Node_Str"") public Object[][] getRelativeCases(){
  return new Object[][]{{""String_Node_Str"",true},{""String_Node_Str"",true},{""String_Node_Str"",true},{""String_Node_Str"",true},{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",true},{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",false}};
}"
9046,"private void auditAccessMessage(AuditEventPublisher auditEventPublisher,AuditEventFactory auditEventFactory,LogRecord record,String realm){
  if (!auditEventPublisher.isAuditing(realm,AuditConstants.ACCESS_TOPIC,EventName.AM_ACCESS_ATTEMPT)) {
    return;
  }
  AgentLogParser logParser=new AgentLogParser();
  LogExtracts logExtracts=logParser.tryParse(record.getMessage());
  if (logExtracts == null) {
    return;
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,String> info=record.getLogInfoMap();
  String clientIp=info.get(LogConstants.IP_ADDR);
  if (StringUtils.isEmpty(clientIp)) {
    clientIp=info.get(LogConstants.HOST_NAME);
  }
  String contextId=info.get(LogConstants.CONTEXT_ID);
  String clientId=info.get(LogConstants.LOGIN_ID);
  String resourceUrl=logExtracts.getResourceUrl();
  int queryStringIndex=resourceUrl.indexOf('?');
  String queryString=queryStringIndex > -1 ? resourceUrl.substring(queryStringIndex) : ""String_Node_Str"";
  String path=resourceUrl.replace(queryString,""String_Node_Str"");
  Map<String,List<String>> queryParameters=AMAuditEventBuilderUtils.getQueryParametersAsMap(queryString);
  AuditEvent auditEvent=auditEventFactory.accessEvent(realm).transactionId(AuditRequestContext.getTransactionIdValue()).eventName(EventName.AM_ACCESS_OUTCOME).component(Component.POLICY_AGENT).userId(clientId).httpRequest(hasSecureScheme(resourceUrl),""String_Node_Str"",path,queryParameters,Collections.<String,List<String>>emptyMap()).request(""String_Node_Str"",""String_Node_Str"").client(clientIp).trackingId(contextId).response(logExtracts.getStatus(),logExtracts.getStatusCode(),-1,MILLISECONDS).toEvent();
  auditEventPublisher.tryPublish(AuditConstants.ACCESS_TOPIC,auditEvent);
}","private void auditAccessMessage(AuditEventPublisher auditEventPublisher,AuditEventFactory auditEventFactory,LogRecord record,String realm){
  AgentLogParser logParser=new AgentLogParser();
  LogExtracts logExtracts=logParser.tryParse(record.getMessage());
  if (logExtracts == null) {
    return;
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,String> info=record.getLogInfoMap();
  String clientIp=info.get(LogConstants.IP_ADDR);
  if (StringUtils.isEmpty(clientIp)) {
    clientIp=info.get(LogConstants.HOST_NAME);
  }
  String contextId=info.get(LogConstants.CONTEXT_ID);
  String clientId=info.get(LogConstants.LOGIN_ID);
  String resourceUrl=logExtracts.getResourceUrl();
  int queryStringIndex=resourceUrl.indexOf('?');
  String queryString=queryStringIndex > -1 ? resourceUrl.substring(queryStringIndex) : ""String_Node_Str"";
  String path=resourceUrl.replace(queryString,""String_Node_Str"");
  Map<String,List<String>> queryParameters=AMAuditEventBuilderUtils.getQueryParametersAsMap(queryString);
  AuditEvent auditEvent=auditEventFactory.accessEvent(realm).transactionId(AuditRequestContext.getTransactionIdValue()).eventName(EventName.AM_ACCESS_OUTCOME).component(Component.POLICY_AGENT).userId(clientId).httpRequest(hasSecureScheme(resourceUrl),""String_Node_Str"",path,queryParameters,Collections.<String,List<String>>emptyMap()).request(""String_Node_Str"",""String_Node_Str"").client(clientIp).trackingId(contextId).response(logExtracts.getStatus(),logExtracts.getStatusCode(),-1,MILLISECONDS).toEvent();
  auditEventPublisher.tryPublish(AuditConstants.ACCESS_TOPIC,auditEvent);
}"
9047,"public static void changePassword(Context serverContext,String realm,String username,String oldPassword,String newPassword) throws ResourceException {
  try {
    SSOToken token=serverContext.asContext(SSOTokenContext.class).getCallerSSOToken();
    AMIdentity userIdentity=new AMIdentity(token,username,IdType.USER,realm,null);
    userIdentity.changePassword(oldPassword,newPassword);
  }
 catch (  SSOException ssoe) {
    debug.warning(""String_Node_Str"" + ""String_Node_Str"" + username,ssoe);
    throw new PermanentException(401,""String_Node_Str"",ssoe);
  }
catch (  IdRepoException ire) {
    if (IdRepoBundle.ACCESS_DENIED.equals(ire.getErrorCode())) {
      throw new ForbiddenException(""String_Node_Str"");
    }
 else {
      debug.warning(""String_Node_Str"" + ""String_Node_Str"" + username,ire);
      throw new InternalServerErrorException(""String_Node_Str"",ire);
    }
  }
}","public static void changePassword(Context serverContext,String realm,String username,String oldPassword,String newPassword) throws ResourceException {
  try {
    SSOToken token=serverContext.asContext(SSOTokenContext.class).getCallerSSOToken();
    AMIdentity userIdentity=new AMIdentity(token,username,IdType.USER,realm,null);
    userIdentity.changePassword(oldPassword,newPassword);
  }
 catch (  SSOException ssoe) {
    debug.warning(""String_Node_Str"" + ""String_Node_Str"" + username,ssoe);
    throw new PermanentException(401,""String_Node_Str"",ssoe);
  }
catch (  IdRepoException ire) {
    if (IdRepoBundle.ACCESS_DENIED.equals(ire.getErrorCode())) {
      throw new ForbiddenException(""String_Node_Str"");
    }
 else     if (LDAPConstants.LDAP_INVALID_CREDENTIALS.equals(ire.getLDAPErrorCode())) {
      throw ResourceException.newResourceException(401,""String_Node_Str"");
    }
 else {
      debug.warning(""String_Node_Str"" + ""String_Node_Str"" + username,ire);
      throw new InternalServerErrorException(""String_Node_Str"",ire);
    }
  }
}"
9048,"/** 
 * Updates an   {@code AMIdentity} in the identity repository with thedetails specified in  {@code identity}.
 * @param identity The updated identity details.
 * @param admin The admin token.
 * @throws ResourceException If a problem occurs.
 */
public void update(IdentityDetails identity,SSOToken admin) throws ResourceException {
  String idName=identity.getName();
  String idType=identity.getType();
  String realm=identity.getRealm();
  if (StringUtils.isEmpty(idName)) {
    throw new BadRequestException(""String_Node_Str"");
  }
  if (StringUtils.isEmpty(idType)) {
    idType=""String_Node_Str"";
  }
  if (realm == null) {
    realm=""String_Node_Str"";
  }
  try {
    IdType objectIdType=getIdType(idType);
    AMIdentityRepository repo=getRepo(admin,realm);
    if (!isOperationSupported(repo,objectIdType,IdOperation.EDIT)) {
      throw new ForbiddenException(""String_Node_Str"");
    }
    AMIdentity amIdentity=getAMIdentity(admin,repo,idType,idName);
    if (amIdentity == null) {
      String msg=""String_Node_Str"" + idName + ""String_Node_Str""+ idType+ ""String_Node_Str"";
      throw new NotFoundException(msg);
    }
    if (isSpecialUser(amIdentity)) {
      throw new ForbiddenException(""String_Node_Str"");
    }
    Map<String,Set<String>> attrs=asMap(identity.getAttributes());
    if (attrs != null && !attrs.isEmpty()) {
      Map<String,Set<String>> idAttrs=new HashMap<>();
      Set<String> removeAttrs=new HashSet<>();
      for (      Map.Entry<String,Set<String>> entry : attrs.entrySet()) {
        String attrName=entry.getKey();
        Set<String> attrValues=entry.getValue();
        if (attrValues != null && !attrValues.isEmpty()) {
          idAttrs.put(attrName,attrValues);
        }
 else {
          removeAttrs.add(attrName);
        }
      }
      boolean storeNeeded=false;
      if (!idAttrs.isEmpty()) {
        amIdentity.setAttributes(idAttrs);
        storeNeeded=true;
      }
      if (!removeAttrs.isEmpty()) {
        amIdentity.removeAttributes(removeAttrs);
        storeNeeded=true;
      }
      if (storeNeeded) {
        amIdentity.store();
      }
    }
    if (IdType.USER.equals(objectIdType)) {
      Set<String> roles=asSet(identity.getRoleList());
      if (!roles.isEmpty()) {
        setMemberships(repo,amIdentity,roles,IdType.ROLE);
      }
      Set<String> groups=asSet(identity.getGroupList());
      if (!groups.isEmpty()) {
        setMemberships(repo,amIdentity,groups,IdType.GROUP);
      }
    }
    if (IdType.GROUP.equals(objectIdType) || IdType.ROLE.equals(objectIdType)) {
      Set<String> members=asSet(identity.getMemberList());
      if (!members.isEmpty()) {
        setMembers(repo,amIdentity,members,IdType.USER);
      }
    }
  }
 catch (  IdRepoException ex) {
    debug.error(""String_Node_Str"",ex);
    if (LDAPConstants.CONSTRAINT_VIOLATED_ERROR.equals(ex.getErrorCode())) {
      throw new InternalServerErrorException(ex.getConstraintViolationDetails());
    }
    if (LDAPConstants.LDAP_INVALID_SYNTAX.equals(ex.getLDAPErrorCode())) {
      throw new BadRequestException(""String_Node_Str"");
    }
    throw convertToResourceException(idServicesErrorHandler.handleError(ex));
  }
catch (  SSOException ex) {
    debug.error(""String_Node_Str"",ex);
    throw new BadRequestException(ex.getMessage());
  }
catch (  ObjectNotFound e) {
    debug.error(""String_Node_Str"",e);
    throw new NotFoundException(e.getMessage());
  }
}","/** 
 * Updates an   {@code AMIdentity} in the identity repository with thedetails specified in  {@code identity}.
 * @param identity The updated identity details.
 * @param admin The admin token.
 * @throws ResourceException If a problem occurs.
 */
public void update(IdentityDetails identity,SSOToken admin) throws ResourceException {
  String idName=identity.getName();
  String idType=identity.getType();
  String realm=identity.getRealm();
  if (StringUtils.isEmpty(idName)) {
    throw new BadRequestException(""String_Node_Str"");
  }
  if (StringUtils.isEmpty(idType)) {
    idType=""String_Node_Str"";
  }
  if (realm == null) {
    realm=""String_Node_Str"";
  }
  try {
    IdType objectIdType=getIdType(idType);
    AMIdentityRepository repo=getRepo(admin,realm);
    if (!isOperationSupported(repo,objectIdType,IdOperation.EDIT)) {
      throw new ForbiddenException(""String_Node_Str"");
    }
    AMIdentity amIdentity=getAMIdentity(admin,repo,idType,idName);
    if (amIdentity == null) {
      String msg=""String_Node_Str"" + idName + ""String_Node_Str""+ idType+ ""String_Node_Str"";
      throw new NotFoundException(msg);
    }
    if (isSpecialUser(amIdentity)) {
      throw new ForbiddenException(""String_Node_Str"");
    }
    Map<String,Set<String>> attrs=asMap(identity.getAttributes());
    if (attrs != null && !attrs.isEmpty()) {
      Map<String,Set<String>> idAttrs=new HashMap<>();
      Set<String> removeAttrs=new HashSet<>();
      for (      Map.Entry<String,Set<String>> entry : attrs.entrySet()) {
        String attrName=entry.getKey();
        Set<String> attrValues=entry.getValue();
        if (attrValues != null && !attrValues.isEmpty()) {
          idAttrs.put(attrName,attrValues);
        }
 else {
          removeAttrs.add(attrName);
        }
      }
      boolean storeNeeded=false;
      if (!idAttrs.isEmpty()) {
        amIdentity.setAttributes(idAttrs);
        storeNeeded=true;
      }
      if (!removeAttrs.isEmpty()) {
        amIdentity.removeAttributes(removeAttrs);
        storeNeeded=true;
      }
      if (storeNeeded) {
        amIdentity.store();
      }
    }
    if (IdType.USER.equals(objectIdType)) {
      Set<String> roles=asSet(identity.getRoleList());
      if (!roles.isEmpty()) {
        setMemberships(repo,amIdentity,roles,IdType.ROLE);
      }
      Set<String> groups=asSet(identity.getGroupList());
      if (!groups.isEmpty()) {
        setMemberships(repo,amIdentity,groups,IdType.GROUP);
      }
    }
    if (IdType.GROUP.equals(objectIdType) || IdType.ROLE.equals(objectIdType)) {
      Set<String> members=asSet(identity.getMemberList());
      if (!members.isEmpty()) {
        setMembers(repo,amIdentity,members,IdType.USER);
      }
    }
  }
 catch (  IdRepoException ex) {
    debug.error(""String_Node_Str"",ex);
    if (LDAPConstants.CONSTRAINT_VIOLATED_ERROR.equals(ex.getErrorCode())) {
      throw new InternalServerErrorException(ex.getConstraintViolationDetails());
    }
 else     if (LDAPConstants.LDAP_INVALID_SYNTAX.equals(ex.getLDAPErrorCode())) {
      throw new BadRequestException(""String_Node_Str"");
    }
 else     if (LDAPConstants.ILLEGAL_ARGS_ERROR.equals(ex.getErrorCode())) {
      throw new BadRequestException(ex);
    }
    throw convertToResourceException(idServicesErrorHandler.handleError(ex));
  }
catch (  SSOException ex) {
    debug.error(""String_Node_Str"",ex);
    throw new BadRequestException(ex.getMessage());
  }
catch (  ObjectNotFound e) {
    debug.error(""String_Node_Str"",e);
    throw new NotFoundException(e.getMessage());
  }
}"
9049,"/** 
 * Validates attributes for create or modify operation. 
 * @param attrMap attributes map to be validated.
 * @param idOp operaton which is ethier <code>IdOperation.CREATE</code> or<code>IdOperation.EDIT</code>
 * @throws IdRepoException If attributes can't be validated or there arerepository related error conditions.
 */
public void validateAttributes(Map<String,Set<String>> attrMap,IdOperation idOp) throws IdRepoException ;","/** 
 * Validates attributes for create or modify operation. 
 * @param attrMap attributes map to be validated.
 * @param idOp operation which is either <code>IdOperation.CREATE</code> or<code>IdOperation.EDIT</code>
 * @throws IdRepoException If attributes can't be validated or there arerepository related error conditions.
 */
void validateAttributes(Map<String,Set<String>> attrMap,IdOperation idOp) throws IdRepoException ;"
9050,"/** 
 * Initialization paramters as configred for a given plugin.
 * @param configParams configuration parameters
 */
public void initialize(Map<String,Set<String>> configParams);","/** 
 * Initialization parameters as configured for a given plugin.
 * @param configParams configuration parameters
 */
void initialize(Map<String,Set<String>> configParams);"
9051,"/** 
 * Validates attributes for create or modify operation. 
 * @param attrMap attributes map to be validated.
 * @param idOp operaton which is ethier <code>IdOperation.CREATE</code> or<code>IdOperation.EDIT</code>
 * @throws IdRepoException If attributes can't be validated or there arerepository related error conditions.
 */
public void validateAttributes(Map<String,Set<String>> attrMap,IdOperation idOp) throws IdRepoException {
  if (minPasswordLength == 0) {
    return;
  }
  attrMap=new CaseInsensitiveHashMap(attrMap);
  if (!attrMap.containsKey(ATTR_USER_PASSWORD)) {
    if (idOp.equals(IdOperation.CREATE)) {
      Object[] args={""String_Node_Str"" + minPasswordLength};
      throw new IdRepoException(IdRepoBundle.BUNDLE_NAME,""String_Node_Str"",args);
    }
  }
 else {
    Set<String> values=attrMap.get(ATTR_USER_PASSWORD);
    if ((values == null) || (values.isEmpty())) {
      Object[] args={""String_Node_Str"" + minPasswordLength};
      throw new IdRepoException(IdRepoBundle.BUNDLE_NAME,""String_Node_Str"",args);
    }
 else {
      String password=values.iterator().next();
      if (password.length() < minPasswordLength) {
        Object[] args={""String_Node_Str"" + minPasswordLength};
        throw new IdRepoException(IdRepoBundle.BUNDLE_NAME,""String_Node_Str"",args);
      }
    }
  }
}","@Override public void validateAttributes(Map<String,Set<String>> attrMap,IdOperation idOp) throws IdRepoException {
  if (minPasswordLength == 0) {
    return;
  }
  attrMap=new CaseInsensitiveHashMap(attrMap);
  if (!attrMap.containsKey(ATTR_USER_PASSWORD)) {
    if (idOp.equals(IdOperation.CREATE)) {
      Object[] args={""String_Node_Str"" + minPasswordLength};
      throw new IdRepoException(IdRepoBundle.BUNDLE_NAME,""String_Node_Str"",args);
    }
  }
 else {
    Set<String> values=attrMap.get(ATTR_USER_PASSWORD);
    if ((values == null) || (values.isEmpty())) {
      Object[] args={""String_Node_Str"" + minPasswordLength};
      throw new IdRepoException(IdRepoBundle.BUNDLE_NAME,""String_Node_Str"",args);
    }
 else {
      String password=values.iterator().next();
      if (password.length() < minPasswordLength) {
        Object[] args={""String_Node_Str"" + minPasswordLength};
        throw new IdRepoException(IdRepoBundle.BUNDLE_NAME,""String_Node_Str"",args);
      }
    }
  }
}"
9052,"/** 
 * Initialization paramters as configred for a given plugin.
 * @param configParams configuration parameters
 */
public void initialize(Map<String,Set<String>> configParams){
  if ((configParams == null) || configParams.isEmpty()) {
    return;
  }
  for (  String name : configParams.keySet()) {
    if (name.equals(PROP_MIN_PASSWORD_LENGTH)) {
      Set<String> values=configParams.get(name);
      if ((values != null) && (!values.isEmpty())) {
        String value=values.iterator().next();
        try {
          minPasswordLength=Integer.parseInt(value);
          if (minPasswordLength < 0) {
            minPasswordLength=0;
          }
        }
 catch (        NumberFormatException nfe) {
          if (debug.warningEnabled()) {
            debug.warning(""String_Node_Str"" + ""String_Node_Str"",nfe);
          }
        }
      }
    }
  }
}","@Override public void initialize(Map<String,Set<String>> configParams){
  if ((configParams == null) || configParams.isEmpty()) {
    return;
  }
  for (  String name : configParams.keySet()) {
    if (name.equals(PROP_MIN_PASSWORD_LENGTH)) {
      Set<String> values=configParams.get(name);
      if ((values != null) && (!values.isEmpty())) {
        String value=values.iterator().next();
        try {
          minPasswordLength=Integer.parseInt(value);
          if (minPasswordLength < 0) {
            minPasswordLength=0;
          }
        }
 catch (        NumberFormatException nfe) {
          if (debug.warningEnabled()) {
            debug.warning(""String_Node_Str"" + ""String_Node_Str"",nfe);
          }
        }
      }
    }
  }
}"
9053,"/** 
 * Updates an   {@code AMIdentity} in the identity repository with thedetails specified in  {@code identity}.
 * @param identity The updated identity details.
 * @param admin The admin token.
 * @throws ResourceException If a problem occurs.
 */
public void update(IdentityDetails identity,SSOToken admin) throws ResourceException {
  String idName=identity.getName();
  String idType=identity.getType();
  String realm=identity.getRealm();
  if (StringUtils.isEmpty(idName)) {
    throw new BadRequestException(""String_Node_Str"");
  }
  if (StringUtils.isEmpty(idType)) {
    idType=""String_Node_Str"";
  }
  if (realm == null) {
    realm=""String_Node_Str"";
  }
  try {
    IdType objectIdType=getIdType(idType);
    AMIdentityRepository repo=getRepo(admin,realm);
    if (!isOperationSupported(repo,objectIdType,IdOperation.EDIT)) {
      throw new ForbiddenException(""String_Node_Str"");
    }
    AMIdentity amIdentity=getAMIdentity(admin,repo,idType,idName);
    if (amIdentity == null) {
      String msg=""String_Node_Str"" + idName + ""String_Node_Str""+ idType+ ""String_Node_Str"";
      throw new NotFoundException(msg);
    }
    if (isSpecialUser(amIdentity)) {
      throw new ForbiddenException(""String_Node_Str"");
    }
    Map<String,Set<String>> attrs=asMap(identity.getAttributes());
    if (attrs != null && !attrs.isEmpty()) {
      Map<String,Set<String>> idAttrs=new HashMap<>();
      Set<String> removeAttrs=new HashSet<>();
      for (      Map.Entry<String,Set<String>> entry : attrs.entrySet()) {
        String attrName=entry.getKey();
        Set<String> attrValues=entry.getValue();
        if (attrValues != null && !attrValues.isEmpty()) {
          idAttrs.put(attrName,attrValues);
        }
 else {
          removeAttrs.add(attrName);
        }
      }
      boolean storeNeeded=false;
      if (!idAttrs.isEmpty()) {
        amIdentity.setAttributes(idAttrs);
        storeNeeded=true;
      }
      if (!removeAttrs.isEmpty()) {
        amIdentity.removeAttributes(removeAttrs);
        storeNeeded=true;
      }
      if (storeNeeded) {
        amIdentity.store();
      }
    }
    if (IdType.USER.equals(objectIdType)) {
      Set<String> roles=asSet(identity.getRoleList());
      if (!roles.isEmpty()) {
        setMemberships(repo,amIdentity,roles,IdType.ROLE);
      }
      Set<String> groups=asSet(identity.getGroupList());
      if (!groups.isEmpty()) {
        setMemberships(repo,amIdentity,groups,IdType.GROUP);
      }
    }
    if (IdType.GROUP.equals(objectIdType) || IdType.ROLE.equals(objectIdType)) {
      Set<String> members=asSet(identity.getMemberList());
      if (!members.isEmpty()) {
        setMembers(repo,amIdentity,members,IdType.USER);
      }
    }
  }
 catch (  IdRepoException ex) {
    debug.error(""String_Node_Str"",ex);
    if (LDAPConstants.CONSTRAINT_VIOLATED_ERROR.equals(ex.getErrorCode())) {
      throw new InternalServerErrorException(ex.getConstraintViolationDetails());
    }
    throw convertToResourceException(idServicesErrorHandler.handleError(ex));
  }
catch (  SSOException ex) {
    debug.error(""String_Node_Str"",ex);
    throw new BadRequestException(ex.getMessage());
  }
catch (  ObjectNotFound e) {
    debug.error(""String_Node_Str"",e);
    throw new NotFoundException(e.getMessage());
  }
}","/** 
 * Updates an   {@code AMIdentity} in the identity repository with thedetails specified in  {@code identity}.
 * @param identity The updated identity details.
 * @param admin The admin token.
 * @throws ResourceException If a problem occurs.
 */
public void update(IdentityDetails identity,SSOToken admin) throws ResourceException {
  String idName=identity.getName();
  String idType=identity.getType();
  String realm=identity.getRealm();
  if (StringUtils.isEmpty(idName)) {
    throw new BadRequestException(""String_Node_Str"");
  }
  if (StringUtils.isEmpty(idType)) {
    idType=""String_Node_Str"";
  }
  if (realm == null) {
    realm=""String_Node_Str"";
  }
  try {
    IdType objectIdType=getIdType(idType);
    AMIdentityRepository repo=getRepo(admin,realm);
    if (!isOperationSupported(repo,objectIdType,IdOperation.EDIT)) {
      throw new ForbiddenException(""String_Node_Str"");
    }
    AMIdentity amIdentity=getAMIdentity(admin,repo,idType,idName);
    if (amIdentity == null) {
      String msg=""String_Node_Str"" + idName + ""String_Node_Str""+ idType+ ""String_Node_Str"";
      throw new NotFoundException(msg);
    }
    if (isSpecialUser(amIdentity)) {
      throw new ForbiddenException(""String_Node_Str"");
    }
    Map<String,Set<String>> attrs=asMap(identity.getAttributes());
    if (attrs != null && !attrs.isEmpty()) {
      Map<String,Set<String>> idAttrs=new HashMap<>();
      Set<String> removeAttrs=new HashSet<>();
      for (      Map.Entry<String,Set<String>> entry : attrs.entrySet()) {
        String attrName=entry.getKey();
        Set<String> attrValues=entry.getValue();
        if (attrValues != null && !attrValues.isEmpty()) {
          idAttrs.put(attrName,attrValues);
        }
 else {
          removeAttrs.add(attrName);
        }
      }
      boolean storeNeeded=false;
      if (!idAttrs.isEmpty()) {
        amIdentity.setAttributes(idAttrs);
        storeNeeded=true;
      }
      if (!removeAttrs.isEmpty()) {
        amIdentity.removeAttributes(removeAttrs);
        storeNeeded=true;
      }
      if (storeNeeded) {
        amIdentity.store();
      }
    }
    if (IdType.USER.equals(objectIdType)) {
      Set<String> roles=asSet(identity.getRoleList());
      if (!roles.isEmpty()) {
        setMemberships(repo,amIdentity,roles,IdType.ROLE);
      }
      Set<String> groups=asSet(identity.getGroupList());
      if (!groups.isEmpty()) {
        setMemberships(repo,amIdentity,groups,IdType.GROUP);
      }
    }
    if (IdType.GROUP.equals(objectIdType) || IdType.ROLE.equals(objectIdType)) {
      Set<String> members=asSet(identity.getMemberList());
      if (!members.isEmpty()) {
        setMembers(repo,amIdentity,members,IdType.USER);
      }
    }
  }
 catch (  IdRepoException ex) {
    debug.error(""String_Node_Str"",ex);
    if (LDAPConstants.CONSTRAINT_VIOLATED_ERROR.equals(ex.getErrorCode())) {
      throw new InternalServerErrorException(ex.getConstraintViolationDetails());
    }
    if (LDAPConstants.LDAP_INVALID_SYNTAX.equals(ex.getLDAPErrorCode())) {
      throw new BadRequestException(""String_Node_Str"");
    }
    throw convertToResourceException(idServicesErrorHandler.handleError(ex));
  }
catch (  SSOException ex) {
    debug.error(""String_Node_Str"",ex);
    throw new BadRequestException(ex.getMessage());
  }
catch (  ObjectNotFound e) {
    debug.error(""String_Node_Str"",e);
    throw new NotFoundException(e.getMessage());
  }
}"
9054,"private Privilege parsePrivilege(String providedName,JsonValue jsonValue) throws EntitlementException {
  try {
    JsonPolicy policy=MAPPER.readValue(jsonValue.toString(),JsonPolicy.class);
    Privilege privilege=policy.asPrivilege();
    if (isBlank(privilege.getName())) {
      privilege.setName(providedName);
    }
    if (isBlank(privilege.getName())) {
      throw new EntitlementException(EntitlementException.MISSING_PRIVILEGE_NAME);
    }
    if (privilege.getCondition() != null) {
      privilege.getCondition().validate();
    }
    return privilege;
  }
 catch (  UnrecognizedPropertyException ex) {
    throw new EntitlementException(EntitlementException.INVALID_VALUE,new Object[]{ex.getUnrecognizedPropertyName()});
  }
catch (  JsonMappingException ex) {
    throw new EntitlementException(EntitlementException.INVALID_JSON,ex,ex.getCause().getMessage());
  }
catch (  IOException e) {
    throw new EntitlementException(EntitlementException.UNABLE_TO_CREATE_POLICY,e);
  }
}","private Privilege parsePrivilege(String providedName,JsonValue jsonValue) throws EntitlementException {
  try {
    JsonPolicy policy=MAPPER.readValue(jsonValue.toString(),JsonPolicy.class);
    Privilege privilege=policy.asPrivilege();
    if (isBlank(privilege.getName())) {
      privilege.setName(providedName);
    }
    if (isBlank(privilege.getName())) {
      throw new EntitlementException(EntitlementException.MISSING_PRIVILEGE_NAME);
    }
    if (privilege.getCondition() != null) {
      privilege.getCondition().validate();
    }
    return privilege;
  }
 catch (  UnrecognizedPropertyException ex) {
    throw new EntitlementException(EntitlementException.INVALID_VALUE,new Object[]{ex.getUnrecognizedPropertyName()});
  }
catch (  JsonMappingException ex) {
    throw new EntitlementException(EntitlementException.INVALID_JSON,ex,ex.getMessage());
  }
catch (  IOException e) {
    throw new EntitlementException(EntitlementException.UNABLE_TO_CREATE_POLICY,e);
  }
}"
9055,"@Override public void init(javax.security.auth.Subject subject,Map sharedState,Map options){
  for (  Object key : options.keySet()) {
    String keyStr=(String)key;
    if (OPTIONS_MAP.containsKey(keyStr) && CollectionHelper.getMapAttr(options,keyStr) != null) {
      if (((String)key).equalsIgnoreCase(BINDING)) {
        String bindingTmp=CollectionHelper.getMapAttr(options,keyStr);
        params.put(OPTIONS_MAP.get(keyStr),Collections.singletonList(bindingTmp.substring(bindingTmp.lastIndexOf(""String_Node_Str"") + 1)));
      }
 else {
        params.put(OPTIONS_MAP.get(keyStr),Collections.singletonList(CollectionHelper.getMapAttr(options,keyStr)));
      }
    }
  }
  nameIDFormat=CollectionHelper.getMapAttr(options,NAME_ID_FORMAT);
  entityName=CollectionHelper.getMapAttr(options,ENTITY_NAME);
  metaAlias=CollectionHelper.getMapAttr(options,META_ALIAS);
  reqBinding=CollectionHelper.getMapAttr(options,REQ_BINDING);
  localChain=CollectionHelper.getMapAttr(options,LOCAL_CHAIN);
  singleLogoutEnabled=CollectionHelper.getBooleanMapAttr(options,SLO_ENABLED,false);
  sloRelayState=CollectionHelper.getMapAttr(options,SLO_RELAY_STATE);
  metaManager=SAML2Utils.getSAML2MetaManager();
  realm=DNMapper.orgNameToRealmName(getRequestOrg());
  bundle=amCache.getResBundle(BUNDLE_NAME,getLoginLocale());
  String authLevel=CollectionHelper.getMapAttr(options,AUTHLEVEL);
  if (authLevel != null) {
    try {
      setAuthLevel(Integer.parseInt(authLevel));
    }
 catch (    Exception e) {
      DEBUG.error(""String_Node_Str"",authLevel,e);
    }
  }
}","@Override public void init(javax.security.auth.Subject subject,Map sharedState,Map options){
  for (  Object key : options.keySet()) {
    String keyStr=(String)key;
    if (OPTIONS_MAP.containsKey(keyStr) && CollectionHelper.getMapAttr(options,keyStr) != null) {
      if (((String)key).equalsIgnoreCase(BINDING)) {
        String bindingTmp=CollectionHelper.getMapAttr(options,keyStr);
        params.put(OPTIONS_MAP.get(keyStr),Collections.singletonList(bindingTmp.substring(bindingTmp.lastIndexOf(""String_Node_Str"") + 1)));
      }
 else {
        params.put(OPTIONS_MAP.get(keyStr),Collections.singletonList(CollectionHelper.getMapAttr(options,keyStr)));
      }
    }
  }
  nameIDFormat=CollectionHelper.getMapAttr(options,NAME_ID_FORMAT);
  entityName=CollectionHelper.getMapAttr(options,ENTITY_NAME);
  metaAlias=CollectionHelper.getMapAttr(options,META_ALIAS);
  reqBinding=CollectionHelper.getMapAttr(options,REQ_BINDING);
  binding=CollectionHelper.getMapAttr(options,BINDING);
  localChain=CollectionHelper.getMapAttr(options,LOCAL_CHAIN);
  singleLogoutEnabled=CollectionHelper.getBooleanMapAttr(options,SLO_ENABLED,false);
  sloRelayState=CollectionHelper.getMapAttr(options,SLO_RELAY_STATE);
  metaManager=SAML2Utils.getSAML2MetaManager();
  realm=DNMapper.orgNameToRealmName(getRequestOrg());
  bundle=amCache.getResBundle(BUNDLE_NAME,getLoginLocale());
  String authLevel=CollectionHelper.getMapAttr(options,AUTHLEVEL);
  if (authLevel != null) {
    try {
      setAuthLevel(Integer.parseInt(authLevel));
    }
 catch (    Exception e) {
      DEBUG.error(""String_Node_Str"",authLevel,e);
    }
  }
}"
9056,"/** 
 * ""Inspired"" by the OAuth2 module. We use this cookie to remind us exactly where we are when returning from a remote server as we currently cannot trust the RedirectCallback's authentication framework equiv.
 */
private void setCookiesForRedirects(final HttpServletRequest request,final HttpServletResponse response){
  final Set<String> domains=AuthClientUtils.getCookieDomains();
  final StringBuilder originalUrl=new StringBuilder();
  final XUIState xuiState=InjectorHolder.getInstance(XUIState.class);
  final String requestedQuery=request.getQueryString();
  if (xuiState.isXUIEnabled()) {
    originalUrl.append(request.getContextPath());
  }
 else {
    originalUrl.append(request.getRequestURI());
  }
  if (StringUtils.isNotEmpty(realm)) {
    originalUrl.append(""String_Node_Str"").append(URLEncDec.encode(realm));
  }
  if (requestedQuery != null) {
    originalUrl.append(originalUrl.indexOf(""String_Node_Str"") == -1 ? '?' : '&');
    originalUrl.append(requestedQuery);
  }
  for (  String domain : domains) {
    CookieUtils.addCookieToResponse(response,CookieUtils.newCookie(Constants.AM_LOCATION_COOKIE,originalUrl.toString(),""String_Node_Str"",domain));
  }
}","/** 
 * ""Inspired"" by the OAuth2 module. We use this cookie to remind us exactly where we are when returning from a remote server as we currently cannot trust the RedirectCallback's authentication framework equiv.
 */
private void setCookiesForRedirects(final HttpServletRequest request,final HttpServletResponse response){
  final Set<String> domains=AuthClientUtils.getCookieDomains();
  final StringBuilder originalUrl=new StringBuilder();
  final String requestedQuery=request.getQueryString();
  final XUIState xuiState=InjectorHolder.getInstance(XUIState.class);
  if (xuiState.isXUIEnabled()) {
    originalUrl.append(request.getContextPath());
  }
 else {
    originalUrl.append(request.getRequestURI());
  }
  if (StringUtils.isNotEmpty(realm)) {
    originalUrl.append(""String_Node_Str"").append(URLEncDec.encode(realm));
  }
  if (requestedQuery != null) {
    originalUrl.append(originalUrl.indexOf(""String_Node_Str"") == -1 ? '?' : '&');
    originalUrl.append(requestedQuery);
  }
  for (  String domain : domains) {
    CookieUtils.addCookieToResponse(response,CookieUtils.newCookie(Constants.AM_LOCATION_COOKIE,originalUrl.toString(),""String_Node_Str"",domain));
  }
}"
9057,"/** 
 * Adds information necessary for the session to be federated completely (if attributes are being drawn in, and to configure ready for SLO).
 */
private void setSessionProperties(Assertion assertion,NameID nameId,String userName) throws AuthLoginException, SAML2Exception {
  setUserSessionProperty(SAML2Constants.SINGLE_LOGOUT,String.valueOf(singleLogoutEnabled));
  if (singleLogoutEnabled) {
    setUserSessionProperty(SAML2Constants.RELAY_STATE,sloRelayState);
  }
  setUserSessionProperty(SAML2Constants.SESSION_INDEX,sessionIndex);
  setUserSessionProperty(SAML2Constants.IDPENTITYID,entityName);
  setUserSessionProperty(SAML2Constants.SPENTITYID,SPSSOFederate.getSPEntityId(metaAlias));
  setUserSessionProperty(SAML2Constants.METAALIAS,metaAlias);
  setUserSessionProperty(SAML2Constants.REQ_BINDING,reqBinding);
  setUserSessionProperty(SAML2Constants.NAMEID,nameId.toXMLString(true,true));
  setUserSessionProperty(Constants.IS_TRANSIENT,Boolean.toString(isTransient));
  setUserSessionProperty(Constants.REQUEST_ID,respInfo.getResponse().getInResponseTo());
  setAttributeProperties(assertion,userName);
}","/** 
 * Adds information necessary for the session to be federated completely (if attributes are being drawn in, and to configure ready for SLO).
 */
private void setSessionProperties(Assertion assertion,NameID nameId,String userName) throws AuthLoginException, SAML2Exception {
  setUserSessionProperty(SAML2Constants.SINGLE_LOGOUT,String.valueOf(singleLogoutEnabled));
  if (singleLogoutEnabled) {
    setUserSessionProperty(SAML2Constants.RELAY_STATE,sloRelayState);
  }
  setUserSessionProperty(SAML2Constants.SESSION_INDEX,sessionIndex);
  setUserSessionProperty(SAML2Constants.IDPENTITYID,entityName);
  setUserSessionProperty(SAML2Constants.SPENTITYID,SPSSOFederate.getSPEntityId(metaAlias));
  setUserSessionProperty(SAML2Constants.METAALIAS,metaAlias);
  setUserSessionProperty(SAML2Constants.REQ_BINDING,reqBinding);
  setUserSessionProperty(SAML2Constants.NAMEID,nameId.toXMLString(true,true));
  setUserSessionProperty(Constants.IS_TRANSIENT,Boolean.toString(isTransient));
  setUserSessionProperty(Constants.REQUEST_ID,respInfo.getResponse().getInResponseTo());
  setUserSessionProperty(SAML2Constants.BINDING,binding);
  setUserSessionProperty(Constants.CACHE_KEY,storageKey);
}"
9058,"/** 
 * Once we're back from the ACS, we need to validate that we have not errored during the proxying process. Then we detect if we need to perform a local linking authentication chain, or if the user is already locally linked, we need to look up the already-linked username.
 */
private int handleReturnFromRedirect(final int state,final HttpServletRequest request,final String spName,final HttpServletResponse response) throws AuthLoginException {
  removeCookiesForRedirects(response);
  if (Boolean.parseBoolean(request.getParameter(SAML2Proxy.ERROR_PARAM_KEY))) {
    return handleRedirectError(request);
  }
  final String key;
  if (request.getParameter(""String_Node_Str"") != null) {
    key=JsonValueBuilder.toJsonValue(request.getParameter(""String_Node_Str"")).get(""String_Node_Str"").asString();
  }
 else {
    key=request.getParameter(SAML2Proxy.RESPONSE_KEY);
  }
  final String username;
  final SAML2ResponseData data;
  if (SAML2FailoverUtils.isSAML2FailoverEnabled() && !StringUtils.isBlank(key)) {
    try {
      data=(SAML2ResponseData)SAML2FailoverUtils.retrieveSAML2Token(key);
    }
 catch (    SAML2TokenRepositoryException e) {
      return processError(bundle.getString(""String_Node_Str""),""String_Node_Str"",e);
    }
  }
 else   if (!StringUtils.isBlank(key)) {
    data=(SAML2ResponseData)SAML2Store.getTokenFromStore(key);
  }
 else {
    return processError(bundle.getString(""String_Node_Str""),""String_Node_Str"" + ""String_Node_Str"");
  }
  assertionSubject=data.getSubject();
  authnAssertion=data.getAssertion();
  sessionIndex=data.getSessionIndex();
  respInfo=data.getResponseInfo();
  try {
    username=SPACSUtils.getPrincipalWithoutLogin(assertionSubject,authnAssertion,realm,spName,metaManager,entityName);
    if (username != null) {
      principal=new SAML2Principal(username);
      return success(authnAssertion,getNameId(),username);
    }
  }
 catch (  SAML2Exception e) {
    return processError(e,null,""String_Node_Str"");
  }
  if (StringUtils.isBlank(localChain)) {
    return processError(bundle.getString(""String_Node_Str""),""String_Node_Str"" + ""String_Node_Str"");
  }
  authenticationContext=new AuthContext(realm);
  authenticationContext.login(AuthContext.IndexType.SERVICE,localChain,null,null,null,null);
  return injectCallbacks(null,state);
}","/** 
 * Once we're back from the ACS, we need to validate that we have not errored during the proxying process. Then we detect if we need to perform a local linking authentication chain, or if the user is already locally linked, we need to look up the already-linked username.
 */
private int handleReturnFromRedirect(final int state,final HttpServletRequest request,final String spName,final HttpServletResponse response) throws AuthLoginException {
  removeCookiesForRedirects(response);
  if (Boolean.parseBoolean(request.getParameter(SAML2Proxy.ERROR_PARAM_KEY))) {
    return handleRedirectError(request);
  }
  final String key;
  if (request.getParameter(""String_Node_Str"") != null) {
    key=JsonValueBuilder.toJsonValue(request.getParameter(""String_Node_Str"")).get(""String_Node_Str"").asString();
  }
 else {
    key=request.getParameter(SAML2Proxy.RESPONSE_KEY);
  }
  final String username;
  SAML2ResponseData data=null;
  if (!StringUtils.isBlank(key)) {
    data=(SAML2ResponseData)SAML2Store.getTokenFromStore(key);
  }
  if (data == null && SAML2FailoverUtils.isSAML2FailoverEnabled() && !StringUtils.isBlank(key)) {
    try {
      data=(SAML2ResponseData)SAML2FailoverUtils.retrieveSAML2Token(key);
    }
 catch (    SAML2TokenRepositoryException e) {
      return processError(bundle.getString(""String_Node_Str""),""String_Node_Str"",e);
    }
  }
  if (data == null) {
    return processError(bundle.getString(""String_Node_Str""),""String_Node_Str"" + ""String_Node_Str"");
  }
  storageKey=key;
  assertionSubject=data.getSubject();
  authnAssertion=data.getAssertion();
  sessionIndex=data.getSessionIndex();
  respInfo=data.getResponseInfo();
  try {
    username=SPACSUtils.getPrincipalWithoutLogin(assertionSubject,authnAssertion,realm,spName,metaManager,entityName,storageKey);
    if (username != null) {
      principal=new SAML2Principal(username);
      return success(authnAssertion,getNameId(),username);
    }
  }
 catch (  SAML2Exception e) {
    return processError(e,null,""String_Node_Str"");
  }
  if (StringUtils.isBlank(localChain)) {
    return processError(bundle.getString(""String_Node_Str""),""String_Node_Str"" + ""String_Node_Str"");
  }
  authenticationContext=new AuthContext(realm);
  authenticationContext.login(AuthContext.IndexType.SERVICE,localChain,null,null,null,null);
  return injectCallbacks(null,state);
}"
9059,"/** 
 * Sets the auth module's logged-in username via storeUsernamePasswd, triggers call to add information necessary for SLO (if configured) and returns success.
 */
private int success(Assertion assertion,NameID nameId,String userName) throws AuthLoginException, SAML2Exception {
  setSessionProperties(assertion,nameId,userName);
  DEBUG.message(""String_Node_Str"",getPrincipal().getName());
  storeUsernamePasswd(DNUtils.DNtoName(getPrincipal().getName()),null);
  return ISAuthConstants.LOGIN_SUCCEED;
}","/** 
 * Sets the auth module's logged-in username via storeUsernamePasswd, triggers call to add information necessary for SLO (if configured) and returns success.
 */
private int success(Assertion assertion,NameID nameId,String userName) throws AuthLoginException, SAML2Exception {
  setSessionProperties(assertion,nameId,userName);
  setSessionAttributes(assertion,userName);
  DEBUG.message(""String_Node_Str"",getPrincipal().getName());
  storeUsernamePasswd(DNUtils.DNtoName(getPrincipal().getName()),null);
  return ISAuthConstants.LOGIN_SUCCEED;
}"
9060,"/** 
 * Performs similar to SPSSOFederate.initiateAuthnRequest by returning to the next auth stage with a redirect (either GET or POST depending on the config) which triggers remote IdP authentication.
 */
private int initiateSAMLLoginAtIDP(final HttpServletResponse response,final HttpServletRequest request) throws SAML2Exception, AuthLoginException {
  if (reqBinding == null) {
    reqBinding=SAML2Constants.HTTP_REDIRECT;
  }
  final String spEntityID=SPSSOFederate.getSPEntityId(metaAlias);
  final IDPSSODescriptorElement idpsso=SPSSOFederate.getIDPSSOForAuthnReq(realm,entityName);
  final SPSSODescriptorElement spsso=SPSSOFederate.getSPSSOForAuthnReq(realm,spEntityID);
  if (idpsso == null || spsso == null) {
    return processError(bundle.getString(""String_Node_Str""),""String_Node_Str"",bundle.getString(""String_Node_Str""));
  }
  final String ssoURL=SPSSOFederate.getSSOURL(idpsso.getSingleSignOnService(),reqBinding);
  final List extensionsList=SPSSOFederate.getExtensionsList(spEntityID,realm);
  final Map<String,Collection<String>> spConfigAttrsMap=SPSSOFederate.getAttrsMapForAuthnReq(realm,spEntityID);
  final AuthnRequest authnRequest=SPSSOFederate.createAuthnRequest(realm,spEntityID,params,spConfigAttrsMap,extensionsList,spsso,idpsso,ssoURL,false);
  final AuthnRequestInfo reqInfo=new AuthnRequestInfo(request,response,realm,spEntityID,null,authnRequest,null,params);
synchronized (SPCache.requestHash) {
    SPCache.requestHash.put(authnRequest.getID(),reqInfo);
  }
  saveAuthnRequestIfFailoverEnabled(authnRequest,reqInfo);
  final Callback[] nextCallbacks=getCallback(REDIRECT);
  final RedirectCallback redirectCallback=(RedirectCallback)nextCallbacks[0];
  setCookiesForRedirects(request,response);
  if (SAML2Constants.HTTP_POST.equals(reqBinding)) {
    final String postMsg=SPSSOFederate.getPostBindingMsg(idpsso,spsso,spConfigAttrsMap,authnRequest);
    configurePostRedirectCallback(postMsg,ssoURL,redirectCallback);
  }
 else {
    final String authReqXMLString=authnRequest.toXMLString(true,true);
    final String redirectUrl=SPSSOFederate.getRedirect(authReqXMLString,null,ssoURL,idpsso,spsso,spConfigAttrsMap);
    configureGetRedirectCallback(redirectUrl,redirectCallback);
  }
  return REDIRECT;
}","/** 
 * Performs similar to SPSSOFederate.initiateAuthnRequest by returning to the next auth stage with a redirect (either GET or POST depending on the config) which triggers remote IdP authentication.
 */
private int initiateSAMLLoginAtIDP(final HttpServletResponse response,final HttpServletRequest request) throws SAML2Exception, AuthLoginException {
  if (reqBinding == null) {
    reqBinding=SAML2Constants.HTTP_REDIRECT;
  }
  final String spEntityID=SPSSOFederate.getSPEntityId(metaAlias);
  final IDPSSODescriptorElement idpsso=SPSSOFederate.getIDPSSOForAuthnReq(realm,entityName);
  final SPSSODescriptorElement spsso=SPSSOFederate.getSPSSOForAuthnReq(realm,spEntityID);
  if (idpsso == null || spsso == null) {
    return processError(bundle.getString(""String_Node_Str""),""String_Node_Str"",bundle.getString(""String_Node_Str""));
  }
  final String ssoURL=SPSSOFederate.getSSOURL(idpsso.getSingleSignOnService(),reqBinding);
  final List extensionsList=SPSSOFederate.getExtensionsList(spEntityID,realm);
  final Map<String,Collection<String>> spConfigAttrsMap=SPSSOFederate.getAttrsMapForAuthnReq(realm,spEntityID);
  authnRequest=SPSSOFederate.createAuthnRequest(realm,spEntityID,params,spConfigAttrsMap,extensionsList,spsso,idpsso,ssoURL,false);
  final AuthnRequestInfo reqInfo=new AuthnRequestInfo(request,response,realm,spEntityID,null,authnRequest,null,params);
synchronized (SPCache.requestHash) {
    SPCache.requestHash.put(authnRequest.getID(),reqInfo);
  }
  saveAuthnRequest(authnRequest,reqInfo);
  final Callback[] nextCallbacks=getCallback(REDIRECT);
  final RedirectCallback redirectCallback=(RedirectCallback)nextCallbacks[0];
  setCookiesForRedirects(request,response);
  if (SAML2Constants.HTTP_POST.equals(reqBinding)) {
    final String postMsg=SPSSOFederate.getPostBindingMsg(idpsso,spsso,spConfigAttrsMap,authnRequest);
    configurePostRedirectCallback(postMsg,ssoURL,redirectCallback);
  }
 else {
    final String authReqXMLString=authnRequest.toXMLString(true,true);
    final String redirectUrl=SPSSOFederate.getRedirect(authReqXMLString,null,ssoURL,idpsso,spsso,spConfigAttrsMap);
    configureGetRedirectCallback(redirectUrl,redirectCallback);
  }
  return REDIRECT;
}"
9061,"/** 
 * If enabled, performs the first-stage of SLO - by recording the currently logged in user. The information relating to a remote user is stored alongside their local information, and upon active-logout is used to trigger a call to the IdP requesting their logout.
 * @param requestParamsMap map containing <code>HttpServletRequest</code>parameters
 * @param request <code>HttpServletRequest</code> object.
 * @param response <code>HttpServletResponse</code> object.
 * @param ssoToken authenticated user's single sign token.
 */
@Override public void onLoginSuccess(Map requestParamsMap,HttpServletRequest request,HttpServletResponse response,SSOToken ssoToken){
  try {
    final String metaAlias=ssoToken.getProperty(SAML2Constants.METAALIAS);
    final String sessionIndex=ssoToken.getProperty(SAML2Constants.SESSION_INDEX);
    final String spEntityId=ssoToken.getProperty(SAML2Constants.SPENTITYID);
    final String idpEntityId=ssoToken.getProperty(SAML2Constants.IDPENTITYID);
    final String nameIdXML=ssoToken.getProperty(SAML2Constants.NAMEID);
    final NameID nameId=new NameIDImplWithoutSPNameQualifier(nameIdXML);
    final boolean isTransient=Boolean.parseBoolean(ssoToken.getProperty(Constants.IS_TRANSIENT));
    final String requestId=ssoToken.getProperty(Constants.REQUEST_ID);
    final NameIDInfo info=new NameIDInfo(spEntityId,idpEntityId,nameId,SAML2Constants.SP_ROLE,false);
    final String ssOutEnabled=ssoToken.getProperty(SAML2Constants.SINGLE_LOGOUT);
    if (Boolean.parseBoolean(ssOutEnabled)) {
      setupSingleLogOut(ssoToken,metaAlias,sessionIndex,spEntityId,idpEntityId,nameId);
    }
    configureIdpInitSLO(ssoToken,sessionIndex,metaAlias,info,isTransient,requestId);
    clearSession(ssoToken);
  }
 catch (  SAML2Exception|SessionException|SSOException e) {
    DEBUG.warning(""String_Node_Str"");
  }
}","/** 
 * If enabled, performs the first-stage of SLO - by recording the currently logged in user. The information relating to a remote user is stored alongside their local information, and upon active-logout is used to trigger a call to the IdP requesting their logout.
 * @param requestParamsMap map containing <code>HttpServletRequest</code>parameters
 * @param request <code>HttpServletRequest</code> object.
 * @param response <code>HttpServletResponse</code> object.
 * @param ssoToken authenticated user's single sign token.
 */
@Override public void onLoginSuccess(Map requestParamsMap,HttpServletRequest request,HttpServletResponse response,SSOToken ssoToken){
  try {
    final String metaAlias=ssoToken.getProperty(SAML2Constants.METAALIAS);
    final String sessionIndex=ssoToken.getProperty(SAML2Constants.SESSION_INDEX);
    final String spEntityId=ssoToken.getProperty(SAML2Constants.SPENTITYID);
    final String idpEntityId=ssoToken.getProperty(SAML2Constants.IDPENTITYID);
    final String nameIdXML=ssoToken.getProperty(SAML2Constants.NAMEID);
    final NameID nameId=new NameIDImplWithoutSPNameQualifier(nameIdXML);
    final boolean isTransient=Boolean.parseBoolean(ssoToken.getProperty(Constants.IS_TRANSIENT));
    final String requestId=ssoToken.getProperty(Constants.REQUEST_ID);
    final SessionProvider sessionProvider=SessionManager.getProvider();
    final NameIDInfo info=new NameIDInfo(spEntityId,idpEntityId,nameId,SAML2Constants.SP_ROLE,false);
    final String ssOutEnabled=ssoToken.getProperty(SAML2Constants.SINGLE_LOGOUT);
    final String cacheKey=ssoToken.getProperty(Constants.CACHE_KEY);
    final String realm=DNMapper.orgNameToRealmName(ssoToken.getProperty(com.sun.identity.shared.Constants.ORGANIZATION));
    SAML2ResponseData data=(SAML2ResponseData)SAML2Store.getTokenFromStore(cacheKey);
    if (data == null && SAML2FailoverUtils.isSAML2FailoverEnabled()) {
      data=(SAML2ResponseData)SAML2FailoverUtils.retrieveSAML2Token(cacheKey);
    }
 else {
      throw new SAML2Exception(""String_Node_Str"");
    }
    if (Boolean.parseBoolean(ssOutEnabled)) {
      setupSingleLogOut(ssoToken,metaAlias,sessionIndex,spEntityId,idpEntityId,nameId);
    }
    configureIdpInitSLO(sessionProvider,ssoToken,sessionIndex,metaAlias,info,isTransient,requestId);
    configurePostSSO(spEntityId,realm,request,response,ssoToken,sessionProvider,data.getResponseInfo(),cacheKey);
    clearSession(ssoToken);
  }
 catch (  SAML2Exception|SessionException|SSOException|SAML2TokenRepositoryException e) {
    DEBUG.warning(""String_Node_Str"",e);
  }
}"
9062,"@Override public void onLogout(HttpServletRequest request,HttpServletResponse response,SSOToken ssoToken) throws AuthenticationException {
  try {
    final String ssOutEnabled=ssoToken.getProperty(SAML2Constants.SINGLE_LOGOUT);
    if (Boolean.parseBoolean(ssOutEnabled)) {
      request.setAttribute(AMPostAuthProcessInterface.POST_PROCESS_LOGOUT_URL,ssoToken.getProperty(SLO_SESSION_LOCATION) + ssoToken.getProperty(SLO_SESSION_REFERENCE));
      ssoToken.setProperty(AMPostAuthProcessInterface.POST_PROCESS_LOGOUT_URL,ssoToken.getProperty(SLO_SESSION_LOCATION) + ESAPI.encoder().encodeForURL(ssoToken.getProperty(SLO_SESSION_REFERENCE)));
    }
  }
 catch (  EncodingException|SSOException e) {
    DEBUG.warning(""String_Node_Str"");
  }
}","@Override public void onLogout(HttpServletRequest request,HttpServletResponse response,SSOToken ssoToken) throws AuthenticationException {
  try {
    final String ssOutEnabled=ssoToken.getProperty(SAML2Constants.SINGLE_LOGOUT);
    if (Boolean.parseBoolean(ssOutEnabled)) {
      final XUIState xuiState=InjectorHolder.getInstance(XUIState.class);
      final StringBuilder logoutLocation=new StringBuilder();
      logoutLocation.append(ssoToken.getProperty(SLO_SESSION_LOCATION));
      if (xuiState.isXUIEnabled()) {
        logoutLocation.append(ESAPI.encoder().encodeForURL(ssoToken.getProperty(SLO_SESSION_REFERENCE)));
      }
 else {
        logoutLocation.append(ssoToken.getProperty(SLO_SESSION_REFERENCE));
      }
      request.setAttribute(AMPostAuthProcessInterface.POST_PROCESS_LOGOUT_URL,logoutLocation.toString());
    }
  }
 catch (  EncodingException|SSOException e) {
    DEBUG.warning(""String_Node_Str"",e);
  }
}"
9063,"private void configureIdpInitSLO(SSOToken session,String sessionIndex,String metaAlias,NameIDInfo info,boolean isTransient,String requestID) throws SessionException, SAML2Exception, SSOException {
  SessionProvider sessionProvider=SessionManager.getProvider();
  SPACSUtils.saveInfoInMemory(sessionProvider,session,sessionIndex,metaAlias,info,IDPProxyUtil.isIDPProxyEnabled(requestID),isTransient);
}","private void configureIdpInitSLO(SessionProvider sessionProvider,SSOToken session,String sessionIndex,String metaAlias,NameIDInfo info,boolean isTransient,String requestID) throws SessionException, SAML2Exception, SSOException {
  SPACSUtils.saveInfoInMemory(sessionProvider,session,sessionIndex,metaAlias,info,IDPProxyUtil.isIDPProxyEnabled(requestID),isTransient);
}"
9064,"/** 
 * Clears the session of all the temp data we passed to set up SLO.
 */
private void clearSession(SSOToken ssoToken) throws SSOException {
  ssoToken.setProperty(SAML2Constants.RELAY_STATE,""String_Node_Str"");
  ssoToken.setProperty(SAML2Constants.SESSION_INDEX,""String_Node_Str"");
  ssoToken.setProperty(SAML2Constants.IDPENTITYID,""String_Node_Str"");
  ssoToken.setProperty(SAML2Constants.SPENTITYID,""String_Node_Str"");
  ssoToken.setProperty(SAML2Constants.METAALIAS,""String_Node_Str"");
  ssoToken.setProperty(SAML2Constants.REQ_BINDING,""String_Node_Str"");
  ssoToken.setProperty(SAML2Constants.NAMEID,""String_Node_Str"");
  ssoToken.setProperty(Constants.IS_TRANSIENT,""String_Node_Str"");
  ssoToken.setProperty(Constants.REQUEST_ID,""String_Node_Str"");
}","/** 
 * Clears the session of all the temp data we passed to set up SLO.
 */
private void clearSession(SSOToken ssoToken) throws SSOException {
  ssoToken.setProperty(SAML2Constants.RELAY_STATE,""String_Node_Str"");
  ssoToken.setProperty(SAML2Constants.SESSION_INDEX,""String_Node_Str"");
  ssoToken.setProperty(SAML2Constants.IDPENTITYID,""String_Node_Str"");
  ssoToken.setProperty(SAML2Constants.SPENTITYID,""String_Node_Str"");
  ssoToken.setProperty(SAML2Constants.METAALIAS,""String_Node_Str"");
  ssoToken.setProperty(SAML2Constants.REQ_BINDING,""String_Node_Str"");
  ssoToken.setProperty(SAML2Constants.NAMEID,""String_Node_Str"");
  ssoToken.setProperty(Constants.IS_TRANSIENT,""String_Node_Str"");
  ssoToken.setProperty(Constants.REQUEST_ID,""String_Node_Str"");
  ssoToken.setProperty(Constants.CACHE_KEY,""String_Node_Str"");
}"
9065,"public int process(Callback[] callbacks,int state) throws LoginException {
  OAuthUtil.debugMessage(""String_Node_Str"" + state);
  HttpServletRequest request=getHttpServletRequest();
  HttpServletResponse response=getHttpServletResponse();
  if (request == null) {
    OAuthUtil.debugError(""String_Node_Str"" + ""String_Node_Str"");
    return ISAuthConstants.LOGIN_IGNORE;
  }
  String code=request.getParameter(PARAM_CODE);
  if (code != null) {
    OAuthUtil.debugMessage(""String_Node_Str"" + code);
    state=GET_OAUTH_TOKEN_STATE;
  }
  proxyURL=config.getProxyURL();
switch (state) {
case ISAuthConstants.LOGIN_START:
{
      config.validateConfiguration();
      serverName=request.getServerName();
      StringBuilder originalUrl=new StringBuilder();
      String requestedQuery=request.getQueryString();
      String realm=null;
      String authCookieName=AuthUtils.getAuthCookieName();
      final XUIState xuiState=InjectorHolder.getInstance(XUIState.class);
      if (xuiState.isXUIEnabled()) {
        originalUrl.append(request.getContextPath());
        if (requestedQuery != null && !requestedQuery.contains(""String_Node_Str"")) {
          realm=request.getParameter(""String_Node_Str"");
        }
      }
 else {
        originalUrl.append(request.getRequestURI());
      }
      if (StringUtils.isNotEmpty(realm)) {
        originalUrl.append(""String_Node_Str"").append(URLEncDec.encode(realm));
      }
      if (requestedQuery != null) {
        if (requestedQuery.endsWith(authCookieName + ""String_Node_Str"")) {
          requestedQuery=requestedQuery.substring(0,requestedQuery.length() - authCookieName.length() - 1);
        }
        originalUrl.append(originalUrl.indexOf(""String_Node_Str"") == -1 ? '?' : '&');
        originalUrl.append(requestedQuery);
      }
      Set<String> domains=AuthClientUtils.getCookieDomains();
      String ProviderLogoutURL=config.getLogoutServiceUrl();
      String csrfStateTokenId=RandomStringUtils.randomAlphanumeric(32);
      String csrfState=createAuthorizationState();
      Token csrfStateToken=new Token(csrfStateTokenId,TokenType.GENERIC);
      csrfStateToken.setAttribute(CoreTokenField.STRING_ONE,csrfState);
      csrfStateToken.setAttribute(CoreTokenField.STRING_TWO,getCodeVerifier(config.getCodeChallengeMethod()));
      try {
        ctsStore.create(csrfStateToken);
      }
 catch (      CoreTokenException e) {
        OAuthUtil.debugError(""String_Node_Str"" + ""String_Node_Str"");
        throw new AuthLoginException(""String_Node_Str"" + ""String_Node_Str"",e);
      }
      for (      String domain : domains) {
        CookieUtils.addCookieToResponse(response,CookieUtils.newCookie(COOKIE_PROXY_URL,proxyURL,""String_Node_Str"",domain));
        CookieUtils.addCookieToResponse(response,CookieUtils.newCookie(COOKIE_ORIG_URL,originalUrl.toString(),""String_Node_Str"",domain));
        CookieUtils.addCookieToResponse(response,CookieUtils.newCookie(NONCE_TOKEN_ID,csrfStateTokenId,""String_Node_Str"",domain));
        if (ProviderLogoutURL != null && !ProviderLogoutURL.isEmpty()) {
          CookieUtils.addCookieToResponse(response,CookieUtils.newCookie(COOKIE_LOGOUT_URL,ProviderLogoutURL,""String_Node_Str"",domain));
        }
      }
      setUserSessionProperty(ISAuthConstants.FULL_LOGIN_URL,originalUrl.toString());
      setUserSessionProperty(SESSION_LOGOUT_BEHAVIOUR,config.getLogoutBhaviour());
      String authServiceUrl=config.getAuthServiceUrl(proxyURL,csrfState,getCodeVerifier(config.getCodeChallengeMethod()),config.getCodeChallengeMethod());
      OAuthUtil.debugMessage(""String_Node_Str"" + authServiceUrl);
      Callback[] callbacks1=getCallback(2);
      RedirectCallback rc=(RedirectCallback)callbacks1[0];
      RedirectCallback rcNew=new RedirectCallback(authServiceUrl,null,""String_Node_Str"",rc.getStatusParameter(),rc.getRedirectBackUrlCookieName());
      replaceCallback(2,0,rcNew);
      return GET_OAUTH_TOKEN_STATE;
    }
case GET_OAUTH_TOKEN_STATE:
{
    final String csrfState;
    if (request.getParameter(""String_Node_Str"") != null) {
      final JsonValue jval=JsonValueBuilder.toJsonValue(request.getParameter(""String_Node_Str""));
      csrfState=jval.get(""String_Node_Str"").asString();
      code=jval.get(PARAM_CODE).asString();
    }
 else {
      csrfState=request.getParameter(""String_Node_Str"");
      code=request.getParameter(PARAM_CODE);
    }
    if (csrfState == null) {
      OAuthUtil.debugError(""String_Node_Str"" + ""String_Node_Str"");
      throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null);
    }
    try {
      Token csrfStateToken=ctsStore.read(OAuthUtil.findCookie(request,NONCE_TOKEN_ID));
      ctsStore.deleteAsync(csrfStateToken);
      String expectedCsrfState=csrfStateToken.getValue(CoreTokenField.STRING_ONE);
      if (!expectedCsrfState.equals(csrfState)) {
        OAuthUtil.debugError(""String_Node_Str"" + ""String_Node_Str"");
        throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null);
      }
      if (code == null || code.isEmpty()) {
        OAuthUtil.debugMessage(""String_Node_Str"");
        return ISAuthConstants.LOGIN_START;
      }
      validateInput(""String_Node_Str"",code,""String_Node_Str"",512,false);
      OAuthUtil.debugMessage(""String_Node_Str"" + code);
      final String codeVerifier=csrfStateToken.getValue(CoreTokenField.STRING_TWO);
      String tokenSvcResponse=getContent(config.getTokenServiceUrl(code,proxyURL,codeVerifier),null);
      OAuthUtil.debugMessage(""String_Node_Str"" + tokenSvcResponse);
      JwtClaimsSet jwtClaims=null;
      String idToken=null;
      if (config.isOpenIDConnect()) {
        idToken=extractToken(ID_TOKEN,tokenSvcResponse);
        JwtHandler jwtHandler=new JwtHandler(jwtHandlerConfig);
        try {
          jwtClaims=jwtHandler.validateJwt(idToken);
        }
 catch (        RuntimeException|AuthLoginException e) {
          debug.warning(""String_Node_Str"",e);
          throw e;
        }
        if (!JwtHandler.isIntendedForAudience(config.getClientId(),jwtClaims)) {
          OAuthUtil.debugError(""String_Node_Str"");
          throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null);
        }
      }
      String token=extractToken(PARAM_ACCESS_TOKEN,tokenSvcResponse);
      setUserSessionProperty(SESSION_OAUTH_TOKEN,token);
      String profileSvcResponse=null;
      if (StringUtils.isNotEmpty(config.getProfileServiceUrl())) {
        profileSvcResponse=getContent(config.getProfileServiceUrl(),""String_Node_Str"" + token);
        OAuthUtil.debugMessage(""String_Node_Str"" + profileSvcResponse);
      }
      String realm=getRequestOrg();
      if (realm == null) {
        realm=""String_Node_Str"";
      }
      AccountProvider accountProvider=instantiateAccountProvider();
      AttributeMapper accountAttributeMapper=instantiateAccountMapper();
      Map<String,Set<String>> userNames=getAttributes(profileSvcResponse,config.getAccountMapperConfig(),accountAttributeMapper,jwtClaims);
      String user=null;
      if (!userNames.isEmpty()) {
        user=getUser(realm,accountProvider,userNames);
      }
      if (user == null && !config.getCreateAccountFlag()) {
        authenticatedUser=getDynamicUser(userNames);
        if (authenticatedUser != null) {
          if (config.getSaveAttributesToSessionFlag()) {
            Map<String,Set<String>> attributes=getAttributesMap(profileSvcResponse,jwtClaims);
            saveAttributes(attributes);
          }
          OAuthUtil.debugMessage(""String_Node_Str"" + ""String_Node_Str"" + authenticatedUser);
          storeUsernamePasswd(authenticatedUser,null);
          return ISAuthConstants.LOGIN_SUCCEED;
        }
 else {
          throw new AuthLoginException(""String_Node_Str"");
        }
      }
      if (user == null && config.getCreateAccountFlag()) {
        if (config.getPromptPasswordFlag()) {
          setUserSessionProperty(PROFILE_SERVICE_RESPONSE,profileSvcResponse);
          if (config.isOpenIDConnect()) {
            setUserSessionProperty(OPENID_TOKEN,idToken);
          }
          return SET_PASSWORD_STATE;
        }
 else {
          authenticatedUser=provisionAccountNow(accountProvider,realm,profileSvcResponse,getRandomData(),jwtClaims);
          if (authenticatedUser != null) {
            OAuthUtil.debugMessage(""String_Node_Str"" + authenticatedUser);
            storeUsernamePasswd(authenticatedUser,null);
            return ISAuthConstants.LOGIN_SUCCEED;
          }
 else {
            return ISAuthConstants.LOGIN_IGNORE;
          }
        }
      }
      if (user != null) {
        authenticatedUser=user;
        OAuthUtil.debugMessage(""String_Node_Str"" + ""String_Node_Str"" + authenticatedUser);
        if (config.getSaveAttributesToSessionFlag()) {
          Map<String,Set<String>> attributes=getAttributesMap(profileSvcResponse,jwtClaims);
          saveAttributes(attributes);
        }
        storeUsernamePasswd(authenticatedUser,null);
        return ISAuthConstants.LOGIN_SUCCEED;
      }
    }
 catch (    JSONException je) {
      OAuthUtil.debugError(""String_Node_Str"" + je.getMessage());
      throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null,je);
    }
catch (    SSOException ssoe) {
      OAuthUtil.debugError(""String_Node_Str"" + ssoe.getMessage());
      throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null,ssoe);
    }
catch (    IdRepoException ire) {
      OAuthUtil.debugError(""String_Node_Str"" + ire.getMessage());
      throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null,ire);
    }
catch (    CoreTokenException e) {
      OAuthUtil.debugError(""String_Node_Str"" + ""String_Node_Str"");
      throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null,e);
    }
    break;
  }
case SET_PASSWORD_STATE:
{
  if (!config.getCreateAccountFlag()) {
    return ISAuthConstants.LOGIN_IGNORE;
  }
  userPassword=request.getParameter(PARAM_TOKEN1);
  validateInput(PARAM_TOKEN1,userPassword,""String_Node_Str"",512,false);
  String userPassword2=request.getParameter(PARAM_TOKEN2);
  validateInput(PARAM_TOKEN2,userPassword2,""String_Node_Str"",512,false);
  if (!userPassword.equals(userPassword2)) {
    OAuthUtil.debugWarning(""String_Node_Str"");
    return SET_PASSWORD_STATE;
  }
  String terms=request.getParameter(""String_Node_Str"");
  if (!terms.equalsIgnoreCase(""String_Node_Str"")) {
    return SET_PASSWORD_STATE;
  }
  String profileSvcResponse=getUserSessionProperty(""String_Node_Str"");
  data=getRandomData();
  String mail=getMail(profileSvcResponse,config.getMailAttribute());
  OAuthUtil.debugMessage(""String_Node_Str"" + mail);
  try {
    OAuthUtil.sendEmail(config.getEmailFrom(),mail,data,config.getSMTPConfig(),bundle,proxyURL);
  }
 catch (  NoEmailSentException ex) {
    OAuthUtil.debugError(""String_Node_Str"",ex);
    throw new AuthLoginException(""String_Node_Str"" + ""String_Node_Str"");
  }
  OAuthUtil.debugMessage(""String_Node_Str"" + data);
  return CREATE_USER_STATE;
}
case CREATE_USER_STATE:
{
String activation=request.getParameter(PARAM_ACTIVATION);
validateInput(PARAM_ACTIVATION,activation,""String_Node_Str"",512,false);
OAuthUtil.debugMessage(""String_Node_Str"" + activation);
if (activation == null || activation.isEmpty() || !activation.trim().equals(data.trim())) {
  return CREATE_USER_STATE;
}
String profileSvcResponse=getUserSessionProperty(PROFILE_SERVICE_RESPONSE);
String idToken=getUserSessionProperty(ID_TOKEN);
String realm=getRequestOrg();
if (realm == null) {
  realm=""String_Node_Str"";
}
OAuthUtil.debugMessage(""String_Node_Str"" + profileSvcResponse);
AccountProvider accountProvider=instantiateAccountProvider();
JwtClaimsSet jwtClaims=null;
if (idToken != null) {
  jwtClaims=new JwtHandler(jwtHandlerConfig).getJwtClaims(idToken);
}
authenticatedUser=provisionAccountNow(accountProvider,realm,profileSvcResponse,userPassword,jwtClaims);
if (authenticatedUser != null) {
  OAuthUtil.debugMessage(""String_Node_Str"" + authenticatedUser);
  storeUsernamePasswd(authenticatedUser,null);
  return ISAuthConstants.LOGIN_SUCCEED;
}
 else {
  return ISAuthConstants.LOGIN_IGNORE;
}
}
default :
{
OAuthUtil.debugError(""String_Node_Str"");
return ISAuthConstants.LOGIN_IGNORE;
}
}
throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null);
}","public int process(Callback[] callbacks,int state) throws LoginException {
  OAuthUtil.debugMessage(""String_Node_Str"" + state);
  HttpServletRequest request=getHttpServletRequest();
  HttpServletResponse response=getHttpServletResponse();
  if (request == null) {
    OAuthUtil.debugError(""String_Node_Str"" + ""String_Node_Str"");
    return ISAuthConstants.LOGIN_IGNORE;
  }
  String code=request.getParameter(PARAM_CODE);
  if (code != null) {
    OAuthUtil.debugMessage(""String_Node_Str"" + code);
    state=GET_OAUTH_TOKEN_STATE;
  }
  proxyURL=config.getProxyURL();
switch (state) {
case ISAuthConstants.LOGIN_START:
{
      config.validateConfiguration();
      serverName=request.getServerName();
      StringBuilder originalUrl=new StringBuilder();
      String requestedQuery=request.getQueryString();
      String realm=null;
      String authCookieName=AuthUtils.getAuthCookieName();
      final XUIState xuiState=InjectorHolder.getInstance(XUIState.class);
      if (xuiState.isXUIEnabled()) {
        originalUrl.append(request.getContextPath());
        if (requestedQuery != null && !requestedQuery.contains(""String_Node_Str"")) {
          realm=request.getParameter(""String_Node_Str"");
        }
      }
 else {
        originalUrl.append(request.getRequestURI());
      }
      if (StringUtils.isNotEmpty(realm)) {
        originalUrl.append(""String_Node_Str"").append(URLEncDec.encode(realm));
      }
      if (requestedQuery != null) {
        if (requestedQuery.endsWith(authCookieName + ""String_Node_Str"")) {
          requestedQuery=requestedQuery.substring(0,requestedQuery.length() - authCookieName.length() - 1);
        }
        originalUrl.append(originalUrl.indexOf(""String_Node_Str"") == -1 ? '?' : '&');
        originalUrl.append(requestedQuery);
      }
      Set<String> domains=AuthClientUtils.getCookieDomains();
      String ProviderLogoutURL=config.getLogoutServiceUrl();
      String csrfStateTokenId=RandomStringUtils.randomAlphanumeric(32);
      String csrfState=createAuthorizationState();
      Token csrfStateToken=new Token(csrfStateTokenId,TokenType.GENERIC);
      csrfStateToken.setAttribute(CoreTokenField.STRING_ONE,csrfState);
      csrfStateToken.setAttribute(CoreTokenField.STRING_TWO,getCodeVerifier(config.getCodeChallengeMethod()));
      try {
        ctsStore.create(csrfStateToken);
      }
 catch (      CoreTokenException e) {
        OAuthUtil.debugError(""String_Node_Str"" + ""String_Node_Str"");
        throw new AuthLoginException(""String_Node_Str"" + ""String_Node_Str"",e);
      }
      for (      String domain : domains) {
        CookieUtils.addCookieToResponse(response,CookieUtils.newCookie(COOKIE_PROXY_URL,proxyURL,""String_Node_Str"",domain));
        CookieUtils.addCookieToResponse(response,CookieUtils.newCookie(COOKIE_ORIG_URL,originalUrl.toString(),""String_Node_Str"",domain));
        CookieUtils.addCookieToResponse(response,CookieUtils.newCookie(NONCE_TOKEN_ID,csrfStateTokenId,""String_Node_Str"",domain));
        if (ProviderLogoutURL != null && !ProviderLogoutURL.isEmpty()) {
          CookieUtils.addCookieToResponse(response,CookieUtils.newCookie(COOKIE_LOGOUT_URL,ProviderLogoutURL,""String_Node_Str"",domain));
        }
      }
      setUserSessionProperty(ISAuthConstants.FULL_LOGIN_URL,originalUrl.toString());
      setUserSessionProperty(SESSION_LOGOUT_BEHAVIOUR,config.getLogoutBhaviour());
      String authServiceUrl=config.getAuthServiceUrl(proxyURL,csrfState,getCodeVerifier(config.getCodeChallengeMethod()),config.getCodeChallengeMethod());
      OAuthUtil.debugMessage(""String_Node_Str"" + authServiceUrl);
      Callback[] callbacks1=getCallback(2);
      RedirectCallback rc=(RedirectCallback)callbacks1[0];
      RedirectCallback rcNew=new RedirectCallback(authServiceUrl,null,""String_Node_Str"",rc.getStatusParameter(),rc.getRedirectBackUrlCookieName());
      rcNew.setTrackingCookie(true);
      replaceCallback(2,0,rcNew);
      return GET_OAUTH_TOKEN_STATE;
    }
case GET_OAUTH_TOKEN_STATE:
{
    final String csrfState;
    if (request.getParameter(""String_Node_Str"") != null) {
      final JsonValue jval=JsonValueBuilder.toJsonValue(request.getParameter(""String_Node_Str""));
      csrfState=jval.get(""String_Node_Str"").asString();
      code=jval.get(PARAM_CODE).asString();
    }
 else {
      csrfState=request.getParameter(""String_Node_Str"");
      code=request.getParameter(PARAM_CODE);
    }
    if (csrfState == null) {
      OAuthUtil.debugError(""String_Node_Str"" + ""String_Node_Str"");
      throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null);
    }
    try {
      Token csrfStateToken=ctsStore.read(OAuthUtil.findCookie(request,NONCE_TOKEN_ID));
      ctsStore.deleteAsync(csrfStateToken);
      String expectedCsrfState=csrfStateToken.getValue(CoreTokenField.STRING_ONE);
      if (!expectedCsrfState.equals(csrfState)) {
        OAuthUtil.debugError(""String_Node_Str"" + ""String_Node_Str"");
        throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null);
      }
      if (code == null || code.isEmpty()) {
        OAuthUtil.debugMessage(""String_Node_Str"");
        return ISAuthConstants.LOGIN_START;
      }
      validateInput(""String_Node_Str"",code,""String_Node_Str"",512,false);
      OAuthUtil.debugMessage(""String_Node_Str"" + code);
      final String codeVerifier=csrfStateToken.getValue(CoreTokenField.STRING_TWO);
      String tokenSvcResponse=getContent(config.getTokenServiceUrl(code,proxyURL,codeVerifier),null);
      OAuthUtil.debugMessage(""String_Node_Str"" + tokenSvcResponse);
      JwtClaimsSet jwtClaims=null;
      String idToken=null;
      if (config.isOpenIDConnect()) {
        idToken=extractToken(ID_TOKEN,tokenSvcResponse);
        JwtHandler jwtHandler=new JwtHandler(jwtHandlerConfig);
        try {
          jwtClaims=jwtHandler.validateJwt(idToken);
        }
 catch (        RuntimeException|AuthLoginException e) {
          debug.warning(""String_Node_Str"",e);
          throw e;
        }
        if (!JwtHandler.isIntendedForAudience(config.getClientId(),jwtClaims)) {
          OAuthUtil.debugError(""String_Node_Str"");
          throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null);
        }
      }
      String token=extractToken(PARAM_ACCESS_TOKEN,tokenSvcResponse);
      setUserSessionProperty(SESSION_OAUTH_TOKEN,token);
      String profileSvcResponse=null;
      if (StringUtils.isNotEmpty(config.getProfileServiceUrl())) {
        profileSvcResponse=getContent(config.getProfileServiceUrl(),""String_Node_Str"" + token);
        OAuthUtil.debugMessage(""String_Node_Str"" + profileSvcResponse);
      }
      String realm=getRequestOrg();
      if (realm == null) {
        realm=""String_Node_Str"";
      }
      AccountProvider accountProvider=instantiateAccountProvider();
      AttributeMapper accountAttributeMapper=instantiateAccountMapper();
      Map<String,Set<String>> userNames=getAttributes(profileSvcResponse,config.getAccountMapperConfig(),accountAttributeMapper,jwtClaims);
      String user=null;
      if (!userNames.isEmpty()) {
        user=getUser(realm,accountProvider,userNames);
      }
      if (user == null && !config.getCreateAccountFlag()) {
        authenticatedUser=getDynamicUser(userNames);
        if (authenticatedUser != null) {
          if (config.getSaveAttributesToSessionFlag()) {
            Map<String,Set<String>> attributes=getAttributesMap(profileSvcResponse,jwtClaims);
            saveAttributes(attributes);
          }
          OAuthUtil.debugMessage(""String_Node_Str"" + ""String_Node_Str"" + authenticatedUser);
          storeUsernamePasswd(authenticatedUser,null);
          return ISAuthConstants.LOGIN_SUCCEED;
        }
 else {
          throw new AuthLoginException(""String_Node_Str"");
        }
      }
      if (user == null && config.getCreateAccountFlag()) {
        if (config.getPromptPasswordFlag()) {
          setUserSessionProperty(PROFILE_SERVICE_RESPONSE,profileSvcResponse);
          if (config.isOpenIDConnect()) {
            setUserSessionProperty(OPENID_TOKEN,idToken);
          }
          return SET_PASSWORD_STATE;
        }
 else {
          authenticatedUser=provisionAccountNow(accountProvider,realm,profileSvcResponse,getRandomData(),jwtClaims);
          if (authenticatedUser != null) {
            OAuthUtil.debugMessage(""String_Node_Str"" + authenticatedUser);
            storeUsernamePasswd(authenticatedUser,null);
            return ISAuthConstants.LOGIN_SUCCEED;
          }
 else {
            return ISAuthConstants.LOGIN_IGNORE;
          }
        }
      }
      if (user != null) {
        authenticatedUser=user;
        OAuthUtil.debugMessage(""String_Node_Str"" + ""String_Node_Str"" + authenticatedUser);
        if (config.getSaveAttributesToSessionFlag()) {
          Map<String,Set<String>> attributes=getAttributesMap(profileSvcResponse,jwtClaims);
          saveAttributes(attributes);
        }
        storeUsernamePasswd(authenticatedUser,null);
        return ISAuthConstants.LOGIN_SUCCEED;
      }
    }
 catch (    JSONException je) {
      OAuthUtil.debugError(""String_Node_Str"" + je.getMessage());
      throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null,je);
    }
catch (    SSOException ssoe) {
      OAuthUtil.debugError(""String_Node_Str"" + ssoe.getMessage());
      throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null,ssoe);
    }
catch (    IdRepoException ire) {
      OAuthUtil.debugError(""String_Node_Str"" + ire.getMessage());
      throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null,ire);
    }
catch (    CoreTokenException e) {
      OAuthUtil.debugError(""String_Node_Str"" + ""String_Node_Str"");
      throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null,e);
    }
    break;
  }
case SET_PASSWORD_STATE:
{
  if (!config.getCreateAccountFlag()) {
    return ISAuthConstants.LOGIN_IGNORE;
  }
  userPassword=request.getParameter(PARAM_TOKEN1);
  validateInput(PARAM_TOKEN1,userPassword,""String_Node_Str"",512,false);
  String userPassword2=request.getParameter(PARAM_TOKEN2);
  validateInput(PARAM_TOKEN2,userPassword2,""String_Node_Str"",512,false);
  if (!userPassword.equals(userPassword2)) {
    OAuthUtil.debugWarning(""String_Node_Str"");
    return SET_PASSWORD_STATE;
  }
  String terms=request.getParameter(""String_Node_Str"");
  if (!terms.equalsIgnoreCase(""String_Node_Str"")) {
    return SET_PASSWORD_STATE;
  }
  String profileSvcResponse=getUserSessionProperty(""String_Node_Str"");
  data=getRandomData();
  String mail=getMail(profileSvcResponse,config.getMailAttribute());
  OAuthUtil.debugMessage(""String_Node_Str"" + mail);
  try {
    OAuthUtil.sendEmail(config.getEmailFrom(),mail,data,config.getSMTPConfig(),bundle,proxyURL);
  }
 catch (  NoEmailSentException ex) {
    OAuthUtil.debugError(""String_Node_Str"",ex);
    throw new AuthLoginException(""String_Node_Str"" + ""String_Node_Str"");
  }
  OAuthUtil.debugMessage(""String_Node_Str"" + data);
  return CREATE_USER_STATE;
}
case CREATE_USER_STATE:
{
String activation=request.getParameter(PARAM_ACTIVATION);
validateInput(PARAM_ACTIVATION,activation,""String_Node_Str"",512,false);
OAuthUtil.debugMessage(""String_Node_Str"" + activation);
if (activation == null || activation.isEmpty() || !activation.trim().equals(data.trim())) {
  return CREATE_USER_STATE;
}
String profileSvcResponse=getUserSessionProperty(PROFILE_SERVICE_RESPONSE);
String idToken=getUserSessionProperty(ID_TOKEN);
String realm=getRequestOrg();
if (realm == null) {
  realm=""String_Node_Str"";
}
OAuthUtil.debugMessage(""String_Node_Str"" + profileSvcResponse);
AccountProvider accountProvider=instantiateAccountProvider();
JwtClaimsSet jwtClaims=null;
if (idToken != null) {
  jwtClaims=new JwtHandler(jwtHandlerConfig).getJwtClaims(idToken);
}
authenticatedUser=provisionAccountNow(accountProvider,realm,profileSvcResponse,userPassword,jwtClaims);
if (authenticatedUser != null) {
  OAuthUtil.debugMessage(""String_Node_Str"" + authenticatedUser);
  storeUsernamePasswd(authenticatedUser,null);
  return ISAuthConstants.LOGIN_SUCCEED;
}
 else {
  return ISAuthConstants.LOGIN_IGNORE;
}
}
default :
{
OAuthUtil.debugError(""String_Node_Str"");
return ISAuthConstants.LOGIN_IGNORE;
}
}
throw new AuthLoginException(BUNDLE_NAME,""String_Node_Str"",null);
}"
9066,"/** 
 * Generates the redirect from SAML2 auth module to IDP as GET.
 */
private void configureGetRedirectCallback(final String redirectUrl,RedirectCallback redirectCallback) throws AuthLoginException {
  final RedirectCallback rcNew=new RedirectCallback(redirectUrl,null,""String_Node_Str"",redirectCallback.getStatusParameter(),redirectCallback.getRedirectBackUrlCookieName());
  Map<String,String> redirectData=rcNew.getRedirectData();
  if (null == redirectData) {
    redirectData=new HashMap<>();
  }
  rcNew.setRedirectData(redirectData);
  replaceCallback(REDIRECT,REDIRECT_CALLBACK,rcNew);
}","/** 
 * Generates the redirect from SAML2 auth module to IDP as GET.
 */
private void configureGetRedirectCallback(final String redirectUrl,RedirectCallback redirectCallback) throws AuthLoginException {
  final RedirectCallback rcNew=new RedirectCallback(redirectUrl,null,""String_Node_Str"",redirectCallback.getStatusParameter(),redirectCallback.getRedirectBackUrlCookieName());
  Map<String,String> redirectData=rcNew.getRedirectData();
  rcNew.setRedirectData(redirectData);
  rcNew.setTrackingCookie(true);
  replaceCallback(REDIRECT,REDIRECT_CALLBACK,rcNew);
}"
9067,"/** 
 * Generates the redirect from SAML2 auth module to IDP as POST.
 */
private void configurePostRedirectCallback(final String postMsg,final String ssoURL,final RedirectCallback redirectCallback) throws AuthLoginException {
  final Map<String,String> postData=new HashMap<>();
  postData.put(SAML2Constants.SAML_REQUEST,postMsg);
  final RedirectCallback rcNew=new RedirectCallback(ssoURL,postData,""String_Node_Str"",redirectCallback.getStatusParameter(),redirectCallback.getRedirectBackUrlCookieName());
  replaceCallback(REDIRECT,REDIRECT_CALLBACK,rcNew);
}","/** 
 * Generates the redirect from SAML2 auth module to IDP as POST.
 */
private void configurePostRedirectCallback(final String postMsg,final String ssoURL,final RedirectCallback redirectCallback) throws AuthLoginException {
  final Map<String,String> postData=new HashMap<>();
  postData.put(SAML2Constants.SAML_REQUEST,postMsg);
  final RedirectCallback rcNew=new RedirectCallback(ssoURL,postData,""String_Node_Str"",redirectCallback.getStatusParameter(),redirectCallback.getRedirectBackUrlCookieName());
  rcNew.setTrackingCookie(true);
  replaceCallback(REDIRECT,REDIRECT_CALLBACK,rcNew);
}"
9068,"/** 
 * Converts the   {@code RedirectCallback} into a JSON representation.{@inheritDoc}
 */
public JsonValue convertToJson(RedirectCallback callback,int index) throws RestAuthException {
  JsonValue callbacksJson=json(array(createOutputField(""String_Node_Str"",callback.getRedirectUrl()),createOutputField(""String_Node_Str"",callback.getMethod())));
  JsonValue jsonValue=json(object(field(""String_Node_Str"",CALLBACK_NAME),field(""String_Node_Str"",callbacksJson.getObject())));
  if (callback.getRedirectData() != null) {
    callbacksJson.add(createOutputField(""String_Node_Str"",callback.getRedirectData()));
  }
  return jsonValue;
}","/** 
 * Converts the   {@code RedirectCallback} into a JSON representation.{@inheritDoc}
 */
public JsonValue convertToJson(RedirectCallback callback,int index) throws RestAuthException {
  JsonValue callbacksJson=json(array(createOutputField(""String_Node_Str"",callback.getRedirectUrl()),createOutputField(""String_Node_Str"",callback.getMethod()),createOutputField(""String_Node_Str"",callback.getTrackingCookie())));
  JsonValue jsonValue=json(object(field(""String_Node_Str"",CALLBACK_NAME),field(""String_Node_Str"",callbacksJson.getObject())));
  if (callback.getRedirectData() != null) {
    callbacksJson.add(createOutputField(""String_Node_Str"",callback.getRedirectData()));
  }
  return jsonValue;
}"
9069,"@Test public void shouldSerialiseToJsonCorrectly() throws Exception {
  RedirectCallback redirectCallback=mock(RedirectCallback.class);
  final Map<String,String> redirectData=Collections.singletonMap(""String_Node_Str"",""String_Node_Str"");
  given(redirectCallback.getRedirectUrl()).willReturn(""String_Node_Str"");
  given(redirectCallback.getMethod()).willReturn(""String_Node_Str"");
  given(redirectCallback.getRedirectData()).willReturn(redirectData);
  String json=JsonValueBuilder.getObjectMapper().writeValueAsString(restAuthRedirectCallbackHandler.convertToJson(redirectCallback,1).getObject());
  JsonValue parsed=JsonValueBuilder.toJsonValue(json);
  assertThat(parsed).stringAt(""String_Node_Str"").isEqualTo(""String_Node_Str"");
  assertThat(parsed).hasArray(""String_Node_Str"").hasSize(3);
  assertThat(parsed).hasObject(""String_Node_Str"").containsExactly(entry(""String_Node_Str"",""String_Node_Str""),entry(""String_Node_Str"",""String_Node_Str""));
  assertThat(parsed).hasObject(""String_Node_Str"").containsExactly(entry(""String_Node_Str"",""String_Node_Str""),entry(""String_Node_Str"",""String_Node_Str""));
  assertThat(parsed).hasObject(""String_Node_Str"").containsExactly(entry(""String_Node_Str"",""String_Node_Str""),entry(""String_Node_Str"",redirectData));
}","@Test public void shouldSerialiseToJsonCorrectly() throws Exception {
  RedirectCallback redirectCallback=mock(RedirectCallback.class);
  final Map<String,String> redirectData=Collections.singletonMap(""String_Node_Str"",""String_Node_Str"");
  given(redirectCallback.getRedirectUrl()).willReturn(""String_Node_Str"");
  given(redirectCallback.getMethod()).willReturn(""String_Node_Str"");
  given(redirectCallback.getRedirectData()).willReturn(redirectData);
  String json=JsonValueBuilder.getObjectMapper().writeValueAsString(restAuthRedirectCallbackHandler.convertToJson(redirectCallback,1).getObject());
  JsonValue parsed=JsonValueBuilder.toJsonValue(json);
  assertThat(parsed).stringAt(""String_Node_Str"").isEqualTo(""String_Node_Str"");
  assertThat(parsed).hasArray(""String_Node_Str"").hasSize(4);
  assertThat(parsed).hasObject(""String_Node_Str"").containsExactly(entry(""String_Node_Str"",""String_Node_Str""),entry(""String_Node_Str"",""String_Node_Str""));
  assertThat(parsed).hasObject(""String_Node_Str"").containsExactly(entry(""String_Node_Str"",""String_Node_Str""),entry(""String_Node_Str"",""String_Node_Str""));
  assertThat(parsed).hasObject(""String_Node_Str"").containsExactly(entry(""String_Node_Str"",""String_Node_Str""),entry(""String_Node_Str"",false));
  assertThat(parsed).hasObject(""String_Node_Str"").containsExactly(entry(""String_Node_Str"",""String_Node_Str""),entry(""String_Node_Str"",redirectData));
}"
9070,"@Test public void shouldFailConvertToJson() throws RestAuthException {
  RedirectCallback redirectCallback=mock(RedirectCallback.class);
  given(redirectCallback.getRedirectUrl()).willReturn(""String_Node_Str"");
  given(redirectCallback.getMethod()).willReturn(""String_Node_Str"");
  given(redirectCallback.getRedirectData()).willReturn(Collections.<String,String>emptyMap());
  JsonValue json=restAuthRedirectCallbackHandler.convertToJson(redirectCallback,1);
  assertThat(json.asMap()).hasSize(2);
  assertThat(json.get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").asList()).hasSize(3);
  assertThat(json.get(""String_Node_Str"").get(0).get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").get(0).get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").get(1).get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").get(1).get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").get(2).get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").get(2).get(""String_Node_Str"").asMap()).hasSize(0);
}","@Test public void shouldFailConvertToJson() throws RestAuthException {
  RedirectCallback redirectCallback=mock(RedirectCallback.class);
  given(redirectCallback.getRedirectUrl()).willReturn(""String_Node_Str"");
  given(redirectCallback.getMethod()).willReturn(""String_Node_Str"");
  given(redirectCallback.getRedirectData()).willReturn(Collections.<String,String>emptyMap());
  JsonValue json=restAuthRedirectCallbackHandler.convertToJson(redirectCallback,1);
  assertThat(json.asMap()).hasSize(2);
  assertThat(json.get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").asList()).hasSize(4);
  assertThat(json.get(""String_Node_Str"").get(0).get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").get(0).get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").get(1).get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").get(1).get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").get(2).get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").get(2).get(""String_Node_Str"").asBoolean()).isEqualTo(false);
  assertThat(json.get(""String_Node_Str"").get(3).get(""String_Node_Str"").asString()).isEqualTo(""String_Node_Str"");
  assertThat(json.get(""String_Node_Str"").get(3).get(""String_Node_Str"").asMap()).hasSize(0);
}"
9071,"public void handleRedirectCallback(HttpServletRequest request,HttpServletResponse response,RedirectCallback redirectCallback,String loginURL) throws IOException {
  setRedirectCallbackCookie(request,response,redirectCallback,loginURL);
  String qString=AuthClientUtils.getQueryStrFromParameters(redirectCallback.getRedirectData());
  StringBuilder redirectUrl=new StringBuilder(redirectCallback.getRedirectUrl());
  if (qString != null && qString.length() != 0) {
    redirectUrl.append(qString);
  }
  String rUrl=redirectUrl.toString();
  if (rUrl.startsWith(""String_Node_Str"")) {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"" + ""String_Node_Str"" + rUrl + ""String_Node_Str""+ AuthClientUtils.getServiceURI());
    }
    response.sendRedirect(AuthClientUtils.getServiceURI() + rUrl);
  }
 else {
    if (redirectCallback.getMethod().equalsIgnoreCase(""String_Node_Str"")) {
      request.setAttribute(""String_Node_Str"",redirectCallback.getRedirectData());
      request.setAttribute(""String_Node_Str"",redirectCallback.getRedirectUrl());
      try {
        request.getRequestDispatcher(FORWARDING_PLACE).forward(request,response);
      }
 catch (      ServletException e) {
        if (debug.warningEnabled()) {
          debug.warning(""String_Node_Str"" + e.toString());
        }
        throw new RedirectException(""String_Node_Str"",e);
      }
    }
 else {
      response.sendRedirect(rUrl);
    }
  }
}","public void handleRedirectCallback(HttpServletRequest request,HttpServletResponse response,RedirectCallback redirectCallback,String loginURL) throws IOException {
  setRedirectCallbackCookie(request,response,redirectCallback,loginURL);
  String qString=AuthClientUtils.getQueryStrFromParameters(redirectCallback.getRedirectData());
  StringBuilder redirectUrl=new StringBuilder(redirectCallback.getRedirectUrl());
  if (qString != null && qString.length() != 0) {
    redirectUrl.append(qString);
  }
  String rUrl=redirectUrl.toString();
  if (rUrl.startsWith(""String_Node_Str"")) {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"" + ""String_Node_Str"" + rUrl + ""String_Node_Str""+ AuthClientUtils.getServiceURI());
    }
    response.sendRedirect(AuthClientUtils.getServiceURI() + rUrl);
  }
 else {
    if (redirectCallback.getMethod().equalsIgnoreCase(""String_Node_Str"")) {
      Map<String,String> dataMap=redirectCallback.getRedirectData();
      if (dataMap == null) {
        dataMap=new HashMap<>();
      }
      request.setAttribute(""String_Node_Str"",dataMap);
      request.setAttribute(""String_Node_Str"",redirectCallback.getRedirectUrl());
      try {
        request.getRequestDispatcher(FORWARDING_PLACE).forward(request,response);
      }
 catch (      ServletException e) {
        if (debug.warningEnabled()) {
          debug.warning(""String_Node_Str"" + e.toString());
        }
        throw new RedirectException(""String_Node_Str"",e);
      }
    }
 else {
      response.sendRedirect(rUrl);
    }
  }
}"
9072,"/** 
 * Create a body auditor for JSON bodies.
 * @param fields The fields that should be captured if they exist.
 * @return The auditor object.
 */
public static RestletBodyAuditor jacksonAuditor(String... fields){
  return new RestletBodyAuditor<Map<String,Object>>(fields){
    @Override public JsonValue apply(    Representation representation) throws AuditException {
      try {
        if (((JacksonRepresentation)representation).getObject() instanceof Map) {
          return extractValues((Map<String,Object>)((JacksonRepresentation)representation).getObject());
        }
        return json(object());
      }
 catch (      IOException e) {
        throw new AuditException(""String_Node_Str"",e);
      }
    }
    @Override Object getValue(    String field,    Map<String,Object> object) throws AuditException {
      return object.get(field);
    }
  }
;
}","/** 
 * Create a body auditor for JSON bodies.
 * @param fields The fields that should be captured if they exist.
 * @return The auditor object.
 */
public static RestletBodyAuditor jacksonAuditor(String... fields){
  return new RestletBodyAuditor<Map<String,Object>>(fields){
    @Override public JsonValue apply(    Representation representation) throws AuditException {
      try {
        if (!representation.isEmpty() && ((JacksonRepresentation)representation).getObject() instanceof Map) {
          return extractValues((Map<String,Object>)((JacksonRepresentation)representation).getObject());
        }
        return json(object());
      }
 catch (      IOException e) {
        throw new AuditException(""String_Node_Str"",e);
      }
    }
    @Override Object getValue(    String field,    Map<String,Object> object) throws AuditException {
      return object.get(field);
    }
  }
;
}"
9073,"@Override protected void configure(){
  bind(ResourceTypeConfiguration.class).to(ResourceTypeConfigurationImpl.class);
  bind(ResourceTypeService.class).to(ResourceTypeServiceImpl.class);
  bind(ConstraintValidator.class).to(ConstraintValidatorImpl.class);
  install(new FactoryModuleBuilder().implement(ApplicationService.class,ApplicationServiceImpl.class).build(ApplicationServiceFactory.class));
}","@Override protected void configure(){
  bind(ResourceTypeConfiguration.class).to(ResourceTypeConfigurationImpl.class);
  bind(ResourceTypeService.class).to(ResourceTypeServiceImpl.class);
  bind(ConstraintValidator.class).to(ConstraintValidatorImpl.class);
  install(new FactoryModuleBuilder().implement(ApplicationService.class,ApplicationServiceImpl.class).build(ApplicationServiceFactory.class));
  bind(SessionCache.class).toInstance(SessionCache.getInstance());
}"
9074,"/** 
 * Entry point to the engine.
 */
public static void main(String[] argv){
  boolean bBootstrapped=true;
  importSvcCmd=(argv.length > 0) && argv[0].equals(IMPORT_SVC_CMD);
  if (importSvcCmd) {
    try {
      initSys=new InitializeSystem();
    }
 catch (    FileNotFoundException ex) {
      System.err.println(""String_Node_Str"" + ex.getMessage());
      System.exit(1);
    }
catch (    IOException ex) {
      System.err.println(""String_Node_Str"" + ex.getMessage());
    }
catch (    LDAPServiceException ex) {
      System.err.println(""String_Node_Str"" + ex.getMessage());
    }
  }
 else {
    try {
      Bootstrap.load();
      AdminTokenAction.getInstance().authenticationInitialized();
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
 catch (    ConfiguratorException ex) {
      bBootstrapped=false;
      if ((argv.length > 0) && !argv[0].equals(CLIConstants.PREFIX_ARGUMENT_LONG + CLIConstants.ARGUMENT_VERSION) && !argv[0].equals(CLIConstants.PREFIX_ARGUMENT_SHORT + CLIConstants.SHORT_ARGUMENT_VERSION)) {
        System.err.println(ex.getL10NMessage(Locale.getDefault()));
        System.exit(1);
      }
    }
catch (    Exception e) {
      System.err.println(""String_Node_Str"" + e.getMessage());
      System.exit(1);
    }
    if (bBootstrapped) {
      if (VersionCheck.isVersionValid() == 1) {
        System.exit(1);
      }
    }
  }
  if (bBootstrapped) {
    debugger=Debug.getInstance(""String_Node_Str"");
    getIsInstallTime();
    Crypt.checkCaller();
  }
  new CommandManager(argv);
}","/** 
 * Entry point to the engine.
 */
public static void main(String[] argv){
  boolean bBootstrapped=true;
  importSvcCmd=(argv.length > 0) && argv[0].equals(IMPORT_SVC_CMD);
  if (importSvcCmd) {
    try {
      initSys=new InitializeSystem();
    }
 catch (    FileNotFoundException ex) {
      System.err.println(""String_Node_Str"" + ex.getMessage());
      System.exit(1);
    }
catch (    IOException ex) {
      System.err.println(""String_Node_Str"" + ex.getMessage());
    }
catch (    LDAPServiceException ex) {
      System.err.println(""String_Node_Str"" + ex.getMessage());
    }
  }
 else {
    try {
      InjectorConfiguration.setGuiceModuleLoader(new CliGuiceModuleLoader());
      Bootstrap.load();
      AdminTokenAction.getInstance().authenticationInitialized();
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
 catch (    ConfiguratorException ex) {
      bBootstrapped=false;
      if ((argv.length > 0) && !argv[0].equals(CLIConstants.PREFIX_ARGUMENT_LONG + CLIConstants.ARGUMENT_VERSION) && !argv[0].equals(CLIConstants.PREFIX_ARGUMENT_SHORT + CLIConstants.SHORT_ARGUMENT_VERSION)) {
        System.err.println(ex.getL10NMessage(Locale.getDefault()));
        System.exit(1);
      }
    }
catch (    Exception e) {
      System.err.println(""String_Node_Str"" + e.getMessage());
      System.exit(1);
    }
    if (bBootstrapped) {
      if (VersionCheck.isVersionValid() == 1) {
        System.exit(1);
      }
    }
  }
  if (bBootstrapped) {
    debugger=Debug.getInstance(""String_Node_Str"");
    getIsInstallTime();
    Crypt.checkCaller();
  }
  new CommandManager(argv);
}"
9075,"/** 
 * Handles POST requests to the OpenId Connect client registration endpoint for creating OpenId Connect client registrations.
 * @param entity The representation of the client registration details.
 * @return The representation of the client registration details as created in the store.
 * @throws OAuth2RestletException If an error occurs whilst processing the client registration.
 */
@Post public Representation createClient(Representation entity) throws OAuth2RestletException {
  final OAuth2Request request=requestFactory.create(getRequest());
  final ChallengeResponse authHeader=getRequest().getChallengeResponse();
  final String accessToken=authHeader != null ? authHeader.getRawValue() : null;
  try {
    final String deploymentUrl=getRequest().getHostRef().toString() + ""String_Node_Str"" + getRequest().getResourceRef().getSegments().get(0);
    final JsonValue registration=clientRegistrationService.createRegistration(accessToken,deploymentUrl,request);
    setStatus(Status.SUCCESS_CREATED);
    return new JsonRepresentation(registration.asMap());
  }
 catch (  OAuth2Exception e) {
    throw new OAuth2RestletException(e.getStatusCode(),e.getError(),e.getMessage(),null);
  }
}","/** 
 * Handles POST requests to the OpenId Connect client registration endpoint for creating OpenId Connect client registrations.
 * @param entity The representation of the client registration details.
 * @return The representation of the client registration details as created in the store.
 * @throws OAuth2RestletException If an error occurs whilst processing the client registration.
 */
@Post public Representation createClient(Representation entity) throws OAuth2RestletException {
  final OAuth2Request request=requestFactory.create(getRequest());
  final ChallengeResponse authHeader=getRequest().getChallengeResponse();
  final String accessToken=authHeader != null ? authHeader.getRawValue() : null;
  try {
    final String deploymentUrl=getRequest().getHostRef().toString() + ""String_Node_Str"" + getRequest().getResourceRef().getSegments().get(0);
    final JsonValue registration=clientRegistrationService.createRegistration(accessToken,deploymentUrl,request);
    setStatus(Status.SUCCESS_CREATED);
    return new JacksonRepresentation(registration.asMap());
  }
 catch (  OAuth2Exception e) {
    throw new OAuth2RestletException(e.getStatusCode(),e.getError(),e.getMessage(),null);
  }
}"
9076,"/** 
 * Handles GET requests to the OpenId Connect client registration endpoint for retrieving OpenId Connect client registrations.
 * @return The representation of the client registration details.
 * @throws OAuth2RestletException If an error occurs whilst retrieving the client registration.
 */
@Get public Representation getClient() throws OAuth2RestletException {
  final OAuth2Request request=requestFactory.create(getRequest());
  final String clientId=request.getParameter(OAuth2Constants.OAuth2Client.CLIENT_ID);
  final String accessToken=getRequest().getChallengeResponse().getRawValue();
  try {
    final JsonValue registration=clientRegistrationService.getRegistration(clientId,accessToken,request);
    return new JsonRepresentation(registration.asMap());
  }
 catch (  OAuth2Exception e) {
    throw new OAuth2RestletException(e.getStatusCode(),e.getError(),e.getMessage(),null);
  }
}","/** 
 * Handles GET requests to the OpenId Connect client registration endpoint for retrieving OpenId Connect client registrations.
 * @return The representation of the client registration details.
 * @throws OAuth2RestletException If an error occurs whilst retrieving the client registration.
 */
@Get public Representation getClient() throws OAuth2RestletException {
  final OAuth2Request request=requestFactory.create(getRequest());
  final String clientId=request.getParameter(OAuth2Constants.OAuth2Client.CLIENT_ID);
  final String accessToken=getRequest().getChallengeResponse().getRawValue();
  try {
    final JsonValue registration=clientRegistrationService.getRegistration(clientId,accessToken,request);
    return new JacksonRepresentation(registration.asMap());
  }
 catch (  OAuth2Exception e) {
    throw new OAuth2RestletException(e.getStatusCode(),e.getError(),e.getMessage(),null);
  }
}"
9077,"/** 
 * Create a body auditor for JSON bodies.
 * @param fields The fields that should be captured if they exist.
 * @return The auditor object.
 */
public static RestletBodyAuditor jacksonAuditor(String... fields){
  return new RestletBodyAuditor<Map<String,Object>>(fields){
    @Override public JsonValue apply(    Representation representation) throws AuditException {
      try {
        return extractValues((Map<String,Object>)(new JacksonRepresentation(representation).getObject()));
      }
 catch (      IOException e) {
        throw new AuditException(""String_Node_Str"",e);
      }
    }
    @Override Object getValue(    String field,    Map<String,Object> object) throws AuditException {
      return object.get(field);
    }
  }
;
}","/** 
 * Create a body auditor for JSON bodies.
 * @param fields The fields that should be captured if they exist.
 * @return The auditor object.
 */
public static RestletBodyAuditor jacksonAuditor(String... fields){
  return new RestletBodyAuditor<Map<String,Object>>(fields){
    @Override public JsonValue apply(    Representation representation) throws AuditException {
      try {
        if (((JacksonRepresentation)representation).getObject() instanceof Map) {
          return extractValues((Map<String,Object>)((JacksonRepresentation)representation).getObject());
        }
        return json(object());
      }
 catch (      IOException e) {
        throw new AuditException(""String_Node_Str"",e);
      }
    }
    @Override Object getValue(    String field,    Map<String,Object> object) throws AuditException {
      return object.get(field);
    }
  }
;
}"
9078,"/** 
 * Create a body auditor for JSON bodies.
 * @param fields The fields that should be captured if they exist.
 * @return The auditor object.
 */
public static RestletBodyAuditor jsonAuditor(String... fields){
  return new RestletBodyAuditor<JSONObject>(fields){
    @Override public JsonValue apply(    Representation representation) throws AuditException {
      try {
        return extractValues(new JsonRepresentation(representation).getJsonObject());
      }
 catch (      IOException|JSONException e) {
        throw new AuditException(""String_Node_Str"",e);
      }
    }
    @Override Object getValue(    String field,    JSONObject object) throws AuditException {
      return object.opt(field);
    }
  }
;
}","/** 
 * Create a body auditor for JSON bodies.
 * @param fields The fields that should be captured if they exist.
 * @return The auditor object.
 */
public static RestletBodyAuditor jsonAuditor(String... fields){
  return new RestletBodyAuditor<JSONObject>(fields){
    @Override public JsonValue apply(    Representation representation) throws AuditException {
      try {
        boolean isBufferingRepresentation=(representation instanceof BufferingRepresentation);
        boolean isEmptyBufferingRepresentation=isBufferingRepresentation && ((BufferingRepresentation)representation).getWrappedRepresentation().isEmpty();
        if (isEmptyBufferingRepresentation || (!isBufferingRepresentation && representation.isEmpty())) {
          return json(object());
        }
        return extractValues(new JsonRepresentation(representation).getJsonObject());
      }
 catch (      IOException|JSONException e) {
        throw new AuditException(""String_Node_Str"",e);
      }
    }
    @Override Object getValue(    String field,    JSONObject object) throws AuditException {
      return object.opt(field);
    }
  }
;
}"
9079,"/** 
 * Create a body auditor for JSON bodies.
 * @param fields The fields that should be captured if they exist.
 * @return The auditor object.
 */
public static RestletBodyAuditor jacksonAuditor(String... fields){
  return new RestletBodyAuditor<Map<String,Object>>(fields){
    @Override public JsonValue apply(    Representation representation) throws AuditException {
      try {
        return extractValues((Map<String,Object>)((JacksonRepresentation)representation).getObject());
      }
 catch (      IOException e) {
        throw new AuditException(""String_Node_Str"",e);
      }
    }
    @Override Object getValue(    String field,    Map<String,Object> object) throws AuditException {
      return object.get(field);
    }
  }
;
}","/** 
 * Create a body auditor for JSON bodies.
 * @param fields The fields that should be captured if they exist.
 * @return The auditor object.
 */
public static RestletBodyAuditor jacksonAuditor(String... fields){
  return new RestletBodyAuditor<Map<String,Object>>(fields){
    @Override public JsonValue apply(    Representation representation) throws AuditException {
      try {
        return extractValues((Map<String,Object>)(new JacksonRepresentation(representation).getObject()));
      }
 catch (      IOException e) {
        throw new AuditException(""String_Node_Str"",e);
      }
    }
    @Override Object getValue(    String field,    Map<String,Object> object) throws AuditException {
      return object.get(field);
    }
  }
;
}"
9080,"/** 
 * Create a body auditor for JSON bodies.
 * @param fields The fields that should be captured if they exist.
 * @return The auditor object.
 */
public static RestletBodyAuditor jsonAuditor(String... fields){
  return new RestletBodyAuditor<JSONObject>(fields){
    @Override public JsonValue apply(    Representation representation) throws AuditException {
      try {
        return extractValues(((JsonRepresentation)representation).getJsonObject());
      }
 catch (      JSONException e) {
        throw new AuditException(""String_Node_Str"",e);
      }
    }
    @Override Object getValue(    String field,    JSONObject object) throws AuditException {
      return object.opt(field);
    }
  }
;
}","/** 
 * Create a body auditor for JSON bodies.
 * @param fields The fields that should be captured if they exist.
 * @return The auditor object.
 */
public static RestletBodyAuditor jsonAuditor(String... fields){
  return new RestletBodyAuditor<JSONObject>(fields){
    @Override public JsonValue apply(    Representation representation) throws AuditException {
      try {
        return extractValues(new JsonRepresentation(representation).getJsonObject());
      }
 catch (      IOException|JSONException e) {
        throw new AuditException(""String_Node_Str"",e);
      }
    }
    @Override Object getValue(    String field,    JSONObject object) throws AuditException {
      return object.opt(field);
    }
  }
;
}"
9081,"/** 
 * Adds and removes labels on the updated resource set, creating the label if required and deleting labels which are no longer used.
 * @param resourceSet The updated resource set.
 */
void updateLabelsForExistingResourceSet(ResourceSetDescription resourceSet){
  JsonValue newLabels=resourceSet.getDescription().get(OAuth2Constants.ResourceSets.LABELS);
  if (newLabels.isNull()) {
    newLabels=json(array());
  }
  Collection<String> addedLabels=newLabels.asSet(String.class);
  try {
    Set<ResourceSetLabel> labels=labelsStore.forResourceSet(resourceSet.getRealm(),resourceSet.getResourceOwnerId(),resourceSet.getId(),true);
    Collection<String> removedLabels=new HashSet<>();
    for (    ResourceSetLabel label : labels) {
      String labelName=label.getName().substring(label.getName().lastIndexOf(""String_Node_Str"") + 1);
      if (!addedLabels.remove(labelName)) {
        removedLabels.add(labelName);
      }
    }
    updateLabels(resourceSet,addedLabels,removedLabels);
  }
 catch (  ResourceException e) {
    logger.error(""String_Node_Str"",resourceSet.getId(),e);
  }
}","/** 
 * Adds and removes labels on the updated resource set, creating the label if required and deleting labels which are no longer used.
 * @param resourceSet The updated resource set.
 */
void updateLabelsForExistingResourceSet(ResourceSetDescription resourceSet){
  JsonValue newLabels=resourceSet.getDescription().get(OAuth2Constants.ResourceSets.LABELS);
  if (newLabels.isNull()) {
    newLabels=json(array());
  }
  Collection<String> addedLabels=new HashSet<>(newLabels.asSet(String.class));
  try {
    Set<ResourceSetLabel> labels=labelsStore.forResourceSet(resourceSet.getRealm(),resourceSet.getResourceOwnerId(),resourceSet.getId(),true);
    Collection<String> removedLabels=new HashSet<>();
    for (    ResourceSetLabel label : labels) {
      String labelName=label.getName().substring(label.getName().lastIndexOf(""String_Node_Str"") + 1);
      if (!addedLabels.remove(labelName)) {
        removedLabels.add(labelName);
      }
    }
    updateLabels(resourceSet,addedLabels,removedLabels);
  }
 catch (  ResourceException e) {
    logger.error(""String_Node_Str"",resourceSet.getId(),e);
  }
}"
9082,"private Representation readResourceSet(String resourceSetId) throws NotFoundException, ServerException {
  ResourceSetStore store=providerSettingsFactory.get(requestFactory.create(getRequest())).getResourceSetStore();
  return createJsonResponse(store.read(resourceSetId),true,true);
}","private Representation readResourceSet(String resourceSetId) throws NotFoundException, ServerException {
  ResourceSetStore store=providerSettingsFactory.get(requestFactory.create(getRequest())).getResourceSetStore();
  ResourceSetDescription resourceSetDescription=store.read(resourceSetId);
  Set<String> labels=new HashSet<String>();
  try {
    Set<ResourceSetLabel> labelSet=umaLabelsStore.forResourceSet(resourceSetDescription.getRealm(),resourceSetDescription.getResourceOwnerId(),resourceSetDescription.getId(),false);
    for (    ResourceSetLabel label : labelSet) {
      labels.add(label.getName());
    }
  }
 catch (  org.forgerock.json.resource.ResourceException e) {
    throw new ServerException(e);
  }
  resourceSetDescription.getDescription().put(""String_Node_Str"",labels);
  return createJsonResponse(resourceSetDescription,true,true);
}"
9083,"/** 
 * <p>Creates or updates a resource set description.</p> <p>If the request contains a If-Match header an update is performed, otherwise a create is performed.</p> <p>An update will replace the current description of the resource set with the contents of the request body.</p>
 * @param entity The new resource set description.
 * @return A JSON object containing the authorization server's unique id for the resource set and, optionally,a policy uri.
 * @throws NotFoundException If the requested resource set description does not exist.
 * @throws ServerException When an error occurs during creating or updating.
 * @throws BadRequestException If the request JSON is invalid.
 */
@Post public Representation createResourceSet(JsonRepresentation entity) throws NotFoundException, ServerException, BadRequestException {
  ResourceSetDescription resourceSetDescription=new ResourceSetDescription(null,getClientId(),getResourceOwnerId(),validator.validate(toMap(entity)));
  OAuth2Request oAuth2Request=requestFactory.create(getRequest());
  ResourceSetStore store=providerSettingsFactory.get(oAuth2Request).getResourceSetStore();
  QueryFilter<String> query=QueryFilter.and(QueryFilter.equalTo(ResourceSetTokenField.NAME,resourceSetDescription.getName()),QueryFilter.equalTo(ResourceSetTokenField.CLIENT_ID,getClientId()),QueryFilter.equalTo(ResourceSetTokenField.RESOURCE_OWNER_ID,getResourceOwnerId()));
  if (!store.query(query).isEmpty()) {
    getResponse().setStatus(Status.CLIENT_ERROR_BAD_REQUEST);
    Map<String,Object> response=new HashMap<String,Object>();
    response.put(OAuth2Constants.Params.ERROR,Status.CLIENT_ERROR_BAD_REQUEST.getReasonPhrase());
    response.put(OAuth2Constants.Params.ERROR_DESCRIPTION,""String_Node_Str"" + resourceSetDescription.getName() + ""String_Node_Str"");
    return new JsonRepresentation(response);
  }
  JsonValue labels=resourceSetDescription.getDescription().get(OAuth2Constants.ResourceSets.LABELS);
  resourceSetDescription.getDescription().remove(OAuth2Constants.ResourceSets.LABELS);
  for (  ResourceRegistrationFilter filter : extensionFilterManager.getFilters(ResourceRegistrationFilter.class)) {
    filter.beforeResourceRegistration(resourceSetDescription);
  }
  store.create(oAuth2Request,resourceSetDescription);
  resourceSetDescription.getDescription().add(OAuth2Constants.ResourceSets.LABELS,labels);
  labelRegistration.updateLabelsForNewResourceSet(resourceSetDescription);
  for (  ResourceRegistrationFilter filter : extensionFilterManager.getFilters(ResourceRegistrationFilter.class)) {
    filter.afterResourceRegistration(resourceSetDescription);
  }
  for (  ResourceSetRegistrationListener listener : listeners) {
    listener.resourceSetCreated(oAuth2Request.<String>getParameter(""String_Node_Str""),resourceSetDescription);
  }
  getResponse().setStatus(Status.SUCCESS_CREATED);
  return createJsonResponse(resourceSetDescription,false,true);
}","/** 
 * <p>Creates or updates a resource set description.</p> <p>If the request contains a If-Match header an update is performed, otherwise a create is performed.</p> <p>An update will replace the current description of the resource set with the contents of the request body.</p>
 * @param entity The new resource set description.
 * @return A JSON object containing the authorization server's unique id for the resource set and, optionally,a policy uri.
 * @throws NotFoundException If the requested resource set description does not exist.
 * @throws ServerException When an error occurs during creating or updating.
 * @throws BadRequestException If the request JSON is invalid.
 */
@Post public Representation createResourceSet(JsonRepresentation entity) throws NotFoundException, ServerException, BadRequestException {
  ResourceSetDescription resourceSetDescription=new ResourceSetDescription(null,getClientId(),getResourceOwnerId(),validator.validate(toMap(entity)));
  OAuth2Request oAuth2Request=requestFactory.create(getRequest());
  ResourceSetStore store=providerSettingsFactory.get(oAuth2Request).getResourceSetStore();
  QueryFilter<String> query=QueryFilter.and(QueryFilter.equalTo(ResourceSetTokenField.NAME,resourceSetDescription.getName()),QueryFilter.equalTo(ResourceSetTokenField.CLIENT_ID,getClientId()),QueryFilter.equalTo(ResourceSetTokenField.RESOURCE_OWNER_ID,getResourceOwnerId()));
  if (!store.query(query).isEmpty()) {
    getResponse().setStatus(Status.CLIENT_ERROR_BAD_REQUEST);
    Map<String,Object> response=new HashMap<String,Object>();
    response.put(OAuth2Constants.Params.ERROR,Status.CLIENT_ERROR_BAD_REQUEST.getReasonPhrase());
    response.put(OAuth2Constants.Params.ERROR_DESCRIPTION,""String_Node_Str"" + resourceSetDescription.getName() + ""String_Node_Str"");
    return new JsonRepresentation(response);
  }
  JsonValue labels=resourceSetDescription.getDescription().get(OAuth2Constants.ResourceSets.LABELS);
  resourceSetDescription.getDescription().remove(OAuth2Constants.ResourceSets.LABELS);
  for (  ResourceRegistrationFilter filter : extensionFilterManager.getFilters(ResourceRegistrationFilter.class)) {
    filter.beforeResourceRegistration(resourceSetDescription);
  }
  store.create(oAuth2Request,resourceSetDescription);
  if (labels.isNotNull()) {
    resourceSetDescription.getDescription().add(OAuth2Constants.ResourceSets.LABELS,labels.asSet());
  }
  labelRegistration.updateLabelsForNewResourceSet(resourceSetDescription);
  for (  ResourceRegistrationFilter filter : extensionFilterManager.getFilters(ResourceRegistrationFilter.class)) {
    filter.afterResourceRegistration(resourceSetDescription);
  }
  for (  ResourceSetRegistrationListener listener : listeners) {
    listener.resourceSetCreated(oAuth2Request.<String>getParameter(""String_Node_Str""),resourceSetDescription);
  }
  getResponse().setStatus(Status.SUCCESS_CREATED);
  return createJsonResponse(resourceSetDescription,false,true);
}"
9084,"private Tag generateETag(ResourceSetDescription resourceSetDescription){
  return new Tag(Integer.toString(resourceSetDescription.hashCode()),true);
}","private Tag generateETag(ResourceSetDescription resourceSetDescription){
  int hashCode=resourceSetDescription.hashCode();
  JsonValue description=resourceSetDescription.getDescription();
  if (!description.isDefined(OAuth2Constants.ResourceSets.LABELS)) {
    description.put(OAuth2Constants.ResourceSets.LABELS,null);
    hashCode=resourceSetDescription.hashCode();
    description.remove(OAuth2Constants.ResourceSets.LABELS);
  }
  return new Tag(Integer.toString(hashCode),true);
}"
9085,"@Put public Representation updateResourceSet(JsonRepresentation entity) throws NotFoundException, ServerException, BadRequestException {
  if (!isConditionalRequest()) {
    throw new ResourceException(512,""String_Node_Str"",""String_Node_Str"",null);
  }
  final Map<String,Object> resourceSetDescriptionAttributes=validator.validate(toMap(entity));
  final String resourceSetId=getResourceSetId();
  ResourceSetStore store=providerSettingsFactory.get(requestFactory.create(getRequest())).getResourceSetStore();
  ResourceSetDescription resourceSetDescription=store.read(resourceSetId).update(resourceSetDescriptionAttributes);
  JsonValue labels=resourceSetDescription.getDescription().get(OAuth2Constants.ResourceSets.LABELS);
  resourceSetDescription.getDescription().remove(OAuth2Constants.ResourceSets.LABELS);
  store.update(resourceSetDescription);
  resourceSetDescription.getDescription().add(OAuth2Constants.ResourceSets.LABELS,labels);
  labelRegistration.updateLabelsForExistingResourceSet(resourceSetDescription);
  return createJsonResponse(resourceSetDescription,false,true);
}","@Put public Representation updateResourceSet(JsonRepresentation entity) throws NotFoundException, ServerException, BadRequestException {
  if (!isConditionalRequest()) {
    throw new ResourceException(512,""String_Node_Str"",""String_Node_Str"",null);
  }
  final Map<String,Object> resourceSetDescriptionAttributes=validator.validate(toMap(entity));
  final String resourceSetId=getResourceSetId();
  ResourceSetStore store=providerSettingsFactory.get(requestFactory.create(getRequest())).getResourceSetStore();
  ResourceSetDescription resourceSetDescription=store.read(resourceSetId).update(resourceSetDescriptionAttributes);
  JsonValue labels=resourceSetDescription.getDescription().get(OAuth2Constants.ResourceSets.LABELS);
  resourceSetDescription.getDescription().remove(OAuth2Constants.ResourceSets.LABELS);
  store.update(resourceSetDescription);
  if (labels.isNotNull()) {
    resourceSetDescription.getDescription().add(OAuth2Constants.ResourceSets.LABELS,labels.asSet());
  }
 else {
    resourceSetDescription.getDescription().add(OAuth2Constants.ResourceSets.LABELS,new HashSet<String>());
  }
  labelRegistration.updateLabelsForExistingResourceSet(resourceSetDescription);
  return createJsonResponse(resourceSetDescription,false,true);
}"
9086,"/** 
 * Construct a new ResourceSetRegistrationEndpoint instance.
 * @param providerSettingsFactory An instance of the {@link OAuth2ProviderSettingsFactory}.
 * @param validator An instance of the {@link ResourceSetDescriptionValidator}.
 * @param requestFactory An instance of the OAuth2RequestFactory.
 * @param listeners A {@code Set} of {@code ResourceSetRegistrationListener}s.
 * @param labelRegistration An instance of the {@code ResourceSetLabelRegistration}.
 * @param extensionFilterManager An instance of the {@code ExtensionFilterManager}.
 * @param exceptionHandler An instance of the {@code ExceptionHandler}.
 */
@Inject public ResourceSetRegistrationEndpoint(OAuth2ProviderSettingsFactory providerSettingsFactory,ResourceSetDescriptionValidator validator,OAuth2RequestFactory<Request> requestFactory,Set<ResourceSetRegistrationListener> listeners,ResourceSetLabelRegistration labelRegistration,ExtensionFilterManager extensionFilterManager,ExceptionHandler exceptionHandler){
  this.providerSettingsFactory=providerSettingsFactory;
  this.validator=validator;
  this.requestFactory=requestFactory;
  this.listeners=listeners;
  this.labelRegistration=labelRegistration;
  this.extensionFilterManager=extensionFilterManager;
  this.exceptionHandler=exceptionHandler;
}","/** 
 * Construct a new ResourceSetRegistrationEndpoint instance.
 * @param providerSettingsFactory An instance of the {@link OAuth2ProviderSettingsFactory}.
 * @param validator An instance of the {@link ResourceSetDescriptionValidator}.
 * @param requestFactory An instance of the OAuth2RequestFactory.
 * @param listeners A {@code Set} of {@code ResourceSetRegistrationListener}s.
 * @param labelRegistration An instance of the {@code ResourceSetLabelRegistration}.
 * @param extensionFilterManager An instance of the {@code ExtensionFilterManager}.
 * @param exceptionHandler An instance of the {@code ExceptionHandler}.
 * @param umaLabelsStore An instance of the Uma Label Store
 */
@Inject public ResourceSetRegistrationEndpoint(OAuth2ProviderSettingsFactory providerSettingsFactory,ResourceSetDescriptionValidator validator,OAuth2RequestFactory<Request> requestFactory,Set<ResourceSetRegistrationListener> listeners,ResourceSetLabelRegistration labelRegistration,ExtensionFilterManager extensionFilterManager,ExceptionHandler exceptionHandler,UmaLabelsStore umaLabelsStore){
  this.providerSettingsFactory=providerSettingsFactory;
  this.validator=validator;
  this.requestFactory=requestFactory;
  this.listeners=listeners;
  this.labelRegistration=labelRegistration;
  this.extensionFilterManager=extensionFilterManager;
  this.exceptionHandler=exceptionHandler;
  this.umaLabelsStore=umaLabelsStore;
}"
9087,"@BeforeMethod @SuppressWarnings(""String_Node_Str"") public void setup() throws ServerException, InvalidGrantException, NotFoundException {
  store=mock(ResourceSetStore.class);
  validator=mock(ResourceSetDescriptionValidator.class);
  OAuth2RequestFactory<Request> requestFactory=mock(OAuth2RequestFactory.class);
  Set<ResourceSetRegistrationListener> listeners=new HashSet<ResourceSetRegistrationListener>();
  listener=mock(ResourceSetRegistrationListener.class);
  listeners.add(listener);
  labelRegistration=mock(ResourceSetLabelRegistration.class);
  ExtensionFilterManager extensionFilterManager=mock(ExtensionFilterManager.class);
  resourceRegistrationFilter=mock(ResourceRegistrationFilter.class);
  given(extensionFilterManager.getFilters(ResourceRegistrationFilter.class)).willReturn(Collections.singletonList(resourceRegistrationFilter));
  OAuth2ProviderSettingsFactory providerSettingsFactory=mock(OAuth2ProviderSettingsFactory.class);
  OAuth2ProviderSettings providerSettings=mock(OAuth2ProviderSettings.class);
  given(providerSettingsFactory.get(Matchers.<OAuth2Request>anyObject())).willReturn(providerSettings);
  given(providerSettings.getResourceSetStore()).willReturn(store);
  ExceptionHandler exceptionHandler=mock(ExceptionHandler.class);
  endpoint=spy(new ResourceSetRegistrationEndpoint(providerSettingsFactory,validator,requestFactory,listeners,labelRegistration,extensionFilterManager,exceptionHandler));
  Request request=mock(Request.class);
  ChallengeResponse challengeResponse=new ChallengeResponse(ChallengeScheme.HTTP_BASIC);
  challengeResponse.setRawValue(""String_Node_Str"");
  given(request.getChallengeResponse()).willReturn(challengeResponse);
  given(endpoint.getRequest()).willReturn(request);
  AccessToken accessToken=mock(AccessToken.class);
  given(accessToken.getClientId()).willReturn(""String_Node_Str"");
  given(accessToken.getResourceOwnerId()).willReturn(""String_Node_Str"");
  response=mock(Response.class);
  given(endpoint.getResponse()).willReturn(response);
  OAuth2Request oAuth2Request=mock(OAuth2Request.class);
  given(requestFactory.create(Matchers.<Request>anyObject())).willReturn(oAuth2Request);
  given(oAuth2Request.getToken(AccessToken.class)).willReturn(accessToken);
}","@BeforeMethod @SuppressWarnings(""String_Node_Str"") public void setup() throws ServerException, InvalidGrantException, NotFoundException {
  store=mock(ResourceSetStore.class);
  validator=mock(ResourceSetDescriptionValidator.class);
  OAuth2RequestFactory<Request> requestFactory=mock(OAuth2RequestFactory.class);
  Set<ResourceSetRegistrationListener> listeners=new HashSet<ResourceSetRegistrationListener>();
  listener=mock(ResourceSetRegistrationListener.class);
  listeners.add(listener);
  labelRegistration=mock(ResourceSetLabelRegistration.class);
  ExtensionFilterManager extensionFilterManager=mock(ExtensionFilterManager.class);
  resourceRegistrationFilter=mock(ResourceRegistrationFilter.class);
  given(extensionFilterManager.getFilters(ResourceRegistrationFilter.class)).willReturn(Collections.singletonList(resourceRegistrationFilter));
  OAuth2ProviderSettingsFactory providerSettingsFactory=mock(OAuth2ProviderSettingsFactory.class);
  OAuth2ProviderSettings providerSettings=mock(OAuth2ProviderSettings.class);
  given(providerSettingsFactory.get(Matchers.<OAuth2Request>anyObject())).willReturn(providerSettings);
  given(providerSettings.getResourceSetStore()).willReturn(store);
  ExceptionHandler exceptionHandler=mock(ExceptionHandler.class);
  UmaLabelsStore umaLabelsStore=mock(UmaLabelsStore.class);
  endpoint=spy(new ResourceSetRegistrationEndpoint(providerSettingsFactory,validator,requestFactory,listeners,labelRegistration,extensionFilterManager,exceptionHandler,umaLabelsStore));
  Request request=mock(Request.class);
  ChallengeResponse challengeResponse=new ChallengeResponse(ChallengeScheme.HTTP_BASIC);
  challengeResponse.setRawValue(""String_Node_Str"");
  given(request.getChallengeResponse()).willReturn(challengeResponse);
  given(endpoint.getRequest()).willReturn(request);
  AccessToken accessToken=mock(AccessToken.class);
  given(accessToken.getClientId()).willReturn(""String_Node_Str"");
  given(accessToken.getResourceOwnerId()).willReturn(""String_Node_Str"");
  response=mock(Response.class);
  given(endpoint.getResponse()).willReturn(response);
  OAuth2Request oAuth2Request=mock(OAuth2Request.class);
  given(requestFactory.create(Matchers.<Request>anyObject())).willReturn(oAuth2Request);
  given(oAuth2Request.getToken(AccessToken.class)).willReturn(accessToken);
}"
9088,"/** 
 * Gets and processes the Single <code>LogoutResponse</code> from IDP, destroys the local session, checks response's issuer and inResponseTo.
 * @param request the HttpServletRequest.
 * @param response the HttpServletResponse.
 * @param samlResponse <code>LogoutResponse</code> in theXML string format.
 * @param relayState the target URL on successful<code>LogoutResponse</code>.
 * @throws SAML2Exception if error processing<code>LogoutResponse</code>.
 * @throws SessionException if error processing<code>LogoutResponse</code>.
 */
public static Map<String,String> processLogoutResponse(HttpServletRequest request,HttpServletResponse response,String samlResponse,String relayState) throws SAML2Exception, SessionException {
  String method=""String_Node_Str"";
  if (debug.messageEnabled()) {
    debug.message(method + ""String_Node_Str"" + samlResponse);
    debug.message(method + ""String_Node_Str"" + relayState);
  }
  String rmethod=request.getMethod();
  String binding=SAML2Constants.HTTP_REDIRECT;
  if (rmethod.equals(""String_Node_Str"")) {
    binding=SAML2Constants.HTTP_POST;
  }
  String metaAlias=SAML2MetaUtils.getMetaAliasByUri(request.getRequestURI());
  if ((SPCache.isFedlet) && ((metaAlias == null) || (metaAlias.length() == 0))) {
    List spMetaAliases=sm.getAllHostedServiceProviderMetaAliases(""String_Node_Str"");
    if ((spMetaAliases != null) && !spMetaAliases.isEmpty()) {
      metaAlias=(String)spMetaAliases.get(0);
    }
  }
  if ((metaAlias == null) || (metaAlias.length() == 0)) {
    throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
  }
  String realm=SAML2Utils.getRealm(SAML2MetaUtils.getRealmByMetaAlias(metaAlias));
  String spEntityID=sm.getEntityByMetaAlias(metaAlias);
  if (!SAML2Utils.isSPProfileBindingSupported(realm,spEntityID,SAML2Constants.SLO_SERVICE,binding)) {
    throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
  }
  SAML2Utils.validateRelayStateURL(realm,spEntityID,relayState,SAML2Constants.SP_ROLE);
  LogoutResponse logoutRes=null;
  if (rmethod.equals(""String_Node_Str"")) {
    logoutRes=LogoutUtil.getLogoutResponseFromPost(samlResponse,response);
  }
 else   if (rmethod.equals(""String_Node_Str"")) {
    String decodedStr=SAML2Utils.decodeFromRedirect(samlResponse);
    if (decodedStr == null) {
      throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
    }
    logoutRes=ProtocolFactory.getInstance().createLogoutResponse(decodedStr);
  }
  if (logoutRes == null) {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"" + ""String_Node_Str"");
    }
    return null;
  }
  String idpEntityID=logoutRes.getIssuer().getValue();
  Issuer resIssuer=logoutRes.getIssuer();
  String inResponseTo=logoutRes.getInResponseTo();
  LogoutRequest logoutReq=(LogoutRequest)SPCache.logoutRequestIDHash.remove(inResponseTo);
  if (logoutReq == null && SAML2FailoverUtils.isSAML2FailoverEnabled()) {
    try {
      logoutReq=(LogoutRequest)SAML2FailoverUtils.retrieveSAML2Token(inResponseTo);
    }
 catch (    SAML2TokenRepositoryException e) {
      throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
    }
  }
 else {
    logoutReq=(LogoutRequest)SAML2Store.getTokenFromStore(inResponseTo);
  }
  String userId=null;
  if (!SPCache.isFedlet) {
    userId=preSingleLogoutProcess(spEntityID,realm,request,response,null,logoutReq,logoutRes,binding);
  }
  SAML2Utils.verifyResponseIssuer(realm,spEntityID,resIssuer,inResponseTo);
  boolean needToVerify=SAML2Utils.getWantLogoutResponseSigned(realm,spEntityID,SAML2Constants.SP_ROLE);
  if (debug.messageEnabled()) {
    debug.message(method + ""String_Node_Str"" + metaAlias);
    debug.message(method + ""String_Node_Str"" + realm);
    debug.message(method + ""String_Node_Str"" + idpEntityID);
    debug.message(method + ""String_Node_Str"" + spEntityID);
  }
  Map<String,String> infoMap=new HashMap<String,String>();
  infoMap.put(""String_Node_Str"",spEntityID);
  infoMap.put(SAML2Constants.REALM,realm);
  if (needToVerify) {
    boolean valid=false;
    if (rmethod.equals(""String_Node_Str"")) {
      String queryString=request.getQueryString();
      valid=SAML2Utils.verifyQueryString(queryString,realm,SAML2Constants.SP_ROLE,idpEntityID);
    }
 else {
      valid=LogoutUtil.verifySLOResponse(logoutRes,realm,idpEntityID,spEntityID,SAML2Constants.SP_ROLE);
    }
    if (!valid) {
      debug.error(""String_Node_Str"" + ""String_Node_Str"");
      throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
    }
    SPSSODescriptorElement spsso=sm.getSPSSODescriptor(realm,spEntityID);
    String loc=getSLOResponseLocationOrLocation(spsso,binding);
    if (!SAML2Utils.verifyDestination(logoutRes.getDestination(),loc)) {
      throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
    }
  }
  if (inResponseTo == null || inResponseTo.length() == 0) {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"");
    }
    throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
  }
  if (logoutReq != null) {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"" + ""String_Node_Str"");
    }
    throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
  }
  infoMap.put(""String_Node_Str"",inResponseTo);
  infoMap.put(SAML2Constants.RELAY_STATE,relayState);
  try {
    Object session=sessionProvider.getSession(request);
    if ((session != null) && sessionProvider.isValid(session)) {
      sessionProvider.invalidateSession(session,request,response);
    }
  }
 catch (  SessionException se) {
    debug.message(""String_Node_Str"" + se.getMessage());
  }
  if (!SPCache.isFedlet) {
    if (isSuccess(logoutRes)) {
      postSingleLogoutSuccess(spEntityID,realm,request,response,userId,logoutReq,logoutRes,binding);
    }
 else {
      throw new SAML2Exception(SAML2Utils.BUNDLE_NAME,""String_Node_Str"",null);
    }
  }
 else {
    FedletAdapter fedletAdapter=SAML2Utils.getFedletAdapterClass(spEntityID,realm);
    if (fedletAdapter != null) {
      if (isSuccess(logoutRes)) {
        fedletAdapter.onFedletSLOSuccess(request,response,logoutReq,logoutRes,spEntityID,idpEntityID,binding);
      }
 else {
        fedletAdapter.onFedletSLOFailure(request,response,logoutReq,logoutRes,spEntityID,idpEntityID,binding);
        throw new SAML2Exception(SAML2Utils.BUNDLE_NAME,""String_Node_Str"",null);
      }
    }
  }
  return infoMap;
}","/** 
 * Gets and processes the Single <code>LogoutResponse</code> from IDP, destroys the local session, checks response's issuer and inResponseTo.
 * @param request the HttpServletRequest.
 * @param response the HttpServletResponse.
 * @param samlResponse <code>LogoutResponse</code> in theXML string format.
 * @param relayState the target URL on successful<code>LogoutResponse</code>.
 * @throws SAML2Exception if error processing<code>LogoutResponse</code>.
 * @throws SessionException if error processing<code>LogoutResponse</code>.
 */
public static Map<String,String> processLogoutResponse(HttpServletRequest request,HttpServletResponse response,String samlResponse,String relayState) throws SAML2Exception, SessionException {
  String method=""String_Node_Str"";
  if (debug.messageEnabled()) {
    debug.message(method + ""String_Node_Str"" + samlResponse);
    debug.message(method + ""String_Node_Str"" + relayState);
  }
  String rmethod=request.getMethod();
  String binding=SAML2Constants.HTTP_REDIRECT;
  if (rmethod.equals(""String_Node_Str"")) {
    binding=SAML2Constants.HTTP_POST;
  }
  String metaAlias=SAML2MetaUtils.getMetaAliasByUri(request.getRequestURI());
  if ((SPCache.isFedlet) && ((metaAlias == null) || (metaAlias.length() == 0))) {
    List spMetaAliases=sm.getAllHostedServiceProviderMetaAliases(""String_Node_Str"");
    if ((spMetaAliases != null) && !spMetaAliases.isEmpty()) {
      metaAlias=(String)spMetaAliases.get(0);
    }
  }
  if ((metaAlias == null) || (metaAlias.length() == 0)) {
    throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
  }
  String realm=SAML2Utils.getRealm(SAML2MetaUtils.getRealmByMetaAlias(metaAlias));
  String spEntityID=sm.getEntityByMetaAlias(metaAlias);
  if (!SAML2Utils.isSPProfileBindingSupported(realm,spEntityID,SAML2Constants.SLO_SERVICE,binding)) {
    throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
  }
  SAML2Utils.validateRelayStateURL(realm,spEntityID,relayState,SAML2Constants.SP_ROLE);
  LogoutResponse logoutRes=null;
  if (rmethod.equals(""String_Node_Str"")) {
    logoutRes=LogoutUtil.getLogoutResponseFromPost(samlResponse,response);
  }
 else   if (rmethod.equals(""String_Node_Str"")) {
    String decodedStr=SAML2Utils.decodeFromRedirect(samlResponse);
    if (decodedStr == null) {
      throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
    }
    logoutRes=ProtocolFactory.getInstance().createLogoutResponse(decodedStr);
  }
  if (logoutRes == null) {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"" + ""String_Node_Str"");
    }
    return null;
  }
  String idpEntityID=logoutRes.getIssuer().getValue();
  Issuer resIssuer=logoutRes.getIssuer();
  String inResponseTo=logoutRes.getInResponseTo();
  LogoutRequest logoutReq=(LogoutRequest)SPCache.logoutRequestIDHash.remove(inResponseTo);
  if (logoutReq == null) {
    logoutReq=(LogoutRequest)SAML2Store.getTokenFromStore(inResponseTo);
  }
  if (logoutReq == null && SAML2FailoverUtils.isSAML2FailoverEnabled()) {
    try {
      logoutReq=(LogoutRequest)SAML2FailoverUtils.retrieveSAML2Token(inResponseTo);
    }
 catch (    SAML2TokenRepositoryException e) {
      throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
    }
  }
  String userId=null;
  if (!SPCache.isFedlet) {
    userId=preSingleLogoutProcess(spEntityID,realm,request,response,null,logoutReq,logoutRes,binding);
  }
  SAML2Utils.verifyResponseIssuer(realm,spEntityID,resIssuer,inResponseTo);
  boolean needToVerify=SAML2Utils.getWantLogoutResponseSigned(realm,spEntityID,SAML2Constants.SP_ROLE);
  if (debug.messageEnabled()) {
    debug.message(method + ""String_Node_Str"" + metaAlias);
    debug.message(method + ""String_Node_Str"" + realm);
    debug.message(method + ""String_Node_Str"" + idpEntityID);
    debug.message(method + ""String_Node_Str"" + spEntityID);
  }
  Map<String,String> infoMap=new HashMap<String,String>();
  infoMap.put(""String_Node_Str"",spEntityID);
  infoMap.put(SAML2Constants.REALM,realm);
  if (needToVerify) {
    boolean valid=false;
    if (rmethod.equals(""String_Node_Str"")) {
      String queryString=request.getQueryString();
      valid=SAML2Utils.verifyQueryString(queryString,realm,SAML2Constants.SP_ROLE,idpEntityID);
    }
 else {
      valid=LogoutUtil.verifySLOResponse(logoutRes,realm,idpEntityID,spEntityID,SAML2Constants.SP_ROLE);
    }
    if (!valid) {
      debug.error(""String_Node_Str"" + ""String_Node_Str"");
      throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
    }
    SPSSODescriptorElement spsso=sm.getSPSSODescriptor(realm,spEntityID);
    String loc=getSLOResponseLocationOrLocation(spsso,binding);
    if (!SAML2Utils.verifyDestination(logoutRes.getDestination(),loc)) {
      throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
    }
  }
  if (inResponseTo == null || inResponseTo.length() == 0) {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"");
    }
    throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
  }
  if (logoutReq != null) {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"" + ""String_Node_Str"");
    }
    throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
  }
  infoMap.put(""String_Node_Str"",inResponseTo);
  infoMap.put(SAML2Constants.RELAY_STATE,relayState);
  try {
    Object session=sessionProvider.getSession(request);
    if ((session != null) && sessionProvider.isValid(session)) {
      sessionProvider.invalidateSession(session,request,response);
    }
  }
 catch (  SessionException se) {
    debug.message(""String_Node_Str"" + se.getMessage());
  }
  if (!SPCache.isFedlet) {
    if (isSuccess(logoutRes)) {
      postSingleLogoutSuccess(spEntityID,realm,request,response,userId,logoutReq,logoutRes,binding);
    }
 else {
      throw new SAML2Exception(SAML2Utils.BUNDLE_NAME,""String_Node_Str"",null);
    }
  }
 else {
    FedletAdapter fedletAdapter=SAML2Utils.getFedletAdapterClass(spEntityID,realm);
    if (fedletAdapter != null) {
      if (isSuccess(logoutRes)) {
        fedletAdapter.onFedletSLOSuccess(request,response,logoutReq,logoutRes,spEntityID,idpEntityID,binding);
      }
 else {
        fedletAdapter.onFedletSLOFailure(request,response,logoutReq,logoutRes,spEntityID,idpEntityID,binding);
        throw new SAML2Exception(SAML2Utils.BUNDLE_NAME,""String_Node_Str"",null);
      }
    }
  }
  return infoMap;
}"
9089,"/** 
 * Lets through any request which is coming from a verifiable administrator.
 */
protected Promise<AuthorizationResult,ResourceException> authorize(Context context){
  try {
    String userId=getUserId(context);
    if (isSuperUser(userId)) {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + userId + ""String_Node_Str"");
      }
      return Promises.newResultPromise(AuthorizationResult.accessPermitted());
    }
 else {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + userId);
      }
      return Promises.newResultPromise(AuthorizationResult.accessDenied(""String_Node_Str""));
    }
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
}","/** 
 * Lets through any request which is coming from a verifiable administrator.
 */
protected Promise<AuthorizationResult,ResourceException> authorize(Context context){
  try {
    String userId=getUserId(context);
    if (isSuperUser(userId)) {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + userId + ""String_Node_Str"");
      }
      return Promises.newResultPromise(AuthorizationResult.accessPermitted());
    }
 else {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + userId);
      }
      return Promises.newResultPromise(AuthorizationResult.accessDenied(""String_Node_Str""));
    }
  }
 catch (  ForbiddenException e) {
    return Promises.newResultPromise(AuthorizationResult.accessDenied(""String_Node_Str""));
  }
catch (  ResourceException re) {
    return re.asPromise();
  }
}"
9090,"/** 
 * Given the calling context and the privilege definition attempts to authorise the calling subject.
 * @param context the server context
 * @param definition the privilege definition
 * @return the authorisation result
 */
private Promise<AuthorizationResult,ResourceException> evaluate(final Context context,final PrivilegeDefinition definition){
  final String realm=(context.containsContext(RealmContext.class)) ? context.asContext(RealmContext.class).getResolvedRealm() : ""String_Node_Str"";
  final SubjectContext subjectContext=context.asContext(SubjectContext.class);
  final UriRouterContext routerContext=context.asContext(UriRouterContext.class);
  final Set<String> actions=transformSet(definition.getActions(),ACTION_TO_STRING_MAPPER);
  try {
    final DelegationPermission permissionRequest=permissionFactory.newInstance(realm,REST,VERSION,routerContext.getMatchedUri(),definition.getCommonVerb(),actions,Collections.<String,String>emptyMap());
    if (evaluator.isAllowed(subjectContext.getCallerSSOToken(),permissionRequest,Collections.<String,Set<String>>emptyMap())) {
      return Promises.newResultPromise(AuthorizationResult.accessPermitted());
    }
  }
 catch (  DelegationException dE) {
    return new InternalServerErrorException(""String_Node_Str"",dE).asPromise();
  }
catch (  SSOException ssoE) {
    return new InternalServerErrorException(""String_Node_Str"",ssoE).asPromise();
  }
  return Promises.newResultPromise(AuthorizationResult.accessDenied(""String_Node_Str""));
}","/** 
 * Given the calling context and the privilege definition attempts to authorise the calling subject.
 * @param context the server context
 * @param definition the privilege definition
 * @return the authorisation result
 */
private Promise<AuthorizationResult,ResourceException> evaluate(final Context context,final PrivilegeDefinition definition){
  final String realm=(context.containsContext(RealmContext.class)) ? context.asContext(RealmContext.class).getResolvedRealm() : ""String_Node_Str"";
  final SubjectContext subjectContext=context.asContext(SubjectContext.class);
  final UriRouterContext routerContext=context.asContext(UriRouterContext.class);
  final Set<String> actions=transformSet(definition.getActions(),ACTION_TO_STRING_MAPPER);
  try {
    final DelegationPermission permissionRequest=permissionFactory.newInstance(realm,REST,VERSION,routerContext.getMatchedUri(),definition.getCommonVerb(),actions,Collections.<String,String>emptyMap());
    if (evaluator.isAllowed(subjectContext.getCallerSSOToken(),permissionRequest,Collections.<String,Set<String>>emptyMap())) {
      return Promises.newResultPromise(AuthorizationResult.accessPermitted());
    }
  }
 catch (  DelegationException dE) {
    return new InternalServerErrorException(""String_Node_Str"",dE).asPromise();
  }
catch (  SSOException ssoE) {
    return Promises.newResultPromise(AuthorizationResult.accessDenied(""String_Node_Str""));
  }
  return Promises.newResultPromise(AuthorizationResult.accessDenied(""String_Node_Str""));
}"
9091,"@Test(expectedExceptions=ResourceException.class) public void shouldErrorInvalidContext() throws SSOException, ResourceException, InterruptedException {
  SSOTokenContext mockSSOTokenContext=mock(SSOTokenContext.class);
  SSOToken mockSSOToken=mock(SSOToken.class);
  given(mockSSOTokenContext.getCallerSSOToken()).willReturn(mockSSOToken);
  given(mockSSOToken.getProperty(Constants.UNIVERSAL_IDENTIFIER)).willThrow(new SSOException(""String_Node_Str""));
  Promise<AuthorizationResult,ResourceException> result=testModule.authorize(mockSSOTokenContext);
  result.getOrThrow();
}","@Test public void shouldErrorInvalidContext() throws SSOException, ResourceException, InterruptedException, ExecutionException {
  SSOTokenContext mockSSOTokenContext=mock(SSOTokenContext.class);
  SSOToken mockSSOToken=mock(SSOToken.class);
  given(mockSSOTokenContext.getCallerSSOToken()).willReturn(mockSSOToken);
  given(mockSSOToken.getProperty(Constants.UNIVERSAL_IDENTIFIER)).willThrow(new SSOException(""String_Node_Str""));
  Promise<AuthorizationResult,ResourceException> result=testModule.authorize(mockSSOTokenContext);
  assertFalse(result.get().isAuthorized());
}"
9092,"/** 
 * Set the result.
 * @param result The result.
 */
public void setResult(EventOutcome result){
  this.entry.put(RESULT_KEY,result);
}","/** 
 * Set the result.
 * @param result The result.
 */
public void setResult(AuthenticationAuditEventBuilder.Status result){
  this.entry.put(RESULT_KEY,result);
}"
9093,"/** 
 * Get the result.
 * @return The result.
 */
public EventOutcome getResult(){
  return (EventOutcome)this.entry.get(RESULT_KEY);
}","/** 
 * Get the result.
 * @return The result.
 */
public AuthenticationAuditEventBuilder.Status getResult(){
  return (AuthenticationAuditEventBuilder.Status)this.entry.get(RESULT_KEY);
}"
9094,"/** 
 * Writes a log record.
 * @param s Array of data information for the log record.
 * @param type Type of log either <code>LOG_ERROR</code> or<code>LOG_ACCESS</code>.
 * @param messageName Message ID for the log record.
 * @param ssoProperties Single Sign On Properties to be written to thelog record. If this is <code>null</code>, properties will be retrieved from administrator Single Sign On Token.
 */
public void logIt(String[] s,int type,String messageName,Hashtable ssoProperties){
  LogMessageProviderBase provider=null;
  if (logStatus && (s != null)) {
    try {
      provider=(LogMessageProviderBase)MessageProviderFactory.getProvider(""String_Node_Str"");
      com.sun.identity.log.LogRecord lr=null;
      SSOToken ssot=AccessController.doPrivileged(AdminTokenAction.getInstance());
      if (ssoProperties == null) {
        lr=provider.createLogRecord(messageName,s,ssot);
      }
 else {
        lr=provider.createLogRecord(messageName,s,ssoProperties);
      }
      com.sun.identity.log.Logger logger;
switch (type) {
case LOG_ACCESS:
        logger=(com.sun.identity.log.Logger)Logger.getLogger(""String_Node_Str"");
      logger.log(lr,ssot);
    break;
case LOG_ERROR:
  logger=(com.sun.identity.log.Logger)Logger.getLogger(""String_Node_Str"");
logger.log(lr,ssot);
break;
default :
logger=(com.sun.identity.log.Logger)Logger.getLogger(""String_Node_Str"");
logger.log(lr,ssot);
break;
}
}
 catch (IOException ex) {
ex.printStackTrace();
debug.error(""String_Node_Str"" + ex.getMessage());
}
}
initializeAuditor();
String orgName=(String)ssoProperties.get(""String_Node_Str"");
String realmName=DNMapper.orgNameToRealmName(orgName);
boolean isAuditing=false;
if (isAuthenticationOnlyEvent(messageName)) {
if (auditor.isAuditing(realmName,AuditConstants.AUTHENTICATION_TOPIC)) {
isAuditing=true;
}
}
if (isActivityOnlyEvent(messageName)) {
if (auditor.isAuditing(realmName,AuditConstants.ACTIVITY_TOPIC)) {
isAuditing=true;
}
}
if (isAuditing) {
if (!auditor.isLogoutEvent(messageName)) {
String description=null;
if (provider != null) {
description=provider.getAllHashMessageIDs().get(messageName).getDescription();
}
String userName=(String)ssoProperties.get(""String_Node_Str"");
String contextID=(String)ssoProperties.get(LogConstants.CONTEXT_ID);
String LoginIDSid=(String)ssoProperties.get(LogConstants.LOGIN_ID_SID);
Set<String> trackingIds=null;
if (StringUtils.isNotEmpty(contextID)) {
trackingIds=new HashSet<>();
trackingIds.add(contextID);
}
if (StringUtils.isNotEmpty(LoginIDSid)) {
InternalSession session=AuthD.getSession(new SessionID(LoginIDSid));
String sessionContext;
if (session != null) {
if (trackingIds == null) {
trackingIds=new HashSet<>();
}
sessionContext=session.getProperty(Constants.AM_CTX_ID);
trackingIds.add(sessionContext);
}
}
AMIdentity identity=IdUtils.getIdentity(userName,realmName);
String authentication=null;
String principal;
if (identity != null) {
authentication=identity.getUniversalId();
if (contextID != null) {
principal=getPrincipalFromUniversalId(identity.getName());
}
 else {
principal=identity.getName();
}
}
 else {
principal=userName;
}
String moduleName=(String)ssoProperties.get(""String_Node_Str"");
AuthenticationAuditEventBuilder.Status result=null;
List<AuthenticationAuditEntry> entries=null;
if (StringUtils.isNotEmpty(moduleName)) {
Map<String,String> info=null;
String ip=(String)ssoProperties.get(LogConstants.IP_ADDR);
if (StringUtils.isNotEmpty(ip)) {
info=new HashMap<>();
info.put(IP_ADDRESS.toString(),ip);
}
if (StringUtils.isNotEmpty(description)) {
if (info == null) {
info=new HashMap<>();
}
info.put(EVENT_DATA.toString(),description);
}
AuthenticationAuditEntry authenticationAuditEntry=new AuthenticationAuditEntry();
authenticationAuditEntry.setModuleId(moduleName);
messageName=AM_LOGIN_CHAIN_COMPLETED.toString();
if (info != null) {
authenticationAuditEntry.setInfo(info);
}
entries=Collections.singletonList(authenticationAuditEntry);
if (contextID == null) {
result=FAILED;
}
 else {
result=SUCCESSFUL;
}
}
auditor.audit(messageName,AuditRequestContext.getTransactionIdValue(),authentication,principal,realmName,trackingIds,entries,result);
}
}
}","/** 
 * Writes a log record.
 * @param s Array of data information for the log record.
 * @param type Type of log either <code>LOG_ERROR</code> or<code>LOG_ACCESS</code>.
 * @param messageName Message ID for the log record.
 * @param ssoProperties Single Sign On Properties to be written to thelog record. If this is <code>null</code>, properties will be retrieved from administrator Single Sign On Token.
 */
public void logIt(String[] s,int type,String messageName,Hashtable ssoProperties){
  LogMessageProviderBase provider=null;
  if (logStatus && (s != null)) {
    try {
      provider=(LogMessageProviderBase)MessageProviderFactory.getProvider(""String_Node_Str"");
      com.sun.identity.log.LogRecord lr=null;
      SSOToken ssot=AccessController.doPrivileged(AdminTokenAction.getInstance());
      if (ssoProperties == null) {
        lr=provider.createLogRecord(messageName,s,ssot);
      }
 else {
        lr=provider.createLogRecord(messageName,s,ssoProperties);
      }
      com.sun.identity.log.Logger logger;
switch (type) {
case LOG_ACCESS:
        logger=(com.sun.identity.log.Logger)Logger.getLogger(""String_Node_Str"");
      logger.log(lr,ssot);
    break;
case LOG_ERROR:
  logger=(com.sun.identity.log.Logger)Logger.getLogger(""String_Node_Str"");
logger.log(lr,ssot);
break;
default :
logger=(com.sun.identity.log.Logger)Logger.getLogger(""String_Node_Str"");
logger.log(lr,ssot);
break;
}
}
 catch (IOException ex) {
ex.printStackTrace();
debug.error(""String_Node_Str"" + ex.getMessage());
}
}
initializeAuditor();
String orgName=(String)ssoProperties.get(""String_Node_Str"");
String realmName=DNMapper.orgNameToRealmName(orgName);
boolean isAuditing=false;
if (isAuthenticationOnlyEvent(messageName)) {
if (auditor.isAuditing(realmName,AuditConstants.AUTHENTICATION_TOPIC)) {
isAuditing=true;
}
}
if (isActivityOnlyEvent(messageName)) {
if (auditor.isAuditing(realmName,AuditConstants.ACTIVITY_TOPIC)) {
isAuditing=true;
}
}
if (isAuditing) {
if (!auditor.isLogoutEvent(messageName)) {
String description=null;
if (provider != null) {
description=provider.getAllHashMessageIDs().get(messageName).getDescription();
}
String userName=(String)ssoProperties.get(""String_Node_Str"");
String contextID=(String)ssoProperties.get(LogConstants.CONTEXT_ID);
String LoginIDSid=(String)ssoProperties.get(LogConstants.LOGIN_ID_SID);
Set<String> trackingIds=null;
if (StringUtils.isNotEmpty(contextID)) {
trackingIds=new HashSet<>();
trackingIds.add(contextID);
}
if (StringUtils.isNotEmpty(LoginIDSid)) {
InternalSession session=AuthD.getSession(new SessionID(LoginIDSid));
String sessionContext;
if (session != null) {
if (trackingIds == null) {
trackingIds=new HashSet<>();
}
sessionContext=session.getProperty(Constants.AM_CTX_ID);
trackingIds.add(sessionContext);
}
}
AMIdentity identity=null;
if (StringUtils.isNotEmpty(userName) && StringUtils.isNotEmpty(realmName)) {
identity=IdUtils.getIdentity(userName,realmName);
}
String authentication=null;
String principal;
if (identity != null) {
authentication=identity.getUniversalId();
if (contextID != null) {
principal=getPrincipalFromUniversalId(identity.getName());
}
 else {
principal=identity.getName();
}
}
 else {
principal=userName;
}
String moduleName=(String)ssoProperties.get(""String_Node_Str"");
AuthenticationAuditEventBuilder.Status result=null;
List<AuthenticationAuditEntry> entries=null;
if (StringUtils.isNotEmpty(moduleName)) {
Map<String,String> info=null;
String ip=(String)ssoProperties.get(LogConstants.IP_ADDR);
if (StringUtils.isNotEmpty(ip)) {
info=new HashMap<>();
info.put(IP_ADDRESS.toString(),ip);
}
if (StringUtils.isNotEmpty(description)) {
if (info == null) {
info=new HashMap<>();
}
info.put(EVENT_DATA.toString(),description);
}
AuthenticationAuditEntry authenticationAuditEntry=new AuthenticationAuditEntry();
authenticationAuditEntry.setModuleId(moduleName);
messageName=AM_LOGIN_CHAIN_COMPLETED.toString();
if (info != null) {
authenticationAuditEntry.setInfo(info);
}
entries=Collections.singletonList(authenticationAuditEntry);
if (contextID == null) {
result=FAILED;
}
 else {
result=SUCCESSFUL;
}
}
auditor.audit(messageName,AuditRequestContext.getTransactionIdValue(),authentication,principal,realmName,trackingIds,entries,result);
}
}
}"
9095,"private boolean auditAuthenticationEvent(String description,String transactionId,String authentication,String realmName,long time,Map<String,String> contexts,List<?> entries){
  boolean couldHandleEvent=true;
  AMAuthenticationAuditEventBuilder builder=authenticationAuditor.authenticationEvent();
  builder.transactionId(transactionId).authentication(authentication).timestamp(time).component(AuditConstants.Component.AUTHENTICATION);
  if (StringUtils.isNotEmpty(description)) {
    builder.eventName(description);
  }
  if (StringUtils.isNotEmpty(realmName)) {
    builder.realm(realmName);
  }
  if (contexts != null && !contexts.isEmpty()) {
    builder.contexts(contexts);
  }
  if (entries != null && !entries.isEmpty()) {
    builder.entries(entries);
  }
  try {
    authenticationAuditor.publish(builder.toEvent());
  }
 catch (  AuditException e) {
    couldHandleEvent=false;
  }
  return couldHandleEvent;
}","private boolean auditAuthenticationEvent(String description,String transactionId,String authentication,String realmName,long time,Map<String,String> contexts,List<Entry> entries){
  boolean couldHandleEvent=true;
  AMAuthenticationAuditEventBuilder builder=authenticationAuditor.authenticationEvent();
  builder.transactionId(transactionId).authentication(authentication).timestamp(time).component(AuditConstants.Component.AUTHENTICATION);
  if (StringUtils.isNotEmpty(description)) {
    builder.eventName(description);
  }
  if (StringUtils.isNotEmpty(realmName)) {
    builder.realm(realmName);
  }
  if (contexts != null && !contexts.isEmpty()) {
    builder.contexts(contexts);
  }
  if (entries != null && !entries.isEmpty()) {
    List<Map<String,Object>> list=new ArrayList<>();
    for (    Entry entry : entries) {
      Map<String,Object> map=new HashMap<>();
      map.put(""String_Node_Str"",entry.getModuleId());
      map.put(""String_Node_Str"",entry.getResult());
      map.put(""String_Node_Str"",entry.getInfo());
      list.add(map);
    }
    builder.entries(list);
  }
  try {
    authenticationAuditor.publish(builder.toEvent());
  }
 catch (  AuditException e) {
    couldHandleEvent=false;
  }
  return couldHandleEvent;
}"
9096,"/** 
 * Audit an event generated from a legacy context. Depending upon the configuration the user has chosen, the event may be audited, or silently ignored. Note that if an event is for a topic which is not being audited, true may still be returned, which would indicate that the event was handled successfully (not sent anywhere, respecting the configuration) and there were no errors. A return value of true does not mean that the event was actually logged, only that no error occurred in the attempt to log it. To find out if a specific topic is being audited, use  {@link LegacyAuthenticationEventAuditor#isAuditing(java.lang.String,java.lang.String)}.
 * @param eventName The description of the event which occurred (see {@code AuthenticationLogMessageIDs.xml}'name' attribute of each logmessage element.
 * @param eventDescription The description of the event which occurred (see {@code AuthenticationLogMessageIDs.xml}'description' attribute of each logmessage element. Cannot be null.
 * @param transactionId The transaction id for the audit event. Cannot be null.
 * @param authentication The authentication details for the audit event. Cannot be null.
 * @param realmName The realm name for the audit event. May be null.
 * @param time The time the audit event occurred. May be null.
 * @param contexts Any contexts for the audit event. May be null.
 * @param entries Any extra information for the audit event. May be null.
 * @return true if the event was handled, false if there was some sort of problem.
 */
public boolean audit(String eventName,String eventDescription,String transactionId,String authentication,String realmName,long time,Map<String,String> contexts,List<?> entries){
  Reject.ifNull(transactionId,""String_Node_Str"");
  Reject.ifNull(authentication,""String_Node_Str"");
  Reject.ifNull(eventDescription,""String_Node_Str"");
  boolean isActivityEvent=false;
  boolean isAuthenticationEvent=true;
  if (StringUtils.isNotEmpty(eventName)) {
    if (""String_Node_Str"".equals(eventName)) {
      isActivityEvent=true;
      isAuthenticationEvent=false;
    }
  }
  if (isAuthenticationEvent) {
    return auditAuthenticationEvent(eventDescription,transactionId,authentication,realmName,time,contexts,entries);
  }
  if (isActivityEvent) {
    return auditActivityEvent(eventDescription,transactionId,authentication,realmName,time,contexts);
  }
  return false;
}","/** 
 * Audit an event generated from a legacy context. Depending upon the configuration the user has chosen, the event may be audited, or silently ignored. Note that if an event is for a topic which is not being audited, true may still be returned, which would indicate that the event was handled successfully (not sent anywhere, respecting the configuration) and there were no errors. A return value of true does not mean that the event was actually logged, only that no error occurred in the attempt to log it. To find out if a specific topic is being audited, use  {@link LegacyAuthenticationEventAuditor#isAuditing(java.lang.String,java.lang.String)}.
 * @param eventName The description of the event which occurred (see {@code AuthenticationLogMessageIDs.xml}'name' attribute of each logmessage element.
 * @param eventDescription The description of the event which occurred (see {@code AuthenticationLogMessageIDs.xml}'description' attribute of each logmessage element. Cannot be null.
 * @param transactionId The transaction id for the audit event. Cannot be null.
 * @param authentication The authentication details for the audit event. Cannot be null.
 * @param realmName The realm name for the audit event. May be null.
 * @param time The time the audit event occurred. May be null.
 * @param contexts Any contexts for the audit event. May be null.
 * @param entries Any extra information for the audit event. May be null.
 * @return true if the event was handled, false if there was some sort of problem.
 */
public boolean audit(String eventName,String eventDescription,String transactionId,String authentication,String realmName,long time,Map<String,String> contexts,List<Entry> entries){
  Reject.ifNull(transactionId,""String_Node_Str"");
  Reject.ifNull(authentication,""String_Node_Str"");
  Reject.ifNull(eventDescription,""String_Node_Str"");
  boolean isActivityEvent=false;
  boolean isAuthenticationEvent=true;
  if (StringUtils.isNotEmpty(eventName)) {
    if (""String_Node_Str"".equals(eventName)) {
      isActivityEvent=true;
      isAuthenticationEvent=false;
    }
  }
  if (isAuthenticationEvent) {
    return auditAuthenticationEvent(eventDescription,transactionId,authentication,realmName,time,contexts,entries);
  }
  if (isActivityEvent) {
    return auditActivityEvent(eventDescription,transactionId,authentication,realmName,time,contexts);
  }
  return false;
}"
9097,"/** 
 * Writes a log record.
 * @param s Array of data information for the log record.
 * @param type Type of log either <code>LOG_ERROR</code> or<code>LOG_ACCESS</code>.
 * @param messageName Message ID for the log record.
 * @param ssoProperties Single Sign On Properties to be written to thelog record. If this is <code>null</code>, properties will be retrieved from administrator Single Sign On Token.
 */
public void logIt(String[] s,int type,String messageName,Hashtable ssoProperties){
  if (logStatus && (s != null)) {
    try {
      LogMessageProviderBase provider=(LogMessageProviderBase)MessageProviderFactory.getProvider(""String_Node_Str"");
      if (auditor == null) {
        auditor=InjectorHolder.getInstance(LegacyAuthenticationEventAuditor.class);
      }
      CoreWrapper cw=new CoreWrapper();
      String orgName=(String)ssoProperties.get(""String_Node_Str"");
      String realmName=cw.convertOrgNameToRealmName(orgName);
      if (auditor.isAuditing(realmName)) {
        if (!auditor.isLogoutEvent(messageName)) {
          String userName=(String)ssoProperties.get(""String_Node_Str"");
          String description=provider.getAllHashMessageIDs().get(messageName).getDescription();
          String contextID=(String)ssoProperties.get(""String_Node_Str"");
          String LoginIDSid=(String)ssoProperties.get(""String_Node_Str"");
          long time=Calendar.getInstance().getTimeInMillis();
          Map<String,String> contexts=null;
          if (StringUtils.isNotEmpty(contextID)) {
            contexts=new HashMap<>();
            contexts.put(AUTH.toString(),contextID);
          }
          if (StringUtils.isNotEmpty(LoginIDSid)) {
            InternalSession session=AuthD.getSession(new SessionID(LoginIDSid));
            String sessionContext=null;
            if (session != null) {
              sessionContext=session.getProperty(Constants.AM_CTX_ID);
              contexts.put(SESSION.toString(),sessionContext);
            }
          }
          AMIdentity identity=cw.getIdentity(userName,realmName);
          String authentication=null;
          if (identity != null) {
            authentication=identity.getUniversalId();
          }
          String moduleName=(String)ssoProperties.get(""String_Node_Str"");
          List<?> entries=null;
          if (StringUtils.isNotEmpty(moduleName)) {
            Map<String,String> info=new HashMap<>();
            String ip=(String)ssoProperties.get(""String_Node_Str"");
            if (StringUtils.isNotEmpty(ip)) {
              info=Collections.singletonMap(""String_Node_Str"",ip);
            }
            Map<String,Object> map=new HashMap<>();
            map.put(""String_Node_Str"",moduleName);
            map.put(""String_Node_Str"",description);
            description=AM_LOGIN_CHAIN_COMPLETED.toString();
            map.put(""String_Node_Str"",info);
            entries=Collections.singletonList(map);
          }
          auditor.audit(messageName,description,AuditRequestContext.getTransactionIdValue(),authentication,realmName,time,contexts,entries);
        }
      }
      com.sun.identity.log.LogRecord lr=null;
      SSOToken ssot=AccessController.doPrivileged(AdminTokenAction.getInstance());
      if (ssoProperties == null) {
        lr=provider.createLogRecord(messageName,s,ssot);
      }
 else {
        lr=provider.createLogRecord(messageName,s,ssoProperties);
      }
      com.sun.identity.log.Logger logger;
switch (type) {
case LOG_ACCESS:
        logger=(com.sun.identity.log.Logger)Logger.getLogger(""String_Node_Str"");
      logger.log(lr,ssot);
    break;
case LOG_ERROR:
  logger=(com.sun.identity.log.Logger)Logger.getLogger(""String_Node_Str"");
logger.log(lr,ssot);
break;
default :
logger=(com.sun.identity.log.Logger)Logger.getLogger(""String_Node_Str"");
logger.log(lr,ssot);
break;
}
}
 catch (IOException ex) {
ex.printStackTrace();
debug.error(""String_Node_Str"" + ex.getMessage());
}
}
}","/** 
 * Writes a log record.
 * @param s Array of data information for the log record.
 * @param type Type of log either <code>LOG_ERROR</code> or<code>LOG_ACCESS</code>.
 * @param messageName Message ID for the log record.
 * @param ssoProperties Single Sign On Properties to be written to thelog record. If this is <code>null</code>, properties will be retrieved from administrator Single Sign On Token.
 */
public void logIt(String[] s,int type,String messageName,Hashtable ssoProperties){
  if (logStatus && (s != null)) {
    try {
      LogMessageProviderBase provider=(LogMessageProviderBase)MessageProviderFactory.getProvider(""String_Node_Str"");
      if (auditor == null) {
        auditor=InjectorHolder.getInstance(LegacyAuthenticationEventAuditor.class);
      }
      CoreWrapper cw=new CoreWrapper();
      String orgName=(String)ssoProperties.get(""String_Node_Str"");
      String realmName=cw.convertOrgNameToRealmName(orgName);
      if (auditor.isAuditing(realmName)) {
        if (!auditor.isLogoutEvent(messageName)) {
          String userName=(String)ssoProperties.get(""String_Node_Str"");
          String description=provider.getAllHashMessageIDs().get(messageName).getDescription();
          String contextID=(String)ssoProperties.get(""String_Node_Str"");
          String LoginIDSid=(String)ssoProperties.get(""String_Node_Str"");
          long time=Calendar.getInstance().getTimeInMillis();
          Map<String,String> contexts=null;
          if (StringUtils.isNotEmpty(contextID)) {
            contexts=new HashMap<>();
            contexts.put(AUTH.toString(),contextID);
          }
          if (StringUtils.isNotEmpty(LoginIDSid)) {
            InternalSession session=AuthD.getSession(new SessionID(LoginIDSid));
            String sessionContext=null;
            if (session != null) {
              sessionContext=session.getProperty(Constants.AM_CTX_ID);
              contexts.put(SESSION.toString(),sessionContext);
            }
          }
          AMIdentity identity=cw.getIdentity(userName,realmName);
          String authentication=null;
          if (identity != null) {
            authentication=identity.getUniversalId();
          }
          String moduleName=(String)ssoProperties.get(""String_Node_Str"");
          List<Entry> entries=null;
          if (StringUtils.isNotEmpty(moduleName)) {
            Map<String,String> info=null;
            String ip=(String)ssoProperties.get(""String_Node_Str"");
            if (StringUtils.isNotEmpty(ip)) {
              info=Collections.singletonMap(""String_Node_Str"",ip);
            }
            Entry entry=new Entry();
            entry.setModuleId(moduleName);
            entry.setResult(description);
            description=AM_LOGIN_CHAIN_COMPLETED.toString();
            if (info != null) {
              entry.setInfo(info);
            }
            entries=Collections.singletonList(entry);
          }
          auditor.audit(messageName,description,AuditRequestContext.getTransactionIdValue(),authentication,realmName,time,contexts,entries);
        }
      }
      com.sun.identity.log.LogRecord lr=null;
      SSOToken ssot=AccessController.doPrivileged(AdminTokenAction.getInstance());
      if (ssoProperties == null) {
        lr=provider.createLogRecord(messageName,s,ssot);
      }
 else {
        lr=provider.createLogRecord(messageName,s,ssoProperties);
      }
      com.sun.identity.log.Logger logger;
switch (type) {
case LOG_ACCESS:
        logger=(com.sun.identity.log.Logger)Logger.getLogger(""String_Node_Str"");
      logger.log(lr,ssot);
    break;
case LOG_ERROR:
  logger=(com.sun.identity.log.Logger)Logger.getLogger(""String_Node_Str"");
logger.log(lr,ssot);
break;
default :
logger=(com.sun.identity.log.Logger)Logger.getLogger(""String_Node_Str"");
logger.log(lr,ssot);
break;
}
}
 catch (IOException ex) {
ex.printStackTrace();
debug.error(""String_Node_Str"" + ex.getMessage());
}
}
}"
9098,"/** 
 * Log Logout status 
 */
public void logLogout(SSOToken ssot){
  try {
    String logLogout=bundle.getString(""String_Node_Str"");
    List<String> dataList=new ArrayList<String>();
    dataList.add(logLogout);
    StringBuilder messageId=new StringBuilder();
    messageId.append(""String_Node_Str"");
    String indexType=ssot.getProperty(ISAuthConstants.INDEX_TYPE);
    if (indexType != null) {
      messageId.append(""String_Node_Str"").append(indexType.toUpperCase());
      dataList.add(indexType);
      if (indexType.equals(AuthContext.IndexType.USER.toString())) {
        dataList.add(ssot.getProperty(ISAuthConstants.PRINCIPAL));
      }
 else       if (indexType.equals(AuthContext.IndexType.ROLE.toString())) {
        dataList.add(ssot.getProperty(ISAuthConstants.ROLE));
      }
 else       if (indexType.equals(AuthContext.IndexType.SERVICE.toString())) {
        dataList.add(ssot.getProperty(ISAuthConstants.SERVICE));
      }
 else       if (indexType.equals(AuthContext.IndexType.LEVEL.toString())) {
        dataList.add(ssot.getProperty(ISAuthConstants.AUTH_LEVEL));
      }
 else       if (indexType.equals(AuthContext.IndexType.MODULE_INSTANCE.toString())) {
        dataList.add(ssot.getProperty(ISAuthConstants.AUTH_TYPE));
      }
    }
    Hashtable<String,String> props=new Hashtable<String,String>();
    String client=ssot.getProperty(ISAuthConstants.HOST);
    if (client != null) {
      props.put(LogConstants.IP_ADDR,client);
    }
    String userDN=ssot.getProperty(ISAuthConstants.PRINCIPAL);
    if (userDN != null) {
      props.put(LogConstants.LOGIN_ID,userDN);
    }
    String orgDN=ssot.getProperty(ISAuthConstants.ORGANIZATION);
    if (orgDN != null) {
      props.put(LogConstants.DOMAIN,orgDN);
    }
    String authMethName=ssot.getProperty(ISAuthConstants.AUTH_TYPE);
    if (authMethName != null) {
      props.put(LogConstants.MODULE_NAME,authMethName);
    }
    String contextId=null;
    contextId=ssot.getProperty(Constants.AM_CTX_ID);
    if (contextId != null) {
      props.put(LogConstants.CONTEXT_ID,contextId);
    }
    props.put(LogConstants.LOGIN_ID_SID,ssot.getTokenID().toString());
    String[] data=dataList.toArray(new String[dataList.size()]);
    if (auditor == null) {
      auditor=InjectorHolder.getInstance(LegacyAuthenticationEventAuditor.class);
    }
    CoreWrapper cw=new CoreWrapper();
    String realmName=cw.convertOrgNameToRealmName(orgDN);
    if (auditor.isAuditing(realmName,AuditConstants.AUTHENTICATION_TOPIC)) {
      String messageName=messageId.toString();
      LogMessageProviderBase provider=null;
      if (logStatus) {
        try {
          provider=(LogMessageProviderBase)MessageProviderFactory.getProvider(""String_Node_Str"");
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      String description=""String_Node_Str"";
      if (provider != null) {
        description=provider.getAllHashMessageIDs().get(messageName).getDescription();
      }
      long time=Calendar.getInstance().getTimeInMillis();
      Map<String,String> contexts=null;
      if (StringUtils.isNotEmpty(contextId)) {
        contexts=new HashMap<>();
        contexts.put(AuditConstants.Context.SESSION.toString(),contextId);
      }
      AMIdentity identity=cw.getIdentity(userDN,realmName);
      String authentication=null;
      if (identity != null) {
        authentication=identity.getUniversalId();
      }
      List<?> entries;
      Map<String,String> info=new HashMap<>();
      if (StringUtils.isNotEmpty(client)) {
        info=Collections.singletonMap(""String_Node_Str"",client);
      }
      Map<String,Object> map=new HashMap<>();
      map.put(""String_Node_Str"",authMethName);
      map.put(""String_Node_Str"",description);
      map.put(""String_Node_Str"",info);
      entries=Collections.singletonList(map);
      auditor.audit(messageName,AM_LOGOUT.toString(),AuditRequestContext.getTransactionIdValue(),authentication,realmName,time,contexts,entries);
    }
    this.logIt(data,LOG_ACCESS,messageId.toString(),props);
  }
 catch (  SSOException ssoExp) {
    debug.error(""String_Node_Str"",ssoExp);
  }
catch (  Exception e) {
    debug.error(""String_Node_Str"",e);
  }
}","/** 
 * Log Logout status 
 */
public void logLogout(SSOToken ssot){
  try {
    String logLogout=bundle.getString(""String_Node_Str"");
    List<String> dataList=new ArrayList<String>();
    dataList.add(logLogout);
    StringBuilder messageId=new StringBuilder();
    messageId.append(""String_Node_Str"");
    String indexType=ssot.getProperty(ISAuthConstants.INDEX_TYPE);
    if (indexType != null) {
      messageId.append(""String_Node_Str"").append(indexType.toUpperCase());
      dataList.add(indexType);
      if (indexType.equals(AuthContext.IndexType.USER.toString())) {
        dataList.add(ssot.getProperty(ISAuthConstants.PRINCIPAL));
      }
 else       if (indexType.equals(AuthContext.IndexType.ROLE.toString())) {
        dataList.add(ssot.getProperty(ISAuthConstants.ROLE));
      }
 else       if (indexType.equals(AuthContext.IndexType.SERVICE.toString())) {
        dataList.add(ssot.getProperty(ISAuthConstants.SERVICE));
      }
 else       if (indexType.equals(AuthContext.IndexType.LEVEL.toString())) {
        dataList.add(ssot.getProperty(ISAuthConstants.AUTH_LEVEL));
      }
 else       if (indexType.equals(AuthContext.IndexType.MODULE_INSTANCE.toString())) {
        dataList.add(ssot.getProperty(ISAuthConstants.AUTH_TYPE));
      }
    }
    Hashtable<String,String> props=new Hashtable<String,String>();
    String client=ssot.getProperty(ISAuthConstants.HOST);
    if (client != null) {
      props.put(LogConstants.IP_ADDR,client);
    }
    String userDN=ssot.getProperty(ISAuthConstants.PRINCIPAL);
    if (userDN != null) {
      props.put(LogConstants.LOGIN_ID,userDN);
    }
    String orgDN=ssot.getProperty(ISAuthConstants.ORGANIZATION);
    if (orgDN != null) {
      props.put(LogConstants.DOMAIN,orgDN);
    }
    String authMethName=ssot.getProperty(ISAuthConstants.AUTH_TYPE);
    if (authMethName != null) {
      props.put(LogConstants.MODULE_NAME,authMethName);
    }
    String contextId=null;
    contextId=ssot.getProperty(Constants.AM_CTX_ID);
    if (contextId != null) {
      props.put(LogConstants.CONTEXT_ID,contextId);
    }
    props.put(LogConstants.LOGIN_ID_SID,ssot.getTokenID().toString());
    String[] data=dataList.toArray(new String[dataList.size()]);
    if (auditor == null) {
      auditor=InjectorHolder.getInstance(LegacyAuthenticationEventAuditor.class);
    }
    CoreWrapper cw=new CoreWrapper();
    String realmName=cw.convertOrgNameToRealmName(orgDN);
    if (auditor.isAuditing(realmName,AuditConstants.AUTHENTICATION_TOPIC)) {
      String messageName=messageId.toString();
      LogMessageProviderBase provider=null;
      if (logStatus) {
        try {
          provider=(LogMessageProviderBase)MessageProviderFactory.getProvider(""String_Node_Str"");
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      String description=""String_Node_Str"";
      if (provider != null) {
        description=provider.getAllHashMessageIDs().get(messageName).getDescription();
      }
      long time=Calendar.getInstance().getTimeInMillis();
      Map<String,String> contexts=null;
      if (StringUtils.isNotEmpty(contextId)) {
        contexts=new HashMap<>();
        contexts.put(AuditConstants.Context.SESSION.toString(),contextId);
      }
      AMIdentity identity=cw.getIdentity(userDN,realmName);
      String authentication=null;
      if (identity != null) {
        authentication=identity.getUniversalId();
      }
      List<Entry> entries;
      Map<String,String> info=new HashMap<>();
      if (StringUtils.isNotEmpty(client)) {
        info=Collections.singletonMap(""String_Node_Str"",client);
      }
      Entry entry=new Entry();
      entry.setModuleId(authMethName);
      entry.setResult(description);
      entry.setInfo(info);
      entries=Collections.singletonList(entry);
      auditor.audit(messageName,AM_LOGOUT.toString(),AuditRequestContext.getTransactionIdValue(),authentication,realmName,time,contexts,entries);
    }
    this.logIt(data,LOG_ACCESS,messageId.toString(),props);
  }
 catch (  SSOException ssoExp) {
    debug.error(""String_Node_Str"",ssoExp);
  }
catch (  Exception e) {
    debug.error(""String_Node_Str"",e);
  }
}"
9099,"public static Map<String,Set<String>> getEmptySMSAttributeState(){
  HashMap<String,Set<String>> emptyAttributeMap=new HashMap<>();
  emptyAttributeMap.put(NAME_ID_FORMAT,Collections.<String>emptySet());
  emptyAttributeMap.put(ATTRIBUTE_MAP,Collections.<String>emptySet());
  emptyAttributeMap.put(TOKEN_LIFETIME,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_CONDITIONS_PROVIDER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_SUBJECT_PROVIDER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_ATTRIBUTE_STATEMENTS_PROVIDER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_AUTHENTICATION_STATEMENTS_PROVIDER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_AUTHZ_DECISION_STATEMENTS_PROVIDER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_ATTRIBUTE_MAPPER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_AUTHN_CONTEXT_MAPPER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(SIGN_ASSERTION,Collections.<String>emptySet());
  emptyAttributeMap.put(ENCRYPT_ATTRIBUTES,Collections.<String>emptySet());
  emptyAttributeMap.put(ENCRYPT_NAME_ID,Collections.<String>emptySet());
  emptyAttributeMap.put(ENCRYPT_ASSERTION,Collections.<String>emptySet());
  emptyAttributeMap.put(ENCRYPTION_ALGORITHM,Collections.<String>emptySet());
  emptyAttributeMap.put(ENCRYPTION_ALGORITHM_STRENGTH,Collections.<String>emptySet());
  emptyAttributeMap.put(KEYSTORE_FILE_NAME,Collections.<String>emptySet());
  emptyAttributeMap.put(KEYSTORE_PASSWORD,Collections.<String>emptySet());
  emptyAttributeMap.put(SP_ENTITY_ID,Collections.<String>emptySet());
  emptyAttributeMap.put(SP_ACS_URL,Collections.<String>emptySet());
  emptyAttributeMap.put(ENCRYPTION_KEY_ALIAS,Collections.<String>emptySet());
  emptyAttributeMap.put(SIGNATURE_KEY_ALIAS,Collections.<String>emptySet());
  emptyAttributeMap.put(SIGNATURE_KEY_PASSWORD,Collections.<String>emptySet());
  return emptyAttributeMap;
}","public static Map<String,Set<String>> getEmptySMSAttributeState(){
  HashMap<String,Set<String>> emptyAttributeMap=new HashMap<>();
  emptyAttributeMap.put(NAME_ID_FORMAT,Collections.<String>emptySet());
  emptyAttributeMap.put(ATTRIBUTE_MAP,Collections.<String>emptySet());
  emptyAttributeMap.put(TOKEN_LIFETIME,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_CONDITIONS_PROVIDER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_SUBJECT_PROVIDER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_ATTRIBUTE_STATEMENTS_PROVIDER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_AUTHENTICATION_STATEMENTS_PROVIDER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_AUTHZ_DECISION_STATEMENTS_PROVIDER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_ATTRIBUTE_MAPPER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(CUSTOM_AUTHN_CONTEXT_MAPPER_CLASS,Collections.<String>emptySet());
  emptyAttributeMap.put(SIGN_ASSERTION,Collections.<String>emptySet());
  emptyAttributeMap.put(ENCRYPT_ATTRIBUTES,Collections.<String>emptySet());
  emptyAttributeMap.put(ENCRYPT_NAME_ID,Collections.<String>emptySet());
  emptyAttributeMap.put(ENCRYPT_ASSERTION,Collections.<String>emptySet());
  emptyAttributeMap.put(ENCRYPTION_ALGORITHM,Collections.<String>emptySet());
  emptyAttributeMap.put(ENCRYPTION_ALGORITHM_STRENGTH,Collections.<String>emptySet());
  emptyAttributeMap.put(KEYSTORE_FILE_NAME,Collections.<String>emptySet());
  emptyAttributeMap.put(KEYSTORE_PASSWORD,Collections.<String>emptySet());
  emptyAttributeMap.put(SP_ENTITY_ID,Collections.<String>emptySet());
  emptyAttributeMap.put(SP_ACS_URL,Collections.<String>emptySet());
  emptyAttributeMap.put(ENCRYPTION_KEY_ALIAS,Collections.<String>emptySet());
  emptyAttributeMap.put(SIGNATURE_KEY_ALIAS,Collections.<String>emptySet());
  emptyAttributeMap.put(SIGNATURE_KEY_PASSWORD,Collections.<String>emptySet());
  emptyAttributeMap.put(ISSUER_NAME,Collections.<String>emptySet());
  return emptyAttributeMap;
}"
9100,"/** 
 * Handles both initial and subsequent RESTful calls from clients submitting Callbacks for the authentication process to continue. This is determined by checking if the POST body is empty or not. If it is empty then this is initiating the authentication process otherwise it is a subsequent call submitting Callbacks. Initiating authentication request using the query parameters from the URL starts the login process and either returns an SSOToken on successful authentication or a number of Callbacks needing to be completed before authentication can proceed or an exception if any problems occurred whilst trying to authenticate. Using the body of the POST request the method continues the login process, submitting the given Callbacks and then either returns an SSOToken on successful authentication or a number of additional Callbacks needing to be completed before authentication can proceed or an exception if any problems occurred whilst trying to authenticate.
 * @param context The request context.
 * @param httpRequest The HTTP request.
 * @return A Json Representation of the response body. The response will contain either a JSON object containing theSSOToken id from a successful authentication, a JSON object containing a number of Callbacks for the client to complete and return or a JSON object containing an exception message.
 * @throws ResourceException If there is an error processing the authentication request.
 */
@Post public Response authenticate(@Contextual Context context,@Contextual Request httpRequest){
  if (!isSupportedMediaType(httpRequest)) {
    if (DEBUG.errorEnabled()) {
      DEBUG.error(""String_Node_Str"" + ContentTypeHeader.valueOf(httpRequest).getType());
    }
    return handleErrorResponse(httpRequest,Status.UNSUPPORTED_MEDIA_TYPE,null);
  }
  final HttpServletRequest request=getHttpServletRequest(context);
  final HttpServletResponse response=getHttpServletResponse(context);
  Form urlQueryString=getUrlQueryString(httpRequest);
  final String sessionUpgradeSSOTokenId=urlQueryString.getFirst(""String_Node_Str"");
  try {
    JsonValue jsonContent;
    try {
      jsonContent=getJsonContent(httpRequest);
    }
 catch (    IOException e) {
      DEBUG.message(""String_Node_Str"",e);
      return handleErrorResponse(httpRequest,Status.BAD_REQUEST,e);
    }
    JsonValue jsonResponse;
    if (jsonContent != null && jsonContent.size() > 0) {
      jsonResponse=restAuthenticationHandler.continueAuthentication(request,response,jsonContent,sessionUpgradeSSOTokenId);
    }
 else {
      final String authIndexType=urlQueryString.getFirst(""String_Node_Str"");
      final String authIndexValue=urlQueryString.getFirst(""String_Node_Str"");
      jsonResponse=restAuthenticationHandler.initiateAuthentication(request,response,authIndexType,authIndexValue,sessionUpgradeSSOTokenId);
    }
    return createResponse(jsonResponse);
  }
 catch (  RestAuthResponseException e) {
    DEBUG.message(""String_Node_Str"",e);
    return handleErrorResponse(httpRequest,Status.valueOf(e.getStatusCode()),e);
  }
catch (  RestAuthException e) {
    DEBUG.message(""String_Node_Str"",e);
    return handleErrorResponse(httpRequest,Status.UNAUTHORIZED,e);
  }
catch (  IOException e) {
    DEBUG.error(""String_Node_Str"",e);
    return handleErrorResponse(httpRequest,Status.INTERNAL_SERVER_ERROR,e);
  }
}","/** 
 * Handles both initial and subsequent RESTful calls from clients submitting Callbacks for the authentication process to continue. This is determined by checking if the POST body is empty or not. If it is empty then this is initiating the authentication process otherwise it is a subsequent call submitting Callbacks. Initiating authentication request using the query parameters from the URL starts the login process and either returns an SSOToken on successful authentication or a number of Callbacks needing to be completed before authentication can proceed or an exception if any problems occurred whilst trying to authenticate. Using the body of the POST request the method continues the login process, submitting the given Callbacks and then either returns an SSOToken on successful authentication or a number of additional Callbacks needing to be completed before authentication can proceed or an exception if any problems occurred whilst trying to authenticate.
 * @param context The request context.
 * @param httpRequest The HTTP request.
 * @return A Json Representation of the response body. The response will contain either a JSON object containing theSSOToken id from a successful authentication, a JSON object containing a number of Callbacks for the client to complete and return or a JSON object containing an exception message.
 * @throws ResourceException If there is an error processing the authentication request.
 */
@Post public Response authenticate(@Contextual Context context,@Contextual Request httpRequest){
  if (!isSupportedMediaType(httpRequest)) {
    if (DEBUG.errorEnabled()) {
      DEBUG.error(""String_Node_Str"" + ContentTypeHeader.valueOf(httpRequest).getType());
    }
    return handleErrorResponse(httpRequest,Status.UNSUPPORTED_MEDIA_TYPE,null);
  }
  final HttpServletRequest request=getHttpServletRequest(context);
  final HttpServletResponse response=getHttpServletResponse(context);
  Form urlQueryString=getUrlQueryString(httpRequest);
  final String sessionUpgradeSSOTokenId=urlQueryString.getFirst(""String_Node_Str"");
  try {
    JsonValue jsonContent;
    try {
      jsonContent=getJsonContent(httpRequest);
    }
 catch (    IOException e) {
      DEBUG.message(""String_Node_Str"",e);
      return handleErrorResponse(httpRequest,Status.BAD_REQUEST,e);
    }
    JsonValue jsonResponse;
    if (jsonContent != null && jsonContent.size() > 0) {
      jsonResponse=restAuthenticationHandler.continueAuthentication(request,response,jsonContent,sessionUpgradeSSOTokenId);
    }
 else {
      final String authIndexType=urlQueryString.getFirst(""String_Node_Str"");
      final String authIndexValue=urlQueryString.getFirst(""String_Node_Str"");
      jsonResponse=restAuthenticationHandler.initiateAuthentication(request,response,authIndexType,authIndexValue,sessionUpgradeSSOTokenId);
    }
    return createResponse(jsonResponse);
  }
 catch (  RestAuthResponseException e) {
    DEBUG.message(""String_Node_Str"",e);
    return handleErrorResponse(httpRequest,Status.valueOf(e.getStatusCode()),e);
  }
catch (  RestAuthException e) {
    DEBUG.message(""String_Node_Str"",e);
    return handleErrorResponse(httpRequest,Status.valueOf(e.getStatusCode()),e);
  }
catch (  IOException e) {
    DEBUG.error(""String_Node_Str"",e);
    return handleErrorResponse(httpRequest,Status.INTERNAL_SERVER_ERROR,e);
  }
}"
9101,"/** 
 * For token transformations with x509 certificates as an input token type, a client's identity can only be asserted via x509 certificates presented via two-way-tls. This certificate can be obtained via the attribute referenced by the javax.servlet.request.X509Certificate key (if the container is deployed with two-way-tls), or from the header referenced by offloadedTlsClientCertKey, in case OpenAM is deployed behind infrastructure which performs tls-offloading. This method will consult header value if configured for this rest-sts instance, and if not configured, the ClientInfoContxt will be consulted, which contains the state corresponding to the javax.servlet.request.X509Certificate attribute. An exception will be thrown if the client cert cannot be obtained.
 * @param context The Context instance corresponding to this invocation
 * @throws org.forgerock.openam.sts.TokenMarshalException if the client's X509 token cannot be obtained from thejavax.servlet.request.X509Certificate attribute, or from the header referenced by the offloadedTlsClientCertKey value.
 * @return a RestTokenTransformValidatorParameters instance with a X509Certificate[] generic type.
 */
private RestTokenTransformValidatorParameters<X509Certificate[]> buildX509CertTokenTransformValidatorParameters(Context context) throws TokenMarshalException {
  X509Certificate[] certificates;
  if (!""String_Node_Str"".equals(offloadedTlsClientCertKey)) {
    String clientIpAddress=ClientUtils.getClientIPAddress(context);
    if (!tlsOffloadEngineHosts.contains(clientIpAddress) && !tlsOffloadEngineHosts.contains(ANY_HOST)) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + offloadedTlsClientCertKey + ""String_Node_Str""+ ""String_Node_Str""+ clientIpAddress+ ""String_Node_Str""+ tlsOffloadEngineHosts);
      throw new TokenMarshalException(ResourceException.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    certificates=pullClientCertFromHeader(context.asContext(HttpContext.class));
  }
 else {
    certificates=pullClientCertFromRequestAttribute(context.asContext(ClientContext.class));
  }
  if (certificates != null) {
    return marshalX509CertIntoTokenValidatorParameters(certificates);
  }
 else {
    if (!""String_Node_Str"".equals(offloadedTlsClientCertKey)) {
      throw new TokenMarshalException(ResourceException.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      throw new TokenMarshalException(ResourceException.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + offloadedTlsClientCertKey + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}","/** 
 * For token transformations with x509 certificates as an input token type, a client's identity can only be asserted via x509 certificates presented via two-way-tls. This certificate can be obtained via the attribute referenced by the javax.servlet.request.X509Certificate key (if the container is deployed with two-way-tls), or from the header referenced by offloadedTlsClientCertKey, in case OpenAM is deployed behind infrastructure which performs tls-offloading. This method will consult header value if configured for this rest-sts instance, and if not configured, the ClientInfoContxt will be consulted, which contains the state corresponding to the javax.servlet.request.X509Certificate attribute. An exception will be thrown if the client cert cannot be obtained.
 * @param context The Context instance corresponding to this invocation
 * @throws org.forgerock.openam.sts.TokenMarshalException if the client's X509 token cannot be obtained from thejavax.servlet.request.X509Certificate attribute, or from the header referenced by the offloadedTlsClientCertKey value.
 * @return a RestTokenTransformValidatorParameters instance with a X509Certificate[] generic type.
 */
private RestTokenTransformValidatorParameters<X509Certificate[]> buildX509CertTokenTransformValidatorParameters(Context context) throws TokenMarshalException {
  X509Certificate[] certificates;
  if (!""String_Node_Str"".equals(offloadedTlsClientCertKey)) {
    String clientIpAddress=ClientUtils.getClientIPAddress(context);
    if (!tlsOffloadEngineHosts.contains(clientIpAddress) && !tlsOffloadEngineHosts.contains(ANY_HOST)) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + offloadedTlsClientCertKey + ""String_Node_Str""+ ""String_Node_Str""+ clientIpAddress+ ""String_Node_Str""+ tlsOffloadEngineHosts);
      throw new TokenMarshalException(ResourceException.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    certificates=pullClientCertFromHeader(context.asContext(HttpContext.class));
  }
 else {
    certificates=pullClientCertFromRequestAttribute(context.asContext(ClientContext.class));
  }
  if (!ArrayUtils.isEmpty(certificates)) {
    return marshalX509CertIntoTokenValidatorParameters(certificates);
  }
 else {
    if (""String_Node_Str"".equals(offloadedTlsClientCertKey)) {
      throw new TokenMarshalException(ResourceException.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      throw new TokenMarshalException(ResourceException.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + offloadedTlsClientCertKey + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}"
9102,"private String getCodeVerifier(String codeChallengeMethod) throws LoginException {
  String codeVerifier=Base64url.encode(RandomStringUtils.randomAlphanumeric(96).getBytes());
  if (SHA_256_DISPLAY_NAME.equals(codeChallengeMethod)) {
    try {
      return Base64url.encode(MessageDigest.getInstance(""String_Node_Str"").digest(codeVerifier.getBytes(StandardCharsets.US_ASCII)));
    }
 catch (    NoSuchAlgorithmException e) {
      throw new LoginException(""String_Node_Str"");
    }
  }
 else {
    return codeVerifier;
  }
}","private String getCodeVerifier(String codeChallengeMethod) throws LoginException {
  String codeVerifier=Base64url.encode(RandomStringUtils.randomAlphanumeric(96).getBytes());
  if (OAuth2Constants.Custom.CODE_CHALLENGE_METHOD_S_256.equals(codeChallengeMethod)) {
    try {
      return Base64url.encode(MessageDigest.getInstance(""String_Node_Str"").digest(codeVerifier.getBytes(StandardCharsets.US_ASCII)));
    }
 catch (    NoSuchAlgorithmException e) {
      throw new LoginException(""String_Node_Str"");
    }
  }
 else {
    return codeVerifier;
  }
}"
9103,"@Override protected String getContextIdForAccessAttempt(Request request){
  try {
    String jsonString=request.getEntity().getString();
    if (isNotEmpty(jsonString)) {
      JsonValue jsonValue=toJsonValue(jsonString);
      if (jsonValue.isDefined(AUTH_ID)) {
        populateContextFromAuthId(jsonValue.get(AUTH_ID).asString());
      }
    }
    return super.getContextIdForAccessAttempt(request);
  }
 catch (  IOException e) {
    return ""String_Node_Str"";
  }
}","protected String getContextIdForAccessAttempt(Request request){
  try {
    String jsonString=request.getEntity().getString();
    if (isNotEmpty(jsonString)) {
      JsonValue jsonValue=toJsonValue(jsonString);
      if (jsonValue.isDefined(AUTH_ID)) {
        populateContextFromAuthId(jsonValue.get(AUTH_ID).asString());
      }
    }
  }
 catch (  IOException e) {
    return ""String_Node_Str"";
  }
  return null;
}"
9104,"@Override protected String getContextIdForAccessOutcome(Response response){
  String contextId=super.getContextIdForAccessOutcome(response);
  if (isNotEmpty(contextId)) {
    return contextId;
  }
  String tokenId=AuditRequestContext.getProperty(TOKEN_ID);
  String sessionId=AuditRequestContext.getProperty(SESSION_ID);
  String authId=AuditRequestContext.getProperty(AUTH_ID);
  if (isNotEmpty(tokenId)) {
    populateContextFromTokenId(tokenId);
  }
 else   if (isNotEmpty(sessionId)) {
    AuditRequestContext.putProperty(CONTEXT_ID,getContextIdFromSessionId(sessionId));
  }
 else   if (isNotEmpty(authId)) {
    populateContextFromAuthId(authId);
  }
  return super.getContextIdForAccessOutcome(response);
}","protected String getContextIdForAccessOutcome(Response response){
  String tokenId=AuditRequestContext.getProperty(TOKEN_ID);
  String sessionId=AuditRequestContext.getProperty(SESSION_ID);
  String authId=AuditRequestContext.getProperty(AUTH_ID);
  if (isNotEmpty(tokenId)) {
    populateContextFromTokenId(tokenId);
  }
 else   if (isNotEmpty(sessionId)) {
  }
 else   if (isNotEmpty(authId)) {
    populateContextFromAuthId(authId);
  }
  return null;
}"
9105,"private void populateContextFromAuthId(String authId){
  try {
    String sessionId=authIdHelper.reconstructAuthId(authId).getClaimsSet().getClaim(SESSION_ID,String.class);
    if (isEmpty(sessionId)) {
      return;
    }
    String contextId=getContextIdFromSessionId(sessionId);
    if (isNotEmpty(contextId)) {
      AuditRequestContext.putProperty(CONTEXT_ID,contextId);
    }
  }
 catch (  RestAuthException e) {
    debug.warning(""String_Node_Str"");
  }
}","private void populateContextFromAuthId(String authId){
  try {
    String sessionId=authIdHelper.reconstructAuthId(authId).getClaimsSet().getClaim(SESSION_ID,String.class);
    if (isEmpty(sessionId)) {
      return;
    }
    String contextId=getContextIdFromSessionId(sessionId);
    if (isNotEmpty(contextId)) {
    }
  }
 catch (  RestAuthException e) {
    debug.warning(""String_Node_Str"");
  }
}"
9106,"private void populateContextFromTokenId(String tokenId){
  try {
    SSOToken token=SSOTokenManager.getInstance().createSSOToken(tokenId);
    AuditRequestContext.putProperty(USER_ID,getUserId(token));
    AuditRequestContext.putProperty(CONTEXT_ID,getContextIdFromSSOToken(token));
  }
 catch (  SSOException e) {
    debug.warning(""String_Node_Str"");
  }
}","private void populateContextFromTokenId(String tokenId){
  try {
    SSOToken token=SSOTokenManager.getInstance().createSSOToken(tokenId);
    AuditRequestContext.putProperty(USER_ID,getUserId(token));
  }
 catch (  SSOException e) {
    debug.warning(""String_Node_Str"");
  }
}"
9107,"private void auditAccessSuccess(Request request,Response response){
  if (auditEventPublisher.isAuditing(ACCESS_TOPIC)) {
    long endTime=System.currentTimeMillis();
    AMAccessAuditEventBuilder builder=auditEventFactory.accessEvent().timestamp(endTime).transactionId(AuditRequestContext.getTransactionIdValue()).eventName(EventName.AM_ACCESS_OUTCOME).component(component).authentication(getUserIdForAccessOutcome(response)).contextId(getContextIdForAccessOutcome(response)).response(""String_Node_Str"",endTime - request.getDate().getTime());
    addHttpData(request,builder);
    auditEventPublisher.tryPublish(ACCESS_TOPIC,builder.toEvent());
  }
}","private void auditAccessSuccess(Request request,Response response){
}"
9108,"private void addHttpData(Request request,AMAccessAuditEventBuilder builder){
  HttpServletRequest servletRequest=getRequest(request);
  if (servletRequest != null) {
    builder.forHttpServletRequest(servletRequest);
  }
}","private void addHttpData(Request request,AMAccessAuditEventBuilder builder){
}"
9109,"/** 
 * Retrieve the context ID for an access attempt.
 * @param request the restlet request
 * @return the context ID
 */
protected String getContextIdForAccessAttempt(Request request){
  return AuditRequestContext.getProperty(CONTEXT_ID);
}","/** 
 * Retrieve the context ID for an access attempt.
 * @param request the restlet request
 * @return the context ID
 */
protected String getContextIdForAccessAttempt(Request request){
  return null;
}"
9110,"/** 
 * Retrieve the user ID for an access outcome.
 * @param response the restlet response
 * @return the user ID
 */
protected String getUserIdForAccessOutcome(Response response){
  String userId=AuditRequestContext.getProperty(USER_ID);
  return userId == null ? ""String_Node_Str"" : userId;
}","/** 
 * Retrieve the user ID for an access outcome.
 * @param response the restlet response
 * @return the user ID
 */
protected String getUserIdForAccessOutcome(Response response){
  return null;
}"
9111,"@Override protected void afterHandle(Request request,Response response){
  super.afterHandle(request,response);
  if (response.getStatus().isError()) {
    auditAccessFailure(request,response);
  }
 else {
    auditAccessSuccess(request,response);
  }
}","@Override protected void afterHandle(Request request,Response response){
}"
9112,"/** 
 * Retrieve the Context ID for an access outcome.
 * @param response the restlet response
 * @return the context ID
 */
protected String getContextIdForAccessOutcome(Response response){
  return AuditRequestContext.getProperty(CONTEXT_ID);
}","/** 
 * Retrieve the Context ID for an access outcome.
 * @param response the restlet response
 * @return the context ID
 */
protected String getContextIdForAccessOutcome(Response response){
  return null;
}"
9113,"private void auditAccessFailure(Request request,Response response){
  if (auditEventPublisher.isAuditing(ACCESS_TOPIC)) {
    long endTime=System.currentTimeMillis();
    AMAccessAuditEventBuilder builder=auditEventFactory.accessEvent().timestamp(endTime).transactionId(AuditRequestContext.getTransactionIdValue()).eventName(EventName.AM_ACCESS_OUTCOME).component(component).authentication(getUserIdForAccessOutcome(response)).contextId(getContextIdForAccessOutcome(response)).responseWithMessage(""String_Node_Str"" + response.getStatus().getCode(),endTime - request.getDate().getTime(),response.getStatus().getDescription());
    addHttpData(request,builder);
    auditEventPublisher.tryPublish(ACCESS_TOPIC,builder.toEvent());
  }
}","private void auditAccessFailure(Request request,Response response){
}"
9114,"/** 
 * Retrieve the user ID for an access attempt.
 * @param request the restlet request
 * @return the user ID
 */
protected String getUserIdForAccessAttempt(Request request){
  String userId=AuditRequestContext.getProperty(USER_ID);
  return userId == null ? ""String_Node_Str"" : userId;
}","/** 
 * Retrieve the user ID for an access attempt.
 * @param request the restlet request
 * @return the user ID
 */
protected String getUserIdForAccessAttempt(Request request){
  return null;
}"
9115,"@Override protected int beforeHandle(Request request,Response response){
  try {
    Representation representation=request.getEntity();
    if (representation.isTransient()) {
      request.setEntity(new BufferingRepresentation(request.getEntity()));
    }
    auditAccessAttempt(request);
  }
 catch (  AuditException e) {
    response.setStatus(Status.SERVER_ERROR_INTERNAL,e);
    return STOP;
  }
  return CONTINUE;
}","@Override protected int beforeHandle(Request request,Response response){
  return 0;
}"
9116,"private void auditAccessAttempt(Request request) throws AuditException {
  if (auditEventPublisher.isAuditing(ACCESS_TOPIC)) {
    AMAccessAuditEventBuilder builder=auditEventFactory.accessEvent().timestamp(request.getDate().getTime()).transactionId(AuditRequestContext.getTransactionIdValue()).eventName(EventName.AM_ACCESS_ATTEMPT).component(component).authentication(getUserIdForAccessAttempt(request)).contextId(getContextIdForAccessAttempt(request));
    addHttpData(request,builder);
    auditEventPublisher.publish(ACCESS_TOPIC,builder.toEvent());
  }
}","private void auditAccessAttempt(Request request) throws AuditException {
}"
9117,"/** 
 * {@inheritDoc}
 */
@Override protected String getContextIdForAccessAttempt(Request request){
  String contextId=super.getContextIdForAccessAttempt(request);
  if (contextId != null) {
    return contextId;
  }
  AccessToken accessToken=retrieveAccessToken(request);
  contextId=generateContextID(accessToken);
  AuditRequestContext.putProperty(CONTEXT_ID,contextId);
  return contextId;
}","/** 
 * {@inheritDoc}
 */
@Override protected String getContextIdForAccessAttempt(Request request){
  return null;
}"
9118,"@Test public void shouldHandleAuditException() throws AuditException {
  Request request=mock(Request.class);
  Response response=new Response(request);
  Representation representation=mock(Representation.class);
  when(request.getEntity()).thenReturn(representation);
  when(request.getDate()).thenReturn(new Date());
  when(representation.isTransient()).thenReturn(false);
  AuditRequestContext.putProperty(USER_ID,""String_Node_Str"");
  AuditRequestContext.putProperty(CONTEXT_ID,""String_Node_Str"");
  when(eventPublisher.isAuditing(anyString())).thenReturn(true);
  when(eventPublisher.isSuppressExceptions()).thenReturn(false);
  doThrow(AuditException.class).when(eventPublisher).publish(anyString(),any(AuditEvent.class));
  auditFilter.handle(request,response);
  verify(restlet,never()).handle(any(Request.class),any(Response.class));
  assertThat(response.getStatus()).isEqualTo(Status.SERVER_ERROR_INTERNAL);
}","@Test public void shouldHandleAuditException() throws AuditException {
  Request request=mock(Request.class);
  Response response=new Response(request);
  Representation representation=mock(Representation.class);
  when(request.getEntity()).thenReturn(representation);
  when(request.getDate()).thenReturn(new Date());
  when(representation.isTransient()).thenReturn(false);
  AuditRequestContext.putProperty(USER_ID,""String_Node_Str"");
  when(eventPublisher.isAuditing(anyString())).thenReturn(true);
  when(eventPublisher.isSuppressExceptions()).thenReturn(false);
  doThrow(AuditException.class).when(eventPublisher).publish(anyString(),any(AuditEvent.class));
  auditFilter.handle(request,response);
  verify(restlet,never()).handle(any(Request.class),any(Response.class));
  assertThat(response.getStatus()).isEqualTo(Status.SERVER_ERROR_INTERNAL);
}"
9119,"public void auditActivity(InternalSession session,EventName eventName){
  if (auditEventPublisher.isAuditing(ACTIVITY_TOPIC)) {
    String contextId=session.getProperty(Constants.AM_CTX_ID);
    AuditEvent auditEvent=auditEventFactory.activityEvent().transactionId(AuditRequestContext.getTransactionIdValue()).eventName(eventName).component(Component.SESSION).authentication(session.getProperty(Constants.UNIVERSAL_IDENTIFIER)).contextId(Context.SESSION,contextId).runAs(getUserId(getAdminToken())).resourceOperation(contextId,""String_Node_Str"",getCrudType(eventName)).toEvent();
    auditEventPublisher.tryPublish(ACTIVITY_TOPIC,auditEvent);
  }
}","public void auditActivity(InternalSession session,EventName eventName){
  if (auditEventPublisher.isAuditing(ACTIVITY_TOPIC)) {
    String contextId=session.getProperty(Constants.AM_CTX_ID);
    AuditEvent auditEvent=auditEventFactory.activityEvent().transactionId(AuditRequestContext.getTransactionIdValue()).eventName(eventName).component(Component.SESSION).authentication(session.getProperty(Constants.UNIVERSAL_IDENTIFIER)).context(Context.SESSION,contextId).runAs(getUserId(getAdminToken())).resourceOperation(contextId,""String_Node_Str"",getCrudType(eventName)).toEvent();
    auditEventPublisher.tryPublish(ACTIVITY_TOPIC,auditEvent);
  }
}"
9120,"/** 
 * @return
 */
public static Map<String,String> getAllAvailableContexts(){
  Map<String,String> map=new HashMap<>();
  for (  AuditConstants.Context context : AuditConstants.Context.values()) {
    String contextKey=context.toString();
    String contextValue=AuditRequestContext.getProperty(contextKey);
    if (StringUtils.isNotEmpty(contextValue)) {
      map.put(contextKey,contextValue);
    }
  }
  return map;
}","/** 
 * Get all available   {@link AuditConstants.Context} values from the possible list of{@link AuditConstants.Context} values, from the {@link AuditRequestContext}.
 * @return All the available {@link AuditConstants.Context} values.
 */
public static Map<String,String> getAllAvailableContexts(){
  Map<String,String> map=new HashMap<>();
  for (  AuditConstants.Context context : AuditConstants.Context.values()) {
    String contextKey=context.toString();
    String contextValue=AuditRequestContext.getProperty(contextKey);
    if (StringUtils.isNotEmpty(contextValue)) {
      map.put(contextKey,contextValue);
    }
  }
  return map;
}"
9121,"@Override public void addRoutes(RestRouter rootRouter,RestRouter realmRouter){
  realmRouter.route(""String_Node_Str"").auditAs(DASHBOARD).toCollection(DashboardResource.class);
  realmRouter.route(""String_Node_Str"").authenticateWith(ssoToken().exceptRead()).auditAs(SERVER_INFO).forVersion(1,1).toCollection(ServerInfoResource.class);
  realmRouter.route(""String_Node_Str"").authenticateWith(ssoToken().exceptActions(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).auditAs(USERS).forVersion(1,2).toCollection(Key.get(IdentityResourceV1.class,Names.named(""String_Node_Str""))).forVersion(2,1).toCollection(Key.get(IdentityResourceV2.class,Names.named(""String_Node_Str"")));
  realmRouter.route(""String_Node_Str"").auditAs(GROUPS).forVersion(1,2).toCollection(Key.get(IdentityResourceV1.class,Names.named(""String_Node_Str""))).forVersion(2,1).toCollection(Key.get(IdentityResourceV2.class,Names.named(""String_Node_Str"")));
  realmRouter.route(""String_Node_Str"").auditAs(POLICY_AGENT).authorizeWith(ResourceOwnerOrSuperUserAuthzModule.class).forVersion(1,2).toCollection(Key.get(IdentityResourceV1.class,Names.named(""String_Node_Str""))).forVersion(2,1).toCollection(Key.get(IdentityResourceV2.class,Names.named(""String_Node_Str"")));
  realmRouter.route(""String_Node_Str"").auditAs(DEVICES).toCollection(TrustedDevicesResource.class);
  realmRouter.route(""String_Node_Str"").auditAs(DEVICES).authorizeWith(ResourceOwnerOrSuperUserAuthzModule.class).toCollection(OathDevicesResource.class);
  realmRouter.route(""String_Node_Str"").auditAs(BATCH).authorizeWith(AdminOnlyAuthzModule.class).toCollection(BatchResource.class);
  realmRouter.route(""String_Node_Str"").authenticateWith(ssoToken().exceptActions(""String_Node_Str"")).auditAs(SESSION).authorizeWith(SessionResourceAuthzModule.class).forVersion(1,1).toCollection(SessionResource.class);
  rootRouter.route(""String_Node_Str"").auditAs(CTS).authorizeWith(CoreTokenResourceAuthzModule.class).toCollection(CoreTokenResource.class);
  rootRouter.route(RecordConstants.RECORD_REST_ENDPOINT).auditAs(RECORD).authorizeWith(AdminOnlyAuthzModule.class).toCollection(RecordResource.class);
}","@Override public void addRoutes(RestRouter rootRouter,RestRouter realmRouter){
  realmRouter.route(""String_Node_Str"").auditAs(DASHBOARD).toCollection(DashboardResource.class);
  realmRouter.route(""String_Node_Str"").authenticateWith(ssoToken().exceptRead()).auditAs(SERVER_INFO).forVersion(1,1).toCollection(ServerInfoResource.class);
  realmRouter.route(""String_Node_Str"").authenticateWith(ssoToken().exceptActions(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).auditAs(USERS).forVersion(1,2).toCollection(Key.get(IdentityResourceV1.class,Names.named(""String_Node_Str""))).forVersion(2,1).toCollection(Key.get(IdentityResourceV2.class,Names.named(""String_Node_Str"")));
  realmRouter.route(""String_Node_Str"").auditAs(GROUPS).forVersion(1,2).toCollection(Key.get(IdentityResourceV1.class,Names.named(""String_Node_Str""))).forVersion(2,1).toCollection(Key.get(IdentityResourceV2.class,Names.named(""String_Node_Str"")));
  realmRouter.route(""String_Node_Str"").auditAs(POLICY_AGENT).forVersion(1,2).toCollection(Key.get(IdentityResourceV1.class,Names.named(""String_Node_Str""))).forVersion(2,1).toCollection(Key.get(IdentityResourceV2.class,Names.named(""String_Node_Str"")));
  realmRouter.route(""String_Node_Str"").auditAs(DEVICES).toCollection(TrustedDevicesResource.class);
  realmRouter.route(""String_Node_Str"").auditAs(DEVICES).authorizeWith(ResourceOwnerOrSuperUserAuthzModule.class).toCollection(OathDevicesResource.class);
  realmRouter.route(""String_Node_Str"").auditAs(BATCH).authorizeWith(AdminOnlyAuthzModule.class).toCollection(BatchResource.class);
  realmRouter.route(""String_Node_Str"").authenticateWith(ssoToken().exceptActions(""String_Node_Str"")).auditAs(SESSION).authorizeWith(SessionResourceAuthzModule.class).forVersion(1,1).toCollection(SessionResource.class);
  rootRouter.route(""String_Node_Str"").auditAs(CTS).authorizeWith(CoreTokenResourceAuthzModule.class).toCollection(CoreTokenResource.class);
  rootRouter.route(RecordConstants.RECORD_REST_ENDPOINT).auditAs(RECORD).authorizeWith(AdminOnlyAuthzModule.class).toCollection(RecordResource.class);
}"
9122,"/** 
 * Gets the instance of the OAuth2ProviderSettings.
 * @param realm The realm.
 * @param req The request that can be used to obtain the base deployment url.
 * @return The OAuth2ProviderSettings instance.
 */
OAuth2ProviderSettings get(String realm,HttpServletRequest req) throws NotFoundException ;","/** 
 * Gets the instance of the OAuth2ProviderSettings.
 * @param realm The realm.
 * @param context The context that can be used to obtain the base deployment url.
 * @return The OAuth2ProviderSettings instance.
 */
OAuth2ProviderSettings get(String realm,Context context) throws NotFoundException ;"
9123,"/** 
 * Cache each provider settings on the realm it was created for.  {@inheritDoc}
 */
public OAuth2ProviderSettings get(String realm,HttpServletRequest req) throws NotFoundException {
  String baseDeploymentUri=baseURLProviderFactory.get(realm).getURL(req);
synchronized (providerSettingsMap) {
    OAuth2ProviderSettings providerSettings=providerSettingsMap.get(realm);
    if (providerSettings == null) {
      ResourceSetStore resourceSetStore=resourceSetStoreFactory.create(realm);
      providerSettings=new OpenAMOAuth2ProviderSettings(realm,baseDeploymentUri,resourceSetStore,cookieExtractor);
      if (providerSettings.exists()) {
        providerSettingsMap.put(realm,providerSettings);
      }
 else {
        throw new NotFoundException(""String_Node_Str"" + realm);
      }
    }
    return providerSettings;
  }
}","@Override public OAuth2ProviderSettings get(String realm,Context context) throws NotFoundException {
  Reject.ifNull(realm,""String_Node_Str"");
  Reject.ifNull(context,""String_Node_Str"");
  String baseDeploymentUri=baseURLProviderFactory.get(realm).getURL(context.asContext(HttpContext.class));
  return getProviderSettings(realm,baseDeploymentUri);
}"
9124,"@Override public void addRoutes(RestRouter rootRouter,RestRouter realmRouter){
  realmRouter.route(""String_Node_Str"").auditAs(OAUTH2).authorizeWith(ResourceOwnerOrSuperUserAuthzModule.class).through(UmaEnabledFilter.class).toCollection(ResourceSetResource.class);
  realmRouter.route(""String_Node_Str"").auditAs(OAUTH2).authorizeWith(ResourceOwnerOrSuperUserAuthzModule.class).toCollection(UmaLabelResource.class);
}","@Override public void addRoutes(RestRouter rootRouter,RestRouter realmRouter){
  realmRouter.route(""String_Node_Str"").auditAs(OAUTH2).authorizeWith(ResourceOwnerOrSuperUserAuthzModule.class).through(UmaEnabledFilter.class).toCollection(ResourceSetResource.class);
  realmRouter.route(""String_Node_Str"").auditAs(OAUTH2).authorizeWith(ResourceOwnerOrSuperUserAuthzModule.class).through(UmaEnabledFilter.class).toCollection(UmaLabelResource.class);
}"
9125,"public void setResourceSetQuery(org.forgerock.util.query.QueryFilter<String> query){
  setFirstQuery(query);
}","/** 
 * Set the resource set query.
 * @param query The query.
 */
public void setResourceSetQuery(org.forgerock.util.query.QueryFilter<String> query){
  setFirstQuery(query);
}"
9126,"public QueryFilter getPolicyQuery(){
  return getSecondQuery();
}","/** 
 * Get the policy query.
 * @return The query.
 */
public QueryFilter<JsonPointer> getPolicyQuery(){
  return getSecondQuery();
}"
9127,"public org.forgerock.util.query.QueryFilter<String> getResourceSetQuery(){
  return getFirstQuery();
}","/** 
 * Get the resource set query.
 * @return The query.
 */
public org.forgerock.util.query.QueryFilter<String> getResourceSetQuery(){
  return getFirstQuery();
}"
9128,"public void setPolicyQuery(QueryFilter query){
  setSecondQuery(query);
}","/** 
 * Set the policy query.
 * @param query The query.
 */
public void setPolicyQuery(QueryFilter<JsonPointer> query){
  setSecondQuery(query);
}"
9129,"private Promise<Void,ResourceException> enabled(Context serverContext){
  try {
    final String realm=ServerContextUtils.getRealm(serverContext);
    UmaProviderSettings settings=umaProviderSettingsFactory.get(RequestHolder.get(),realm);
    if (settings.isEnabled()) {
      return newResultPromise(null);
    }
  }
 catch (  NotFoundException ignore) {
  }
  return newExceptionPromise(newNotSupportedException(""String_Node_Str""));
}","private Promise<Void,ResourceException> enabled(Context serverContext){
  try {
    final String realm=ServerContextUtils.getRealm(serverContext);
    UmaProviderSettings settings=umaProviderSettingsFactory.get(serverContext,realm);
    if (settings.isEnabled()) {
      return newResultPromise(null);
    }
  }
 catch (  NotFoundException ignore) {
  }
  return newExceptionPromise(newNotSupportedException(""String_Node_Str""));
}"
9130,"@Test public void nameQueryShouldBeSupported() throws Exception {
  Context context=mock(Context.class);
  QueryRequest request=mock(QueryRequest.class);
  given(request.getFields()).willReturn(Arrays.asList(new JsonPointer(""String_Node_Str"")));
  QueryResourceHandler handler=mock(QueryResourceHandler.class);
  ResourceSetDescription resourceSet=mock(ResourceSetDescription.class);
  QueryFilter<JsonPointer> queryFilter=QueryFilter.and(QueryFilter.equalTo(new JsonPointer(""String_Node_Str""),""String_Node_Str""),QueryFilter.equalTo(new JsonPointer(""String_Node_Str""),""String_Node_Str""),QueryFilter.equalTo(new JsonPointer(""String_Node_Str""),""String_Node_Str""));
  Promise<Collection<ResourceSetDescription>,ResourceException> resourceSetsPromise=Promises.newResultPromise((Collection<ResourceSetDescription>)asSet(resourceSet));
  given(contextHelper.getRealm(context)).willReturn(""String_Node_Str"");
  given(contextHelper.getUserId(context)).willReturn(""String_Node_Str"");
  given(request.getQueryFilter()).willReturn(queryFilter);
  given(resourceSetService.getResourceSets(eq(context),eq(""String_Node_Str""),Matchers.<ResourceSetWithPolicyQuery>anyObject(),eq(""String_Node_Str""),eq(false))).willReturn(resourceSetsPromise);
  Promise<QueryResponse,ResourceException> promise=resource.queryCollection(context,request,handler);
  ArgumentCaptor<ResourceSetWithPolicyQuery> queryCaptor=ArgumentCaptor.forClass(ResourceSetWithPolicyQuery.class);
  verify(resourceSetService).getResourceSets(eq(context),eq(""String_Node_Str""),queryCaptor.capture(),eq(""String_Node_Str""),eq(false));
  assertThat(queryCaptor.getValue().getOperator()).isEqualTo(AggregateQuery.Operator.AND);
  assertThat(queryCaptor.getValue().getPolicyQuery()).isEqualTo(QueryFilter.equalTo(""String_Node_Str"",""String_Node_Str""));
  assertThat(queryCaptor.getValue().getResourceSetQuery()).isEqualTo(QueryFilter.and(QueryFilter.equalTo(""String_Node_Str"",""String_Node_Str""),QueryFilter.equalTo(""String_Node_Str"",""String_Node_Str"")));
  assertThat(promise).succeeded().withObject().isNotNull();
}","@Test public void nameQueryShouldBeSupported() throws Exception {
  Context context=mock(Context.class);
  QueryRequest request=mock(QueryRequest.class);
  given(request.getFields()).willReturn(Arrays.asList(new JsonPointer(""String_Node_Str"")));
  QueryResourceHandler handler=mock(QueryResourceHandler.class);
  ResourceSetDescription resourceSet=mock(ResourceSetDescription.class);
  QueryFilter<JsonPointer> queryFilter=QueryFilter.and(QueryFilter.equalTo(new JsonPointer(""String_Node_Str""),""String_Node_Str""),QueryFilter.equalTo(new JsonPointer(""String_Node_Str""),""String_Node_Str""),QueryFilter.equalTo(new JsonPointer(""String_Node_Str""),""String_Node_Str""));
  Promise<Collection<ResourceSetDescription>,ResourceException> resourceSetsPromise=Promises.newResultPromise((Collection<ResourceSetDescription>)asSet(resourceSet));
  given(contextHelper.getRealm(context)).willReturn(""String_Node_Str"");
  given(contextHelper.getUserId(context)).willReturn(""String_Node_Str"");
  given(request.getQueryFilter()).willReturn(queryFilter);
  given(resourceSetService.getResourceSets(eq(context),eq(""String_Node_Str""),Matchers.<ResourceSetWithPolicyQuery>anyObject(),eq(""String_Node_Str""),eq(false))).willReturn(resourceSetsPromise);
  Promise<QueryResponse,ResourceException> promise=resource.queryCollection(context,request,handler);
  ArgumentCaptor<ResourceSetWithPolicyQuery> queryCaptor=ArgumentCaptor.forClass(ResourceSetWithPolicyQuery.class);
  verify(resourceSetService).getResourceSets(eq(context),eq(""String_Node_Str""),queryCaptor.capture(),eq(""String_Node_Str""),eq(false));
  assertThat(queryCaptor.getValue().getOperator()).isEqualTo(AggregateQuery.Operator.AND);
  assertThat(queryCaptor.getValue().getPolicyQuery()).isEqualTo(QueryFilter.equalTo(new JsonPointer(""String_Node_Str""),""String_Node_Str""));
  assertThat(queryCaptor.getValue().getResourceSetQuery()).isEqualTo(QueryFilter.and(QueryFilter.equalTo(""String_Node_Str"",""String_Node_Str""),QueryFilter.equalTo(""String_Node_Str"",""String_Node_Str"")));
  assertThat(promise).succeeded().withObject().isNotNull();
}"
9131,"@Test public void getResourceSetsShouldReturnEmptySetWhenNoResourceSetsExist() throws Exception {
  String realm=""String_Node_Str"";
  Context context=mockContext(realm);
  ResourceSetWithPolicyQuery query=new ResourceSetWithPolicyQuery();
  String resourceOwnerId=""String_Node_Str"";
  boolean augmentWithPolicies=false;
  QueryFilter<String> resourceSetQuery=mock(QueryFilter.class);
  QueryFilter policyQuery=QueryFilter.alwaysFalse();
  Set<ResourceSetDescription> queriedResourceSets=new HashSet<>();
  Collection<UmaPolicy> queriedPolicies=new HashSet<>();
  Pair<QueryResponse,Collection<UmaPolicy>> queriedPoliciesPair=Pair.of(newQueryResponse(),queriedPolicies);
  Promise<Pair<QueryResponse,Collection<UmaPolicy>>,ResourceException> queriedPoliciesPromise=Promises.newResultPromise(queriedPoliciesPair);
  query.setResourceSetQuery(resourceSetQuery);
  query.setPolicyQuery(policyQuery);
  given(resourceSetStore.query(any(QueryFilter.class))).willReturn(queriedResourceSets);
  given(policyService.queryPolicies(eq(context),Matchers.<QueryRequest>anyObject())).willReturn(queriedPoliciesPromise);
  mockResourceOwnerIdentity(resourceOwnerId,realm);
  mockPolicyEvaluator(""String_Node_Str"");
  mockFilteredResourceSetsQueryVisitor(resourceSetQuery,queriedResourceSets);
  Collection<ResourceSetDescription> resourceSets=service.getResourceSets(context,realm,query,resourceOwnerId,augmentWithPolicies).getOrThrowUninterruptibly();
  assertThat(resourceSets).isEmpty();
}","@Test public void getResourceSetsShouldReturnEmptySetWhenNoResourceSetsExist() throws Exception {
  String realm=""String_Node_Str"";
  Context context=mockContext(realm);
  ResourceSetWithPolicyQuery query=new ResourceSetWithPolicyQuery();
  String resourceOwnerId=""String_Node_Str"";
  boolean augmentWithPolicies=false;
  QueryFilter<String> resourceSetQuery=mock(QueryFilter.class);
  QueryFilter<JsonPointer> policyQuery=QueryFilter.alwaysFalse();
  Set<ResourceSetDescription> queriedResourceSets=new HashSet<>();
  Collection<UmaPolicy> queriedPolicies=new HashSet<>();
  Pair<QueryResponse,Collection<UmaPolicy>> queriedPoliciesPair=Pair.of(newQueryResponse(),queriedPolicies);
  Promise<Pair<QueryResponse,Collection<UmaPolicy>>,ResourceException> queriedPoliciesPromise=Promises.newResultPromise(queriedPoliciesPair);
  query.setResourceSetQuery(resourceSetQuery);
  query.setPolicyQuery(policyQuery);
  given(resourceSetStore.query(any(QueryFilter.class))).willReturn(queriedResourceSets);
  given(policyService.queryPolicies(eq(context),Matchers.<QueryRequest>anyObject())).willReturn(queriedPoliciesPromise);
  mockResourceOwnerIdentity(resourceOwnerId,realm);
  mockPolicyEvaluator(""String_Node_Str"");
  mockFilteredResourceSetsQueryVisitor(resourceSetQuery,queriedResourceSets);
  Collection<ResourceSetDescription> resourceSets=service.getResourceSets(context,realm,query,resourceOwnerId,augmentWithPolicies).getOrThrowUninterruptibly();
  assertThat(resourceSets).isEmpty();
}"
9132,"@BeforeClass public static void setupFactories() throws Exception {
  notYetConfiguredFactory=mock(UmaProviderSettingsFactory.class);
  given(notYetConfiguredFactory.get(any(HttpServletRequest.class),anyString())).willThrow(NotFoundException.class);
  UmaProviderSettings notEnabled=mock(UmaProviderSettings.class);
  given(notEnabled.isEnabled()).willReturn(false);
  notEnabledFactory=mock(UmaProviderSettingsFactory.class);
  given(notEnabledFactory.get(any(HttpServletRequest.class),anyString())).willReturn(notEnabled);
  UmaProviderSettings enabled=mock(UmaProviderSettings.class);
  given(enabled.isEnabled()).willReturn(true);
  enabledFactory=mock(UmaProviderSettingsFactory.class);
  given(enabledFactory.get(any(HttpServletRequest.class),anyString())).willReturn(enabled);
}","@BeforeClass public static void setupFactories() throws Exception {
  notYetConfiguredFactory=mock(UmaProviderSettingsFactory.class);
  given(notYetConfiguredFactory.get(any(Context.class),anyString())).willThrow(NotFoundException.class);
  UmaProviderSettings notEnabled=mock(UmaProviderSettings.class);
  given(notEnabled.isEnabled()).willReturn(false);
  notEnabledFactory=mock(UmaProviderSettingsFactory.class);
  given(notEnabledFactory.get(any(Context.class),anyString())).willReturn(notEnabled);
  UmaProviderSettings enabled=mock(UmaProviderSettings.class);
  given(enabled.isEnabled()).willReturn(true);
  enabledFactory=mock(UmaProviderSettingsFactory.class);
  given(enabledFactory.get(any(Context.class),anyString())).willReturn(enabled);
}"
9133,"@BeforeMethod public void setup() throws Exception {
  MockitoAnnotations.initMocks(this);
  context=new InternalContext(new RealmContext(new RootContext()));
  requestHandler=mock(RequestHandler.class);
  when(requestHandler.handleAction(any(Context.class),any(ActionRequest.class))).thenReturn(promise(newActionResponse(null)));
  when(requestHandler.handleCreate(any(Context.class),any(CreateRequest.class))).thenReturn(promise(newResourceResponse(null,null,null)));
  when(requestHandler.handleDelete(any(Context.class),any(DeleteRequest.class))).thenReturn(promise(newResourceResponse(null,null,null)));
  when(requestHandler.handlePatch(any(Context.class),any(PatchRequest.class))).thenReturn(promise(newResourceResponse(null,null,null)));
  when(requestHandler.handleQuery(any(Context.class),any(QueryRequest.class),any(QueryResourceHandler.class))).thenReturn(promise(newQueryResponse()));
  when(requestHandler.handleRead(any(Context.class),any(ReadRequest.class))).thenReturn(promise(newResourceResponse(null,null,null)));
  when(requestHandler.handleUpdate(any(Context.class),any(UpdateRequest.class))).thenReturn(promise(newResourceResponse(null,null,null)));
  RequestHolder.set(mock(HttpServletRequest.class));
}","@BeforeMethod public void setup() throws Exception {
  MockitoAnnotations.initMocks(this);
  context=new InternalContext(new RealmContext(new RootContext()));
  requestHandler=mock(RequestHandler.class);
  when(requestHandler.handleAction(any(Context.class),any(ActionRequest.class))).thenReturn(promise(newActionResponse(null)));
  when(requestHandler.handleCreate(any(Context.class),any(CreateRequest.class))).thenReturn(promise(newResourceResponse(null,null,null)));
  when(requestHandler.handleDelete(any(Context.class),any(DeleteRequest.class))).thenReturn(promise(newResourceResponse(null,null,null)));
  when(requestHandler.handlePatch(any(Context.class),any(PatchRequest.class))).thenReturn(promise(newResourceResponse(null,null,null)));
  when(requestHandler.handleQuery(any(Context.class),any(QueryRequest.class),any(QueryResourceHandler.class))).thenReturn(promise(newQueryResponse()));
  when(requestHandler.handleRead(any(Context.class),any(ReadRequest.class))).thenReturn(promise(newResourceResponse(null,null,null)));
  when(requestHandler.handleUpdate(any(Context.class),any(UpdateRequest.class))).thenReturn(promise(newResourceResponse(null,null,null)));
}"
9134,"/** 
 * <p>Gets the instance of the UmaProviderSettings.</p> <p>Cache each provider settings on the realm it was created for.</p>
 * @param request The request instance from which the base URL can be deduced.
 * @param realm The realm.
 * @return The OAuth2ProviderSettings instance.
 */
public UmaProviderSettings get(HttpServletRequest request,String realm) throws NotFoundException {
synchronized (providerSettingsMap) {
    UmaProviderSettingsImpl providerSettings=providerSettingsMap.get(realm);
    if (providerSettings == null) {
      OAuth2ProviderSettings oAuth2ProviderSettings=oAuth2ProviderSettingsFactory.get(realm,request);
      String baseUrlPattern=baseURLProviderFactory.get(realm).getURL(request);
      UmaTokenStore tokenStore=tokenStoreFactory.create(realm);
      providerSettings=new UmaProviderSettingsImpl(realm,baseUrlPattern,tokenStore,oAuth2ProviderSettings);
      providerSettingsMap.put(realm,providerSettings);
    }
    return providerSettings;
  }
}","/** 
 * <p>Gets the instance of the UmaProviderSettings.</p> <p>Cache each provider settings on the realm it was created for.</p>
 * @param context The context instance from which the base URL can be deduced.
 * @param realm The realm.
 * @return The OAuth2ProviderSettings instance.
 */
public UmaProviderSettings get(Context context,String realm) throws NotFoundException {
synchronized (providerSettingsMap) {
    UmaProviderSettingsImpl providerSettings=providerSettingsMap.get(realm);
    if (providerSettings == null) {
      OAuth2ProviderSettings oAuth2ProviderSettings=oAuth2ProviderSettingsFactory.get(realm,context);
      String baseUrlPattern=baseURLProviderFactory.get(realm).getURL(context.asContext(HttpContext.class));
      providerSettings=getUmaProviderSettings(realm,oAuth2ProviderSettings,baseUrlPattern);
    }
    return providerSettings;
  }
}"
9135,"@Provides @Singleton Iterator<HttpRouteProvider> getHttpRouteProviders(){
  return ServiceLoader.load(HttpRouteProvider.class).iterator();
}","@Provides @Singleton Iterable<HttpRouteProvider> getHttpRouteProviders(){
  return ServiceLoader.load(HttpRouteProvider.class);
}"
9136,"Handler getHandler(){
  return handler.get();
}","Handler getHandler(){
  return new Handler(){
    @Override public Promise<Response,NeverThrowsException> handle(    Context context,    Request request){
      return handler.get().handle(context,request);
    }
  }
;
}"
9137,"AuthenticationFilter(CrestAuthenticationFilter authenticationFilter,AuthenticationModule authenticationModule){
  this.authenticationFilter=authenticationFilter;
  this.authenticationModule=authenticationModule;
}","AuthenticationFilter(Filter authenticationFilter,AuthenticationModule authenticationModule){
  this.authenticationFilter=authenticationFilter;
  this.authenticationModule=authenticationModule;
}"
9138,"@BeforeClass public void setupMocks(){
  restletXACMLServiceServlet=mock(RestletServiceServlet.class);
  restletOAuth2ServiceServlet=mock(RestletServiceServlet.class);
  restletUMAServiceServlet=mock(RestletServiceServlet.class);
}","@BeforeClass public void setupMocks(){
  restletXACMLServiceServlet=mock(RestletServiceServlet.class);
  restletOAuth2ServiceServlet=mock(RestletServiceServlet.class);
  restletUMAServiceServlet=mock(RestletServiceServlet.class);
  restletXACMLHttpServlet=mock(HttpServlet.class);
  authenticationFilter=mock(Filter.class);
}"
9139,"@Test(dataProvider=""String_Node_Str"") public void shouldHandleRequestWithRestletServlet(String path,RestletServiceServlet servlet) throws Exception {
  HttpServletRequest request=mock(HttpServletRequest.class);
  HttpServletResponse response=mock(HttpServletResponse.class);
  given(request.getServletPath()).willReturn(path);
  restEndpointServlet.service(request,response);
  verify(servlet).service(Matchers.<HttpServletRequest>anyObject(),eq(response));
  for (  RestletServiceServlet s : Arrays.asList(restletXACMLServiceServlet,restletOAuth2ServiceServlet,restletUMAServiceServlet)) {
    if (s != servlet) {
      verifyZeroInteractions(s);
    }
  }
}","@Test(dataProvider=""String_Node_Str"",enabled=false) public void shouldHandleRequestWithRestletServlet(String path,HttpServlet servlet) throws Exception {
  HttpServletRequest request=mock(HttpServletRequest.class);
  HttpServletResponse response=mock(HttpServletResponse.class);
  given(request.getHeaderNames()).willReturn(Collections.enumeration(Collections.emptySet()));
  given(request.getAttributeNames()).willReturn(Collections.enumeration(Collections.emptySet()));
  given(request.getServletPath()).willReturn(path);
  restEndpointServlet.init();
  restEndpointServlet.service(request,response);
  verify(servlet).service(Matchers.<HttpServletRequest>anyObject(),eq(response));
  for (  HttpServlet s : Arrays.asList(restletXACMLHttpServlet,restletOAuth2ServiceServlet,restletUMAServiceServlet)) {
    if (s != servlet) {
      verifyZeroInteractions(s);
    }
  }
}"
9140,"@DataProvider(name=""String_Node_Str"") public Object[][] restletPathData(){
  return new Object[][]{{""String_Node_Str"",restletXACMLServiceServlet},{""String_Node_Str"",restletOAuth2ServiceServlet},{""String_Node_Str"",restletUMAServiceServlet}};
}","@DataProvider(name=""String_Node_Str"") public Object[][] restletPathData(){
  return new Object[][]{{""String_Node_Str"",restletXACMLHttpServlet},{""String_Node_Str"",restletOAuth2ServiceServlet},{""String_Node_Str"",restletUMAServiceServlet}};
}"
9141,"@BeforeMethod public void setUp(){
  reset(restletXACMLServiceServlet);
  reset(restletOAuth2ServiceServlet);
  reset(restletUMAServiceServlet);
  restEndpointServlet=new RestEndpointServlet(restletXACMLServiceServlet,restletOAuth2ServiceServlet,restletUMAServiceServlet);
}","@BeforeMethod public void setUp(){
  reset(restletXACMLServiceServlet,restletOAuth2ServiceServlet,restletUMAServiceServlet,restletXACMLHttpServlet,authenticationFilter);
  restEndpointServlet=new RestEndpointServlet(restletXACMLServiceServlet,restletOAuth2ServiceServlet,restletUMAServiceServlet,restletXACMLHttpServlet,authenticationFilter);
}"
9142,"private Promise<Collection<ResourceSetDescription>,ResourceException> getPolicies(final ServerContext context,QueryRequest policyQuery,final String resourceOwnerId,final Set<ResourceSetDescription> resourceSets,final boolean augmentWithPolicies,final ResourceSetWithPolicyQuery query){
  return policyService.queryPolicies(context,policyQuery).thenAsync(new AsyncFunction<Pair<QueryResult,Collection<UmaPolicy>>,Collection<ResourceSetDescription>,ResourceException>(){
    @Override public Promise<Collection<ResourceSetDescription>,ResourceException> apply(    final Pair<QueryResult,Collection<UmaPolicy>> result){
      final Set<ResourceSetDescription> filteredResourceSets=new HashSet<>();
      try {
        String realm=context.asContext(RealmContext.class).getResolvedRealm();
        Subject subject=createSubject(resourceOwnerId,realm);
        Evaluator evaluator=umaProviderSettingsFactory.get(realm).getPolicyEvaluator(subject);
        for (        UmaPolicy sharedPolicy : result.getSecond()) {
          String sharedResourceName=sharedPolicy.getResourceSet().getName();
          List<Entitlement> entitlements=evaluator.evaluate(realm,subject,sharedResourceName,null,false);
          if (!entitlements.isEmpty()) {
            resourceSets.add(sharedPolicy.getResourceSet());
          }
        }
        filteredResourceSets.addAll(query.getResourceSetQuery().accept(new QueryFilterVisitor<Set<ResourceSetDescription>,Set<ResourceSetDescription>,String>(){
          @Override public Set<ResourceSetDescription> visitAndFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          List<org.forgerock.util.query.QueryFilter<String>> list){
            for (            org.forgerock.util.query.QueryFilter<String> filter : list) {
              resourceSetDescriptions.retainAll(filter.accept(this,resourceSetDescriptions));
            }
            return resourceSetDescriptions;
          }
          @Override public Set<ResourceSetDescription> visitBooleanLiteralFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          boolean value){
            if (value) {
              return resourceSetDescriptions;
            }
 else {
              return Collections.EMPTY_SET;
            }
          }
          @Override public Set<ResourceSetDescription> visitContainsFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String fieldName,          Object value){
            Set<ResourceSetDescription> results=new HashSet<>();
            for (            ResourceSetDescription resourceSetDescription : resourceSetDescriptions) {
              if (fieldName.equals(""String_Node_Str"")) {
                if (resourceSetDescription.getName().toLowerCase().contains(((String)value).toLowerCase())) {
                  results.add(resourceSetDescription);
                }
              }
            }
            return results;
          }
          @Override public Set<ResourceSetDescription> visitEqualsFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String fieldName,          Object value){
            Set<ResourceSetDescription> results=new HashSet<>();
            for (            ResourceSetDescription resourceSetDescription : resourceSetDescriptions) {
              if (fieldName.equals(ResourceSetTokenField.RESOURCE_OWNER_ID)) {
                if (resourceSetDescription.getResourceOwnerId().equals(value)) {
                  results.add(resourceSetDescription);
                }
              }
 else               if (fieldName.equals(ResourceSetTokenField.RESOURCE_SET_ID)) {
                if (resourceSetDescription.getId().equals(value)) {
                  results.add(resourceSetDescription);
                }
              }
            }
            return results;
          }
          @Override public Set<ResourceSetDescription> visitExtendedMatchFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s,          String s2,          Object o){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitGreaterThanFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s,          Object o){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitGreaterThanOrEqualToFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s,          Object o){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitLessThanFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s,          Object o){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitLessThanOrEqualToFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s,          Object o){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitNotFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          org.forgerock.util.query.QueryFilter<String> queryFilter){
            Set<ResourceSetDescription> excludedResourceSets=queryFilter.accept(this,resourceSetDescriptions);
            resourceSetDescriptions.removeAll(excludedResourceSets);
            return resourceSetDescriptions;
          }
          @Override public Set<ResourceSetDescription> visitOrFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          List<org.forgerock.util.query.QueryFilter<String>> list){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitPresentFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitStartsWithFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s,          Object o){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
        }
,resourceSets));
        return Promises.newResultPromise((Collection<ResourceSetDescription>)filteredResourceSets);
      }
 catch (      EntitlementException e) {
        return Promises.newExceptionPromise((ResourceException)new InternalServerErrorException(e));
      }
    }
  }
);
}","private Promise<Collection<ResourceSetDescription>,ResourceException> getPolicies(final ServerContext context,QueryRequest policyQuery,final String resourceOwnerId,final Set<ResourceSetDescription> resourceSets,final boolean augmentWithPolicies,final ResourceSetWithPolicyQuery query){
  return policyService.queryPolicies(context,policyQuery).thenAsync(new AsyncFunction<Pair<QueryResult,Collection<UmaPolicy>>,Collection<ResourceSetDescription>,ResourceException>(){
    @Override public Promise<Collection<ResourceSetDescription>,ResourceException> apply(    final Pair<QueryResult,Collection<UmaPolicy>> result){
      final Set<ResourceSetDescription> filteredResourceSets=new HashSet<>();
      try {
        String realm=context.asContext(RealmContext.class).getResolvedRealm();
        Subject subject=createSubject(resourceOwnerId,realm);
        Evaluator evaluator=umaProviderSettingsFactory.get(realm).getPolicyEvaluator(subject);
        for (        UmaPolicy sharedPolicy : result.getSecond()) {
          if (!containsResourceSet(resourceSets,sharedPolicy.getResourceSet())) {
            String sharedResourceName=sharedPolicy.getResourceSet().getName();
            List<Entitlement> entitlements=evaluator.evaluate(realm,subject,sharedResourceName,null,false);
            if (!entitlements.isEmpty()) {
              resourceSets.add(sharedPolicy.getResourceSet());
            }
          }
        }
        filteredResourceSets.addAll(query.getResourceSetQuery().accept(new QueryFilterVisitor<Set<ResourceSetDescription>,Set<ResourceSetDescription>,String>(){
          @Override public Set<ResourceSetDescription> visitAndFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          List<org.forgerock.util.query.QueryFilter<String>> list){
            for (            org.forgerock.util.query.QueryFilter<String> filter : list) {
              resourceSetDescriptions.retainAll(filter.accept(this,resourceSetDescriptions));
            }
            return resourceSetDescriptions;
          }
          @Override public Set<ResourceSetDescription> visitBooleanLiteralFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          boolean value){
            if (value) {
              return resourceSetDescriptions;
            }
 else {
              return Collections.EMPTY_SET;
            }
          }
          @Override public Set<ResourceSetDescription> visitContainsFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String fieldName,          Object value){
            Set<ResourceSetDescription> results=new HashSet<>();
            for (            ResourceSetDescription resourceSetDescription : resourceSetDescriptions) {
              if (fieldName.equals(""String_Node_Str"")) {
                if (resourceSetDescription.getName().toLowerCase().contains(((String)value).toLowerCase())) {
                  results.add(resourceSetDescription);
                }
              }
            }
            return results;
          }
          @Override public Set<ResourceSetDescription> visitEqualsFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String fieldName,          Object value){
            Set<ResourceSetDescription> results=new HashSet<>();
            for (            ResourceSetDescription resourceSetDescription : resourceSetDescriptions) {
              if (fieldName.equals(ResourceSetTokenField.RESOURCE_OWNER_ID)) {
                if (resourceSetDescription.getResourceOwnerId().equals(value)) {
                  results.add(resourceSetDescription);
                }
              }
 else               if (fieldName.equals(ResourceSetTokenField.RESOURCE_SET_ID)) {
                if (resourceSetDescription.getId().equals(value)) {
                  results.add(resourceSetDescription);
                }
              }
            }
            return results;
          }
          @Override public Set<ResourceSetDescription> visitExtendedMatchFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s,          String s2,          Object o){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitGreaterThanFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s,          Object o){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitGreaterThanOrEqualToFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s,          Object o){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitLessThanFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s,          Object o){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitLessThanOrEqualToFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s,          Object o){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitNotFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          org.forgerock.util.query.QueryFilter<String> queryFilter){
            Set<ResourceSetDescription> excludedResourceSets=queryFilter.accept(this,resourceSetDescriptions);
            resourceSetDescriptions.removeAll(excludedResourceSets);
            return resourceSetDescriptions;
          }
          @Override public Set<ResourceSetDescription> visitOrFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          List<org.forgerock.util.query.QueryFilter<String>> list){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitPresentFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public Set<ResourceSetDescription> visitStartsWithFilter(          Set<ResourceSetDescription> resourceSetDescriptions,          String s,          Object o){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
        }
,resourceSets));
        return Promises.newResultPromise((Collection<ResourceSetDescription>)filteredResourceSets);
      }
 catch (      EntitlementException e) {
        return Promises.newExceptionPromise((ResourceException)new InternalServerErrorException(e));
      }
    }
  }
);
}"
9143,"/** 
 * @return the value of the default CTS root suffix
 */
@VisibleForTesting DN getDefaultRootSuffix(){
  return defaultRootSuffix;
}","/** 
 * @return the value of the default CTS root suffix
 */
public DN getDefaultRootSuffix(){
  return defaultRootSuffix;
}"
9144,"/** 
 * Performs the upgrade by traversing through the candidate LDIF files and tries to process them. If embedded configuration store is used the indexes are also rebuilt as part of the upgrade. That will make sure that the newly created indexes are all operational.
 * @throws UpgradeException If there was an error while processing the LDIF files.
 */
public void upgrade() throws UpgradeException {
  Connection conn=null;
  try {
    conn=connFactory.create();
    for (    Upgrader upgrader : upgraders) {
      processLDIF(conn,upgrader.getLDIFPath());
    }
  }
 catch (  DataLayerException ere) {
    DEBUG.error(""String_Node_Str"",ere);
    throw new UpgradeException(ere);
  }
 finally {
    IOUtils.closeIfNotNull(conn);
  }
  if (EmbeddedOpenDS.isStarted()) {
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"");
    }
    Map<String,String> rebuildIndexData=new HashMap<String,String>(2);
    rebuildIndexData.put(SetupConstants.CONFIG_VAR_BASE_DIR,baseDir);
    rebuildIndexData.put(SetupConstants.CONFIG_VAR_ROOT_SUFFIX,baseDN);
    try {
      EmbeddedOpenDS.rebuildIndex(rebuildIndexData);
    }
 catch (    Exception ex) {
      throw new UpgradeException(ex);
    }
  }
}","/** 
 * Performs the upgrade by traversing through the candidate LDIF files and tries to process them. If embedded configuration store is used the indexes are also rebuilt as part of the upgrade. That will make sure that the newly created indexes are all operational.
 * @throws UpgradeException If there was an error while processing the LDIF files.
 */
public void upgrade() throws UpgradeException {
  Connection conn=null;
  try {
    conn=connFactory.create();
    for (    Upgrader upgrader : upgraders) {
      processLDIF(conn,upgrader.getLDIFPath());
    }
  }
 catch (  DataLayerException ere) {
    DEBUG.error(""String_Node_Str"",ere);
    throw new UpgradeException(ere);
  }
 finally {
    IOUtils.closeIfNotNull(conn);
  }
  if (isEmbedded) {
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"");
    }
    Map<String,String> rebuildIndexData=new HashMap<String,String>(2);
    rebuildIndexData.put(SetupConstants.CONFIG_VAR_BASE_DIR,baseDir);
    rebuildIndexData.put(SetupConstants.CONFIG_VAR_ROOT_SUFFIX,baseDN);
    try {
      EmbeddedOpenDS.rebuildIndex(rebuildIndexData);
    }
 catch (    Exception ex) {
      throw new UpgradeException(ex);
    }
  }
}"
9145,"/** 
 * This constructor will initialize the different directory content upgraders and ensures that each of them are actually applicable. At the end this upgrader will have a list of   {@link Upgrader}s that needs to be executed.
 * @param baseDir The base directory of OpenAM (where the configuration can be found).
 * @param baseDN The base DN of the configuration store.
 * @throws UpgradeException If there was a problem while checking if a given Upgrader is applicable.
 */
public DirectoryContentUpgrader(String baseDir,String baseDN) throws UpgradeException {
  this.baseDir=baseDir;
  this.baseDN=baseDN;
  Key<ConnectionFactory> key=Key.get(ConnectionFactory.class,DataLayer.Types.typed(ConnectionType.DATA_LAYER));
  connFactory=InjectorHolder.getInstance(key);
  upgraders.add(new AddCTSSchema());
  upgraders.add(new CreateCTSContainer());
  if (EmbeddedOpenDS.isStarted()) {
    upgraders.add(new CreateCTSIndexes());
    upgraders.add(new AddDashboardSchema());
    upgraders.add(new AddDevicePrintSchema());
    upgraders.add(new AddUmaAuditSchema());
    upgraders.add(new AddResourceSetsSchema());
    upgraders.add(new AddUmaPendingRequestsSchema());
    upgraders.add(new AddOATHDeviceSchema());
    upgraders.add(new OATH2FASchema());
  }
  Connection conn=null;
  try {
    conn=connFactory.create();
    Schema schema=null;
    try {
      schema=Schema.readSchemaForEntry(conn,DN.valueOf(baseDN)).asStrictSchema();
    }
 catch (    ErrorResultException ere) {
      DEBUG.error(""String_Node_Str"",ere);
    }
    Iterator<Upgrader> it=upgraders.iterator();
    while (it.hasNext()) {
      if (!it.next().isUpgradeNecessary(conn,schema)) {
        it.remove();
      }
    }
  }
 catch (  DataLayerException ere) {
    DEBUG.error(""String_Node_Str"",ere);
    throw new UpgradeException(ere);
  }
 finally {
    IOUtils.closeIfNotNull(conn);
  }
}","/** 
 * This constructor will initialize the different directory content upgraders and ensures that each of them are actually applicable. At the end this upgrader will have a list of   {@link Upgrader}s that needs to be executed.
 * @param baseDir The base directory of OpenAM (where the configuration can be found).
 * @param baseDN The base DN of the configuration store.
 * @throws UpgradeException If there was a problem while checking if a given Upgrader is applicable.
 */
public DirectoryContentUpgrader(String baseDir,String baseDN) throws UpgradeException {
  this.baseDir=baseDir;
  this.baseDN=baseDN;
  isEmbedded=EmbeddedOpenDS.isStarted();
  ctsConfig=InjectorHolder.getInstance(CTSDataLayerConfiguration.class);
  Key<ConnectionFactory> key=Key.get(ConnectionFactory.class,DataLayer.Types.typed(ConnectionType.DATA_LAYER));
  connFactory=InjectorHolder.getInstance(key);
  upgraders.add(new AddCTSSchema());
  upgraders.add(new CreateCTSContainer());
  if (isEmbedded) {
    upgraders.add(new CreateCTSIndexes());
    upgraders.add(new AddDashboardSchema());
    upgraders.add(new AddDevicePrintSchema());
    upgraders.add(new AddUmaAuditSchema());
    upgraders.add(new AddResourceSetsSchema());
    upgraders.add(new AddUmaPendingRequestsSchema());
    upgraders.add(new AddOATHDeviceSchema());
    upgraders.add(new OATH2FASchema());
  }
  Connection conn=null;
  try {
    conn=connFactory.create();
    Schema schema=null;
    try {
      schema=Schema.readSchemaForEntry(conn,DN.valueOf(baseDN)).asStrictSchema();
    }
 catch (    ErrorResultException ere) {
      DEBUG.error(""String_Node_Str"",ere);
    }
    Iterator<Upgrader> it=upgraders.iterator();
    while (it.hasNext()) {
      if (!it.next().isUpgradeNecessary(conn,schema)) {
        it.remove();
      }
    }
  }
 catch (  DataLayerException ere) {
    DEBUG.error(""String_Node_Str"",ere);
    throw new UpgradeException(ere);
  }
 finally {
    IOUtils.closeIfNotNull(conn);
  }
}"
9146,"private JsonValue parseOptions(String options){
  if (options == null) {
    return json(""String_Node_Str"");
  }
  if (KEY_VALUE_PAIR_REGEX.matcher(options).matches()) {
    JsonValue optionsValue=json(object());
    for (    String pair : options.split(""String_Node_Str"")) {
      String[] keyValue=pair.trim().split(""String_Node_Str"");
      if (keyValue.length != 2) {
        return json(options);
      }
      optionsValue.add(keyValue[0],keyValue[1]);
    }
    return optionsValue;
  }
 else {
    return json(options);
  }
}","private JsonValue parseOptions(String options){
  if (options == null || options.isEmpty()) {
    return json(object());
  }
  if (KEY_VALUE_PAIR_REGEX.matcher(options).matches()) {
    JsonValue optionsValue=json(object());
    for (    String pair : options.split(""String_Node_Str"")) {
      String[] keyValue=pair.trim().split(""String_Node_Str"");
      if (keyValue.length != 2) {
        return json(options);
      }
      optionsValue.add(keyValue[0],keyValue[1]);
    }
    return optionsValue;
  }
 else {
    return json(options);
  }
}"
9147,"private JsonValue transformRequestBody(JsonValue body) throws InternalServerErrorException {
  if (body.isDefined(""String_Node_Str"")) {
    try {
      List<AuthConfigurationEntry> entries=new ArrayList<>();
      for (      JsonValue entry : body.get(""String_Node_Str"")) {
        String module=entry.get(""String_Node_Str"").asString();
        String criteria=entry.get(""String_Node_Str"").asString();
        String options;
        if (entry.get(""String_Node_Str"").isString()) {
          options=entry.get(""String_Node_Str"").asString();
        }
 else {
          StringBuilder optionsBuilder=new StringBuilder();
          for (          Map.Entry<String,String> option : entry.get(""String_Node_Str"").asMap(String.class).entrySet()) {
            optionsBuilder.append(option.getKey()).append(""String_Node_Str"").append(option.getValue()).append(""String_Node_Str"");
          }
          options=optionsBuilder.substring(0,optionsBuilder.length() - 1);
        }
        entries.add(new AuthConfigurationEntry(module,criteria,options));
      }
      body.put(""String_Node_Str"",AMAuthConfigUtils.authConfigurationEntryToXMLString(entries));
    }
 catch (    AMConfigurationException e) {
      throw new InternalServerErrorException(""String_Node_Str"",e);
    }
  }
  return body;
}","private JsonValue transformRequestBody(JsonValue body) throws InternalServerErrorException {
  if (body.isDefined(""String_Node_Str"")) {
    try {
      List<AuthConfigurationEntry> entries=new ArrayList<>();
      for (      JsonValue entry : body.get(""String_Node_Str"")) {
        String module=entry.get(""String_Node_Str"").asString();
        String criteria=entry.get(""String_Node_Str"").asString();
        String options=getOptions(entry);
        entries.add(new AuthConfigurationEntry(module,criteria,options));
      }
      body.put(""String_Node_Str"",AMAuthConfigUtils.authConfigurationEntryToXMLString(entries));
    }
 catch (    AMConfigurationException e) {
      throw new InternalServerErrorException(""String_Node_Str"",e);
    }
  }
  return body;
}"
9148,"/** 
 * Populate the map containing the headers keys and values based on the   {@link FilterConfig}.   {@inheritDoc}
 */
@Override public void init(FilterConfig config) throws ServletException {
  if (config != null) {
    Enumeration<String> initParams=config.getInitParameterNames();
    while (initParams.hasMoreElements()) {
      String headerKey=initParams.nextElement();
      headerKeyValues.put(headerKey,config.getInitParameter(headerKey));
    }
  }
}","/** 
 * Initializes the filter based on the   {@link FilterConfig}. The ""excludes"" init parameter is used to prevent the filter from setting the headers when accessing certain URIs. Any other init parameter specified in web.xml will be handled as a headername-headervalue pair that should be added to the HttpServletResponse.  {@inheritDoc}
 */
@Override public void init(FilterConfig config) throws ServletException {
  if (config != null) {
    contextPathLength=config.getServletContext().getContextPath().length();
    Enumeration<String> initParams=config.getInitParameterNames();
    while (initParams.hasMoreElements()) {
      String key=initParams.nextElement();
      String value=config.getInitParameter(key);
      if (EXCLUDES.equals(key)) {
        excludes.addAll(Arrays.asList(value.split(""String_Node_Str"")));
      }
 else {
        headerKeyValues.put(key,value);
      }
    }
  }
}"
9149,"/** 
 * Set HTTP Headers based on the values in the filterConfig init-parameters.  {@inheritDoc}
 */
@Override public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse,FilterChain filterChain) throws IOException, ServletException {
  HttpServletResponse httpServletResponse=(HttpServletResponse)servletResponse;
  HttpServletRequest httpServleRequest=(HttpServletRequest)servletRequest;
  for (  Map.Entry<String,String> entry : headerKeyValues.entrySet()) {
    httpServletResponse.addHeader(entry.getKey(),entry.getValue());
  }
  filterChain.doFilter(httpServleRequest,httpServletResponse);
}","/** 
 * Set HTTP Headers based on the values in the filterConfig init-parameters.  {@inheritDoc}
 */
@Override public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse,FilterChain filterChain) throws IOException, ServletException {
  HttpServletRequest httpServletRequest=(HttpServletRequest)servletRequest;
  HttpServletResponse httpServletResponse=(HttpServletResponse)servletResponse;
  if (!excludes.contains(httpServletRequest.getRequestURI().substring(contextPathLength))) {
    for (    Map.Entry<String,String> entry : headerKeyValues.entrySet()) {
      httpServletResponse.addHeader(entry.getKey(),entry.getValue());
    }
  }
  filterChain.doFilter(httpServletRequest,httpServletResponse);
}"
9150,"/** 
 * Initialises the JwtSessionModule for use by the Post Authentication Process.
 * @param requestParamsMap {@inheritDoc}
 * @param request {@inheritDoc}
 * @param response {@inheritDoc}
 * @param ssoToken {@inheritDoc}
 * @return {@inheritDoc}
 * @throws AuthenticationException {@inheritDoc}
 */
@Override protected Map<String,Object> initialize(Map requestParamsMap,HttpServletRequest request,HttpServletResponse response,SSOToken ssoToken) throws AuthenticationException {
  try {
    final String tokenIdleTime=ssoToken.getProperty(JwtSessionModule.TOKEN_IDLE_TIME_CLAIM_KEY);
    final String maxTokenLife=ssoToken.getProperty(JwtSessionModule.MAX_TOKEN_LIFE_KEY);
    final boolean enforceClientIP=Boolean.parseBoolean(ssoToken.getProperty(ENFORCE_CLIENT_IP_SETTING_KEY));
    final String realm=ssoToken.getProperty(SSO_TOKEN_ORGANIZATION_PROPERTY_KEY);
    boolean secureCookie=Boolean.parseBoolean(ssoToken.getProperty(SECURE_COOKIE_KEY));
    boolean httpOnlyCookie=Boolean.parseBoolean(ssoToken.getProperty(HTTP_ONLY_COOKIE_KEY));
    String cookieName=ssoToken.getProperty(COOKIE_NAME_KEY);
    Collection<String> cookieDomains=Arrays.asList(ssoToken.getProperty(COOKIE_DOMAINS_KEY).split(""String_Node_Str""));
    return initialize(tokenIdleTime,maxTokenLife,enforceClientIP,realm,secureCookie,httpOnlyCookie,cookieName,cookieDomains);
  }
 catch (  SSOException e) {
    DEBUG.error(""String_Node_Str"",e);
    throw new AuthenticationException(e.getLocalizedMessage());
  }
catch (  SMSException e) {
    DEBUG.error(""String_Node_Str"",e);
    throw new AuthenticationException(e.getLocalizedMessage());
  }
}","/** 
 * Initialises the JwtSessionModule for use by the Post Authentication Process.
 * @param requestParamsMap {@inheritDoc}
 * @param request {@inheritDoc}
 * @param response {@inheritDoc}
 * @param ssoToken {@inheritDoc}
 * @return {@inheritDoc}
 * @throws AuthenticationException {@inheritDoc}
 */
@Override protected Map<String,Object> initialize(Map requestParamsMap,HttpServletRequest request,HttpServletResponse response,SSOToken ssoToken) throws AuthenticationException {
  try {
    final String tokenIdleTime=ssoToken.getProperty(JwtSessionModule.TOKEN_IDLE_TIME_CLAIM_KEY);
    final String maxTokenLife=ssoToken.getProperty(JwtSessionModule.MAX_TOKEN_LIFE_KEY);
    final boolean enforceClientIP=Boolean.parseBoolean(ssoToken.getProperty(ENFORCE_CLIENT_IP_SETTING_KEY));
    final String realm=ssoToken.getProperty(SSO_TOKEN_ORGANIZATION_PROPERTY_KEY);
    boolean secureCookie=Boolean.parseBoolean(ssoToken.getProperty(SECURE_COOKIE_KEY));
    boolean httpOnlyCookie=Boolean.parseBoolean(ssoToken.getProperty(HTTP_ONLY_COOKIE_KEY));
    String cookieName=ssoToken.getProperty(COOKIE_NAME_KEY);
    String cookieDomainsString=ssoToken.getProperty(COOKIE_DOMAINS_KEY);
    Collection<String> cookieDomains;
    if (cookieDomainsString.isEmpty()) {
      cookieDomains=Collections.singleton(null);
    }
 else {
      cookieDomains=Arrays.asList(cookieDomainsString.split(""String_Node_Str""));
    }
    return initialize(tokenIdleTime,maxTokenLife,enforceClientIP,realm,secureCookie,httpOnlyCookie,cookieName,cookieDomains);
  }
 catch (  SSOException e) {
    DEBUG.error(""String_Node_Str"",e);
    throw new AuthenticationException(e.getLocalizedMessage());
  }
catch (  SMSException e) {
    DEBUG.error(""String_Node_Str"",e);
    throw new AuthenticationException(e.getLocalizedMessage());
  }
}"
9151,"public Set getAssignedServices(SSOToken token,IdType type,String name,Map mapOfServiceNamesAndOCs,String amOrgName,String amsdkDN) throws IdRepoException, SSOException {
  IdRepoException origEx=null;
  checkPermission(token,amOrgName,name,null,IdOperation.READ,type);
  Set configuredPluginClasses=idrepoCache.getIdRepoPlugins(amOrgName,IdOperation.SERVICE,type);
  if ((configuredPluginClasses == null) || configuredPluginClasses.isEmpty()) {
    if (ServiceManager.getBaseDN().equalsIgnoreCase(amOrgName) && (type.equals(IdType.REALM))) {
      return (configuredPluginClasses);
    }
 else {
      throw new IdRepoException(IdRepoBundle.BUNDLE_NAME,""String_Node_Str"",null);
    }
  }
  Iterator it=configuredPluginClasses.iterator();
  int noOfSuccess=configuredPluginClasses.size();
  IdRepo idRepo=null;
  Set resultsSet=new HashSet();
  while (it.hasNext()) {
    IdRepo repo=(IdRepo)it.next();
    try {
      Set services=null;
      if (repo.getClass().getName().equals(IdConstants.AMSDK_PLUGIN) && amsdkDN != null) {
        services=repo.getAssignedServices(token,type,amsdkDN,mapOfServiceNamesAndOCs);
      }
 else {
        services=repo.getAssignedServices(token,type,name,mapOfServiceNamesAndOCs);
      }
      if (services != null && !services.isEmpty()) {
        resultsSet.addAll(services);
      }
    }
 catch (    IdRepoUnsupportedOpException ide) {
      if (idRepo != null && DEBUG.messageEnabled()) {
        DEBUG.message(""String_Node_Str"" + ""String_Node_Str"" + repo.getClass().getName() + ""String_Node_Str""+ ide.getMessage());
      }
      noOfSuccess--;
      origEx=(origEx == null) ? ide : origEx;
    }
catch (    IdRepoFatalException idf) {
      DEBUG.error(""String_Node_Str"" + ""String_Node_Str"",idf);
      throw idf;
    }
catch (    IdRepoException ide) {
      if (idRepo != null && DEBUG.warningEnabled()) {
        DEBUG.warning(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + idRepo.getClass().getName() + ""String_Node_Str""+ ide.getMessage());
      }
      noOfSuccess--;
      origEx=(origEx == null) ? ide : origEx;
    }
  }
  if (noOfSuccess == 0) {
    if (DEBUG.warningEnabled()) {
      DEBUG.warning(""String_Node_Str"" + ""String_Node_Str"" + type.getName() + ""String_Node_Str""+ name+ ""String_Node_Str"",origEx);
    }
    throw origEx;
  }
 else {
    return resultsSet;
  }
}","public Set<String> getAssignedServices(SSOToken token,IdType type,String name,Map mapOfServiceNamesAndOCs,String amOrgName,String amsdkDN) throws IdRepoException, SSOException {
  IdRepoException origEx=null;
  checkPermission(token,amOrgName,name,null,IdOperation.READ,type);
  Set<IdRepo> configuredPluginClasses=idrepoCache.getIdRepoPlugins(amOrgName,IdOperation.SERVICE,type);
  if (configuredPluginClasses == null || configuredPluginClasses.isEmpty()) {
    if (type.equals(IdType.REALM)) {
      return Collections.emptySet();
    }
  }
  int noOfSuccess=configuredPluginClasses.size();
  Set<String> resultsSet=new HashSet<String>();
  for (  IdRepo repo : configuredPluginClasses) {
    try {
      Set<String> services;
      if (repo.getClass().getName().equals(IdConstants.AMSDK_PLUGIN) && amsdkDN != null) {
        services=repo.getAssignedServices(token,type,amsdkDN,mapOfServiceNamesAndOCs);
      }
 else {
        services=repo.getAssignedServices(token,type,name,mapOfServiceNamesAndOCs);
      }
      if (services != null && !services.isEmpty()) {
        resultsSet.addAll(services);
      }
    }
 catch (    IdRepoUnsupportedOpException ide) {
      if (DEBUG.messageEnabled()) {
        DEBUG.message(""String_Node_Str"" + repo.getClass().getName() + ""String_Node_Str""+ ide.getMessage());
      }
      noOfSuccess--;
      origEx=origEx == null ? ide : origEx;
    }
catch (    IdRepoFatalException idf) {
      DEBUG.error(""String_Node_Str"",idf);
      throw idf;
    }
catch (    IdRepoException ide) {
      if (DEBUG.warningEnabled()) {
        DEBUG.warning(""String_Node_Str"" + ""String_Node_Str"" + repo.getClass().getName() + ""String_Node_Str""+ ide.getMessage());
      }
      noOfSuccess--;
      origEx=(origEx == null) ? ide : origEx;
    }
  }
  if (noOfSuccess == 0) {
    if (DEBUG.warningEnabled()) {
      DEBUG.warning(""String_Node_Str"" + type.getName() + ""String_Node_Str""+ name+ ""String_Node_Str"",origEx);
    }
    throw origEx;
  }
 else {
    return resultsSet;
  }
}"
9152,"public Set getAssignedServices(SSOToken token,IdType type,String name,Map mapOfServiceNamesAndOCs,String amOrgName,String amsdkDN) throws IdRepoException, SSOException {
  IdRepoException origEx=null;
  checkPermission(token,amOrgName,name,null,IdOperation.READ,type);
  Set configuredPluginClasses=idrepoCache.getIdRepoPlugins(amOrgName,IdOperation.SERVICE,type);
  if ((configuredPluginClasses == null) || configuredPluginClasses.isEmpty()) {
    if (ServiceManager.getBaseDN().equalsIgnoreCase(amOrgName) && (type.equals(IdType.REALM))) {
      return (configuredPluginClasses);
    }
 else {
      throw new IdRepoException(IdRepoBundle.BUNDLE_NAME,""String_Node_Str"",null);
    }
  }
  Iterator it=configuredPluginClasses.iterator();
  int noOfSuccess=configuredPluginClasses.size();
  IdRepo idRepo=null;
  Set resultsSet=new HashSet();
  while (it.hasNext()) {
    IdRepo repo=(IdRepo)it.next();
    try {
      Set services=null;
      if (repo.getClass().getName().equals(IdConstants.AMSDK_PLUGIN) && amsdkDN != null) {
        services=repo.getAssignedServices(token,type,amsdkDN,mapOfServiceNamesAndOCs);
      }
 else {
        services=repo.getAssignedServices(token,type,name,mapOfServiceNamesAndOCs);
      }
      if (services != null && !services.isEmpty()) {
        resultsSet.addAll(services);
      }
    }
 catch (    IdRepoUnsupportedOpException ide) {
      if (idRepo != null && DEBUG.messageEnabled()) {
        DEBUG.message(""String_Node_Str"" + ""String_Node_Str"" + repo.getClass().getName() + ""String_Node_Str""+ ide.getMessage());
      }
      noOfSuccess--;
      origEx=(origEx == null) ? ide : origEx;
    }
catch (    IdRepoFatalException idf) {
      DEBUG.error(""String_Node_Str"" + ""String_Node_Str"",idf);
      throw idf;
    }
catch (    IdRepoException ide) {
      if (idRepo != null && DEBUG.warningEnabled()) {
        DEBUG.warning(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + idRepo.getClass().getName() + ""String_Node_Str""+ ide.getMessage());
      }
      noOfSuccess--;
      origEx=(origEx == null) ? ide : origEx;
    }
  }
  if (noOfSuccess == 0) {
    if (DEBUG.warningEnabled()) {
      DEBUG.warning(""String_Node_Str"" + ""String_Node_Str"" + type.getName() + ""String_Node_Str""+ name+ ""String_Node_Str"",origEx);
    }
    throw origEx;
  }
 else {
    return resultsSet;
  }
}","public Set<String> getAssignedServices(SSOToken token,IdType type,String name,Map mapOfServiceNamesAndOCs,String amOrgName,String amsdkDN) throws IdRepoException, SSOException {
  IdRepoException origEx=null;
  checkPermission(token,amOrgName,name,null,IdOperation.READ,type);
  Set<IdRepo> configuredPluginClasses=idrepoCache.getIdRepoPlugins(amOrgName,IdOperation.SERVICE,type);
  if (configuredPluginClasses == null || configuredPluginClasses.isEmpty()) {
    if (type.equals(IdType.REALM)) {
      return Collections.emptySet();
    }
  }
  int noOfSuccess=configuredPluginClasses.size();
  Set<String> resultsSet=new HashSet<String>();
  for (  IdRepo repo : configuredPluginClasses) {
    try {
      Set<String> services;
      if (repo.getClass().getName().equals(IdConstants.AMSDK_PLUGIN) && amsdkDN != null) {
        services=repo.getAssignedServices(token,type,amsdkDN,mapOfServiceNamesAndOCs);
      }
 else {
        services=repo.getAssignedServices(token,type,name,mapOfServiceNamesAndOCs);
      }
      if (services != null && !services.isEmpty()) {
        resultsSet.addAll(services);
      }
    }
 catch (    IdRepoUnsupportedOpException ide) {
      if (DEBUG.messageEnabled()) {
        DEBUG.message(""String_Node_Str"" + repo.getClass().getName() + ""String_Node_Str""+ ide.getMessage());
      }
      noOfSuccess--;
      origEx=origEx == null ? ide : origEx;
    }
catch (    IdRepoFatalException idf) {
      DEBUG.error(""String_Node_Str"",idf);
      throw idf;
    }
catch (    IdRepoException ide) {
      if (DEBUG.warningEnabled()) {
        DEBUG.warning(""String_Node_Str"" + ""String_Node_Str"" + repo.getClass().getName() + ""String_Node_Str""+ ide.getMessage());
      }
      noOfSuccess--;
      origEx=(origEx == null) ? ide : origEx;
    }
  }
  if (noOfSuccess == 0) {
    if (DEBUG.warningEnabled()) {
      DEBUG.warning(""String_Node_Str"" + type.getName() + ""String_Node_Str""+ name+ ""String_Node_Str"",origEx);
    }
    throw origEx;
  }
 else {
    return resultsSet;
  }
}"
9153,"public Set getAssignedServices(SSOToken token,IdType type,String name,Map mapOfServiceNamesAndOCs,String amOrgName,String amsdkDN) throws IdRepoException, SSOException {
  IdRepoException origEx=null;
  checkPermission(token,amOrgName,name,null,IdOperation.READ,type);
  Set configuredPluginClasses=idrepoCache.getIdRepoPlugins(amOrgName,IdOperation.SERVICE,type);
  if ((configuredPluginClasses == null) || configuredPluginClasses.isEmpty()) {
    if (ServiceManager.getBaseDN().equalsIgnoreCase(amOrgName) && (type.equals(IdType.REALM))) {
      return (configuredPluginClasses);
    }
 else {
      throw new IdRepoException(IdRepoBundle.BUNDLE_NAME,""String_Node_Str"",null);
    }
  }
  Iterator it=configuredPluginClasses.iterator();
  int noOfSuccess=configuredPluginClasses.size();
  IdRepo idRepo=null;
  Set resultsSet=new HashSet();
  while (it.hasNext()) {
    IdRepo repo=(IdRepo)it.next();
    try {
      Set services=null;
      if (repo.getClass().getName().equals(IdConstants.AMSDK_PLUGIN) && amsdkDN != null) {
        services=repo.getAssignedServices(token,type,amsdkDN,mapOfServiceNamesAndOCs);
      }
 else {
        services=repo.getAssignedServices(token,type,name,mapOfServiceNamesAndOCs);
      }
      if (services != null && !services.isEmpty()) {
        resultsSet.addAll(services);
      }
    }
 catch (    IdRepoUnsupportedOpException ide) {
      if (idRepo != null && DEBUG.messageEnabled()) {
        DEBUG.message(""String_Node_Str"" + ""String_Node_Str"" + repo.getClass().getName() + ""String_Node_Str""+ ide.getMessage());
      }
      noOfSuccess--;
      origEx=(origEx == null) ? ide : origEx;
    }
catch (    IdRepoFatalException idf) {
      DEBUG.error(""String_Node_Str"" + ""String_Node_Str"",idf);
      throw idf;
    }
catch (    IdRepoException ide) {
      if (idRepo != null && DEBUG.warningEnabled()) {
        DEBUG.warning(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + idRepo.getClass().getName() + ""String_Node_Str""+ ide.getMessage());
      }
      noOfSuccess--;
      origEx=(origEx == null) ? ide : origEx;
    }
  }
  if (noOfSuccess == 0) {
    if (DEBUG.warningEnabled()) {
      DEBUG.warning(""String_Node_Str"" + ""String_Node_Str"" + type.getName() + ""String_Node_Str""+ name+ ""String_Node_Str"",origEx);
    }
    throw origEx;
  }
 else {
    return resultsSet;
  }
}","public Set<String> getAssignedServices(SSOToken token,IdType type,String name,Map mapOfServiceNamesAndOCs,String amOrgName,String amsdkDN) throws IdRepoException, SSOException {
  IdRepoException origEx=null;
  checkPermission(token,amOrgName,name,null,IdOperation.READ,type);
  Set<IdRepo> configuredPluginClasses=idrepoCache.getIdRepoPlugins(amOrgName,IdOperation.SERVICE,type);
  if (configuredPluginClasses == null || configuredPluginClasses.isEmpty()) {
    if (type.equals(IdType.REALM)) {
      return Collections.emptySet();
    }
  }
  int noOfSuccess=configuredPluginClasses.size();
  Set<String> resultsSet=new HashSet<String>();
  for (  IdRepo repo : configuredPluginClasses) {
    try {
      Set<String> services;
      if (repo.getClass().getName().equals(IdConstants.AMSDK_PLUGIN) && amsdkDN != null) {
        services=repo.getAssignedServices(token,type,amsdkDN,mapOfServiceNamesAndOCs);
      }
 else {
        services=repo.getAssignedServices(token,type,name,mapOfServiceNamesAndOCs);
      }
      if (services != null && !services.isEmpty()) {
        resultsSet.addAll(services);
      }
    }
 catch (    IdRepoUnsupportedOpException ide) {
      if (DEBUG.messageEnabled()) {
        DEBUG.message(""String_Node_Str"" + repo.getClass().getName() + ""String_Node_Str""+ ide.getMessage());
      }
      noOfSuccess--;
      origEx=origEx == null ? ide : origEx;
    }
catch (    IdRepoFatalException idf) {
      DEBUG.error(""String_Node_Str"",idf);
      throw idf;
    }
catch (    IdRepoException ide) {
      if (DEBUG.warningEnabled()) {
        DEBUG.warning(""String_Node_Str"" + ""String_Node_Str"" + repo.getClass().getName() + ""String_Node_Str""+ ide.getMessage());
      }
      noOfSuccess--;
      origEx=(origEx == null) ? ide : origEx;
    }
  }
  if (noOfSuccess == 0) {
    if (DEBUG.warningEnabled()) {
      DEBUG.warning(""String_Node_Str"" + type.getName() + ""String_Node_Str""+ name+ ""String_Node_Str"",origEx);
    }
    throw origEx;
  }
 else {
    return resultsSet;
  }
}"
9154,"void updateSessionForFailover(){
  if (!isNoSession() || stateless) {
    return;
  }
  getSession().setIsISStored(true);
}","void updateSessionForFailover(){
  if (stateless || isNoSession()) {
    return;
  }
  getSession().setIsISStored(true);
}"
9155,"@Test public void rotationInDSTDateOctober() throws Exception {
  Calendar calDSTOctober=Calendar.getInstance();
  calDSTOctober.set(Calendar.YEAR,2015);
  calDSTOctober.set(Calendar.MONTH,Calendar.OCTOBER);
  calDSTOctober.set(Calendar.DAY_OF_MONTH,26);
  calDSTOctober.set(Calendar.HOUR_OF_DAY,1);
  calDSTOctober.set(Calendar.MINUTE,58);
  calDSTOctober.set(Calendar.SECOND,0);
  calDSTOctober.set(Calendar.MILLISECOND,0);
  long fakeInitTime=calDSTOctober.getTimeInMillis();
  System.out.println(TimeZone.getDefault().getDisplayName());
  System.out.println(TimeZone.getDefault().getID());
  System.out.println(""String_Node_Str"" + dateFormat.format(calDSTOctober.getTime()) + ""String_Node_Str"");
  rotation(fakeInitTime);
}","@Test public void rotationInDSTDateOctober() throws Exception {
  Calendar calDSTOctober=Calendar.getInstance();
  calDSTOctober.set(Calendar.YEAR,2015);
  calDSTOctober.set(Calendar.MONTH,Calendar.OCTOBER);
  calDSTOctober.set(Calendar.DAY_OF_MONTH,26);
  calDSTOctober.set(Calendar.HOUR_OF_DAY,1);
  calDSTOctober.set(Calendar.MINUTE,58);
  calDSTOctober.set(Calendar.SECOND,0);
  calDSTOctober.set(Calendar.MILLISECOND,0);
  long fakeInitTime=calDSTOctober.getTimeInMillis();
  System.out.println(""String_Node_Str"" + dateFormat.format(calDSTOctober.getTime()) + ""String_Node_Str"");
  rotation(fakeInitTime);
}"
9156,"private void rotation(long fakeInitTime) throws Exception {
  String DEBUG_CONFIG_FOR_TEST=""String_Node_Str"";
  initializeProperties();
  initializeProvider(DEBUG_CONFIG_FOR_TEST);
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  String debugNameFile=""String_Node_Str"";
  long initTime=System.currentTimeMillis();
  int testDurationMs=2000;
  int factor=360;
  int fakeDurationMs=testDurationMs * factor;
  TimeService accelerateClock=new AccelerateTimeService(fakeInitTime,factor);
  debugFileProvider.setClock(accelerateClock);
  IDebug debugTest1MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  IDebug debugTest2MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  IDebug debugTest3MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  List<PrintLogRunnable> printLogRunnableTests=new ArrayList<PrintLogRunnable>();
  PrintLogRunnable printLogRunnableTest1=new PrintLogRunnable(debugTest1MergeToDebugMerge,initTime,testDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest1);
  PrintLogRunnable printLogRunnableTest2=new PrintLogRunnable(debugTest2MergeToDebugMerge,initTime,testDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest2);
  PrintLogRunnable printLogRunnableTest3=new PrintLogRunnable(debugTest3MergeToDebugMerge,initTime,testDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest3);
  List<Thread> threads=new ArrayList<Thread>();
  for (  PrintLogRunnable printLogRunnableTest : printLogRunnableTests) {
    threads.add(new Thread(printLogRunnableTest));
  }
  debugTest1MergeToDebugMerge.message(""String_Node_Str"",null);
  long currentAccelerateTimeInMin=accelerateClock.now() / (1000 * 60);
  while (accelerateClock.now() / (1000 * 60) < currentAccelerateTimeInMin) {
    Thread.sleep(100);
  }
  debugTest2MergeToDebugMerge.message(""String_Node_Str"",null);
  currentAccelerateTimeInMin=accelerateClock.now() / (1000 * 60);
  while (accelerateClock.now() / (1000 * 60) < currentAccelerateTimeInMin) {
    Thread.sleep(100);
  }
  debugTest3MergeToDebugMerge.message(""String_Node_Str"",null);
  for (  Thread thread : threads) {
    thread.start();
  }
  for (  Thread thread : threads) {
    thread.join();
  }
  for (  PrintLogRunnable printLogRunnableTest : printLogRunnableTests) {
    if (printLogRunnableTest.ex != null)     throw printLogRunnableTest.ex;
  }
  Calendar calRandomDate=Calendar.getInstance();
  calRandomDate.setTimeInMillis(fakeInitTime);
  if (!isFileExist(debugNameFile + dateFormat.format(calRandomDate.getTime()))) {
    calRandomDate.add(Calendar.MINUTE,1);
  }
  while (calRandomDate.getTimeInMillis() - fakeInitTime < fakeDurationMs) {
    checkLogFileStatus(true,debugNameFile + dateFormat.format(calRandomDate.getTime()));
    calRandomDate.add(Calendar.MINUTE,1);
    checkLogFileStatus(false,debugNameFile + dateFormat.format(calRandomDate.getTime()));
    calRandomDate.add(Calendar.MINUTE,1);
    checkLogFileStatus(false,debugNameFile + dateFormat.format(calRandomDate.getTime()));
    calRandomDate.add(Calendar.MINUTE,1);
  }
}","private void rotation(long fakeInitTime) throws Exception {
  String DEBUG_CONFIG_FOR_TEST=""String_Node_Str"";
  DebugConfigurationFromProperties debugConfigurationFromProperties=new DebugConfigurationFromProperties(DEBUG_CONFIG_FOR_TEST);
  initializeProperties();
  initializeProvider(DEBUG_CONFIG_FOR_TEST);
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  String debugNameFile=""String_Node_Str"";
  int rotationPeriod=debugConfigurationFromProperties.getRotationInterval();
  int fakeDurationMs=60 * 60 * 1000;
  AccelerateTimeService accelerateClock=new AccelerateTimeService(fakeInitTime);
  debugFileProvider.setClock(accelerateClock);
  IDebug debugTest1MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  IDebug debugTest2MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  IDebug debugTest3MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  List<PrintLogRunnable> printLogRunnableTests=new ArrayList<PrintLogRunnable>();
  PrintLogRunnable printLogRunnableTest1=new PrintLogRunnable(debugTest1MergeToDebugMerge,fakeInitTime,fakeDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest1);
  PrintLogRunnable printLogRunnableTest2=new PrintLogRunnable(debugTest2MergeToDebugMerge,fakeInitTime,fakeDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest2);
  PrintLogRunnable printLogRunnableTest3=new PrintLogRunnable(debugTest3MergeToDebugMerge,fakeInitTime,fakeDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest3);
  List<Thread> threads=new ArrayList<Thread>();
  for (  PrintLogRunnable printLogRunnableTest : printLogRunnableTests) {
    threads.add(new Thread(printLogRunnableTest));
  }
  debugTest1MergeToDebugMerge.message(""String_Node_Str"",null);
  accelerateClock.incrementTime(1000 * 60 + 10);
  debugTest2MergeToDebugMerge.message(""String_Node_Str"",null);
  accelerateClock.incrementTime(1000 * 60 + 10);
  debugTest3MergeToDebugMerge.message(""String_Node_Str"",null);
  for (  Thread thread : threads) {
    thread.start();
  }
  for (  Thread thread : threads) {
    thread.join();
  }
  for (  PrintLogRunnable printLogRunnableTest : printLogRunnableTests) {
    if (printLogRunnableTest.ex != null)     throw printLogRunnableTest.ex;
  }
  Calendar fakeDate=Calendar.getInstance();
  fakeDate.setTimeInMillis(fakeInitTime);
  int currentPeriod=-1;
  while (fakeDate.getTimeInMillis() - fakeInitTime < fakeDurationMs) {
    if (isFileExist(debugNameFile + dateFormat.format(fakeDate.getTime()))) {
      if (currentPeriod != -1 && currentPeriod < rotationPeriod) {
        failAndPrintFolderStatusReport(""String_Node_Str"" + ""String_Node_Str"" + currentPeriod + ""String_Node_Str"");
      }
      currentPeriod=0;
    }
    currentPeriod++;
    fakeDate.add(Calendar.MINUTE,1);
  }
}"
9157,"public void run(){
  try {
    while (System.currentTimeMillis() - initTime < testDuration) {
      String dateInStringWithMs=dateFormatWithMs.format(new Date(accelerateClock.now()));
      debug.message(""String_Node_Str"" + dateInStringWithMs,null);
    }
  }
 catch (  Exception e) {
    this.ex=e;
  }
}","public void run(){
  try {
    while (accelerateClock.now() - initTime < testDuration) {
      String dateInStringWithMs=dateFormatWithMs.format(new Date(accelerateClock.now()));
      debug.message(""String_Node_Str"" + dateInStringWithMs,null);
    }
  }
 catch (  Exception e) {
    this.ex=e;
  }
}"
9158,"/** 
 * Check the file status
 * @param isCreated true if you want to check that the file exist, false for the contrary
 * @param logName   log file name
 */
protected void checkLogFileStatus(boolean isCreated,String logName){
  String fullPath=debugDirectory + File.separator + logName;
  if (isCreated != isFileExist(logName)) {
    StringBuilder bugReport=new StringBuilder();
    bugReport.append(""String_Node_Str"" + fullPath + ""String_Node_Str""+ isCreated+ ""String_Node_Str"");
    File dir=new File(debugDirectory);
    File[] files=dir.listFiles(new FileFilter(){
      @Override public boolean accept(      File pathname){
        return true;
      }
    }
);
    bugReport.append(""String_Node_Str"");
    for (    File file : files) {
      bugReport.append(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    }
    Assert.fail(bugReport.toString());
  }
}","/** 
 * Check the file status
 * @param isCreated true if you want to check that the file exist, false for the contrary
 * @param logName   log file name
 */
protected void checkLogFileStatus(boolean isCreated,String logName){
  String fullPath=debugDirectory + File.separator + logName;
  if (isCreated != isFileExist(logName)) {
    failAndPrintFolderStatusReport(""String_Node_Str"" + fullPath + ""String_Node_Str""+ isCreated+ ""String_Node_Str"");
  }
}"
9159,"/** 
 * Constructor
 * @param initTime when the time acceleration should started, in MS from epoch
 * @param factor   acceleration factor
 */
public AccelerateTimeService(long initTime,int factor){
  this.initTime=initTime;
  this.factor=factor;
  this.systemTimeAtInitialization=System.currentTimeMillis();
}","/** 
 * Constructor
 * @param initTime when the time acceleration should started, in MS from epoch
 */
public AccelerateTimeService(long initTime){
  this.clock=new AtomicLong(initTime);
}"
9160,"@Override public long now(){
  long deltaTimeFromInitTime=System.currentTimeMillis() - systemTimeAtInitialization;
  return deltaTimeFromInitTime * factor + initTime;
}","@Override public long now(){
  return incrementTime(INCR_TIME_MS);
}"
9161,"private static String getResponseLocation(SingleLogoutServiceElement endpoint){
  String location=endpoint.getResponseLocation();
  if (location == null) {
    location=endpoint.getLocation();
  }
  return location;
}","private static String getResponseLocation(SingleLogoutServiceElement endpoint){
  String location=endpoint.getResponseLocation();
  if (StringUtils.isBlank(location)) {
    location=endpoint.getLocation();
  }
  return location;
}"
9162,"@Test public void rotationInDSTDateOctober() throws Exception {
  Calendar calDSTOctober=Calendar.getInstance();
  calDSTOctober.set(Calendar.YEAR,2015);
  calDSTOctober.set(Calendar.MONTH,Calendar.OCTOBER);
  calDSTOctober.set(Calendar.DAY_OF_MONTH,26);
  calDSTOctober.set(Calendar.HOUR_OF_DAY,1);
  calDSTOctober.set(Calendar.MINUTE,58);
  calDSTOctober.set(Calendar.SECOND,0);
  calDSTOctober.set(Calendar.MILLISECOND,0);
  long fakeInitTime=calDSTOctober.getTimeInMillis();
  System.out.println(TimeZone.getDefault().getDisplayName());
  System.out.println(TimeZone.getDefault().getID());
  System.out.println(""String_Node_Str"" + dateFormat.format(calDSTOctober.getTime()) + ""String_Node_Str"");
  rotation(fakeInitTime);
}","@Test public void rotationInDSTDateOctober() throws Exception {
  Calendar calDSTOctober=Calendar.getInstance();
  calDSTOctober.set(Calendar.YEAR,2015);
  calDSTOctober.set(Calendar.MONTH,Calendar.OCTOBER);
  calDSTOctober.set(Calendar.DAY_OF_MONTH,26);
  calDSTOctober.set(Calendar.HOUR_OF_DAY,1);
  calDSTOctober.set(Calendar.MINUTE,58);
  calDSTOctober.set(Calendar.SECOND,0);
  calDSTOctober.set(Calendar.MILLISECOND,0);
  long fakeInitTime=calDSTOctober.getTimeInMillis();
  System.out.println(""String_Node_Str"" + dateFormat.format(calDSTOctober.getTime()) + ""String_Node_Str"");
  rotation(fakeInitTime);
}"
9163,"private void rotation(long fakeInitTime) throws Exception {
  String DEBUG_CONFIG_FOR_TEST=""String_Node_Str"";
  initializeProperties();
  initializeProvider(DEBUG_CONFIG_FOR_TEST);
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  String debugNameFile=""String_Node_Str"";
  long initTime=System.currentTimeMillis();
  int testDurationMs=2000;
  int factor=360;
  int fakeDurationMs=testDurationMs * factor;
  TimeService accelerateClock=new AccelerateTimeService(fakeInitTime,factor);
  debugFileProvider.setClock(accelerateClock);
  IDebug debugTest1MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  IDebug debugTest2MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  IDebug debugTest3MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  List<PrintLogRunnable> printLogRunnableTests=new ArrayList<PrintLogRunnable>();
  PrintLogRunnable printLogRunnableTest1=new PrintLogRunnable(debugTest1MergeToDebugMerge,initTime,testDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest1);
  PrintLogRunnable printLogRunnableTest2=new PrintLogRunnable(debugTest2MergeToDebugMerge,initTime,testDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest2);
  PrintLogRunnable printLogRunnableTest3=new PrintLogRunnable(debugTest3MergeToDebugMerge,initTime,testDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest3);
  List<Thread> threads=new ArrayList<Thread>();
  for (  PrintLogRunnable printLogRunnableTest : printLogRunnableTests) {
    threads.add(new Thread(printLogRunnableTest));
  }
  debugTest1MergeToDebugMerge.message(""String_Node_Str"",null);
  long currentAccelerateTimeInMin=accelerateClock.now() / (1000 * 60);
  while (accelerateClock.now() / (1000 * 60) < currentAccelerateTimeInMin) {
    Thread.sleep(100);
  }
  debugTest2MergeToDebugMerge.message(""String_Node_Str"",null);
  currentAccelerateTimeInMin=accelerateClock.now() / (1000 * 60);
  while (accelerateClock.now() / (1000 * 60) < currentAccelerateTimeInMin) {
    Thread.sleep(100);
  }
  debugTest3MergeToDebugMerge.message(""String_Node_Str"",null);
  for (  Thread thread : threads) {
    thread.start();
  }
  for (  Thread thread : threads) {
    thread.join();
  }
  for (  PrintLogRunnable printLogRunnableTest : printLogRunnableTests) {
    if (printLogRunnableTest.ex != null)     throw printLogRunnableTest.ex;
  }
  Calendar calRandomDate=Calendar.getInstance();
  calRandomDate.setTimeInMillis(fakeInitTime);
  if (!isFileExist(debugNameFile + dateFormat.format(calRandomDate.getTime()))) {
    calRandomDate.add(Calendar.MINUTE,1);
  }
  while (calRandomDate.getTimeInMillis() - fakeInitTime < fakeDurationMs) {
    checkLogFileStatus(true,debugNameFile + dateFormat.format(calRandomDate.getTime()));
    calRandomDate.add(Calendar.MINUTE,1);
    checkLogFileStatus(false,debugNameFile + dateFormat.format(calRandomDate.getTime()));
    calRandomDate.add(Calendar.MINUTE,1);
    checkLogFileStatus(false,debugNameFile + dateFormat.format(calRandomDate.getTime()));
    calRandomDate.add(Calendar.MINUTE,1);
  }
}","private void rotation(long fakeInitTime) throws Exception {
  String DEBUG_CONFIG_FOR_TEST=""String_Node_Str"";
  DebugConfigurationFromProperties debugConfigurationFromProperties=new DebugConfigurationFromProperties(DEBUG_CONFIG_FOR_TEST);
  initializeProperties();
  initializeProvider(DEBUG_CONFIG_FOR_TEST);
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  String debugNameFile=""String_Node_Str"";
  int rotationPeriod=debugConfigurationFromProperties.getRotationInterval();
  int fakeDurationMs=60 * 60 * 1000;
  AccelerateTimeService accelerateClock=new AccelerateTimeService(fakeInitTime);
  debugFileProvider.setClock(accelerateClock);
  IDebug debugTest1MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  IDebug debugTest2MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  IDebug debugTest3MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  List<PrintLogRunnable> printLogRunnableTests=new ArrayList<PrintLogRunnable>();
  PrintLogRunnable printLogRunnableTest1=new PrintLogRunnable(debugTest1MergeToDebugMerge,fakeInitTime,fakeDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest1);
  PrintLogRunnable printLogRunnableTest2=new PrintLogRunnable(debugTest2MergeToDebugMerge,fakeInitTime,fakeDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest2);
  PrintLogRunnable printLogRunnableTest3=new PrintLogRunnable(debugTest3MergeToDebugMerge,fakeInitTime,fakeDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest3);
  List<Thread> threads=new ArrayList<Thread>();
  for (  PrintLogRunnable printLogRunnableTest : printLogRunnableTests) {
    threads.add(new Thread(printLogRunnableTest));
  }
  debugTest1MergeToDebugMerge.message(""String_Node_Str"",null);
  accelerateClock.incrementTime(1000 * 60 + 10);
  debugTest2MergeToDebugMerge.message(""String_Node_Str"",null);
  accelerateClock.incrementTime(1000 * 60 + 10);
  debugTest3MergeToDebugMerge.message(""String_Node_Str"",null);
  for (  Thread thread : threads) {
    thread.start();
  }
  for (  Thread thread : threads) {
    thread.join();
  }
  for (  PrintLogRunnable printLogRunnableTest : printLogRunnableTests) {
    if (printLogRunnableTest.ex != null)     throw printLogRunnableTest.ex;
  }
  Calendar fakeDate=Calendar.getInstance();
  fakeDate.setTimeInMillis(fakeInitTime);
  int currentPeriod=-1;
  while (fakeDate.getTimeInMillis() - fakeInitTime < fakeDurationMs) {
    if (isFileExist(debugNameFile + dateFormat.format(fakeDate.getTime()))) {
      if (currentPeriod != -1 && currentPeriod < rotationPeriod) {
        failAndPrintFolderStatusReport(""String_Node_Str"" + ""String_Node_Str"" + currentPeriod + ""String_Node_Str"");
      }
      currentPeriod=0;
    }
    currentPeriod++;
    fakeDate.add(Calendar.MINUTE,1);
  }
}"
9164,"public void run(){
  try {
    while (System.currentTimeMillis() - initTime < testDuration) {
      String dateInStringWithMs=dateFormatWithMs.format(new Date(accelerateClock.now()));
      debug.message(""String_Node_Str"" + dateInStringWithMs,null);
    }
  }
 catch (  Exception e) {
    this.ex=e;
  }
}","public void run(){
  try {
    while (accelerateClock.now() - initTime < testDuration) {
      String dateInStringWithMs=dateFormatWithMs.format(new Date(accelerateClock.now()));
      debug.message(""String_Node_Str"" + dateInStringWithMs,null);
    }
  }
 catch (  Exception e) {
    this.ex=e;
  }
}"
9165,"/** 
 * Check the file status
 * @param isCreated true if you want to check that the file exist, false for the contrary
 * @param logName   log file name
 */
protected void checkLogFileStatus(boolean isCreated,String logName){
  String fullPath=debugDirectory + File.separator + logName;
  if (isCreated != isFileExist(logName)) {
    StringBuilder bugReport=new StringBuilder();
    bugReport.append(""String_Node_Str"" + fullPath + ""String_Node_Str""+ isCreated+ ""String_Node_Str"");
    File dir=new File(debugDirectory);
    File[] files=dir.listFiles(new FileFilter(){
      @Override public boolean accept(      File pathname){
        return true;
      }
    }
);
    bugReport.append(""String_Node_Str"");
    for (    File file : files) {
      bugReport.append(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    }
    Assert.fail(bugReport.toString());
  }
}","/** 
 * Check the file status
 * @param isCreated true if you want to check that the file exist, false for the contrary
 * @param logName   log file name
 */
protected void checkLogFileStatus(boolean isCreated,String logName){
  String fullPath=debugDirectory + File.separator + logName;
  if (isCreated != isFileExist(logName)) {
    failAndPrintFolderStatusReport(""String_Node_Str"" + fullPath + ""String_Node_Str""+ isCreated+ ""String_Node_Str"");
  }
}"
9166,"/** 
 * Constructor
 * @param initTime when the time acceleration should started, in MS from epoch
 * @param factor   acceleration factor
 */
public AccelerateTimeService(long initTime,int factor){
  this.initTime=initTime;
  this.factor=factor;
  this.systemTimeAtInitialization=System.currentTimeMillis();
}","/** 
 * Constructor
 * @param initTime when the time acceleration should started, in MS from epoch
 */
public AccelerateTimeService(long initTime){
  this.clock=new AtomicLong(initTime);
}"
9167,"@Override public long now(){
  long deltaTimeFromInitTime=System.currentTimeMillis() - systemTimeAtInitialization;
  return deltaTimeFromInitTime * factor + initTime;
}","@Override public long now(){
  return incrementTime(INCR_TIME_MS);
}"
9168,"@Test public void rotationInDSTDateOctober() throws Exception {
  Calendar calDSTOctober=Calendar.getInstance();
  calDSTOctober.set(Calendar.YEAR,2015);
  calDSTOctober.set(Calendar.MONTH,Calendar.OCTOBER);
  calDSTOctober.set(Calendar.DAY_OF_MONTH,26);
  calDSTOctober.set(Calendar.HOUR_OF_DAY,1);
  calDSTOctober.set(Calendar.MINUTE,58);
  calDSTOctober.set(Calendar.SECOND,0);
  calDSTOctober.set(Calendar.MILLISECOND,0);
  long fakeInitTime=calDSTOctober.getTimeInMillis();
  System.out.println(TimeZone.getDefault().getDisplayName());
  System.out.println(TimeZone.getDefault().getID());
  System.out.println(""String_Node_Str"" + dateFormat.format(calDSTOctober.getTime()) + ""String_Node_Str"");
  rotation(fakeInitTime);
}","@Test public void rotationInDSTDateOctober() throws Exception {
  Calendar calDSTOctober=Calendar.getInstance();
  calDSTOctober.set(Calendar.YEAR,2015);
  calDSTOctober.set(Calendar.MONTH,Calendar.OCTOBER);
  calDSTOctober.set(Calendar.DAY_OF_MONTH,26);
  calDSTOctober.set(Calendar.HOUR_OF_DAY,1);
  calDSTOctober.set(Calendar.MINUTE,58);
  calDSTOctober.set(Calendar.SECOND,0);
  calDSTOctober.set(Calendar.MILLISECOND,0);
  long fakeInitTime=calDSTOctober.getTimeInMillis();
  System.out.println(""String_Node_Str"" + dateFormat.format(calDSTOctober.getTime()) + ""String_Node_Str"");
  rotation(fakeInitTime);
}"
9169,"private void rotation(long fakeInitTime) throws Exception {
  String DEBUG_CONFIG_FOR_TEST=""String_Node_Str"";
  initializeProperties();
  initializeProvider(DEBUG_CONFIG_FOR_TEST);
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  String debugNameFile=""String_Node_Str"";
  long initTime=System.currentTimeMillis();
  int testDurationMs=2000;
  int factor=360;
  int fakeDurationMs=testDurationMs * factor;
  TimeService accelerateClock=new AccelerateTimeService(fakeInitTime,factor);
  debugFileProvider.setClock(accelerateClock);
  IDebug debugTest1MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  IDebug debugTest2MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  IDebug debugTest3MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  List<PrintLogRunnable> printLogRunnableTests=new ArrayList<PrintLogRunnable>();
  PrintLogRunnable printLogRunnableTest1=new PrintLogRunnable(debugTest1MergeToDebugMerge,initTime,testDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest1);
  PrintLogRunnable printLogRunnableTest2=new PrintLogRunnable(debugTest2MergeToDebugMerge,initTime,testDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest2);
  PrintLogRunnable printLogRunnableTest3=new PrintLogRunnable(debugTest3MergeToDebugMerge,initTime,testDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest3);
  List<Thread> threads=new ArrayList<Thread>();
  for (  PrintLogRunnable printLogRunnableTest : printLogRunnableTests) {
    threads.add(new Thread(printLogRunnableTest));
  }
  debugTest1MergeToDebugMerge.message(""String_Node_Str"",null);
  long currentAccelerateTimeInMin=accelerateClock.now() / (1000 * 60);
  while (accelerateClock.now() / (1000 * 60) < currentAccelerateTimeInMin) {
    Thread.sleep(100);
  }
  debugTest2MergeToDebugMerge.message(""String_Node_Str"",null);
  currentAccelerateTimeInMin=accelerateClock.now() / (1000 * 60);
  while (accelerateClock.now() / (1000 * 60) < currentAccelerateTimeInMin) {
    Thread.sleep(100);
  }
  debugTest3MergeToDebugMerge.message(""String_Node_Str"",null);
  for (  Thread thread : threads) {
    thread.start();
  }
  for (  Thread thread : threads) {
    thread.join();
  }
  for (  PrintLogRunnable printLogRunnableTest : printLogRunnableTests) {
    if (printLogRunnableTest.ex != null)     throw printLogRunnableTest.ex;
  }
  Calendar calRandomDate=Calendar.getInstance();
  calRandomDate.setTimeInMillis(fakeInitTime);
  if (!isFileExist(debugNameFile + dateFormat.format(calRandomDate.getTime()))) {
    calRandomDate.add(Calendar.MINUTE,1);
  }
  while (calRandomDate.getTimeInMillis() - fakeInitTime < fakeDurationMs) {
    checkLogFileStatus(true,debugNameFile + dateFormat.format(calRandomDate.getTime()));
    calRandomDate.add(Calendar.MINUTE,1);
    checkLogFileStatus(false,debugNameFile + dateFormat.format(calRandomDate.getTime()));
    calRandomDate.add(Calendar.MINUTE,1);
    checkLogFileStatus(false,debugNameFile + dateFormat.format(calRandomDate.getTime()));
    calRandomDate.add(Calendar.MINUTE,1);
  }
}","private void rotation(long fakeInitTime) throws Exception {
  String DEBUG_CONFIG_FOR_TEST=""String_Node_Str"";
  DebugConfigurationFromProperties debugConfigurationFromProperties=new DebugConfigurationFromProperties(DEBUG_CONFIG_FOR_TEST);
  initializeProperties();
  initializeProvider(DEBUG_CONFIG_FOR_TEST);
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  String debugNameFile=""String_Node_Str"";
  int rotationPeriod=debugConfigurationFromProperties.getRotationInterval();
  int fakeDurationMs=60 * 60 * 1000;
  AccelerateTimeService accelerateClock=new AccelerateTimeService(fakeInitTime);
  debugFileProvider.setClock(accelerateClock);
  IDebug debugTest1MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  IDebug debugTest2MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  IDebug debugTest3MergeToDebugMerge=provider.getInstance(""String_Node_Str"");
  List<PrintLogRunnable> printLogRunnableTests=new ArrayList<PrintLogRunnable>();
  PrintLogRunnable printLogRunnableTest1=new PrintLogRunnable(debugTest1MergeToDebugMerge,fakeInitTime,fakeDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest1);
  PrintLogRunnable printLogRunnableTest2=new PrintLogRunnable(debugTest2MergeToDebugMerge,fakeInitTime,fakeDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest2);
  PrintLogRunnable printLogRunnableTest3=new PrintLogRunnable(debugTest3MergeToDebugMerge,fakeInitTime,fakeDurationMs,accelerateClock);
  printLogRunnableTests.add(printLogRunnableTest3);
  List<Thread> threads=new ArrayList<Thread>();
  for (  PrintLogRunnable printLogRunnableTest : printLogRunnableTests) {
    threads.add(new Thread(printLogRunnableTest));
  }
  debugTest1MergeToDebugMerge.message(""String_Node_Str"",null);
  accelerateClock.incrementTime(1000 * 60 + 10);
  debugTest2MergeToDebugMerge.message(""String_Node_Str"",null);
  accelerateClock.incrementTime(1000 * 60 + 10);
  debugTest3MergeToDebugMerge.message(""String_Node_Str"",null);
  for (  Thread thread : threads) {
    thread.start();
  }
  for (  Thread thread : threads) {
    thread.join();
  }
  for (  PrintLogRunnable printLogRunnableTest : printLogRunnableTests) {
    if (printLogRunnableTest.ex != null)     throw printLogRunnableTest.ex;
  }
  Calendar fakeDate=Calendar.getInstance();
  fakeDate.setTimeInMillis(fakeInitTime);
  int currentPeriod=-1;
  while (fakeDate.getTimeInMillis() - fakeInitTime < fakeDurationMs) {
    if (isFileExist(debugNameFile + dateFormat.format(fakeDate.getTime()))) {
      if (currentPeriod != -1 && currentPeriod < rotationPeriod) {
        failAndPrintFolderStatusReport(""String_Node_Str"" + ""String_Node_Str"" + currentPeriod + ""String_Node_Str"");
      }
      currentPeriod=0;
    }
    currentPeriod++;
    fakeDate.add(Calendar.MINUTE,1);
  }
}"
9170,"public void run(){
  try {
    while (System.currentTimeMillis() - initTime < testDuration) {
      String dateInStringWithMs=dateFormatWithMs.format(new Date(accelerateClock.now()));
      debug.message(""String_Node_Str"" + dateInStringWithMs,null);
    }
  }
 catch (  Exception e) {
    this.ex=e;
  }
}","public void run(){
  try {
    while (accelerateClock.now() - initTime < testDuration) {
      String dateInStringWithMs=dateFormatWithMs.format(new Date(accelerateClock.now()));
      debug.message(""String_Node_Str"" + dateInStringWithMs,null);
    }
  }
 catch (  Exception e) {
    this.ex=e;
  }
}"
9171,"/** 
 * Check the file status
 * @param isCreated true if you want to check that the file exist, false for the contrary
 * @param logName   log file name
 */
protected void checkLogFileStatus(boolean isCreated,String logName){
  String fullPath=debugDirectory + File.separator + logName;
  if (isCreated != isFileExist(logName)) {
    StringBuilder bugReport=new StringBuilder();
    bugReport.append(""String_Node_Str"" + fullPath + ""String_Node_Str""+ isCreated+ ""String_Node_Str"");
    File dir=new File(debugDirectory);
    File[] files=dir.listFiles(new FileFilter(){
      @Override public boolean accept(      File pathname){
        return true;
      }
    }
);
    bugReport.append(""String_Node_Str"");
    for (    File file : files) {
      bugReport.append(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    }
    Assert.fail(bugReport.toString());
  }
}","/** 
 * Check the file status
 * @param isCreated true if you want to check that the file exist, false for the contrary
 * @param logName   log file name
 */
protected void checkLogFileStatus(boolean isCreated,String logName){
  String fullPath=debugDirectory + File.separator + logName;
  if (isCreated != isFileExist(logName)) {
    failAndPrintFolderStatusReport(""String_Node_Str"" + fullPath + ""String_Node_Str""+ isCreated+ ""String_Node_Str"");
  }
}"
9172,"/** 
 * Constructor
 * @param initTime when the time acceleration should started, in MS from epoch
 * @param factor   acceleration factor
 */
public AccelerateTimeService(long initTime,int factor){
  this.initTime=initTime;
  this.factor=factor;
  this.systemTimeAtInitialization=System.currentTimeMillis();
}","/** 
 * Constructor
 * @param initTime when the time acceleration should started, in MS from epoch
 */
public AccelerateTimeService(long initTime){
  this.clock=new AtomicLong(initTime);
}"
9173,"@Override public long now(){
  long deltaTimeFromInitTime=System.currentTimeMillis() - systemTimeAtInitialization;
  return deltaTimeFromInitTime * factor + initTime;
}","@Override public long now(){
  return incrementTime(INCR_TIME_MS);
}"
9174,"private static String getResponseLocation(SingleLogoutServiceElement endpoint){
  String location=endpoint.getResponseLocation();
  if (location == null) {
    location=endpoint.getLocation();
  }
  return location;
}","private static String getResponseLocation(SingleLogoutServiceElement endpoint){
  String location=endpoint.getResponseLocation();
  if (StringUtils.isBlank(location)) {
    location=endpoint.getLocation();
  }
  return location;
}"
9175,"private static String getResponseLocation(SingleLogoutServiceElement endpoint){
  String location=endpoint.getResponseLocation();
  if (location == null) {
    location=endpoint.getLocation();
  }
  return location;
}","private static String getResponseLocation(SingleLogoutServiceElement endpoint){
  String location=endpoint.getResponseLocation();
  if (StringUtils.isBlank(location)) {
    location=endpoint.getLocation();
  }
  return location;
}"
9176,"/** 
 * Implements methods in <code>com.sun.identity.sm.ServiceListener</code>.
 * @param serviceName
 * @param version
 * @param orgName
 * @param groupName
 * @param serviceComponent
 * @param type
 */
public void organizationConfigChanged(String serviceName,String version,String orgName,String groupName,String serviceComponent,int type){
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + serviceName + ""String_Node_Str""+ version+ ""String_Node_Str""+ orgName+ ""String_Node_Str""+ groupName+ ""String_Node_Str""+ serviceComponent+ ""String_Node_Str""+ type);
  }
synchronized (authLevelMap) {
    authLevelMap.remove(orgName);
  }
  if (AuthD.revisionNumber < ISAuthConstants.AUTHSERVICE_REVISION7_0 && serviceName.equals(CORE_AUTH)) {
synchronized (supportedModulesMap) {
      supportedModulesMap.remove(orgName);
    }
  }
  AMAuthenticationManager.buildModuleInstanceForService(orgName,serviceName);
  updateAuthConfiguration(serviceName,orgName,serviceComponent);
}","/** 
 * Implements methods in <code>com.sun.identity.sm.ServiceListener</code>.
 * @param serviceName
 * @param version
 * @param orgName
 * @param groupName
 * @param serviceComponent
 * @param type
 */
public void organizationConfigChanged(String serviceName,String version,String orgName,String groupName,String serviceComponent,int type){
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + serviceName + ""String_Node_Str""+ version+ ""String_Node_Str""+ orgName+ ""String_Node_Str""+ groupName+ ""String_Node_Str""+ serviceComponent+ ""String_Node_Str""+ type);
  }
synchronized (authLevelMap) {
    authLevelMap.remove(orgName);
  }
  if (AuthD.revisionNumber < ISAuthConstants.AUTHSERVICE_REVISION7_0 && serviceName.equals(CORE_AUTH)) {
synchronized (supportedModulesMap) {
      supportedModulesMap.remove(orgName);
    }
  }
  AMAuthenticationManager.updateModuleInstanceTable(orgName,serviceName);
  updateAuthConfiguration(serviceName,orgName,serviceComponent);
}"
9177,"/** 
 * Constructs an instance of <code>AMAuthenticationManager</code> for the specified realm to manage the authentication module instances available to this realm.
 * @param token Single sign on token of the user identity on whose behalf the operations are performed.
 * @param org The realm in which the module instance management is performed.
 * @throws AMConfigurationException if Service Management related error occurs.
 */
public AMAuthenticationManager(SSOToken token,String org) throws AMConfigurationException {
  try {
    SMSEntry.validateToken(token);
    this.token=token;
    this.realm=com.sun.identity.sm.DNMapper.orgNameToDN(org);
    if ((this.realm != null) && ((this.realm).length() != 0)) {
      this.realm=(this.realm).toLowerCase();
    }
    orgServiceConfig=getOrgServiceConfig();
    if (orgServiceConfig == null) {
      throw new AMConfigurationException(BUNDLE_NAME,""String_Node_Str"",new Object[]{realm});
    }
synchronized (AMAuthenticationManager.class) {
      if (MODULE_INSTANCE_TABLE.get(realm) == null) {
        buildModuleInstanceTable(token,realm);
      }
    }
  }
 catch (  SMSException e) {
    throw new AMConfigurationException(e);
  }
catch (  Exception ee) {
    String installTime=SystemProperties.get(AdminTokenAction.AMADMIN_MODE);
    if ((installTime != null) && installTime.equalsIgnoreCase(""String_Node_Str"")) {
      DEBUG.error(""String_Node_Str"",ee);
    }
  }
}","/** 
 * Constructs an instance of <code>AMAuthenticationManager</code> for the specified realm to manage the authentication module instances available to this realm.
 * @param token Single sign on token of the user identity on whose behalf the operations are performed.
 * @param org The realm in which the module instance management is performed.
 * @throws AMConfigurationException if Service Management related error occurs.
 */
public AMAuthenticationManager(SSOToken token,String org) throws AMConfigurationException {
  try {
    SMSEntry.validateToken(token);
    this.token=token;
    this.realm=com.sun.identity.sm.DNMapper.orgNameToDN(org);
    orgServiceConfig=getOrgServiceConfig();
    if (orgServiceConfig == null) {
      throw new AMConfigurationException(BUNDLE_NAME,""String_Node_Str"",new Object[]{realm});
    }
synchronized (AMAuthenticationManager.class) {
      if (!MODULE_INSTANCE_TABLE.containsKey(realm)) {
        buildModuleInstanceTable(token,realm);
      }
    }
  }
 catch (  SMSException e) {
    throw new AMConfigurationException(e);
  }
catch (  Exception ee) {
    String installTime=SystemProperties.get(AdminTokenAction.AMADMIN_MODE);
    if ((installTime != null) && installTime.equalsIgnoreCase(""String_Node_Str"")) {
      DEBUG.error(""String_Node_Str"",ee);
    }
  }
}"
9178,"/** 
 * Updates the static module instance table for the specified service in the realm.
 * @param realm The realm in which the operation is processed.
 * @param serviceName the service for which the table is built.
 */
public static synchronized void buildModuleInstanceForService(String realm,String serviceName){
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + MODULE_INSTANCE_TABLE + ""String_Node_Str""+ realm+ ""String_Node_Str""+ serviceName);
  }
  try {
    String moduleName=getModuleName(serviceName);
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"" + moduleName);
    }
    if ((moduleName != null) && (moduleName.length() != 0)) {
      ServiceConfigManager scm=new ServiceConfigManager(serviceName,getAdminToken());
      ServiceConfig config=scm.getOrganizationConfig(realm,null);
      if (config == null) {
        if (DEBUG.messageEnabled()) {
          DEBUG.message(""String_Node_Str"" + ""String_Node_Str"" + serviceName + ""String_Node_Str""+ realm);
        }
      }
      realm=com.sun.identity.sm.DNMapper.orgNameToDN(realm);
synchronized (MODULE_INSTANCE_TABLE) {
        Map<String,Set<String>> moduleMap=MODULE_INSTANCE_TABLE.remove(realm);
        if (moduleMap != null) {
          Map<String,Set<String>> newMap=new HashMap<String,Set<String>>(moduleMap);
          newMap.remove(moduleName);
          moduleMap=newMap;
        }
        Set<String> instanceSet=new HashSet<String>();
        Map<String,Set<String>> defaultAttrs=null;
        if (config != null) {
          defaultAttrs=config.getAttributesWithoutDefaults();
        }
        if (defaultAttrs != null && !defaultAttrs.isEmpty()) {
          instanceSet.add(moduleName);
        }
        Set<String> instances=null;
        if (config != null) {
          instances=config.getSubConfigNames();
        }
        if (instances != null) {
          instanceSet.addAll(instances);
        }
        if (!instanceSet.isEmpty()) {
          if (moduleMap == null) {
            moduleMap=new HashMap<String,Set<String>>();
          }
          moduleMap.put(moduleName,instanceSet);
        }
        if (moduleMap != null && !moduleMap.isEmpty()) {
          MODULE_INSTANCE_TABLE.put(realm,moduleMap);
        }
      }
    }
  }
 catch (  Exception e) {
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"",e);
    }
  }
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + MODULE_INSTANCE_TABLE);
  }
}","/** 
 * Updates the static module instance table for the specified service in the realm.
 * @param realm The realm in which the operation is processed.
 * @param serviceName the service for which the table is built.
 */
private static synchronized void buildModuleInstanceForService(String realm,String serviceName){
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + MODULE_INSTANCE_TABLE + ""String_Node_Str""+ realm+ ""String_Node_Str""+ serviceName);
  }
  try {
    String moduleName=getModuleName(serviceName);
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"" + moduleName);
    }
    if ((moduleName != null) && (moduleName.length() != 0)) {
      ServiceConfigManager scm=new ServiceConfigManager(serviceName,getAdminToken());
      ServiceConfig config=scm.getOrganizationConfig(realm,null);
      if (config == null) {
        if (DEBUG.messageEnabled()) {
          DEBUG.message(""String_Node_Str"" + ""String_Node_Str"" + serviceName + ""String_Node_Str""+ realm);
        }
      }
      realm=com.sun.identity.sm.DNMapper.orgNameToDN(realm);
synchronized (MODULE_INSTANCE_TABLE) {
        Map<String,Set<String>> moduleMap=MODULE_INSTANCE_TABLE.remove(realm);
        if (moduleMap != null) {
          Map<String,Set<String>> newMap=new HashMap<String,Set<String>>(moduleMap);
          newMap.remove(moduleName);
          moduleMap=newMap;
        }
        Set<String> instanceSet=new HashSet<String>();
        Map<String,Set<String>> defaultAttrs=null;
        if (config != null) {
          defaultAttrs=config.getAttributesWithoutDefaults();
        }
        if (defaultAttrs != null && !defaultAttrs.isEmpty()) {
          instanceSet.add(moduleName);
        }
        Set<String> instances=null;
        if (config != null) {
          instances=config.getSubConfigNames();
        }
        if (instances != null) {
          instanceSet.addAll(instances);
        }
        if (!instanceSet.isEmpty()) {
          if (moduleMap == null) {
            moduleMap=new HashMap<String,Set<String>>();
          }
          moduleMap.put(moduleName,instanceSet);
        }
        if (moduleMap != null && !moduleMap.isEmpty()) {
          MODULE_INSTANCE_TABLE.put(realm,moduleMap);
        }
      }
    }
  }
 catch (  Exception e) {
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"",e);
    }
  }
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + MODULE_INSTANCE_TABLE);
  }
}"
9179,"/** 
 * Implements methods in <code>com.sun.identity.sm.ServiceListener</code>.
 * @param serviceName
 * @param version
 * @param orgName
 * @param groupName
 * @param serviceComponent
 * @param type
 */
public void organizationConfigChanged(String serviceName,String version,String orgName,String groupName,String serviceComponent,int type){
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + serviceName + ""String_Node_Str""+ version+ ""String_Node_Str""+ orgName+ ""String_Node_Str""+ groupName+ ""String_Node_Str""+ serviceComponent+ ""String_Node_Str""+ type);
  }
synchronized (authLevelMap) {
    authLevelMap.remove(orgName);
  }
  if (AuthD.revisionNumber < ISAuthConstants.AUTHSERVICE_REVISION7_0 && serviceName.equals(CORE_AUTH)) {
synchronized (supportedModulesMap) {
      supportedModulesMap.remove(orgName);
    }
  }
  AMAuthenticationManager.buildModuleInstanceForService(orgName,serviceName);
  updateAuthConfiguration(serviceName,orgName,serviceComponent);
}","/** 
 * Implements methods in <code>com.sun.identity.sm.ServiceListener</code>.
 * @param serviceName
 * @param version
 * @param orgName
 * @param groupName
 * @param serviceComponent
 * @param type
 */
public void organizationConfigChanged(String serviceName,String version,String orgName,String groupName,String serviceComponent,int type){
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + serviceName + ""String_Node_Str""+ version+ ""String_Node_Str""+ orgName+ ""String_Node_Str""+ groupName+ ""String_Node_Str""+ serviceComponent+ ""String_Node_Str""+ type);
  }
synchronized (authLevelMap) {
    authLevelMap.remove(orgName);
  }
  if (AuthD.revisionNumber < ISAuthConstants.AUTHSERVICE_REVISION7_0 && serviceName.equals(CORE_AUTH)) {
synchronized (supportedModulesMap) {
      supportedModulesMap.remove(orgName);
    }
  }
  AMAuthenticationManager.updateModuleInstanceTable(orgName,serviceName);
  updateAuthConfiguration(serviceName,orgName,serviceComponent);
}"
9180,"/** 
 * Constructs an instance of <code>AMAuthenticationManager</code> for the specified realm to manage the authentication module instances available to this realm.
 * @param token Single sign on token of the user identity on whose behalf the operations are performed.
 * @param org The realm in which the module instance management is performed.
 * @throws AMConfigurationException if Service Management related error occurs.
 */
public AMAuthenticationManager(SSOToken token,String org) throws AMConfigurationException {
  try {
    SMSEntry.validateToken(token);
    this.token=token;
    this.realm=com.sun.identity.sm.DNMapper.orgNameToDN(org);
    if ((this.realm != null) && ((this.realm).length() != 0)) {
      this.realm=(this.realm).toLowerCase();
    }
    orgServiceConfig=getOrgServiceConfig();
    if (orgServiceConfig == null) {
      throw new AMConfigurationException(BUNDLE_NAME,""String_Node_Str"",new Object[]{realm});
    }
synchronized (AMAuthenticationManager.class) {
      if (MODULE_INSTANCE_TABLE.get(realm) == null) {
        buildModuleInstanceTable(token,realm);
      }
    }
  }
 catch (  SMSException e) {
    throw new AMConfigurationException(e);
  }
catch (  Exception ee) {
    String installTime=SystemProperties.get(AdminTokenAction.AMADMIN_MODE);
    if ((installTime != null) && installTime.equalsIgnoreCase(""String_Node_Str"")) {
      DEBUG.error(""String_Node_Str"",ee);
    }
  }
}","/** 
 * Constructs an instance of <code>AMAuthenticationManager</code> for the specified realm to manage the authentication module instances available to this realm.
 * @param token Single sign on token of the user identity on whose behalf the operations are performed.
 * @param org The realm in which the module instance management is performed.
 * @throws AMConfigurationException if Service Management related error occurs.
 */
public AMAuthenticationManager(SSOToken token,String org) throws AMConfigurationException {
  try {
    SMSEntry.validateToken(token);
    this.token=token;
    this.realm=com.sun.identity.sm.DNMapper.orgNameToDN(org);
    orgServiceConfig=getOrgServiceConfig();
    if (orgServiceConfig == null) {
      throw new AMConfigurationException(BUNDLE_NAME,""String_Node_Str"",new Object[]{realm});
    }
synchronized (AMAuthenticationManager.class) {
      if (!MODULE_INSTANCE_TABLE.containsKey(realm)) {
        buildModuleInstanceTable(token,realm);
      }
    }
  }
 catch (  SMSException e) {
    throw new AMConfigurationException(e);
  }
catch (  Exception ee) {
    String installTime=SystemProperties.get(AdminTokenAction.AMADMIN_MODE);
    if ((installTime != null) && installTime.equalsIgnoreCase(""String_Node_Str"")) {
      DEBUG.error(""String_Node_Str"",ee);
    }
  }
}"
9181,"/** 
 * Updates the static module instance table for the specified service in the realm.
 * @param realm The realm in which the operation is processed.
 * @param serviceName the service for which the table is built.
 */
public static synchronized void buildModuleInstanceForService(String realm,String serviceName){
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + MODULE_INSTANCE_TABLE + ""String_Node_Str""+ realm+ ""String_Node_Str""+ serviceName);
  }
  try {
    String moduleName=getModuleName(serviceName);
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"" + moduleName);
    }
    if ((moduleName != null) && (moduleName.length() != 0)) {
      ServiceConfigManager scm=new ServiceConfigManager(serviceName,getAdminToken());
      ServiceConfig config=scm.getOrganizationConfig(realm,null);
      if (config == null) {
        if (DEBUG.messageEnabled()) {
          DEBUG.message(""String_Node_Str"" + ""String_Node_Str"" + serviceName + ""String_Node_Str""+ realm);
        }
      }
      realm=com.sun.identity.sm.DNMapper.orgNameToDN(realm);
synchronized (MODULE_INSTANCE_TABLE) {
        Map<String,Set<String>> moduleMap=MODULE_INSTANCE_TABLE.remove(realm);
        if (moduleMap != null) {
          Map<String,Set<String>> newMap=new HashMap<String,Set<String>>(moduleMap);
          newMap.remove(moduleName);
          moduleMap=newMap;
        }
        Set<String> instanceSet=new HashSet<String>();
        Map<String,Set<String>> defaultAttrs=null;
        if (config != null) {
          defaultAttrs=config.getAttributesWithoutDefaults();
        }
        if (defaultAttrs != null && !defaultAttrs.isEmpty()) {
          instanceSet.add(moduleName);
        }
        Set<String> instances=null;
        if (config != null) {
          instances=config.getSubConfigNames();
        }
        if (instances != null) {
          instanceSet.addAll(instances);
        }
        if (!instanceSet.isEmpty()) {
          if (moduleMap == null) {
            moduleMap=new HashMap<String,Set<String>>();
          }
          moduleMap.put(moduleName,instanceSet);
        }
        if (moduleMap != null && !moduleMap.isEmpty()) {
          MODULE_INSTANCE_TABLE.put(realm,moduleMap);
        }
      }
    }
  }
 catch (  Exception e) {
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"",e);
    }
  }
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + MODULE_INSTANCE_TABLE);
  }
}","/** 
 * Updates the static module instance table for the specified service in the realm.
 * @param realm The realm in which the operation is processed.
 * @param serviceName the service for which the table is built.
 */
private static synchronized void buildModuleInstanceForService(String realm,String serviceName){
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + MODULE_INSTANCE_TABLE + ""String_Node_Str""+ realm+ ""String_Node_Str""+ serviceName);
  }
  try {
    String moduleName=getModuleName(serviceName);
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"" + moduleName);
    }
    if ((moduleName != null) && (moduleName.length() != 0)) {
      ServiceConfigManager scm=new ServiceConfigManager(serviceName,getAdminToken());
      ServiceConfig config=scm.getOrganizationConfig(realm,null);
      if (config == null) {
        if (DEBUG.messageEnabled()) {
          DEBUG.message(""String_Node_Str"" + ""String_Node_Str"" + serviceName + ""String_Node_Str""+ realm);
        }
      }
      realm=com.sun.identity.sm.DNMapper.orgNameToDN(realm);
synchronized (MODULE_INSTANCE_TABLE) {
        Map<String,Set<String>> moduleMap=MODULE_INSTANCE_TABLE.remove(realm);
        if (moduleMap != null) {
          Map<String,Set<String>> newMap=new HashMap<String,Set<String>>(moduleMap);
          newMap.remove(moduleName);
          moduleMap=newMap;
        }
        Set<String> instanceSet=new HashSet<String>();
        Map<String,Set<String>> defaultAttrs=null;
        if (config != null) {
          defaultAttrs=config.getAttributesWithoutDefaults();
        }
        if (defaultAttrs != null && !defaultAttrs.isEmpty()) {
          instanceSet.add(moduleName);
        }
        Set<String> instances=null;
        if (config != null) {
          instances=config.getSubConfigNames();
        }
        if (instances != null) {
          instanceSet.addAll(instances);
        }
        if (!instanceSet.isEmpty()) {
          if (moduleMap == null) {
            moduleMap=new HashMap<String,Set<String>>();
          }
          moduleMap.put(moduleName,instanceSet);
        }
        if (moduleMap != null && !moduleMap.isEmpty()) {
          MODULE_INSTANCE_TABLE.put(realm,moduleMap);
        }
      }
    }
  }
 catch (  Exception e) {
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"",e);
    }
  }
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + MODULE_INSTANCE_TABLE);
  }
}"
9182,"/** 
 * Implements methods in <code>com.sun.identity.sm.ServiceListener</code>.
 * @param serviceName
 * @param version
 * @param orgName
 * @param groupName
 * @param serviceComponent
 * @param type
 */
public void organizationConfigChanged(String serviceName,String version,String orgName,String groupName,String serviceComponent,int type){
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + serviceName + ""String_Node_Str""+ version+ ""String_Node_Str""+ orgName+ ""String_Node_Str""+ groupName+ ""String_Node_Str""+ serviceComponent+ ""String_Node_Str""+ type);
  }
synchronized (authLevelMap) {
    authLevelMap.remove(orgName);
  }
  if (AuthD.revisionNumber < ISAuthConstants.AUTHSERVICE_REVISION7_0 && serviceName.equals(CORE_AUTH)) {
synchronized (supportedModulesMap) {
      supportedModulesMap.remove(orgName);
    }
  }
  AMAuthenticationManager.buildModuleInstanceForService(orgName,serviceName);
  updateAuthConfiguration(serviceName,orgName,serviceComponent);
}","/** 
 * Implements methods in <code>com.sun.identity.sm.ServiceListener</code>.
 * @param serviceName
 * @param version
 * @param orgName
 * @param groupName
 * @param serviceComponent
 * @param type
 */
public void organizationConfigChanged(String serviceName,String version,String orgName,String groupName,String serviceComponent,int type){
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + serviceName + ""String_Node_Str""+ version+ ""String_Node_Str""+ orgName+ ""String_Node_Str""+ groupName+ ""String_Node_Str""+ serviceComponent+ ""String_Node_Str""+ type);
  }
synchronized (authLevelMap) {
    authLevelMap.remove(orgName);
  }
  if (AuthD.revisionNumber < ISAuthConstants.AUTHSERVICE_REVISION7_0 && serviceName.equals(CORE_AUTH)) {
synchronized (supportedModulesMap) {
      supportedModulesMap.remove(orgName);
    }
  }
  AMAuthenticationManager.updateModuleInstanceTable(orgName,serviceName);
  updateAuthConfiguration(serviceName,orgName,serviceComponent);
}"
9183,"/** 
 * Constructs an instance of <code>AMAuthenticationManager</code> for the specified realm to manage the authentication module instances available to this realm.
 * @param token Single sign on token of the user identity on whose behalf the operations are performed.
 * @param org The realm in which the module instance management is performed.
 * @throws AMConfigurationException if Service Management related error occurs.
 */
public AMAuthenticationManager(SSOToken token,String org) throws AMConfigurationException {
  try {
    SMSEntry.validateToken(token);
    this.token=token;
    this.realm=com.sun.identity.sm.DNMapper.orgNameToDN(org);
    if ((this.realm != null) && ((this.realm).length() != 0)) {
      this.realm=(this.realm).toLowerCase();
    }
    orgServiceConfig=getOrgServiceConfig();
    if (orgServiceConfig == null) {
      throw new AMConfigurationException(BUNDLE_NAME,""String_Node_Str"",new Object[]{realm});
    }
synchronized (AMAuthenticationManager.class) {
      if (MODULE_INSTANCE_TABLE.get(realm) == null) {
        buildModuleInstanceTable(token,realm);
      }
    }
  }
 catch (  SMSException e) {
    throw new AMConfigurationException(e);
  }
catch (  Exception ee) {
    String installTime=SystemProperties.get(AdminTokenAction.AMADMIN_MODE);
    if ((installTime != null) && installTime.equalsIgnoreCase(""String_Node_Str"")) {
      DEBUG.error(""String_Node_Str"",ee);
    }
  }
}","/** 
 * Constructs an instance of <code>AMAuthenticationManager</code> for the specified realm to manage the authentication module instances available to this realm.
 * @param token Single sign on token of the user identity on whose behalf the operations are performed.
 * @param org The realm in which the module instance management is performed.
 * @throws AMConfigurationException if Service Management related error occurs.
 */
public AMAuthenticationManager(SSOToken token,String org) throws AMConfigurationException {
  try {
    SMSEntry.validateToken(token);
    this.token=token;
    this.realm=com.sun.identity.sm.DNMapper.orgNameToDN(org);
    orgServiceConfig=getOrgServiceConfig();
    if (orgServiceConfig == null) {
      throw new AMConfigurationException(BUNDLE_NAME,""String_Node_Str"",new Object[]{realm});
    }
synchronized (AMAuthenticationManager.class) {
      if (!MODULE_INSTANCE_TABLE.containsKey(realm)) {
        buildModuleInstanceTable(token,realm);
      }
    }
  }
 catch (  SMSException e) {
    throw new AMConfigurationException(e);
  }
catch (  Exception ee) {
    String installTime=SystemProperties.get(AdminTokenAction.AMADMIN_MODE);
    if ((installTime != null) && installTime.equalsIgnoreCase(""String_Node_Str"")) {
      DEBUG.error(""String_Node_Str"",ee);
    }
  }
}"
9184,"/** 
 * Updates the static module instance table for the specified service in the realm.
 * @param realm The realm in which the operation is processed.
 * @param serviceName the service for which the table is built.
 */
public static synchronized void buildModuleInstanceForService(String realm,String serviceName){
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + MODULE_INSTANCE_TABLE + ""String_Node_Str""+ realm+ ""String_Node_Str""+ serviceName);
  }
  try {
    String moduleName=getModuleName(serviceName);
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"" + moduleName);
    }
    if ((moduleName != null) && (moduleName.length() != 0)) {
      ServiceConfigManager scm=new ServiceConfigManager(serviceName,getAdminToken());
      ServiceConfig config=scm.getOrganizationConfig(realm,null);
      if (config == null) {
        if (DEBUG.messageEnabled()) {
          DEBUG.message(""String_Node_Str"" + ""String_Node_Str"" + serviceName + ""String_Node_Str""+ realm);
        }
      }
      realm=com.sun.identity.sm.DNMapper.orgNameToDN(realm);
synchronized (MODULE_INSTANCE_TABLE) {
        Map<String,Set<String>> moduleMap=MODULE_INSTANCE_TABLE.remove(realm);
        if (moduleMap != null) {
          Map<String,Set<String>> newMap=new HashMap<String,Set<String>>(moduleMap);
          newMap.remove(moduleName);
          moduleMap=newMap;
        }
        Set<String> instanceSet=new HashSet<String>();
        Map<String,Set<String>> defaultAttrs=null;
        if (config != null) {
          defaultAttrs=config.getAttributesWithoutDefaults();
        }
        if (defaultAttrs != null && !defaultAttrs.isEmpty()) {
          instanceSet.add(moduleName);
        }
        Set<String> instances=null;
        if (config != null) {
          instances=config.getSubConfigNames();
        }
        if (instances != null) {
          instanceSet.addAll(instances);
        }
        if (!instanceSet.isEmpty()) {
          if (moduleMap == null) {
            moduleMap=new HashMap<String,Set<String>>();
          }
          moduleMap.put(moduleName,instanceSet);
        }
        if (moduleMap != null && !moduleMap.isEmpty()) {
          MODULE_INSTANCE_TABLE.put(realm,moduleMap);
        }
      }
    }
  }
 catch (  Exception e) {
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"",e);
    }
  }
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + MODULE_INSTANCE_TABLE);
  }
}","/** 
 * Updates the static module instance table for the specified service in the realm.
 * @param realm The realm in which the operation is processed.
 * @param serviceName the service for which the table is built.
 */
private static synchronized void buildModuleInstanceForService(String realm,String serviceName){
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + MODULE_INSTANCE_TABLE + ""String_Node_Str""+ realm+ ""String_Node_Str""+ serviceName);
  }
  try {
    String moduleName=getModuleName(serviceName);
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"" + moduleName);
    }
    if ((moduleName != null) && (moduleName.length() != 0)) {
      ServiceConfigManager scm=new ServiceConfigManager(serviceName,getAdminToken());
      ServiceConfig config=scm.getOrganizationConfig(realm,null);
      if (config == null) {
        if (DEBUG.messageEnabled()) {
          DEBUG.message(""String_Node_Str"" + ""String_Node_Str"" + serviceName + ""String_Node_Str""+ realm);
        }
      }
      realm=com.sun.identity.sm.DNMapper.orgNameToDN(realm);
synchronized (MODULE_INSTANCE_TABLE) {
        Map<String,Set<String>> moduleMap=MODULE_INSTANCE_TABLE.remove(realm);
        if (moduleMap != null) {
          Map<String,Set<String>> newMap=new HashMap<String,Set<String>>(moduleMap);
          newMap.remove(moduleName);
          moduleMap=newMap;
        }
        Set<String> instanceSet=new HashSet<String>();
        Map<String,Set<String>> defaultAttrs=null;
        if (config != null) {
          defaultAttrs=config.getAttributesWithoutDefaults();
        }
        if (defaultAttrs != null && !defaultAttrs.isEmpty()) {
          instanceSet.add(moduleName);
        }
        Set<String> instances=null;
        if (config != null) {
          instances=config.getSubConfigNames();
        }
        if (instances != null) {
          instanceSet.addAll(instances);
        }
        if (!instanceSet.isEmpty()) {
          if (moduleMap == null) {
            moduleMap=new HashMap<String,Set<String>>();
          }
          moduleMap.put(moduleName,instanceSet);
        }
        if (moduleMap != null && !moduleMap.isEmpty()) {
          MODULE_INSTANCE_TABLE.put(realm,moduleMap);
        }
      }
    }
  }
 catch (  Exception e) {
    if (DEBUG.messageEnabled()) {
      DEBUG.message(""String_Node_Str"",e);
    }
  }
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + MODULE_INSTANCE_TABLE);
  }
}"
9185,"/** 
 * Convert from a Token using the serialised JSON blob to generate the JsonValue.
 * @param token Token to be converted back to its original format.
 * @return Non null JsonValue.
 * @throws IllegalArgumentException If the object wrapped inside the Tokenwas not an instance of a Map.
 */
public JsonValue fromToken(Token token){
  if (token == null) {
    return null;
  }
  String data=blobUtils.getBlobAsString(token);
  JsonValue r;
  try {
    r=new JsonValue(serialisation.deserialise(data,Map.class));
    Set<String> keys=new HashSet<String>(r.keys());
    for (    String key : keys) {
      List<String> x=r.get(key).asList(String.class);
      Set<String> set=new HashSet<String>(x);
      r.remove(key);
      r.add(key,set);
    }
  }
 catch (  RuntimeException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return r;
}","/** 
 * Convert from a Token using the serialised JSON blob to generate the JsonValue.
 * @param token Token to be converted back to its original format.
 * @return Non null JsonValue.
 * @throws IllegalArgumentException If the object wrapped inside the Tokenwas not an instance of a Map.
 */
public JsonValue fromToken(Token token){
  if (token == null) {
    return null;
  }
  String data=blobUtils.getBlobAsString(token);
  if (data == null) {
    return null;
  }
  JsonValue r;
  try {
    r=new JsonValue(serialisation.deserialise(data,Map.class));
    Set<String> keys=new HashSet<String>(r.keys());
    for (    String key : keys) {
      List<String> x=r.get(key).asList(String.class);
      Set<String> set=new HashSet<String>(x);
      r.remove(key);
      r.add(key,set);
    }
  }
 catch (  IllegalStateException e) {
    return null;
  }
  return r;
}"
9186,"/** 
 * Get the BaseURLProvider for a realm.
 * @param realm The realm.
 * @return The BaseURLProvider.
 */
public BaseURLProvider get(String realm){
  String realmDN=DNMapper.orgNameToDN(realm);
  BaseURLProvider cached=providers.get(realmDN);
  if (cached != null) {
    return cached;
  }
  return create(realmDN);
}","/** 
 * Get the BaseURLProvider for a realm.
 * @param request The Http Servlet Request.
 * @param realm The realm.
 * @return The BaseURLProvider.
 */
public BaseURLProvider get(HttpServletRequest request,String realm){
  String realmDN=DNMapper.orgNameToDN(realm);
  BaseURLProvider cached=providers.get(realmDN);
  if (cached != null) {
    return cached;
  }
  return create(request,realmDN);
}"
9187,"private synchronized BaseURLProvider create(String realmDN){
  if (!providers.containsKey(realmDN)) {
    debug.message(""String_Node_Str"",realmDN);
    OpenAMSettingsImpl settings=new OpenAMSettingsImpl(SERVICE_NAME,SERVICE_VERSION);
    try {
      BaseURLProvider provider;
      if (settings.hasConfig(realmDN)) {
        ProviderType providerType=ProviderType.valueOf(settings.getStringSetting(realmDN,PROVIDER_TYPE));
        provider=providerType.getProvider();
        provider.init(settings,realmDN);
        provider.setContextPath(settings.getStringSetting(realmDN,CONTEXT_PATH));
      }
 else {
        provider=new RequestValuesBaseURLProvider();
      }
      providers.put(realmDN,provider);
    }
 catch (    SMSException e) {
      debug.error(""String_Node_Str"",realmDN,e);
      throw new IllegalStateException(e);
    }
catch (    SSOException e) {
      debug.error(""String_Node_Str"",realmDN,e);
      throw new IllegalStateException(e);
    }
  }
  return providers.get(realmDN);
}","private synchronized BaseURLProvider create(HttpServletRequest request,String realmDN){
  if (!providers.containsKey(realmDN)) {
    debug.message(""String_Node_Str"",realmDN);
    OpenAMSettingsImpl settings=new OpenAMSettingsImpl(SERVICE_NAME,SERVICE_VERSION);
    try {
      BaseURLProvider provider;
      if (settings.hasConfig(realmDN)) {
        ProviderType providerType=ProviderType.valueOf(settings.getStringSetting(realmDN,PROVIDER_TYPE));
        provider=providerType.getProvider();
        provider.init(settings,realmDN);
        provider.setContextPath(settings.getStringSetting(realmDN,CONTEXT_PATH));
      }
 else {
        provider=new RequestValuesBaseURLProvider();
        provider.setContextPath(request.getContextPath());
      }
      providers.put(realmDN,provider);
    }
 catch (    SMSException e) {
      debug.error(""String_Node_Str"",realmDN,e);
      throw new IllegalStateException(e);
    }
catch (    SSOException e) {
      debug.error(""String_Node_Str"",realmDN,e);
      throw new IllegalStateException(e);
    }
  }
  return providers.get(realmDN);
}"
9188,"/** 
 * <p>Creates or updates a resource set description.</p> <p>If the request contains a If-Match header an update is performed, otherwise a create is performed.</p> <p>An update will replace the current description of the resource set with the contents of the request body.</p>
 * @param entity The new resource set description.
 * @return A JSON object containing the authorization server's unique id for the resource set and, optionally,a policy uri.
 * @throws NotFoundException If the requested resource set description does not exist.
 * @throws ServerException When an error occurs during creating or updating.
 * @throws BadRequestException If the request JSON is invalid.
 */
@Post public Representation createResourceSet(JsonRepresentation entity) throws NotFoundException, ServerException, BadRequestException {
  ResourceSetDescription resourceSetDescription=new ResourceSetDescription(null,getClientId(),getResourceOwnerId(),validator.validate(toMap(entity)));
  OAuth2Request oAuth2Request=requestFactory.create(getRequest());
  ResourceSetStore store=providerSettingsFactory.get(oAuth2Request).getResourceSetStore();
  try {
    store.create(oAuth2Request,resourceSetDescription);
    for (    ResourceSetRegistrationListener listener : listeners) {
      listener.resourceSetCreated(oAuth2Request.<String>getParameter(""String_Node_Str""),resourceSetDescription);
    }
  }
 catch (  ServerException e) {
    throw e;
  }
catch (  BadRequestException e) {
    throw e;
  }
catch (  NotFoundException e) {
    throw e;
  }
  getResponse().setStatus(new Status(201));
  return createJsonResponse(resourceSetDescription,false,true);
}","/** 
 * <p>Creates or updates a resource set description.</p> <p>If the request contains a If-Match header an update is performed, otherwise a create is performed.</p> <p>An update will replace the current description of the resource set with the contents of the request body.</p>
 * @param entity The new resource set description.
 * @return A JSON object containing the authorization server's unique id for the resource set and, optionally,a policy uri.
 * @throws NotFoundException If the requested resource set description does not exist.
 * @throws ServerException When an error occurs during creating or updating.
 * @throws BadRequestException If the request JSON is invalid.
 */
@Post public Representation createResourceSet(JsonRepresentation entity) throws NotFoundException, ServerException, BadRequestException {
  ResourceSetDescription resourceSetDescription=new ResourceSetDescription(null,getClientId(),getResourceOwnerId(),validator.validate(toMap(entity)));
  OAuth2Request oAuth2Request=requestFactory.create(getRequest());
  ResourceSetStore store=providerSettingsFactory.get(oAuth2Request).getResourceSetStore();
  store.create(oAuth2Request,resourceSetDescription);
  for (  ResourceSetRegistrationListener listener : listeners) {
    listener.resourceSetCreated(oAuth2Request.<String>getParameter(""String_Node_Str""),resourceSetDescription);
  }
  getResponse().setStatus(new Status(201));
  return createJsonResponse(resourceSetDescription,false,true);
}"
9189,"/** 
 * Constructs a new   {@link org.forgerock.openam.rest.resource.CrestRealmRouter} with routes to each of the CRESTresource endpoints.
 * @return A {@code RealmRouter}.
 */
private CrestRouter createResourceRouter(final Set<String> invalidRealmNames){
  FluentRouter rootRealmRouterDelegate=InjectorHolder.getInstance(LoggingFluentRouter.class);
  FluentRouter rootRealmRouter=new RealmBlackListingFluentRouter(rootRealmRouterDelegate,invalidRealmNames);
  FluentRealmRouter dynamicRealmRouter=rootRealmRouter.dynamically();
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(DashboardResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(ServerInfoResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(IdentityResourceV1.class,""String_Node_Str"").forVersion(""String_Node_Str"").to(IdentityResourceV2.class,""String_Node_Str"");
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(IdentityResourceV1.class,""String_Node_Str"").forVersion(""String_Node_Str"").to(IdentityResourceV2.class,""String_Node_Str"");
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(IdentityResourceV1.class,""String_Node_Str"").forVersion(""String_Node_Str"").to(IdentityResourceV2.class,""String_Node_Str"");
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(TrustedDevicesResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(ResourceOwnerOrSuperUserAuthzModule.class,ResourceOwnerOrSuperUserAuthzModule.NAME).forVersion(""String_Node_Str"").to(ResourceSetResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(ResourceOwnerOrSuperUserAuthzModule.class,ResourceOwnerOrSuperUserAuthzModule.NAME).forVersion(""String_Node_Str"").to(UmaPolicyResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(AuditHistory.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(PolicyResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(ReferralsResourceV1.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(RealmResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(SessionResourceAuthzModule.class,SessionResourceAuthzModule.NAME).forVersion(""String_Node_Str"").to(SessionResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(ApplicationsResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(SubjectAttributesResourceV1.class);
  rootRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(ApplicationTypesResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(ResourceTypesResource.class);
  rootRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(DecisionCombinersResource.class);
  rootRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(ConditionTypesResource.class);
  rootRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(SubjectTypesResource.class);
  rootRealmRouter.route(""String_Node_Str"").through(CoreTokenResourceAuthzModule.class,CoreTokenResourceAuthzModule.NAME).forVersion(""String_Node_Str"").to(CoreTokenResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(AdminOnlyAuthzModule.class,AdminOnlyAuthzModule.NAME).forVersion(""String_Node_Str"").to(ScriptResource.class);
  VersionBehaviourConfigListener.bindToServiceConfigManager(rootRealmRouter);
  VersionBehaviourConfigListener.bindToServiceConfigManager(dynamicRealmRouter);
  return rootRealmRouterDelegate;
}","/** 
 * Constructs a new   {@link org.forgerock.openam.rest.resource.CrestRealmRouter} with routes to each of the CRESTresource endpoints.
 * @return A {@code RealmRouter}.
 */
private CrestRouter createResourceRouter(final Set<String> invalidRealmNames){
  FluentRouter rootRealmRouterDelegate=InjectorHolder.getInstance(LoggingFluentRouter.class);
  FluentRouter rootRealmRouter=new RealmBlackListingFluentRouter(rootRealmRouterDelegate,invalidRealmNames);
  FluentRealmRouter dynamicRealmRouter=rootRealmRouter.dynamically();
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(DashboardResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(ServerInfoResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(InjectorHolder.getInstance(UmaConfigurationResource.class));
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(IdentityResourceV1.class,""String_Node_Str"").forVersion(""String_Node_Str"").to(IdentityResourceV2.class,""String_Node_Str"");
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(IdentityResourceV1.class,""String_Node_Str"").forVersion(""String_Node_Str"").to(IdentityResourceV2.class,""String_Node_Str"");
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(IdentityResourceV1.class,""String_Node_Str"").forVersion(""String_Node_Str"").to(IdentityResourceV2.class,""String_Node_Str"");
  dynamicRealmRouter.route(""String_Node_Str"").forVersion(""String_Node_Str"").to(TrustedDevicesResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(ResourceOwnerOrSuperUserAuthzModule.class,ResourceOwnerOrSuperUserAuthzModule.NAME).forVersion(""String_Node_Str"").to(ResourceSetResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(UmaPolicyResourceAuthzFilter.class,UmaPolicyResourceAuthzFilter.NAME).forVersion(""String_Node_Str"").to(UmaPolicyResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(ResourceOwnerOrSuperUserAuthzModule.class,ResourceOwnerOrSuperUserAuthzModule.NAME).forVersion(""String_Node_Str"").to(AuditHistory.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(PolicyResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(ReferralsResourceV1.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(RealmResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(SessionResourceAuthzModule.class,SessionResourceAuthzModule.NAME).forVersion(""String_Node_Str"").to(SessionResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(ApplicationsResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(SubjectAttributesResourceV1.class);
  rootRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(ApplicationTypesResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(ResourceTypesResource.class);
  rootRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(DecisionCombinersResource.class);
  rootRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(ConditionTypesResource.class);
  rootRealmRouter.route(""String_Node_Str"").through(PrivilegeAuthzModule.class,PrivilegeAuthzModule.NAME).forVersion(""String_Node_Str"").to(SubjectTypesResource.class);
  rootRealmRouter.route(""String_Node_Str"").through(CoreTokenResourceAuthzModule.class,CoreTokenResourceAuthzModule.NAME).forVersion(""String_Node_Str"").to(CoreTokenResource.class);
  dynamicRealmRouter.route(""String_Node_Str"").through(AdminOnlyAuthzModule.class,AdminOnlyAuthzModule.NAME).forVersion(""String_Node_Str"").to(ScriptResource.class);
  VersionBehaviourConfigListener.bindToServiceConfigManager(rootRealmRouter);
  VersionBehaviourConfigListener.bindToServiceConfigManager(dynamicRealmRouter);
  return rootRealmRouterDelegate;
}"
9190,"boolean isSuperUser(String userId){
  return sessionService.get().isSuperUser(userId);
}","protected boolean isSuperUser(String userId){
  return sessionService.get().isSuperUser(userId);
}"
9191,"/** 
 * Lets through any request which is coming from a verifiable administrator.
 */
Promise<AuthorizationResult,ResourceException> authorize(ServerContext context){
  try {
    String userId=getUserId(context);
    if (isSuperUser(userId)) {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + userId + ""String_Node_Str"");
      }
      return Promises.newSuccessfulPromise(AuthorizationResult.accessPermitted());
    }
 else {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + userId);
      }
      return Promises.newSuccessfulPromise(AuthorizationResult.accessDenied(""String_Node_Str""));
    }
  }
 catch (  ResourceException e) {
    return Promises.newFailedPromise(e);
  }
}","/** 
 * Lets through any request which is coming from a verifiable administrator.
 */
protected Promise<AuthorizationResult,ResourceException> authorize(ServerContext context){
  try {
    String userId=getUserId(context);
    if (isSuperUser(userId)) {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + userId + ""String_Node_Str"");
      }
      return Promises.newSuccessfulPromise(AuthorizationResult.accessPermitted());
    }
 else {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + userId);
      }
      return Promises.newSuccessfulPromise(AuthorizationResult.accessDenied(""String_Node_Str""));
    }
  }
 catch (  ResourceException e) {
    return Promises.newFailedPromise(e);
  }
}"
9192,"String getUserId(ServerContext context) throws ResourceException {
  SSOTokenContext tokenContext=context.asContext(SSOTokenContext.class);
  try {
    SSOToken token=tokenContext.getCallerSSOToken();
    return token.getProperty(Constants.UNIVERSAL_IDENTIFIER);
  }
 catch (  SSOException e) {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"",e);
    }
    throw new ForbiddenException(e.getMessage(),e);
  }
}","protected String getUserId(ServerContext context) throws ResourceException {
  SSOTokenContext tokenContext=context.asContext(SSOTokenContext.class);
  try {
    SSOToken token=tokenContext.getCallerSSOToken();
    return token.getProperty(Constants.UNIVERSAL_IDENTIFIER);
  }
 catch (  SSOException e) {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"",e);
    }
    throw new ForbiddenException(e.getMessage(),e);
  }
}"
9193,"/** 
 * Prevents access to   {@link org.forgerock.openam.forgerockrest.cts.CoreTokenResource} unless thisREST endpoint has been explicitly enabled. If the endpoint has been explicitly enabled, it defers to {@link org.forgerock.openam.rest.authz.AdminOnlyAuthzModule} to ensure that the SSO Token belongs toa user with Administrator-level access.
 */
@Override Promise<AuthorizationResult,ResourceException> authorize(ServerContext context){
  if (!enabled) {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"");
    }
    return Promises.newSuccessfulPromise(AuthorizationResult.failure(""String_Node_Str""));
  }
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"");
  }
  return super.authorize(context);
}","/** 
 * Prevents access to   {@link org.forgerock.openam.forgerockrest.cts.CoreTokenResource} unless thisREST endpoint has been explicitly enabled. If the endpoint has been explicitly enabled, it defers to {@link org.forgerock.openam.rest.authz.AdminOnlyAuthzModule} to ensure that the SSO Token belongs toa user with Administrator-level access.
 */
@Override protected Promise<AuthorizationResult,ResourceException> authorize(ServerContext context){
  if (!enabled) {
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"");
    }
    return Promises.newSuccessfulPromise(AuthorizationResult.failure(""String_Node_Str""));
  }
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"");
  }
  return super.authorize(context);
}"
9194,"private String getUserIdFromUri(ServerContext context) throws InternalServerErrorException {
  String username=context.asContext(RouterContext.class).getUriTemplateVariables().get(""String_Node_Str"");
  String realm=context.asContext(RealmContext.class).getResolvedRealm();
  return IdUtils.getIdentity(username,realm).getUniversalId();
}","protected String getUserIdFromUri(ServerContext context) throws InternalServerErrorException {
  String username=context.asContext(RouterContext.class).getUriTemplateVariables().get(""String_Node_Str"");
  String realm=context.asContext(RealmContext.class).getResolvedRealm();
  return IdUtils.getIdentity(username,realm).getUniversalId();
}"
9195,"/** 
 * Authorizes caller if they are either a super user or they are making a request to a resource they ""own"", i.e. demo making a call to /json/users/demo/uma/resourceset.
 * @param context The request context.
 * @return The authorization result.
 */
@Override Promise<AuthorizationResult,ResourceException> authorize(ServerContext context){
  try {
    String loggedInUserId=getUserId(context);
    if (isSuperUser(loggedInUserId)) {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + loggedInUserId + ""String_Node_Str"");
      }
      return Promises.newSuccessfulPromise(AuthorizationResult.accessPermitted());
    }
 else     if (loggedInUserId.equalsIgnoreCase(getUserIdFromUri(context))) {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + loggedInUserId + ""String_Node_Str"");
      }
      return Promises.newSuccessfulPromise(AuthorizationResult.accessPermitted());
    }
 else {
      if (debug.warningEnabled()) {
        debug.warning(""String_Node_Str"" + loggedInUserId);
      }
      return Promises.newSuccessfulPromise(AuthorizationResult.accessDenied(""String_Node_Str"" + loggedInUserId + ""String_Node_Str""));
    }
  }
 catch (  ResourceException e) {
    return Promises.newFailedPromise(e);
  }
}","/** 
 * Authorizes caller if they are either a super user or they are making a request to a resource they ""own"", i.e. demo making a call to /json/users/demo/uma/resourceset.
 * @param context The request context.
 * @return The authorization result.
 */
@Override protected Promise<AuthorizationResult,ResourceException> authorize(ServerContext context){
  try {
    String loggedInUserId=getUserId(context);
    if (isSuperUser(loggedInUserId)) {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + loggedInUserId + ""String_Node_Str"");
      }
      return Promises.newSuccessfulPromise(AuthorizationResult.accessPermitted());
    }
 else     if (loggedInUserId.equalsIgnoreCase(getUserIdFromUri(context))) {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + loggedInUserId + ""String_Node_Str"");
      }
      return Promises.newSuccessfulPromise(AuthorizationResult.accessPermitted());
    }
 else {
      if (debug.warningEnabled()) {
        debug.warning(""String_Node_Str"" + loggedInUserId);
      }
      return Promises.newSuccessfulPromise(AuthorizationResult.accessDenied(""String_Node_Str"" + loggedInUserId + ""String_Node_Str""));
    }
  }
 catch (  ResourceException e) {
    return Promises.newFailedPromise(e);
  }
}"
9196,"/** 
 * Write message into file
 * @param prefix Message prefix
 * @param msg    Message to be recorded.
 * @param th     the optional <code>java.lang.Throwable</code> which ifpresent will be used to record the stack trace.
 * @throws IOException
 */
public void writeIt(String prefix,String msg,Throwable th) throws IOException ;","/** 
 * Write message into file
 * @param prefix Message prefix
 * @param msg    Message to be recorded.
 * @param th     the optional <code>java.lang.Throwable</code> which ifpresent will be used to record the stack trace.
 * @throws IOException
 */
public void writeIt(StringBuilder prefix,String msg,Throwable th) throws IOException ;"
9197,"boolean processIndexType(IndexType indexType,String indexName,String orgDN) throws AuthLoginException {
  boolean ignoreProfile=false;
  IndexType previousType=loginState.getPreviousIndexType();
  String normOrgDN=DNUtils.normalizeDN(orgDN);
  if ((previousType != IndexType.LEVEL && previousType != IndexType.COMPOSITE_ADVICE) || indexType != IndexType.MODULE_INSTANCE) {
    HttpServletRequest hreq=loginState.getHttpServletRequest();
    boolean isTokenValid=false;
    final boolean isFederation=indexType == AuthContext.IndexType.MODULE_INSTANCE && ISAuthConstants.FEDERATION_MODULE.equals(indexName);
    if (hreq != null && !isFederation) {
      try {
        SSOTokenManager manager=SSOTokenManager.getInstance();
        SSOToken ssoToken=manager.createSSOToken(hreq);
        if (manager.isValidToken(ssoToken)) {
          debug.message(""String_Node_Str"");
          isTokenValid=true;
        }
      }
 catch (      Exception e) {
        debug.message(""String_Node_Str"" + e.toString());
      }
      if (!isTokenValid) {
        debug.message(""String_Node_Str"");
        Hashtable requestHash=loginState.getRequestParamHash();
        String newOrgDN=AuthUtils.getDomainNameByRequest(hreq,requestHash);
        if (debug.messageEnabled()) {
          debug.message(""String_Node_Str"" + orgDN + ""String_Node_Str""+ newOrgDN);
        }
        if (normOrgDN != null) {
          if (!normOrgDN.equals(newOrgDN) && !pCookieMode) {
            loginStatus.setStatus(LoginStatus.AUTH_RESET);
            loginState.setErrorCode(AMAuthErrorCode.AUTH_ERROR);
            setErrorMsgAndTemplate();
            internalAuthError=true;
            throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_ERROR,null);
          }
        }
      }
    }
  }
  if (indexType == IndexType.COMPOSITE_ADVICE) {
    debug.message(""String_Node_Str"");
    String compositeAdvice=URLEncDec.decode(indexName);
    loginState.setCompositeAdvice(compositeAdvice);
    try {
      if (processCompositeAdvice(indexType,indexName,orgDN,clientType)) {
        debug.message(""String_Node_Str"");
        return true;
      }
 else {
        return false;
      }
    }
 catch (    AuthException ae) {
      loginState.setErrorCode(ae.getErrorCode());
      loginState.logFailed(ae.getMessage());
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(ae);
    }
  }
 else   if (indexType == IndexType.LEVEL) {
    debug.message(""String_Node_Str"");
    try {
      if (processLevel(indexType,indexName,orgDN,clientType)) {
        debug.message(""String_Node_Str"");
        return true;
      }
 else {
        return false;
      }
    }
 catch (    AuthException ae) {
      loginState.setErrorCode(ae.getErrorCode());
      loginState.logFailed(ae.getMessage());
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(ae);
    }
  }
 else   if (indexType == IndexType.USER) {
    debug.message(""String_Node_Str"");
    boolean userValid=false;
    if (!loginState.ignoreProfile()) {
      userValid=validateUser(indexName);
    }
 else {
      ignoreProfile=true;
    }
    if (pCookieMode) {
      processPCookieMode(userValid);
      return true;
    }
 else     if ((!userValid) && (!ignoreProfile)) {
      debug.message(""String_Node_Str"");
      loginState.logFailed(bundle.getString(""String_Node_Str""),""String_Node_Str"");
      loginState.setErrorCode(AMAuthErrorCode.AUTH_LOGIN_FAILED);
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_USER_INACTIVE,null);
    }
 else     if (ignoreProfile) {
      setAuthError(AMAuthErrorCode.AUTH_PROFILE_ERROR,""String_Node_Str"");
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_PROFILE_ERROR,null);
    }
 else {
      return false;
    }
  }
 else   if (indexType == IndexType.MODULE_INSTANCE) {
    debug.message(""String_Node_Str"");
    boolean instanceExists=loginState.getDomainAuthenticators().contains(indexName);
    if (!indexName.equals(ISAuthConstants.APPLICATION_MODULE) && !instanceExists) {
      debug.message(""String_Node_Str"");
      loginState.setErrorCode(AMAuthErrorCode.AUTH_MODULE_DENIED);
      loginState.logFailed(bundle.getString(""String_Node_Str""),""String_Node_Str"");
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_MODULE_DENIED,null);
    }
 else {
      return false;
    }
  }
 else   if (indexType == IndexType.ROLE) {
    debug.message(""String_Node_Str"");
    if (loginState.ignoreProfile()) {
      setAuthError(AMAuthErrorCode.AUTH_TYPE_DENIED,""String_Node_Str"");
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_TYPE_DENIED,null);
    }
  }
  return false;
}","boolean processIndexType(IndexType indexType,String indexName,String orgDN) throws AuthLoginException {
  boolean ignoreProfile=false;
  IndexType previousType=loginState.getPreviousIndexType();
  String normOrgDN=DNUtils.normalizeDN(orgDN);
  if ((previousType != IndexType.LEVEL && previousType != IndexType.COMPOSITE_ADVICE) || indexType != IndexType.MODULE_INSTANCE) {
    HttpServletRequest hreq=loginState.getHttpServletRequest();
    boolean isTokenValid=false;
    final boolean isFederation=indexType == IndexType.MODULE_INSTANCE && ISAuthConstants.FEDERATION_MODULE.equals(indexName);
    if (hreq != null && !isFederation) {
      try {
        SSOTokenManager manager=SSOTokenManager.getInstance();
        SSOToken ssoToken=manager.createSSOToken(hreq);
        if (manager.isValidToken(ssoToken)) {
          debug.message(""String_Node_Str"");
          isTokenValid=true;
        }
      }
 catch (      Exception e) {
        debug.message(""String_Node_Str"" + e.toString());
      }
      if (!isTokenValid) {
        debug.message(""String_Node_Str"");
        Hashtable requestHash=loginState.getRequestParamHash();
        String newOrgDN=AuthUtils.getDomainNameByRequest(hreq,requestHash);
        if (debug.messageEnabled()) {
          debug.message(""String_Node_Str"" + orgDN + ""String_Node_Str""+ newOrgDN);
        }
        if (normOrgDN != null) {
          if (!normOrgDN.equals(newOrgDN) && !pCookieMode) {
            loginStatus.setStatus(LoginStatus.AUTH_RESET);
            loginState.setErrorCode(AMAuthErrorCode.AUTH_ERROR);
            setErrorMsgAndTemplate();
            internalAuthError=true;
            throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_ERROR,null);
          }
        }
      }
    }
  }
  if (indexType == IndexType.COMPOSITE_ADVICE) {
    debug.message(""String_Node_Str"");
    String compositeAdvice=URLEncDec.decode(indexName);
    loginState.setCompositeAdvice(compositeAdvice);
    try {
      if (processCompositeAdvice(indexType,indexName,orgDN,clientType)) {
        debug.message(""String_Node_Str"");
        return true;
      }
 else {
        return false;
      }
    }
 catch (    AuthException ae) {
      loginState.setErrorCode(ae.getErrorCode());
      loginState.logFailed(ae.getMessage());
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(ae);
    }
  }
 else   if (indexType == IndexType.LEVEL) {
    debug.message(""String_Node_Str"");
    try {
      if (processLevel(indexType,indexName,orgDN,clientType)) {
        debug.message(""String_Node_Str"");
        return true;
      }
 else {
        return false;
      }
    }
 catch (    AuthException ae) {
      loginState.setErrorCode(ae.getErrorCode());
      loginState.logFailed(ae.getMessage());
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(ae);
    }
  }
 else   if (indexType == IndexType.USER) {
    debug.message(""String_Node_Str"");
    boolean userValid=false;
    if (!loginState.ignoreProfile()) {
      userValid=validateUser(indexName);
    }
 else {
      ignoreProfile=true;
    }
    if (pCookieMode) {
      processPCookieMode(userValid);
      return true;
    }
 else     if ((!userValid) && (!ignoreProfile)) {
      debug.message(""String_Node_Str"");
      loginState.logFailed(bundle.getString(""String_Node_Str""),""String_Node_Str"");
      loginState.setErrorCode(AMAuthErrorCode.AUTH_LOGIN_FAILED);
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_USER_INACTIVE,null);
    }
 else     if (ignoreProfile) {
      setAuthError(AMAuthErrorCode.AUTH_PROFILE_ERROR,""String_Node_Str"");
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_PROFILE_ERROR,null);
    }
 else {
      return false;
    }
  }
 else   if (indexType == IndexType.MODULE_INSTANCE) {
    debug.message(""String_Node_Str"");
    boolean instanceExists=loginState.getDomainAuthenticators().contains(indexName);
    if (!indexName.equals(ISAuthConstants.APPLICATION_MODULE) && !instanceExists) {
      debug.message(""String_Node_Str"");
      loginState.setErrorCode(AMAuthErrorCode.AUTH_MODULE_DENIED);
      loginState.logFailed(bundle.getString(""String_Node_Str""),""String_Node_Str"");
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_MODULE_DENIED,null);
    }
 else {
      return false;
    }
  }
 else   if (indexType == IndexType.ROLE) {
    debug.message(""String_Node_Str"");
    if (loginState.ignoreProfile()) {
      setAuthError(AMAuthErrorCode.AUTH_TYPE_DENIED,""String_Node_Str"");
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_TYPE_DENIED,null);
    }
  }
  return false;
}"
9198,"/** 
 * Write message into file
 * @param prefix Message prefix
 * @param msg    Message to be recorded.
 * @param th     the optional <code>java.lang.Throwable</code> which ifpresent will be used to record the stack trace.
 * @throws IOException
 */
public void writeIt(String prefix,String msg,Throwable th) throws IOException ;","/** 
 * Write message into file
 * @param prefix Message prefix
 * @param msg    Message to be recorded.
 * @param th     the optional <code>java.lang.Throwable</code> which ifpresent will be used to record the stack trace.
 * @throws IOException
 */
public void writeIt(StringBuilder prefix,String msg,Throwable th) throws IOException ;"
9199,"/** 
 * Write message into file
 * @param prefix Message prefix
 * @param msg    Message to be recorded.
 * @param th     the optional <code>java.lang.Throwable</code> which ifpresent will be used to record the stack trace.
 * @throws IOException
 */
public void writeIt(String prefix,String msg,Throwable th) throws IOException ;","/** 
 * Write message into file
 * @param prefix Message prefix
 * @param msg    Message to be recorded.
 * @param th     the optional <code>java.lang.Throwable</code> which ifpresent will be used to record the stack trace.
 * @throws IOException
 */
public void writeIt(StringBuilder prefix,String msg,Throwable th) throws IOException ;"
9200,"boolean processIndexType(IndexType indexType,String indexName,String orgDN) throws AuthLoginException {
  boolean ignoreProfile=false;
  IndexType previousType=loginState.getPreviousIndexType();
  String normOrgDN=DNUtils.normalizeDN(orgDN);
  if ((previousType != IndexType.LEVEL && previousType != IndexType.COMPOSITE_ADVICE) || indexType != IndexType.MODULE_INSTANCE) {
    HttpServletRequest hreq=loginState.getHttpServletRequest();
    boolean isTokenValid=false;
    final boolean isFederation=indexType == AuthContext.IndexType.MODULE_INSTANCE && ISAuthConstants.FEDERATION_MODULE.equals(indexName);
    if (hreq != null && !isFederation) {
      try {
        SSOTokenManager manager=SSOTokenManager.getInstance();
        SSOToken ssoToken=manager.createSSOToken(hreq);
        if (manager.isValidToken(ssoToken)) {
          debug.message(""String_Node_Str"");
          isTokenValid=true;
        }
      }
 catch (      Exception e) {
        debug.message(""String_Node_Str"" + e.toString());
      }
      if (!isTokenValid) {
        debug.message(""String_Node_Str"");
        Hashtable requestHash=loginState.getRequestParamHash();
        String newOrgDN=AuthUtils.getDomainNameByRequest(hreq,requestHash);
        if (debug.messageEnabled()) {
          debug.message(""String_Node_Str"" + orgDN + ""String_Node_Str""+ newOrgDN);
        }
        if (normOrgDN != null) {
          if (!normOrgDN.equals(newOrgDN) && !pCookieMode) {
            loginStatus.setStatus(LoginStatus.AUTH_RESET);
            loginState.setErrorCode(AMAuthErrorCode.AUTH_ERROR);
            setErrorMsgAndTemplate();
            internalAuthError=true;
            throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_ERROR,null);
          }
        }
      }
    }
  }
  if (indexType == IndexType.COMPOSITE_ADVICE) {
    debug.message(""String_Node_Str"");
    String compositeAdvice=URLEncDec.decode(indexName);
    loginState.setCompositeAdvice(compositeAdvice);
    try {
      if (processCompositeAdvice(indexType,indexName,orgDN,clientType)) {
        debug.message(""String_Node_Str"");
        return true;
      }
 else {
        return false;
      }
    }
 catch (    AuthException ae) {
      loginState.setErrorCode(ae.getErrorCode());
      loginState.logFailed(ae.getMessage());
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(ae);
    }
  }
 else   if (indexType == IndexType.LEVEL) {
    debug.message(""String_Node_Str"");
    try {
      if (processLevel(indexType,indexName,orgDN,clientType)) {
        debug.message(""String_Node_Str"");
        return true;
      }
 else {
        return false;
      }
    }
 catch (    AuthException ae) {
      loginState.setErrorCode(ae.getErrorCode());
      loginState.logFailed(ae.getMessage());
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(ae);
    }
  }
 else   if (indexType == IndexType.USER) {
    debug.message(""String_Node_Str"");
    boolean userValid=false;
    if (!loginState.ignoreProfile()) {
      userValid=validateUser(indexName);
    }
 else {
      ignoreProfile=true;
    }
    if (pCookieMode) {
      processPCookieMode(userValid);
      return true;
    }
 else     if ((!userValid) && (!ignoreProfile)) {
      debug.message(""String_Node_Str"");
      loginState.logFailed(bundle.getString(""String_Node_Str""),""String_Node_Str"");
      loginState.setErrorCode(AMAuthErrorCode.AUTH_LOGIN_FAILED);
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_USER_INACTIVE,null);
    }
 else     if (ignoreProfile) {
      setAuthError(AMAuthErrorCode.AUTH_PROFILE_ERROR,""String_Node_Str"");
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_PROFILE_ERROR,null);
    }
 else {
      return false;
    }
  }
 else   if (indexType == IndexType.MODULE_INSTANCE) {
    debug.message(""String_Node_Str"");
    boolean instanceExists=loginState.getDomainAuthenticators().contains(indexName);
    if (!indexName.equals(ISAuthConstants.APPLICATION_MODULE) && !instanceExists) {
      debug.message(""String_Node_Str"");
      loginState.setErrorCode(AMAuthErrorCode.AUTH_MODULE_DENIED);
      loginState.logFailed(bundle.getString(""String_Node_Str""),""String_Node_Str"");
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_MODULE_DENIED,null);
    }
 else {
      return false;
    }
  }
 else   if (indexType == IndexType.ROLE) {
    debug.message(""String_Node_Str"");
    if (loginState.ignoreProfile()) {
      setAuthError(AMAuthErrorCode.AUTH_TYPE_DENIED,""String_Node_Str"");
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_TYPE_DENIED,null);
    }
  }
  return false;
}","boolean processIndexType(IndexType indexType,String indexName,String orgDN) throws AuthLoginException {
  boolean ignoreProfile=false;
  IndexType previousType=loginState.getPreviousIndexType();
  String normOrgDN=DNUtils.normalizeDN(orgDN);
  if ((previousType != IndexType.LEVEL && previousType != IndexType.COMPOSITE_ADVICE) || indexType != IndexType.MODULE_INSTANCE) {
    HttpServletRequest hreq=loginState.getHttpServletRequest();
    boolean isTokenValid=false;
    final boolean isFederation=indexType == IndexType.MODULE_INSTANCE && ISAuthConstants.FEDERATION_MODULE.equals(indexName);
    if (hreq != null && !isFederation) {
      try {
        SSOTokenManager manager=SSOTokenManager.getInstance();
        SSOToken ssoToken=manager.createSSOToken(hreq);
        if (manager.isValidToken(ssoToken)) {
          debug.message(""String_Node_Str"");
          isTokenValid=true;
        }
      }
 catch (      Exception e) {
        debug.message(""String_Node_Str"" + e.toString());
      }
      if (!isTokenValid) {
        debug.message(""String_Node_Str"");
        Hashtable requestHash=loginState.getRequestParamHash();
        String newOrgDN=AuthUtils.getDomainNameByRequest(hreq,requestHash);
        if (debug.messageEnabled()) {
          debug.message(""String_Node_Str"" + orgDN + ""String_Node_Str""+ newOrgDN);
        }
        if (normOrgDN != null) {
          if (!normOrgDN.equals(newOrgDN) && !pCookieMode) {
            loginStatus.setStatus(LoginStatus.AUTH_RESET);
            loginState.setErrorCode(AMAuthErrorCode.AUTH_ERROR);
            setErrorMsgAndTemplate();
            internalAuthError=true;
            throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_ERROR,null);
          }
        }
      }
    }
  }
  if (indexType == IndexType.COMPOSITE_ADVICE) {
    debug.message(""String_Node_Str"");
    String compositeAdvice=URLEncDec.decode(indexName);
    loginState.setCompositeAdvice(compositeAdvice);
    try {
      if (processCompositeAdvice(indexType,indexName,orgDN,clientType)) {
        debug.message(""String_Node_Str"");
        return true;
      }
 else {
        return false;
      }
    }
 catch (    AuthException ae) {
      loginState.setErrorCode(ae.getErrorCode());
      loginState.logFailed(ae.getMessage());
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(ae);
    }
  }
 else   if (indexType == IndexType.LEVEL) {
    debug.message(""String_Node_Str"");
    try {
      if (processLevel(indexType,indexName,orgDN,clientType)) {
        debug.message(""String_Node_Str"");
        return true;
      }
 else {
        return false;
      }
    }
 catch (    AuthException ae) {
      loginState.setErrorCode(ae.getErrorCode());
      loginState.logFailed(ae.getMessage());
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(ae);
    }
  }
 else   if (indexType == IndexType.USER) {
    debug.message(""String_Node_Str"");
    boolean userValid=false;
    if (!loginState.ignoreProfile()) {
      userValid=validateUser(indexName);
    }
 else {
      ignoreProfile=true;
    }
    if (pCookieMode) {
      processPCookieMode(userValid);
      return true;
    }
 else     if ((!userValid) && (!ignoreProfile)) {
      debug.message(""String_Node_Str"");
      loginState.logFailed(bundle.getString(""String_Node_Str""),""String_Node_Str"");
      loginState.setErrorCode(AMAuthErrorCode.AUTH_LOGIN_FAILED);
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_USER_INACTIVE,null);
    }
 else     if (ignoreProfile) {
      setAuthError(AMAuthErrorCode.AUTH_PROFILE_ERROR,""String_Node_Str"");
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_PROFILE_ERROR,null);
    }
 else {
      return false;
    }
  }
 else   if (indexType == IndexType.MODULE_INSTANCE) {
    debug.message(""String_Node_Str"");
    boolean instanceExists=loginState.getDomainAuthenticators().contains(indexName);
    if (!indexName.equals(ISAuthConstants.APPLICATION_MODULE) && !instanceExists) {
      debug.message(""String_Node_Str"");
      loginState.setErrorCode(AMAuthErrorCode.AUTH_MODULE_DENIED);
      loginState.logFailed(bundle.getString(""String_Node_Str""),""String_Node_Str"");
      setErrorMsgAndTemplate();
      loginStatus.setStatus(LoginStatus.AUTH_FAILED);
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_MODULE_DENIED,null);
    }
 else {
      return false;
    }
  }
 else   if (indexType == IndexType.ROLE) {
    debug.message(""String_Node_Str"");
    if (loginState.ignoreProfile()) {
      setAuthError(AMAuthErrorCode.AUTH_TYPE_DENIED,""String_Node_Str"");
      throw new AuthLoginException(BUNDLE_NAME,AMAuthErrorCode.AUTH_TYPE_DENIED,null);
    }
  }
  return false;
}"
9201,"/** 
 * Compute the final log file name (prefix and suffix)
 * @param fileName the log file name base
 * @return the complete log file name
 */
private String wrapFilename(String fileName){
  StringBuilder newFileName=new StringBuilder();
  if (debugPrefix != null) {
    newFileName.append(debugPrefix);
  }
  newFileName.append(fileName);
synchronized (suffixDateFormat) {
    if (suffixDateFormat != null && rotationInterval > 0) {
      newFileName.append(suffixDateFormat.format(new Date(clock.now())));
    }
  }
  return newFileName.toString();
}","/** 
 * Compute the final log file name (prefix and suffix)
 * @param fileName the log file name base
 * @return the complete log file name
 */
private String wrapFilename(String fileName){
  StringBuilder newFileName=new StringBuilder();
  if (debugPrefix != null) {
    newFileName.append(debugPrefix);
  }
  newFileName.append(fileName);
  if (suffixDateFormat != null && rotationInterval > 0) {
synchronized (suffixDateFormat) {
      newFileName.append(suffixDateFormat.format(new Date(clock.now())));
    }
  }
  return newFileName.toString();
}"
9202,"/** 
 * Creates an instance of <code>DebugImpl</code>.
 * @param debugName Name of the debug.
 */
public DebugImpl(String debugName,DebugFileProvider debugFileProvider){
  this.debugName=debugName;
  if (SystemPropertiesManager.get(DebugConstants.CONFIG_DEBUG_LEVEL) != null) {
    setDebug(SystemPropertiesManager.get(DebugConstants.CONFIG_DEBUG_LEVEL));
  }
 else {
    setDebug(DebugLevel.OFF);
  }
  this.debugFileProvider=debugFileProvider;
  stdoutDebugFile=debugFileProvider.getStdOutDebugFile();
  String mf=SystemPropertiesManager.get(DebugConstants.CONFIG_DEBUG_MERGEALL);
  mergeAllMode=""String_Node_Str"".equals(mf);
}","/** 
 * Creates an instance of <code>DebugImpl</code>.
 * @param debugName Name of the debug.
 */
public DebugImpl(String debugName,DebugFileProvider debugFileProvider){
  this.debugName=debugName;
  if (SystemPropertiesManager.get(DebugConstants.CONFIG_DEBUG_LEVEL) != null) {
    setDebug(SystemPropertiesManager.get(DebugConstants.CONFIG_DEBUG_LEVEL));
  }
 else {
    setDebug(DebugLevel.ON);
  }
  this.debugFileProvider=debugFileProvider;
  stdoutDebugFile=debugFileProvider.getStdOutDebugFile();
  String mf=SystemPropertiesManager.get(DebugConstants.CONFIG_DEBUG_MERGEALL);
  mergeAllMode=""String_Node_Str"".equals(mf);
}"
9203,"/** 
 * Creates an instance of <code>DebugImpl</code>.
 * @param debugName Name of the debug.
 */
public DebugImpl(String debugName,DebugFileProvider debugFileProvider){
  this.debugName=debugName;
  if (SystemPropertiesManager.get(DebugConstants.CONFIG_DEBUG_LEVEL) != null) {
    setDebug(SystemPropertiesManager.get(DebugConstants.CONFIG_DEBUG_LEVEL));
  }
 else {
    setDebug(DebugLevel.OFF);
  }
  this.debugFileProvider=debugFileProvider;
  stdoutDebugFile=debugFileProvider.getStdOutDebugFile();
  String mf=SystemPropertiesManager.get(DebugConstants.CONFIG_DEBUG_MERGEALL);
  mergeAllMode=""String_Node_Str"".equals(mf);
}","/** 
 * Creates an instance of <code>DebugImpl</code>.
 * @param debugName Name of the debug.
 */
public DebugImpl(String debugName,DebugFileProvider debugFileProvider){
  this.debugName=debugName;
  if (SystemPropertiesManager.get(DebugConstants.CONFIG_DEBUG_LEVEL) != null) {
    setDebug(SystemPropertiesManager.get(DebugConstants.CONFIG_DEBUG_LEVEL));
  }
 else {
    setDebug(DebugLevel.ON);
  }
  this.debugFileProvider=debugFileProvider;
  stdoutDebugFile=debugFileProvider.getStdOutDebugFile();
  String mf=SystemPropertiesManager.get(DebugConstants.CONFIG_DEBUG_MERGEALL);
  mergeAllMode=""String_Node_Str"".equals(mf);
}"
9204,"@Override public void validate() throws EntitlementException {
  if (startTime == null && startDay == null && startDate == null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + ""String_Node_Str"" + START_DATE + ""String_Node_Str""+ START_TIME+ ""String_Node_Str""+ START_DAY);
    }
    throw new EntitlementException(AT_LEAST_ONE_OF_TIME_PROPS_SHOULD_BE_DEFINED,START_DATE + ""String_Node_Str"" + START_TIME+ ""String_Node_Str""+ START_DAY);
  }
  if (startTime != null && endTime == null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + START_TIME + ""String_Node_Str""+ END_TIME);
    }
    throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,START_TIME,END_TIME);
  }
  if (startTime == null && endTime != null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + END_TIME + ""String_Node_Str""+ START_TIME);
    }
    throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,END_TIME,START_TIME);
  }
  if (startDay != null && endDay == null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + START_DAY + ""String_Node_Str""+ END_DAY);
    }
    throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,START_DAY,END_DAY);
  }
  if (startDay == null && endDay != null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + END_DAY + ""String_Node_Str""+ START_DAY);
    }
    throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,END_DAY,START_DAY);
  }
  if (startDate != null && endDate == null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + START_DATE + ""String_Node_Str""+ END_DATE);
    }
    throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,START_DATE,END_DATE);
  }
  if (startDate == null && endDate != null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + END_DATE + ""String_Node_Str""+ START_DATE);
    }
    throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,END_DATE,START_DATE);
  }
  if (startDateCal.getTime().getTime() > endDateCal.getTime().getTime()) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"");
    }
    throw new EntitlementException(START_DATE_AFTER_END_DATE);
  }
}","@Override public void validate() throws EntitlementException {
  if (startTime == null && startDay == null && startDate == null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + ""String_Node_Str"" + START_DATE + ""String_Node_Str""+ START_TIME+ ""String_Node_Str""+ START_DAY);
    }
    throw new EntitlementException(AT_LEAST_ONE_OF_TIME_PROPS_SHOULD_BE_DEFINED,START_DATE + ""String_Node_Str"" + START_TIME+ ""String_Node_Str""+ START_DAY);
  }
  if (startTime != null && endTime == null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + START_TIME + ""String_Node_Str""+ END_TIME);
    }
    throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,START_TIME,END_TIME);
  }
  if (startTime == null && endTime != null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + END_TIME + ""String_Node_Str""+ START_TIME);
    }
    throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,END_TIME,START_TIME);
  }
  if (startDay != null && endDay == null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + START_DAY + ""String_Node_Str""+ END_DAY);
    }
    throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,START_DAY,END_DAY);
  }
  if (startDay == null && endDay != null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + END_DAY + ""String_Node_Str""+ START_DAY);
    }
    throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,END_DAY,START_DAY);
  }
  if (startDate != null && endDate == null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + START_DATE + ""String_Node_Str""+ END_DATE);
    }
    throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,START_DATE,END_DATE);
  }
  if (startDate == null && endDate != null) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + END_DATE + ""String_Node_Str""+ START_DATE);
    }
    throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,END_DATE,START_DATE);
  }
  if (startDate != null) {
    if (startDateCal == null || endDateCal == null) {
      if (debug.errorEnabled()) {
        debug.error(""String_Node_Str"" + START_DATE + ""String_Node_Str""+ END_DATE+ ""String_Node_Str"");
      }
      throw new EntitlementException(PAIR_PROPERTY_NOT_DEFINED,END_DATE,START_DATE);
    }
 else {
      if (startDateCal.getTime().getTime() > endDateCal.getTime().getTime()) {
        if (debug.errorEnabled()) {
          debug.error(""String_Node_Str"");
        }
        throw new EntitlementException(START_DATE_AFTER_END_DATE,startDateCal.getTime(),endDateCal.getTime());
      }
    }
  }
}"
9205,"@Inject public LDAPConfig(String rootSuffix){
  defaultCTSRootSuffix=DN.valueOf(rootSuffix).child(""String_Node_Str"").child(""String_Node_Str"").child(""String_Node_Str"");
}","@Inject public LDAPConfig(String rootSuffix){
  defaultCTSRootSuffix=DN.valueOf(rootSuffix).child(""String_Node_Str"").child(""String_Node_Str"").child(""String_Node_Str"");
  update();
}"
9206,"@Test public void shouldIndicateHasChanged(){
  PowerMockito.mockStatic(SystemProperties.class);
  given(SystemProperties.get(anyString())).willReturn(""String_Node_Str"");
  LDAPConfig config=new LDAPConfig(""String_Node_Str"");
  config.update();
  assertThat(config.hasChanged()).isTrue();
}","@Test public void shouldIndicateHasChanged(){
  PowerMockito.mockStatic(SystemProperties.class);
  given(SystemProperties.get(anyString())).willReturn(""String_Node_Str"");
  LDAPConfig config=new LDAPConfig(""String_Node_Str"");
  assertThat(config.hasChanged()).isTrue();
}"
9207,"@Inject public LDAPConfig(String rootSuffix){
  defaultCTSRootSuffix=DN.valueOf(rootSuffix).child(""String_Node_Str"").child(""String_Node_Str"").child(""String_Node_Str"");
}","@Inject public LDAPConfig(String rootSuffix){
  defaultCTSRootSuffix=DN.valueOf(rootSuffix).child(""String_Node_Str"").child(""String_Node_Str"").child(""String_Node_Str"");
  update();
}"
9208,"@Test public void shouldIndicateHasChanged(){
  PowerMockito.mockStatic(SystemProperties.class);
  given(SystemProperties.get(anyString())).willReturn(""String_Node_Str"");
  LDAPConfig config=new LDAPConfig(""String_Node_Str"");
  config.update();
  assertThat(config.hasChanged()).isTrue();
}","@Test public void shouldIndicateHasChanged(){
  PowerMockito.mockStatic(SystemProperties.class);
  given(SystemProperties.get(anyString())).willReturn(""String_Node_Str"");
  LDAPConfig config=new LDAPConfig(""String_Node_Str"");
  assertThat(config.hasChanged()).isTrue();
}"
9209,"/** 
 * {@inheritDoc}
 */
@Override public void createInstance(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  String providedName=null;
  try {
    providedName=request.getNewResourceId();
    if (!providedName.equals(DN.escapeAttributeValue(providedName))) {
      throw new EntitlementException(EntitlementException.INVALID_VALUE,new Object[]{""String_Node_Str"" + providedName + ""String_Node_Str""});
    }
    Privilege policy=policyParser.parsePolicy(providedName,request.getContent());
    if (isNotBlank(providedName) && !providedName.equals(policy.getName())) {
      DEBUG.error(""String_Node_Str"");
      throw new EntitlementException(EntitlementException.POLICY_NAME_MISMATCH);
    }
    policyStoreProvider.getPolicyStore(context).create(policy);
    handler.handleResult(policyResource(policy));
  }
 catch (  EntitlementException ex) {
    DEBUG.error(""String_Node_Str"" + providedName,ex);
    handler.handleError(resourceErrorHandler.handleError(request,ex));
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void createInstance(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  String providedName=null;
  try {
    providedName=request.getNewResourceId();
    Privilege policy=policyParser.parsePolicy(providedName,request.getContent());
    if (isNotBlank(providedName) && !providedName.equals(policy.getName())) {
      DEBUG.error(""String_Node_Str"");
      throw new EntitlementException(EntitlementException.POLICY_NAME_MISMATCH);
    }
    if (isBlank(providedName)) {
      providedName=policy.getName();
    }
    if (!providedName.equals(DN.escapeAttributeValue(providedName))) {
      throw new EntitlementException(EntitlementException.INVALID_VALUE,new Object[]{""String_Node_Str"" + providedName + ""String_Node_Str""});
    }
    policyStoreProvider.getPolicyStore(context).create(policy);
    handler.handleResult(policyResource(policy));
  }
 catch (  EntitlementException ex) {
    DEBUG.error(""String_Node_Str"" + providedName,ex);
    handler.handleError(resourceErrorHandler.handleError(request,ex));
  }
}"
9210,"/** 
 * Notifies the monitoring system that a rate tracker must be incremented, and the rate information recalculated.
 */
public void add(){
synchronized (this) {
    count.incrementAndGet();
  }
  rateWindow.recalculate(timer.now());
}","/** 
 * Notifies the monitoring system that a rate tracker must be incremented, and the rate information recalculated.
 */
public void add(){
  count.incrementAndGet();
  rateWindow.incrementForTimestamp(timer.now());
}"
9211,"/** 
 * Increments the cumulative count for an operation and recalculates the rate at which the operation has been made. <br/> Only synchronizes the count increment, NOT the whole method.
 */
void increment(){
  count.incrementAndGet();
  rateWindow.recalculate(timerGetter.now());
}","/** 
 * Increments the cumulative count for an operation and recalculates the rate at which the operation has been made. <br/> Only synchronizes the count increment, NOT the whole method.
 */
void increment(){
  count.incrementAndGet();
  rateWindow.incrementForTimestamp(timerGetter.now());
}"
9212,"/** 
 * Increments the cumulative count of evaluations and recalculates the rate. <br/> Only synchronizes the count increment, NOT the whole method.
 */
public void increment(){
  count.incrementAndGet();
  rateWindow.recalculate(timerGetter.now());
}","/** 
 * Increments the cumulative count of evaluations and recalculates the rate. <br/> Only synchronizes the count increment, NOT the whole method.
 */
public void increment(){
  count.incrementAndGet();
  rateWindow.incrementForTimestamp(timerGetter.now());
}"
9213,"public int compare(AtomicLong rate,AtomicLong rate2){
  return (int)(rate.get() - rate2.get());
}","@Override public int compare(AtomicLong rate,AtomicLong rate2){
  return Long.compare(rate.get(),rate2.get());
}"
9214,"/** 
 * Gets the minimum rate.
 * @return The minimum event rate.
 */
public synchronized long getMinRate(){
  if (minMaxRate.isEmpty()) {
    return 0L;
  }
  if (isAtCurrentIndex(toSampleRate(timer.now()))) {
    addNextSlot();
  }
  return new ArrayList<AtomicLong>(minMaxRate).get(0).get();
}","/** 
 * Gets the minimum rate.
 * @return The minimum event rate.
 */
public long getMinRate(){
  if (window.isEmpty()) {
    return 0L;
  }
  fillInWindow(getCurrentIndex());
  return Collections.min(window.values(),atomicLongComparator).get();
}"
9215,"/** 
 * Constructs a new instance of the RateWindow.
 * @param timer An instance of a Timer.
 * @param size The size of the window.
 * @param sampleRate The sample rate for the window.
 */
public RateWindow(final RateTimer timer,final int size,final long sampleRate){
  this.timer=timer;
  this.size=size;
  this.sampleRate=sampleRate;
  this.window=new LinkedHashMap<Long,AtomicLong>(size);
}","/** 
 * Constructs a new instance of the RateWindow.
 * @param timer An instance of a Timer.
 * @param size The size of the window.
 * @param sampleRate The sample rate for the window.
 */
public RateWindow(final RateTimer timer,final int size,final long sampleRate){
  this.timer=timer;
  this.size=size;
  this.sampleRate=sampleRate;
}"
9216,"/** 
 * Gets the maximum rate.
 * @return The maximum event rate.
 */
public synchronized long getMaxRate(){
  if (minMaxRate.isEmpty()) {
    return 0L;
  }
  if (isAtCurrentIndex(toSampleRate(timer.now()))) {
    addNextSlot();
  }
  List<AtomicLong> maxRate=new ArrayList<AtomicLong>(minMaxRate);
  return maxRate.get(maxRate.size() - 1).get();
}","/** 
 * Gets the maximum rate.
 * @return The maximum event rate.
 */
public long getMaxRate(){
  if (window.isEmpty()) {
    return 0L;
  }
  fillInWindow(getCurrentIndex());
  return Collections.max(window.values(),atomicLongComparator).get();
}"
9217,"/** 
 * Gets the average rate for the sample rate averaged across the whole window. <br/> Does not include the latest window slot if time has not passed beyond it yet as otherwise could skew the average as that time slot has not yet completed and may get more events made in it.
 * @return The average event rate.
 */
public synchronized double getAverageRate(){
  if (window.size() == 0) {
    return 0D;
  }
  double averageRate=0;
  final long now=toSampleRate(timer.now());
  for (  Map.Entry<Long,AtomicLong> entry : window.entrySet()) {
    if (isAtCurrentIndex(now) && entry.getKey().equals(currentIndex)) {
      continue;
    }
    averageRate+=entry.getValue().get();
  }
  return averageRate / window.size();
}","/** 
 * Gets the average rate for the sample rate averaged across the whole window. <br/> Does not include the latest window slot if time has not passed beyond it yet as otherwise could skew the average as that time slot has not yet completed and may get more events made in it.
 * @return The average event rate.
 */
public synchronized double getAverageRate(){
  if (window.isEmpty()) {
    return 0D;
  }
  fillInWindow(getCurrentIndex());
  double averageRate=0;
  for (  Map.Entry<Long,AtomicLong> entry : window.entrySet()) {
    if (entry.getKey().equals(getCurrentIndex())) {
      continue;
    }
    averageRate+=entry.getValue().get();
  }
  return averageRate / window.size();
}"
9218,"/** 
 * Validates the Relay State URL against a list of valid Relay State   URLs created on the hosted service provider.
 * @param orgName realm or organization name the provider resides in.
 * @param hostEntityId Entity ID of the hosted provider.
 * @param relayState Relay State URL.
 * @param role IDP/SP Role.
 * @throws SAML2Exception if the processing failed. 
 */
public static void validateRelayStateURL(String orgName,String hostEntityId,String relayState,String role) throws SAML2Exception {
  if (relayState != null) {
    if (!RELAY_STATE_VALIDATOR.isRedirectUrlValid(relayState,SAMLEntityInfo.from(orgName,hostEntityId,role))) {
      throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
    }
  }
}","/** 
 * Validates the Relay State URL against a list of valid Relay State   URLs created on the hosted service provider.
 * @param orgName realm or organization name the provider resides in.
 * @param hostEntityId Entity ID of the hosted provider.
 * @param relayState Relay State URL.
 * @param role IDP/SP Role.
 * @throws SAML2Exception if the processing failed. 
 */
public static void validateRelayStateURL(String orgName,String hostEntityId,String relayState,String role) throws SAML2Exception {
  if (relayState != null && !relayState.isEmpty()) {
    if (!RELAY_STATE_VALIDATOR.isRedirectUrlValid(relayState,SAMLEntityInfo.from(orgName,hostEntityId,role))) {
      throw new SAML2Exception(SAML2Utils.bundle.getString(""String_Node_Str""));
    }
  }
}"
9219,"/** 
 * Checks if a privilege with the specified name can be found.
 * @param name name of the privilege.
 * @throws com.sun.identity.entitlement.EntitlementException if search failed.
 */
@Override public boolean canFindByName(String name) throws EntitlementException {
  SearchFilter filter=new SearchFilter(""String_Node_Str"",name);
  return searchNames(asSet(filter)).isEmpty();
}","/** 
 * Checks if a privilege with the specified name can be found.
 * @param name name of the privilege.
 * @throws com.sun.identity.entitlement.EntitlementException if search failed.
 */
@Override public boolean canFindByName(String name) throws EntitlementException {
  SearchFilter filter=new SearchFilter(""String_Node_Str"",name);
  return !searchNames(asSet(filter)).isEmpty();
}"
9220,"/** 
 * Checks if a privilege with the specified name can be found.
 * @param name name of the privilege.
 * @throws com.sun.identity.entitlement.EntitlementException if search failed.
 */
@Override public boolean canFindByName(String name) throws EntitlementException {
  SearchFilter filter=new SearchFilter(""String_Node_Str"",name);
  return searchNames(asSet(filter)).isEmpty();
}","/** 
 * Checks if a privilege with the specified name can be found.
 * @param name name of the privilege.
 * @throws com.sun.identity.entitlement.EntitlementException if search failed.
 */
@Override public boolean canFindByName(String name) throws EntitlementException {
  SearchFilter filter=new SearchFilter(""String_Node_Str"",name);
  return !searchNames(asSet(filter)).isEmpty();
}"
9221,"@Test public void shouldNotStoreSecondaryKeyIfNull(){
  SAMLToken samlToken=new SAMLToken(""String_Node_Str"",null,12345,""String_Node_Str"");
  given(tokenIdFactory.toSAMLPrimaryTokenId(anyString())).willReturn(""String_Node_Str"");
  given(serialisation.serialise(anyObject())).willReturn(""String_Node_Str"");
  Token token=adapter.toToken(samlToken);
  assertThat(token.getValue(SAMLTokenField.SECONDARY_KEY.getField())).isNull();
}","@Test public void shouldNotStoreSecondaryKeyIfNull(){
  SAMLToken samlToken=new SAMLToken(""String_Node_Str"",null,12345,""String_Node_Str"");
  given(tokenIdFactory.toSAMLPrimaryTokenId(anyString())).willReturn(""String_Node_Str"");
  given(serialisation.serialise(anyObject())).willReturn(""String_Node_Str"");
  Token token=adapter.toToken(samlToken);
  assertThat(token.<String>getValue(SAMLTokenField.SECONDARY_KEY.getField())).isNull();
}"
9222,"public void shouldAssignSessionHandle(){
  long timestamp=12345l;
  InternalSession mockSession=mock(InternalSession.class);
  SessionID mockSessionID=mock(SessionID.class);
  String sessionId=""String_Node_Str"";
  String sessionHandle=SessionService.SHANDLE_SCHEME_PREFIX + ""String_Node_Str"";
  given(mockSessionID.toString()).willReturn(sessionId);
  given(jsonSerialisation.deserialise(anyString(),any(Class.class))).willReturn(mockSession);
  given(mockSession.getExpirationTime()).willReturn(timestamp);
  given(mockSession.getID()).willReturn(mockSessionID);
  given(mockSession.getSessionHandle()).willReturn(sessionHandle);
  given(tokenIdFactory.toSessionTokenId(eq(mockSession))).willReturn(sessionId);
  given(jsonSerialisation.serialise(any())).willReturn(""String_Node_Str"");
  Token token=adapter.toToken(mockSession);
  assertThat(token.getValue(SessionTokenField.SESSION_HANDLE.getField())).isEqualTo(sessionHandle);
}","public void shouldAssignSessionHandle(){
  long timestamp=12345l;
  InternalSession mockSession=mock(InternalSession.class);
  SessionID mockSessionID=mock(SessionID.class);
  String sessionId=""String_Node_Str"";
  String sessionHandle=SessionService.SHANDLE_SCHEME_PREFIX + ""String_Node_Str"";
  given(mockSessionID.toString()).willReturn(sessionId);
  given(jsonSerialisation.deserialise(anyString(),any(Class.class))).willReturn(mockSession);
  given(mockSession.getExpirationTime()).willReturn(timestamp);
  given(mockSession.getID()).willReturn(mockSessionID);
  given(mockSession.getSessionHandle()).willReturn(sessionHandle);
  given(tokenIdFactory.toSessionTokenId(eq(mockSession))).willReturn(sessionId);
  given(jsonSerialisation.serialise(any())).willReturn(""String_Node_Str"");
  Token token=adapter.toToken(mockSession);
  assertThat(token.<String>getValue(SessionTokenField.SESSION_HANDLE.getField())).isEqualTo(sessionHandle);
}"
9223,"@Test public void shouldAssignSessionID(){
  long timestamp=12345l;
  InternalSession mockSession=mock(InternalSession.class);
  SessionID mockSessionID=mock(SessionID.class);
  String sessionId=""String_Node_Str"";
  String sessionHandle=SessionService.SHANDLE_SCHEME_PREFIX + ""String_Node_Str"";
  given(mockSessionID.toString()).willReturn(sessionId);
  given(jsonSerialisation.deserialise(anyString(),any(Class.class))).willReturn(mockSession);
  given(mockSession.getExpirationTime()).willReturn(timestamp);
  given(mockSession.getID()).willReturn(mockSessionID);
  given(mockSession.getSessionHandle()).willReturn(sessionHandle);
  given(tokenIdFactory.toSessionTokenId(eq(mockSession))).willReturn(sessionId);
  given(jsonSerialisation.serialise(any())).willReturn(""String_Node_Str"");
  Token token=adapter.toToken(mockSession);
  assertThat(token.getValue(SessionTokenField.SESSION_ID.getField())).isEqualTo(sessionId);
}","@Test public void shouldAssignSessionID(){
  long timestamp=12345l;
  InternalSession mockSession=mock(InternalSession.class);
  SessionID mockSessionID=mock(SessionID.class);
  String sessionId=""String_Node_Str"";
  String sessionHandle=SessionService.SHANDLE_SCHEME_PREFIX + ""String_Node_Str"";
  given(mockSessionID.toString()).willReturn(sessionId);
  given(jsonSerialisation.deserialise(anyString(),any(Class.class))).willReturn(mockSession);
  given(mockSession.getExpirationTime()).willReturn(timestamp);
  given(mockSession.getID()).willReturn(mockSessionID);
  given(mockSession.getSessionHandle()).willReturn(sessionHandle);
  given(tokenIdFactory.toSessionTokenId(eq(mockSession))).willReturn(sessionId);
  given(jsonSerialisation.serialise(any())).willReturn(""String_Node_Str"");
  Token token=adapter.toToken(mockSession);
  assertThat(token.<String>getValue(SessionTokenField.SESSION_ID.getField())).isEqualTo(sessionId);
}"
9224,"@Test public void shouldContainNewFieldInCopyConstructor(){
  String id=""String_Node_Str"";
  CoreTokenField field=CoreTokenField.TOKEN_ID;
  PartialToken first=new PartialToken(Collections.<CoreTokenField,Object>emptyMap());
  PartialToken clone=new PartialToken(first,field,id);
  assertThat(clone.getValue(field)).isEqualTo(id);
}","@Test public void shouldContainNewFieldInCopyConstructor(){
  String id=""String_Node_Str"";
  CoreTokenField field=CoreTokenField.TOKEN_ID;
  PartialToken first=new PartialToken(Collections.<CoreTokenField,Object>emptyMap());
  PartialToken clone=new PartialToken(first,field,id);
  assertThat(clone.<String>getValue(field)).isEqualTo(id);
}"
9225,"/** 
 * Audits an attempted REST request, indicating which resource was accessed using which method linked to the SSOToken of the accessing user.
 * @param resource The accessed resource.
 * @param action The CREST action-type requested.
 * @param token The SSO token of the accessing user.
 */
public void auditAccessMessage(String resource,String action,SSOToken token){
  if (accessLogger != null && msgProvider != null) {
    final LogRecord record=msgProvider.createLogRecord(""String_Node_Str"",new String[]{resource,action},token);
    if (record != null) {
      accessLogger.log(record,AccessController.doPrivileged(AdminTokenAction.getInstance()));
    }
  }
}","/** 
 * Audits an attempted REST request, indicating which resource was accessed using which method linked to the SSOToken of the accessing user.
 * @param resource The accessed resource.
 * @param action The CREST action-type requested.
 * @param token The SSO token of the accessing user (null if XUI)
 */
public void auditAccessMessage(String resource,String action,SSOToken token){
  if (accessLogger != null && msgProvider != null) {
    final LogRecord record=msgProvider.createLogRecord(""String_Node_Str"",new String[]{resource,action},token);
    if (record != null) {
      accessLogger.log(record,AccessController.doPrivileged(AdminTokenAction.getInstance()));
    }
  }
}"
9226,"/** 
 * Retrieves a link to the user's SSO Token, if it exists in the context.
 * @param context from which to pull the SSO Token
 */
public static SSOToken getTokenFromContext(ServerContext context){
  SSOToken userToken=null;
  if (!context.containsContext(SSOTokenContext.class)) {
    context=new SSOTokenContext(context);
  }
  SSOTokenContext ssoTokenContext=context.asContext(SSOTokenContext.class);
  try {
    userToken=ssoTokenContext.getCallerSSOToken();
  }
 catch (  SSOException e) {
  }
  return userToken;
}","/** 
 * Retrieves a link to the user's SSO Token, if it exists in the context.
 * @param context from which to pull the SSO Token
 */
public static SSOToken getTokenFromContext(ServerContext context,Debug debug){
  SSOToken userToken=null;
  if (!context.containsContext(SSOTokenContext.class)) {
    context=new SSOTokenContext(context);
  }
  SSOTokenContext ssoTokenContext=context.asContext(SSOTokenContext.class);
  try {
    userToken=ssoTokenContext.getCallerSSOToken();
  }
 catch (  SSOException e) {
    debug.message(""String_Node_Str"",e);
  }
  return userToken;
}"
9227,"@Override public Promise<AuthorizationResult,ResourceException> authorizeUpdate(ServerContext serverContext,UpdateRequest updateRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getUpdateString(updateRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext),module.authorizeUpdate(serverContext,updateRequest),moduleName);
}","@Override public Promise<AuthorizationResult,ResourceException> authorizeUpdate(ServerContext serverContext,UpdateRequest updateRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getUpdateString(updateRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext,debug),module.authorizeUpdate(serverContext,updateRequest),moduleName);
}"
9228,"@Override public Promise<AuthorizationResult,ResourceException> authorizeQuery(ServerContext serverContext,QueryRequest queryRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getQueryString(queryRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext),module.authorizeQuery(serverContext,queryRequest),moduleName);
}","@Override public Promise<AuthorizationResult,ResourceException> authorizeQuery(ServerContext serverContext,QueryRequest queryRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getQueryString(queryRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext,debug),module.authorizeQuery(serverContext,queryRequest),moduleName);
}"
9229,"Promise<AuthorizationResult,ResourceException> log(String resource,String action,SSOToken token,Promise<AuthorizationResult,ResourceException> result,String authZModule){
  try {
    if (!result.get().isAuthorized()) {
      restLog.auditAccessDenied(resource,action,authZModule,token);
    }
 else {
      restLog.auditAccessGranted(resource,action,authZModule,token);
    }
  }
 catch (  ExecutionException e) {
    debug.error(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    debug.error(""String_Node_Str"",e);
  }
  return result;
}","Promise<AuthorizationResult,ResourceException> log(String resource,String action,SSOToken token,Promise<AuthorizationResult,ResourceException> result,String authZModule){
  try {
    if (!result.get().isAuthorized()) {
      restLog.auditAccessDenied(resource,action,authZModule,token);
    }
 else {
      restLog.auditAccessGranted(resource,action,authZModule,token);
    }
  }
 catch (  ExecutionException e) {
    debug.message(e.getMessage());
  }
catch (  InterruptedException e) {
    debug.message(e.getMessage());
  }
  return result;
}"
9230,"@Override public Promise<AuthorizationResult,ResourceException> authorizePatch(ServerContext serverContext,PatchRequest patchRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getPatchString(patchRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext),module.authorizePatch(serverContext,patchRequest),moduleName);
}","@Override public Promise<AuthorizationResult,ResourceException> authorizePatch(ServerContext serverContext,PatchRequest patchRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getPatchString(patchRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext,debug),module.authorizePatch(serverContext,patchRequest),moduleName);
}"
9231,"@Override public Promise<AuthorizationResult,ResourceException> authorizeCreate(ServerContext serverContext,CreateRequest createRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getCreateString(createRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext),module.authorizeCreate(serverContext,createRequest),moduleName);
}","@Override public Promise<AuthorizationResult,ResourceException> authorizeCreate(ServerContext serverContext,CreateRequest createRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getCreateString(createRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext,debug),module.authorizeCreate(serverContext,createRequest),moduleName);
}"
9232,"@Override public Promise<AuthorizationResult,ResourceException> authorizeAction(ServerContext serverContext,ActionRequest actionRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getActionString(actionRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext),module.authorizeAction(serverContext,actionRequest),moduleName);
}","@Override public Promise<AuthorizationResult,ResourceException> authorizeAction(ServerContext serverContext,ActionRequest actionRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getActionString(actionRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext,debug),module.authorizeAction(serverContext,actionRequest),moduleName);
}"
9233,"@Override public Promise<AuthorizationResult,ResourceException> authorizeRead(ServerContext serverContext,ReadRequest readRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getReadString(readRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext),module.authorizeRead(serverContext,readRequest),moduleName);
}","@Override public Promise<AuthorizationResult,ResourceException> authorizeRead(ServerContext serverContext,ReadRequest readRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getReadString(readRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext,debug),module.authorizeRead(serverContext,readRequest),moduleName);
}"
9234,"@Override public Promise<AuthorizationResult,ResourceException> authorizeDelete(ServerContext serverContext,DeleteRequest deleteRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getDeleteString(deleteRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext),module.authorizeDelete(serverContext,deleteRequest),moduleName);
}","@Override public Promise<AuthorizationResult,ResourceException> authorizeDelete(ServerContext serverContext,DeleteRequest deleteRequest){
  final String resource=ServerContextUtils.getMatchedUri(serverContext);
  final String action=ServerContextUtils.getDeleteString(deleteRequest);
  return log(resource,action,ServerContextUtils.getTokenFromContext(serverContext,debug),module.authorizeDelete(serverContext,deleteRequest),moduleName);
}"
9235,"/** 
 * Pushes off to our logging subsystem.
 */
private void logAccess(String resource,String operation,ServerContext context){
  if (!context.containsContext(SSOTokenContext.class)) {
    context=new SSOTokenContext(context);
  }
  SSOTokenContext ssoTokenContext=context.asContext(SSOTokenContext.class);
  try {
    restLog.auditAccessMessage(resource,operation,ssoTokenContext.getCallerSSOToken());
  }
 catch (  SSOException e) {
    if (debug.errorEnabled()) {
      debug.error(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  restLog.debugOperationAttemptAsPrincipal(resource,operation,context,null,debug);
}","/** 
 * Pushes off to our logging subsystem.
 */
private void logAccess(String resource,String operation,ServerContext context){
  if (!context.containsContext(SSOTokenContext.class)) {
    context=new SSOTokenContext(context);
  }
  SSOTokenContext ssoTokenContext=context.asContext(SSOTokenContext.class);
  try {
    restLog.auditAccessMessage(resource,operation,ssoTokenContext.getCallerSSOToken());
  }
 catch (  SSOException e) {
    if (debug.warningEnabled()) {
      debug.warning(""String_Node_Str"" + ""String_Node_Str"",e);
      restLog.auditAccessMessage(resource,operation,null);
    }
  }
  restLog.debugOperationAttemptAsPrincipal(resource,operation,context,null,debug);
}"
9236,"/** 
 * {@inheritDoc}
 */
public Map<String,Object> extraDataToReturnForTokenEndpoint(Map<String,String> parameters,CoreToken token){
  final Map<String,Object> map=new HashMap<String,Object>();
  final Set<String> scope=token.getScope();
  if (scope != null && scope.contains(""String_Node_Str"")) {
    final Map.Entry<String,String> tokenEntry;
    try {
      tokenEntry=openIDTokenIssuer.issueToken(new AccessTokenToLegacyAdapter(token),requestFactory.create(Request.getCurrent()));
    }
 catch (    ServerException e) {
      throw OAuthProblemException.OAuthError.SERVER_ERROR.handle(null,e.getMessage());
    }
catch (    InvalidClientException e) {
      throw OAuthProblemException.OAuthError.INVALID_CLIENT.handle(null,e.getMessage());
    }
catch (    InvalidGrantException e) {
      throw OAuthProblemException.OAuthError.INVALID_GRANT.handle(null,e.getMessage());
    }
    if (tokenEntry != null) {
      map.put(tokenEntry.getKey(),tokenEntry.getValue());
    }
  }
  return map;
}","/** 
 * {@inheritDoc}
 */
public Map<String,Object> extraDataToReturnForTokenEndpoint(Map<String,String> parameters,CoreToken token){
  final Map<String,Object> map=new HashMap<String,Object>();
  final Set<String> scope=token.getScope();
  if (scope != null && scope.contains(OPENID_SCOPE)) {
    final Map.Entry<String,String> tokenEntry;
    try {
      tokenEntry=openIDTokenIssuer.issueToken(new AccessTokenToLegacyAdapter(token),requestFactory.create(Request.getCurrent()));
    }
 catch (    ServerException e) {
      throw OAuthProblemException.OAuthError.SERVER_ERROR.handle(null,e.getMessage());
    }
catch (    InvalidClientException e) {
      throw OAuthProblemException.OAuthError.INVALID_CLIENT.handle(null,e.getMessage());
    }
catch (    InvalidGrantException e) {
      throw OAuthProblemException.OAuthError.INVALID_GRANT.handle(null,e.getMessage());
    }
    if (tokenEntry != null) {
      map.put(tokenEntry.getKey(),tokenEntry.getValue());
    }
  }
  return map;
}"
9237,"/** 
 * {@inheritDoc}
 */
public Map<String,Object> getUserInfo(CoreToken token){
  Set<String> scopes=token.getScope();
  Map<String,Object> response=new HashMap<String,Object>();
  AMIdentity id=null;
  try {
    id=identityManager.getResourceOwnerIdentity(token.getUserID(),token.getRealm());
  }
 catch (  UnauthorizedClientException e) {
    throw OAuthProblemException.OAuthError.UNAUTHORIZED_CLIENT.handle(null,e.getMessage());
  }
  response.put(""String_Node_Str"",token.getUserID());
  for (  String scope : scopes) {
    Object attributes=scopeToUserUserProfileAttributes.get(scope);
    if (attributes == null) {
      logger.error(""String_Node_Str"" + scope);
    }
 else     if (attributes instanceof String) {
      Set<String> attr=null;
      try {
        attr=id.getAttribute((String)attributes);
      }
 catch (      IdRepoException e) {
        logger.error(""String_Node_Str"",e);
      }
catch (      SSOException e) {
        logger.error(""String_Node_Str"",e);
      }
      if (attr != null && attr.size() == 1) {
        response.put(scope,attr.iterator().next());
      }
 else       if (attr != null && attr.size() > 1) {
        response.put(scope,attr);
      }
 else {
        logger.error(""String_Node_Str"" + scope);
      }
    }
 else     if (attributes instanceof Map) {
      if (attributes != null && !((Map<String,String>)attributes).isEmpty()) {
        for (        Map.Entry<String,String> entry : ((Map<String,String>)attributes).entrySet()) {
          String attribute;
          attribute=entry.getValue();
          Set<String> attr=null;
          try {
            attr=id.getAttribute(attribute);
          }
 catch (          IdRepoException e) {
            logger.error(""String_Node_Str"",e);
          }
catch (          SSOException e) {
            logger.error(""String_Node_Str"",e);
          }
          if (attr != null && attr.size() == 1) {
            response.put(entry.getKey(),attr.iterator().next());
          }
 else           if (attr != null && attr.size() > 1) {
            response.put(entry.getKey(),attr);
          }
 else {
            logger.error(""String_Node_Str"" + scope);
          }
        }
      }
    }
  }
  return response;
}","/** 
 * {@inheritDoc}
 */
public Map<String,Object> getUserInfo(CoreToken token){
  Set<String> scopes=token.getScope();
  Map<String,Object> response=new HashMap<String,Object>();
  AMIdentity id=null;
  try {
    id=identityManager.getResourceOwnerIdentity(token.getUserID(),token.getRealm());
  }
 catch (  UnauthorizedClientException e) {
    throw OAuthProblemException.OAuthError.UNAUTHORIZED_CLIENT.handle(null,e.getMessage());
  }
  response.put(""String_Node_Str"",token.getUserID());
  for (  String scope : scopes) {
    if (OPENID_SCOPE.equals(scope)) {
      continue;
    }
    Object attributes=scopeToUserUserProfileAttributes.get(scope);
    if (attributes == null) {
      logger.error(""String_Node_Str"" + scope);
    }
 else     if (attributes instanceof String) {
      Set<String> attr=null;
      try {
        attr=id.getAttribute((String)attributes);
      }
 catch (      IdRepoException e) {
        logger.warning(""String_Node_Str"" + attributes,e);
      }
catch (      SSOException e) {
        logger.warning(""String_Node_Str"" + attributes,e);
      }
      if (attr != null && attr.size() == 1) {
        response.put(scope,attr.iterator().next());
      }
 else       if (attr != null && attr.size() > 1) {
        response.put(scope,attr);
      }
 else {
        logger.warning(""String_Node_Str"" + attributes + ""String_Node_Str""+ scope);
      }
    }
 else     if (attributes instanceof Map) {
      if (attributes != null && !((Map<String,String>)attributes).isEmpty()) {
        for (        Map.Entry<String,String> entry : ((Map<String,String>)attributes).entrySet()) {
          String attribute;
          attribute=entry.getValue();
          Set<String> attr=null;
          try {
            attr=id.getAttribute(attribute);
          }
 catch (          IdRepoException e) {
            logger.warning(""String_Node_Str"",e);
          }
catch (          SSOException e) {
            logger.warning(""String_Node_Str"",e);
          }
          if (attr != null && attr.size() == 1) {
            response.put(entry.getKey(),attr.iterator().next());
          }
 else           if (attr != null && attr.size() > 1) {
            response.put(entry.getKey(),attr);
          }
 else {
            logger.warning(""String_Node_Str"" + scope);
          }
        }
      }
    }
  }
  return response;
}"
9238,"/** 
 * Perform any necessary session cleanup after authentication has completed. In the case of successful session upgrade, this will destroy the original session in favour of the new (upgraded) session. In the case of force-auth mode, this will destroy the new session in favour of the old (now upgraded) session. In the case of authentication failure the new session will always be destroyed. For failed session upgrade, the original session is restored. Otherwise, any existing session is also destroyed on authentication failure.
 */
public void cleanup(){
  if (isFailed()) {
    DEBUG.message(""String_Node_Str"");
    authContext.destroySession();
    if (authContext.isSessionUpgrade()) {
      DEBUG.message(""String_Node_Str"");
      authContext.restoreOldSession();
    }
 else {
      authContext.destroyOldSession();
    }
  }
 else   if (isSuccessful()) {
    if (authContext.isForceAuth()) {
      DEBUG.message(""String_Node_Str"");
      authContext.destroySession();
      authContext.restoreOldSession();
    }
 else     if (authContext.isSessionUpgrade() && SystemProperties.getAsBoolean(Constants.DESTROY_SESSION_AFTER_UPGRADE)) {
      DEBUG.message(""String_Node_Str"");
      authContext.destroyOldSession();
    }
  }
}","/** 
 * Perform any necessary session cleanup after authentication has completed. In the case of successful session upgrade, this will destroy the original session in favour of the new (upgraded) session. In the case of force-auth mode, this will destroy the new session in favour of the old (now upgraded) session. In the case of authentication failure the new session will always be destroyed. For failed session upgrade, the original session is restored. Otherwise, any existing session is also destroyed on authentication failure.
 */
public void cleanup(){
  if (isFailed()) {
    DEBUG.message(""String_Node_Str"");
    authContext.destroySession();
    if (authContext.isSessionUpgrade()) {
      DEBUG.message(""String_Node_Str"");
      authContext.restoreOldSession();
    }
 else {
      authContext.destroyOldSession();
    }
  }
 else   if (isSuccessful()) {
    if (authContext.isForceAuth()) {
      DEBUG.message(""String_Node_Str"");
      authContext.destroySession();
      authContext.restoreOldSession();
    }
 else     if (authContext.hasOldSession() && SystemProperties.getAsBoolean(Constants.DESTROY_SESSION_AFTER_UPGRADE)) {
      DEBUG.message(""String_Node_Str"");
      authContext.destroyOldSession();
    }
  }
}"
9239,"@Test public void shouldDestroyOldSessionAfterSessionUpgrade(){
  System.setProperty(Constants.DESTROY_SESSION_AFTER_UPGRADE,""String_Node_Str"");
  given(authContext.getStatus()).willReturn(AuthContext.Status.SUCCESS);
  given(authContext.isSessionUpgrade()).willReturn(true);
  loginProcess.cleanup();
  verify(authContext).destroyOldSession();
}","@Test public void shouldDestroyOldSessionAfterSessionUpgrade(){
  System.setProperty(Constants.DESTROY_SESSION_AFTER_UPGRADE,""String_Node_Str"");
  given(authContext.getStatus()).willReturn(AuthContext.Status.SUCCESS);
  given(authContext.hasOldSession()).willReturn(true);
  loginProcess.cleanup();
  verify(authContext).destroyOldSession();
}"
9240,"/** 
 * Sets mime headers in HTTP servlet response.
 * @param headers mime headers to be set.
 * @param res HTTP servlet response.
 */
public static void putHeaders(MimeHeaders headers,HttpServletResponse res){
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + headers.toString());
  }
  Iterator it=headers.getAllHeaders();
  while (it.hasNext()) {
    MimeHeader header=(MimeHeader)it.next();
    String[] values=headers.getHeader(header.getName());
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"" + header.getName() + ""String_Node_Str""+ values);
    }
    if (values.length == 1) {
      res.setHeader(header.getName(),header.getValue());
    }
 else {
      StringBuffer concat=new StringBuffer();
      int i=0;
      while (i < values.length) {
        if (i != 0) {
          concat.append(',');
        }
        concat.append(values[i++]);
      }
      res.setHeader(header.getName(),concat.toString());
    }
  }
}","/** 
 * Sets mime headers in HTTP servlet response.
 * @param headers mime headers to be set.
 * @param res HTTP servlet response.
 */
public static void putHeaders(MimeHeaders headers,HttpServletResponse res){
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + headers.toString());
  }
  Iterator it=headers.getAllHeaders();
  while (it.hasNext()) {
    MimeHeader header=(MimeHeader)it.next();
    String[] values=headers.getHeader(header.getName());
    if (debug.messageEnabled()) {
      debug.message(""String_Node_Str"" + header.getName() + ""String_Node_Str""+ Arrays.toString(values));
    }
    if (values.length == 1) {
      res.setHeader(header.getName(),header.getValue());
    }
 else {
      StringBuffer concat=new StringBuffer();
      int i=0;
      while (i < values.length) {
        if (i != 0) {
          concat.append(',');
        }
        concat.append(values[i++]);
      }
      res.setHeader(header.getName(),concat.toString());
    }
  }
}"
9241,"/** 
 * Checks certificate validity with configured CRL 
 * @param cert x509 certificate 
 * @return <code>true</code> if the certificate is not in CRL, otherwise, return <code>false</code> 
 */
public static boolean validateCertificate(X509Certificate cert){
  String method=""String_Node_Str"";
  boolean certgood=true;
  if (checkCertStatus == false) {
    if (debug.messageEnabled()) {
      debug.message(method + ""String_Node_Str"");
    }
    return certgood=true;
  }
  certgood=CRLValidator.validateCertificate(cert,checkCAStatus);
  if (debug.messageEnabled()) {
    debug.message(method + ""String_Node_Str"" + certgood);
  }
  return certgood;
}","/** 
 * Checks certificate validity with configured CRL 
 * @param cert x509 certificate 
 * @return <code>true</code> if the certificate is not in CRL, otherwise, return <code>false</code> 
 */
public static boolean validateCertificate(X509Certificate cert){
  String method=""String_Node_Str"";
  boolean certgood=true;
  if (checkCertStatus == false) {
    if (debug.messageEnabled()) {
      debug.message(method + ""String_Node_Str"");
    }
    return certgood;
  }
  certgood=CRLValidator.validateCertificate(cert,checkCAStatus);
  if (debug.messageEnabled()) {
    debug.message(method + ""String_Node_Str"" + certgood);
  }
  return certgood;
}"
9242,"/** 
 * {@inheritDoc}
 */
@Override public int process(Callback[] callbacks,int state) throws LoginException {
switch (state) {
case STATE_BEGIN:
    if (!clientSideScriptEnabled) {
      clientSideScript=""String_Node_Str"";
    }
  substituteUIStrings();
return STATE_RUN_SCRIPT;
case STATE_RUN_SCRIPT:
Bindings scriptVariables=new SimpleBindings();
scriptVariables.put(""String_Node_Str"",getScriptHttpRequestWrapper());
scriptVariables.put(LOGGER_VARIABLE_NAME,DEBUG);
scriptVariables.put(STATE_VARIABLE_NAME,state);
scriptVariables.put(USERNAME_VARIABLE_NAME,userName);
scriptVariables.put(SUCCESS_ATTR_NAME,SUCCESS_VALUE);
scriptVariables.put(FAILED_ATTR_NAME,FAILURE_VALUE);
scriptVariables.put(HTTP_CLIENT_VARIABLE_NAME,httpClient);
scriptVariables.put(HTTP_CLIENT_REQUEST_VARIABLE_NAME,httpClientRequest);
scriptVariables.put(IDENTITY_REPOSITORY,identityRepository);
try {
scriptEvaluator.evaluateScript(serverSideScript,scriptVariables);
}
 catch (ScriptException e) {
DEBUG.message(""String_Node_Str"",e);
throw new AuthLoginException(""String_Node_Str"");
}
state=((Number)scriptVariables.get(STATE_VARIABLE_NAME)).intValue();
userName=(String)scriptVariables.get(USERNAME_VARIABLE_NAME);
if (state != SUCCESS_VALUE) {
throw new AuthLoginException(""String_Node_Str"");
}
return state;
default :
throw new AuthLoginException(""String_Node_Str"");
}
}","/** 
 * {@inheritDoc}
 */
@Override public int process(Callback[] callbacks,int state) throws LoginException {
switch (state) {
case STATE_BEGIN:
    if (!clientSideScriptEnabled || clientSideScript.isEmpty()) {
      clientSideScript=""String_Node_Str"";
    }
  substituteUIStrings();
return STATE_RUN_SCRIPT;
case STATE_RUN_SCRIPT:
Bindings scriptVariables=new SimpleBindings();
scriptVariables.put(""String_Node_Str"",getScriptHttpRequestWrapper());
scriptVariables.put(LOGGER_VARIABLE_NAME,DEBUG);
scriptVariables.put(STATE_VARIABLE_NAME,state);
scriptVariables.put(USERNAME_VARIABLE_NAME,userName);
scriptVariables.put(SUCCESS_ATTR_NAME,SUCCESS_VALUE);
scriptVariables.put(FAILED_ATTR_NAME,FAILURE_VALUE);
scriptVariables.put(HTTP_CLIENT_VARIABLE_NAME,httpClient);
scriptVariables.put(HTTP_CLIENT_REQUEST_VARIABLE_NAME,httpClientRequest);
scriptVariables.put(IDENTITY_REPOSITORY,identityRepository);
try {
scriptEvaluator.evaluateScript(serverSideScript,scriptVariables);
}
 catch (ScriptException e) {
DEBUG.message(""String_Node_Str"",e);
throw new AuthLoginException(""String_Node_Str"");
}
state=((Number)scriptVariables.get(STATE_VARIABLE_NAME)).intValue();
userName=(String)scriptVariables.get(USERNAME_VARIABLE_NAME);
if (state != SUCCESS_VALUE) {
throw new AuthLoginException(""String_Node_Str"");
}
return state;
default :
throw new AuthLoginException(""String_Node_Str"");
}
}"
9243,"/** 
 * Returns the authentication level of the authentication method used for for authentication.
 * @return The authentication level.
 * @throws SSOException if the SSOToken is not VALID or ifthere are errors in getting the authentication level.
 */
public int getAuthLevel() throws SSOException {
  checkTokenType(""String_Node_Str"");
  try {
    String authLevelFull=SSOSession.getProperty(""String_Node_Str"");
    int indexOfStartOfIntegerPart=0;
    if (authLevelFull.contains(""String_Node_Str"")) {
      indexOfStartOfIntegerPart=authLevelFull.lastIndexOf(""String_Node_Str"") + 1;
    }
    String authLevelInteger=authLevelFull.substring(indexOfStartOfIntegerPart);
    return (new Integer(authLevelInteger)).intValue();
  }
 catch (  Exception e) {
    SSOProviderImpl.debug.error(""String_Node_Str"");
    throw new SSOException(e);
  }
}","/** 
 * Returns the authentication level of the authentication method used for for authentication.
 * @return The authentication level.
 * @throws SSOException if the SSOToken is not VALID or ifthere are errors in getting the authentication level.
 */
public int getAuthLevel() throws SSOException {
  checkTokenType(""String_Node_Str"");
  try {
    String authLevelFull=SSOSession.getProperty(""String_Node_Str"");
    int indexOfStartOfIntegerPart=authLevelFull.lastIndexOf(""String_Node_Str"") + 1;
    String authLevelInteger=authLevelFull.substring(indexOfStartOfIntegerPart);
    return Integer.valueOf(authLevelInteger);
  }
 catch (  Exception e) {
    SSOProviderImpl.debug.error(""String_Node_Str"");
    throw new SSOException(e);
  }
}"
9244,"/** 
 * Returns the authentication level of the authentication method used for for authentication.
 * @return The authentication level.
 * @throws SSOException if the SSOToken is not VALID or ifthere are errors in getting the authentication level.
 */
public int getAuthLevel() throws SSOException {
  checkTokenType(""String_Node_Str"");
  try {
    return ((new Integer(SSOSession.getProperty(""String_Node_Str""))).intValue());
  }
 catch (  Exception e) {
    SSOProviderImpl.debug.error(""String_Node_Str"");
    throw new SSOException(e);
  }
}","/** 
 * Returns the authentication level of the authentication method used for for authentication.
 * @return The authentication level.
 * @throws SSOException if the SSOToken is not VALID or ifthere are errors in getting the authentication level.
 */
public int getAuthLevel() throws SSOException {
  checkTokenType(""String_Node_Str"");
  try {
    String authLevelFull=SSOSession.getProperty(""String_Node_Str"");
    int indexOfStartOfIntegerPart=0;
    if (authLevelFull.contains(""String_Node_Str"")) {
      indexOfStartOfIntegerPart=authLevelFull.lastIndexOf(""String_Node_Str"") + 1;
    }
    String authLevelInteger=authLevelFull.substring(indexOfStartOfIntegerPart);
    return (new Integer(authLevelInteger)).intValue();
  }
 catch (  Exception e) {
    SSOProviderImpl.debug.error(""String_Node_Str"");
    throw new SSOException(e);
  }
}"
9245,"@Override public BearerToken verify(BearerToken token) throws OAuthProblemException {
  Reference reference=new Reference(validationServerRef);
  reference.addQueryParameter(OAuth2Constants.Params.ACCESS_TOKEN,token.getTokenID());
  Client client=new Client(new Context(),Protocol.HTTP);
  ClientResource clientResource=new ClientResource(reference.toUri());
  clientResource.setNext(client);
  clientResource.get();
  try {
    Response response=clientResource.getResponse();
    Map remoteToken=BearerTokenExtractor.extractToken(response);
    Object o=remoteToken.get(OAuth2Constants.Token.OAUTH_ACCESS_TOKEN);
    if (o != null) {
      return (BearerToken)tokenStore.readAccessToken(o.toString());
    }
    return null;
  }
 catch (  OAuthProblemException e) {
    OAuth2Utils.DEBUG.error(""String_Node_Str"",e);
    throw e;
  }
catch (  ResourceException e) {
    OAuth2Utils.DEBUG.error(""String_Node_Str"",e);
    throw OAuthProblemException.OAuthError.ACCESS_DENIED.handle(null,e.getMessage());
  }
}","@Override public BearerToken verify(BearerToken token) throws OAuthProblemException {
  Reference reference=new Reference(validationServerRef);
  reference.addQueryParameter(OAuth2Constants.Params.ACCESS_TOKEN,token.getTokenID());
  Client client=new Client(new Context(),Protocol.HTTP);
  ClientResource clientResource=new ClientResource(reference.toUri());
  clientResource.setNext(client);
  clientResource.get();
  try {
    Response response=clientResource.getResponse();
    Map remoteToken=BearerTokenExtractor.extractToken(response);
    Object o=remoteToken.get(OAuth2Constants.Token.OAUTH_ACCESS_TOKEN);
    if (o != null) {
      return (BearerToken)tokenStore.readAccessToken(o.toString());
    }
    return null;
  }
 catch (  OAuthProblemException e) {
    OAuth2Utils.DEBUG.error(""String_Node_Str"",e);
    throw e;
  }
catch (  ResourceException e) {
    OAuth2Utils.DEBUG.error(""String_Node_Str"",e);
    throw OAuthProblemException.OAuthError.ACCESS_DENIED.handle(null,e.getMessage());
  }
 finally {
    if (client != null) {
      try {
        client.stop();
      }
 catch (      Exception e) {
        OAuth2Utils.DEBUG.error(""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
  }
}"
9246,"/** 
 * Handles both initial and subsequent RESTful calls from clients submitting Callbacks for the authentication process to continue. This is determined by checking if the POST body is empty or not. If it is empty then this is initiating the authentication process otherwise it is a subsequent call submitting Callbacks. Initiating authentication request using the query parameters from the URL starts the login process and either returns an SSOToken on successful authentication or a number of Callbacks needing to be completed before authentication can proceed or an exception if any problems occurred whilst trying to authenticate. Using the body of the POST request the method continues the login process, submitting the given Callbacks and then either returns an SSOToken on successful authentication or a number of additional Callbacks needing to be completed before authentication can proceed or an exception if any problems occurred whilst trying to authenticate.
 * @param entity The Json Representation of the post body of the request.
 * @return A Json Representation of the response body. The response will contain either a JSON object containing theSSOToken id from a successful authentication, a JSON object containing a number of Callbacks for the client to complete and return or a JSON object containing an exception message.
 * @throws ResourceException If there is an error processing the authentication request.
 */
@Post public Representation authenticate(JsonRepresentation entity) throws ResourceException {
  if (entity != null && !MediaType.APPLICATION_JSON.equals(entity.getMediaType())) {
    throw new ResourceException(Status.CLIENT_ERROR_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"");
  }
  final HttpServletRequest request=getHttpServletRequest();
  final HttpServletResponse response=ServletUtils.getResponse(getResponse());
  final Map<String,String> queryString=getReference().getQueryAsForm().getValuesMap();
  final String sessionUpgradeSSOTokenId=queryString.get(""String_Node_Str"");
  try {
    JsonValue jsonContent=getJsonContent(entity);
    JsonValue jsonResponse;
    if (jsonContent != null && jsonContent.size() > 0) {
      jsonResponse=restAuthenticationHandler.continueAuthentication(request,response,jsonContent,sessionUpgradeSSOTokenId);
    }
 else {
      final String authIndexType=queryString.get(""String_Node_Str"");
      final String authIndexValue=queryString.get(""String_Node_Str"");
      jsonResponse=restAuthenticationHandler.initiateAuthentication(request,response,authIndexType,authIndexValue,sessionUpgradeSSOTokenId);
    }
    return createResponse(jsonResponse);
  }
 catch (  RestAuthResponseException e) {
    DEBUG.message(""String_Node_Str"",e);
    return handleCallbackException(e);
  }
catch (  RestAuthException e) {
    DEBUG.error(""String_Node_Str"",e);
    throw new ResourceException(org.forgerock.json.resource.ResourceException.getException(401,e.getMessage()).setDetail(json(object(field(""String_Node_Str"",e.getFailureUrl())))));
  }
catch (  Exception e) {
    DEBUG.error(""String_Node_Str"",e);
    throw new ResourceException(org.forgerock.json.resource.ResourceException.INTERNAL_ERROR,e);
  }
}","/** 
 * Handles both initial and subsequent RESTful calls from clients submitting Callbacks for the authentication process to continue. This is determined by checking if the POST body is empty or not. If it is empty then this is initiating the authentication process otherwise it is a subsequent call submitting Callbacks. Initiating authentication request using the query parameters from the URL starts the login process and either returns an SSOToken on successful authentication or a number of Callbacks needing to be completed before authentication can proceed or an exception if any problems occurred whilst trying to authenticate. Using the body of the POST request the method continues the login process, submitting the given Callbacks and then either returns an SSOToken on successful authentication or a number of additional Callbacks needing to be completed before authentication can proceed or an exception if any problems occurred whilst trying to authenticate.
 * @param entity The Json Representation of the post body of the request.
 * @return A Json Representation of the response body. The response will contain either a JSON object containing theSSOToken id from a successful authentication, a JSON object containing a number of Callbacks for the client to complete and return or a JSON object containing an exception message.
 * @throws ResourceException If there is an error processing the authentication request.
 */
@Post public Representation authenticate(JsonRepresentation entity) throws ResourceException {
  if (entity != null && !MediaType.APPLICATION_JSON.equals(entity.getMediaType())) {
    throw new ResourceException(Status.CLIENT_ERROR_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"");
  }
  final HttpServletRequest request=getHttpServletRequest();
  final HttpServletResponse response=ServletUtils.getResponse(getResponse());
  final Map<String,String> queryString=getReference().getQueryAsForm().getValuesMap();
  final String sessionUpgradeSSOTokenId=queryString.get(""String_Node_Str"");
  try {
    JsonValue jsonContent=getJsonContent(entity);
    JsonValue jsonResponse;
    if (jsonContent != null && jsonContent.size() > 0) {
      jsonResponse=restAuthenticationHandler.continueAuthentication(request,response,jsonContent,sessionUpgradeSSOTokenId);
    }
 else {
      final String authIndexType=queryString.get(""String_Node_Str"");
      final String authIndexValue=queryString.get(""String_Node_Str"");
      jsonResponse=restAuthenticationHandler.initiateAuthentication(request,response,authIndexType,authIndexValue,sessionUpgradeSSOTokenId);
    }
    return createResponse(jsonResponse);
  }
 catch (  RestAuthResponseException e) {
    DEBUG.message(""String_Node_Str"",e);
    return handleCallbackException(e);
  }
catch (  RestAuthException e) {
    DEBUG.error(""String_Node_Str"",e);
    org.forgerock.json.resource.ResourceException cause=org.forgerock.json.resource.ResourceException.getException(401,e.getMessage());
    if (e.getFailureUrl() != null) {
      cause.setDetail(json(object(field(""String_Node_Str"",e.getFailureUrl()))));
    }
    throw new ResourceException(401,cause);
  }
catch (  Exception e) {
    DEBUG.error(""String_Node_Str"",e);
    throw new ResourceException(org.forgerock.json.resource.ResourceException.INTERNAL_ERROR,e);
  }
}"
9247,"public OpenSSOPrivilege(){
  super();
  policyMonitor=InjectorHolder.getInstance(PolicyMonitor.class);
}","public OpenSSOPrivilege(){
  super();
  if (isServerMode()) {
    policyMonitor=InjectorHolder.getInstance(PolicyMonitor.class);
  }
 else {
    policyMonitor=null;
  }
}"
9248,"/** 
 * Constructor to create an evaluator the default service type.
 * @param subject Subject who credential is used for performing the evaluation.
 * @throws EntitlementException if any other abnormal condition occured.
 */
public Evaluator(Subject subject) throws EntitlementException {
  adminSubject=subject;
  policyMonitor=InjectorHolder.getInstance(PolicyMonitor.class);
  configWrapper=new EntitlementConfigurationWrapper();
}","/** 
 * Constructor to create an evaluator the default service type.
 * @param subject Subject who credential is used for performing the evaluation.
 * @throws EntitlementException if any other abnormal condition occured.
 */
public Evaluator(Subject subject) throws EntitlementException {
  adminSubject=subject;
  policyMonitor=getPolicyMonitor();
  configWrapper=new EntitlementConfigurationWrapper();
}"
9249,"/** 
 * eliminates the null path (consecutive delimiters) from the resource 
 */
private String purgeNullPath(String res){
  if ((res == null) || (res.length() == 0)) {
    return ""String_Node_Str"";
  }
  boolean preceedingDelimiter=false;
  int len=res.length();
  char[] oldchars=res.toCharArray();
  char[] newchars=new char[len];
  int i=0;
  int j=0;
  while (i < len) {
    if (oldchars[i] == delimiter.charAt(0)) {
      if (!preceedingDelimiter) {
        newchars[j++]=oldchars[i++];
        preceedingDelimiter=true;
      }
 else {
        i++;
      }
    }
 else {
      newchars[j++]=oldchars[i++];
      preceedingDelimiter=false;
    }
  }
  if (preceedingDelimiter) {
    j--;
  }
  return String.valueOf(newchars,0,j);
}","/** 
 * eliminates the null path (consecutive delimiters) from the resource 
 */
private String purgeNullPath(String res){
  if ((res == null) || (res.length() == 0)) {
    return ""String_Node_Str"";
  }
  boolean preceedingDelimiter=false;
  int len=res.length();
  char[] oldchars=res.toCharArray();
  char[] newchars=new char[len];
  int i=0;
  int j=0;
  while (i < len) {
    if (oldchars[i] == delimiter.charAt(0)) {
      if (!preceedingDelimiter) {
        newchars[j++]=oldchars[i++];
        preceedingDelimiter=true;
      }
 else {
        i++;
      }
    }
 else {
      newchars[j++]=oldchars[i++];
      preceedingDelimiter=false;
    }
  }
  return String.valueOf(newchars,0,j);
}"
9250,"/** 
 * eliminates the null path (consecutive delimiters) from the resource 
 */
private String purgeNullPath(String res){
  if ((res == null) || (res.length() == 0)) {
    return ""String_Node_Str"";
  }
  boolean preceedingDelimiter=false;
  int len=res.length();
  char[] oldchars=res.toCharArray();
  char[] newchars=new char[len];
  int i=0;
  int j=0;
  while (i < len) {
    if (oldchars[i] == delimiter.charAt(0)) {
      if (!preceedingDelimiter) {
        newchars[j++]=oldchars[i++];
        preceedingDelimiter=true;
      }
 else {
        i++;
      }
    }
 else {
      newchars[j++]=oldchars[i++];
      preceedingDelimiter=false;
    }
  }
  if (preceedingDelimiter) {
    j--;
  }
  return String.valueOf(newchars,0,j);
}","/** 
 * eliminates the null path (consecutive delimiters) from the resource 
 */
private String purgeNullPath(String res){
  if ((res == null) || (res.length() == 0)) {
    return ""String_Node_Str"";
  }
  boolean preceedingDelimiter=false;
  int len=res.length();
  char[] oldchars=res.toCharArray();
  char[] newchars=new char[len];
  int i=0;
  int j=0;
  while (i < len) {
    if (oldchars[i] == delimiter.charAt(0)) {
      if (!preceedingDelimiter) {
        newchars[j++]=oldchars[i++];
        preceedingDelimiter=true;
      }
 else {
        i++;
      }
    }
 else {
      newchars[j++]=oldchars[i++];
      preceedingDelimiter=false;
    }
  }
  return String.valueOf(newchars,0,j);
}"
9251,"/** 
 * Returns an asynchronous connection from the underlying connection factory.
 * @param resultHandler the result handler
 * @return the FutureResult from the underlying factory.
 */
public FutureResult<Connection> getConnectionAsync(ResultHandler<? super Connection> resultHandler){
  return getConnectionAsync(resultHandler);
}","/** 
 * Returns an asynchronous connection from the underlying connection factory.
 * @param resultHandler the result handler
 * @return the FutureResult from the underlying factory.
 */
public FutureResult<Connection> getConnectionAsync(ResultHandler<? super Connection> resultHandler){
  return factory.getConnectionAsync(resultHandler);
}"
9252,"/** 
 * eliminates the null path (consecutive delimiters) from the resource 
 */
private String purgeNullPath(String res){
  if ((res == null) || (res.length() == 0)) {
    return ""String_Node_Str"";
  }
  boolean preceedingDelimiter=false;
  int len=res.length();
  char[] oldchars=res.toCharArray();
  char[] newchars=new char[len];
  int i=0;
  int j=0;
  while (i < len) {
    if (oldchars[i] == delimiter.charAt(0)) {
      if (!preceedingDelimiter) {
        newchars[j++]=oldchars[i++];
        preceedingDelimiter=true;
      }
 else {
        i++;
      }
    }
 else {
      newchars[j++]=oldchars[i++];
      preceedingDelimiter=false;
    }
  }
  if (preceedingDelimiter) {
    j--;
  }
  return String.valueOf(newchars,0,j);
}","/** 
 * eliminates the null path (consecutive delimiters) from the resource 
 */
private String purgeNullPath(String res){
  if ((res == null) || (res.length() == 0)) {
    return ""String_Node_Str"";
  }
  boolean preceedingDelimiter=false;
  int len=res.length();
  char[] oldchars=res.toCharArray();
  char[] newchars=new char[len];
  int i=0;
  int j=0;
  while (i < len) {
    if (oldchars[i] == delimiter.charAt(0)) {
      if (!preceedingDelimiter) {
        newchars[j++]=oldchars[i++];
        preceedingDelimiter=true;
      }
 else {
        i++;
      }
    }
 else {
      newchars[j++]=oldchars[i++];
      preceedingDelimiter=false;
    }
  }
  return String.valueOf(newchars,0,j);
}"
9253,"/** 
 * eliminates the null path (consecutive delimiters) from the resource 
 */
private String purgeNullPath(String res){
  if ((res == null) || (res.length() == 0)) {
    return ""String_Node_Str"";
  }
  boolean preceedingDelimiter=false;
  int len=res.length();
  char[] oldchars=res.toCharArray();
  char[] newchars=new char[len];
  int i=0;
  int j=0;
  while (i < len) {
    if (oldchars[i] == delimiter.charAt(0)) {
      if (!preceedingDelimiter) {
        newchars[j++]=oldchars[i++];
        preceedingDelimiter=true;
      }
 else {
        i++;
      }
    }
 else {
      newchars[j++]=oldchars[i++];
      preceedingDelimiter=false;
    }
  }
  if (preceedingDelimiter) {
    j--;
  }
  return String.valueOf(newchars,0,j);
}","/** 
 * eliminates the null path (consecutive delimiters) from the resource 
 */
private String purgeNullPath(String res){
  if ((res == null) || (res.length() == 0)) {
    return ""String_Node_Str"";
  }
  boolean preceedingDelimiter=false;
  int len=res.length();
  char[] oldchars=res.toCharArray();
  char[] newchars=new char[len];
  int i=0;
  int j=0;
  while (i < len) {
    if (oldchars[i] == delimiter.charAt(0)) {
      if (!preceedingDelimiter) {
        newchars[j++]=oldchars[i++];
        preceedingDelimiter=true;
      }
 else {
        i++;
      }
    }
 else {
      newchars[j++]=oldchars[i++];
      preceedingDelimiter=false;
    }
  }
  return String.valueOf(newchars,0,j);
}"
9254,"protected Map<String,Object> getDataModel(Set<String> scopes){
  Map<String,Object> data=new HashMap<String,Object>(getRequest().getAttributes());
  data.put(""String_Node_Str"",getRequest().getResourceRef().toString());
  Set<String> displayNames=client.getClient().getDisplayName();
  Set<String> displayDescriptions=client.getClient().getDisplayDescription();
  Set<String> allScopes=client.getClient().getAllowedGrantScopes();
  String locale=OAuth2Utils.getLocale(getRequest());
  String displayName=""String_Node_Str"";
  String displayDescription=""String_Node_Str"";
  List<String> displayScope=new ArrayList<String>();
  displayName=getDisplayParameter(locale,displayNames);
  displayDescription=getDisplayParameter(locale,displayDescriptions);
  displayScope=getScopeDescriptionsForLocale(scopes,allScopes,locale);
  data.put(""String_Node_Str"",displayName);
  data.put(""String_Node_Str"",displayDescription);
  data.put(""String_Node_Str"",displayScope);
  return data;
}","protected Map<String,Object> getDataModel(Set<String> scopes){
  Map<String,Object> data=new HashMap<String,Object>(getRequest().getAttributes());
  data.put(""String_Node_Str"",getRequest().getResourceRef().toString());
  Set<String> displayNames=client.getClient().getDisplayName();
  Set<String> displayDescriptions=client.getClient().getDisplayDescription();
  Set<String> allScopes=client.getClient().getAllowedGrantScopes();
  String locale=OAuth2Utils.getLocale(getRequest());
  String displayName=""String_Node_Str"";
  String displayDescription=""String_Node_Str"";
  List<String> displayScope=null;
  displayName=getDisplayParameter(locale,displayNames);
  displayDescription=getDisplayParameter(locale,displayDescriptions);
  displayScope=getScopeDescriptionsForLocale(scopes,allScopes,locale);
  data.put(""String_Node_Str"",ESAPI.encoder().encodeForHTML(displayName));
  data.put(""String_Node_Str"",ESAPI.encoder().encodeForHTML(displayDescription));
  data.put(""String_Node_Str"",encodeListForHTML(displayScope));
  return data;
}"
9255,"protected Map<String,Object> getDataModel(Set<String> scopes){
  Map<String,Object> data=new HashMap<String,Object>(getRequest().getAttributes());
  data.put(""String_Node_Str"",getRequest().getResourceRef().toString());
  Set<String> displayNames=client.getClient().getDisplayName();
  Set<String> displayDescriptions=client.getClient().getDisplayDescription();
  Set<String> allScopes=client.getClient().getAllowedGrantScopes();
  String locale=OAuth2Utils.getLocale(getRequest());
  String displayName=""String_Node_Str"";
  String displayDescription=""String_Node_Str"";
  List<String> displayScope=new ArrayList<String>();
  displayName=getDisplayParameter(locale,displayNames);
  displayDescription=getDisplayParameter(locale,displayDescriptions);
  displayScope=getScopeDescriptionsForLocale(scopes,allScopes,locale);
  data.put(""String_Node_Str"",displayName);
  data.put(""String_Node_Str"",displayDescription);
  data.put(""String_Node_Str"",displayScope);
  return data;
}","protected Map<String,Object> getDataModel(Set<String> scopes){
  Map<String,Object> data=new HashMap<String,Object>(getRequest().getAttributes());
  data.put(""String_Node_Str"",getRequest().getResourceRef().toString());
  Set<String> displayNames=client.getClient().getDisplayName();
  Set<String> displayDescriptions=client.getClient().getDisplayDescription();
  Set<String> allScopes=client.getClient().getAllowedGrantScopes();
  String locale=OAuth2Utils.getLocale(getRequest());
  String displayName=""String_Node_Str"";
  String displayDescription=""String_Node_Str"";
  List<String> displayScope=null;
  displayName=getDisplayParameter(locale,displayNames);
  displayDescription=getDisplayParameter(locale,displayDescriptions);
  displayScope=getScopeDescriptionsForLocale(scopes,allScopes,locale);
  data.put(""String_Node_Str"",ESAPI.encoder().encodeForHTML(displayName));
  data.put(""String_Node_Str"",ESAPI.encoder().encodeForHTML(displayDescription));
  data.put(""String_Node_Str"",encodeListForHTML(displayScope));
  return data;
}"
9256,"/** 
 * The function to run when timeout.
 */
public void run(){
  if (!isTimedOut()) {
    if (sessionState == Session.INVALID) {
      setState(Session.DESTROYED);
      ss.removeInternalSession(sessionID);
      ss.sendEvent(this,SessionEvent.DESTROY);
    }
 else {
      long timeLeft=getTimeLeft();
      if (timeLeft == 0) {
        changeStateAndNotify(SessionEvent.MAX_TIMEOUT);
        if (timerPool != null) {
          if (purgeDelay > 0) {
            timerPool.schedule(this,new Date((timedOutAt + (purgeDelay * 60)) * 1000));
          }
        }
      }
 else {
        long idleTimeLeft=(maxIdleTime * 60) - getIdleTime();
        if (idleTimeLeft <= 0 && sessionState != Session.INACTIVE) {
          changeStateAndNotify(SessionEvent.IDLE_TIMEOUT);
          if (timerPool != null) {
            if (purgeDelay > 0) {
              timerPool.schedule(this,new Date((timedOutAt + (purgeDelay * 60)) * 1000));
            }
          }
        }
 else {
          long timeToWait=Math.min(timeLeft,idleTimeLeft);
          if (timerPool != null) {
            timerPool.schedule(this,new Date(((System.currentTimeMillis() / 1000) + timeToWait) * 1000));
          }
        }
      }
    }
  }
 else {
    ss.logEvent(this,SessionEvent.DESTROY);
    setState(Session.DESTROYED);
    ss.removeInternalSession(sessionID);
    ss.sendEvent(this,SessionEvent.DESTROY);
  }
}","/** 
 * The function to run when timeout.
 */
public void run(){
  if (!isTimedOut()) {
    if (isInvalid()) {
      removeSession();
    }
 else {
      long timeLeft=getTimeLeft();
      if (timeLeft == 0) {
        changeStateAndNotify(SessionEvent.MAX_TIMEOUT);
        if (timerPool != null) {
          if (purgeDelay > 0) {
            timerPool.schedule(this,new Date((timedOutAt + (purgeDelay * 60)) * 1000));
          }
        }
      }
 else {
        long idleTimeLeft=(maxIdleTime * 60) - getIdleTime();
        if (idleTimeLeft <= 0 && sessionState != Session.INACTIVE) {
          changeStateAndNotify(SessionEvent.IDLE_TIMEOUT);
          if (timerPool != null) {
            if (purgeDelay > 0) {
              timerPool.schedule(this,new Date((timedOutAt + (purgeDelay * 60)) * 1000));
            }
          }
        }
 else {
          long timeToWait=Math.min(timeLeft,idleTimeLeft);
          if (timerPool != null) {
            timerPool.schedule(this,new Date(((System.currentTimeMillis() / 1000) + timeToWait) * 1000));
          }
        }
      }
    }
  }
 else {
    removeSession();
  }
}"
9257,"/** 
 * Returns true if cookies are supported.
 * @return true if cookie supported;
 */
private boolean getCookieSupport(){
  boolean cookieSupport=false;
  try {
    if (sessionID.getCookieMode() != null) {
      cookieSupport=sessionID.getCookieMode().booleanValue();
    }
 else     if (this.cookieMode != null) {
      cookieSupport=this.cookieMode.booleanValue();
    }
  }
 catch (  Exception ex) {
    DEBUG.error(""String_Node_Str"",ex);
    cookieSupport=true;
  }
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + cookieSupport);
  }
  return cookieSupport;
}","/** 
 * Returns true if cookies are supported.
 * @return true if cookie supported;
 */
private boolean getCookieSupport(){
  boolean cookieSupport=false;
  try {
    if (sessionID.getCookieMode() != null) {
      cookieSupport=sessionID.getCookieMode().booleanValue();
    }
 else     if (this.cookieMode != null) {
      cookieSupport=this.cookieMode.booleanValue();
    }
  }
 catch (  Exception ex) {
    debug.error(""String_Node_Str"",ex);
    cookieSupport=true;
  }
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + cookieSupport);
  }
  return cookieSupport;
}"
9258,"/** 
 * Transfers the info about the Internal Session to Session Info.
 * @return SessionInfo
 */
public SessionInfo toSessionInfo(){
  SessionInfo info=new SessionInfo();
  info.sid=sessionID.toString();
  if (sessionType == Session.USER_SESSION) {
    info.stype=""String_Node_Str"";
  }
 else   if (sessionType == Session.APPLICATION_SESSION) {
    info.stype=""String_Node_Str"";
  }
  info.cid=clientID;
  info.cdomain=clientDomain;
  info.maxtime=Long.toString(getMaxSessionTime());
  info.maxidle=Long.toString(getMaxIdleTime());
  info.maxcaching=Long.toString(getMaxCachingTime());
  if (willExpireFlag == true) {
    info.timeidle=Long.toString(getIdleTime());
    info.timeleft=Long.toString(getTimeLeft());
  }
 else {
    info.timeidle=Long.toString(0);
    info.timeleft=Long.toString(Long.MAX_VALUE / 60);
  }
  if (sessionState == Session.INVALID) {
    info.state=""String_Node_Str"";
  }
 else   if (sessionState == Session.VALID) {
    info.state=""String_Node_Str"";
  }
 else   if (sessionState == Session.INACTIVE) {
    info.state=""String_Node_Str"";
  }
 else   if (sessionState == Session.DESTROYED) {
    info.state=""String_Node_Str"";
  }
  info.properties=(Properties)sessionProperties.clone();
  return info;
}","/** 
 * Transfers the info about the Internal Session to Session Info.
 * @return SessionInfo
 */
public SessionInfo toSessionInfo(){
  SessionInfo info=new SessionInfo();
  info.sid=sessionID.toString();
  if (sessionType == Session.USER_SESSION) {
    info.stype=""String_Node_Str"";
  }
 else   if (sessionType == Session.APPLICATION_SESSION) {
    info.stype=""String_Node_Str"";
  }
  info.cid=clientID;
  info.cdomain=clientDomain;
  info.maxtime=Long.toString(getMaxSessionTime());
  info.maxidle=Long.toString(getMaxIdleTime());
  info.maxcaching=Long.toString(getMaxCachingTime());
  if (willExpireFlag == true) {
    info.timeidle=Long.toString(getIdleTime());
    info.timeleft=Long.toString(getTimeLeft());
  }
 else {
    info.timeidle=Long.toString(0);
    info.timeleft=Long.toString(Long.MAX_VALUE / 60);
  }
  if (isInvalid()) {
    info.state=""String_Node_Str"";
  }
 else   if (sessionState == Session.VALID) {
    info.state=""String_Node_Str"";
  }
 else   if (sessionState == Session.INACTIVE) {
    info.state=""String_Node_Str"";
  }
 else   if (sessionState == Session.DESTROYED) {
    info.state=""String_Node_Str"";
  }
  info.properties=(Properties)sessionProperties.clone();
  return info;
}"
9259,"/** 
 * set the cookieMode based on whether the request has cookies or not. This method is called from createSSOToken(request) method in SSOTokenManager.
 * @param cookieMode ,Boolean value whether request has cookies or not.
 */
public void setCookieMode(Boolean cookieMode){
  DEBUG.message(""String_Node_Str"" + cookieMode);
  if (cookieMode != null) {
    this.cookieMode=cookieMode;
  }
}","/** 
 * set the cookieMode based on whether the request has cookies or not. This method is called from createSSOToken(request) method in SSOTokenManager.
 * @param cookieMode ,Boolean value whether request has cookies or not.
 */
public void setCookieMode(Boolean cookieMode){
  debug.message(""String_Node_Str"" + cookieMode);
  if (cookieMode != null) {
    this.cookieMode=cookieMode;
  }
}"
9260,"/** 
 * Encodes the url by adding the cookiename=sid to it. if cookie support is true returns without encoding <p> The cookie Value is written in the URL based on the encodingScheme specified. The Cookie Value could be written as path info separated by either a ""/"" OR  "";"" or as a query string. <p> If the encoding scheme is SLASH then the  cookie value would be written in the URL as extra path info in the following format: <pre> protocol://server:port/servletpath/&lt;cookieName>=&lt;cookieValue>? queryString      </pre> <p> Note that this format works only if the path is a servlet, if a a jsp file is specified then webcontainers return with ""File Not found"" error. To rewrite links which are JSP files with cookie value use the SEMICOLON OR QUERY encoding scheme.      <p> If the encoding scheme is SEMICOLON then the cookie value would be written in the URL as extra path info in the following format: <pre> protocol://server:port/path;&lt;cookieName=cookieValue>?queryString </pre> Note that this is not supported in the servlet specification and some web containers do not support this. <p> If the encoding scheme is QUERY then the cookie value would be written in the URL in the following format: <pre> protocol://server:port/path?&lt;cookieName>=&lt;cookieValue> protocol://server:port/path?queryString&&lt;cookieName>=&lt;cookieValue> </pre> <p> This is the default and OpenSSO always encodes in this format  unless otherwise specified. If the URL passed in has query parameter then entity escaping of ampersand will be done before appending the cookie if the escape is true.  Only the ampersand before appending  cookie parameter will be entity escaped. <p>
 * @param url the url to be encoded
 * @param encodingScheme possible values are QUERY,SLASH,SEMICOLON
 * @param escape entity escaping of ampersand when appending theSSOToken ID to request query string.
 * @param cookieName 
 * @return encoded URL with cookie value (session id) basedon the encoding scheme or the url itself if there is an error.
 */
public String encodeURL(String url,short encodingScheme,boolean escape,String cookieName){
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + url);
  }
  String encodedURL=url;
  if (((url != null) && (url.length() > 0)) && !getCookieSupport()) {
    if ((cookieStr != null && cookieStr.length() != 0) && (Session.foundCookieName(cookieStr,cookieName))) {
      encodedURL=SessionEncodeURL.buildCookieString(url,cookieStr,encodingScheme,escape);
    }
 else {
      if (sessionID != null) {
        cookieStr=SessionEncodeURL.createCookieString(cookieName,sessionID.toString());
        encodedURL=SessionEncodeURL.encodeURL(cookieStr,url,encodingScheme,escape);
      }
    }
  }
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + ""String_Node_Str"" + encodedURL);
  }
  return encodedURL;
}","/** 
 * Encodes the url by adding the cookiename=sid to it. if cookie support is true returns without encoding <p> The cookie Value is written in the URL based on the encodingScheme specified. The Cookie Value could be written as path info separated by either a ""/"" OR  "";"" or as a query string. <p> If the encoding scheme is SLASH then the  cookie value would be written in the URL as extra path info in the following format: <pre> protocol://server:port/servletpath/&lt;cookieName>=&lt;cookieValue>? queryString      </pre> <p> Note that this format works only if the path is a servlet, if a a jsp file is specified then webcontainers return with ""File Not found"" error. To rewrite links which are JSP files with cookie value use the SEMICOLON OR QUERY encoding scheme.      <p> If the encoding scheme is SEMICOLON then the cookie value would be written in the URL as extra path info in the following format: <pre> protocol://server:port/path;&lt;cookieName=cookieValue>?queryString </pre> Note that this is not supported in the servlet specification and some web containers do not support this. <p> If the encoding scheme is QUERY then the cookie value would be written in the URL in the following format: <pre> protocol://server:port/path?&lt;cookieName>=&lt;cookieValue> protocol://server:port/path?queryString&&lt;cookieName>=&lt;cookieValue> </pre> <p> This is the default and OpenSSO always encodes in this format  unless otherwise specified. If the URL passed in has query parameter then entity escaping of ampersand will be done before appending the cookie if the escape is true.  Only the ampersand before appending  cookie parameter will be entity escaped. <p>
 * @param url the url to be encoded
 * @param encodingScheme possible values are QUERY,SLASH,SEMICOLON
 * @param escape entity escaping of ampersand when appending theSSOToken ID to request query string.
 * @param cookieName 
 * @return encoded URL with cookie value (session id) basedon the encoding scheme or the url itself if there is an error.
 */
public String encodeURL(String url,short encodingScheme,boolean escape,String cookieName){
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + url);
  }
  String encodedURL=url;
  if (((url != null) && (url.length() > 0)) && !getCookieSupport()) {
    if ((cookieStr != null && cookieStr.length() != 0) && (Session.foundCookieName(cookieStr,cookieName))) {
      encodedURL=SessionEncodeURL.buildCookieString(url,cookieStr,encodingScheme,escape);
    }
 else {
      if (sessionID != null) {
        cookieStr=SessionEncodeURL.createCookieString(cookieName,sessionID.toString());
        encodedURL=SessionEncodeURL.encodeURL(cookieStr,url,encodingScheme,escape);
      }
    }
  }
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + ""String_Node_Str"" + encodedURL);
  }
  return encodedURL;
}"
9261,"/** 
 * Sets the key-value pair in the InternalSession property table if it is not protected. If it is protected client should have permission to set it. This method is to be used in conjuction with SessionRequestHandler/SessionService invocation path If the property is protected, an attempt to remotely set a protected property is logged and the method throws an Exception. Otherwise invocation is delegated to internalPutProperty() Note that package default access is being used
 * @param clientToken Token of the client setting external property.
 * @param key Property key
 * @param value Property value for the key
 * @exception SessionException is thrown if the key is protected property.
 */
void putExternalProperty(SSOToken clientToken,String key,String value) throws SessionException {
  try {
    SessionUtils.checkPermissionToSetProperty(clientToken,key,value);
  }
 catch (  SessionException se) {
    SessionService.getSessionService().logIt(this,""String_Node_Str"");
    throw se;
  }
  internalPutProperty(key,value);
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Sets the key-value pair in the InternalSession property table if it is not protected. If it is protected client should have permission to set it. This method is to be used in conjuction with SessionRequestHandler/SessionService invocation path If the property is protected, an attempt to remotely set a protected property is logged and the method throws an Exception. Otherwise invocation is delegated to internalPutProperty() Note that package default access is being used
 * @param clientToken Token of the client setting external property.
 * @param key Property key
 * @param value Property value for the key
 * @exception SessionException is thrown if the key is protected property.
 */
void putExternalProperty(SSOToken clientToken,String key,String value) throws SessionException {
  try {
    SessionUtils.checkPermissionToSetProperty(clientToken,key,value);
  }
 catch (  SessionException se) {
    SessionService.getSessionService().logIt(this,""String_Node_Str"");
    throw se;
  }
  internalPutProperty(key,value);
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
9262,"/** 
 * Changes the state of the session to ACTIVE after creation.
 * @param userDN 
 * @return <code> true </code> if the session is successfully activated after creation , <code>false</code> otherwise
 */
public boolean activate(String userDN){
  if (userDN == null) {
    return false;
  }
  if ((SessionService.getActiveSessions() >= SessionService.maxSessions) && (!userDN.equalsIgnoreCase(superUserDN))) {
    SessionService.getSessionService().logSystemMessage(LOG_MSG_SESSION_MAX_LIMIT_REACHED,java.util.logging.Level.INFO);
    return false;
  }
  if ((SessionService.isSessionConstraintEnabled()) && !shouldIgnoreSessionQuotaChecking(userDN)) {
    if (SessionConstraint.checkQuotaAndPerformAction(this)) {
      if (DEBUG.messageEnabled()) {
        DEBUG.message(""String_Node_Str"" + ""String_Node_Str"");
      }
      SessionService.getSessionService().logEvent(this,SessionEvent.QUOTA_EXHAUSTED);
      return false;
    }
  }
  setLatestAccessTime();
  setState(Session.VALID);
  if (reschedulePossible) {
    reschedule();
  }
  SessionService.getSessionService().logEvent(this,SessionEvent.SESSION_CREATION);
  SessionService.getSessionService().sendEvent(this,SessionEvent.SESSION_CREATION);
  if (!isAppSession() || SessionService.returnAppSession) {
    SessionService.incrementActiveSessions();
  }
  return true;
}","/** 
 * Changes the state of the session to ACTIVE after creation.
 * @param userDN 
 * @return <code> true </code> if the session is successfully activated after creation , <code>false</code> otherwise
 */
public boolean activate(String userDN){
  if (userDN == null) {
    return false;
  }
  if ((SessionService.getActiveSessions() >= SessionService.maxSessions) && (!userDN.equalsIgnoreCase(superUserDN))) {
    SessionService.getSessionService().logSystemMessage(LOG_MSG_SESSION_MAX_LIMIT_REACHED,java.util.logging.Level.INFO);
    return false;
  }
  if ((SessionService.isSessionConstraintEnabled()) && !shouldIgnoreSessionQuotaChecking(userDN)) {
    if (SessionConstraint.checkQuotaAndPerformAction(this)) {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + ""String_Node_Str"");
      }
      SessionService.getSessionService().logEvent(this,SessionEvent.QUOTA_EXHAUSTED);
      return false;
    }
  }
  setLatestAccessTime();
  setState(Session.VALID);
  if (reschedulePossible) {
    reschedule();
  }
  SessionService.getSessionService().logEvent(this,SessionEvent.SESSION_CREATION);
  SessionService.getSessionService().sendEvent(this,SessionEvent.SESSION_CREATION);
  if (!isAppSession() || SessionService.returnAppSession) {
    SessionService.incrementActiveSessions();
  }
  return true;
}"
9263,"/** 
 * Default constructor required for deserialisation.
 */
public InternalSession(){
  this(null,SessionService.getSessionService(),SessionService.sessionDebug);
}","/** 
 * Default constructor required for deserialisation.
 */
public InternalSession(){
}"
9264,"/** 
 * Sets the key-value pair in the Internal Session property table.
 * @param key Property key
 * @param value Property value for the key
 */
protected void internalPutProperty(String key,String value){
  if (key.equals(HOST_NAME) || key.equals(HOST)) {
    if (value == null || value.length() == 0) {
      return;
    }
    if (isEnableHostLookUp) {
      try {
        InetAddress address=java.net.InetAddress.getByName(value);
        String hostName=address.getHostName();
        sessionProperties.put(HOST_NAME,hostName);
        sessionProperties.put(HOST,value);
      }
 catch (      UnknownHostException uhe) {
        DEBUG.error(""String_Node_Str"" + ""String_Node_Str"" + value + ""String_Node_Str"",uhe);
      }
    }
 else {
      sessionProperties.put(HOST_NAME,value);
      sessionProperties.put(HOST,value);
    }
  }
 else   if (key.equals(AM_MAX_IDLE_TIME)) {
    setMaxIdleTime(Long.parseLong(value));
  }
 else {
    sessionProperties.put(key,value);
  }
  if (sessionState == Session.VALID && SessionService.isSendPropertyNotification(key)) {
    SessionService.getSessionService().sendEvent(this,SessionEvent.PROPERTY_CHANGED);
    SessionService.getSessionService().logEvent(this,SessionEvent.PROPERTY_CHANGED);
  }
  updateForFailover();
}","/** 
 * Sets the key-value pair in the Internal Session property table.
 * @param key Property key
 * @param value Property value for the key
 */
protected void internalPutProperty(String key,String value){
  if (key.equals(HOST_NAME) || key.equals(HOST)) {
    if (value == null || value.length() == 0) {
      return;
    }
    if (isEnableHostLookUp) {
      try {
        InetAddress address=java.net.InetAddress.getByName(value);
        String hostName=address.getHostName();
        sessionProperties.put(HOST_NAME,hostName);
        sessionProperties.put(HOST,value);
      }
 catch (      UnknownHostException uhe) {
        debug.error(""String_Node_Str"" + ""String_Node_Str"" + value + ""String_Node_Str"",uhe);
      }
    }
 else {
      sessionProperties.put(HOST_NAME,value);
      sessionProperties.put(HOST,value);
    }
  }
 else   if (key.equals(AM_MAX_IDLE_TIME)) {
    setMaxIdleTime(Long.parseLong(value));
  }
 else {
    sessionProperties.put(key,value);
  }
  if (sessionState == Session.VALID && SessionService.isSendPropertyNotification(key)) {
    SessionService.getSessionService().sendEvent(this,SessionEvent.PROPERTY_CHANGED);
    SessionService.getSessionService().logEvent(this,SessionEvent.PROPERTY_CHANGED);
  }
  updateForFailover();
}"
9265,"/** 
 * Checks whether the sesion should be destroyed or not.
 */
boolean shouldDestroy(){
  if (willExpireFlag == false) {
    return false;
  }
  if (!isTimedOut()) {
    if (sessionState == Session.INVALID) {
      if (checkInvalidSessionDefaultIdleTime()) {
        setState(Session.DESTROYED);
        ss.sendEvent(this,SessionEvent.DESTROY);
        return true;
      }
 else {
        return false;
      }
    }
    if (getTimeLeft() == 0) {
      changeStateAndNotify(SessionEvent.MAX_TIMEOUT);
      return false;
    }
    if (getIdleTime() >= maxIdleTime * 60 && sessionState != Session.INACTIVE) {
      changeStateAndNotify(SessionEvent.IDLE_TIMEOUT);
      return false;
    }
    return false;
  }
 else {
    if (getTimeLeftBeforePurge() <= 0) {
      SessionService.getSessionService().logEvent(this,SessionEvent.DESTROY);
      setState(Session.DESTROYED);
      SessionService.getSessionService().sendEvent(this,SessionEvent.DESTROY);
      return true;
    }
 else {
      return false;
    }
  }
}","/** 
 * Checks whether the sesion should be destroyed or not.
 */
boolean shouldDestroy(){
  if (willExpireFlag == false) {
    return false;
  }
  if (!isTimedOut()) {
    if (isInvalid()) {
      if (checkInvalidSessionDefaultIdleTime()) {
        setState(Session.DESTROYED);
        ss.sendEvent(this,SessionEvent.DESTROY);
        return true;
      }
 else {
        return false;
      }
    }
    if (getTimeLeft() == 0) {
      changeStateAndNotify(SessionEvent.MAX_TIMEOUT);
      return false;
    }
    if (getIdleTime() >= maxIdleTime * 60 && sessionState != Session.INACTIVE) {
      changeStateAndNotify(SessionEvent.IDLE_TIMEOUT);
      return false;
    }
    return false;
  }
 else {
    if (getTimeLeftBeforePurge() <= 0) {
      SessionService.getSessionService().logEvent(this,SessionEvent.DESTROY);
      setState(Session.DESTROYED);
      SessionService.getSessionService().sendEvent(this,SessionEvent.DESTROY);
      return true;
    }
 else {
      return false;
    }
  }
}"
9266,"/** 
 * Static initialisation section will be called the first time the SessionService is initailised. Note: This function depends on the singleton pattern that the SessionService follows.
 */
private static void initialiseStatic(){
  sessionDebug=Debug.getInstance(""String_Node_Str"");
  stats=Stats.getInstance(""String_Node_Str"");
  int poolSize=DEFAULT_POOL_SIZE;
  int threshold=DEFAULT_THRESHOLD;
  String size=SystemProperties.get(Constants.NOTIFICATION_THREADPOOL_SIZE);
  if (size != null) {
    try {
      poolSize=Integer.parseInt(size);
    }
 catch (    NumberFormatException e) {
      sessionDebug.error(""String_Node_Str"" + size + ""String_Node_Str""+ DEFAULT_POOL_SIZE);
    }
  }
  String thres=SystemProperties.get(Constants.NOTIFICATION_THREADPOOL_THRESHOLD);
  if (thres != null) {
    try {
      threshold=Integer.parseInt(thres);
    }
 catch (    Exception e) {
      sessionDebug.error(""String_Node_Str"" + thres + ""String_Node_Str""+ DEFAULT_THRESHOLD);
    }
  }
  ShutdownManager shutdownMan=ShutdownManager.getInstance();
  if (shutdownMan.acquireValidLock()) {
    try {
      threadPool=new ThreadPool(""String_Node_Str"",poolSize,threshold,true,sessionDebug);
      shutdownMan.addShutdownListener(new ShutdownListener(){
        public void shutdown(){
          threadPool.shutdown();
        }
      }
);
    }
  finally {
      shutdownMan.releaseLockAndNotify();
    }
  }
  if (threadPool != null) {
    try {
      maxSessions=Integer.parseInt(SystemProperties.get(Constants.AM_SESSION_MAX_SESSIONS));
    }
 catch (    Exception ex) {
      maxSessions=10000;
    }
  }
  String status=SystemProperties.get(Constants.AM_LOGSTATUS);
  if (status == null) {
    status=""String_Node_Str"";
  }
  logStatus=status.equalsIgnoreCase(""String_Node_Str"");
}","/** 
 * Static initialisation section will be called the first time the SessionService is initailised. Note: This function depends on the singleton pattern that the SessionService follows.
 */
private static void initialiseStatic(){
  Key<Debug> key=Key.get(Debug.class,Names.named(SessionConstants.SESSION_DEBUG));
  sessionDebug=InjectorHolder.getInstance(key);
  stats=Stats.getInstance(""String_Node_Str"");
  int poolSize=DEFAULT_POOL_SIZE;
  int threshold=DEFAULT_THRESHOLD;
  String size=SystemProperties.get(Constants.NOTIFICATION_THREADPOOL_SIZE);
  if (size != null) {
    try {
      poolSize=Integer.parseInt(size);
    }
 catch (    NumberFormatException e) {
      sessionDebug.error(""String_Node_Str"" + size + ""String_Node_Str""+ DEFAULT_POOL_SIZE);
    }
  }
  String thres=SystemProperties.get(Constants.NOTIFICATION_THREADPOOL_THRESHOLD);
  if (thres != null) {
    try {
      threshold=Integer.parseInt(thres);
    }
 catch (    Exception e) {
      sessionDebug.error(""String_Node_Str"" + thres + ""String_Node_Str""+ DEFAULT_THRESHOLD);
    }
  }
  ShutdownManager shutdownMan=ShutdownManager.getInstance();
  if (shutdownMan.acquireValidLock()) {
    try {
      threadPool=new ThreadPool(""String_Node_Str"",poolSize,threshold,true,sessionDebug);
      shutdownMan.addShutdownListener(new ShutdownListener(){
        public void shutdown(){
          threadPool.shutdown();
        }
      }
);
    }
  finally {
      shutdownMan.releaseLockAndNotify();
    }
  }
  if (threadPool != null) {
    try {
      maxSessions=Integer.parseInt(SystemProperties.get(Constants.AM_SESSION_MAX_SESSIONS));
    }
 catch (    Exception ex) {
      maxSessions=10000;
    }
  }
  String status=SystemProperties.get(Constants.AM_LOGSTATUS);
  if (status == null) {
    status=""String_Node_Str"";
  }
  logStatus=status.equalsIgnoreCase(""String_Node_Str"");
}"
9267,"/** 
 * Removes the Internal Session from the Internal Session table.
 * @param sid Session ID
 */
InternalSession removeInternalSession(SessionID sid){
  boolean isSessionStored=true;
  if (sid == null)   return null;
  InternalSession session=(InternalSession)sessionTable.remove(sid);
  if (session != null) {
    remoteSessionSet.remove(sid);
    session.cancel();
    removeSessionHandle(session);
    removeRestrictedTokens(session);
    isSessionStored=session.getIsISstored();
    if (session.getState() == Session.VALID) {
      decrementActiveSessions();
      SessionCount.decrementSessionCount(session);
    }
  }
  if (isSessionFailoverEnabled && isSessionStored) {
    if (getUseInternalRequestRouting()) {
      try {
        String tokenId=tokenIdFactory.toSessionTokenId(session);
        getRepository().delete(tokenId);
      }
 catch (      Exception e) {
        sessionDebug.error(""String_Node_Str"",e);
      }
    }
 else {
      invalidateHttpSession(sid);
    }
  }
  return session;
}","/** 
 * Removes the Internal Session from the Internal Session table.
 * @param sid Session ID
 */
InternalSession removeInternalSession(SessionID sid){
  boolean isSessionStored=false;
  if (sid == null)   return null;
  InternalSession session=(InternalSession)sessionTable.remove(sid);
  if (session != null) {
    remoteSessionSet.remove(sid);
    session.cancel();
    removeSessionHandle(session);
    removeRestrictedTokens(session);
    isSessionStored=session.getIsISstored();
    if (session.getState() == Session.VALID) {
      decrementActiveSessions();
      SessionCount.decrementSessionCount(session);
    }
  }
  if (isSessionFailoverEnabled && isSessionStored) {
    if (getUseInternalRequestRouting()) {
      try {
        String tokenId=tokenIdFactory.toSessionTokenId(session);
        getRepository().delete(tokenId);
      }
 catch (      Exception e) {
        sessionDebug.error(""String_Node_Str"",e);
      }
    }
 else {
      invalidateHttpSession(sid);
    }
  }
  return session;
}"
9268,"/** 
 * If InternalSession is not present, we attempt to recover its state from associated HttpSession. We have to set the session tracking cookie to HttpID which is present in the SessionID object. This will work in the fail over cases. We first get the HttpSession by invoking the GetHttpSession Servlet on the SAME server instance this code is invoked. This should trigger the Web container to perform recovery of the associated Http session <p/> We also pass the SessionID to the servlet to double check the match between the session id and Http session <p/> This is the ""client side"" of the remote invocation. The servlet will call retrieveSession() to complete the work
 * @param sid Session ID
 */
InternalSession recoverSession(SessionID sid){
  if (!isSessionFailoverEnabled) {
    return null;
  }
  if (getUseInternalRequestRouting()) {
    InternalSession sess=null;
    try {
      String tokenId=tokenIdFactory.toSessionTokenId(sid);
      Token token=getRepository().read(tokenId);
      if (token == null) {
        return sess;
      }
      sess=tokenAdapter.fromToken(token);
      updateSessionMaps(sess);
    }
 catch (    CoreTokenException e) {
      sessionDebug.error(""String_Node_Str"",e);
    }
    return sess;
  }
 else {
    if (sessionDebug.messageEnabled()) {
      sessionDebug.message(""String_Node_Str"" + sid);
    }
    DataInputStream in=null;
    InternalSession sess=null;
    try {
      String query=""String_Node_Str"" + GetHttpSession.OP + ""String_Node_Str""+ GetHttpSession.RECOVER_OP;
      URL url=new URL(thisSessionServerProtocol,thisSessionServer,thisSessionServerPort,deploymentURI + ""String_Node_Str"" + query);
      HttpURLConnection conn=invokeRemote(url,sid,null);
      in=new DataInputStream(conn.getInputStream());
      sess=(InternalSession)sessionTable.get(sid);
      if (sess == null) {
        sess=resolveRestrictedToken(sid,false);
      }
    }
 catch (    Exception ex) {
      sessionDebug.error(""String_Node_Str"",ex);
    }
 finally {
      closeStream(in);
    }
    return sess;
  }
}","/** 
 * If InternalSession is not present, we attempt to recover its state from associated HttpSession. We have to set the session tracking cookie to HttpID which is present in the SessionID object. This will work in the fail over cases. We first get the HttpSession by invoking the GetHttpSession Servlet on the SAME server instance this code is invoked. This should trigger the Web container to perform recovery of the associated Http session <p/> We also pass the SessionID to the servlet to double check the match between the session id and Http session <p/> This is the ""client side"" of the remote invocation. The servlet will call retrieveSession() to complete the work
 * @param sid Session ID
 */
InternalSession recoverSession(SessionID sid){
  if (!isSessionFailoverEnabled) {
    return null;
  }
  if (getUseInternalRequestRouting()) {
    InternalSession sess=null;
    try {
      String tokenId=tokenIdFactory.toSessionTokenId(sid);
      Token token=getRepository().read(tokenId);
      if (token == null) {
        return sess;
      }
      sess=tokenAdapter.fromToken(token);
      sess.setDebug(sessionDebug);
      sess.setSessionService(this);
      sess.scheduleExpiry();
      updateSessionMaps(sess);
    }
 catch (    CoreTokenException e) {
      sessionDebug.error(""String_Node_Str"",e);
    }
    return sess;
  }
 else {
    if (sessionDebug.messageEnabled()) {
      sessionDebug.message(""String_Node_Str"" + sid);
    }
    DataInputStream in=null;
    InternalSession sess=null;
    try {
      String query=""String_Node_Str"" + GetHttpSession.OP + ""String_Node_Str""+ GetHttpSession.RECOVER_OP;
      URL url=new URL(thisSessionServerProtocol,thisSessionServer,thisSessionServerPort,deploymentURI + ""String_Node_Str"" + query);
      HttpURLConnection conn=invokeRemote(url,sid,null);
      in=new DataInputStream(conn.getInputStream());
      sess=(InternalSession)sessionTable.get(sid);
      if (sess == null) {
        sess=resolveRestrictedToken(sid,false);
      }
    }
 catch (    Exception ex) {
      sessionDebug.error(""String_Node_Str"",ex);
    }
 finally {
      closeStream(in);
    }
    return sess;
  }
}"
9269,"/** 
 * Private Singleton Session Service.
 */
private SessionService(){
  KeyConversion keyConversion=new KeyConversion();
  tokenIdFactory=InjectorHolder.getInstance(TokenIdFactory.class);
  coreTokenConfig=InjectorHolder.getInstance(CoreTokenConfig.class);
  tokenAdapter=InjectorHolder.getInstance(SessionAdapter.class);
  try {
    dsameAdminDN=(String)AccessController.doPrivileged(new AdminDNAction());
    dsameAdminPassword=(String)AccessController.doPrivileged(new AdminPasswordAction());
    sessionServerProtocol=SystemProperties.get(Constants.AM_SERVER_PROTOCOL);
    sessionServer=SystemProperties.get(Constants.AM_SERVER_HOST);
    sessionServerPort=SystemProperties.get(Constants.AM_SERVER_PORT);
    sessionServerURI=SystemProperties.get(Constants.AM_SERVICES_DEPLOYMENT_DESCRIPTOR);
    sessionServerID=WebtopNaming.getServerID(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
    isSiteEnabled=WebtopNaming.isSiteEnabled(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
    if (isSiteEnabled) {
      sessionServerID=WebtopNaming.getSiteID(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
      String secondaryIDs=WebtopNaming.getSecondarySites(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
      secondaryServerIDs=new HashSet();
      if (secondaryIDs != null) {
        if (secondaryIDs.contains(""String_Node_Str"")) {
          StringTokenizer st=new StringTokenizer(secondaryIDs,""String_Node_Str"");
          while (st.hasMoreTokens()) {
            secondaryServerIDs.add(st.nextToken());
          }
        }
 else {
          secondaryServerIDs.add(secondaryIDs);
        }
      }
      sessionServiceID=new URL(WebtopNaming.getServerFromID(sessionServerID));
      sessionServerProtocol=sessionServiceID.getProtocol();
      sessionServer=sessionServiceID.getHost();
      sessionServerPort=Integer.toString(sessionServiceID.getPort());
    }
 else {
      sessionServiceID=new URL(WebtopNaming.getServerFromID(sessionServerID));
    }
    try {
      secureRandom=SecureRandom.getInstance(""String_Node_Str"",""String_Node_Str"");
    }
 catch (    NoSuchProviderException e) {
      secureRandom=SecureRandom.getInstance(""String_Node_Str"");
    }
    sessionTable=new Hashtable();
    remoteSessionSet=Collections.synchronizedSet(new HashSet());
    if (stats.isEnabled()) {
      maxSessionStats=new SessionMaxStats(sessionTable);
      stats.addStatsListener(maxSessionStats);
    }
    thisSessionServerProtocol=SystemProperties.get(Constants.AM_SERVER_PROTOCOL);
    thisSessionServer=SystemProperties.get(Constants.AM_SERVER_HOST);
    thisSessionServerPortAsString=SystemProperties.get(Constants.AM_SERVER_PORT);
    thisSessionURI=SystemProperties.get(Constants.AM_SERVICES_DEPLOYMENT_DESCRIPTOR);
    if ((thisSessionServerProtocol == null) || (thisSessionServerPortAsString == null) || (thisSessionServer == null)|| (thisSessionURI == null)) {
      throw new SessionException(SessionBundle.rbName,""String_Node_Str"",null);
    }
    thisSessionServerPort=Integer.parseInt(thisSessionServerPortAsString);
    thisSessionServerID=WebtopNaming.getServerID(thisSessionServerProtocol,thisSessionServer,thisSessionServerPortAsString,thisSessionURI);
    thisSessionServerURL=thisSessionServerProtocol + ""String_Node_Str"" + thisSessionServer+ ""String_Node_Str""+ thisSessionServerPortAsString+ thisSessionURI;
    thisSessionServiceURL=Session.getSessionServiceURL(thisSessionServerProtocol,thisSessionServer,thisSessionServerPortAsString,thisSessionURI);
    postInit();
  }
 catch (  Exception ex) {
    sessionDebug.error(""String_Node_Str"",ex);
  }
}","/** 
 * Private Singleton Session Service.
 */
private SessionService(){
  tokenIdFactory=InjectorHolder.getInstance(TokenIdFactory.class);
  coreTokenConfig=InjectorHolder.getInstance(CoreTokenConfig.class);
  tokenAdapter=InjectorHolder.getInstance(SessionAdapter.class);
  try {
    dsameAdminDN=(String)AccessController.doPrivileged(new AdminDNAction());
    dsameAdminPassword=(String)AccessController.doPrivileged(new AdminPasswordAction());
    sessionServerProtocol=SystemProperties.get(Constants.AM_SERVER_PROTOCOL);
    sessionServer=SystemProperties.get(Constants.AM_SERVER_HOST);
    sessionServerPort=SystemProperties.get(Constants.AM_SERVER_PORT);
    sessionServerURI=SystemProperties.get(Constants.AM_SERVICES_DEPLOYMENT_DESCRIPTOR);
    sessionServerID=WebtopNaming.getServerID(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
    isSiteEnabled=WebtopNaming.isSiteEnabled(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
    if (isSiteEnabled) {
      sessionServerID=WebtopNaming.getSiteID(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
      String secondaryIDs=WebtopNaming.getSecondarySites(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
      secondaryServerIDs=new HashSet();
      if (secondaryIDs != null) {
        if (secondaryIDs.contains(""String_Node_Str"")) {
          StringTokenizer st=new StringTokenizer(secondaryIDs,""String_Node_Str"");
          while (st.hasMoreTokens()) {
            secondaryServerIDs.add(st.nextToken());
          }
        }
 else {
          secondaryServerIDs.add(secondaryIDs);
        }
      }
      sessionServiceID=new URL(WebtopNaming.getServerFromID(sessionServerID));
      sessionServerProtocol=sessionServiceID.getProtocol();
      sessionServer=sessionServiceID.getHost();
      sessionServerPort=Integer.toString(sessionServiceID.getPort());
    }
 else {
      sessionServiceID=new URL(WebtopNaming.getServerFromID(sessionServerID));
    }
    try {
      secureRandom=SecureRandom.getInstance(""String_Node_Str"",""String_Node_Str"");
    }
 catch (    NoSuchProviderException e) {
      secureRandom=SecureRandom.getInstance(""String_Node_Str"");
    }
    sessionTable=new Hashtable();
    remoteSessionSet=Collections.synchronizedSet(new HashSet());
    if (stats.isEnabled()) {
      maxSessionStats=new SessionMaxStats(sessionTable);
      stats.addStatsListener(maxSessionStats);
    }
    thisSessionServerProtocol=SystemProperties.get(Constants.AM_SERVER_PROTOCOL);
    thisSessionServer=SystemProperties.get(Constants.AM_SERVER_HOST);
    thisSessionServerPortAsString=SystemProperties.get(Constants.AM_SERVER_PORT);
    thisSessionURI=SystemProperties.get(Constants.AM_SERVICES_DEPLOYMENT_DESCRIPTOR);
    if ((thisSessionServerProtocol == null) || (thisSessionServerPortAsString == null) || (thisSessionServer == null)|| (thisSessionURI == null)) {
      throw new SessionException(SessionBundle.rbName,""String_Node_Str"",null);
    }
    thisSessionServerPort=Integer.parseInt(thisSessionServerPortAsString);
    thisSessionServerID=WebtopNaming.getServerID(thisSessionServerProtocol,thisSessionServer,thisSessionServerPortAsString,thisSessionURI);
    thisSessionServerURL=thisSessionServerProtocol + ""String_Node_Str"" + thisSessionServer+ ""String_Node_Str""+ thisSessionServerPortAsString+ thisSessionURI;
    thisSessionServiceURL=Session.getSessionServiceURL(thisSessionServerProtocol,thisSessionServer,thisSessionServerPortAsString,thisSessionURI);
    postInit();
  }
 catch (  Exception ex) {
    sessionDebug.error(""String_Node_Str"",ex);
  }
}"
9270,"@Override protected void configure(){
  bind(new AdminTokenType()).toProvider(new AdminTokenProvider()).in(Singleton.class);
  bind(ServiceManagementDAO.class).to(ServiceManagementDAOWrapper.class).in(Singleton.class);
  bind(DNWrapper.class).in(Singleton.class);
  bind(IndexChangeObservable.class).in(Singleton.class);
  bind(ShutdownManagerWrapper.class).in(Singleton.class);
  bind(SearchResultHandler.class).to(IndexChangeHandler.class).in(Singleton.class);
  bind(IndexChangeManager.class).to(IndexChangeManagerImpl.class).in(Singleton.class);
  bind(IndexChangeMonitor.class).to(IndexChangeMonitorImpl.class).in(Singleton.class);
  bind(IndexTreeService.class).to(IndexTreeServiceImpl.class).in(Singleton.class);
  bind(new TypeLiteral<TokenAdapter<JsonValue>>(){
  }
).to(OAuthAdapter.class);
  bind(DataLayerConnectionFactory.class).in(Singleton.class);
  bind(DSConfigMgr.class).toProvider(new Provider<DSConfigMgr>(){
    public DSConfigMgr get(){
      try {
        return DSConfigMgr.getDSConfigMgr();
      }
 catch (      LDAPServiceException e) {
        throw new IllegalStateException(e);
      }
    }
  }
).in(Singleton.class);
  bind(Debug.class).annotatedWith(Names.named(CoreTokenConstants.CTS_DEBUG)).toInstance(Debug.getInstance(CoreTokenConstants.CTS_DEBUG));
  bind(Debug.class).annotatedWith(Names.named(CoreTokenConstants.CTS_REAPER_DEBUG)).toInstance(Debug.getInstance(CoreTokenConstants.CTS_REAPER_DEBUG));
  bind(CoreTokenConstants.class).in(Singleton.class);
  bind(CTSPersistentStore.class).in(Singleton.class);
  bind(CoreTokenConfig.class).in(Singleton.class);
  bind(ConnectionFactory.class).to(CTSConnectionFactory.class).in(Singleton.class);
  bind(LDAPConfig.class).toProvider(new Provider<LDAPConfig>(){
    public LDAPConfig get(){
      return new LDAPConfig(SMSEntry.getRootSuffix());
    }
  }
).in(Singleton.class);
  bind(ExternalTokenConfig.class).in(Singleton.class);
  bind(ConfigurationObserver.class).toProvider(new Provider<ConfigurationObserver>(){
    public ConfigurationObserver get(){
      return ConfigurationObserver.getInstance();
    }
  }
).in(Singleton.class);
  bind(ScheduledExecutorService.class).annotatedWith(Names.named(CTSReaper.CTS_SCHEDULED_SERVICE)).toInstance(Executors.newScheduledThreadPool(1));
  bind(SessionService.class).toProvider(new Provider<SessionService>(){
    public SessionService get(){
      return SessionService.getSessionService();
    }
  }
).in(Singleton.class);
}","@Override protected void configure(){
  bind(new AdminTokenType()).toProvider(new AdminTokenProvider()).in(Singleton.class);
  bind(ServiceManagementDAO.class).to(ServiceManagementDAOWrapper.class).in(Singleton.class);
  bind(DNWrapper.class).in(Singleton.class);
  bind(IndexChangeObservable.class).in(Singleton.class);
  bind(ShutdownManagerWrapper.class).in(Singleton.class);
  bind(SearchResultHandler.class).to(IndexChangeHandler.class).in(Singleton.class);
  bind(IndexChangeManager.class).to(IndexChangeManagerImpl.class).in(Singleton.class);
  bind(IndexChangeMonitor.class).to(IndexChangeMonitorImpl.class).in(Singleton.class);
  bind(IndexTreeService.class).to(IndexTreeServiceImpl.class).in(Singleton.class);
  bind(new TypeLiteral<TokenAdapter<JsonValue>>(){
  }
).to(OAuthAdapter.class);
  bind(DataLayerConnectionFactory.class).in(Singleton.class);
  bind(DSConfigMgr.class).toProvider(new Provider<DSConfigMgr>(){
    public DSConfigMgr get(){
      try {
        return DSConfigMgr.getDSConfigMgr();
      }
 catch (      LDAPServiceException e) {
        throw new IllegalStateException(e);
      }
    }
  }
).in(Singleton.class);
  bind(Debug.class).annotatedWith(Names.named(CoreTokenConstants.CTS_DEBUG)).toInstance(Debug.getInstance(CoreTokenConstants.CTS_DEBUG));
  bind(Debug.class).annotatedWith(Names.named(CoreTokenConstants.CTS_REAPER_DEBUG)).toInstance(Debug.getInstance(CoreTokenConstants.CTS_REAPER_DEBUG));
  bind(CoreTokenConstants.class).in(Singleton.class);
  bind(CTSPersistentStore.class).in(Singleton.class);
  bind(CoreTokenConfig.class).in(Singleton.class);
  bind(ConnectionFactory.class).to(CTSConnectionFactory.class).in(Singleton.class);
  bind(LDAPConfig.class).toProvider(new Provider<LDAPConfig>(){
    public LDAPConfig get(){
      return new LDAPConfig(SMSEntry.getRootSuffix());
    }
  }
).in(Singleton.class);
  bind(ExternalTokenConfig.class).in(Singleton.class);
  bind(ConfigurationObserver.class).toProvider(new Provider<ConfigurationObserver>(){
    public ConfigurationObserver get(){
      return ConfigurationObserver.getInstance();
    }
  }
).in(Singleton.class);
  bind(ScheduledExecutorService.class).annotatedWith(Names.named(CTSReaper.CTS_SCHEDULED_SERVICE)).toInstance(Executors.newScheduledThreadPool(1));
  bind(SessionService.class).toProvider(new Provider<SessionService>(){
    public SessionService get(){
      return SessionService.getSessionService();
    }
  }
).in(Singleton.class);
  bind(Debug.class).annotatedWith(Names.named(SessionConstants.SESSION_DEBUG)).toInstance(Debug.getInstance(SessionConstants.SESSION_DEBUG));
}"
9271,"/** 
 * Creates a default instance with dependencies defined.
 * @param tokenIdFactory Non null.
 * @param config Non null.
 * @param serialisation Non null.
 * @param blobUtils
 */
@Inject public SessionAdapter(TokenIdFactory tokenIdFactory,CoreTokenConfig config,JSONSerialisation serialisation,LDAPDataConversion dataConversion,TokenBlobUtils blobUtils){
  this.tokenIdFactory=tokenIdFactory;
  this.config=config;
  this.serialisation=serialisation;
  this.dataConversion=dataConversion;
  this.blobUtils=blobUtils;
}","/** 
 * Creates a default instance with dependencies defined.
 * @param tokenIdFactory Non null.
 * @param config Non null.
 * @param serialisation Non null.
 * @param blobUtils A collection of Binary Object utilities.
 */
@Inject public SessionAdapter(TokenIdFactory tokenIdFactory,CoreTokenConfig config,JSONSerialisation serialisation,LDAPDataConversion dataConversion,TokenBlobUtils blobUtils){
  this.tokenIdFactory=tokenIdFactory;
  this.config=config;
  this.serialisation=serialisation;
  this.dataConversion=dataConversion;
  this.blobUtils=blobUtils;
}"
9272,"private String getPasswordFromHeader(ServerContext context){
  return RestUtils.getCookieFromServerContext(context);
}","private String getPasswordFromHeader(ServerContext context){
  List<String> headerList=null;
  String oldUserPasswordHeaderName=""String_Node_Str"";
  HttpContext header=null;
  try {
    header=context.asContext(HttpContext.class);
    if (header == null) {
      RestDispatcher.debug.error(""String_Node_Str"" + ""String_Node_Str"");
      return null;
    }
    headerList=header.getHeaders().get(oldUserPasswordHeaderName.toLowerCase());
    if (headerList != null && !headerList.isEmpty()) {
      for (      String s : headerList) {
        return (s != null && !s.isEmpty()) ? s : null;
      }
    }
  }
 catch (  Exception e) {
    RestDispatcher.debug.error(""String_Node_Str"" + ""String_Node_Str"" + e);
  }
  return null;
}"
9273,"/** 
 * {@inheritDoc}
 */
@Override public void updateInstance(final ServerContext context,final String resourceId,final UpdateRequest request,final ResultHandler<Resource> handler){
  Token admin=new Token();
  admin.setId(getCookieFromServerContext(context));
  final JsonValue jVal=request.getNewContent();
  final String rev=request.getRevision();
  IdentityDetails dtls, newDtls;
  IdentityServicesImpl idsvc=new IdentityServicesImpl();
  ;
  Resource resource;
  try {
    dtls=idsvc.read(resourceId,idSvcsAttrList,admin);
    newDtls=jsonValueToIdentityDetails(jVal);
    newDtls.setName(resourceId);
    String userpass=jVal.get(""String_Node_Str"").asString();
    if (userpass != null && !userpass.isEmpty()) {
      if (checkValidPassword(resourceId,userpass.toCharArray(),realm) || isAdmin(context)) {
      }
 else {
        String strPass=getPasswordFromHeader(context);
        if (strPass != null && !strPass.isEmpty() && checkValidPassword(resourceId,strPass.toCharArray(),realm)) {
        }
 else {
          throw new ForbiddenException(""String_Node_Str"",null);
        }
      }
    }
    UpdateResponse message=idsvc.update(newDtls,admin);
    IdentityDetails checkIdent=idsvc.read(dtls.getName(),idSvcsAttrList,admin);
    resource=new Resource(resourceId,""String_Node_Str"",identityDetailsToJsonValue(checkIdent));
    handler.handleResult(resource);
  }
 catch (  final ObjectNotFound onf) {
    RestDispatcher.debug.error(""String_Node_Str"" + onf);
    handler.handleError(new NotFoundException(""String_Node_Str"" + resourceId + ""String_Node_Str"",onf));
  }
catch (  final NeedMoreCredentials needMoreCredentials) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ needMoreCredentials);
    handler.handleError(new ForbiddenException(""String_Node_Str"",needMoreCredentials));
  }
catch (  final TokenExpired tokenExpired) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ tokenExpired);
    handler.handleError(new PermanentException(401,""String_Node_Str"",null));
  }
catch (  final AccessDenied accessDenied) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ accessDenied);
    handler.handleError(new ForbiddenException(accessDenied.getMessage(),accessDenied));
  }
catch (  final GeneralFailure generalFailure) {
    RestDispatcher.debug.error(""String_Node_Str"" + generalFailure);
    handler.handleError(new BadRequestException(generalFailure.getMessage(),generalFailure));
  }
catch (  ForbiddenException fe) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ fe);
    handler.handleError(fe);
  }
catch (  final Exception exception) {
    RestDispatcher.debug.error(""String_Node_Str"" + exception);
    handler.handleError(new NotFoundException(exception.getMessage(),exception));
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void updateInstance(final ServerContext context,final String resourceId,final UpdateRequest request,final ResultHandler<Resource> handler){
  Token admin=new Token();
  admin.setId(getCookieFromServerContext(context));
  final JsonValue jVal=request.getNewContent();
  final String rev=request.getRevision();
  IdentityDetails dtls, newDtls;
  IdentityServicesImpl idsvc=new IdentityServicesImpl();
  ;
  Resource resource;
  try {
    dtls=idsvc.read(resourceId,idSvcsAttrList,admin);
    newDtls=jsonValueToIdentityDetails(jVal);
    newDtls.setName(resourceId);
    String userpass=jVal.get(""String_Node_Str"").asString();
    if (userpass != null && !userpass.isEmpty()) {
      if (checkValidPassword(resourceId,userpass.toCharArray(),realm) || isAdmin(context)) {
      }
 else {
        String strPass=getPasswordFromHeader(context);
        if (strPass != null && !strPass.isEmpty() && checkValidPassword(resourceId,strPass.toCharArray(),realm)) {
        }
 else {
          throw new BadRequestException(""String_Node_Str"");
        }
      }
    }
    UpdateResponse message=idsvc.update(newDtls,admin);
    IdentityDetails checkIdent=idsvc.read(dtls.getName(),idSvcsAttrList,admin);
    resource=new Resource(resourceId,""String_Node_Str"",identityDetailsToJsonValue(checkIdent));
    handler.handleResult(resource);
  }
 catch (  final ObjectNotFound onf) {
    RestDispatcher.debug.error(""String_Node_Str"" + onf);
    handler.handleError(new NotFoundException(""String_Node_Str"" + resourceId + ""String_Node_Str"",onf));
  }
catch (  final NeedMoreCredentials needMoreCredentials) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ needMoreCredentials);
    handler.handleError(new ForbiddenException(""String_Node_Str"",needMoreCredentials));
  }
catch (  final TokenExpired tokenExpired) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ tokenExpired);
    handler.handleError(new PermanentException(401,""String_Node_Str"",null));
  }
catch (  final AccessDenied accessDenied) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ accessDenied);
    handler.handleError(new ForbiddenException(accessDenied.getMessage(),accessDenied));
  }
catch (  final GeneralFailure generalFailure) {
    RestDispatcher.debug.error(""String_Node_Str"" + generalFailure);
    handler.handleError(new BadRequestException(generalFailure.getMessage(),generalFailure));
  }
catch (  BadRequestException bre) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ bre);
    handler.handleError(bre);
  }
catch (  final Exception exception) {
    RestDispatcher.debug.error(""String_Node_Str"" + exception);
    handler.handleError(new NotFoundException(exception.getMessage(),exception));
  }
}"
9274,"@Post(""String_Node_Str"") public Representation represent(Representation entity){
  Representation rep=null;
  client=getAuthenticatedClient();
  if (client.getClient().getClientType().equals(ClientApplication.ClientType.PUBLIC)) {
    OAuth2Utils.DEBUG.warning(""String_Node_Str"");
    throw OAuthProblemException.OAuthError.INVALID_CLIENT.handle(getRequest(),""String_Node_Str"");
  }
  String scope_before=OAuth2Utils.getRequestParameter(getRequest(),OAuth2Constants.Params.SCOPE,String.class);
  Set<String> checkedScope=executeAccessTokenScopePlugin(scope_before);
  CoreToken token=createAccessToken(checkedScope);
  Map<String,Object> response=token.convertToMap();
  Map<String,String> data=new HashMap<String,String>();
  response.putAll(executeExtraDataScopePlugin(data,token));
  if (checkedScope != null && !checkedScope.isEmpty()) {
    response.put(OAuth2Constants.Params.SCOPE,OAuth2Utils.join(checkedScope,OAuth2Utils.getScopeDelimiter(getContext())));
  }
  return new JacksonRepresentation<Map>(response);
}","@Post(""String_Node_Str"") public Representation represent(Representation entity){
  Representation rep=null;
  client=getAuthenticatedClient();
  if (client.getClient().getClientType().equals(ClientApplication.ClientType.PUBLIC)) {
    OAuth2Utils.DEBUG.warning(""String_Node_Str"");
    throw OAuthProblemException.OAuthError.UNAUTHORIZED_CLIENT.handle(getRequest(),""String_Node_Str"");
  }
  String scope_before=OAuth2Utils.getRequestParameter(getRequest(),OAuth2Constants.Params.SCOPE,String.class);
  Set<String> checkedScope=executeAccessTokenScopePlugin(scope_before);
  CoreToken token=createAccessToken(checkedScope);
  Map<String,Object> response=token.convertToMap();
  Map<String,String> data=new HashMap<String,String>();
  response.putAll(executeExtraDataScopePlugin(data,token));
  if (checkedScope != null && !checkedScope.isEmpty()) {
    response.put(OAuth2Constants.Params.SCOPE,OAuth2Utils.join(checkedScope,OAuth2Utils.getScopeDelimiter(getContext())));
  }
  return new JacksonRepresentation<Map>(response);
}"
9275,"/** 
 * The function to run when timeout.
 */
public void run(){
  if (!isTimedOut()) {
    if (sessionState == Session.INVALID) {
      setState(Session.DESTROYED);
      ss.removeInternalSession(sessionID);
      ss.sendEvent(this,SessionEvent.DESTROY);
    }
 else {
      long timeLeft=getTimeLeft();
      if (timeLeft == 0) {
        changeStateAndNotify(SessionEvent.MAX_TIMEOUT);
        if (timerPool != null) {
          if (purgeDelay > 0) {
            timerPool.schedule(this,new Date((timedOutAt + (purgeDelay * 60)) * 1000));
          }
        }
      }
 else {
        long idleTimeLeft=(maxIdleTime * 60) - getIdleTime();
        if (idleTimeLeft <= 0 && sessionState != Session.INACTIVE) {
          changeStateAndNotify(SessionEvent.IDLE_TIMEOUT);
          if (timerPool != null) {
            if (purgeDelay > 0) {
              timerPool.schedule(this,new Date((timedOutAt + (purgeDelay * 60)) * 1000));
            }
          }
        }
 else {
          long timeToWait=Math.min(timeLeft,idleTimeLeft);
          if (timerPool != null) {
            timerPool.schedule(this,new Date(((System.currentTimeMillis() / 1000) + timeToWait) * 1000));
          }
        }
      }
    }
  }
 else {
    ss.logEvent(this,SessionEvent.DESTROY);
    setState(Session.DESTROYED);
    ss.removeInternalSession(sessionID);
    ss.sendEvent(this,SessionEvent.DESTROY);
  }
}","/** 
 * The function to run when timeout.
 */
public void run(){
  if (!isTimedOut()) {
    if (isInvalid()) {
      removeSession();
    }
 else {
      long timeLeft=getTimeLeft();
      if (timeLeft == 0) {
        changeStateAndNotify(SessionEvent.MAX_TIMEOUT);
        if (timerPool != null) {
          if (purgeDelay > 0) {
            timerPool.schedule(this,new Date((timedOutAt + (purgeDelay * 60)) * 1000));
          }
        }
      }
 else {
        long idleTimeLeft=(maxIdleTime * 60) - getIdleTime();
        if (idleTimeLeft <= 0 && sessionState != Session.INACTIVE) {
          changeStateAndNotify(SessionEvent.IDLE_TIMEOUT);
          if (timerPool != null) {
            if (purgeDelay > 0) {
              timerPool.schedule(this,new Date((timedOutAt + (purgeDelay * 60)) * 1000));
            }
          }
        }
 else {
          long timeToWait=Math.min(timeLeft,idleTimeLeft);
          if (timerPool != null) {
            timerPool.schedule(this,new Date(((System.currentTimeMillis() / 1000) + timeToWait) * 1000));
          }
        }
      }
    }
  }
 else {
    removeSession();
  }
}"
9276,"/** 
 * Returns true if cookies are supported.
 * @return true if cookie supported;
 */
private boolean getCookieSupport(){
  boolean cookieSupport=false;
  try {
    if (sessionID.getCookieMode() != null) {
      cookieSupport=sessionID.getCookieMode().booleanValue();
    }
 else     if (this.cookieMode != null) {
      cookieSupport=this.cookieMode.booleanValue();
    }
  }
 catch (  Exception ex) {
    DEBUG.error(""String_Node_Str"",ex);
    cookieSupport=true;
  }
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + cookieSupport);
  }
  return cookieSupport;
}","/** 
 * Returns true if cookies are supported.
 * @return true if cookie supported;
 */
private boolean getCookieSupport(){
  boolean cookieSupport=false;
  try {
    if (sessionID.getCookieMode() != null) {
      cookieSupport=sessionID.getCookieMode().booleanValue();
    }
 else     if (this.cookieMode != null) {
      cookieSupport=this.cookieMode.booleanValue();
    }
  }
 catch (  Exception ex) {
    debug.error(""String_Node_Str"",ex);
    cookieSupport=true;
  }
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + cookieSupport);
  }
  return cookieSupport;
}"
9277,"/** 
 * Transfers the info about the Internal Session to Session Info.
 * @return SessionInfo
 */
public SessionInfo toSessionInfo(){
  SessionInfo info=new SessionInfo();
  info.sid=sessionID.toString();
  if (sessionType == Session.USER_SESSION) {
    info.stype=""String_Node_Str"";
  }
 else   if (sessionType == Session.APPLICATION_SESSION) {
    info.stype=""String_Node_Str"";
  }
  info.cid=clientID;
  info.cdomain=clientDomain;
  info.maxtime=Long.toString(getMaxSessionTime());
  info.maxidle=Long.toString(getMaxIdleTime());
  info.maxcaching=Long.toString(getMaxCachingTime());
  if (willExpireFlag == true) {
    info.timeidle=Long.toString(getIdleTime());
    info.timeleft=Long.toString(getTimeLeft());
  }
 else {
    info.timeidle=Long.toString(0);
    info.timeleft=Long.toString(Long.MAX_VALUE / 60);
  }
  if (sessionState == Session.INVALID) {
    info.state=""String_Node_Str"";
  }
 else   if (sessionState == Session.VALID) {
    info.state=""String_Node_Str"";
  }
 else   if (sessionState == Session.INACTIVE) {
    info.state=""String_Node_Str"";
  }
 else   if (sessionState == Session.DESTROYED) {
    info.state=""String_Node_Str"";
  }
  info.properties=(Properties)sessionProperties.clone();
  return info;
}","/** 
 * Transfers the info about the Internal Session to Session Info.
 * @return SessionInfo
 */
public SessionInfo toSessionInfo(){
  SessionInfo info=new SessionInfo();
  info.sid=sessionID.toString();
  if (sessionType == Session.USER_SESSION) {
    info.stype=""String_Node_Str"";
  }
 else   if (sessionType == Session.APPLICATION_SESSION) {
    info.stype=""String_Node_Str"";
  }
  info.cid=clientID;
  info.cdomain=clientDomain;
  info.maxtime=Long.toString(getMaxSessionTime());
  info.maxidle=Long.toString(getMaxIdleTime());
  info.maxcaching=Long.toString(getMaxCachingTime());
  if (willExpireFlag == true) {
    info.timeidle=Long.toString(getIdleTime());
    info.timeleft=Long.toString(getTimeLeft());
  }
 else {
    info.timeidle=Long.toString(0);
    info.timeleft=Long.toString(Long.MAX_VALUE / 60);
  }
  if (isInvalid()) {
    info.state=""String_Node_Str"";
  }
 else   if (sessionState == Session.VALID) {
    info.state=""String_Node_Str"";
  }
 else   if (sessionState == Session.INACTIVE) {
    info.state=""String_Node_Str"";
  }
 else   if (sessionState == Session.DESTROYED) {
    info.state=""String_Node_Str"";
  }
  info.properties=(Properties)sessionProperties.clone();
  return info;
}"
9278,"/** 
 * set the cookieMode based on whether the request has cookies or not. This method is called from createSSOToken(request) method in SSOTokenManager.
 * @param cookieMode ,Boolean value whether request has cookies or not.
 */
public void setCookieMode(Boolean cookieMode){
  DEBUG.message(""String_Node_Str"" + cookieMode);
  if (cookieMode != null) {
    this.cookieMode=cookieMode;
  }
}","/** 
 * set the cookieMode based on whether the request has cookies or not. This method is called from createSSOToken(request) method in SSOTokenManager.
 * @param cookieMode ,Boolean value whether request has cookies or not.
 */
public void setCookieMode(Boolean cookieMode){
  debug.message(""String_Node_Str"" + cookieMode);
  if (cookieMode != null) {
    this.cookieMode=cookieMode;
  }
}"
9279,"/** 
 * Encodes the url by adding the cookiename=sid to it. if cookie support is true returns without encoding <p> The cookie Value is written in the URL based on the encodingScheme specified. The Cookie Value could be written as path info separated by either a ""/"" OR  "";"" or as a query string. <p> If the encoding scheme is SLASH then the  cookie value would be written in the URL as extra path info in the following format: <pre> protocol://server:port/servletpath/&lt;cookieName>=&lt;cookieValue>? queryString      </pre> <p> Note that this format works only if the path is a servlet, if a a jsp file is specified then webcontainers return with ""File Not found"" error. To rewrite links which are JSP files with cookie value use the SEMICOLON OR QUERY encoding scheme.      <p> If the encoding scheme is SEMICOLON then the cookie value would be written in the URL as extra path info in the following format: <pre> protocol://server:port/path;&lt;cookieName=cookieValue>?queryString </pre> Note that this is not supported in the servlet specification and some web containers do not support this. <p> If the encoding scheme is QUERY then the cookie value would be written in the URL in the following format: <pre> protocol://server:port/path?&lt;cookieName>=&lt;cookieValue> protocol://server:port/path?queryString&&lt;cookieName>=&lt;cookieValue> </pre> <p> This is the default and OpenSSO always encodes in this format  unless otherwise specified. If the URL passed in has query parameter then entity escaping of ampersand will be done before appending the cookie if the escape is true.  Only the ampersand before appending  cookie parameter will be entity escaped. <p>
 * @param url the url to be encoded
 * @param encodingScheme possible values are QUERY,SLASH,SEMICOLON
 * @param escape entity escaping of ampersand when appending theSSOToken ID to request query string.
 * @param cookieName 
 * @return encoded URL with cookie value (session id) basedon the encoding scheme or the url itself if there is an error.
 */
public String encodeURL(String url,short encodingScheme,boolean escape,String cookieName){
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + url);
  }
  String encodedURL=url;
  if (((url != null) && (url.length() > 0)) && !getCookieSupport()) {
    if ((cookieStr != null && cookieStr.length() != 0) && (Session.foundCookieName(cookieStr,cookieName))) {
      encodedURL=SessionEncodeURL.buildCookieString(url,cookieStr,encodingScheme,escape);
    }
 else {
      if (sessionID != null) {
        cookieStr=SessionEncodeURL.createCookieString(cookieName,sessionID.toString());
        encodedURL=SessionEncodeURL.encodeURL(cookieStr,url,encodingScheme,escape);
      }
    }
  }
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + ""String_Node_Str"" + encodedURL);
  }
  return encodedURL;
}","/** 
 * Encodes the url by adding the cookiename=sid to it. if cookie support is true returns without encoding <p> The cookie Value is written in the URL based on the encodingScheme specified. The Cookie Value could be written as path info separated by either a ""/"" OR  "";"" or as a query string. <p> If the encoding scheme is SLASH then the  cookie value would be written in the URL as extra path info in the following format: <pre> protocol://server:port/servletpath/&lt;cookieName>=&lt;cookieValue>? queryString      </pre> <p> Note that this format works only if the path is a servlet, if a a jsp file is specified then webcontainers return with ""File Not found"" error. To rewrite links which are JSP files with cookie value use the SEMICOLON OR QUERY encoding scheme.      <p> If the encoding scheme is SEMICOLON then the cookie value would be written in the URL as extra path info in the following format: <pre> protocol://server:port/path;&lt;cookieName=cookieValue>?queryString </pre> Note that this is not supported in the servlet specification and some web containers do not support this. <p> If the encoding scheme is QUERY then the cookie value would be written in the URL in the following format: <pre> protocol://server:port/path?&lt;cookieName>=&lt;cookieValue> protocol://server:port/path?queryString&&lt;cookieName>=&lt;cookieValue> </pre> <p> This is the default and OpenSSO always encodes in this format  unless otherwise specified. If the URL passed in has query parameter then entity escaping of ampersand will be done before appending the cookie if the escape is true.  Only the ampersand before appending  cookie parameter will be entity escaped. <p>
 * @param url the url to be encoded
 * @param encodingScheme possible values are QUERY,SLASH,SEMICOLON
 * @param escape entity escaping of ampersand when appending theSSOToken ID to request query string.
 * @param cookieName 
 * @return encoded URL with cookie value (session id) basedon the encoding scheme or the url itself if there is an error.
 */
public String encodeURL(String url,short encodingScheme,boolean escape,String cookieName){
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + url);
  }
  String encodedURL=url;
  if (((url != null) && (url.length() > 0)) && !getCookieSupport()) {
    if ((cookieStr != null && cookieStr.length() != 0) && (Session.foundCookieName(cookieStr,cookieName))) {
      encodedURL=SessionEncodeURL.buildCookieString(url,cookieStr,encodingScheme,escape);
    }
 else {
      if (sessionID != null) {
        cookieStr=SessionEncodeURL.createCookieString(cookieName,sessionID.toString());
        encodedURL=SessionEncodeURL.encodeURL(cookieStr,url,encodingScheme,escape);
      }
    }
  }
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + ""String_Node_Str"" + encodedURL);
  }
  return encodedURL;
}"
9280,"/** 
 * Sets the key-value pair in the InternalSession property table if it is not protected. If it is protected client should have permission to set it. This method is to be used in conjuction with SessionRequestHandler/SessionService invocation path If the property is protected, an attempt to remotely set a protected property is logged and the method throws an Exception. Otherwise invocation is delegated to internalPutProperty() Note that package default access is being used
 * @param clientToken Token of the client setting external property.
 * @param key Property key
 * @param value Property value for the key
 * @exception SessionException is thrown if the key is protected property.
 */
void putExternalProperty(SSOToken clientToken,String key,String value) throws SessionException {
  try {
    SessionUtils.checkPermissionToSetProperty(clientToken,key,value);
  }
 catch (  SessionException se) {
    SessionService.getSessionService().logIt(this,""String_Node_Str"");
    throw se;
  }
  internalPutProperty(key,value);
  if (DEBUG.messageEnabled()) {
    DEBUG.message(""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Sets the key-value pair in the InternalSession property table if it is not protected. If it is protected client should have permission to set it. This method is to be used in conjuction with SessionRequestHandler/SessionService invocation path If the property is protected, an attempt to remotely set a protected property is logged and the method throws an Exception. Otherwise invocation is delegated to internalPutProperty() Note that package default access is being used
 * @param clientToken Token of the client setting external property.
 * @param key Property key
 * @param value Property value for the key
 * @exception SessionException is thrown if the key is protected property.
 */
void putExternalProperty(SSOToken clientToken,String key,String value) throws SessionException {
  try {
    SessionUtils.checkPermissionToSetProperty(clientToken,key,value);
  }
 catch (  SessionException se) {
    SessionService.getSessionService().logIt(this,""String_Node_Str"");
    throw se;
  }
  internalPutProperty(key,value);
  if (debug.messageEnabled()) {
    debug.message(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
9281,"/** 
 * Changes the state of the session to ACTIVE after creation.
 * @param userDN 
 * @return <code> true </code> if the session is successfully activated after creation , <code>false</code> otherwise
 */
public boolean activate(String userDN){
  if (userDN == null) {
    return false;
  }
  if ((SessionService.getActiveSessions() >= SessionService.maxSessions) && (!userDN.equalsIgnoreCase(superUserDN))) {
    SessionService.getSessionService().logSystemMessage(LOG_MSG_SESSION_MAX_LIMIT_REACHED,java.util.logging.Level.INFO);
    return false;
  }
  if ((SessionService.isSessionConstraintEnabled()) && !shouldIgnoreSessionQuotaChecking(userDN)) {
    if (SessionConstraint.checkQuotaAndPerformAction(this)) {
      if (DEBUG.messageEnabled()) {
        DEBUG.message(""String_Node_Str"" + ""String_Node_Str"");
      }
      SessionService.getSessionService().logEvent(this,SessionEvent.QUOTA_EXHAUSTED);
      return false;
    }
  }
  setLatestAccessTime();
  setState(Session.VALID);
  if (reschedulePossible) {
    reschedule();
  }
  SessionService.getSessionService().logEvent(this,SessionEvent.SESSION_CREATION);
  SessionService.getSessionService().sendEvent(this,SessionEvent.SESSION_CREATION);
  if (!isAppSession() || SessionService.returnAppSession) {
    SessionService.incrementActiveSessions();
  }
  return true;
}","/** 
 * Changes the state of the session to ACTIVE after creation.
 * @param userDN 
 * @return <code> true </code> if the session is successfully activated after creation , <code>false</code> otherwise
 */
public boolean activate(String userDN){
  if (userDN == null) {
    return false;
  }
  if ((SessionService.getActiveSessions() >= SessionService.maxSessions) && (!userDN.equalsIgnoreCase(superUserDN))) {
    SessionService.getSessionService().logSystemMessage(LOG_MSG_SESSION_MAX_LIMIT_REACHED,java.util.logging.Level.INFO);
    return false;
  }
  if ((SessionService.isSessionConstraintEnabled()) && !shouldIgnoreSessionQuotaChecking(userDN)) {
    if (SessionConstraint.checkQuotaAndPerformAction(this)) {
      if (debug.messageEnabled()) {
        debug.message(""String_Node_Str"" + ""String_Node_Str"");
      }
      SessionService.getSessionService().logEvent(this,SessionEvent.QUOTA_EXHAUSTED);
      return false;
    }
  }
  setLatestAccessTime();
  setState(Session.VALID);
  if (reschedulePossible) {
    reschedule();
  }
  SessionService.getSessionService().logEvent(this,SessionEvent.SESSION_CREATION);
  SessionService.getSessionService().sendEvent(this,SessionEvent.SESSION_CREATION);
  if (!isAppSession() || SessionService.returnAppSession) {
    SessionService.incrementActiveSessions();
  }
  return true;
}"
9282,"/** 
 * Default constructor required for deserialisation.
 */
public InternalSession(){
  this(null,SessionService.getSessionService(),SessionService.sessionDebug);
}","/** 
 * Default constructor required for deserialisation.
 */
public InternalSession(){
}"
9283,"/** 
 * Sets the key-value pair in the Internal Session property table.
 * @param key Property key
 * @param value Property value for the key
 */
protected void internalPutProperty(String key,String value){
  if (key.equals(HOST_NAME) || key.equals(HOST)) {
    if (value == null || value.length() == 0) {
      return;
    }
    if (isEnableHostLookUp) {
      try {
        InetAddress address=java.net.InetAddress.getByName(value);
        String hostName=address.getHostName();
        sessionProperties.put(HOST_NAME,hostName);
        sessionProperties.put(HOST,value);
      }
 catch (      UnknownHostException uhe) {
        DEBUG.error(""String_Node_Str"" + ""String_Node_Str"" + value + ""String_Node_Str"",uhe);
      }
    }
 else {
      sessionProperties.put(HOST_NAME,value);
      sessionProperties.put(HOST,value);
    }
  }
 else   if (key.equals(AM_MAX_IDLE_TIME)) {
    setMaxIdleTime(Long.parseLong(value));
  }
 else {
    sessionProperties.put(key,value);
  }
  if (sessionState == Session.VALID && SessionService.isSendPropertyNotification(key)) {
    SessionService.getSessionService().sendEvent(this,SessionEvent.PROPERTY_CHANGED);
    SessionService.getSessionService().logEvent(this,SessionEvent.PROPERTY_CHANGED);
  }
  updateForFailover();
}","/** 
 * Sets the key-value pair in the Internal Session property table.
 * @param key Property key
 * @param value Property value for the key
 */
protected void internalPutProperty(String key,String value){
  if (key.equals(HOST_NAME) || key.equals(HOST)) {
    if (value == null || value.length() == 0) {
      return;
    }
    if (isEnableHostLookUp) {
      try {
        InetAddress address=java.net.InetAddress.getByName(value);
        String hostName=address.getHostName();
        sessionProperties.put(HOST_NAME,hostName);
        sessionProperties.put(HOST,value);
      }
 catch (      UnknownHostException uhe) {
        debug.error(""String_Node_Str"" + ""String_Node_Str"" + value + ""String_Node_Str"",uhe);
      }
    }
 else {
      sessionProperties.put(HOST_NAME,value);
      sessionProperties.put(HOST,value);
    }
  }
 else   if (key.equals(AM_MAX_IDLE_TIME)) {
    setMaxIdleTime(Long.parseLong(value));
  }
 else {
    sessionProperties.put(key,value);
  }
  if (sessionState == Session.VALID && SessionService.isSendPropertyNotification(key)) {
    SessionService.getSessionService().sendEvent(this,SessionEvent.PROPERTY_CHANGED);
    SessionService.getSessionService().logEvent(this,SessionEvent.PROPERTY_CHANGED);
  }
  updateForFailover();
}"
9284,"/** 
 * Checks whether the sesion should be destroyed or not.
 */
boolean shouldDestroy(){
  if (willExpireFlag == false) {
    return false;
  }
  if (!isTimedOut()) {
    if (sessionState == Session.INVALID) {
      if (checkInvalidSessionDefaultIdleTime()) {
        setState(Session.DESTROYED);
        ss.sendEvent(this,SessionEvent.DESTROY);
        return true;
      }
 else {
        return false;
      }
    }
    if (getTimeLeft() == 0) {
      changeStateAndNotify(SessionEvent.MAX_TIMEOUT);
      return false;
    }
    if (getIdleTime() >= maxIdleTime * 60 && sessionState != Session.INACTIVE) {
      changeStateAndNotify(SessionEvent.IDLE_TIMEOUT);
      return false;
    }
    return false;
  }
 else {
    if (getTimeLeftBeforePurge() <= 0) {
      SessionService.getSessionService().logEvent(this,SessionEvent.DESTROY);
      setState(Session.DESTROYED);
      SessionService.getSessionService().sendEvent(this,SessionEvent.DESTROY);
      return true;
    }
 else {
      return false;
    }
  }
}","/** 
 * Checks whether the sesion should be destroyed or not.
 */
boolean shouldDestroy(){
  if (willExpireFlag == false) {
    return false;
  }
  if (!isTimedOut()) {
    if (isInvalid()) {
      if (checkInvalidSessionDefaultIdleTime()) {
        setState(Session.DESTROYED);
        ss.sendEvent(this,SessionEvent.DESTROY);
        return true;
      }
 else {
        return false;
      }
    }
    if (getTimeLeft() == 0) {
      changeStateAndNotify(SessionEvent.MAX_TIMEOUT);
      return false;
    }
    if (getIdleTime() >= maxIdleTime * 60 && sessionState != Session.INACTIVE) {
      changeStateAndNotify(SessionEvent.IDLE_TIMEOUT);
      return false;
    }
    return false;
  }
 else {
    if (getTimeLeftBeforePurge() <= 0) {
      SessionService.getSessionService().logEvent(this,SessionEvent.DESTROY);
      setState(Session.DESTROYED);
      SessionService.getSessionService().sendEvent(this,SessionEvent.DESTROY);
      return true;
    }
 else {
      return false;
    }
  }
}"
9285,"/** 
 * Static initialisation section will be called the first time the SessionService is initailised. Note: This function depends on the singleton pattern that the SessionService follows.
 */
private static void initialiseStatic(){
  sessionDebug=Debug.getInstance(""String_Node_Str"");
  stats=Stats.getInstance(""String_Node_Str"");
  int poolSize=DEFAULT_POOL_SIZE;
  int threshold=DEFAULT_THRESHOLD;
  String size=SystemProperties.get(Constants.NOTIFICATION_THREADPOOL_SIZE);
  if (size != null) {
    try {
      poolSize=Integer.parseInt(size);
    }
 catch (    NumberFormatException e) {
      sessionDebug.error(""String_Node_Str"" + size + ""String_Node_Str""+ DEFAULT_POOL_SIZE);
    }
  }
  String thres=SystemProperties.get(Constants.NOTIFICATION_THREADPOOL_THRESHOLD);
  if (thres != null) {
    try {
      threshold=Integer.parseInt(thres);
    }
 catch (    Exception e) {
      sessionDebug.error(""String_Node_Str"" + thres + ""String_Node_Str""+ DEFAULT_THRESHOLD);
    }
  }
  ShutdownManager shutdownMan=ShutdownManager.getInstance();
  if (shutdownMan.acquireValidLock()) {
    try {
      threadPool=new ThreadPool(""String_Node_Str"",poolSize,threshold,true,sessionDebug);
      shutdownMan.addShutdownListener(new ShutdownListener(){
        public void shutdown(){
          threadPool.shutdown();
        }
      }
);
    }
  finally {
      shutdownMan.releaseLockAndNotify();
    }
  }
  if (threadPool != null) {
    try {
      maxSessions=Integer.parseInt(SystemProperties.get(Constants.AM_SESSION_MAX_SESSIONS));
    }
 catch (    Exception ex) {
      maxSessions=10000;
    }
  }
  String status=SystemProperties.get(Constants.AM_LOGSTATUS);
  if (status == null) {
    status=""String_Node_Str"";
  }
  logStatus=status.equalsIgnoreCase(""String_Node_Str"");
}","/** 
 * Static initialisation section will be called the first time the SessionService is initailised. Note: This function depends on the singleton pattern that the SessionService follows.
 */
private static void initialiseStatic(){
  Key<Debug> key=Key.get(Debug.class,Names.named(SessionConstants.SESSION_DEBUG));
  sessionDebug=InjectorHolder.getInstance(key);
  stats=Stats.getInstance(""String_Node_Str"");
  int poolSize=DEFAULT_POOL_SIZE;
  int threshold=DEFAULT_THRESHOLD;
  String size=SystemProperties.get(Constants.NOTIFICATION_THREADPOOL_SIZE);
  if (size != null) {
    try {
      poolSize=Integer.parseInt(size);
    }
 catch (    NumberFormatException e) {
      sessionDebug.error(""String_Node_Str"" + size + ""String_Node_Str""+ DEFAULT_POOL_SIZE);
    }
  }
  String thres=SystemProperties.get(Constants.NOTIFICATION_THREADPOOL_THRESHOLD);
  if (thres != null) {
    try {
      threshold=Integer.parseInt(thres);
    }
 catch (    Exception e) {
      sessionDebug.error(""String_Node_Str"" + thres + ""String_Node_Str""+ DEFAULT_THRESHOLD);
    }
  }
  ShutdownManager shutdownMan=ShutdownManager.getInstance();
  if (shutdownMan.acquireValidLock()) {
    try {
      threadPool=new ThreadPool(""String_Node_Str"",poolSize,threshold,true,sessionDebug);
      shutdownMan.addShutdownListener(new ShutdownListener(){
        public void shutdown(){
          threadPool.shutdown();
        }
      }
);
    }
  finally {
      shutdownMan.releaseLockAndNotify();
    }
  }
  if (threadPool != null) {
    try {
      maxSessions=Integer.parseInt(SystemProperties.get(Constants.AM_SESSION_MAX_SESSIONS));
    }
 catch (    Exception ex) {
      maxSessions=10000;
    }
  }
  String status=SystemProperties.get(Constants.AM_LOGSTATUS);
  if (status == null) {
    status=""String_Node_Str"";
  }
  logStatus=status.equalsIgnoreCase(""String_Node_Str"");
}"
9286,"/** 
 * Removes the Internal Session from the Internal Session table.
 * @param sid Session ID
 */
InternalSession removeInternalSession(SessionID sid){
  boolean isSessionStored=true;
  if (sid == null)   return null;
  InternalSession session=(InternalSession)sessionTable.remove(sid);
  if (session != null) {
    remoteSessionSet.remove(sid);
    session.cancel();
    removeSessionHandle(session);
    removeRestrictedTokens(session);
    isSessionStored=session.getIsISstored();
    if (session.getState() == Session.VALID) {
      decrementActiveSessions();
      SessionCount.decrementSessionCount(session);
    }
  }
  if (isSessionFailoverEnabled && isSessionStored) {
    if (getUseInternalRequestRouting()) {
      try {
        String tokenId=tokenIdFactory.toSessionTokenId(session);
        getRepository().delete(tokenId);
      }
 catch (      Exception e) {
        sessionDebug.error(""String_Node_Str"",e);
      }
    }
 else {
      invalidateHttpSession(sid);
    }
  }
  return session;
}","/** 
 * Removes the Internal Session from the Internal Session table.
 * @param sid Session ID
 */
InternalSession removeInternalSession(SessionID sid){
  boolean isSessionStored=false;
  if (sid == null)   return null;
  InternalSession session=(InternalSession)sessionTable.remove(sid);
  if (session != null) {
    remoteSessionSet.remove(sid);
    session.cancel();
    removeSessionHandle(session);
    removeRestrictedTokens(session);
    isSessionStored=session.getIsISstored();
    if (session.getState() == Session.VALID) {
      decrementActiveSessions();
      SessionCount.decrementSessionCount(session);
    }
  }
  if (isSessionFailoverEnabled && isSessionStored) {
    if (getUseInternalRequestRouting()) {
      try {
        String tokenId=tokenIdFactory.toSessionTokenId(session);
        getRepository().delete(tokenId);
      }
 catch (      Exception e) {
        sessionDebug.error(""String_Node_Str"",e);
      }
    }
 else {
      invalidateHttpSession(sid);
    }
  }
  return session;
}"
9287,"/** 
 * If InternalSession is not present, we attempt to recover its state from associated HttpSession. We have to set the session tracking cookie to HttpID which is present in the SessionID object. This will work in the fail over cases. We first get the HttpSession by invoking the GetHttpSession Servlet on the SAME server instance this code is invoked. This should trigger the Web container to perform recovery of the associated Http session <p/> We also pass the SessionID to the servlet to double check the match between the session id and Http session <p/> This is the ""client side"" of the remote invocation. The servlet will call retrieveSession() to complete the work
 * @param sid Session ID
 */
InternalSession recoverSession(SessionID sid){
  if (!isSessionFailoverEnabled) {
    return null;
  }
  if (getUseInternalRequestRouting()) {
    InternalSession sess=null;
    try {
      String tokenId=tokenIdFactory.toSessionTokenId(sid);
      Token token=getRepository().read(tokenId);
      if (token == null) {
        return sess;
      }
      sess=tokenAdapter.fromToken(token);
      updateSessionMaps(sess);
    }
 catch (    CoreTokenException e) {
      sessionDebug.error(""String_Node_Str"",e);
    }
    return sess;
  }
 else {
    if (sessionDebug.messageEnabled()) {
      sessionDebug.message(""String_Node_Str"" + sid);
    }
    DataInputStream in=null;
    InternalSession sess=null;
    try {
      String query=""String_Node_Str"" + GetHttpSession.OP + ""String_Node_Str""+ GetHttpSession.RECOVER_OP;
      URL url=new URL(thisSessionServerProtocol,thisSessionServer,thisSessionServerPort,deploymentURI + ""String_Node_Str"" + query);
      HttpURLConnection conn=invokeRemote(url,sid,null);
      in=new DataInputStream(conn.getInputStream());
      sess=(InternalSession)sessionTable.get(sid);
      if (sess == null) {
        sess=resolveRestrictedToken(sid,false);
      }
    }
 catch (    Exception ex) {
      sessionDebug.error(""String_Node_Str"",ex);
    }
 finally {
      closeStream(in);
    }
    return sess;
  }
}","/** 
 * If InternalSession is not present, we attempt to recover its state from associated HttpSession. We have to set the session tracking cookie to HttpID which is present in the SessionID object. This will work in the fail over cases. We first get the HttpSession by invoking the GetHttpSession Servlet on the SAME server instance this code is invoked. This should trigger the Web container to perform recovery of the associated Http session <p/> We also pass the SessionID to the servlet to double check the match between the session id and Http session <p/> This is the ""client side"" of the remote invocation. The servlet will call retrieveSession() to complete the work
 * @param sid Session ID
 */
InternalSession recoverSession(SessionID sid){
  if (!isSessionFailoverEnabled) {
    return null;
  }
  if (getUseInternalRequestRouting()) {
    InternalSession sess=null;
    try {
      String tokenId=tokenIdFactory.toSessionTokenId(sid);
      Token token=getRepository().read(tokenId);
      if (token == null) {
        return sess;
      }
      sess=tokenAdapter.fromToken(token);
      sess.setDebug(sessionDebug);
      sess.setSessionService(this);
      sess.scheduleExpiry();
      updateSessionMaps(sess);
    }
 catch (    CoreTokenException e) {
      sessionDebug.error(""String_Node_Str"",e);
    }
    return sess;
  }
 else {
    if (sessionDebug.messageEnabled()) {
      sessionDebug.message(""String_Node_Str"" + sid);
    }
    DataInputStream in=null;
    InternalSession sess=null;
    try {
      String query=""String_Node_Str"" + GetHttpSession.OP + ""String_Node_Str""+ GetHttpSession.RECOVER_OP;
      URL url=new URL(thisSessionServerProtocol,thisSessionServer,thisSessionServerPort,deploymentURI + ""String_Node_Str"" + query);
      HttpURLConnection conn=invokeRemote(url,sid,null);
      in=new DataInputStream(conn.getInputStream());
      sess=(InternalSession)sessionTable.get(sid);
      if (sess == null) {
        sess=resolveRestrictedToken(sid,false);
      }
    }
 catch (    Exception ex) {
      sessionDebug.error(""String_Node_Str"",ex);
    }
 finally {
      closeStream(in);
    }
    return sess;
  }
}"
9288,"/** 
 * Private Singleton Session Service.
 */
private SessionService(){
  KeyConversion keyConversion=new KeyConversion();
  tokenIdFactory=InjectorHolder.getInstance(TokenIdFactory.class);
  coreTokenConfig=InjectorHolder.getInstance(CoreTokenConfig.class);
  tokenAdapter=InjectorHolder.getInstance(SessionAdapter.class);
  try {
    dsameAdminDN=(String)AccessController.doPrivileged(new AdminDNAction());
    dsameAdminPassword=(String)AccessController.doPrivileged(new AdminPasswordAction());
    sessionServerProtocol=SystemProperties.get(Constants.AM_SERVER_PROTOCOL);
    sessionServer=SystemProperties.get(Constants.AM_SERVER_HOST);
    sessionServerPort=SystemProperties.get(Constants.AM_SERVER_PORT);
    sessionServerURI=SystemProperties.get(Constants.AM_SERVICES_DEPLOYMENT_DESCRIPTOR);
    sessionServerID=WebtopNaming.getServerID(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
    isSiteEnabled=WebtopNaming.isSiteEnabled(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
    if (isSiteEnabled) {
      sessionServerID=WebtopNaming.getSiteID(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
      String secondaryIDs=WebtopNaming.getSecondarySites(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
      secondaryServerIDs=new HashSet();
      if (secondaryIDs != null) {
        if (secondaryIDs.contains(""String_Node_Str"")) {
          StringTokenizer st=new StringTokenizer(secondaryIDs,""String_Node_Str"");
          while (st.hasMoreTokens()) {
            secondaryServerIDs.add(st.nextToken());
          }
        }
 else {
          secondaryServerIDs.add(secondaryIDs);
        }
      }
      sessionServiceID=new URL(WebtopNaming.getServerFromID(sessionServerID));
      sessionServerProtocol=sessionServiceID.getProtocol();
      sessionServer=sessionServiceID.getHost();
      sessionServerPort=Integer.toString(sessionServiceID.getPort());
    }
 else {
      sessionServiceID=new URL(WebtopNaming.getServerFromID(sessionServerID));
    }
    try {
      secureRandom=SecureRandom.getInstance(""String_Node_Str"",""String_Node_Str"");
    }
 catch (    NoSuchProviderException e) {
      secureRandom=SecureRandom.getInstance(""String_Node_Str"");
    }
    sessionTable=new Hashtable();
    remoteSessionSet=Collections.synchronizedSet(new HashSet());
    if (stats.isEnabled()) {
      maxSessionStats=new SessionMaxStats(sessionTable);
      stats.addStatsListener(maxSessionStats);
    }
    thisSessionServerProtocol=SystemProperties.get(Constants.AM_SERVER_PROTOCOL);
    thisSessionServer=SystemProperties.get(Constants.AM_SERVER_HOST);
    thisSessionServerPortAsString=SystemProperties.get(Constants.AM_SERVER_PORT);
    thisSessionURI=SystemProperties.get(Constants.AM_SERVICES_DEPLOYMENT_DESCRIPTOR);
    if ((thisSessionServerProtocol == null) || (thisSessionServerPortAsString == null) || (thisSessionServer == null)|| (thisSessionURI == null)) {
      throw new SessionException(SessionBundle.rbName,""String_Node_Str"",null);
    }
    thisSessionServerPort=Integer.parseInt(thisSessionServerPortAsString);
    thisSessionServerID=WebtopNaming.getServerID(thisSessionServerProtocol,thisSessionServer,thisSessionServerPortAsString,thisSessionURI);
    thisSessionServerURL=thisSessionServerProtocol + ""String_Node_Str"" + thisSessionServer+ ""String_Node_Str""+ thisSessionServerPortAsString+ thisSessionURI;
    thisSessionServiceURL=Session.getSessionServiceURL(thisSessionServerProtocol,thisSessionServer,thisSessionServerPortAsString,thisSessionURI);
    postInit();
  }
 catch (  Exception ex) {
    sessionDebug.error(""String_Node_Str"",ex);
  }
}","/** 
 * Private Singleton Session Service.
 */
private SessionService(){
  tokenIdFactory=InjectorHolder.getInstance(TokenIdFactory.class);
  coreTokenConfig=InjectorHolder.getInstance(CoreTokenConfig.class);
  tokenAdapter=InjectorHolder.getInstance(SessionAdapter.class);
  try {
    dsameAdminDN=(String)AccessController.doPrivileged(new AdminDNAction());
    dsameAdminPassword=(String)AccessController.doPrivileged(new AdminPasswordAction());
    sessionServerProtocol=SystemProperties.get(Constants.AM_SERVER_PROTOCOL);
    sessionServer=SystemProperties.get(Constants.AM_SERVER_HOST);
    sessionServerPort=SystemProperties.get(Constants.AM_SERVER_PORT);
    sessionServerURI=SystemProperties.get(Constants.AM_SERVICES_DEPLOYMENT_DESCRIPTOR);
    sessionServerID=WebtopNaming.getServerID(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
    isSiteEnabled=WebtopNaming.isSiteEnabled(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
    if (isSiteEnabled) {
      sessionServerID=WebtopNaming.getSiteID(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
      String secondaryIDs=WebtopNaming.getSecondarySites(sessionServerProtocol,sessionServer,sessionServerPort,sessionServerURI);
      secondaryServerIDs=new HashSet();
      if (secondaryIDs != null) {
        if (secondaryIDs.contains(""String_Node_Str"")) {
          StringTokenizer st=new StringTokenizer(secondaryIDs,""String_Node_Str"");
          while (st.hasMoreTokens()) {
            secondaryServerIDs.add(st.nextToken());
          }
        }
 else {
          secondaryServerIDs.add(secondaryIDs);
        }
      }
      sessionServiceID=new URL(WebtopNaming.getServerFromID(sessionServerID));
      sessionServerProtocol=sessionServiceID.getProtocol();
      sessionServer=sessionServiceID.getHost();
      sessionServerPort=Integer.toString(sessionServiceID.getPort());
    }
 else {
      sessionServiceID=new URL(WebtopNaming.getServerFromID(sessionServerID));
    }
    try {
      secureRandom=SecureRandom.getInstance(""String_Node_Str"",""String_Node_Str"");
    }
 catch (    NoSuchProviderException e) {
      secureRandom=SecureRandom.getInstance(""String_Node_Str"");
    }
    sessionTable=new Hashtable();
    remoteSessionSet=Collections.synchronizedSet(new HashSet());
    if (stats.isEnabled()) {
      maxSessionStats=new SessionMaxStats(sessionTable);
      stats.addStatsListener(maxSessionStats);
    }
    thisSessionServerProtocol=SystemProperties.get(Constants.AM_SERVER_PROTOCOL);
    thisSessionServer=SystemProperties.get(Constants.AM_SERVER_HOST);
    thisSessionServerPortAsString=SystemProperties.get(Constants.AM_SERVER_PORT);
    thisSessionURI=SystemProperties.get(Constants.AM_SERVICES_DEPLOYMENT_DESCRIPTOR);
    if ((thisSessionServerProtocol == null) || (thisSessionServerPortAsString == null) || (thisSessionServer == null)|| (thisSessionURI == null)) {
      throw new SessionException(SessionBundle.rbName,""String_Node_Str"",null);
    }
    thisSessionServerPort=Integer.parseInt(thisSessionServerPortAsString);
    thisSessionServerID=WebtopNaming.getServerID(thisSessionServerProtocol,thisSessionServer,thisSessionServerPortAsString,thisSessionURI);
    thisSessionServerURL=thisSessionServerProtocol + ""String_Node_Str"" + thisSessionServer+ ""String_Node_Str""+ thisSessionServerPortAsString+ thisSessionURI;
    thisSessionServiceURL=Session.getSessionServiceURL(thisSessionServerProtocol,thisSessionServer,thisSessionServerPortAsString,thisSessionURI);
    postInit();
  }
 catch (  Exception ex) {
    sessionDebug.error(""String_Node_Str"",ex);
  }
}"
9289,"@Override protected void configure(){
  bind(new AdminTokenType()).toProvider(new AdminTokenProvider()).in(Singleton.class);
  bind(ServiceManagementDAO.class).to(ServiceManagementDAOWrapper.class).in(Singleton.class);
  bind(DNWrapper.class).in(Singleton.class);
  bind(IndexChangeObservable.class).in(Singleton.class);
  bind(ShutdownManagerWrapper.class).in(Singleton.class);
  bind(SearchResultHandler.class).to(IndexChangeHandler.class).in(Singleton.class);
  bind(IndexChangeManager.class).to(IndexChangeManagerImpl.class).in(Singleton.class);
  bind(IndexChangeMonitor.class).to(IndexChangeMonitorImpl.class).in(Singleton.class);
  bind(IndexTreeService.class).to(IndexTreeServiceImpl.class).in(Singleton.class);
  bind(new TypeLiteral<TokenAdapter<JsonValue>>(){
  }
).to(OAuthAdapter.class);
  bind(DataLayerConnectionFactory.class).in(Singleton.class);
  bind(DSConfigMgr.class).toProvider(new Provider<DSConfigMgr>(){
    public DSConfigMgr get(){
      try {
        return DSConfigMgr.getDSConfigMgr();
      }
 catch (      LDAPServiceException e) {
        throw new IllegalStateException(e);
      }
    }
  }
).in(Singleton.class);
  bind(Debug.class).annotatedWith(Names.named(CoreTokenConstants.CTS_DEBUG)).toInstance(Debug.getInstance(CoreTokenConstants.CTS_DEBUG));
  bind(Debug.class).annotatedWith(Names.named(CoreTokenConstants.CTS_REAPER_DEBUG)).toInstance(Debug.getInstance(CoreTokenConstants.CTS_REAPER_DEBUG));
  bind(CoreTokenConstants.class).in(Singleton.class);
  bind(CTSPersistentStore.class).in(Singleton.class);
  bind(CoreTokenConfig.class).in(Singleton.class);
  bind(ConnectionFactory.class).to(CTSConnectionFactory.class).in(Singleton.class);
  bind(LDAPConfig.class).toProvider(new Provider<LDAPConfig>(){
    public LDAPConfig get(){
      return new LDAPConfig(SMSEntry.getRootSuffix());
    }
  }
).in(Singleton.class);
  bind(ExternalTokenConfig.class).in(Singleton.class);
  bind(ConfigurationObserver.class).toProvider(new Provider<ConfigurationObserver>(){
    public ConfigurationObserver get(){
      return ConfigurationObserver.getInstance();
    }
  }
).in(Singleton.class);
  bind(ScheduledExecutorService.class).annotatedWith(Names.named(CTSReaper.CTS_SCHEDULED_SERVICE)).toInstance(Executors.newScheduledThreadPool(1));
  bind(SessionService.class).toProvider(new Provider<SessionService>(){
    public SessionService get(){
      return SessionService.getSessionService();
    }
  }
).in(Singleton.class);
}","@Override protected void configure(){
  bind(new AdminTokenType()).toProvider(new AdminTokenProvider()).in(Singleton.class);
  bind(ServiceManagementDAO.class).to(ServiceManagementDAOWrapper.class).in(Singleton.class);
  bind(DNWrapper.class).in(Singleton.class);
  bind(IndexChangeObservable.class).in(Singleton.class);
  bind(ShutdownManagerWrapper.class).in(Singleton.class);
  bind(SearchResultHandler.class).to(IndexChangeHandler.class).in(Singleton.class);
  bind(IndexChangeManager.class).to(IndexChangeManagerImpl.class).in(Singleton.class);
  bind(IndexChangeMonitor.class).to(IndexChangeMonitorImpl.class).in(Singleton.class);
  bind(IndexTreeService.class).to(IndexTreeServiceImpl.class).in(Singleton.class);
  bind(new TypeLiteral<TokenAdapter<JsonValue>>(){
  }
).to(OAuthAdapter.class);
  bind(DataLayerConnectionFactory.class).in(Singleton.class);
  bind(DSConfigMgr.class).toProvider(new Provider<DSConfigMgr>(){
    public DSConfigMgr get(){
      try {
        return DSConfigMgr.getDSConfigMgr();
      }
 catch (      LDAPServiceException e) {
        throw new IllegalStateException(e);
      }
    }
  }
).in(Singleton.class);
  bind(Debug.class).annotatedWith(Names.named(CoreTokenConstants.CTS_DEBUG)).toInstance(Debug.getInstance(CoreTokenConstants.CTS_DEBUG));
  bind(Debug.class).annotatedWith(Names.named(CoreTokenConstants.CTS_REAPER_DEBUG)).toInstance(Debug.getInstance(CoreTokenConstants.CTS_REAPER_DEBUG));
  bind(CoreTokenConstants.class).in(Singleton.class);
  bind(CTSPersistentStore.class).in(Singleton.class);
  bind(CoreTokenConfig.class).in(Singleton.class);
  bind(ConnectionFactory.class).to(CTSConnectionFactory.class).in(Singleton.class);
  bind(LDAPConfig.class).toProvider(new Provider<LDAPConfig>(){
    public LDAPConfig get(){
      return new LDAPConfig(SMSEntry.getRootSuffix());
    }
  }
).in(Singleton.class);
  bind(ExternalTokenConfig.class).in(Singleton.class);
  bind(ConfigurationObserver.class).toProvider(new Provider<ConfigurationObserver>(){
    public ConfigurationObserver get(){
      return ConfigurationObserver.getInstance();
    }
  }
).in(Singleton.class);
  bind(ScheduledExecutorService.class).annotatedWith(Names.named(CTSReaper.CTS_SCHEDULED_SERVICE)).toInstance(Executors.newScheduledThreadPool(1));
  bind(SessionService.class).toProvider(new Provider<SessionService>(){
    public SessionService get(){
      return SessionService.getSessionService();
    }
  }
).in(Singleton.class);
  bind(Debug.class).annotatedWith(Names.named(SessionConstants.SESSION_DEBUG)).toInstance(Debug.getInstance(SessionConstants.SESSION_DEBUG));
}"
9290,"/** 
 * Creates a default instance with dependencies defined.
 * @param tokenIdFactory Non null.
 * @param config Non null.
 * @param serialisation Non null.
 * @param blobUtils
 */
@Inject public SessionAdapter(TokenIdFactory tokenIdFactory,CoreTokenConfig config,JSONSerialisation serialisation,LDAPDataConversion dataConversion,TokenBlobUtils blobUtils){
  this.tokenIdFactory=tokenIdFactory;
  this.config=config;
  this.serialisation=serialisation;
  this.dataConversion=dataConversion;
  this.blobUtils=blobUtils;
}","/** 
 * Creates a default instance with dependencies defined.
 * @param tokenIdFactory Non null.
 * @param config Non null.
 * @param serialisation Non null.
 * @param blobUtils A collection of Binary Object utilities.
 */
@Inject public SessionAdapter(TokenIdFactory tokenIdFactory,CoreTokenConfig config,JSONSerialisation serialisation,LDAPDataConversion dataConversion,TokenBlobUtils blobUtils){
  this.tokenIdFactory=tokenIdFactory;
  this.config=config;
  this.serialisation=serialisation;
  this.dataConversion=dataConversion;
  this.blobUtils=blobUtils;
}"
9291,"@Post(""String_Node_Str"") public Representation represent(Representation entity){
  Representation rep=null;
  client=getAuthenticatedClient();
  if (client.getClient().getClientType().equals(ClientApplication.ClientType.PUBLIC)) {
    OAuth2Utils.DEBUG.warning(""String_Node_Str"");
    throw OAuthProblemException.OAuthError.INVALID_CLIENT.handle(getRequest(),""String_Node_Str"");
  }
  String scope_before=OAuth2Utils.getRequestParameter(getRequest(),OAuth2Constants.Params.SCOPE,String.class);
  Set<String> checkedScope=executeAccessTokenScopePlugin(scope_before);
  CoreToken token=createAccessToken(checkedScope);
  Map<String,Object> response=token.convertToMap();
  Map<String,String> data=new HashMap<String,String>();
  response.putAll(executeExtraDataScopePlugin(data,token));
  if (checkedScope != null && !checkedScope.isEmpty()) {
    response.put(OAuth2Constants.Params.SCOPE,OAuth2Utils.join(checkedScope,OAuth2Utils.getScopeDelimiter(getContext())));
  }
  return new JacksonRepresentation<Map>(response);
}","@Post(""String_Node_Str"") public Representation represent(Representation entity){
  Representation rep=null;
  client=getAuthenticatedClient();
  if (client.getClient().getClientType().equals(ClientApplication.ClientType.PUBLIC)) {
    OAuth2Utils.DEBUG.warning(""String_Node_Str"");
    throw OAuthProblemException.OAuthError.UNAUTHORIZED_CLIENT.handle(getRequest(),""String_Node_Str"");
  }
  String scope_before=OAuth2Utils.getRequestParameter(getRequest(),OAuth2Constants.Params.SCOPE,String.class);
  Set<String> checkedScope=executeAccessTokenScopePlugin(scope_before);
  CoreToken token=createAccessToken(checkedScope);
  Map<String,Object> response=token.convertToMap();
  Map<String,String> data=new HashMap<String,String>();
  response.putAll(executeExtraDataScopePlugin(data,token));
  if (checkedScope != null && !checkedScope.isEmpty()) {
    response.put(OAuth2Constants.Params.SCOPE,OAuth2Utils.join(checkedScope,OAuth2Utils.getScopeDelimiter(getContext())));
  }
  return new JacksonRepresentation<Map>(response);
}"
9292,"private String getPasswordFromHeader(ServerContext context){
  return RestUtils.getCookieFromServerContext(context);
}","private String getPasswordFromHeader(ServerContext context){
  List<String> headerList=null;
  String oldUserPasswordHeaderName=""String_Node_Str"";
  HttpContext header=null;
  try {
    header=context.asContext(HttpContext.class);
    if (header == null) {
      RestDispatcher.debug.error(""String_Node_Str"" + ""String_Node_Str"");
      return null;
    }
    headerList=header.getHeaders().get(oldUserPasswordHeaderName.toLowerCase());
    if (headerList != null && !headerList.isEmpty()) {
      for (      String s : headerList) {
        return (s != null && !s.isEmpty()) ? s : null;
      }
    }
  }
 catch (  Exception e) {
    RestDispatcher.debug.error(""String_Node_Str"" + ""String_Node_Str"" + e);
  }
  return null;
}"
9293,"/** 
 * {@inheritDoc}
 */
@Override public void updateInstance(final ServerContext context,final String resourceId,final UpdateRequest request,final ResultHandler<Resource> handler){
  Token admin=new Token();
  admin.setId(getCookieFromServerContext(context));
  final JsonValue jVal=request.getNewContent();
  final String rev=request.getRevision();
  IdentityDetails dtls, newDtls;
  IdentityServicesImpl idsvc=new IdentityServicesImpl();
  ;
  Resource resource;
  try {
    dtls=idsvc.read(resourceId,idSvcsAttrList,admin);
    newDtls=jsonValueToIdentityDetails(jVal);
    newDtls.setName(resourceId);
    String userpass=jVal.get(""String_Node_Str"").asString();
    if (userpass != null && !userpass.isEmpty()) {
      if (checkValidPassword(resourceId,userpass.toCharArray(),realm) || isAdmin(context)) {
      }
 else {
        String strPass=getPasswordFromHeader(context);
        if (strPass != null && !strPass.isEmpty() && checkValidPassword(resourceId,strPass.toCharArray(),realm)) {
        }
 else {
          throw new ForbiddenException(""String_Node_Str"",null);
        }
      }
    }
    UpdateResponse message=idsvc.update(newDtls,admin);
    IdentityDetails checkIdent=idsvc.read(dtls.getName(),idSvcsAttrList,admin);
    resource=new Resource(resourceId,""String_Node_Str"",identityDetailsToJsonValue(checkIdent));
    handler.handleResult(resource);
  }
 catch (  final ObjectNotFound onf) {
    RestDispatcher.debug.error(""String_Node_Str"" + onf);
    handler.handleError(new NotFoundException(""String_Node_Str"" + resourceId + ""String_Node_Str"",onf));
  }
catch (  final NeedMoreCredentials needMoreCredentials) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ needMoreCredentials);
    handler.handleError(new ForbiddenException(""String_Node_Str"",needMoreCredentials));
  }
catch (  final TokenExpired tokenExpired) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ tokenExpired);
    handler.handleError(new PermanentException(401,""String_Node_Str"",null));
  }
catch (  final AccessDenied accessDenied) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ accessDenied);
    handler.handleError(new ForbiddenException(accessDenied.getMessage(),accessDenied));
  }
catch (  final GeneralFailure generalFailure) {
    RestDispatcher.debug.error(""String_Node_Str"" + generalFailure);
    handler.handleError(new BadRequestException(generalFailure.getMessage(),generalFailure));
  }
catch (  ForbiddenException fe) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ fe);
    handler.handleError(fe);
  }
catch (  final Exception exception) {
    RestDispatcher.debug.error(""String_Node_Str"" + exception);
    handler.handleError(new NotFoundException(exception.getMessage(),exception));
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void updateInstance(final ServerContext context,final String resourceId,final UpdateRequest request,final ResultHandler<Resource> handler){
  Token admin=new Token();
  admin.setId(getCookieFromServerContext(context));
  final JsonValue jVal=request.getNewContent();
  final String rev=request.getRevision();
  IdentityDetails dtls, newDtls;
  IdentityServicesImpl idsvc=new IdentityServicesImpl();
  ;
  Resource resource;
  try {
    dtls=idsvc.read(resourceId,idSvcsAttrList,admin);
    newDtls=jsonValueToIdentityDetails(jVal);
    newDtls.setName(resourceId);
    String userpass=jVal.get(""String_Node_Str"").asString();
    if (userpass != null && !userpass.isEmpty()) {
      if (checkValidPassword(resourceId,userpass.toCharArray(),realm) || isAdmin(context)) {
      }
 else {
        String strPass=getPasswordFromHeader(context);
        if (strPass != null && !strPass.isEmpty() && checkValidPassword(resourceId,strPass.toCharArray(),realm)) {
        }
 else {
          throw new BadRequestException(""String_Node_Str"");
        }
      }
    }
    UpdateResponse message=idsvc.update(newDtls,admin);
    IdentityDetails checkIdent=idsvc.read(dtls.getName(),idSvcsAttrList,admin);
    resource=new Resource(resourceId,""String_Node_Str"",identityDetailsToJsonValue(checkIdent));
    handler.handleResult(resource);
  }
 catch (  final ObjectNotFound onf) {
    RestDispatcher.debug.error(""String_Node_Str"" + onf);
    handler.handleError(new NotFoundException(""String_Node_Str"" + resourceId + ""String_Node_Str"",onf));
  }
catch (  final NeedMoreCredentials needMoreCredentials) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ needMoreCredentials);
    handler.handleError(new ForbiddenException(""String_Node_Str"",needMoreCredentials));
  }
catch (  final TokenExpired tokenExpired) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ tokenExpired);
    handler.handleError(new PermanentException(401,""String_Node_Str"",null));
  }
catch (  final AccessDenied accessDenied) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ accessDenied);
    handler.handleError(new ForbiddenException(accessDenied.getMessage(),accessDenied));
  }
catch (  final GeneralFailure generalFailure) {
    RestDispatcher.debug.error(""String_Node_Str"" + generalFailure);
    handler.handleError(new BadRequestException(generalFailure.getMessage(),generalFailure));
  }
catch (  BadRequestException bre) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ bre);
    handler.handleError(bre);
  }
catch (  final Exception exception) {
    RestDispatcher.debug.error(""String_Node_Str"" + exception);
    handler.handleError(new NotFoundException(exception.getMessage(),exception));
  }
}"
9294,"/** 
 * Update an existing Token in the store. If the Token does not exist in the store then a Token is created. If the Token did exist in the store then it is updated. Not all fields on the Token can be updated, see the Token class for more details.
 * @see Token
 * @param token Non null Token to update.
 * @throws CoreTokenException If there was a non-recoverable error during the operation.
 */
public void update(Token token) throws CoreTokenException {
  try {
    strategy.perfom(token);
  }
 catch (  TokenStrategyFailedException e) {
    throw new CoreTokenException(""String_Node_Str"",e);
  }
  getAdapter().update(token);
  if (DEBUG.messageEnabled()) {
    DEBUG.message(MessageFormat.format(CoreTokenConstants.DEBUG_HEADER + ""String_Node_Str"",token.getTokenId()));
  }
}","/** 
 * Update an existing Token in the store. If the Token does not exist in the store then a Token is created. If the Token did exist in the store then it is updated. Not all fields on the Token can be updated, see the Token class for more details.
 * @see Token
 * @param token Non null Token to update.
 * @throws CoreTokenException If there was a non-recoverable error during the operation.
 */
public void update(Token token) throws CoreTokenException {
  try {
    strategy.perfom(token);
  }
 catch (  TokenStrategyFailedException e) {
    throw new CoreTokenException(""String_Node_Str"",e);
  }
  adapter.updateOrCreate(token);
  if (DEBUG.messageEnabled()) {
    DEBUG.message(MessageFormat.format(CoreTokenConstants.DEBUG_HEADER + ""String_Node_Str"",token.getTokenId()));
  }
}"
9295,"/** 
 * Delete a collection of Tokens from the Token Store using a filter to narrow down the Tokens to be deleted. Note: This operation is linear in its execution time so the more Tokens being deleted, the longer it will take.
 * @param query Non null filters which will be combined logically using AND.
 * @return total number of tokens deleted by query.
 * @throws DeleteFailedException If the delete failed for any reason.
 */
public int delete(Map<CoreTokenField,Object> query) throws DeleteFailedException {
  QueryFilter.QueryFilterBuilder queryFilter=getAdapter().buildFilter().and();
  for (  Map.Entry<CoreTokenField,Object> entry : query.entrySet()) {
    CoreTokenField key=entry.getKey();
    Object value=entry.getValue();
    queryFilter=queryFilter.attribute(key,value);
  }
  QueryBuilder builder=getAdapter().query().withFilter(queryFilter.build()).returnTheseAttributes(CoreTokenField.TOKEN_ID);
  Collection<Entry> entries;
  try {
    entries=builder.executeRawResults();
    for (    Entry entry : entries) {
      Attribute attribute=entry.getAttribute(CoreTokenField.TOKEN_ID.toString());
      String tokenId=attribute.firstValueAsString();
      getAdapter().delete(tokenId);
    }
    if (DEBUG.messageEnabled()) {
      DEBUG.message(MessageFormat.format(CoreTokenConstants.DEBUG_HEADER + ""String_Node_Str"",entries.size()));
    }
  }
 catch (  CoreTokenException e) {
    throw new DeleteFailedException(builder,e);
  }
  return entries.size();
}","/** 
 * Delete a collection of Tokens from the Token Store using a filter to narrow down the Tokens to be deleted. Note: This operation is linear in its execution time so the more Tokens being deleted, the longer it will take.
 * @param query Non null filters which will be combined logically using AND.
 * @return total number of tokens deleted by query.
 * @throws DeleteFailedException If the delete failed for any reason.
 */
public int delete(Map<CoreTokenField,Object> query) throws DeleteFailedException {
  QueryFilter.QueryFilterBuilder queryFilter=adapter.buildFilter().and();
  for (  Map.Entry<CoreTokenField,Object> entry : query.entrySet()) {
    CoreTokenField key=entry.getKey();
    Object value=entry.getValue();
    queryFilter=queryFilter.attribute(key,value);
  }
  QueryBuilder builder=adapter.query().withFilter(queryFilter.build()).returnTheseAttributes(CoreTokenField.TOKEN_ID);
  Collection<Entry> entries;
  try {
    entries=builder.executeRawResults();
    for (    Entry entry : entries) {
      Attribute attribute=entry.getAttribute(CoreTokenField.TOKEN_ID.toString());
      String tokenId=attribute.firstValueAsString();
      adapter.delete(tokenId);
    }
    if (DEBUG.messageEnabled()) {
      DEBUG.message(MessageFormat.format(CoreTokenConstants.DEBUG_HEADER + ""String_Node_Str"",entries.size()));
    }
  }
 catch (  CoreTokenException e) {
    throw new DeleteFailedException(builder,e);
  }
  return entries.size();
}"
9296,"/** 
 * Private restricted to preserve Singleton Instantiation.
 */
@Inject public CTSPersistentStore(CoreTokenConfig coreTokenConfig,LDAPDataConversion dataConversion,DataLayerConnectionFactory connectionFactory,TokenBlobStrategy strategy){
  this.coreTokenConfig=coreTokenConfig;
  this.dataConversion=dataConversion;
  this.strategy=strategy;
  this.connectionFactory=connectionFactory;
  this.DEBUG=SessionService.sessionDebug;
}","/** 
 * Private restricted to preserve Singleton Instantiation.
 */
@Inject public CTSPersistentStore(CoreTokenConfig coreTokenConfig,LDAPDataConversion dataConversion,TokenBlobStrategy strategy,CoreTokenAdapter adapter){
  this.coreTokenConfig=coreTokenConfig;
  this.dataConversion=dataConversion;
  this.strategy=strategy;
  this.adapter=adapter;
  this.DEBUG=SessionService.sessionDebug;
}"
9297,"/** 
 * Create a Token in the persistent store. If the Token already exists in the store then this function will throw a CoreTokenException. Instead it is recommended to use the update function.
 * @see CTSPersistentStore#update(com.sun.identity.sm.ldap.api.tokens.Token)
 * @param token Non null Token to create.
 * @throws CoreTokenException If there was a non-recoverable error during the operation or ifthe Token already exists in the store.
 */
public void create(Token token) throws CoreTokenException {
  try {
    strategy.perfom(token);
  }
 catch (  TokenStrategyFailedException e) {
    throw new CoreTokenException(""String_Node_Str"",e);
  }
  getAdapter().create(token);
}","/** 
 * Create a Token in the persistent store. If the Token already exists in the store then this function will throw a CoreTokenException. Instead it is recommended to use the update function.
 * @see CTSPersistentStore#update(com.sun.identity.sm.ldap.api.tokens.Token)
 * @param token Non null Token to create.
 * @throws CoreTokenException If there was a non-recoverable error during the operation or ifthe Token already exists in the store.
 */
public void create(Token token) throws CoreTokenException {
  try {
    strategy.perfom(token);
  }
 catch (  TokenStrategyFailedException e) {
    throw new CoreTokenException(""String_Node_Str"",e);
  }
  adapter.create(token);
}"
9298,"/** 
 * Read a Token from the persistent store.
 * @param tokenId The non null Token Id that the Token was created with.
 * @return Null if there was no matching Token. Otherwise a fully populated Token will be returned.
 * @throws CoreTokenException If there was a non-recoverable error during the operation.
 */
public Token read(String tokenId) throws CoreTokenException {
  Token token=getAdapter().read(tokenId);
  try {
    strategy.reverse(token);
  }
 catch (  TokenStrategyFailedException e) {
    throw new CoreTokenException(""String_Node_Str"",e);
  }
  return token;
}","/** 
 * Read a Token from the persistent store.
 * @param tokenId The non null Token Id that the Token was created with.
 * @return Null if there was no matching Token. Otherwise a fully populated Token will be returned.
 * @throws CoreTokenException If there was a non-recoverable error during the operation.
 */
public Token read(String tokenId) throws CoreTokenException {
  Token token=adapter.read(tokenId);
  try {
    strategy.reverse(token);
  }
 catch (  TokenStrategyFailedException e) {
    throw new CoreTokenException(""String_Node_Str"",e);
  }
  return token;
}"
9299,"/** 
 * Returns the expiration information of all sessions belonging to a user. The returned value will be a Map (sid->expiration_time).
 * @param uuid User's universal unique ID.
 * @return Map of all Session for the user
 * @throws Exception if there is any problem with accessing the sessionrepository.
 */
public Map<String,Long> getTokensByUUID(String uuid) throws CoreTokenException {
  Collection<Entry> entries;
  Filter filter=getAdapter().buildFilter().and().userId(uuid).build();
  entries=getAdapter().query().withFilter(filter).returnTheseAttributes(CoreTokenField.TOKEN_ID,CoreTokenField.EXPIRY_DATE).executeRawResults();
  if (DEBUG.messageEnabled()) {
    DEBUG.message(MessageFormat.format(CoreTokenConstants.DEBUG_HEADER + ""String_Node_Str"" + ""String_Node_Str"",entries.size(),uuid));
  }
  Map<String,Long> sessions=new HashMap<String,Long>();
  for (  Entry entry : entries) {
    String sessionId=entry.getAttribute(CoreTokenField.TOKEN_ID.toString()).firstValueAsString();
    String dateString=entry.getAttribute(CoreTokenField.EXPIRY_DATE.toString()).firstValueAsString();
    Calendar timestamp=dataConversion.fromLDAPDate(dateString);
    long epochedSeconds=dataConversion.toEpochedSeconds(timestamp);
    sessions.put(sessionId,epochedSeconds);
  }
  return sessions;
}","/** 
 * Returns the expiration information of all sessions belonging to a user. The returned value will be a Map (sid->expiration_time).
 * @param uuid User's universal unique ID.
 * @return Map of all Session for the user
 * @throws Exception if there is any problem with accessing the sessionrepository.
 */
public Map<String,Long> getTokensByUUID(String uuid) throws CoreTokenException {
  Collection<Entry> entries;
  Filter filter=adapter.buildFilter().and().userId(uuid).build();
  entries=adapter.query().withFilter(filter).returnTheseAttributes(CoreTokenField.TOKEN_ID,CoreTokenField.EXPIRY_DATE).executeRawResults();
  if (DEBUG.messageEnabled()) {
    DEBUG.message(MessageFormat.format(CoreTokenConstants.DEBUG_HEADER + ""String_Node_Str"" + ""String_Node_Str"",entries.size(),uuid));
  }
  Map<String,Long> sessions=new HashMap<String,Long>();
  for (  Entry entry : entries) {
    String sessionId=entry.getAttribute(CoreTokenField.TOKEN_ID.toString()).firstValueAsString();
    String dateString=entry.getAttribute(CoreTokenField.EXPIRY_DATE.toString()).firstValueAsString();
    Calendar timestamp=dataConversion.fromLDAPDate(dateString);
    long epochedSeconds=dataConversion.toEpochedSeconds(timestamp);
    sessions.put(sessionId,epochedSeconds);
  }
  return sessions;
}"
9300,"/** 
 * Performs a list operation against the Core Token Service with a predefined filter. This allows more complex filters to be constructed and is intended to be used with the QueryFilter fluent class.
 * @see QueryFilter
 * @param filter A non null OpenDJ LDAP Filter to use to control the results returned.
 * @return A non null, but possible empty collection of Tokens.
 * @throws CoreTokenException If there was an unrecoverable error.
 */
public Collection<Token> list(Filter filter) throws CoreTokenException {
  Collection<Token> tokens=getAdapter().query().withFilter(filter).execute();
  decryptTokens(tokens);
  return tokens;
}","/** 
 * Performs a list operation against the Core Token Service with a predefined filter. This allows more complex filters to be constructed and is intended to be used with the QueryFilter fluent class.
 * @see QueryFilter
 * @param filter A non null OpenDJ LDAP Filter to use to control the results returned.
 * @return A non null, but possible empty collection of Tokens.
 * @throws CoreTokenException If there was an unrecoverable error.
 */
public Collection<Token> list(Filter filter) throws CoreTokenException {
  Collection<Token> tokens=adapter.query().withFilter(filter).execute();
  decryptTokens(tokens);
  return tokens;
}"
9301,"/** 
 * Delete all Expired Sessions, within Default Limits.
 * @return True if there are more tokens to delete.
 * @throws CoreTokenException If there was a problem performing the delete.
 */
private boolean deleteExpired() throws CoreTokenException {
  Calendar nowTimestamp=Calendar.getInstance();
  Filter filter=getAdapter().buildFilter().and().beforeDate(nowTimestamp).build();
  Collection<Entry> entries=getAdapter().query().withFilter(filter).limitResultsTo(coreTokenConfig.getExpiredSessionsSearchLimit()).returnTheseAttributes(CoreTokenField.TOKEN_ID).executeRawResults();
  for (  Entry entry : entries) {
    Attribute attribute=entry.getAttribute(CoreTokenField.TOKEN_ID.toString());
    String tokenId=attribute.firstValueAsString();
    delete(tokenId);
  }
  if (DEBUG.messageEnabled()) {
    DEBUG.message(MessageFormat.format(CoreTokenConstants.DEBUG_HEADER + ""String_Node_Str"",entries.size()));
  }
  return entries.size() == coreTokenConfig.getExpiredSessionsSearchLimit();
}","/** 
 * Delete all Expired Sessions, within Default Limits.
 * @return True if there are more tokens to delete.
 * @throws CoreTokenException If there was a problem performing the delete.
 */
private boolean deleteExpired() throws CoreTokenException {
  Calendar nowTimestamp=Calendar.getInstance();
  Filter filter=adapter.buildFilter().and().beforeDate(nowTimestamp).build();
  Collection<Entry> entries=adapter.query().withFilter(filter).limitResultsTo(coreTokenConfig.getExpiredSessionsSearchLimit()).returnTheseAttributes(CoreTokenField.TOKEN_ID).executeRawResults();
  for (  Entry entry : entries) {
    Attribute attribute=entry.getAttribute(CoreTokenField.TOKEN_ID.toString());
    String tokenId=attribute.firstValueAsString();
    delete(tokenId);
  }
  if (DEBUG.messageEnabled()) {
    DEBUG.message(MessageFormat.format(CoreTokenConstants.DEBUG_HEADER + ""String_Node_Str"",entries.size()));
  }
  return entries.size() == coreTokenConfig.getExpiredSessionsSearchLimit();
}"
9302,"/** 
 * Provide Service Instance Access to our Singleton
 * @return CTSPersistentStore Singleton Instance.
 */
public static final CTSPersistentStore getInstance(){
synchronized (CTSPersistentStore.class) {
    if (instance == null) {
      instance=new CTSPersistentStore(InjectorHolder.getInstance(CoreTokenConfig.class),InjectorHolder.getInstance(LDAPDataConversion.class),InjectorHolder.getInstance(DataLayerConnectionFactory.class),InjectorHolder.getInstance(TokenBlobStrategy.class));
      try {
        initialize();
      }
 catch (      StoreException se) {
        DEBUG.error(""String_Node_Str"" + se.getMessage());
        DEBUG.error(""String_Node_Str"");
      }
    }
  }
  return instance;
}","/** 
 * Provide Service Instance Access to our Singleton
 * @return CTSPersistentStore Singleton Instance.
 */
public static final CTSPersistentStore getInstance(){
synchronized (CTSPersistentStore.class) {
    if (instance == null) {
      instance=new CTSPersistentStore(InjectorHolder.getInstance(CoreTokenConfig.class),InjectorHolder.getInstance(LDAPDataConversion.class),InjectorHolder.getInstance(TokenBlobStrategy.class),InjectorHolder.getInstance(CoreTokenAdapter.class));
      try {
        initialize();
      }
 catch (      StoreException se) {
        DEBUG.error(""String_Node_Str"" + se.getMessage());
        DEBUG.error(""String_Node_Str"");
      }
    }
  }
  return instance;
}"
9303,"public QueryFailedException(Connection connection,DN dn,Filter filter,Throwable e){
  super(MessageFormat.format(""String_Node_Str"" + CoreTokenConstants.DEBUG_HEADER + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",dn,connection,filter),e);
}","/** 
 * Creates a formatted exception based on the values provided.
 * @param connection Connection used to make the query.
 * @param dn May be null. DN which was used in the query.
 * @param filter May be null. Filter used in query.
 * @param e Reason for the exception.
 */
public QueryFailedException(Connection connection,DN dn,Filter filter,Throwable e){
  super(MessageFormat.format(""String_Node_Str"" + CoreTokenConstants.DEBUG_HEADER + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",dn,connection,filter),e);
}"
9304,"public SetFailedException(Token token,ModifyRequest diff,Throwable e){
  super(MessageFormat.format(""String_Node_Str"" + CoreTokenConstants.DEBUG_HEADER + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",token,diff),e);
}","public SetFailedException(Token token,Throwable e){
  super(MessageFormat.format(""String_Node_Str"" + CoreTokenConstants.DEBUG_HEADER + ""String_Node_Str""+ ""String_Node_Str"",token),e);
}"
9305,"/** 
 * {@inheritDoc}
 */
@Override public void updateInstance(final ServerContext context,final String resourceId,final UpdateRequest request,final ResultHandler<Resource> handler){
  Token admin=new Token();
  admin.setId(getCookieFromServerContext(context));
  final JsonValue jVal=request.getNewContent();
  final String rev=request.getRevision();
  IdentityDetails dtls=null, newDtls=null;
  IdentityServicesImpl idsvc=null;
  Resource resource=null;
  try {
    idsvc=new IdentityServicesImpl();
    dtls=idsvc.read(resourceId,idSvcsAttrList,admin);
    newDtls=jsonValueToIdentityDetails(jVal);
    newDtls.setName(resourceId);
    String userpass=jVal.get(""String_Node_Str"").asString();
    if (userpass != null && !userpass.isEmpty()) {
      if (checkValidPassword(resourceId,userpass.toCharArray(),realm) || isAdmin(context)) {
      }
 else {
        if (checkValidPassword(resourceId,getPasswordFromHeader(context).toCharArray(),realm)) {
        }
 else {
          throw new PermanentException(401,""String_Node_Str"",null);
        }
      }
    }
    UpdateResponse message=idsvc.update(newDtls,admin);
    IdentityDetails checkIdent=idsvc.read(dtls.getName(),idSvcsAttrList,admin);
    resource=new Resource(resourceId,""String_Node_Str"",identityDetailsToJsonValue(checkIdent));
    handler.handleResult(resource);
  }
 catch (  final ObjectNotFound o) {
    try {
      dtls=jsonValueToIdentityDetails(jVal);
      dtls.setName(resourceId);
      CreateResponse success=idsvc.create(dtls,admin);
      IdentityDetails checkIdent=idsvc.read(dtls.getName(),idSvcsAttrList,admin);
      resource=new Resource(resourceId,""String_Node_Str"",identityDetailsToJsonValue(checkIdent));
      handler.handleResult(resource);
    }
 catch (    final TokenExpired tokenExpired) {
      RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ tokenExpired);
      handler.handleError(new PermanentException(401,""String_Node_Str"",null));
    }
catch (    final Exception e) {
      RestDispatcher.debug.error(""String_Node_Str"" + e);
      handler.handleError(new BadRequestException(e.getMessage(),e));
    }
  }
catch (  final NeedMoreCredentials needMoreCredentials) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ needMoreCredentials);
    handler.handleError(new ForbiddenException(""String_Node_Str"",needMoreCredentials));
  }
catch (  final TokenExpired tokenExpired) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ tokenExpired);
    handler.handleError(new PermanentException(401,""String_Node_Str"",null));
  }
catch (  final AccessDenied accessDenied) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ accessDenied);
    handler.handleError(new ForbiddenException(accessDenied.getMessage(),accessDenied));
  }
catch (  final GeneralFailure generalFailure) {
    RestDispatcher.debug.error(""String_Node_Str"" + generalFailure);
    handler.handleError(new BadRequestException(generalFailure.getMessage(),generalFailure));
  }
catch (  final Exception exception) {
    RestDispatcher.debug.error(""String_Node_Str"" + exception);
    handler.handleError(new NotFoundException(exception.getMessage(),exception));
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void updateInstance(final ServerContext context,final String resourceId,final UpdateRequest request,final ResultHandler<Resource> handler){
  Token admin=new Token();
  admin.setId(getCookieFromServerContext(context));
  final JsonValue jVal=request.getNewContent();
  final String rev=request.getRevision();
  IdentityDetails dtls=null, newDtls=null;
  IdentityServicesImpl idsvc=null;
  Resource resource=null;
  try {
    idsvc=new IdentityServicesImpl();
    dtls=idsvc.read(resourceId,idSvcsAttrList,admin);
    newDtls=jsonValueToIdentityDetails(jVal);
    newDtls.setName(resourceId);
    String userpass=jVal.get(""String_Node_Str"").asString();
    if (userpass != null && !userpass.isEmpty()) {
      if (checkValidPassword(resourceId,userpass.toCharArray(),realm) || isAdmin(context)) {
      }
 else {
        String strPass=getPasswordFromHeader(context);
        if (strPass != null && !strPass.isEmpty() && checkValidPassword(resourceId,strPass.toCharArray(),realm)) {
        }
 else {
          throw new ForbiddenException(""String_Node_Str"",null);
        }
      }
    }
    UpdateResponse message=idsvc.update(newDtls,admin);
    IdentityDetails checkIdent=idsvc.read(dtls.getName(),idSvcsAttrList,admin);
    resource=new Resource(resourceId,""String_Node_Str"",identityDetailsToJsonValue(checkIdent));
    handler.handleResult(resource);
  }
 catch (  final ObjectNotFound o) {
    try {
      dtls=jsonValueToIdentityDetails(jVal);
      dtls.setName(resourceId);
      CreateResponse success=idsvc.create(dtls,admin);
      IdentityDetails checkIdent=idsvc.read(dtls.getName(),idSvcsAttrList,admin);
      resource=new Resource(resourceId,""String_Node_Str"",identityDetailsToJsonValue(checkIdent));
      handler.handleResult(resource);
    }
 catch (    final TokenExpired tokenExpired) {
      RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ tokenExpired);
      handler.handleError(new PermanentException(401,""String_Node_Str"",null));
    }
catch (    final Exception e) {
      RestDispatcher.debug.error(""String_Node_Str"" + e);
      handler.handleError(new BadRequestException(e.getMessage(),e));
    }
  }
catch (  final NeedMoreCredentials needMoreCredentials) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ needMoreCredentials);
    handler.handleError(new ForbiddenException(""String_Node_Str"",needMoreCredentials));
  }
catch (  final TokenExpired tokenExpired) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ tokenExpired);
    handler.handleError(new PermanentException(401,""String_Node_Str"",null));
  }
catch (  final AccessDenied accessDenied) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ accessDenied);
    handler.handleError(new ForbiddenException(accessDenied.getMessage(),accessDenied));
  }
catch (  final GeneralFailure generalFailure) {
    RestDispatcher.debug.error(""String_Node_Str"" + generalFailure);
    handler.handleError(new BadRequestException(generalFailure.getMessage(),generalFailure));
  }
catch (  ForbiddenException fe) {
    RestDispatcher.debug.error(""String_Node_Str"" + resourceId + ""String_Node_Str""+ fe);
    handler.handleError(fe);
  }
catch (  final Exception exception) {
    RestDispatcher.debug.error(""String_Node_Str"" + exception);
    handler.handleError(new NotFoundException(exception.getMessage(),exception));
  }
}"
9306,"/** 
 * Common Get Instance method to obtain access to Service Methods.
 * @return AMTokenRepository Singleton Instance.
 * @throws Exception
 */
public static AMTokenRepository getInstance() throws Exception {
  if (amTokenRepository == null) {
    if (CTS_REPOSITORY_CLASS_NAME.equals(CTSPersistentStore.class.getName())) {
      amTokenRepository=CTSPersistentStore.getInstance();
    }
 else     if (CTS_REPOSITORY_CLASS_NAME.equals(com.sun.identity.sm.mq.JMQSessionRepository.class.getName())) {
      amTokenRepository=com.sun.identity.sm.mq.JMQSessionRepository.getInstance();
    }
 else {
      throw new IllegalAccessException(""String_Node_Str"" + CTS_REPOSITORY_CLASS_NAME + ""String_Node_Str"");
    }
  }
  return amTokenRepository;
}","/** 
 * Common Get Instance method to obtain access to Service Methods.
 * @return AMTokenRepository Singleton Instance.
 * @throws Exception
 */
public static AMTokenRepository getInstance() throws Exception {
  if (amTokenRepository == null) {
    if (CTS_REPOSITORY_CLASS_NAME.equals(CTSPersistentStore.class.getName())) {
      amTokenRepository=CTSPersistentStore.getInstance();
    }
 else     if (CTS_REPOSITORY_CLASS_NAME.equals(com.sun.identity.sm.mq.JMQSessionRepository.class.getName())) {
      amTokenRepository=com.sun.identity.sm.mq.JMQSessionRepository.getInstance();
    }
 else {
      throw new IllegalAccessException(""String_Node_Str"" + CTS_REPOSITORY_CLASS_NAME + ""String_Node_Str"");
    }
  }
  if (amTokenRepository == null) {
    throw new IllegalAccessError(""String_Node_Str"" + CTS_REPOSITORY_CLASS_NAME + ""String_Node_Str"");
  }
  return amTokenRepository;
}"
9307,"private void setErrorMessage(Exception e){
  String authErrorCode=null;
  if ((e != null) && (e instanceof L10NMessage)) {
    L10NMessage l10nE=(L10NMessage)e;
    authErrorCode=l10nE.getErrorCode();
    if (authErrorCode != null) {
      errorCode=authErrorCode;
      ErrorMessage=l10nE.getL10NMessage(com.sun.identity.shared.locale.Locale.getLocale(AuthUtils.getLocale(ac)));
    }
 else {
      if (ac != null) {
        ErrorMessage=ac.getErrorMessage();
        errorCode=ac.getErrorCode();
      }
    }
  }
  if (errorCode == null || errorCode.isEmpty()) {
    errorCode=AMAuthErrorCode.AUTH_ERROR;
    ErrorMessage=AuthUtils.getErrorMessage(errorCode);
  }
  if (ac != null) {
    errorTemplate=ac.getErrorTemplate();
  }
 else {
    errorTemplate=AuthUtils.getErrorTemplate(errorCode);
  }
  if (loginURL != null && errorCode.equals(""String_Node_Str"") && loginURL.isEmpty()) {
    setDisplayFieldValue(LOGIN_URL,AuthUtils.constructLoginURL(request));
  }
  if (loginDebug.messageEnabled()) {
    loginDebug.message(""String_Node_Str"" + ErrorMessage);
    loginDebug.message(""String_Node_Str"" + errorTemplate);
    loginDebug.message(""String_Node_Str"" + errorCode);
  }
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
}","private void setErrorMessage(Exception e){
  String authErrorCode=null;
  if ((e != null) && (e instanceof L10NMessage)) {
    L10NMessage l10nE=(L10NMessage)e;
    authErrorCode=l10nE.getErrorCode();
    if (authErrorCode != null) {
      errorCode=authErrorCode;
      ErrorMessage=l10nE.getL10NMessage(com.sun.identity.shared.locale.Locale.getLocale(AuthUtils.getLocale(ac)));
    }
  }
  if (authErrorCode == null) {
    if (ac != null) {
      errorCode=ac.getErrorCode();
      ErrorMessage=ac.getErrorMessage();
    }
  }
  if (errorCode == null || errorCode.isEmpty()) {
    errorCode=AMAuthErrorCode.AUTH_ERROR;
  }
  if (ErrorMessage == null || ErrorMessage.isEmpty()) {
    ErrorMessage=AuthUtils.getErrorMessage(errorCode);
  }
  if (ac != null) {
    errorTemplate=ac.getErrorTemplate();
  }
 else {
    errorTemplate=AuthUtils.getErrorTemplate(errorCode);
  }
  if (loginURL != null && errorCode.equals(""String_Node_Str"") && loginURL.isEmpty()) {
    setDisplayFieldValue(LOGIN_URL,AuthUtils.constructLoginURL(request));
  }
  if (loginDebug.messageEnabled()) {
    loginDebug.message(""String_Node_Str"" + ErrorMessage);
    loginDebug.message(""String_Node_Str"" + errorTemplate);
    loginDebug.message(""String_Node_Str"" + errorCode);
  }
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
}"
9308,"/** 
 * Format the given LogRecord and return back a formatted String. <p> The formatted String has the values of the fields which are selected and NULL if any field is not selected. All fields are enclosed in single- quotes. <p> A typical formatted string can be given as follows: '10:10:10', '10th June, 2002', 'NULL', 'NULL', 'Session Created Successfull', 'INFO', 'NULL', 'NULL' <p> This formatted string will be enclosed within braces by Handler to construct the query string.
 * @param logRecord the log record to be formatted.
 * @return formatted string.
 */
public String format(java.util.logging.LogRecord logRecord){
  Map logInfoTable=null;
  if ((LogManagerUtil.isAMLoggingMode()) && (logRecord instanceof com.sun.identity.log.ILogRecord)) {
    logInfoTable=((com.sun.identity.log.ILogRecord)logRecord).getLogInfoMap();
  }
  StringBuilder sbuffer=new StringBuilder();
  String strTime;
  if (secureTimestampGenerator != null) {
    strTime=secureTimestampGenerator.getTimestamp();
  }
 else {
    strTime=""String_Node_Str"";
  }
  String toDate=null;
  if (!isMySQL) {
    toDate=""String_Node_Str"";
  }
 else {
    toDate=""String_Node_Str"";
  }
  sbuffer.append(toDate);
  sbuffer.append(strTime);
  sbuffer.append(""String_Node_Str"");
  sbuffer.append(dateTimeFormat);
  sbuffer.append(""String_Node_Str"");
  String tstr=formatMessage(logRecord);
  if ((tstr == null) || (tstr.length() <= 0)) {
    tstr=LogConstants.NOTAVAIL;
  }
 else   if (tstr.length() > 0) {
    String str1=tstr;
    if (tstr.indexOf(""String_Node_Str"") != -1) {
      str1=checkEscapes(tstr,""String_Node_Str"",""String_Node_Str"");
    }
    String str2=str1;
    if (isMySQL) {
      if (str1.indexOf(""String_Node_Str"") != -1) {
        str2=checkEscapes(str1,""String_Node_Str"",""String_Node_Str"");
      }
    }
    tstr=str2;
  }
  sbuffer.append(""String_Node_Str"").append(tstr).append(""String_Node_Str"");
  if (Debug.messageEnabled()) {
    Debug.message(""String_Node_Str"" + sbuffer.toString() + ""String_Node_Str"");
  }
  String[] allFields=lmanager.getAllFields();
  Set selectedFields=lmanager.getSelectedFieldSet();
  int len=0;
  if (allFields != null) {
    len=allFields.length;
  }
  for (int i=2; i < len - 1; i++) {
    if ((logInfoTable != null) && (selectedFields != null) && (selectedFields.contains(allFields[i]))) {
      String tempstr=(String)logInfoTable.get(allFields[i]);
      if ((tempstr != null) && (tempstr.length() > 0) && (tempstr.indexOf(""String_Node_Str"") != -1)) {
        StringTokenizer tmps=new StringTokenizer(tempstr,""String_Node_Str"");
        StringBuilder thisfield=new StringBuilder();
        if (Debug.messageEnabled()) {
          Debug.message(""String_Node_Str"" + tempstr);
        }
        if (tempstr.indexOf(""String_Node_Str"") == 0) {
          thisfield.append(""String_Node_Str"");
          if (tmps.hasMoreTokens()) {
            thisfield.append(tmps.nextToken());
          }
        }
 else {
          if (tmps.hasMoreTokens()) {
            thisfield.append(tmps.nextToken());
          }
        }
        while (tmps.hasMoreTokens()) {
          thisfield.append(""String_Node_Str"").append(tmps.nextToken());
        }
        if (tempstr.indexOf(""String_Node_Str"",tempstr.length() - 1) != -1) {
          thisfield.append(""String_Node_Str"");
        }
        tempstr=thisfield.toString();
      }
      if (tempstr == null) {
        tempstr=LogConstants.NOTAVAIL;
      }
      sbuffer.append(""String_Node_Str"").append(tempstr).append(""String_Node_Str"");
    }
 else {
      sbuffer.append(""String_Node_Str"").append(LogConstants.NOTAVAIL).append(""String_Node_Str"").append(""String_Node_Str"");
    }
  }
  if (Debug.messageEnabled()) {
    Debug.message(""String_Node_Str"" + sbuffer.toString());
  }
  if ((selectedFields != null) && (logInfoTable != null) && (selectedFields.contains(allFields[len - 1]))) {
    String tmpstr=(String)logInfoTable.get(allFields[len - 1]);
    if (tmpstr == null) {
      tmpstr=LogConstants.NOTAVAIL;
    }
    sbuffer.append(""String_Node_Str"").append(tmpstr).append(""String_Node_Str"");
  }
 else {
    sbuffer.append(""String_Node_Str"").append(LogConstants.NOTAVAIL).append(""String_Node_Str"");
  }
  if (Debug.messageEnabled()) {
    Debug.message(""String_Node_Str"" + sbuffer.toString());
  }
  return sbuffer.toString();
}","/** 
 * Format the given LogRecord and return back a formatted String. <p> The formatted String has the values of the fields which are selected and NULL if any field is not selected. All fields are enclosed in single- quotes. <p> A typical formatted string can be given as follows: '10:10:10', '10th June, 2002', 'NULL', 'NULL', 'Session Created Successfull', 'INFO', 'NULL', 'NULL' <p> This formatted string will be enclosed within braces by Handler to construct the query string.
 * @param logRecord the log record to be formatted.
 * @return formatted string.
 */
public String format(java.util.logging.LogRecord logRecord){
  Map logInfoTable=null;
  if ((LogManagerUtil.isAMLoggingMode()) && (logRecord instanceof com.sun.identity.log.ILogRecord)) {
    logInfoTable=((com.sun.identity.log.ILogRecord)logRecord).getLogInfoMap();
  }
  StringBuilder sbuffer=new StringBuilder();
  String strTime;
  if (secureTimestampGenerator != null) {
    strTime=secureTimestampGenerator.getTimestamp();
  }
 else {
    strTime=""String_Node_Str"";
  }
  String toDate=null;
  if (!isMySQL) {
    toDate=""String_Node_Str"";
  }
 else {
    toDate=""String_Node_Str"";
  }
  sbuffer.append(toDate);
  sbuffer.append(strTime);
  sbuffer.append(""String_Node_Str"");
  sbuffer.append(dateTimeFormat);
  sbuffer.append(""String_Node_Str"");
  String tstr=formatMessage(logRecord);
  if ((tstr == null) || (tstr.length() <= 0)) {
    tstr=LogConstants.NOTAVAIL;
  }
 else   if (tstr.length() > 0) {
    String str1=tstr;
    if (tstr.indexOf(""String_Node_Str"") != -1) {
      str1=checkEscapes(tstr,""String_Node_Str"",""String_Node_Str"");
    }
    String str2=str1;
    if (isMySQL) {
      if (str1.indexOf(""String_Node_Str"") != -1) {
        str2=checkEscapes(str1,""String_Node_Str"",""String_Node_Str"");
      }
    }
 else {
      int splitLength=MAX_LITERAL_LENGTH / 4;
      if (str1.length() >= splitLength) {
        StringBuilder strBuilder=new StringBuilder();
        int beginIndex=0;
        int endIndex=splitLength;
        if (str1.length() >= splitLength) {
          strBuilder.append(""String_Node_Str"");
          while (str1.length() > beginIndex) {
            if (endIndex > str1.length()) {
              endIndex=str1.length();
            }
            strBuilder.append(""String_Node_Str"");
            strBuilder.append(str1.substring(beginIndex,endIndex));
            strBuilder.append(""String_Node_Str"");
            beginIndex=beginIndex + splitLength;
            endIndex=endIndex + splitLength;
          }
          strBuilder.append(""String_Node_Str"");
        }
        str2=strBuilder.toString();
      }
    }
    tstr=str2;
  }
  sbuffer.append(""String_Node_Str"").append(tstr).append(""String_Node_Str"");
  if (Debug.messageEnabled()) {
    Debug.message(""String_Node_Str"" + sbuffer.toString() + ""String_Node_Str"");
  }
  String[] allFields=lmanager.getAllFields();
  Set selectedFields=lmanager.getSelectedFieldSet();
  int len=0;
  if (allFields != null) {
    len=allFields.length;
  }
  for (int i=2; i < len - 1; i++) {
    if ((logInfoTable != null) && (selectedFields != null) && (selectedFields.contains(allFields[i]))) {
      String tempstr=(String)logInfoTable.get(allFields[i]);
      if ((tempstr != null) && (tempstr.length() > 0) && (tempstr.indexOf(""String_Node_Str"") != -1)) {
        StringTokenizer tmps=new StringTokenizer(tempstr,""String_Node_Str"");
        StringBuilder thisfield=new StringBuilder();
        if (Debug.messageEnabled()) {
          Debug.message(""String_Node_Str"" + tempstr);
        }
        if (tempstr.indexOf(""String_Node_Str"") == 0) {
          thisfield.append(""String_Node_Str"");
          if (tmps.hasMoreTokens()) {
            thisfield.append(tmps.nextToken());
          }
        }
 else {
          if (tmps.hasMoreTokens()) {
            thisfield.append(tmps.nextToken());
          }
        }
        while (tmps.hasMoreTokens()) {
          thisfield.append(""String_Node_Str"").append(tmps.nextToken());
        }
        if (tempstr.indexOf(""String_Node_Str"",tempstr.length() - 1) != -1) {
          thisfield.append(""String_Node_Str"");
        }
        tempstr=thisfield.toString();
      }
      if (tempstr == null) {
        tempstr=LogConstants.NOTAVAIL;
      }
      sbuffer.append(""String_Node_Str"").append(tempstr).append(""String_Node_Str"");
    }
 else {
      sbuffer.append(""String_Node_Str"").append(LogConstants.NOTAVAIL).append(""String_Node_Str"").append(""String_Node_Str"");
    }
  }
  if (Debug.messageEnabled()) {
    Debug.message(""String_Node_Str"" + sbuffer.toString());
  }
  if ((selectedFields != null) && (logInfoTable != null) && (selectedFields.contains(allFields[len - 1]))) {
    String tmpstr=(String)logInfoTable.get(allFields[len - 1]);
    if (tmpstr == null) {
      tmpstr=LogConstants.NOTAVAIL;
    }
    sbuffer.append(""String_Node_Str"").append(tmpstr).append(""String_Node_Str"");
  }
 else {
    sbuffer.append(""String_Node_Str"").append(LogConstants.NOTAVAIL).append(""String_Node_Str"");
  }
  if (Debug.messageEnabled()) {
    Debug.message(""String_Node_Str"" + sbuffer.toString());
  }
  return sbuffer.toString();
}"
9309,"/** 
 * Takes an AMRecord and writes this to the store
 * @param record The record object to store
 * @throws com.iplanet.dpro.session.exceptions.StoreException
 */
private void writeImmediate(AMRootEntity record) throws StoreException {
  boolean found=false;
  StringBuilder baseDN=new StringBuilder();
  baseDN.append(Constants.AMRECORD_NAMING_ATTR).append(Constants.EQUALS);
  baseDN.append((record).getPrimaryKey()).append(Constants.COMMA);
  baseDN.append(Constants.BASE_DN).append(Constants.COMMA).append(SystemPropertiesManager.get(SYS_PROPERTY_SESSION_HA_REPOSITORY_ROOT_DN));
  debug.error(""String_Node_Str"" + baseDN.toString() + ""String_Node_Str""+ record.toString()+ ""String_Node_Str"");
  try {
    InternalSearchOperation iso=icConn.processSearch(baseDN.toString(),SearchScope.SINGLE_LEVEL,DereferencePolicy.NEVER_DEREF_ALIASES,0,0,false,Constants.FAMRECORD_FILTER,returnAttrs);
    ResultCode resultCode=iso.getResultCode();
    if (resultCode == ResultCode.SUCCESS) {
      final LocalizableMessage message=DB_ENT_P.get(baseDN);
      Log.logger.log(Level.FINE,message.toString());
      found=true;
    }
 else     if (resultCode == ResultCode.NO_SUCH_OBJECT) {
      final LocalizableMessage message=DB_ENT_NOT_P.get(baseDN);
      Log.logger.log(Level.FINE,message.toString());
    }
 else {
      final LocalizableMessage message=DB_ENT_ACC_FAIL.get(baseDN,resultCode.toString());
      Log.logger.log(Level.WARNING,message.toString());
      throw new StoreException(message.toString());
    }
  }
 catch (  DirectoryException dex) {
    final LocalizableMessage message=DB_ENT_ACC_FAIL2.get(baseDN);
    Log.logger.log(Level.WARNING,message.toString(),dex);
    throw new StoreException(message.toString(),dex);
  }
  if (found) {
    updateImmediate(record);
  }
 else {
    storeImmediate(record);
  }
}","/** 
 * Takes an AMRecord and writes this to the store
 * @param record The record object to store
 * @throws com.iplanet.dpro.session.exceptions.StoreException
 */
private void writeImmediate(AMRootEntity record) throws StoreException {
  boolean found=false;
  StringBuilder baseDN=new StringBuilder();
  baseDN.append(Constants.AMRECORD_NAMING_ATTR).append(Constants.EQUALS);
  baseDN.append((record).getPrimaryKey()).append(Constants.COMMA);
  baseDN.append(Constants.BASE_DN).append(Constants.COMMA).append(SystemPropertiesManager.get(SYS_PROPERTY_SESSION_HA_REPOSITORY_ROOT_DN));
  debug.error(""String_Node_Str"" + baseDN.toString() + ""String_Node_Str""+ ""String_Node_Str""+ record.getService()+ ""String_Node_Str""+ ""String_Node_Str""+ record.getOperation()+ ""String_Node_Str""+ ""String_Node_Str""+ record.getPrimaryKey()+ ""String_Node_Str""+ ""String_Node_Str""+ record.getSecondaryKey()+ ""String_Node_Str""+ ""String_Node_Str""+ record.getState()+ ""String_Node_Str""+ ""String_Node_Str""+ record.getExpDate()+ ""String_Node_Str"");
  try {
    InternalSearchOperation iso=icConn.processSearch(baseDN.toString(),SearchScope.SINGLE_LEVEL,DereferencePolicy.NEVER_DEREF_ALIASES,0,0,false,Constants.FAMRECORD_FILTER,returnAttrs);
    ResultCode resultCode=iso.getResultCode();
    if (resultCode == ResultCode.SUCCESS) {
      final LocalizableMessage message=DB_ENT_P.get(baseDN);
      Log.logger.log(Level.FINE,message.toString());
      found=true;
    }
 else     if (resultCode == ResultCode.NO_SUCH_OBJECT) {
      final LocalizableMessage message=DB_ENT_NOT_P.get(baseDN);
      Log.logger.log(Level.FINE,message.toString());
    }
 else {
      final LocalizableMessage message=DB_ENT_ACC_FAIL.get(baseDN,resultCode.toString());
      Log.logger.log(Level.WARNING,message.toString());
      throw new StoreException(message.toString());
    }
  }
 catch (  DirectoryException dex) {
    final LocalizableMessage message=DB_ENT_ACC_FAIL2.get(baseDN);
    Log.logger.log(Level.WARNING,message.toString(),dex);
    throw new StoreException(message.toString(),dex);
  }
  if (found) {
    updateImmediate(record);
  }
 else {
    storeImmediate(record);
  }
}"
9310,"/** 
 * This function inductively adds all of the cofaces of the simplex tau to the complex. For more information about this algorithm, consult the paper ""Fast Construction of the Vietoris-Rips Complex"" by Afra Zomorodian.
 * @param G the neighborhood graph
 * @param k the maximum allowable dimension
 * @param tau the current simplex to add
 * @param N the lower neighbors to investigate
 * @param filtrationValue the filtration value of the current simplex, tau
 */
protected void addCofaces(UndirectedWeightedListGraph G,int k,Simplex tau,TIntHashSet N,double filtrationValue){
  Simplex newSimplex=null;
  if (this.indices != null) {
    newSimplex=HomologyUtility.convertIndices(tau,this.indices);
  }
 else {
    newSimplex=tau;
  }
  if (this.isMember(tau)) {
    this.storageStructure.addElement(newSimplex,this.converter.getFiltrationIndex(filtrationValue));
  }
  if (tau.getDimension() >= k) {
    return;
  }
  double weight=0;
  TIntIterator iterator=N.iterator();
  TIntHashSet M;
  while (iterator.hasNext()) {
    int v=iterator.next();
    Simplex sigma=new Simplex(HomologyUtility.appendToArray(tau.getVertices(),v));
    M=HomologyUtility.computeIntersection(N,G.getLowerNeighbors(v));
    if (sigma.getDimension() == 1) {
      int i=sigma.getVertices()[0];
      int j=sigma.getVertices()[1];
      weight=G.getWeight(i,j);
    }
 else     if (sigma.getDimension() > 1) {
      weight=filtrationValue;
      int[] tauVertices=tau.getVertices();
      for (      int tauVertex : tauVertices) {
        weight=this.converter.computeInducedFiltrationValue(weight,G.getWeight(tauVertex,v));
      }
    }
    this.addCofaces(G,k,sigma,M,weight);
  }
}","/** 
 * This function inductively adds all of the cofaces of the simplex tau to the complex. For more information about this algorithm, consult the paper ""Fast Construction of the Vietoris-Rips Complex"" by Afra Zomorodian.
 * @param G the neighborhood graph
 * @param k the maximum allowable dimension
 * @param tau the current simplex to add
 * @param N the lower neighbors to investigate
 * @param filtrationValue the filtration value of the current simplex, tau
 */
protected void addCofaces(UndirectedWeightedListGraph G,int k,Simplex tau,ArrayList<Integer> lower_vertices,int filtrationIndex){
  Simplex newSimplex=null;
  if (this.indices != null) {
    newSimplex=HomologyUtility.convertIndices(tau,this.indices);
  }
 else {
    newSimplex=tau;
  }
  BooleanDoublePair member=this.isMember(tau);
  if (member.getFirst()) {
    filtrationIndex=Math.max(filtrationIndex,this.converter.getFiltrationIndex(member.getSecond()));
    this.storageStructure.addElement(newSimplex,filtrationIndex);
  }
  if (tau.getDimension() >= k) {
    return;
  }
  if (lower_vertices.size() == 0)   return;
  ArrayList<Integer> new_lower_vertices=new ArrayList<Integer>(lower_vertices.size() - 1);
  for (  int v : lower_vertices) {
    Simplex sigma=new Simplex(HomologyUtility.appendToArray(tau.getVertices(),v));
    if (this.indices != null) {
      newSimplex=HomologyUtility.convertIndices(sigma,this.indices);
    }
 else {
      newSimplex=sigma;
    }
    int newFiltrationIndex=filtrationIndex;
    for (    Simplex ds : newSimplex.getBoundaryArray()) {
      if (this.storageStructure.containsElement(ds)) {
        newFiltrationIndex=Math.max(newFiltrationIndex,this.storageStructure.getFiltrationIndex(ds));
      }
 else {
        continue;
      }
    }
    this.addCofaces(G,k,sigma,new_lower_vertices,newFiltrationIndex);
    new_lower_vertices.add(v);
  }
}"
9311,"/** 
 * This function performs the incremental expansion of the complex.
 * @param G the neighborhood graph
 * @param k the maximum dimension
 */
protected void incrementalExpansion(UndirectedWeightedListGraph G,int k){
  int n=G.getNumVertices();
  for (int u=0; u < n; u++) {
    this.addCofaces(G,k,new Simplex(new int[]{u}),G.getLowerNeighbors(u),this.converter.getInitialFiltrationValue());
  }
}","/** 
 * This function performs the incremental expansion of the complex.
 * @param G the neighborhood graph
 * @param k the maximum dimension
 */
protected void incrementalExpansion(UndirectedWeightedListGraph G,int k){
  int n=G.getNumVertices();
  ArrayList<Integer> lower_vertices=new ArrayList<Integer>(n - 1);
  for (int u=0; u < n; u++) {
    this.addCofaces(G,k,new Simplex(new int[]{u}),lower_vertices,0);
    lower_vertices.add(u);
  }
}"
9312,protected abstract boolean isMember(Simplex simplex);,protected abstract BooleanDoublePair isMember(Simplex simplex);
9313,"protected boolean isMember(Simplex simplex){
  return true;
}","protected BooleanDoublePair isMember(Simplex simplex){
  return new BooleanDoublePair(true,0.0);
}"
9314,"@Override protected boolean isMember(Simplex simplex){
  return true;
}","@Override protected BooleanDoublePair isMember(Simplex simplex){
  return new BooleanDoublePair(true,0.0);
}"
9315,"@Override protected boolean isMember(Simplex simplex){
  boolean isMember=false;
  int[] vertices=simplex.getVertices();
  IntDoublePair witnessAndDistance=this.getWitnessAndDistance(vertices);
  int n_star=witnessAndDistance.getFirst();
  double e_ij=witnessAndDistance.getSecond();
  if (e_ij <= this.maxDistance + this.epsilon) {
    isMember=true;
    this.updateWitnessInformationInternalIndices(n_star,e_ij,simplex.getVertices());
  }
  return isMember;
}","@Override protected BooleanDoublePair isMember(Simplex simplex){
  boolean isMember=false;
  int[] vertices=simplex.getVertices();
  IntDoublePair witnessAndDistance=this.getWitnessAndDistance(vertices);
  int n_star=witnessAndDistance.getFirst();
  double e_ij=witnessAndDistance.getSecond();
  if (e_ij <= this.maxDistance + this.epsilon) {
    isMember=true;
    this.updateWitnessInformationInternalIndices(n_star,e_ij,simplex.getVertices());
  }
  return new BooleanDoublePair(isMember,e_ij);
}"
9316,"/** 
 * This function determines whether the given point is a member of  the interval.
 * @param point the point to test
 * @return true if the point is in the interval and false otherwise
 */
public boolean containsPoint(T point){
  if (!this.isLeftInfinite) {
    if (this.isLeftClosed && (point.compareTo(this.start) < 0)) {
      return false;
    }
    if (!this.isLeftClosed && (point.compareTo(this.start) <= 0)) {
      return false;
    }
  }
  if (!this.isRightInfinite) {
    if (this.isRightClosed && (point.compareTo(this.start) > 0)) {
      return false;
    }
    if (!this.isRightClosed && (point.compareTo(this.start) >= 0)) {
      return false;
    }
  }
  return true;
}","/** 
 * This function determines whether the given point is a member of  the interval.
 * @param point the point to test
 * @return true if the point is in the interval and false otherwise
 */
public boolean containsPoint(T point){
  if (!this.isLeftInfinite) {
    if (this.isLeftClosed && (point.compareTo(this.start) < 0)) {
      return false;
    }
    if (!this.isLeftClosed && (point.compareTo(this.start) <= 0)) {
      return false;
    }
  }
  if (!this.isRightInfinite) {
    if (this.isRightClosed && (point.compareTo(this.end) > 0)) {
      return false;
    }
    if (!this.isRightClosed && (point.compareTo(this.end) >= 0)) {
      return false;
    }
  }
  return true;
}"
9317,"/** 
 * Unlocks the device window in user defined screen mode. 
 */
public static void unlockOrientation(Activity activity){
  activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_USER);
}","/** 
 * Unlocks the device window in user defined screen mode. 
 */
public static void unlockOrientation(Activity activity){
  activity.setRequestedOrientation(getManifestOrientation(activity));
}"
9318,"public List<SchemaValidationError> debugByContent(String content) throws Exception {
  String schemaText=getSchema();
  JsonNode schemaObject=MAPPER.readTree(schemaText);
  JsonSchemaFactory factory=JsonSchemaFactory.byDefault();
  JsonSchema schema=factory.getJsonSchema(schemaObject);
  ProcessingReport report=schema.validate(JsonLoader.fromString(content));
  ListProcessingReport lp=new ListProcessingReport();
  lp.mergeWith(report);
  List<SchemaValidationError> output=new ArrayList<SchemaValidationError>();
  java.util.Iterator<ProcessingMessage> it=lp.iterator();
  while (it.hasNext()) {
    ProcessingMessage pm=it.next();
    output.add(new SchemaValidationError(pm.asJson()));
  }
  return output;
}","public List<SchemaValidationError> debugByContent(String content) throws Exception {
  String schemaText=getSchema();
  JsonNode schemaObject=MAPPER.readTree(schemaText);
  JsonSchemaFactory factory=JsonSchemaFactory.byDefault();
  JsonSchema schema=factory.getJsonSchema(schemaObject);
  ProcessingReport report=schema.validate(JsonLoader.fromString(content));
  ListProcessingReport lp=new ListProcessingReport();
  lp.mergeWith(report);
  List<SchemaValidationError> output=new ArrayList<SchemaValidationError>();
  for (  ProcessingMessage pm : lp) {
    output.add(new SchemaValidationError(pm.asJson()));
  }
  return output;
}"
9319,"/** 
 * Initialize toolbar with required components such as - title, navigation icon + listener, menu/OnMenuItemClickListener, menuHideBody -
 */
protected void initToolbar(){
  toolbar.setTitle(""String_Node_Str"");
  toolbar.setNavigationIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha);
  toolbar.setNavigationOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      onBackPressed();
    }
  }
);
  toolbar.inflateMenu(R.menu.menu_edit);
  toolbar.setOnMenuItemClickListener(this);
  Menu menu=toolbar.getMenu();
  if (menu != null)   menuHideBody=menu.findItem(R.id.action_hide_show_body);
}","/** 
 * Initialize toolbar with required components such as - title, navigation icon + listener, menu/OnMenuItemClickListener, menuHideBody -
 */
protected void initToolbar(){
  toolbar.setTitle(""String_Node_Str"");
  toolbar.setNavigationIcon(R.drawable.abc_ic_ab_back_material);
  toolbar.setNavigationOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      onBackPressed();
    }
  }
);
  toolbar.inflateMenu(R.menu.menu_edit);
  toolbar.setOnMenuItemClickListener(this);
  Menu menu=toolbar.getMenu();
  if (menu != null)   menuHideBody=menu.findItem(R.id.action_hide_show_body);
}"
9320,"@NotNull @Override protected String buildMeaningfulClassesQuery(OWLClassExpression index,SortedSet<OWLClassExpression> targetClasses){
  String query=""String_Node_Str"";
  query+=converter.convert(""String_Node_Str"",index);
  query+=""String_Node_Str"";
  query+=""String_Node_Str"";
  query+=""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(FluentIterable.from(targetClasses).transform(Functions.compose(TO_IRI_FUNCTION,OWLCLASS_TRANSFORM_FUNCTION))) + ""String_Node_Str"";
  return query;
}","@NotNull @Override protected String buildMeaningfulClassesQuery(OWLClassExpression index,SortedSet<OWLClassExpression> targetClasses){
  String query=""String_Node_Str"";
  query+=converter.convert(""String_Node_Str"",index);
  query+=""String_Node_Str"";
  query+=""String_Node_Str"";
  query+=""String_Node_Str"" + targetClasses.stream().map(ce -> ""String_Node_Str"" + ce.asOWLClass().toStringID() + ""String_Node_Str"").collect(Collectors.joining(""String_Node_Str"")) + ""String_Node_Str"";
  return query;
}"
9321,"@Override protected String buildApplicablePropertiesValuesQuery(OWLClassExpression domain,Collection<? extends OWLObjectProperty> objectProperties){
  String domQuery=converter.convert(""String_Node_Str"",domain);
  String props=objectProperties.stream().map(TO_IRI_FUNCTION).collect(Collectors.joining(""String_Node_Str""));
  String query=""String_Node_Str"" + ""String_Node_Str"" + domQuery + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ props+ ""String_Node_Str"";
  return query;
}","@Override protected String buildApplicablePropertiesValuesQuery(OWLClassExpression domain,Collection<? extends OWLObjectProperty> objectProperties){
  String domQuery=converter.convert(""String_Node_Str"",domain);
  String props=objectProperties.stream().map(op -> ""String_Node_Str"" + op.toStringID() + ""String_Node_Str"").collect(Collectors.joining(""String_Node_Str""));
  String query=""String_Node_Str"" + ""String_Node_Str"" + domQuery + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ props+ ""String_Node_Str"";
  return query;
}"
9322,"public static void main(String[] args) throws Exception {
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLOntology ontology=man.createOntology();
  OWLDataFactory df=new OWLDataFactoryImpl();
  PrefixManager pm=new DefaultPrefixManager();
  pm.setDefaultPrefix(""String_Node_Str"");
  OWLDataProperty dp=df.getOWLDataProperty(""String_Node_Str"",pm);
  OWLObjectProperty op=df.getOWLObjectProperty(""String_Node_Str"",pm);
  OWLClass clsA=df.getOWLClass(""String_Node_Str"",pm);
  OWLClass cls1=df.getOWLClass(""String_Node_Str"",pm);
  OWLClass cls2=df.getOWLClass(""String_Node_Str"",pm);
  man.addAxiom(ontology,df.getOWLClassAssertionAxiom(clsA,df.getOWLNamedIndividual(""String_Node_Str"",pm)));
  IntStream.range(0,5).forEach(i -> {
    man.addAxiom(ontology,df.getOWLObjectPropertyAssertionAxiom(op,df.getOWLNamedIndividual(""String_Node_Str"",pm),df.getOWLNamedIndividual(""String_Node_Str"" + i,pm)));
  }
);
  IntStream.range(0,5).forEach(i -> {
    man.addAxiom(ontology,df.getOWLClassAssertionAxiom(cls1,df.getOWLNamedIndividual(""String_Node_Str"" + i,pm)));
  }
);
  ToStringRenderer.getInstance().setRenderer(new DLSyntaxObjectRenderer());
  ontology.getLogicalAxioms().forEach(System.out::println);
  OWLAPIOntology ks=new OWLAPIOntology(ontology);
  ks.init();
  ClosedWorldReasoner reasoner=new ClosedWorldReasoner(ks);
  reasoner.init();
  SortedSet<OWLIndividual> individuals=reasoner.getIndividuals(df.getOWLDataSomeValuesFrom(dp,df.getOWLDatatypeMinMaxInclusiveRestriction(1.0d,2.0d)));
  System.out.println(individuals);
  individuals=reasoner.getIndividuals(df.getOWLDataSomeValuesFrom(dp,df.getOWLDatatypeMinMaxInclusiveRestriction(1.0d,1.9d)));
  System.out.println(individuals);
  individuals=reasoner.getIndividuals(df.getOWLDataSomeValuesFrom(dp,df.getOWLDataUnionOf(df.getOWLDatatypeMinMaxInclusiveRestriction(1.0d,1.5d),df.getOWLDatatypeMinMaxInclusiveRestriction(2.0d,2.5d))));
  System.out.println(individuals);
  individuals=reasoner.getIndividuals(df.getOWLDataSomeValuesFrom(dp,df.getOWLDataComplementOf(df.getOWLDatatypeMinMaxInclusiveRestriction(1.0d,1.5d))));
  System.out.println(df.getOWLObjectIntersectionOf(clsA,df.getOWLObjectMaxCardinality(2,op,cls1)));
  individuals=reasoner.getIndividuals(df.getOWLObjectIntersectionOf(clsA,df.getOWLObjectMaxCardinality(2,op,cls1)));
  System.out.println(individuals);
  individuals=reasoner.getIndividuals(df.getOWLObjectMaxCardinality(10,op,cls1));
  System.out.println(individuals);
  individuals=reasoner.getIndividuals(df.getOWLObjectMaxCardinality(8,op,cls1));
  System.out.println(individuals);
}","public static void main(String[] args) throws Exception {
  StringRenderer.setRenderer(StringRenderer.Rendering.OWL_XML_SYNTAX);
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLOntology ontology=man.createOntology();
  OWLDataFactory df=new OWLDataFactoryImpl();
  PrefixManager pm=new DefaultPrefixManager();
  pm.setDefaultPrefix(""String_Node_Str"");
  OWLDataProperty dp=df.getOWLDataProperty(""String_Node_Str"",pm);
  OWLObjectProperty op=df.getOWLObjectProperty(""String_Node_Str"",pm);
  OWLClass clsA=df.getOWLClass(""String_Node_Str"",pm);
  OWLClass cls1=df.getOWLClass(""String_Node_Str"",pm);
  OWLClass cls2=df.getOWLClass(""String_Node_Str"",pm);
  man.addAxiom(ontology,df.getOWLClassAssertionAxiom(clsA,df.getOWLNamedIndividual(""String_Node_Str"",pm)));
  IntStream.range(0,5).forEach(i -> {
    man.addAxiom(ontology,df.getOWLObjectPropertyAssertionAxiom(op,df.getOWLNamedIndividual(""String_Node_Str"",pm),df.getOWLNamedIndividual(""String_Node_Str"" + i,pm)));
  }
);
  IntStream.range(0,5).forEach(i -> {
    man.addAxiom(ontology,df.getOWLClassAssertionAxiom(cls1,df.getOWLNamedIndividual(""String_Node_Str"" + i,pm)));
  }
);
  ontology.getLogicalAxioms().forEach(System.out::println);
  OWLAPIOntology ks=new OWLAPIOntology(ontology);
  ks.init();
  ClosedWorldReasoner reasoner=new ClosedWorldReasoner(ks);
  reasoner.init();
  SortedSet<OWLIndividual> individuals=reasoner.getIndividuals(df.getOWLDataSomeValuesFrom(dp,df.getOWLDatatypeMinMaxInclusiveRestriction(1.0d,2.0d)));
  System.out.println(individuals);
  individuals=reasoner.getIndividuals(df.getOWLDataSomeValuesFrom(dp,df.getOWLDatatypeMinMaxInclusiveRestriction(1.0d,1.9d)));
  System.out.println(individuals);
  individuals=reasoner.getIndividuals(df.getOWLDataSomeValuesFrom(dp,df.getOWLDataUnionOf(df.getOWLDatatypeMinMaxInclusiveRestriction(1.0d,1.5d),df.getOWLDatatypeMinMaxInclusiveRestriction(2.0d,2.5d))));
  System.out.println(individuals);
  individuals=reasoner.getIndividuals(df.getOWLDataSomeValuesFrom(dp,df.getOWLDataComplementOf(df.getOWLDatatypeMinMaxInclusiveRestriction(1.0d,1.5d))));
  System.out.println(df.getOWLObjectIntersectionOf(clsA,df.getOWLObjectMaxCardinality(2,op,cls1)));
  individuals=reasoner.getIndividuals(df.getOWLObjectIntersectionOf(clsA,df.getOWLObjectMaxCardinality(2,op,cls1)));
  System.out.println(individuals);
  individuals=reasoner.getIndividuals(df.getOWLObjectMaxCardinality(10,op,cls1));
  System.out.println(individuals);
  individuals=reasoner.getIndividuals(df.getOWLObjectMaxCardinality(8,op,cls1));
  System.out.println(individuals);
}"
9323,"private void loadOrDematerialize(){
  if (useMaterializationCaching) {
    File cacheDir=new File(""String_Node_Str"");
    cacheDir.mkdirs();
    HashFunction hf=Hashing.goodFastHash(128);
    Hasher hasher=hf.newHasher();
    hasher.putBoolean(materializeExistentialRestrictions);
    hasher.putBoolean(handlePunning);
    for (    OWLOntology ont : Collections.singleton(baseReasoner.getOntology())) {
      hasher.putInt(ont.getLogicalAxioms().hashCode());
      hasher.putInt(ont.getAxioms().hashCode());
    }
    String filename=hasher.hash().toString() + ""String_Node_Str"";
    File cacheFile=new File(cacheDir,filename);
    if (cacheFile.exists()) {
      logger.debug(""String_Node_Str"");
      try (ObjectInputStream ois=new ObjectInputStream(new FileInputStream(cacheFile))){
        Materialization mat=(Materialization)ois.readObject();
        classInstancesPos=mat.classInstancesPos;
        classInstancesNeg=mat.classInstancesNeg;
        opPos=mat.opPos;
        dpPos=mat.dpPos;
        bdPos=mat.bdPos;
        bdNeg=mat.bdNeg;
        dd=mat.dd;
        id=mat.id;
        sd=mat.sd;
      }
 catch (      ClassNotFoundException|IOException e) {
        e.printStackTrace();
      }
      logger.debug(""String_Node_Str"");
    }
 else {
      materialize();
      Materialization mat=new Materialization();
      mat.classInstancesPos=classInstancesPos;
      mat.classInstancesNeg=classInstancesNeg;
      mat.opPos=opPos;
      mat.dpPos=dpPos;
      mat.bdPos=bdPos;
      mat.bdNeg=bdNeg;
      mat.dd=dd;
      mat.id=id;
      mat.sd=sd;
      try (ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(cacheFile))){
        oos.writeObject(mat);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
 else {
    materialize();
  }
}","private void loadOrDematerialize(){
  if (useMaterializationCaching) {
    File cacheDir=new File(""String_Node_Str"");
    if (!cacheDir.mkdirs()) {
      throw new RuntimeException(""String_Node_Str"" + cacheDir.getAbsolutePath());
    }
    HashFunction hf=Hashing.goodFastHash(128);
    Hasher hasher=hf.newHasher();
    hasher.putBoolean(materializeExistentialRestrictions);
    hasher.putBoolean(handlePunning);
    for (    OWLOntology ont : Collections.singleton(baseReasoner.getOntology())) {
      hasher.putInt(ont.getLogicalAxioms().hashCode());
      hasher.putInt(ont.getAxioms().hashCode());
    }
    String filename=hasher.hash().toString() + ""String_Node_Str"";
    File cacheFile=new File(cacheDir,filename);
    if (cacheFile.exists()) {
      logger.debug(""String_Node_Str"");
      try (ObjectInputStream ois=new ObjectInputStream(new FileInputStream(cacheFile))){
        Materialization mat=(Materialization)ois.readObject();
        classInstancesPos=mat.classInstancesPos;
        classInstancesNeg=mat.classInstancesNeg;
        opPos=mat.opPos;
        dpPos=mat.dpPos;
        bdPos=mat.bdPos;
        bdNeg=mat.bdNeg;
        dd=mat.dd;
        id=mat.id;
        sd=mat.sd;
      }
 catch (      ClassNotFoundException|IOException e) {
        e.printStackTrace();
      }
      logger.debug(""String_Node_Str"");
    }
 else {
      materialize();
      Materialization mat=new Materialization();
      mat.classInstancesPos=classInstancesPos;
      mat.classInstancesNeg=classInstancesNeg;
      mat.opPos=opPos;
      mat.dpPos=dpPos;
      mat.bdPos=bdPos;
      mat.bdNeg=bdNeg;
      mat.dd=dd;
      mat.id=id;
      mat.sd=sd;
      try (ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(cacheFile))){
        oos.writeObject(mat);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
 else {
    materialize();
  }
}"
9324,"@NotNull protected String buildMeaningfulClassesQuery(OWLClassExpression index,SortedSet<OWLClassExpression> targetClasses){
  String query=""String_Node_Str"";
  query+=converter.convert(""String_Node_Str"",index);
  query+=""String_Node_Str"";
  query+=""String_Node_Str"" + targetClasses.stream().map(ce -> ""String_Node_Str"" + ce.asOWLClass().toStringID() + ""String_Node_Str"").collect(Collectors.joining(""String_Node_Str"")) + ""String_Node_Str"";
  query+=""String_Node_Str"";
  return query;
}","protected String buildMeaningfulClassesQuery(OWLClassExpression index,SortedSet<OWLClassExpression> targetClasses){
  String query=""String_Node_Str"";
  query+=converter.convert(""String_Node_Str"",index);
  query+=""String_Node_Str"";
  query+=""String_Node_Str"" + targetClasses.stream().map(ce -> ""String_Node_Str"" + ce.asOWLClass().toStringID() + ""String_Node_Str"").collect(Collectors.joining(""String_Node_Str"")) + ""String_Node_Str"";
  query+=""String_Node_Str"";
  return query;
}"
9325,"public void rebuild(){
  propertyManager=new OWLObjectPropertyManager(getRootOntology().getOWLOntologyManager(),getRootOntology());
  sub2Super=propertyManager.getPropertyHierarchy();
  super2Sub=new HashMap<>();
  for (  OWLObjectPropertyExpression sub : sub2Super.keySet()) {
    for (    OWLObjectPropertyExpression superProp : sub2Super.get(sub)) {
      super2Sub.computeIfAbsent(superProp,k -> new HashSet<>()).add(sub);
    }
  }
}","public void rebuild(){
  propertyManager=new OWLObjectPropertyManager(getRootOntology().getOWLOntologyManager(),getRootOntology());
  sub2Super=propertyManager.getPropertyHierarchy();
  super2Sub=new HashMap<>();
  for (  Map.Entry<OWLObjectPropertyExpression,Set<OWLObjectPropertyExpression>> entry : sub2Super.entrySet()) {
    for (    OWLObjectPropertyExpression superProp : entry.getValue()) {
      super2Sub.computeIfAbsent(superProp,k -> new HashSet<>()).add(entry.getKey());
    }
  }
}"
9326,"@SuppressWarnings(""String_Node_Str"") public SortedSet<OWLIndividual> getIndividualsImplFast(OWLClassExpression description) throws ReasoningMethodUnsupportedException {
  if (description.isOWLThing()) {
    return (TreeSet<OWLIndividual>)individuals.clone();
  }
 else   if (description.isOWLNothing()) {
    return new TreeSet<>();
  }
 else   if (!description.isAnonymous()) {
    if (classInstancesPos.containsKey(description.asOWLClass())) {
      return (TreeSet<OWLIndividual>)classInstancesPos.get(description).clone();
    }
 else {
      return new TreeSet<>();
    }
  }
 else   if (description instanceof OWLObjectComplementOf) {
    OWLClassExpression operand=((OWLObjectComplementOf)description).getOperand();
    if (!operand.isAnonymous()) {
      if (isDefaultNegation()) {
        if (precomputeNegations) {
          return (TreeSet<OWLIndividual>)classInstancesNeg.get(operand).clone();
        }
        SetView<OWLIndividual> diff=Sets.difference(individuals,classInstancesPos.get(operand));
        return new TreeSet<>(diff);
      }
 else {
        return (TreeSet<OWLIndividual>)classInstancesNeg.get(operand).clone();
      }
    }
    return new TreeSet<>(Sets.difference(individuals,getIndividualsImpl(operand)));
  }
 else   if (description instanceof OWLObjectUnionOf) {
    SortedSet<OWLIndividual> ret=new TreeSet<>();
    for (    OWLClassExpression operand : ((OWLObjectUnionOf)description).getOperands()) {
      ret.addAll(getIndividualsImpl(operand));
    }
    return ret;
  }
 else   if (description instanceof OWLObjectIntersectionOf) {
    Iterator<OWLClassExpression> iterator=((OWLObjectIntersectionOf)description).getOperands().iterator();
    SortedSet<OWLIndividual> ret=getIndividualsImpl(iterator.next());
    while (iterator.hasNext()) {
      ret.retainAll(getIndividualsImpl(iterator.next()));
    }
    return ret;
  }
 else   if (description instanceof OWLObjectSomeValuesFrom) {
    OWLObjectPropertyExpression property=((OWLObjectSomeValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectSomeValuesFrom)description).getFiller();
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,? extends Collection<OWLIndividual>> mapping=getTargetIndividuals(property);
    return mapping.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(targetSet::contains)).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
  }
 else   if (description instanceof OWLObjectAllValuesFrom) {
    OWLObjectPropertyExpression property=((OWLObjectAllValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectAllValuesFrom)description).getFiller();
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,? extends Collection<OWLIndividual>> mapping=getTargetIndividuals(property);
    SortedSet<OWLIndividual> returnSet=(SortedSet<OWLIndividual>)individuals.clone();
    mapping.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(ind -> !targetSet.contains(ind))).forEach(e -> returnSet.remove(e.getKey()));
    return returnSet;
  }
 else   if (description instanceof OWLObjectMinCardinality) {
    OWLObjectPropertyExpression property=((OWLObjectMinCardinality)description).getProperty();
    OWLClassExpression filler=((OWLObjectMinCardinality)description).getFiller();
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,? extends Collection<OWLIndividual>> mapping=getTargetIndividuals(property);
    SortedSet<OWLIndividual> returnSet=new TreeSet<>();
    int number=((OWLObjectMinCardinality)description).getCardinality();
    for (    Entry<OWLIndividual,? extends Collection<OWLIndividual>> entry : mapping.entrySet()) {
      int nrOfFillers=0;
      int index=0;
      Collection<OWLIndividual> inds=entry.getValue();
      if (inds.size() < number) {
        continue;
      }
      for (      OWLIndividual ind : inds) {
        if (nrOfFillers >= number) {
          returnSet.add(entry.getKey());
          break;
        }
        if (inds.size() - index < number) {
          break;
        }
        if (targetSet.contains(ind)) {
          nrOfFillers++;
        }
        index++;
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLObjectMaxCardinality) {
    OWLObjectPropertyExpression property=((OWLObjectMaxCardinality)description).getProperty();
    OWLClassExpression filler=((OWLObjectMaxCardinality)description).getFiller();
    int number=((OWLObjectMaxCardinality)description).getCardinality();
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,? extends Collection<OWLIndividual>> mapping=getTargetIndividuals(property);
    SortedSet<OWLIndividual> returnSet=(SortedSet<OWLIndividual>)individuals.clone();
    for (    Entry<OWLIndividual,? extends Collection<OWLIndividual>> entry : mapping.entrySet()) {
      int nrOfFillers=0;
      int index=0;
      Collection<OWLIndividual> inds=entry.getValue();
      if (number < inds.size()) {
        returnSet.add(entry.getKey());
        continue;
      }
      for (      OWLIndividual ind : inds) {
        if (nrOfFillers >= number) {
          break;
        }
        if (inds.size() - index < number) {
          returnSet.add(entry.getKey());
          break;
        }
        if (targetSet.contains(ind)) {
          nrOfFillers++;
        }
        index++;
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLObjectHasValue) {
    OWLObjectPropertyExpression property=((OWLObjectHasValue)description).getProperty();
    OWLIndividual value=((OWLObjectHasValue)description).getFiller();
    Map<OWLIndividual,? extends Collection<OWLIndividual>> mapping=property.isAnonymous() ? Multimaps.invertFrom(MapUtils.createSortedMultiMap(opPos.get(property.getNamedProperty())),TreeMultimap.create()).asMap() : opPos.get(property.getNamedProperty());
    return mapping.entrySet().stream().filter(e -> e.getValue().contains(value)).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
  }
 else   if (description instanceof OWLDataSomeValuesFrom) {
    OWLDataPropertyExpression property=((OWLDataSomeValuesFrom)description).getProperty();
    OWLDataRange filler=((OWLDataSomeValuesFrom)description).getFiller();
    if (filler.isDatatype()) {
      return new TreeSet<>(dpPos.get(property).keySet());
    }
 else     if (filler instanceof OWLDataIntersectionOf) {
      return ((OWLDataIntersectionOf)filler).getOperands().stream().map(dr -> getIndividuals(df.getOWLDataSomeValuesFrom(property,dr))).reduce((s1,s2) -> {
        s1.retainAll(s2);
        return s1;
      }
).orElse(new TreeSet<>());
    }
 else     if (filler instanceof OWLDataUnionOf) {
      return ((OWLDataUnionOf)filler).getOperands().stream().map(dr -> getIndividuals(df.getOWLDataSomeValuesFrom(property,dr))).reduce((s1,s2) -> {
        s1.addAll(s2);
        return s1;
      }
).orElse(new TreeSet<>());
    }
 else     if (filler instanceof OWLDataComplementOf) {
      return new TreeSet<>(Sets.difference(individuals,getIndividualsImpl(df.getOWLDataSomeValuesFrom(property,((OWLDataComplementOf)filler).getDataRange()))));
    }
 else     if (filler instanceof OWLDatatypeRestriction) {
      OWLDatatype datatype=((OWLDatatypeRestriction)filler).getDatatype();
      Set<OWLFacetRestriction> facetRestrictions=((OWLDatatypeRestriction)filler).getFacetRestrictions();
      if (OWLAPIUtils.floatDatatypes.contains(datatype)) {
        double min=facetRestrictions.stream().filter(fr -> fr.getFacet() == OWLFacet.MIN_INCLUSIVE).map(fr -> fr.getFacetValue().isDouble() ? fr.getFacetValue().parseDouble() : (double)fr.getFacetValue().parseFloat()).findAny().orElse(-Double.MAX_VALUE);
        double max=facetRestrictions.stream().filter(fr -> fr.getFacet() == OWLFacet.MAX_INCLUSIVE).map(fr -> fr.getFacetValue().isDouble() ? fr.getFacetValue().parseDouble() : (double)fr.getFacetValue().parseFloat()).findAny().orElse(Double.MAX_VALUE);
        return dd.getOrDefault(property,new HashMap<>()).entrySet().stream().filter(e -> {
          SortedSet<Double> values=e.getValue();
          if (values.last() < min || values.first() > max) {
            return false;
          }
          return values.stream().anyMatch(val -> val >= min && val <= max);
        }
).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
      }
 else       if (OWLAPIUtils.intDatatypes.contains(datatype)) {
        int min=facetRestrictions.stream().filter(fr -> fr.getFacet() == OWLFacet.MIN_INCLUSIVE).map(fr -> fr.getFacetValue().parseInteger()).findAny().orElse(-Integer.MAX_VALUE);
        int max=facetRestrictions.stream().filter(fr -> fr.getFacet() == OWLFacet.MAX_INCLUSIVE).map(fr -> fr.getFacetValue().parseInteger()).findAny().orElse(Integer.MAX_VALUE);
        return id.getOrDefault(property,new HashMap<>()).entrySet().stream().filter(e -> {
          SortedSet<Integer> values=e.getValue();
          if (values.last() < min || values.first() > max) {
            return false;
          }
          return values.stream().anyMatch(val -> val >= min && val <= max);
        }
).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
      }
 else       if (OWLAPIUtils.dtDatatypes.contains(datatype)) {
        OWLLiteral min=facetRestrictions.stream().filter(fr -> fr.getFacet() == OWLFacet.MIN_INCLUSIVE).map(OWLFacetRestriction::getFacetValue).findAny().orElse(null);
        OWLLiteral max=facetRestrictions.stream().filter(fr -> fr.getFacet() == OWLFacet.MAX_INCLUSIVE).map(OWLFacetRestriction::getFacetValue).findAny().orElse(null);
        return dpPos.getOrDefault(property,new HashMap<>()).entrySet().stream().filter(e -> e.getValue().stream().anyMatch(val -> OWLAPIUtils.inRange(val,min,max))).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
      }
    }
 else     if (filler.getDataRangeType() == DataRangeType.DATA_ONE_OF) {
      OWLDataOneOf dataOneOf=(OWLDataOneOf)filler;
      Set<OWLLiteral> values=dataOneOf.getValues();
      return dpPos.getOrDefault(property,new HashMap<>()).entrySet().stream().filter(e -> !Sets.intersection(e.getValue(),values).isEmpty()).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
    }
  }
 else   if (description instanceof OWLDataHasValue) {
    OWLDataPropertyExpression property=((OWLDataHasValue)description).getProperty();
    OWLLiteral value=((OWLDataHasValue)description).getFiller();
    return dpPos.getOrDefault(property,new HashMap<>()).entrySet().stream().filter(e -> e.getValue().contains(value)).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
  }
 else   if (description instanceof OWLObjectOneOf) {
    return new TreeSet(((OWLObjectOneOf)description).getIndividuals());
  }
  throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") public SortedSet<OWLIndividual> getIndividualsImplFast(OWLClassExpression description) throws ReasoningMethodUnsupportedException {
  if (description.isOWLThing()) {
    return (TreeSet<OWLIndividual>)individuals.clone();
  }
 else   if (description.isOWLNothing()) {
    return new TreeSet<>();
  }
 else   if (!description.isAnonymous()) {
    if (classInstancesPos.containsKey(description.asOWLClass())) {
      return (TreeSet<OWLIndividual>)classInstancesPos.get(description).clone();
    }
 else {
      return new TreeSet<>();
    }
  }
 else   if (description instanceof OWLObjectComplementOf) {
    OWLClassExpression operand=((OWLObjectComplementOf)description).getOperand();
    if (!operand.isAnonymous()) {
      if (isDefaultNegation()) {
        if (precomputeNegations) {
          return (TreeSet<OWLIndividual>)classInstancesNeg.get(operand).clone();
        }
        SetView<OWLIndividual> diff=Sets.difference(individuals,classInstancesPos.get(operand));
        return new TreeSet<>(diff);
      }
 else {
        return (TreeSet<OWLIndividual>)classInstancesNeg.get(operand).clone();
      }
    }
    return new TreeSet<>(Sets.difference(individuals,getIndividualsImpl(operand)));
  }
 else   if (description instanceof OWLObjectUnionOf) {
    SortedSet<OWLIndividual> ret=new TreeSet<>();
    for (    OWLClassExpression operand : ((OWLObjectUnionOf)description).getOperands()) {
      ret.addAll(getIndividualsImpl(operand));
    }
    return ret;
  }
 else   if (description instanceof OWLObjectIntersectionOf) {
    Iterator<OWLClassExpression> iterator=((OWLObjectIntersectionOf)description).getOperands().iterator();
    SortedSet<OWLIndividual> ret=getIndividualsImpl(iterator.next());
    while (iterator.hasNext()) {
      ret.retainAll(getIndividualsImpl(iterator.next()));
    }
    return ret;
  }
 else   if (description instanceof OWLObjectSomeValuesFrom) {
    OWLObjectPropertyExpression property=((OWLObjectSomeValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectSomeValuesFrom)description).getFiller();
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,? extends Collection<OWLIndividual>> mapping=getTargetIndividuals(property);
    return mapping.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(targetSet::contains)).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
  }
 else   if (description instanceof OWLObjectAllValuesFrom) {
    OWLObjectPropertyExpression property=((OWLObjectAllValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectAllValuesFrom)description).getFiller();
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,? extends Collection<OWLIndividual>> mapping=getTargetIndividuals(property);
    SortedSet<OWLIndividual> returnSet=(SortedSet<OWLIndividual>)individuals.clone();
    mapping.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(ind -> !targetSet.contains(ind))).forEach(e -> returnSet.remove(e.getKey()));
    return returnSet;
  }
 else   if (description instanceof OWLObjectMinCardinality) {
    OWLObjectPropertyExpression property=((OWLObjectMinCardinality)description).getProperty();
    OWLClassExpression filler=((OWLObjectMinCardinality)description).getFiller();
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,? extends Collection<OWLIndividual>> mapping=getTargetIndividuals(property);
    SortedSet<OWLIndividual> returnSet=new TreeSet<>();
    int number=((OWLObjectMinCardinality)description).getCardinality();
    for (    Entry<OWLIndividual,? extends Collection<OWLIndividual>> entry : mapping.entrySet()) {
      int nrOfFillers=0;
      int index=0;
      Collection<OWLIndividual> inds=entry.getValue();
      if (inds.size() < number) {
        continue;
      }
      for (      OWLIndividual ind : inds) {
        if (nrOfFillers >= number) {
          returnSet.add(entry.getKey());
          break;
        }
        if (inds.size() - index < number) {
          break;
        }
        if (targetSet.contains(ind)) {
          nrOfFillers++;
        }
        index++;
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLObjectMaxCardinality) {
    OWLObjectPropertyExpression property=((OWLObjectMaxCardinality)description).getProperty();
    OWLClassExpression filler=((OWLObjectMaxCardinality)description).getFiller();
    int number=((OWLObjectMaxCardinality)description).getCardinality();
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,? extends Collection<OWLIndividual>> mapping=getTargetIndividuals(property);
    SortedSet<OWLIndividual> returnSet=(SortedSet<OWLIndividual>)individuals.clone();
    for (    Entry<OWLIndividual,? extends Collection<OWLIndividual>> entry : mapping.entrySet()) {
      int nrOfFillers=0;
      int index=0;
      Collection<OWLIndividual> fillers=entry.getValue();
      if (fillers.size() <= number) {
        continue;
      }
      for (      OWLIndividual ind : fillers) {
        if (nrOfFillers > number) {
          returnSet.remove(entry.getKey());
          break;
        }
        if (fillers.size() - index + nrOfFillers <= number) {
          break;
        }
        if (targetSet.contains(ind)) {
          nrOfFillers++;
        }
        index++;
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLObjectHasValue) {
    OWLObjectPropertyExpression property=((OWLObjectHasValue)description).getProperty();
    OWLIndividual value=((OWLObjectHasValue)description).getFiller();
    Map<OWLIndividual,? extends Collection<OWLIndividual>> mapping=property.isAnonymous() ? Multimaps.invertFrom(MapUtils.createSortedMultiMap(opPos.get(property.getNamedProperty())),TreeMultimap.create()).asMap() : opPos.get(property.getNamedProperty());
    return mapping.entrySet().stream().filter(e -> e.getValue().contains(value)).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
  }
 else   if (description instanceof OWLDataSomeValuesFrom) {
    OWLDataPropertyExpression property=((OWLDataSomeValuesFrom)description).getProperty();
    OWLDataRange filler=((OWLDataSomeValuesFrom)description).getFiller();
    if (filler.isDatatype()) {
      return new TreeSet<>(dpPos.get(property).keySet());
    }
 else     if (filler instanceof OWLDataIntersectionOf) {
      return ((OWLDataIntersectionOf)filler).getOperands().stream().map(dr -> getIndividuals(df.getOWLDataSomeValuesFrom(property,dr))).reduce((s1,s2) -> {
        s1.retainAll(s2);
        return s1;
      }
).orElse(new TreeSet<>());
    }
 else     if (filler instanceof OWLDataUnionOf) {
      return ((OWLDataUnionOf)filler).getOperands().stream().map(dr -> getIndividuals(df.getOWLDataSomeValuesFrom(property,dr))).reduce((s1,s2) -> {
        s1.addAll(s2);
        return s1;
      }
).orElse(new TreeSet<>());
    }
 else     if (filler instanceof OWLDataComplementOf) {
      return new TreeSet<>(Sets.difference(individuals,getIndividualsImpl(df.getOWLDataSomeValuesFrom(property,((OWLDataComplementOf)filler).getDataRange()))));
    }
 else     if (filler instanceof OWLDatatypeRestriction) {
      OWLDatatype datatype=((OWLDatatypeRestriction)filler).getDatatype();
      Set<OWLFacetRestriction> facetRestrictions=((OWLDatatypeRestriction)filler).getFacetRestrictions();
      if (OWLAPIUtils.floatDatatypes.contains(datatype)) {
        double min=facetRestrictions.stream().filter(fr -> fr.getFacet() == OWLFacet.MIN_INCLUSIVE).map(fr -> fr.getFacetValue().isDouble() ? fr.getFacetValue().parseDouble() : (double)fr.getFacetValue().parseFloat()).findAny().orElse(-Double.MAX_VALUE);
        double max=facetRestrictions.stream().filter(fr -> fr.getFacet() == OWLFacet.MAX_INCLUSIVE).map(fr -> fr.getFacetValue().isDouble() ? fr.getFacetValue().parseDouble() : (double)fr.getFacetValue().parseFloat()).findAny().orElse(Double.MAX_VALUE);
        return dd.getOrDefault(property,new HashMap<>()).entrySet().stream().filter(e -> {
          SortedSet<Double> values=e.getValue();
          if (values.last() < min || values.first() > max) {
            return false;
          }
          return values.stream().anyMatch(val -> val >= min && val <= max);
        }
).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
      }
 else       if (OWLAPIUtils.intDatatypes.contains(datatype)) {
        int min=facetRestrictions.stream().filter(fr -> fr.getFacet() == OWLFacet.MIN_INCLUSIVE).map(fr -> fr.getFacetValue().parseInteger()).findAny().orElse(-Integer.MAX_VALUE);
        int max=facetRestrictions.stream().filter(fr -> fr.getFacet() == OWLFacet.MAX_INCLUSIVE).map(fr -> fr.getFacetValue().parseInteger()).findAny().orElse(Integer.MAX_VALUE);
        return id.getOrDefault(property,new HashMap<>()).entrySet().stream().filter(e -> {
          SortedSet<Integer> values=e.getValue();
          if (values.last() < min || values.first() > max) {
            return false;
          }
          return values.stream().anyMatch(val -> val >= min && val <= max);
        }
).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
      }
 else       if (OWLAPIUtils.dtDatatypes.contains(datatype)) {
        OWLLiteral min=facetRestrictions.stream().filter(fr -> fr.getFacet() == OWLFacet.MIN_INCLUSIVE).map(OWLFacetRestriction::getFacetValue).findAny().orElse(null);
        OWLLiteral max=facetRestrictions.stream().filter(fr -> fr.getFacet() == OWLFacet.MAX_INCLUSIVE).map(OWLFacetRestriction::getFacetValue).findAny().orElse(null);
        return dpPos.getOrDefault(property,new HashMap<>()).entrySet().stream().filter(e -> e.getValue().stream().anyMatch(val -> OWLAPIUtils.inRange(val,min,max))).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
      }
    }
 else     if (filler.getDataRangeType() == DataRangeType.DATA_ONE_OF) {
      OWLDataOneOf dataOneOf=(OWLDataOneOf)filler;
      Set<OWLLiteral> values=dataOneOf.getValues();
      return dpPos.getOrDefault(property,new HashMap<>()).entrySet().stream().filter(e -> !Sets.intersection(e.getValue(),values).isEmpty()).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
    }
  }
 else   if (description instanceof OWLDataHasValue) {
    OWLDataPropertyExpression property=((OWLDataHasValue)description).getProperty();
    OWLLiteral value=((OWLDataHasValue)description).getFiller();
    return dpPos.getOrDefault(property,new HashMap<>()).entrySet().stream().filter(e -> e.getValue().contains(value)).map(Entry::getKey).collect(Collectors.toCollection(TreeSet::new));
  }
 else   if (description instanceof OWLObjectOneOf) {
    return new TreeSet(((OWLObjectOneOf)description).getIndividuals());
  }
  throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
}"
9327,"public static void main(String[] args){
  SparqlEndpoint endpoint=SparqlEndpoint.getEndpointDBpediaLiveAKSW();
  Set<String> ignoredProperties=Sets.newHashSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ConciseBoundedDescriptionGenerator cbdGen=new ConciseBoundedDescriptionGeneratorImpl(endpoint);
  cbdGen.setIgnoredProperties(ignoredProperties);
  cbdGen.setAllowedPropertyNamespaces(Sets.newHashSet(""String_Node_Str""));
  cbdGen.setAllowedClassNamespaces(Sets.newHashSet(""String_Node_Str""));
  cbdGen.setAllowedObjectNamespaces(Sets.newHashSet(""String_Node_Str""));
  cbdGen=new CachingConciseBoundedDescriptionGenerator(cbdGen);
  Model cbd=cbdGen.getConciseBoundedDescription(""String_Node_Str"",2);
  System.out.println(cbd.size());
}","public static void main(String[] args){
  SparqlEndpoint endpoint=SparqlEndpoint.getEndpointDBpediaLiveAKSW();
  Set<String> ignoredProperties=Sets.newHashSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ConciseBoundedDescriptionGenerator cbdGen=new ConciseBoundedDescriptionGeneratorImpl(endpoint);
  cbdGen=new CachingConciseBoundedDescriptionGenerator(cbdGen);
  Model cbd=cbdGen.getConciseBoundedDescription(""String_Node_Str"",2);
  System.out.println(cbd.size());
}"
9328,"private String createObjectFilter(Var predicateVar,Var targetVar){
  String filter=""String_Node_Str"";
  if (!allowedObjectNamespaces.isEmpty() || !allowedClassNamespaces.isEmpty()) {
    filter+=""String_Node_Str"" + targetVar + ""String_Node_Str"";
  }
  if (!allowedObjectNamespaces.isEmpty()) {
    filter+=""String_Node_Str"" + predicateVar + ""String_Node_Str""+ FmtUtils.stringForResource(RDF.type)+ ""String_Node_Str"";
    filter+=allowedObjectNamespaces.stream().map(ns -> ""String_Node_Str"" + targetVar + ""String_Node_Str""+ ns+ ""String_Node_Str"").collect(Collectors.joining(""String_Node_Str""));
    filter+=""String_Node_Str"";
  }
 else {
    filter+=predicateVar + ""String_Node_Str"" + FmtUtils.stringForResource(RDF.type)+ ""String_Node_Str"";
  }
  if (!allowedClassNamespaces.isEmpty()) {
    filter+=""String_Node_Str"" + predicateVar + ""String_Node_Str""+ FmtUtils.stringForResource(RDF.type)+ ""String_Node_Str"";
    filter+=allowedClassNamespaces.stream().map(ns -> ""String_Node_Str"" + targetVar + ""String_Node_Str""+ ns+ ""String_Node_Str"").collect(Collectors.joining(""String_Node_Str""));
    filter+=""String_Node_Str"";
  }
 else {
    filter+=""String_Node_Str"" + predicateVar + ""String_Node_Str""+ FmtUtils.stringForResource(RDF.type);
  }
  if (!allowedObjectNamespaces.isEmpty() || !allowedClassNamespaces.isEmpty()) {
    filter+=""String_Node_Str"";
  }
  return filter;
}","private String createObjectFilter(Var predicateVar,Var targetVar){
  String filter=""String_Node_Str"";
  if (!allowedObjectNamespaces.isEmpty() || !allowedClassNamespaces.isEmpty()) {
    filter+=""String_Node_Str"" + targetVar + ""String_Node_Str"";
  }
  if (!allowedObjectNamespaces.isEmpty()) {
    filter+=""String_Node_Str"" + predicateVar + ""String_Node_Str""+ FmtUtils.stringForResource(RDF.type)+ ""String_Node_Str"";
    filter+=allowedObjectNamespaces.stream().map(ns -> ""String_Node_Str"" + targetVar + ""String_Node_Str""+ ns+ ""String_Node_Str"").collect(Collectors.joining(""String_Node_Str""));
    filter+=""String_Node_Str"";
  }
 else   if (!allowedClassNamespaces.isEmpty()) {
    filter+=predicateVar + ""String_Node_Str"" + FmtUtils.stringForResource(RDF.type)+ ""String_Node_Str"";
  }
  if (!allowedClassNamespaces.isEmpty()) {
    filter+=""String_Node_Str"" + predicateVar + ""String_Node_Str""+ FmtUtils.stringForResource(RDF.type)+ ""String_Node_Str"";
    filter+=allowedClassNamespaces.stream().map(ns -> ""String_Node_Str"" + targetVar + ""String_Node_Str""+ ns+ ""String_Node_Str"").collect(Collectors.joining(""String_Node_Str""));
    filter+=""String_Node_Str"";
  }
 else   if (!allowedObjectNamespaces.isEmpty()) {
    filter+=""String_Node_Str"" + predicateVar + ""String_Node_Str""+ FmtUtils.stringForResource(RDF.type);
  }
  if (!allowedObjectNamespaces.isEmpty() || !allowedClassNamespaces.isEmpty()) {
    filter+=""String_Node_Str"";
  }
  return filter;
}"
9329,"public OWL2SPARULConverter(OWLOntology ontology,boolean useStrongTyping){
  this(ontology.getOWLOntologyManager(),ontology,useStrongTyping,new OWLAnonymousIndividualsWithMultipleOccurrences());
}","public OWL2SPARULConverter(OWLOntology ontology,boolean useStrongTyping){
  this(ontology.getOWLOntologyManager(),ontology,useStrongTyping,new OWLAnonymousIndividualsWithMultipleOccurrences(),new AlwaysOutputId(),new AtomicInteger());
}"
9330,"@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<>();
  atomicRoles=new TreeSet<>();
  datatypeProperties=new TreeSet<>();
  individuals=new TreeSet<>();
  df=new OWLDataFactoryImpl();
  manager=OWLManager.createOWLOntologyManager();
  prefixes=new TreeMap<>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLOntologyKnowledgeSource) {
      ontology=((OWLOntologyKnowledgeSource)source).createOWLOntology(manager);
      owlAPIOntologies.add(ontology);
    }
 else {
      throw new ComponentInitException(""String_Node_Str"" + source.getClass().getName());
    }
    atomicConcepts.addAll(ontology.getClassesInSignature(Imports.INCLUDED));
    atomicRoles.addAll(ontology.getObjectPropertiesInSignature(Imports.INCLUDED));
    datatypeProperties.addAll(ontology.getDataPropertiesInSignature(Imports.INCLUDED));
    individuals.addAll(ontology.getIndividualsInSignature(Imports.INCLUDED));
    OWLDocumentFormat format=manager.getOntologyFormat(ontology);
    if (format != null && format.isPrefixOWLOntologyFormat()) {
      prefixes.putAll(format.asPrefixOWLOntologyFormat().getPrefixName2PrefixMap());
      baseURI=format.asPrefixOWLOntologyFormat().getDefaultPrefix();
      prefixes.remove(""String_Node_Str"");
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<>();
    for (    OWLOntology ont : owlAPIOntologies) {
      for (      OWLImportsDeclaration importDeclaration : ont.getImportsDeclarations()) {
        addImports.add(new AddImport(ontology,importDeclaration));
      }
    }
    manager.applyChanges(addImports);
    for (    OWLOntology toRemove : owlAPIOntologies) {
      manager.removeOntology(toRemove);
    }
    owlAPIOntologies=new HashSet<>();
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  if (reasoner == null) {
    initBaseReasoner();
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS,InferenceType.OBJECT_PROPERTY_HIERARCHY,InferenceType.DATA_PROPERTY_HIERARCHY,InferenceType.OBJECT_PROPERTY_ASSERTIONS,InferenceType.SAME_INDIVIDUAL);
  }
 else {
    PelletExplanation expGen=new PelletExplanation(ontology);
    System.out.println(expGen.getInconsistencyExplanation());
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY);
    throw new ComponentInitException(""String_Node_Str"");
  }
  df=manager.getOWLDataFactory();
  initDatatypes();
  Iterator<OWLClass> it=atomicConcepts.iterator();
  while (it.hasNext()) {
    OWLClass cls=it.next();
    if (cls.getIRI().isReservedVocabulary()) {
      it.remove();
    }
  }
  minimizer=new OWLClassExpressionMinimizer(df,this);
  logger.info(""String_Node_Str"" + reasoner.getReasonerName() + ""String_Node_Str""+ reasoner.getClass().getName()+ ""String_Node_Str"");
}","@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<>();
  atomicRoles=new TreeSet<>();
  datatypeProperties=new TreeSet<>();
  individuals=new TreeSet<>();
  df=new OWLDataFactoryImpl();
  manager=OWLManager.createOWLOntologyManager();
  prefixes=new TreeMap<>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLOntologyKnowledgeSource) {
      ontology=((OWLOntologyKnowledgeSource)source).createOWLOntology(manager);
      owlAPIOntologies.add(ontology);
    }
 else {
      throw new ComponentInitException(""String_Node_Str"" + source.getClass().getName());
    }
    atomicConcepts.addAll(ontology.getClassesInSignature(Imports.INCLUDED));
    atomicRoles.addAll(ontology.getObjectPropertiesInSignature(Imports.INCLUDED));
    datatypeProperties.addAll(ontology.getDataPropertiesInSignature(Imports.INCLUDED));
    individuals.addAll(ontology.getIndividualsInSignature(Imports.INCLUDED));
    OWLDocumentFormat format=manager.getOntologyFormat(ontology);
    if (format != null && format.isPrefixOWLOntologyFormat()) {
      prefixes.putAll(format.asPrefixOWLOntologyFormat().getPrefixName2PrefixMap());
      baseURI=format.asPrefixOWLOntologyFormat().getDefaultPrefix();
      prefixes.remove(""String_Node_Str"");
    }
  }
  manager.getOntologies().stream().map(OWLOntology::getOntologyID).forEach(System.out::println);
  try {
    ontology=manager.createOntology(IRI.generateDocumentIRI(),new HashSet<>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<>();
    for (    OWLOntology ont : owlAPIOntologies) {
      for (      OWLImportsDeclaration importDeclaration : ont.getImportsDeclarations()) {
        addImports.add(new AddImport(ontology,importDeclaration));
      }
    }
    manager.applyChanges(addImports);
    for (    OWLOntology toRemove : owlAPIOntologies) {
      manager.removeOntology(toRemove);
    }
    owlAPIOntologies=new HashSet<>();
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  if (reasoner == null) {
    initBaseReasoner();
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS,InferenceType.OBJECT_PROPERTY_HIERARCHY,InferenceType.DATA_PROPERTY_HIERARCHY,InferenceType.OBJECT_PROPERTY_ASSERTIONS,InferenceType.SAME_INDIVIDUAL);
  }
 else {
    PelletExplanation expGen=new PelletExplanation(ontology);
    System.out.println(expGen.getInconsistencyExplanation());
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY);
    throw new ComponentInitException(""String_Node_Str"");
  }
  df=manager.getOWLDataFactory();
  initDatatypes();
  Iterator<OWLClass> it=atomicConcepts.iterator();
  while (it.hasNext()) {
    OWLClass cls=it.next();
    if (cls.getIRI().isReservedVocabulary()) {
      it.remove();
    }
  }
  minimizer=new OWLClassExpressionMinimizer(df,this);
  logger.info(""String_Node_Str"" + reasoner.getReasonerName() + ""String_Node_Str""+ reasoner.getClass().getName()+ ""String_Node_Str"");
}"
9331,"@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<>();
  atomicRoles=new TreeSet<>();
  datatypeProperties=new TreeSet<>();
  individuals=new TreeSet<>();
  df=new OWLDataFactoryImpl();
  manager=OWLManager.createOWLOntologyManager();
  prefixes=new TreeMap<>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLOntologyKnowledgeSource) {
      ontology=((OWLOntologyKnowledgeSource)source).createOWLOntology(manager);
      owlAPIOntologies.add(ontology);
    }
 else {
      throw new ComponentInitException(""String_Node_Str"" + source.getClass().getName());
    }
    atomicConcepts.addAll(ontology.getClassesInSignature(Imports.INCLUDED));
    atomicRoles.addAll(ontology.getObjectPropertiesInSignature(Imports.INCLUDED));
    datatypeProperties.addAll(ontology.getDataPropertiesInSignature(Imports.INCLUDED));
    individuals.addAll(ontology.getIndividualsInSignature(Imports.INCLUDED));
    OWLDocumentFormat format=manager.getOntologyFormat(ontology);
    if (format != null && format.isPrefixOWLOntologyFormat()) {
      prefixes.putAll(format.asPrefixOWLOntologyFormat().getPrefixName2PrefixMap());
      baseURI=format.asPrefixOWLOntologyFormat().getDefaultPrefix();
      prefixes.remove(""String_Node_Str"");
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<>();
    for (    OWLOntology ont : owlAPIOntologies) {
      for (      OWLImportsDeclaration importDeclaration : ont.getImportsDeclarations()) {
        addImports.add(new AddImport(ontology,importDeclaration));
      }
    }
    manager.applyChanges(addImports);
    for (    OWLOntology toRemove : owlAPIOntologies) {
      manager.removeOntology(toRemove);
    }
    owlAPIOntologies=null;
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  if (reasoner == null) {
    initBaseReasoner();
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS,InferenceType.OBJECT_PROPERTY_HIERARCHY,InferenceType.DATA_PROPERTY_HIERARCHY,InferenceType.OBJECT_PROPERTY_ASSERTIONS,InferenceType.SAME_INDIVIDUAL);
  }
 else {
    PelletExplanation expGen=new PelletExplanation(ontology);
    System.out.println(expGen.getInconsistencyExplanation());
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY);
    throw new ComponentInitException(""String_Node_Str"");
  }
  df=manager.getOWLDataFactory();
  initDatatypes();
  Iterator<OWLClass> it=atomicConcepts.iterator();
  while (it.hasNext()) {
    OWLClass cls=it.next();
    if (cls.getIRI().isReservedVocabulary()) {
      it.remove();
    }
  }
  minimizer=new OWLClassExpressionMinimizer(df,this);
  logger.info(""String_Node_Str"" + reasoner.getReasonerName() + ""String_Node_Str""+ reasoner.getClass().getName()+ ""String_Node_Str"");
}","@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<>();
  atomicRoles=new TreeSet<>();
  datatypeProperties=new TreeSet<>();
  individuals=new TreeSet<>();
  df=new OWLDataFactoryImpl();
  manager=OWLManager.createOWLOntologyManager();
  prefixes=new TreeMap<>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLOntologyKnowledgeSource) {
      ontology=((OWLOntologyKnowledgeSource)source).createOWLOntology(manager);
      owlAPIOntologies.add(ontology);
    }
 else {
      throw new ComponentInitException(""String_Node_Str"" + source.getClass().getName());
    }
    atomicConcepts.addAll(ontology.getClassesInSignature(Imports.INCLUDED));
    atomicRoles.addAll(ontology.getObjectPropertiesInSignature(Imports.INCLUDED));
    datatypeProperties.addAll(ontology.getDataPropertiesInSignature(Imports.INCLUDED));
    individuals.addAll(ontology.getIndividualsInSignature(Imports.INCLUDED));
    OWLDocumentFormat format=manager.getOntologyFormat(ontology);
    if (format != null && format.isPrefixOWLOntologyFormat()) {
      prefixes.putAll(format.asPrefixOWLOntologyFormat().getPrefixName2PrefixMap());
      baseURI=format.asPrefixOWLOntologyFormat().getDefaultPrefix();
      prefixes.remove(""String_Node_Str"");
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<>();
    for (    OWLOntology ont : owlAPIOntologies) {
      for (      OWLImportsDeclaration importDeclaration : ont.getImportsDeclarations()) {
        addImports.add(new AddImport(ontology,importDeclaration));
      }
    }
    manager.applyChanges(addImports);
    for (    OWLOntology toRemove : owlAPIOntologies) {
      manager.removeOntology(toRemove);
    }
    owlAPIOntologies=new HashSet<>();
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  if (reasoner == null) {
    initBaseReasoner();
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS,InferenceType.OBJECT_PROPERTY_HIERARCHY,InferenceType.DATA_PROPERTY_HIERARCHY,InferenceType.OBJECT_PROPERTY_ASSERTIONS,InferenceType.SAME_INDIVIDUAL);
  }
 else {
    PelletExplanation expGen=new PelletExplanation(ontology);
    System.out.println(expGen.getInconsistencyExplanation());
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY);
    throw new ComponentInitException(""String_Node_Str"");
  }
  df=manager.getOWLDataFactory();
  initDatatypes();
  Iterator<OWLClass> it=atomicConcepts.iterator();
  while (it.hasNext()) {
    OWLClass cls=it.next();
    if (cls.getIRI().isReservedVocabulary()) {
      it.remove();
    }
  }
  minimizer=new OWLClassExpressionMinimizer(df,this);
  logger.info(""String_Node_Str"" + reasoner.getReasonerName() + ""String_Node_Str""+ reasoner.getClass().getName()+ ""String_Node_Str"");
}"
9332,"@Test public void invertedOperatorTest() throws ParseException, ComponentInitException {
  AbstractReasonerComponent reasoner=TestOntologies.getTestOntology(TestOntology.RHO1);
  reasoner.init();
  RhoDRDown op=new RhoDRDown();
  op.setReasoner(reasoner);
  op.setSubHierarchy(reasoner.getClassHierarchy());
  op.setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  op.setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  op.setDropDisjuncts(true);
  op.init();
  LengthLimitedRefinementOperator operator=new OperatorInverter(op);
  OWLClassExpression concept=KBParser.parseConcept(""String_Node_Str"");
  Set<OWLClassExpression> refinements=operator.refine(concept,6);
  for (  OWLClassExpression refinement : refinements) {
    System.out.println(refinement);
  }
  assertTrue(refinements.size() == 4);
}","@Test public void invertedOperatorTest() throws ParseException, ComponentInitException {
  AbstractReasonerComponent reasoner=TestOntologies.getTestOntology(TestOntology.RHO1);
  RhoDRDown op=new RhoDRDown();
  op.setReasoner(reasoner);
  op.setSubHierarchy(reasoner.getClassHierarchy());
  op.setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  op.setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  op.setDropDisjuncts(true);
  op.init();
  LengthLimitedRefinementOperator operator=new OperatorInverter(op);
  OWLClassExpression concept=KBParser.parseConcept(""String_Node_Str"");
  Set<OWLClassExpression> refinements=operator.refine(concept,6);
  for (  OWLClassExpression refinement : refinements) {
    System.out.println(refinement);
  }
  assertTrue(refinements.size() == 4);
}"
9333,"@Test public void rhoDRDownTest2() throws ParseException, ComponentInitException {
  StringRenderer.setRenderer(Rendering.DL_SYNTAX);
  AbstractReasonerComponent reasoner=TestOntologies.getTestOntology(TestOntology.EPC_OE);
  reasoner.init();
  baseURI=reasoner.getBaseURI();
  RhoDRDown op=new RhoDRDown();
  op.setReasoner(reasoner);
  op.setSubHierarchy(reasoner.getClassHierarchy());
  op.setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  op.setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  op.init();
  OWLClassExpression concept=KBParser.parseConcept(""String_Node_Str"");
  Set<OWLClassExpression> results=op.refine(concept,10);
  for (  OWLClassExpression result : results) {
    System.out.println(result);
  }
  int desiredResultSize=107;
  if (results.size() != desiredResultSize) {
    System.out.println(results.size() + ""String_Node_Str"" + desiredResultSize+ ""String_Node_Str"");
  }
  assertTrue(results.size() == desiredResultSize);
}","@Test public void rhoDRDownTest2() throws ParseException, ComponentInitException {
  StringRenderer.setRenderer(Rendering.DL_SYNTAX);
  AbstractReasonerComponent reasoner=TestOntologies.getTestOntology(TestOntology.EPC_OE);
  baseURI=reasoner.getBaseURI();
  RhoDRDown op=new RhoDRDown();
  op.setReasoner(reasoner);
  op.setSubHierarchy(reasoner.getClassHierarchy());
  op.setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  op.setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  op.init();
  OWLClassExpression concept=KBParser.parseConcept(""String_Node_Str"");
  Set<OWLClassExpression> results=op.refine(concept,10);
  for (  OWLClassExpression result : results) {
    System.out.println(result);
  }
  int desiredResultSize=107;
  if (results.size() != desiredResultSize) {
    System.out.println(results.size() + ""String_Node_Str"" + desiredResultSize+ ""String_Node_Str"");
  }
  assertTrue(results.size() == desiredResultSize);
}"
9334,"@Test public void rhoDRDownTest5() throws ParseException, LearningProblemUnsupportedException, ComponentInitException {
  AbstractReasonerComponent reasoner=TestOntologies.getTestOntology(TestOntology.SWORE);
  reasoner.init();
  RhoDRDown op=new RhoDRDown();
  op.setReasoner(reasoner);
  op.setSubHierarchy(reasoner.getClassHierarchy());
  op.setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  op.setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  op.init();
  OWLClassExpression concept=KBParser.parseConcept(""String_Node_Str"");
  System.out.println(concept);
  Set<OWLClassExpression> refinements=op.refine(concept,7);
  for (  OWLClassExpression refinement : refinements) {
    System.out.println(refinement);
  }
}","@Test public void rhoDRDownTest5() throws ParseException, LearningProblemUnsupportedException, ComponentInitException {
  AbstractReasonerComponent reasoner=TestOntologies.getTestOntology(TestOntology.SWORE);
  RhoDRDown op=new RhoDRDown();
  op.setReasoner(reasoner);
  op.setSubHierarchy(reasoner.getClassHierarchy());
  op.setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  op.setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  op.init();
  OWLClassExpression concept=KBParser.parseConcept(""String_Node_Str"");
  System.out.println(concept);
  Set<OWLClassExpression> refinements=op.refine(concept,7);
  for (  OWLClassExpression refinement : refinements) {
    System.out.println(refinement);
  }
}"
9335,"private List<EvaluatedAxiom<OWLAxiom>> applyCELOE(SparqlEndpointKS ks,OWLClass nc,boolean equivalence,boolean reuseKnowledgeSource) throws ComponentInitException {
  System.out.print(""String_Node_Str"");
  long startTime=System.currentTimeMillis();
  SortedSet<OWLIndividual> posExamples=reasoner.getIndividuals(nc,maxNrOfPositiveExamples);
  long runTime=System.currentTimeMillis() - startTime;
  if (posExamples.isEmpty()) {
    System.out.println(""String_Node_Str"" + nc.toString() + ""String_Node_Str"");
    return Collections.emptyList();
  }
  SortedSet<String> posExStr=Helper.getStringSet(posExamples);
  System.out.println(""String_Node_Str"" + posExStr.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
  System.out.print(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  AutomaticNegativeExampleFinderSPARQL2 finder=new AutomaticNegativeExampleFinderSPARQL2(ks.getEndpoint(),reasoner);
  SortedSet<OWLIndividual> negExamples=finder.getNegativeExamples(nc,posExamples,maxNrOfNegativeExamples);
  SortedSetTuple<OWLIndividual> examples=new SortedSetTuple<>(posExamples,negExamples);
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + negExamples.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
  AbstractReasonerComponent rc;
  KnowledgeSource ksFragment;
  if (reuseKnowledgeSource) {
    ksFragment=ksCached;
    rc=rcCached;
  }
 else {
    System.out.print(""String_Node_Str"");
    startTime=System.currentTimeMillis();
    Model model;
    if (ks.isRemote()) {
      model=getFragment(ks,Sets.union(posExamples,negExamples));
    }
 else {
      model=((LocalModelBasedSparqlEndpointKS)ks).getModel();
    }
    filter(model);
    filterByNamespaces(model);
    OWLEntityTypeAdder.addEntityTypes(model);
    runTime=System.currentTimeMillis() - startTime;
    System.out.println(""String_Node_Str"" + model.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
    OWLOntology ontology=asOWLOntology(model);
    if (reasoner.getClassHierarchy() != null) {
      ontology.getOWLOntologyManager().addAxioms(ontology,reasoner.getClassHierarchy().toOWLAxioms());
    }
    ksFragment=new OWLAPIOntology(ontology);
    try {
      OWLManager.createOWLOntologyManager().saveOntology(ontology,new TurtleDocumentFormat(),new FileOutputStream(""String_Node_Str""));
    }
 catch (    OWLOntologyStorageException|FileNotFoundException e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
    rc=new ClosedWorldReasoner(ksFragment);
    rc.init();
    System.out.println(""String_Node_Str"");
    ksCached=ksFragment;
    rcCached=rc;
  }
  ClassLearningProblem lp=new ClassLearningProblem(rc);
  lp.setClassToDescribe(nc);
  lp.setEquivalence(equivalence);
  lp.setAccuracyMethod(new AccMethodFMeasure(true));
  lp.setMaxExecutionTimeInSeconds(10);
  lp.init();
  CELOE la=new CELOE(lp,rc);
  la.setMaxExecutionTimeInSeconds(10);
  la.setNoisePercentage(25);
  la.setMaxNrOfResults(100);
  la.init();
  startTime=System.currentTimeMillis();
  System.out.print(""String_Node_Str"" + (equivalence ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  la.start();
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + runTime + ""String_Node_Str"");
  List<? extends EvaluatedDescription<? extends Score>> learnedDescriptions=la.getCurrentlyBestEvaluatedDescriptions(threshold);
  List<EvaluatedAxiom<OWLAxiom>> learnedAxioms=new LinkedList<>();
  for (  EvaluatedDescription<? extends Score> learnedDescription : learnedDescriptions) {
    OWLAxiom axiom;
    if (equivalence) {
      axiom=dataFactory.getOWLEquivalentClassesAxiom(nc,learnedDescription.getDescription());
    }
 else {
      axiom=dataFactory.getOWLSubClassOfAxiom(nc,learnedDescription.getDescription());
    }
    Score score=lp.computeScore(learnedDescription.getDescription());
    learnedAxioms.add(new EvaluatedAxiom<>(axiom,new AxiomScore(score.getAccuracy())));
  }
  System.out.println(prettyPrint(learnedAxioms));
  learnedEvaluatedAxioms.addAll(learnedAxioms);
  algorithmRuns.add(new AlgorithmRun(CELOE.class,learnedAxioms,ConfigHelper.getConfigOptionValues(la)));
  return learnedAxioms;
}","private List<EvaluatedAxiom<OWLAxiom>> applyCELOE(SparqlEndpointKS ks,OWLClass nc,boolean equivalence,boolean reuseKnowledgeSource) throws ComponentInitException {
  System.out.print(""String_Node_Str"");
  long startTime=System.currentTimeMillis();
  SortedSet<OWLIndividual> posExamples=reasoner.getIndividuals(nc,maxNrOfPositiveExamples);
  long runTime=System.currentTimeMillis() - startTime;
  if (posExamples.isEmpty()) {
    System.out.println(""String_Node_Str"" + nc.toString() + ""String_Node_Str"");
    return Collections.emptyList();
  }
  SortedSet<String> posExStr=Helper.getStringSet(posExamples);
  System.out.println(""String_Node_Str"" + posExStr.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
  System.out.print(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  AutomaticNegativeExampleFinderSPARQL2 finder=new AutomaticNegativeExampleFinderSPARQL2(reasoner);
  SortedSet<OWLIndividual> negExamples=finder.getNegativeExamples(nc,posExamples,maxNrOfNegativeExamples);
  SortedSetTuple<OWLIndividual> examples=new SortedSetTuple<>(posExamples,negExamples);
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + negExamples.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
  AbstractReasonerComponent rc;
  KnowledgeSource ksFragment;
  if (reuseKnowledgeSource) {
    ksFragment=ksCached;
    rc=rcCached;
  }
 else {
    System.out.print(""String_Node_Str"");
    startTime=System.currentTimeMillis();
    Model model;
    if (ks.isRemote()) {
      model=getFragment(ks,Sets.union(posExamples,negExamples));
    }
 else {
      model=((LocalModelBasedSparqlEndpointKS)ks).getModel();
    }
    filter(model);
    filterByNamespaces(model);
    OWLEntityTypeAdder.addEntityTypes(model);
    runTime=System.currentTimeMillis() - startTime;
    System.out.println(""String_Node_Str"" + model.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
    OWLOntology ontology=asOWLOntology(model);
    if (reasoner.getClassHierarchy() != null) {
      ontology.getOWLOntologyManager().addAxioms(ontology,reasoner.getClassHierarchy().toOWLAxioms());
    }
    ksFragment=new OWLAPIOntology(ontology);
    try {
      OWLManager.createOWLOntologyManager().saveOntology(ontology,new TurtleDocumentFormat(),new FileOutputStream(""String_Node_Str""));
    }
 catch (    OWLOntologyStorageException|FileNotFoundException e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
    rc=new ClosedWorldReasoner(ksFragment);
    rc.init();
    System.out.println(""String_Node_Str"");
    ksCached=ksFragment;
    rcCached=rc;
  }
  ClassLearningProblem lp=new ClassLearningProblem(rc);
  lp.setClassToDescribe(nc);
  lp.setEquivalence(equivalence);
  lp.setAccuracyMethod(new AccMethodFMeasure(true));
  lp.setMaxExecutionTimeInSeconds(10);
  lp.init();
  CELOE la=new CELOE(lp,rc);
  la.setMaxExecutionTimeInSeconds(10);
  la.setNoisePercentage(25);
  la.setMaxNrOfResults(100);
  la.init();
  startTime=System.currentTimeMillis();
  System.out.print(""String_Node_Str"" + (equivalence ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  la.start();
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + runTime + ""String_Node_Str"");
  List<? extends EvaluatedDescription<? extends Score>> learnedDescriptions=la.getCurrentlyBestEvaluatedDescriptions(threshold);
  List<EvaluatedAxiom<OWLAxiom>> learnedAxioms=new LinkedList<>();
  for (  EvaluatedDescription<? extends Score> learnedDescription : learnedDescriptions) {
    OWLAxiom axiom;
    if (equivalence) {
      axiom=dataFactory.getOWLEquivalentClassesAxiom(nc,learnedDescription.getDescription());
    }
 else {
      axiom=dataFactory.getOWLSubClassOfAxiom(nc,learnedDescription.getDescription());
    }
    Score score=lp.computeScore(learnedDescription.getDescription());
    learnedAxioms.add(new EvaluatedAxiom<>(axiom,new AxiomScore(score.getAccuracy())));
  }
  System.out.println(prettyPrint(learnedAxioms));
  learnedEvaluatedAxioms.addAll(learnedAxioms);
  algorithmRuns.add(new AlgorithmRun(CELOE.class,learnedAxioms,ConfigHelper.getConfigOptionValues(la)));
  return learnedAxioms;
}"
9336,"/** 
 * Sets the max. execution time of the whole algorithm. Note, this values should always be higher than the max. execution time to compute a partial solution.
 * @param maxExecutionTimeInSeconds the overall the max. execution time
 */
@Override public void setMaxExecutionTimeInSeconds(int maxExecutionTimeInSeconds){
  super.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
}","/** 
 * Sets the max. execution time of the whole algorithm. Note, this values should always be higher than the max. execution time to compute a partial solution.
 * @param maxExecutionTimeInSeconds the overall the max. execution time
 */
@Override public void setMaxExecutionTimeInSeconds(long maxExecutionTimeInSeconds){
  super.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
}"
9337,"@Override public void init() throws ComponentInitException {
  try {
    if (url == null) {
      Path path;
      if (fileName.startsWith(""String_Node_Str"")) {
        path=Paths.get(fileName);
      }
 else {
        path=Paths.get(baseDir,fileName);
      }
      URI uri=path.normalize().toUri();
      setUrl(uri.toURL().toString());
    }
    kb=KBParser.parseKBFile(new URL(getUrl()));
    logger.trace(""String_Node_Str"" + getUrl() + ""String_Node_Str"");
  }
 catch (  ParseException e) {
    throw new ComponentInitException(""String_Node_Str"" + getUrl() + ""String_Node_Str"",e);
  }
catch (  FileNotFoundException e) {
    throw new ComponentInitException(""String_Node_Str"" + getUrl() + ""String_Node_Str"",e);
  }
catch (  OWLOntologyCreationException e) {
    throw new ComponentInitException(""String_Node_Str"" + getUrl() + ""String_Node_Str"",e);
  }
catch (  MalformedURLException e) {
    throw new ComponentInitException(""String_Node_Str"" + getUrl() + ""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new ComponentInitException(""String_Node_Str"" + getUrl() + ""String_Node_Str"",e);
  }
}","@Override public void init() throws ComponentInitException {
  try {
    if (url == null) {
      Path path=Paths.get(fileName);
      if (!path.isAbsolute() && baseDir != null) {
        path=Paths.get(baseDir,fileName);
      }
      URI uri=path.normalize().toUri();
      setUrl(uri.toURL().toString());
    }
    kb=KBParser.parseKBFile(new URL(getUrl()));
    logger.trace(""String_Node_Str"" + getUrl() + ""String_Node_Str"");
  }
 catch (  ParseException e) {
    throw new ComponentInitException(""String_Node_Str"" + getUrl() + ""String_Node_Str"",e);
  }
catch (  FileNotFoundException e) {
    throw new ComponentInitException(""String_Node_Str"" + getUrl() + ""String_Node_Str"",e);
  }
catch (  OWLOntologyCreationException e) {
    throw new ComponentInitException(""String_Node_Str"" + getUrl() + ""String_Node_Str"",e);
  }
catch (  MalformedURLException e) {
    throw new ComponentInitException(""String_Node_Str"" + getUrl() + ""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new ComponentInitException(""String_Node_Str"" + getUrl() + ""String_Node_Str"",e);
  }
}"
9338,"@Override public void init() throws ComponentInitException {
  setReasoning(getReasoningString());
  if (sparql != null) {
    StringBuilder sb=new StringBuilder();
    sb.append(url.toString());
    sb.append(""String_Node_Str"").append(URLencodeUTF8.encode(sparql));
    sb.append(""String_Node_Str"");
    for (    String graph : defaultGraphURIs) {
      sb.append(""String_Node_Str"").append(URLencodeUTF8.encode(graph));
    }
    for (    String graph : namedGraphURIs) {
      sb.append(""String_Node_Str"").append(URLencodeUTF8.encode(graph));
    }
    logger.info(sb.toString());
    try {
      url=new URL(sb.toString());
    }
 catch (    MalformedURLException e) {
      throw new RuntimeException(e);
    }
  }
 else   if (url == null) {
    try {
      Path path;
      if (fileName.startsWith(""String_Node_Str"")) {
        path=Paths.get(fileName);
      }
 else {
        path=Paths.get(baseDir,fileName);
      }
      url=path.normalize().toUri().toURL();
    }
 catch (    MalformedURLException e) {
      throw new RuntimeException(e);
    }
  }
}","@Override public void init() throws ComponentInitException {
  setReasoning(getReasoningString());
  if (sparql != null) {
    StringBuilder sb=new StringBuilder();
    sb.append(url.toString());
    sb.append(""String_Node_Str"").append(URLencodeUTF8.encode(sparql));
    sb.append(""String_Node_Str"");
    for (    String graph : defaultGraphURIs) {
      sb.append(""String_Node_Str"").append(URLencodeUTF8.encode(graph));
    }
    for (    String graph : namedGraphURIs) {
      sb.append(""String_Node_Str"").append(URLencodeUTF8.encode(graph));
    }
    logger.info(sb.toString());
    try {
      url=new URL(sb.toString());
    }
 catch (    MalformedURLException e) {
      throw new RuntimeException(e);
    }
  }
 else   if (url == null) {
    try {
      Path path=Paths.get(fileName);
      if (!path.isAbsolute() && baseDir != null) {
        path=Paths.get(baseDir,fileName);
      }
      url=path.normalize().toUri().toURL();
    }
 catch (    MalformedURLException e) {
      throw new RuntimeException(e);
    }
  }
}"
9339,"private void loadOrDematerialize(){
  if (useMaterializationCaching) {
    File cacheDir=new File(""String_Node_Str"");
    cacheDir.mkdirs();
    HashFunction hf=Hashing.md5();
    Hasher hasher=hf.newHasher();
    hasher.putBoolean(materializeExistentialRestrictions);
    hasher.putBoolean(handlePunning);
    for (    OWLOntology ont : baseReasoner.getOWLAPIOntologies()) {
      hasher.putInt(ont.getLogicalAxioms().hashCode());
      hasher.putInt(ont.getAxioms().hashCode());
    }
    String filename=hasher.hash().toString() + ""String_Node_Str"";
    File cacheFile=new File(cacheDir,filename);
    if (cacheFile.exists()) {
      logger.debug(""String_Node_Str"");
      try (ObjectInputStream ois=new ObjectInputStream(new FileInputStream(cacheFile))){
        Materialization mat=(Materialization)ois.readObject();
        classInstancesPos=mat.classInstancesPos;
        classInstancesNeg=mat.classInstancesNeg;
        opPos=mat.opPos;
        dpPos=mat.dpPos;
        bdPos=mat.bdPos;
        bdNeg=mat.bdNeg;
        dd=mat.dd;
        id=mat.id;
        sd=mat.sd;
      }
 catch (      ClassNotFoundException|IOException e) {
        e.printStackTrace();
      }
      logger.debug(""String_Node_Str"");
    }
 else {
      materialize();
      Materialization mat=new Materialization();
      mat.classInstancesPos=classInstancesPos;
      mat.classInstancesNeg=classInstancesNeg;
      mat.opPos=opPos;
      mat.dpPos=dpPos;
      mat.bdPos=bdPos;
      mat.bdNeg=bdNeg;
      mat.dd=dd;
      mat.id=id;
      mat.sd=sd;
      try (ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(cacheFile))){
        oos.writeObject(mat);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
 else {
    materialize();
  }
}","private void loadOrDematerialize(){
  if (useMaterializationCaching) {
    File cacheDir=new File(""String_Node_Str"");
    cacheDir.mkdirs();
    HashFunction hf=Hashing.md5();
    Hasher hasher=hf.newHasher();
    hasher.putBoolean(materializeExistentialRestrictions);
    hasher.putBoolean(handlePunning);
    for (    OWLOntology ont : Collections.singleton(baseReasoner.getOntology())) {
      hasher.putInt(ont.getLogicalAxioms().hashCode());
      hasher.putInt(ont.getAxioms().hashCode());
    }
    String filename=hasher.hash().toString() + ""String_Node_Str"";
    File cacheFile=new File(cacheDir,filename);
    if (cacheFile.exists()) {
      logger.debug(""String_Node_Str"");
      try (ObjectInputStream ois=new ObjectInputStream(new FileInputStream(cacheFile))){
        Materialization mat=(Materialization)ois.readObject();
        classInstancesPos=mat.classInstancesPos;
        classInstancesNeg=mat.classInstancesNeg;
        opPos=mat.opPos;
        dpPos=mat.dpPos;
        bdPos=mat.bdPos;
        bdNeg=mat.bdNeg;
        dd=mat.dd;
        id=mat.id;
        sd=mat.sd;
      }
 catch (      ClassNotFoundException|IOException e) {
        e.printStackTrace();
      }
      logger.debug(""String_Node_Str"");
    }
 else {
      materialize();
      Materialization mat=new Materialization();
      mat.classInstancesPos=classInstancesPos;
      mat.classInstancesNeg=classInstancesNeg;
      mat.opPos=opPos;
      mat.dpPos=dpPos;
      mat.bdPos=bdPos;
      mat.bdNeg=bdNeg;
      mat.dd=dd;
      mat.id=id;
      mat.sd=sd;
      try (ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(cacheFile))){
        oos.writeObject(mat);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
 else {
    materialize();
  }
}"
9340,"@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<>();
  atomicRoles=new TreeSet<>();
  datatypeProperties=new TreeSet<>();
  individuals=new TreeSet<>();
  df=new OWLDataFactoryImpl();
  manager=OWLManager.createOWLOntologyManager();
  prefixes=new TreeMap<>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLOntologyKnowledgeSource) {
      ontology=((OWLOntologyKnowledgeSource)source).createOWLOntology(manager);
      owlAPIOntologies.add(ontology);
    }
 else {
      throw new ComponentInitException(""String_Node_Str"" + source.getClass().getName());
    }
    atomicConcepts.addAll(ontology.getClassesInSignature(Imports.INCLUDED));
    atomicRoles.addAll(ontology.getObjectPropertiesInSignature(Imports.INCLUDED));
    datatypeProperties.addAll(ontology.getDataPropertiesInSignature(Imports.INCLUDED));
    individuals.addAll(ontology.getIndividualsInSignature(Imports.INCLUDED));
    OWLDocumentFormat format=manager.getOntologyFormat(ontology);
    if (format != null && format.isPrefixOWLOntologyFormat()) {
      prefixes.putAll(format.asPrefixOWLOntologyFormat().getPrefixName2PrefixMap());
      baseURI=format.asPrefixOWLOntologyFormat().getDefaultPrefix();
      prefixes.remove(""String_Node_Str"");
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<>();
    for (    OWLOntology ont : owlAPIOntologies) {
      for (      OWLImportsDeclaration importDeclaration : ont.getImportsDeclarations()) {
        addImports.add(new AddImport(ontology,importDeclaration));
      }
    }
    manager.applyChanges(addImports);
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  if (reasoner == null) {
    initBaseReasoner();
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS,InferenceType.OBJECT_PROPERTY_HIERARCHY,InferenceType.DATA_PROPERTY_HIERARCHY,InferenceType.OBJECT_PROPERTY_ASSERTIONS,InferenceType.SAME_INDIVIDUAL);
  }
 else {
    PelletExplanation expGen=new PelletExplanation(ontology);
    System.out.println(expGen.getInconsistencyExplanation());
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY);
    throw new ComponentInitException(""String_Node_Str"");
  }
  df=manager.getOWLDataFactory();
  initDatatypes();
  Iterator<OWLClass> it=atomicConcepts.iterator();
  while (it.hasNext()) {
    OWLClass cls=it.next();
    if (cls.getIRI().isReservedVocabulary()) {
      it.remove();
    }
  }
  minimizer=new OWLClassExpressionMinimizer(df,this);
  logger.info(""String_Node_Str"" + reasoner.getReasonerName() + ""String_Node_Str""+ reasoner.getClass().getName()+ ""String_Node_Str"");
}","@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<>();
  atomicRoles=new TreeSet<>();
  datatypeProperties=new TreeSet<>();
  individuals=new TreeSet<>();
  df=new OWLDataFactoryImpl();
  manager=OWLManager.createOWLOntologyManager();
  prefixes=new TreeMap<>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLOntologyKnowledgeSource) {
      ontology=((OWLOntologyKnowledgeSource)source).createOWLOntology(manager);
      owlAPIOntologies.add(ontology);
    }
 else {
      throw new ComponentInitException(""String_Node_Str"" + source.getClass().getName());
    }
    atomicConcepts.addAll(ontology.getClassesInSignature(Imports.INCLUDED));
    atomicRoles.addAll(ontology.getObjectPropertiesInSignature(Imports.INCLUDED));
    datatypeProperties.addAll(ontology.getDataPropertiesInSignature(Imports.INCLUDED));
    individuals.addAll(ontology.getIndividualsInSignature(Imports.INCLUDED));
    OWLDocumentFormat format=manager.getOntologyFormat(ontology);
    if (format != null && format.isPrefixOWLOntologyFormat()) {
      prefixes.putAll(format.asPrefixOWLOntologyFormat().getPrefixName2PrefixMap());
      baseURI=format.asPrefixOWLOntologyFormat().getDefaultPrefix();
      prefixes.remove(""String_Node_Str"");
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<>();
    for (    OWLOntology ont : owlAPIOntologies) {
      for (      OWLImportsDeclaration importDeclaration : ont.getImportsDeclarations()) {
        addImports.add(new AddImport(ontology,importDeclaration));
      }
    }
    manager.applyChanges(addImports);
    for (    OWLOntology toRemove : owlAPIOntologies) {
      manager.removeOntology(toRemove);
    }
    owlAPIOntologies=null;
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  if (reasoner == null) {
    initBaseReasoner();
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS,InferenceType.OBJECT_PROPERTY_HIERARCHY,InferenceType.DATA_PROPERTY_HIERARCHY,InferenceType.OBJECT_PROPERTY_ASSERTIONS,InferenceType.SAME_INDIVIDUAL);
  }
 else {
    PelletExplanation expGen=new PelletExplanation(ontology);
    System.out.println(expGen.getInconsistencyExplanation());
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY);
    throw new ComponentInitException(""String_Node_Str"");
  }
  df=manager.getOWLDataFactory();
  initDatatypes();
  Iterator<OWLClass> it=atomicConcepts.iterator();
  while (it.hasNext()) {
    OWLClass cls=it.next();
    if (cls.getIRI().isReservedVocabulary()) {
      it.remove();
    }
  }
  minimizer=new OWLClassExpressionMinimizer(df,this);
  logger.info(""String_Node_Str"" + reasoner.getReasonerName() + ""String_Node_Str""+ reasoner.getClass().getName()+ ""String_Node_Str"");
}"
9341,"private void initDatatypes(){
  Set<OWLDataProperty> numericDataProperties=new HashSet<>();
  for (  OWLDataProperty dataProperty : datatypeProperties) {
    Collection<OWLDataRange> ranges=EntitySearcher.getRanges(dataProperty,owlAPIOntologies);
    Iterator<OWLDataRange> it=ranges.iterator();
    if (it.hasNext()) {
      OWLDataRange range=it.next();
      if (range.isDatatype()) {
        OWLDatatype datatype=range.asOWLDatatype();
        if (datatype.isBuiltIn()) {
          datatype2Properties.put(range.asOWLDatatype(),dataProperty);
          dataproperty2datatype.put(dataProperty,range.asOWLDatatype());
          if (OWLAPIUtils.isNumericDatatype(range.asOWLDatatype())) {
            numericDataProperties.add(dataProperty);
          }
        }
 else         if (OWLAPIUtils.dtDatatypes.contains(datatype)) {
          datatype2Properties.put(range.asOWLDatatype(),dataProperty);
          dataproperty2datatype.put(dataProperty,range.asOWLDatatype());
        }
 else {
        }
      }
 else {
      }
    }
 else {
    }
  }
}","private void initDatatypes(){
  Set<OWLDataProperty> numericDataProperties=new HashSet<>();
  for (  OWLDataProperty dataProperty : datatypeProperties) {
    Collection<OWLDataRange> ranges=EntitySearcher.getRanges(dataProperty,ontology);
    Iterator<OWLDataRange> it=ranges.iterator();
    if (it.hasNext()) {
      OWLDataRange range=it.next();
      if (range.isDatatype()) {
        OWLDatatype datatype=range.asOWLDatatype();
        if (datatype.isBuiltIn()) {
          datatype2Properties.put(range.asOWLDatatype(),dataProperty);
          dataproperty2datatype.put(dataProperty,range.asOWLDatatype());
          if (OWLAPIUtils.isNumericDatatype(range.asOWLDatatype())) {
            numericDataProperties.add(dataProperty);
          }
        }
 else         if (OWLAPIUtils.dtDatatypes.contains(datatype)) {
          datatype2Properties.put(range.asOWLDatatype(),dataProperty);
          dataproperty2datatype.put(dataProperty,range.asOWLDatatype());
        }
 else {
        }
      }
 else {
      }
    }
 else {
    }
  }
}"
9342,"@Override public void init() throws ComponentInitException {
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  if (dummyClass == null) {
    dummyClass=manager.getOWLDataFactory().getOWLClass(IRI.create(""String_Node_Str""));
  }
  logger.debug(""String_Node_Str"");
  Set<OWLIndividual> positiveIndividuals;
  Set<OWLIndividual> negativeIndividuals;
  if (learningProblem == null) {
    learningProblem=cela.getLearningProblem();
  }
  if (learningProblem instanceof PosNegLP) {
    positiveIndividuals=((PosNegLP)learningProblem).getPositiveExamples();
    negativeIndividuals=((PosNegLP)learningProblem).getNegativeExamples();
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    positiveIndividuals=((PosOnlyLP)learningProblem).getPositiveExamples();
    negativeIndividuals=Sets.difference(learningProblem.getReasoner().getIndividuals(),positiveIndividuals);
  }
 else   if (learningProblem instanceof ClassLearningProblem) {
    try {
      List<OWLIndividual> positiveIndividualsList=ReflectionHelper.getPrivateField(learningProblem,""String_Node_Str"");
      positiveIndividuals=new TreeSet<>(positiveIndividualsList);
      negativeIndividuals=new TreeSet<>((List<OWLIndividual>)ReflectionHelper.getPrivateField(learningProblem,""String_Node_Str""));
    }
 catch (    NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
      String msg=""String_Node_Str"" + ""String_Node_Str"" + e.getMessage();
      logger.error(msg);
      throw new ComponentInitException(msg);
    }
  }
 else {
    try {
      throw new LearningProblemUnsupportedException(((AbstractClassExpressionLearningProblem)learningProblem).getClass(),this.getClass());
    }
 catch (    LearningProblemUnsupportedException e) {
      throw new ComponentInitException(e.getMessage());
    }
  }
  logger.debug(""String_Node_Str"");
  Set<OWLAxiom> positiveExamples=OWLUtils.convertIndividualsToAssertionalAxioms(positiveIndividuals,dummyClass);
  Set<OWLAxiom> negativeExamples=OWLUtils.convertIndividualsToAssertionalAxioms(negativeIndividuals,dummyClass);
  edge.setPositiveExampleAxioms(positiveExamples);
  edge.setNegativeExampleAxioms(negativeExamples);
}","@Override public void init() throws ComponentInitException {
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  if (dummyClass == null) {
    dummyClass=manager.getOWLDataFactory().getOWLClass(IRI.create(UniFeIRI.DISPONTE + ""String_Node_Str""));
  }
  logger.debug(""String_Node_Str"");
  Set<OWLIndividual> positiveIndividuals;
  Set<OWLIndividual> negativeIndividuals;
  if (learningProblem == null) {
    learningProblem=cela.getLearningProblem();
  }
  if (learningProblem instanceof PosNegLP) {
    positiveIndividuals=((PosNegLP)learningProblem).getPositiveExamples();
    negativeIndividuals=((PosNegLP)learningProblem).getNegativeExamples();
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    positiveIndividuals=((PosOnlyLP)learningProblem).getPositiveExamples();
    negativeIndividuals=Sets.difference(learningProblem.getReasoner().getIndividuals(),positiveIndividuals);
  }
 else   if (learningProblem instanceof ClassLearningProblem) {
    try {
      List<OWLIndividual> positiveIndividualsList=ReflectionHelper.getPrivateField(learningProblem,""String_Node_Str"");
      positiveIndividuals=new TreeSet<>(positiveIndividualsList);
      negativeIndividuals=new TreeSet<>((List<OWLIndividual>)ReflectionHelper.getPrivateField(learningProblem,""String_Node_Str""));
    }
 catch (    NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
      String msg=""String_Node_Str"" + ""String_Node_Str"" + e.getMessage();
      logger.error(msg);
      throw new ComponentInitException(msg);
    }
  }
 else {
    try {
      throw new LearningProblemUnsupportedException(((AbstractClassExpressionLearningProblem)learningProblem).getClass(),this.getClass());
    }
 catch (    LearningProblemUnsupportedException e) {
      throw new ComponentInitException(e.getMessage());
    }
  }
  logger.debug(""String_Node_Str"");
  Set<OWLAxiom> positiveExamples=OWLUtils.convertIndividualsToAssertionalAxioms(positiveIndividuals,dummyClass);
  Set<OWLAxiom> negativeExamples=OWLUtils.convertIndividualsToAssertionalAxioms(negativeIndividuals,dummyClass);
  edge.setPositiveExampleAxioms(positiveExamples);
  edge.setNegativeExampleAxioms(negativeExamples);
}"
9343,"@Override public void start(){
  stop=false;
  isRunning=true;
  long totalTimeMills=System.currentTimeMillis();
  long celaTimeMills=0;
  edge.start();
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"" + edge.getLL());
  logger.debug(""String_Node_Str"");
  celaTimeMills=System.currentTimeMillis();
  cela.start();
  celaTimeMills=System.currentTimeMillis() - celaTimeMills;
  NavigableSet<? extends EvaluatedDescription> evaluatedDescriptions=cela.getCurrentlyBestEvaluatedDescriptions();
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  Set<? extends OWLAxiom> candidateAxioms;
  if (getClassAxiomType().equalsIgnoreCase(""String_Node_Str"") || getClassAxiomType().equalsIgnoreCase(""String_Node_Str"")) {
    candidateAxioms=convertIntoSubClassOfAxioms(manager,evaluatedDescriptions);
  }
 else {
    candidateAxioms=convertIntoEquivalentClassesAxioms(manager,evaluatedDescriptions);
  }
  logger.info(""String_Node_Str"");
  Set<OWLAxiom> learnedAxioms=null;
  try {
    learnedAxioms=greedySearch(candidateAxioms);
  }
 catch (  UnsupportedLearnedAxiom ex) {
    logger.error(ex.getMessage());
    System.exit(-1);
  }
  logger.info(""String_Node_Str"");
  OWLOntology finalOntology=edge.getSourcesOntology();
  if (cela.getLearningProblem() instanceof ClassLearningProblem) {
    try {
      finalOntology=replaceDummyClass(finalOntology,learnedAxioms);
    }
 catch (    UnsupportedLearnedAxiom ex) {
      logger.error(ex.getMessage());
      System.exit(-1);
    }
  }
 else {
    for (    OWLAxiom axiom : safe(learnedAxioms)) {
      logger.info(""String_Node_Str"" + axiom);
    }
  }
  try {
    OWLUtils.saveOntology(finalOntology,outputFile,outFormat);
  }
 catch (  OWLOntologyStorageException e) {
    String msg=""String_Node_Str"" + e.getMessage();
    throw new StructureLearningException(msg);
  }
  totalTimeMills=System.currentTimeMillis() - totalTimeMills;
  printTimings(totalTimeMills,celaTimeMills,edge.getTimeMap());
}","@Override public void start(){
  stop=false;
  isRunning=true;
  long totalTimeMills=System.currentTimeMillis();
  long celaTimeMills=0;
  edge.start();
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"" + edge.getLL());
  logger.debug(""String_Node_Str"");
  celaTimeMills=System.currentTimeMillis();
  cela.start();
  celaTimeMills=System.currentTimeMillis() - celaTimeMills;
  NavigableSet<? extends EvaluatedDescription> evaluatedDescriptions=cela.getCurrentlyBestEvaluatedDescriptions();
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  Set<? extends OWLAxiom> candidateAxioms;
  if (getClassAxiomType().equalsIgnoreCase(""String_Node_Str"") || getClassAxiomType().equalsIgnoreCase(""String_Node_Str"")) {
    candidateAxioms=convertIntoSubClassOfAxioms(manager,evaluatedDescriptions);
  }
 else {
    candidateAxioms=convertIntoEquivalentClassesAxioms(manager,evaluatedDescriptions);
  }
  logger.info(""String_Node_Str"");
  Set<OWLAxiom> learnedAxioms=null;
  try {
    learnedAxioms=greedySearch(candidateAxioms);
  }
 catch (  UnsupportedLearnedAxiom ex) {
    logger.error(ex.getMessage());
    System.exit(-1);
  }
  logger.info(""String_Node_Str"");
  OWLOntology finalOntology=edge.getSourcesOntology();
  if (cela.getLearningProblem() instanceof ClassLearningProblem) {
    try {
      finalOntology=replaceDummyClass(finalOntology,learnedAxioms);
    }
 catch (    UnsupportedLearnedAxiom ex) {
      logger.error(ex.getMessage());
      System.exit(-1);
    }
  }
 else {
    for (    OWLAxiom axiom : safe(learnedAxioms)) {
      logger.info(""String_Node_Str"" + axiom);
    }
  }
  try {
    logger.info(""String_Node_Str"");
    OWLUtils.saveOntology(finalOntology,outputFile,outFormat);
  }
 catch (  OWLOntologyStorageException e) {
    String msg=""String_Node_Str"" + e.getMessage();
    throw new StructureLearningException(msg);
  }
  totalTimeMills=System.currentTimeMillis() - totalTimeMills;
  printTimings(totalTimeMills,celaTimeMills,edge.getTimeMap());
}"
9344,"@Override public void init() throws ComponentInitException {
  super.init();
  bundle.setBddFType(bddFType);
  bundle.setMaxExplanations(this.maxExplanations);
  bundle.setMaxTime(this.timeout);
  bundle.setLog(true);
  bundle.setAccuracy(this.accuracy);
  bundle.loadOntologies(ontology);
  initialized=true;
}","@Override public void init() throws ComponentInitException {
  super.init();
  bundle.setBddFType(bddFType);
  bundle.setMaxExplanations(this.maxExplanations);
  bundle.setMaxTime(this.timeout);
  bundle.setLog(true);
  bundle.setAccuracy(this.accuracy);
  bundle.loadOntologies(ontology);
  bundle.init();
  initialized=true;
}"
9345,"@Override public OWLProbExplanationReasonerResult computeQuery(OWLAxiom axiom) throws OWLException {
  QueryResult result=bundle.computeQuery(axiom);
  return new OWLProbExplanationReasonerResult(axiom,result.getQueryProbability().doubleValue(),GeneralUtils.safe(result.getExplanations()));
}","@Override public OWLProbReasonerResult computeQuery(OWLAxiom axiom) throws OWLException {
  return computeQueryWithExplanations(axiom);
}"
9346,"/** 
 * This method merges all the input knowledge sources and returns the filename of the new ontology.
 * @param sources set of knowledge bases
 * @return the ontology obtained from the merging of {@code sources}
 * @throws org.dllearner.core.ComponentInitException
 */
public static OWLOntology mergeOntologies(Set<KnowledgeSource> sources) throws ComponentInitException {
  logger.info(""String_Node_Str"" + sources.size());
  logger.info(""String_Node_Str"");
  List<OWLOntology> owlAPIOntologies=new LinkedList<>();
  Set<OWLImportsDeclaration> directImports=new HashSet<>();
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  for (  KnowledgeSource source : sources) {
    OWLOntology ontology;
    if (source instanceof OWLOntologyKnowledgeSource) {
      ontology=((OWLOntologyKnowledgeSource)source).createOWLOntology(manager);
      owlAPIOntologies.add(ontology);
    }
 else {
      String message=""String_Node_Str"" + source.getClass().getName();
      logger.error(message);
      throw new ComponentInitException(message);
    }
    directImports.addAll(ontology.getImportsDeclarations());
  }
  try {
    logger.info(""String_Node_Str"");
    OWLOntology allOntology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<OWLOntology>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<>();
    for (    OWLImportsDeclaration i : directImports) {
      addImports.add(new AddImport(allOntology,i));
    }
    manager.applyChanges(addImports);
    logger.info(""String_Node_Str"");
    return allOntology;
  }
 catch (  OWLOntologyCreationException e1) {
    String message=""String_Node_Str"";
    logger.error(message + e1.getMessage());
    throw new ComponentInitException(message);
  }
}","/** 
 * This method merges all the input knowledge sources and returns the filename of the new ontology.
 * @param sources set of knowledge bases
 * @return the ontology obtained from the merging of {@code sources}
 * @throws org.dllearner.core.ComponentInitException
 */
public static OWLOntology mergeOntologies(Set<KnowledgeSource> sources) throws ComponentInitException {
  logger.info(""String_Node_Str"" + sources.size());
  logger.info(""String_Node_Str"");
  List<OWLOntology> owlAPIOntologies=new LinkedList<>();
  Set<OWLImportsDeclaration> directImports=new HashSet<>();
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  for (  KnowledgeSource source : sources) {
    OWLOntology ontology;
    if (source instanceof OWLOntologyKnowledgeSource) {
      ontology=((OWLOntologyKnowledgeSource)source).createOWLOntology(manager);
      owlAPIOntologies.add(ontology);
    }
 else {
      String message=""String_Node_Str"" + source.getClass().getName();
      logger.error(message);
      throw new ComponentInitException(message);
    }
    directImports.addAll(ontology.getImportsDeclarations());
  }
  try {
    logger.info(""String_Node_Str"");
    OWLOntology allOntology=manager.createOntology(IRI.generateDocumentIRI(),new HashSet<OWLOntology>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<>();
    for (    OWLImportsDeclaration i : directImports) {
      addImports.add(new AddImport(allOntology,i));
    }
    manager.applyChanges(addImports);
    logger.info(""String_Node_Str"");
    return allOntology;
  }
 catch (  OWLOntologyCreationException e1) {
    String message=""String_Node_Str"";
    logger.error(message + e1.getMessage());
    throw new ComponentInitException(message);
  }
}"
9347,"@Override public void run(){
  Set<OWLIndividual> posIndividuals=null;
  Set<OWLIndividual> negIndividuals=null;
  Set<OWLAxiom> posTestQueries;
  Set<OWLAxiom> negTestQueries;
  if (lp instanceof PosNegLP) {
    posIndividuals=((PosNegLP)lp).getPositiveExamples();
    negIndividuals=((PosNegLP)lp).getNegativeExamples();
  }
 else   if (lp instanceof PosOnlyLP) {
    posIndividuals=((PosOnlyLP)lp).getPositiveExamples();
  }
 else {
    throw new UnsupportedOperationException(""String_Node_Str"" + lp.getClass());
  }
  posTestQueries=OWLUtils.convertIndividualsToAssertionalAxioms(posIndividuals,classExpression);
  negTestQueries=OWLUtils.convertIndividualsToAssertionalAxioms(safe(negIndividuals),classExpression);
  try {
    Set<OWLProbReasonerResult> posTestResults=computeQueries(posTestQueries);
    Set<OWLProbReasonerResult> negTestResults=computeQueries(negTestQueries);
    PrintWriter outFile=new PrintWriter(outputFile,""String_Node_Str"");
    outFile.println(""String_Node_Str"" + posTestResults.size());
    outFile.println(""String_Node_Str"" + negTestResults.size());
    outFile.print(""String_Node_Str"");
    for (    OWLProbReasonerResult q : posTestResults) {
      outFile.print(q.getProbability() + ""String_Node_Str"");
      outFile.print(""String_Node_Str"");
    }
    Iterator<OWLProbReasonerResult> it=negTestResults.iterator();
    while (it.hasNext()) {
      OWLProbReasonerResult q=it.next();
      outFile.print(q.getProbability() + ""String_Node_Str"");
      if (it.hasNext()) {
        outFile.print(""String_Node_Str"");
      }
      outFile.println();
    }
    outFile.close();
  }
 catch (  OWLException owle) {
    logger.error(""String_Node_Str"");
    System.exit(State.FAILURE.ordinal());
  }
catch (  FileNotFoundException|UnsupportedEncodingException ex) {
    logger.error(""String_Node_Str"" + outputFile + ""String_Node_Str""+ ""String_Node_Str""+ ex.getMessage());
    System.exit(State.FAILURE.ordinal());
  }
}","@Override public void run(){
  Set<OWLIndividual> posIndividuals=null;
  Set<OWLIndividual> negIndividuals=null;
  Set<OWLAxiom> posTestQueries;
  Set<OWLAxiom> negTestQueries;
  if (lp instanceof PosNegLP) {
    posIndividuals=((PosNegLP)lp).getPositiveExamples();
    negIndividuals=((PosNegLP)lp).getNegativeExamples();
  }
 else   if (lp instanceof PosOnlyLP) {
    posIndividuals=((PosOnlyLP)lp).getPositiveExamples();
  }
 else {
    throw new UnsupportedOperationException(""String_Node_Str"" + lp.getClass());
  }
  posTestQueries=OWLUtils.convertIndividualsToAssertionalAxioms(posIndividuals,classExpression);
  negTestQueries=OWLUtils.convertIndividualsToAssertionalAxioms(safe(negIndividuals),classExpression);
  try {
    Set<OWLProbReasonerResult> posTestResults=computeQueries(posTestQueries);
    Set<OWLProbReasonerResult> negTestResults=computeQueries(negTestQueries);
    PrintWriter outFile=new PrintWriter(outputFile,""String_Node_Str"");
    outFile.println(""String_Node_Str"" + posTestResults.size());
    outFile.println(""String_Node_Str"" + negTestResults.size());
    outFile.print(""String_Node_Str"");
    for (    OWLProbReasonerResult q : posTestResults) {
      outFile.print(q.getProbability() + ""String_Node_Str"");
      outFile.print(""String_Node_Str"");
    }
    Iterator<OWLProbReasonerResult> it=negTestResults.iterator();
    while (it.hasNext()) {
      OWLProbReasonerResult q=it.next();
      outFile.print(q.getProbability() + ""String_Node_Str"");
      if (it.hasNext()) {
        outFile.print(""String_Node_Str"");
      }
    }
    outFile.println();
    outFile.close();
  }
 catch (  OWLException owle) {
    logger.error(""String_Node_Str"");
    System.exit(State.FAILURE.ordinal());
  }
catch (  FileNotFoundException|UnsupportedEncodingException ex) {
    logger.error(""String_Node_Str"" + outputFile + ""String_Node_Str""+ ""String_Node_Str""+ ex.getMessage());
    System.exit(State.FAILURE.ordinal());
  }
}"
9348,"final public String String() throws ParseException {
  Token t;
  String s;
  t=jj_consume_token(STRING);
  s=t.image;
  s=s.substring(1,s.length() - 1);
  try {
    s=java.net.URLDecoder.decode(s,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
  }
{
    if (""String_Node_Str"" != null)     return s;
  }
  throw new Error(""String_Node_Str"");
}","final public String String() throws ParseException {
  Token t;
  String s;
  t=jj_consume_token(STRING);
  s=t.image;
  s=s.substring(1,s.length() - 1);
  try {
    s=java.net.URLDecoder.decode(s,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
  }
catch (  IllegalArgumentException e) {
  }
{
    if (""String_Node_Str"" != null)     return s;
  }
  throw new Error(""String_Node_Str"");
}"
9349,"@Override public boolean isTooWeak(){
  return isTooWeak;
}","public boolean isTooWeak(){
  return isTooWeak;
}"
9350,"protected RDFResourceTree computeLGG(RDFResourceTree tree1,RDFResourceTree tree2,boolean learnFilters){
  subCalls++;
  if ((tree1.isResourceNode() || tree1.isLiteralValueNode()) && tree1.getData().equals(tree2.getData())) {
    logger.trace(""String_Node_Str"",tree1,tree2);
    return tree1;
  }
  if (tree1.isLiteralNode() && tree2.isLiteralNode()) {
    RDFDatatype d1=tree1.getData().getLiteralDatatype();
    RDFDatatype d2=tree2.getData().getLiteralDatatype();
    if (d1 != null && d1.equals(d2)) {
      return new RDFResourceTree(d1);
    }
  }
  RDFResourceTree lgg=new RDFResourceTree();
  Multimap<Node,Node> relatedEdges=getRelatedEdges(tree1,tree2);
  for (  Entry<Node,Collection<Node>> entry : relatedEdges.asMap().entrySet()) {
    Node edge1=entry.getKey();
    Collection<Node> edges2=entry.getValue();
    Set<RDFResourceTree> addedChildren=new HashSet<>();
    for (    RDFResourceTree child1 : tree1.getChildren(edge1)) {
      for (      Node edge2 : edges2) {
        for (        RDFResourceTree child2 : tree2.getChildren(edge2)) {
          RDFResourceTree lggChild=computeLGG(child1,child2,learnFilters);
          Node moreGeneralEdge;
          if (reasoner.isSubPropertyOf(OwlApiJenaUtils.asOWLEntity(edge1,EntityType.OBJECT_PROPERTY),OwlApiJenaUtils.asOWLEntity(edge2,EntityType.OBJECT_PROPERTY))) {
            moreGeneralEdge=edge2;
          }
 else {
            moreGeneralEdge=edge1;
          }
          boolean add=true;
          for (Iterator<RDFResourceTree> it=addedChildren.iterator(); it.hasNext(); ) {
            RDFResourceTree addedChild=it.next();
            if (QueryTreeUtils.isSubsumedBy(addedChild,lggChild,reasoner,edge1.equals(RDF.type.asNode()))) {
              add=false;
              break;
            }
 else             if (QueryTreeUtils.isSubsumedBy(lggChild,addedChild,reasoner,edge1.equals(RDF.type.asNode()))) {
              lgg.removeChild(addedChild,moreGeneralEdge);
              it.remove();
            }
          }
          if (add) {
            Node edge;
            if (reasoner.isSubPropertyOf(OwlApiJenaUtils.asOWLEntity(edge1,EntityType.OBJECT_PROPERTY),OwlApiJenaUtils.asOWLEntity(edge2,EntityType.OBJECT_PROPERTY))) {
              edge=edge2;
            }
 else {
              edge=edge1;
            }
            lgg.addChild(lggChild,edge);
            addedChildren.add(lggChild);
          }
        }
      }
    }
  }
  return lgg;
}","protected RDFResourceTree computeLGG(RDFResourceTree tree1,RDFResourceTree tree2,boolean learnFilters){
  subCalls++;
  if ((tree1.isResourceNode() || tree1.isLiteralValueNode()) && tree1.getData().equals(tree2.getData())) {
    logger.trace(""String_Node_Str"",tree1,tree2);
    return tree1;
  }
  if (tree1.isLiteralNode() && tree2.isLiteralNode()) {
    RDFDatatype d1=tree1.getData().getLiteralDatatype();
    RDFDatatype d2=tree2.getData().getLiteralDatatype();
    if (d1 != null && d1.equals(d2)) {
      return new RDFResourceTree(d1);
    }
  }
  RDFResourceTree lgg=new RDFResourceTree();
  Multimap<Node,Node> relatedEdges=getRelatedEdges(tree1,tree2);
  for (  Entry<Node,Collection<Node>> entry : relatedEdges.asMap().entrySet()) {
    Node edge1=entry.getKey();
    Collection<Node> edges2=entry.getValue();
    Set<RDFResourceTree> addedChildren=new HashSet<>();
    for (    RDFResourceTree child1 : tree1.getChildren(edge1)) {
      for (      Node edge2 : edges2) {
        for (        RDFResourceTree child2 : tree2.getChildren(edge2)) {
          RDFResourceTree lggChild=computeLGG(child1,child2,learnFilters);
          Node moreGeneralEdge;
          if (reasoner.isSubPropertyOf(OwlApiJenaUtils.asOWLEntity(edge1,EntityType.OBJECT_PROPERTY),OwlApiJenaUtils.asOWLEntity(edge2,EntityType.OBJECT_PROPERTY))) {
            moreGeneralEdge=edge2;
          }
 else {
            moreGeneralEdge=edge1;
          }
          boolean add=true;
          for (Iterator<RDFResourceTree> it=addedChildren.iterator(); it.hasNext(); ) {
            RDFResourceTree addedChild=it.next();
            if (QueryTreeUtils.isSubsumedBy(addedChild,lggChild,reasoner,edge1.equals(RDF.type.asNode()))) {
              add=false;
              break;
            }
 else             if (QueryTreeUtils.isSubsumedBy(lggChild,addedChild,reasoner,edge1.equals(RDF.type.asNode()))) {
              lgg.removeChild(addedChild,lgg.getEdgeToChild(addedChild));
              it.remove();
            }
          }
          if (add) {
            Node edge;
            if (reasoner.isSubPropertyOf(OwlApiJenaUtils.asOWLEntity(edge1,EntityType.OBJECT_PROPERTY),OwlApiJenaUtils.asOWLEntity(edge2,EntityType.OBJECT_PROPERTY))) {
              edge=edge2;
            }
 else {
              edge=edge1;
            }
            lgg.addChild(lggChild,edge);
            addedChildren.add(lggChild);
          }
        }
      }
    }
  }
  return lgg;
}"
9351,"public void correctness(){
  treeFactory.setMaxDepth(2);
  treeFactory.addDropFilters((Filter<Statement>[])new DBpediaEvaluationDataset(SparqlEndpoint.getEndpointDBpedia()).getQueryTreeFilters().toArray(new Filter[]{}));
  Model model=ModelFactory.createDefaultModel();
  RDFDataMgr.read(model,this.getClass().getClassLoader().getResourceAsStream(""String_Node_Str""),Lang.TURTLE);
  RDFResourceTree tree1=treeFactory.getQueryTree(""String_Node_Str"",model);
  model=ModelFactory.createDefaultModel();
  RDFDataMgr.read(model,this.getClass().getClassLoader().getResourceAsStream(""String_Node_Str""),Lang.TURTLE);
  RDFResourceTree tree2=treeFactory.getQueryTree(""String_Node_Str"",model);
  long start=System.currentTimeMillis();
  RDFResourceTree lggSimple=lggGenSimple.getLGG(tree1,tree2);
  long end=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  System.out.println(lggSimple.getStringRepresentation());
}","public void correctness(){
  treeFactory.setMaxDepth(2);
  treeFactory.addDropFilters((Filter<Statement>[])new DBpediaEvaluationDataset(new File(""String_Node_Str""),SparqlEndpoint.getEndpointDBpedia()).getQueryTreeFilters().toArray(new Filter[]{}));
  Model model=ModelFactory.createDefaultModel();
  RDFDataMgr.read(model,this.getClass().getClassLoader().getResourceAsStream(""String_Node_Str""),Lang.TURTLE);
  RDFResourceTree tree1=treeFactory.getQueryTree(""String_Node_Str"",model);
  model=ModelFactory.createDefaultModel();
  RDFDataMgr.read(model,this.getClass().getClassLoader().getResourceAsStream(""String_Node_Str""),Lang.TURTLE);
  RDFResourceTree tree2=treeFactory.getQueryTree(""String_Node_Str"",model);
  long start=System.currentTimeMillis();
  RDFResourceTree lggSimple=lggGenSimple.getLGG(tree1,tree2);
  long end=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  System.out.println(lggSimple.getStringRepresentation());
}"
9352,"private void extendNodeProper(ExampleBasedNode node,OWLClassExpression concept,int maxLength,int recDepth){
  if (stop)   return;
  if (recDepth > maxRecDepth)   maxRecDepth=recDepth;
  long refinementCalcTimeNsStart=System.nanoTime();
  Set<OWLClassExpression> refinements=operator.refine(concept,maxLength,null);
  refinementCalcTimeNs+=System.nanoTime() - refinementCalcTimeNsStart;
  if (refinements.size() > maxNrOfRefinements)   maxNrOfRefinements=refinements.size();
  long childConceptsDeletionTimeNsStart=System.nanoTime();
  refinements.removeAll(node.getChildConcepts());
  childConceptsDeletionTimeNs+=System.nanoTime() - childConceptsDeletionTimeNsStart;
  long evaluateSetCreationTimeNsStart=System.nanoTime();
  TreeSet<OWLClassExpression> toEvaluateConcepts=new TreeSet<OWLClassExpression>();
  Iterator<OWLClassExpression> it=refinements.iterator();
  while (it.hasNext()) {
    OWLClassExpression refinement=it.next();
    if (OWLClassExpressionUtils.getLength(refinement) > node.getHorizontalExpansion()) {
      boolean propernessDetected=false;
      if (useShortConceptConstruction) {
        OWLClassExpression shortConcept=ConceptTransformation.getShortConcept(refinement);
        int n=shortConcept.compareTo(concept);
        if (n == 0) {
          propernessTestsAvoidedByShortConceptConstruction++;
          propernessDetected=true;
        }
      }
      if (!propernessDetected && useTooWeakList) {
        if (refinement instanceof OWLObjectIntersectionOf) {
          boolean tooWeakElement=containsTooWeakElement((OWLObjectIntersectionOf)refinement);
          if (tooWeakElement) {
            propernessTestsAvoidedByTooWeakList++;
            conceptTestsTooWeakList++;
            propernessDetected=true;
            properRefinements.add(refinement);
            tooWeakList.add(refinement);
            ExampleBasedNode newNode=new ExampleBasedNode(refinement,negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
            newNode.setHorizontalExpansion(OWLClassExpressionUtils.getLength(refinement) - 1);
            newNode.setTooWeak(true);
            newNode.setQualityEvaluationMethod(ExampleBasedNode.QualityEvaluationMethod.TOO_WEAK_LIST);
            node.addChild(newNode);
            it.remove();
          }
        }
      }
      if (!propernessDetected) {
        toEvaluateConcepts.add(refinement);
      }
    }
  }
  evaluateSetCreationTimeNs+=System.nanoTime() - evaluateSetCreationTimeNsStart;
  Set<OWLClassExpression> improperConcepts=null;
  if (toEvaluateConcepts.size() > 0) {
    if (usePropernessChecks) {
      long propCalcReasoningStart=System.nanoTime();
      improperConcepts=rs.isSuperClassOf(toEvaluateConcepts,concept);
      propernessTestsReasoner+=toEvaluateConcepts.size();
      propernessCalcReasoningTimeNs+=System.nanoTime() - propCalcReasoningStart;
    }
  }
  long improperConceptsRemovalTimeNsStart=System.nanoTime();
  if (improperConcepts != null)   toEvaluateConcepts.removeAll(improperConcepts);
  Set<OWLClassExpression> properConcepts=toEvaluateConcepts;
  refinements.removeAll(properConcepts);
  improperConceptsRemovalTimeNs+=System.nanoTime() - improperConceptsRemovalTimeNsStart;
  for (  OWLClassExpression refinement : properConcepts) {
    long redundancyCheckTimeNsStart=System.nanoTime();
    boolean nonRedundant=properRefinements.add(refinement);
    redundancyCheckTimeNs+=System.nanoTime() - redundancyCheckTimeNsStart;
    if (!nonRedundant)     redundantConcepts++;
    if (nonRedundant) {
      ExampleBasedNode newNode=new ExampleBasedNode(refinement,negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
      newNode.setHorizontalExpansion(OWLClassExpressionUtils.getLength(refinement) - 1);
      boolean qualityKnown=false;
      int quality=-2;
      if (useOverlyGeneralList && refinement instanceof OWLObjectUnionOf) {
        if (containsOverlyGeneralElement((OWLObjectUnionOf)refinement)) {
          conceptTestsOverlyGeneralList++;
          quality=nrOfNegativeExamples;
          qualityKnown=true;
          newNode.setQualityEvaluationMethod(ExampleBasedNode.QualityEvaluationMethod.OVERLY_GENERAL_LIST);
          newNode.setCoveredExamples(positiveExamples,negativeExamples);
        }
      }
      if (!qualityKnown) {
        long propCalcReasoningStart2=System.nanoTime();
        conceptTestsReasoner++;
        Set<OWLIndividual> coveredPositives=node.getCoveredPositives();
        Set<OWLIndividual> newlyCoveredPositives=new HashSet<OWLIndividual>();
        int misclassifiedPositives=nrOfPositiveExamples - coveredPositives.size();
        for (        OWLIndividual i : coveredPositives) {
          if (quality != -1) {
            boolean covered=rs.hasType(refinement,i);
            if (!covered)             misclassifiedPositives++;
 else             newlyCoveredPositives.add(i);
            if (misclassifiedPositives > allowedMisclassifications)             quality=-1;
          }
        }
        Set<OWLIndividual> newlyCoveredNegatives=null;
        if (quality != -1) {
          Set<OWLIndividual> coveredNegatives=node.getCoveredNegatives();
          newlyCoveredNegatives=new HashSet<OWLIndividual>();
          for (          OWLIndividual i : coveredNegatives) {
            boolean covered=rs.hasType(refinement,i);
            if (covered)             newlyCoveredNegatives.add(i);
          }
        }
        propernessCalcReasoningTimeNs+=System.nanoTime() - propCalcReasoningStart2;
        newNode.setQualityEvaluationMethod(ExampleBasedNode.QualityEvaluationMethod.REASONER);
        if (quality != -1) {
          quality=(nrOfPositiveExamples - newlyCoveredPositives.size()) + newlyCoveredNegatives.size();
          newNode.setCoveredExamples(newlyCoveredPositives,newlyCoveredNegatives);
        }
      }
      if (quality == -1) {
        newNode.setTooWeak(true);
        tooWeakList.add(refinement);
      }
 else {
        if (quality >= 0 && quality <= allowedMisclassifications) {
          solutions.add(newNode);
        }
        newCandidates.add(newNode);
        if ((newNode.getCoveredPositives().size() == nrOfPositiveExamples) && quality == nrOfNegativeExamples)         overlyGeneralList.add(refinement);
      }
      node.addChild(newNode);
      if (forceRefinementLengthIncrease && !newNode.isTooWeak()) {
        if (OWLClassExpressionUtils.getLength(node.getConcept()) == OWLClassExpressionUtils.getLength(newNode.getConcept())) {
          extendNodeProper(newNode,refinement,maxLength,recDepth + 1);
        }
      }
    }
  }
  for (  OWLClassExpression refinement : refinements) {
    long redundancyCheckTimeNsStart=System.nanoTime();
    boolean redundant=properRefinements.contains(refinement);
    redundancyCheckTimeNs+=System.nanoTime() - redundancyCheckTimeNsStart;
    if (!redundant) {
      extendNodeProper(node,refinement,maxLength,recDepth + 1);
    }
  }
}","private void extendNodeProper(ExampleBasedNode node,OWLClassExpression concept,int maxLength,int recDepth){
  if (stop)   return;
  if (recDepth > maxRecDepth)   maxRecDepth=recDepth;
  long refinementCalcTimeNsStart=System.nanoTime();
  Set<OWLClassExpression> refinements=operator.refine(concept,maxLength,null);
  refinementCalcTimeNs+=System.nanoTime() - refinementCalcTimeNsStart;
  if (refinements.size() > maxNrOfRefinements)   maxNrOfRefinements=refinements.size();
  long childConceptsDeletionTimeNsStart=System.nanoTime();
  refinements.removeAll(node.getChildConcepts());
  childConceptsDeletionTimeNs+=System.nanoTime() - childConceptsDeletionTimeNsStart;
  long evaluateSetCreationTimeNsStart=System.nanoTime();
  Set<OWLClassExpression> toEvaluateConcepts=new TreeSet<OWLClassExpression>();
  Iterator<OWLClassExpression> it=refinements.iterator();
  while (it.hasNext()) {
    OWLClassExpression refinement=it.next();
    if (OWLClassExpressionUtils.getLength(refinement) > node.getHorizontalExpansion()) {
      boolean impropernessDetected=false;
      if (useShortConceptConstruction) {
        OWLClassExpression shortConcept=ConceptTransformation.getShortConcept(refinement);
        int n=shortConcept.compareTo(concept);
        if (n == 0) {
          propernessTestsAvoidedByShortConceptConstruction++;
          impropernessDetected=true;
        }
      }
      if (!impropernessDetected && useTooWeakList) {
        if (refinement instanceof OWLObjectIntersectionOf) {
          boolean tooWeakElement=containsTooWeakElement((OWLObjectIntersectionOf)refinement);
          if (tooWeakElement) {
            propernessTestsAvoidedByTooWeakList++;
            conceptTestsTooWeakList++;
            impropernessDetected=true;
            properRefinements.add(refinement);
            tooWeakList.add(refinement);
            ExampleBasedNode newNode=new ExampleBasedNode(refinement,negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
            newNode.setHorizontalExpansion(OWLClassExpressionUtils.getLength(refinement) - 1);
            newNode.setTooWeak(true);
            newNode.setQualityEvaluationMethod(ExampleBasedNode.QualityEvaluationMethod.TOO_WEAK_LIST);
            node.addChild(newNode);
            it.remove();
          }
        }
      }
      if (!impropernessDetected) {
        toEvaluateConcepts.add(refinement);
      }
    }
  }
  evaluateSetCreationTimeNs+=System.nanoTime() - evaluateSetCreationTimeNsStart;
  Set<OWLClassExpression> improperConcepts=null;
  if (toEvaluateConcepts.size() > 0) {
    if (usePropernessChecks) {
      long propCalcReasoningStart=System.nanoTime();
      improperConcepts=rs.isSuperClassOf(toEvaluateConcepts,concept);
      propernessTestsReasoner+=toEvaluateConcepts.size();
      propernessCalcReasoningTimeNs+=System.nanoTime() - propCalcReasoningStart;
    }
  }
  long improperConceptsRemovalTimeNsStart=System.nanoTime();
  if (improperConcepts != null)   toEvaluateConcepts.removeAll(improperConcepts);
  Set<OWLClassExpression> properConcepts=toEvaluateConcepts;
  refinements.removeAll(properConcepts);
  improperConceptsRemovalTimeNs+=System.nanoTime() - improperConceptsRemovalTimeNsStart;
  for (  OWLClassExpression refinement : properConcepts) {
    long redundancyCheckTimeNsStart=System.nanoTime();
    boolean nonRedundant=properRefinements.add(refinement);
    redundancyCheckTimeNs+=System.nanoTime() - redundancyCheckTimeNsStart;
    if (!nonRedundant)     redundantConcepts++;
    if (nonRedundant) {
      ExampleBasedNode newNode=new ExampleBasedNode(refinement,negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
      newNode.setHorizontalExpansion(OWLClassExpressionUtils.getLength(refinement) - 1);
      boolean qualityKnown=false;
      int quality=-2;
      if (useOverlyGeneralList && refinement instanceof OWLObjectUnionOf) {
        if (containsOverlyGeneralElement((OWLObjectUnionOf)refinement)) {
          conceptTestsOverlyGeneralList++;
          quality=nrOfNegativeExamples;
          qualityKnown=true;
          newNode.setQualityEvaluationMethod(ExampleBasedNode.QualityEvaluationMethod.OVERLY_GENERAL_LIST);
          newNode.setCoveredExamples(positiveExamples,negativeExamples);
        }
      }
      if (!qualityKnown) {
        long propCalcReasoningStart2=System.nanoTime();
        conceptTestsReasoner++;
        Set<OWLIndividual> coveredPositives=node.getCoveredPositives();
        Set<OWLIndividual> newlyCoveredPositives=new HashSet<OWLIndividual>();
        int misclassifiedPositives=nrOfPositiveExamples - coveredPositives.size();
        for (        OWLIndividual i : coveredPositives) {
          if (quality != -1) {
            boolean covered=rs.hasType(refinement,i);
            if (!covered)             misclassifiedPositives++;
 else             newlyCoveredPositives.add(i);
            if (misclassifiedPositives > allowedMisclassifications)             quality=-1;
          }
        }
        Set<OWLIndividual> newlyCoveredNegatives=null;
        if (quality != -1) {
          Set<OWLIndividual> coveredNegatives=node.getCoveredNegatives();
          newlyCoveredNegatives=new HashSet<OWLIndividual>();
          for (          OWLIndividual i : coveredNegatives) {
            boolean covered=rs.hasType(refinement,i);
            if (covered)             newlyCoveredNegatives.add(i);
          }
        }
        propernessCalcReasoningTimeNs+=System.nanoTime() - propCalcReasoningStart2;
        newNode.setQualityEvaluationMethod(ExampleBasedNode.QualityEvaluationMethod.REASONER);
        if (quality != -1) {
          quality=(nrOfPositiveExamples - newlyCoveredPositives.size()) + newlyCoveredNegatives.size();
          newNode.setCoveredExamples(newlyCoveredPositives,newlyCoveredNegatives);
        }
      }
      if (quality == -1) {
        newNode.setTooWeak(true);
        tooWeakList.add(refinement);
      }
 else {
        if (quality >= 0 && quality <= allowedMisclassifications) {
          solutions.add(newNode);
        }
        newCandidates.add(newNode);
        if ((newNode.getCoveredPositives().size() == nrOfPositiveExamples) && quality == nrOfNegativeExamples)         overlyGeneralList.add(refinement);
      }
      node.addChild(newNode);
      if (forceRefinementLengthIncrease && !newNode.isTooWeak()) {
        if (OWLClassExpressionUtils.getLength(node.getConcept()) == OWLClassExpressionUtils.getLength(newNode.getConcept())) {
          extendNodeProper(newNode,refinement,maxLength,recDepth + 1);
        }
      }
    }
  }
  for (  OWLClassExpression refinement : refinements) {
    long redundancyCheckTimeNsStart=System.nanoTime();
    boolean redundant=properRefinements.contains(refinement);
    redundancyCheckTimeNs+=System.nanoTime() - redundancyCheckTimeNsStart;
    if (!redundant) {
      extendNodeProper(node,refinement,maxLength,recDepth + 1);
    }
  }
}"
9353,"private static void configureClassLP(ClassLearningProblem problem,OWLClass classToDescribe,HeuristicType accuracyMethod,boolean equivalenceLearning,boolean useApproximations,double approxAccuracy) throws ComponentInitException {
  problem.setClassToDescribe(classToDescribe);
  problem.setEquivalence(equivalenceLearning);
  problem.setHeuristic(accuracyMethod);
  problem.setUseApproximations(useApproximations);
  problem.setApproxDelta(approxAccuracy);
  problem.init();
}","private static void configureClassLP(ClassLearningProblem problem,OWLClass classToDescribe,HeuristicType accuracyMethod,boolean equivalenceLearning,boolean useApproximations,double approxAccuracy) throws ComponentInitException {
  problem.setClassToDescribe(classToDescribe);
  problem.setEquivalence(equivalenceLearning);
  problem.setAccuracyMethod(accuracyMethod);
  problem.setUseApproximations(useApproximations);
  problem.setApproxDelta(approxAccuracy);
  problem.init();
}"
9354,"private List<EvaluatedAxiom<OWLAxiom>> applyCELOE(SparqlEndpointKS ks,OWLClass nc,boolean equivalence,boolean reuseKnowledgeSource) throws ComponentInitException {
  System.out.print(""String_Node_Str"");
  long startTime=System.currentTimeMillis();
  SortedSet<OWLIndividual> posExamples=reasoner.getIndividuals(nc,maxNrOfPositiveExamples);
  long runTime=System.currentTimeMillis() - startTime;
  if (posExamples.isEmpty()) {
    System.out.println(""String_Node_Str"" + nc.toString() + ""String_Node_Str"");
    return Collections.emptyList();
  }
  SortedSet<String> posExStr=Helper.getStringSet(posExamples);
  System.out.println(""String_Node_Str"" + posExStr.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
  System.out.print(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  AutomaticNegativeExampleFinderSPARQL2 finder=new AutomaticNegativeExampleFinderSPARQL2(ks.getEndpoint(),reasoner);
  SortedSet<OWLIndividual> negExamples=finder.getNegativeExamples(nc,posExamples,maxNrOfNegativeExamples);
  SortedSetTuple<OWLIndividual> examples=new SortedSetTuple<OWLIndividual>(posExamples,negExamples);
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + negExamples.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
  AbstractReasonerComponent rc;
  KnowledgeSource ksFragment;
  if (reuseKnowledgeSource) {
    ksFragment=ksCached;
    rc=rcCached;
  }
 else {
    System.out.print(""String_Node_Str"");
    startTime=System.currentTimeMillis();
    Model model;
    if (ks.isRemote()) {
      model=getFragment(ks,Sets.union(posExamples,negExamples));
    }
 else {
      model=((LocalModelBasedSparqlEndpointKS)ks).getModel();
    }
    filter(model);
    filterByNamespaces(model);
    OWLEntityTypeAdder.addEntityTypes(model);
    runTime=System.currentTimeMillis() - startTime;
    System.out.println(""String_Node_Str"" + model.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
    OWLOntology ontology=asOWLOntology(model);
    if (reasoner.getClassHierarchy() != null) {
      ontology.getOWLOntologyManager().addAxioms(ontology,reasoner.getClassHierarchy().toOWLAxioms());
    }
    ksFragment=new OWLAPIOntology(ontology);
    try {
      OWLManager.createOWLOntologyManager().saveOntology(ontology,new TurtleOntologyFormat(),new FileOutputStream(""String_Node_Str""));
    }
 catch (    OWLOntologyStorageException|FileNotFoundException e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
    rc=new ClosedWorldReasoner(ksFragment);
    rc.init();
    System.out.println(""String_Node_Str"");
    ksCached=ksFragment;
    rcCached=rc;
  }
  ClassLearningProblem lp=new ClassLearningProblem(rc);
  lp.setClassToDescribe(nc);
  lp.setEquivalence(equivalence);
  lp.setHeuristic(HeuristicType.FMEASURE);
  lp.setUseApproximations(false);
  lp.setMaxExecutionTimeInSeconds(10);
  lp.init();
  CELOE la=new CELOE(lp,rc);
  la.setMaxExecutionTimeInSeconds(10);
  la.setNoisePercentage(25);
  la.setMaxNrOfResults(100);
  la.init();
  startTime=System.currentTimeMillis();
  System.out.print(""String_Node_Str"" + (equivalence ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  la.start();
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + runTime + ""String_Node_Str"");
  List<? extends EvaluatedDescription<? extends Score>> learnedDescriptions=la.getCurrentlyBestEvaluatedDescriptions(threshold);
  List<EvaluatedAxiom<OWLAxiom>> learnedAxioms=new LinkedList<EvaluatedAxiom<OWLAxiom>>();
  for (  EvaluatedDescription<? extends Score> learnedDescription : learnedDescriptions) {
    OWLAxiom axiom;
    if (equivalence) {
      axiom=dataFactory.getOWLEquivalentClassesAxiom(nc,learnedDescription.getDescription());
    }
 else {
      axiom=dataFactory.getOWLSubClassOfAxiom(nc,learnedDescription.getDescription());
    }
    Score score=lp.computeScore(learnedDescription.getDescription());
    learnedAxioms.add(new EvaluatedAxiom<OWLAxiom>(axiom,new AxiomScore(score.getAccuracy())));
  }
  System.out.println(prettyPrint(learnedAxioms));
  learnedEvaluatedAxioms.addAll(learnedAxioms);
  algorithmRuns.add(new AlgorithmRun(CELOE.class,learnedAxioms,ConfigHelper.getConfigOptionValues(la)));
  return learnedAxioms;
}","private List<EvaluatedAxiom<OWLAxiom>> applyCELOE(SparqlEndpointKS ks,OWLClass nc,boolean equivalence,boolean reuseKnowledgeSource) throws ComponentInitException {
  System.out.print(""String_Node_Str"");
  long startTime=System.currentTimeMillis();
  SortedSet<OWLIndividual> posExamples=reasoner.getIndividuals(nc,maxNrOfPositiveExamples);
  long runTime=System.currentTimeMillis() - startTime;
  if (posExamples.isEmpty()) {
    System.out.println(""String_Node_Str"" + nc.toString() + ""String_Node_Str"");
    return Collections.emptyList();
  }
  SortedSet<String> posExStr=Helper.getStringSet(posExamples);
  System.out.println(""String_Node_Str"" + posExStr.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
  System.out.print(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  AutomaticNegativeExampleFinderSPARQL2 finder=new AutomaticNegativeExampleFinderSPARQL2(ks.getEndpoint(),reasoner);
  SortedSet<OWLIndividual> negExamples=finder.getNegativeExamples(nc,posExamples,maxNrOfNegativeExamples);
  SortedSetTuple<OWLIndividual> examples=new SortedSetTuple<OWLIndividual>(posExamples,negExamples);
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + negExamples.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
  AbstractReasonerComponent rc;
  KnowledgeSource ksFragment;
  if (reuseKnowledgeSource) {
    ksFragment=ksCached;
    rc=rcCached;
  }
 else {
    System.out.print(""String_Node_Str"");
    startTime=System.currentTimeMillis();
    Model model;
    if (ks.isRemote()) {
      model=getFragment(ks,Sets.union(posExamples,negExamples));
    }
 else {
      model=((LocalModelBasedSparqlEndpointKS)ks).getModel();
    }
    filter(model);
    filterByNamespaces(model);
    OWLEntityTypeAdder.addEntityTypes(model);
    runTime=System.currentTimeMillis() - startTime;
    System.out.println(""String_Node_Str"" + model.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
    OWLOntology ontology=asOWLOntology(model);
    if (reasoner.getClassHierarchy() != null) {
      ontology.getOWLOntologyManager().addAxioms(ontology,reasoner.getClassHierarchy().toOWLAxioms());
    }
    ksFragment=new OWLAPIOntology(ontology);
    try {
      OWLManager.createOWLOntologyManager().saveOntology(ontology,new TurtleOntologyFormat(),new FileOutputStream(""String_Node_Str""));
    }
 catch (    OWLOntologyStorageException|FileNotFoundException e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
    rc=new ClosedWorldReasoner(ksFragment);
    rc.init();
    System.out.println(""String_Node_Str"");
    ksCached=ksFragment;
    rcCached=rc;
  }
  ClassLearningProblem lp=new ClassLearningProblem(rc);
  lp.setClassToDescribe(nc);
  lp.setEquivalence(equivalence);
  lp.setAccuracyMethod(HeuristicType.FMEASURE);
  lp.setUseApproximations(false);
  lp.setMaxExecutionTimeInSeconds(10);
  lp.init();
  CELOE la=new CELOE(lp,rc);
  la.setMaxExecutionTimeInSeconds(10);
  la.setNoisePercentage(25);
  la.setMaxNrOfResults(100);
  la.init();
  startTime=System.currentTimeMillis();
  System.out.print(""String_Node_Str"" + (equivalence ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  la.start();
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + runTime + ""String_Node_Str"");
  List<? extends EvaluatedDescription<? extends Score>> learnedDescriptions=la.getCurrentlyBestEvaluatedDescriptions(threshold);
  List<EvaluatedAxiom<OWLAxiom>> learnedAxioms=new LinkedList<EvaluatedAxiom<OWLAxiom>>();
  for (  EvaluatedDescription<? extends Score> learnedDescription : learnedDescriptions) {
    OWLAxiom axiom;
    if (equivalence) {
      axiom=dataFactory.getOWLEquivalentClassesAxiom(nc,learnedDescription.getDescription());
    }
 else {
      axiom=dataFactory.getOWLSubClassOfAxiom(nc,learnedDescription.getDescription());
    }
    Score score=lp.computeScore(learnedDescription.getDescription());
    learnedAxioms.add(new EvaluatedAxiom<OWLAxiom>(axiom,new AxiomScore(score.getAccuracy())));
  }
  System.out.println(prettyPrint(learnedAxioms));
  learnedEvaluatedAxioms.addAll(learnedAxioms);
  algorithmRuns.add(new AlgorithmRun(CELOE.class,learnedAxioms,ConfigHelper.getConfigOptionValues(la)));
  return learnedAxioms;
}"
9355,"private List<EvaluatedAxiom> applyCELOE(SparqlEndpointKS ks,OWLClass nc,boolean equivalence,boolean reuseKnowledgeSource,double threshold) throws ComponentInitException {
  SPARQLReasoner sr=new SPARQLReasoner(ks);
  SortedSet<OWLIndividual> posExamples=sr.getIndividuals(nc,20);
  if (posExamples.isEmpty()) {
    System.out.println(""String_Node_Str"" + nc.toString() + ""String_Node_Str"");
    return Collections.emptyList();
  }
  SortedSet<String> posExStr=Helper.getStringSet(posExamples);
  long startTime=System.currentTimeMillis();
  System.out.print(""String_Node_Str"");
  AutomaticNegativeExampleFinderSPARQL2 finder=new AutomaticNegativeExampleFinderSPARQL2(ks.getEndpoint());
  SortedSet<OWLIndividual> negExamples=finder.getNegativeExamples(nc,posExamples,20);
  SortedSetTuple<OWLIndividual> examples=new SortedSetTuple<OWLIndividual>(posExamples,negExamples);
  long runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + negExamples.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
  SparqlKnowledgeSource ks2;
  AbstractReasonerComponent rc;
  ks2=new SparqlKnowledgeSource();
  ks2.setInstances(Datastructures.individualSetToStringSet(examples.getCompleteSet()));
  ks2.setUrl(ks.getEndpoint().getURL());
  ks2.setDefaultGraphURIs(new TreeSet<String>(ks.getEndpoint().getDefaultGraphURIs()));
  ks2.setUseLits(false);
  ks2.setUseCacheDatabase(true);
  ks2.setCacheDir(cacheDir);
  ks2.setRecursionDepth(2);
  ks2.setCloseAfterRecursion(true);
  ks2.setDissolveBlankNodes(false);
  ks2.setSaveExtractedFragment(true);
  startTime=System.currentTimeMillis();
  System.out.print(""String_Node_Str"");
  ks2.init();
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + runTime + ""String_Node_Str"");
  rc=new ClosedWorldReasoner(ks2);
  rc.init();
  ClassLearningProblem lp=new ClassLearningProblem(rc);
  lp.setClassToDescribe(nc);
  lp.setEquivalence(equivalence);
  lp.setHeuristic(HeuristicType.FMEASURE);
  lp.setUseApproximations(false);
  lp.setMaxExecutionTimeInSeconds(10);
  lp.init();
  CELOE la=new CELOE(lp,rc);
  la.setMaxExecutionTimeInSeconds(10);
  la.setNoisePercentage(25);
  la.init();
  startTime=System.currentTimeMillis();
  System.out.print(""String_Node_Str"" + (equivalence ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  la.start();
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + runTime + ""String_Node_Str"");
  List<? extends EvaluatedDescription<? extends Score>> learnedDescriptions=la.getCurrentlyBestEvaluatedDescriptions(threshold);
  List<EvaluatedAxiom> learnedAxioms=new LinkedList<EvaluatedAxiom>();
  for (  EvaluatedDescription<? extends Score> learnedDescription : learnedDescriptions) {
    OWLAxiom axiom;
    if (equivalence) {
      axiom=dataFactory.getOWLEquivalentClassesAxiom(nc,learnedDescription.getDescription());
    }
 else {
      axiom=dataFactory.getOWLSubClassOfAxiom(nc,learnedDescription.getDescription());
    }
    Score score=lp.computeScore(learnedDescription.getDescription());
    learnedAxioms.add(new EvaluatedAxiom(axiom,new AxiomScore(score.getAccuracy())));
  }
  return learnedAxioms;
}","private List<EvaluatedAxiom> applyCELOE(SparqlEndpointKS ks,OWLClass nc,boolean equivalence,boolean reuseKnowledgeSource,double threshold) throws ComponentInitException {
  SPARQLReasoner sr=new SPARQLReasoner(ks);
  SortedSet<OWLIndividual> posExamples=sr.getIndividuals(nc,20);
  if (posExamples.isEmpty()) {
    System.out.println(""String_Node_Str"" + nc.toString() + ""String_Node_Str"");
    return Collections.emptyList();
  }
  SortedSet<String> posExStr=Helper.getStringSet(posExamples);
  long startTime=System.currentTimeMillis();
  System.out.print(""String_Node_Str"");
  AutomaticNegativeExampleFinderSPARQL2 finder=new AutomaticNegativeExampleFinderSPARQL2(ks.getEndpoint());
  SortedSet<OWLIndividual> negExamples=finder.getNegativeExamples(nc,posExamples,20);
  SortedSetTuple<OWLIndividual> examples=new SortedSetTuple<OWLIndividual>(posExamples,negExamples);
  long runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + negExamples.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
  SparqlKnowledgeSource ks2;
  AbstractReasonerComponent rc;
  ks2=new SparqlKnowledgeSource();
  ks2.setInstances(Datastructures.individualSetToStringSet(examples.getCompleteSet()));
  ks2.setUrl(ks.getEndpoint().getURL());
  ks2.setDefaultGraphURIs(new TreeSet<String>(ks.getEndpoint().getDefaultGraphURIs()));
  ks2.setUseLits(false);
  ks2.setUseCacheDatabase(true);
  ks2.setCacheDir(cacheDir);
  ks2.setRecursionDepth(2);
  ks2.setCloseAfterRecursion(true);
  ks2.setDissolveBlankNodes(false);
  ks2.setSaveExtractedFragment(true);
  startTime=System.currentTimeMillis();
  System.out.print(""String_Node_Str"");
  ks2.init();
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + runTime + ""String_Node_Str"");
  rc=new ClosedWorldReasoner(ks2);
  rc.init();
  ClassLearningProblem lp=new ClassLearningProblem(rc);
  lp.setClassToDescribe(nc);
  lp.setEquivalence(equivalence);
  lp.setAccuracyMethod(HeuristicType.FMEASURE);
  lp.setUseApproximations(false);
  lp.setMaxExecutionTimeInSeconds(10);
  lp.init();
  CELOE la=new CELOE(lp,rc);
  la.setMaxExecutionTimeInSeconds(10);
  la.setNoisePercentage(25);
  la.init();
  startTime=System.currentTimeMillis();
  System.out.print(""String_Node_Str"" + (equivalence ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  la.start();
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + runTime + ""String_Node_Str"");
  List<? extends EvaluatedDescription<? extends Score>> learnedDescriptions=la.getCurrentlyBestEvaluatedDescriptions(threshold);
  List<EvaluatedAxiom> learnedAxioms=new LinkedList<EvaluatedAxiom>();
  for (  EvaluatedDescription<? extends Score> learnedDescription : learnedDescriptions) {
    OWLAxiom axiom;
    if (equivalence) {
      axiom=dataFactory.getOWLEquivalentClassesAxiom(nc,learnedDescription.getDescription());
    }
 else {
      axiom=dataFactory.getOWLSubClassOfAxiom(nc,learnedDescription.getDescription());
    }
    Score score=lp.computeScore(learnedDescription.getDescription());
    learnedAxioms.add(new EvaluatedAxiom(axiom,new AxiomScore(score.getAccuracy())));
  }
  return learnedAxioms;
}"
9356,"public Enrichment(SparqlEndpointKS ks,OWLEntity resource,double threshold,int nrOfAxiomsToLearn,boolean useInference,boolean verbose,int chunksize,int maxExecutionTimeInSeconds,boolean omitExistingAxioms){
  this.ks=ks;
  this.resource=resource;
  this.verbose=verbose;
  this.threshold=threshold;
  this.nrOfAxiomsToLearn=nrOfAxiomsToLearn;
  this.useInference=useInference;
  this.chunksize=chunksize;
  this.maxExecutionTimeInSeconds=maxExecutionTimeInSeconds;
  this.omitExistingAxioms=omitExistingAxioms;
  if (ks.isRemote()) {
    try {
      cacheDir=""String_Node_Str"" + File.separator + URLEncoder.encode(ks.getEndpoint().getURL().toString(),""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException e) {
      e.printStackTrace();
    }
  }
  classAlgorithms=new LinkedList<Class<? extends LearningAlgorithm>>();
  classAlgorithms.add(CELOE.class);
  algorithmRuns=new LinkedList<AlgorithmRun>();
  learnedOWLAxioms=new HashSet<OWLAxiom>();
  learnedEvaluatedAxioms=new HashSet<EvaluatedAxiom>();
}","public Enrichment(SparqlEndpointKS ks,OWLEntity resource,double threshold,int nrOfAxiomsToLearn,boolean useInference,boolean verbose,int chunksize,int maxExecutionTimeInSeconds,boolean omitExistingAxioms){
  this.ks=ks;
  this.resource=resource;
  this.verbose=verbose;
  this.threshold=threshold;
  this.nrOfAxiomsToLearn=nrOfAxiomsToLearn;
  this.useInference=useInference;
  this.chunksize=chunksize;
  this.maxExecutionTimeInSeconds=maxExecutionTimeInSeconds;
  this.omitExistingAxioms=omitExistingAxioms;
  try {
    ks.init();
  }
 catch (  ComponentInitException e1) {
    e1.printStackTrace();
  }
  if (ks.isRemote()) {
    try {
      cacheDir=""String_Node_Str"" + File.separator + URLEncoder.encode(ks.getEndpoint().getURL().toString(),""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException e) {
      e.printStackTrace();
    }
  }
  classAlgorithms=new LinkedList<Class<? extends LearningAlgorithm>>();
  classAlgorithms.add(CELOE.class);
  algorithmRuns=new LinkedList<AlgorithmRun>();
  learnedOWLAxioms=new HashSet<OWLAxiom>();
  learnedEvaluatedAxioms=new HashSet<EvaluatedAxiom>();
}"
9357,"public static void main(String[] args) throws IOException, ComponentInitException, IllegalArgumentException, SecurityException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, LearningProblemUnsupportedException {
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  Logger.getRootLogger().setLevel(Level.WARN);
  Logger.getLogger(""String_Node_Str"").setLevel(Level.WARN);
  Logger.getRootLogger().removeAllAppenders();
  Logger.getRootLogger().addAppender(consoleAppender);
  OptionParser parser=new OptionParser();
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(URL.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(URI.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(URI.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(File.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(String.class).defaultsTo(""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Double.class).defaultsTo(0.7);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Integer.class).defaultsTo(10);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(false);
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(false);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(File.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(true);
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(1000);
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(10);
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(false);
  OptionSpec<String> allowedNamespacesOption=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(String.class).withValuesSeparatedBy(',');
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(true);
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(true);
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(true);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(String.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(String.class);
  OptionSet options=null;
  if (args.length == 0) {
    parser.printHelpOn(System.out);
    System.exit(0);
  }
  try {
    options=parser.parse(args);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
    System.exit(0);
  }
  if (options.has(""String_Node_Str"")) {
    parser.printHelpOn(System.out);
    String addHelp=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    System.out.println();
    System.out.println(addHelp);
  }
 else {
    if (!options.hasArgument(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
    SparqlEndpointKS ks=null;
    URL endpoint=null;
    try {
      endpoint=(URL)options.valueOf(""String_Node_Str"");
    }
 catch (    OptionException e) {
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
    try {
      if (isLocalFile(endpoint)) {
        File file=new File(endpoint.toURI());
        if (file.exists()) {
          Model kbModel=ModelFactory.createDefaultModel();
          kbModel.read(new FileInputStream(file),null);
          ks=new LocalModelBasedSparqlEndpointKS(kbModel);
        }
      }
 else {
        URI graph=null;
        try {
          graph=(URI)options.valueOf(""String_Node_Str"");
        }
 catch (        OptionException e) {
          System.out.println(""String_Node_Str"");
          System.exit(0);
        }
        LinkedList<String> defaultGraphURIs=new LinkedList<String>();
        if (graph != null) {
          defaultGraphURIs.add(graph.toString());
        }
        SparqlEndpoint se=new SparqlEndpoint(endpoint,defaultGraphURIs,new LinkedList<String>());
        String cacheDir=System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"";
        ks=new SparqlEndpointKS(se,cacheDir);
      }
    }
 catch (    URISyntaxException e2) {
      e2.printStackTrace();
    }
    URI resourceURI=null;
    try {
      resourceURI=(URI)options.valueOf(""String_Node_Str"");
    }
 catch (    OptionException e) {
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
    if (options.has(""String_Node_Str"") && options.has(""String_Node_Str"")) {
      final String username=(String)options.valueOf(""String_Node_Str"");
      final String password=(String)options.valueOf(""String_Node_Str"");
      Authenticator.setDefault(new Authenticator(){
        @Override protected PasswordAuthentication getPasswordAuthentication(){
          return new PasswordAuthentication(username,password.toCharArray());
        }
      }
);
    }
    if (ks.isRemote()) {
      String query=""String_Node_Str"";
      SparqlQuery sq=new SparqlQuery(query,ks.getEndpoint());
      try {
        ResultSet q=sq.send();
        while (q.hasNext()) {
          q.next();
        }
      }
 catch (      QueryExceptionHTTP e) {
        System.out.println(""String_Node_Str"");
        System.exit(0);
      }
    }
    OWLEntity resource=null;
    if (options.valueOf(""String_Node_Str"") != null) {
      resource=new SPARQLTasks(((SparqlEndpointKS)ks).getEndpoint()).guessResourceType(resourceURI.toString(),true);
      if (resource == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + options.valueOf(""String_Node_Str"") + ""String_Node_Str"");
      }
    }
    boolean useInference=(Boolean)options.valueOf(""String_Node_Str"");
    boolean iterativeMode=(Boolean)options.valueOf(""String_Node_Str"");
    double threshold=(Double)options.valueOf(""String_Node_Str"");
    int maxNrOfResults=(Integer)options.valueOf(""String_Node_Str"");
    if (maxNrOfResults == -1) {
      maxNrOfResults=Integer.MAX_VALUE;
    }
    int chunksize=(Integer)options.valueOf(""String_Node_Str"");
    int maxExecutionTimeInSeconds=(Integer)options.valueOf(""String_Node_Str"");
    boolean omitExistingAxioms=(Boolean)options.valueOf(""String_Node_Str"");
    File f=(File)options.valueOf(""String_Node_Str"");
    if (options.has(""String_Node_Str"") && (!options.has(""String_Node_Str"") || options.valueOf(""String_Node_Str"").equals(""String_Node_Str""))) {
      PrintStream printStream=new PrintStream(new FileOutputStream(f));
      System.setOut(printStream);
    }
    List<String> allowedNamespaces=options.valuesOf(allowedNamespacesOption);
    boolean processObjectProperties=(Boolean)options.valueOf(""String_Node_Str"");
    boolean processDataProperties=(Boolean)options.valueOf(""String_Node_Str"");
    boolean processClasses=(Boolean)options.valueOf(""String_Node_Str"");
    Enrichment e=new Enrichment(ks,resource,threshold,maxNrOfResults,useInference,false,chunksize,maxExecutionTimeInSeconds,omitExistingAxioms);
    e.setAllowedNamespaces(allowedNamespaces);
    e.setIterativeMode(iterativeMode);
    e.setProcessObjectProperties(processObjectProperties);
    e.setProcessDataProperties(processDataProperties);
    e.setProcessClasses(processClasses);
    e.start();
    if (options.has(""String_Node_Str"")) {
      List<AlgorithmRun> runs=e.getAlgorithmRuns();
      List<OWLAxiom> axioms=new LinkedList<OWLAxiom>();
      for (      AlgorithmRun run : runs) {
        axioms.addAll(e.toRDF(run.getAxioms(),run.getAlgorithm(),run.getParameters(),ks));
      }
      Model model=e.getModel(axioms);
      OutputStream os=options.has(""String_Node_Str"") ? new FileOutputStream((File)options.valueOf(""String_Node_Str"")) : System.out;
      if (options.valueOf(""String_Node_Str"").equals(""String_Node_Str"")) {
        if (options.has(""String_Node_Str"")) {
          model.write(new FileOutputStream(f),""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
          model.write(System.out,""String_Node_Str"");
          System.out.println(""String_Node_Str"");
        }
      }
 else       if (options.valueOf(""String_Node_Str"").equals(""String_Node_Str"")) {
        if (options.has(""String_Node_Str"")) {
          model.write(new FileOutputStream(f),""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
          model.write(System.out,""String_Node_Str"");
          System.out.println(""String_Node_Str"");
        }
      }
 else       if (options.valueOf(""String_Node_Str"").equals(""String_Node_Str"")) {
        if (options.has(""String_Node_Str"")) {
          model.write(new FileOutputStream(f),""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
          model.write(System.out,""String_Node_Str"");
          System.out.println(""String_Node_Str"");
        }
      }
    }
    if (options.has(""String_Node_Str"")) {
      File file=(File)options.valueOf(""String_Node_Str"");
      try {
        OWLOntology ontology=e.getGeneratedOntology(options.has(""String_Node_Str""));
        OutputStream os=new BufferedOutputStream(new FileOutputStream(file));
        OWLManager.createOWLOntologyManager().saveOntology(ontology,new RDFXMLOntologyFormat(),os);
      }
 catch (      OWLOntologyStorageException e1) {
        throw new Error(""String_Node_Str"");
      }
    }
  }
}","public static void main(String[] args) throws IOException, ComponentInitException, IllegalArgumentException, SecurityException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, LearningProblemUnsupportedException {
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  Logger.getRootLogger().setLevel(Level.WARN);
  Logger.getLogger(""String_Node_Str"").setLevel(Level.WARN);
  Logger.getRootLogger().removeAllAppenders();
  Logger.getRootLogger().addAppender(consoleAppender);
  OptionParser parser=new OptionParser();
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(URL.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(URI.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(URI.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(File.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(String.class).defaultsTo(""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Double.class).defaultsTo(0.7);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Integer.class).defaultsTo(10);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(false);
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(false);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(File.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(true);
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(1000);
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(10);
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(false);
  OptionSpec<String> allowedNamespacesOption=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(String.class).withValuesSeparatedBy(',');
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(true);
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(true);
  parser.acceptsAll(asList(""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(true);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(String.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(String.class);
  OptionSet options=null;
  if (args.length == 0) {
    parser.printHelpOn(System.out);
    System.exit(0);
  }
  try {
    options=parser.parse(args);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
    System.exit(0);
  }
  if (options.has(""String_Node_Str"")) {
    parser.printHelpOn(System.out);
    String addHelp=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    System.out.println();
    System.out.println(addHelp);
  }
 else {
    if (!options.hasArgument(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
    SparqlEndpointKS ks=null;
    URL endpoint=null;
    try {
      endpoint=(URL)options.valueOf(""String_Node_Str"");
    }
 catch (    OptionException e) {
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
    try {
      if (isLocalFile(endpoint)) {
        File file=new File(endpoint.toURI());
        if (file.exists()) {
          Model kbModel=ModelFactory.createDefaultModel();
          kbModel.read(new FileInputStream(file),null);
          ks=new LocalModelBasedSparqlEndpointKS(kbModel);
        }
      }
 else {
        URI graph=null;
        try {
          graph=(URI)options.valueOf(""String_Node_Str"");
        }
 catch (        OptionException e) {
          System.out.println(""String_Node_Str"");
          System.exit(0);
        }
        LinkedList<String> defaultGraphURIs=new LinkedList<String>();
        if (graph != null) {
          defaultGraphURIs.add(graph.toString());
        }
        SparqlEndpoint se=new SparqlEndpoint(endpoint,defaultGraphURIs,new LinkedList<String>());
        String cacheDir=System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"";
        ks=new SparqlEndpointKS(se,cacheDir);
      }
      ks.init();
    }
 catch (    URISyntaxException e2) {
      e2.printStackTrace();
    }
    URI resourceURI=null;
    try {
      resourceURI=(URI)options.valueOf(""String_Node_Str"");
    }
 catch (    OptionException e) {
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
    if (options.has(""String_Node_Str"") && options.has(""String_Node_Str"")) {
      final String username=(String)options.valueOf(""String_Node_Str"");
      final String password=(String)options.valueOf(""String_Node_Str"");
      Authenticator.setDefault(new Authenticator(){
        @Override protected PasswordAuthentication getPasswordAuthentication(){
          return new PasswordAuthentication(username,password.toCharArray());
        }
      }
);
    }
    if (ks.isRemote()) {
      String query=""String_Node_Str"";
      SparqlQuery sq=new SparqlQuery(query,ks.getEndpoint());
      try {
        ResultSet q=sq.send();
        while (q.hasNext()) {
          q.next();
        }
      }
 catch (      QueryExceptionHTTP e) {
        System.out.println(""String_Node_Str"");
        System.exit(0);
      }
    }
    OWLEntity resource=null;
    if (options.valueOf(""String_Node_Str"") != null) {
      resource=new SPARQLTasks(((SparqlEndpointKS)ks).getEndpoint()).guessResourceType(resourceURI.toString(),true);
      if (resource == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + options.valueOf(""String_Node_Str"") + ""String_Node_Str"");
      }
    }
    boolean useInference=(Boolean)options.valueOf(""String_Node_Str"");
    boolean iterativeMode=(Boolean)options.valueOf(""String_Node_Str"");
    double threshold=(Double)options.valueOf(""String_Node_Str"");
    int maxNrOfResults=(Integer)options.valueOf(""String_Node_Str"");
    if (maxNrOfResults == -1) {
      maxNrOfResults=Integer.MAX_VALUE;
    }
    int chunksize=(Integer)options.valueOf(""String_Node_Str"");
    int maxExecutionTimeInSeconds=(Integer)options.valueOf(""String_Node_Str"");
    boolean omitExistingAxioms=(Boolean)options.valueOf(""String_Node_Str"");
    File f=(File)options.valueOf(""String_Node_Str"");
    if (options.has(""String_Node_Str"") && (!options.has(""String_Node_Str"") || options.valueOf(""String_Node_Str"").equals(""String_Node_Str""))) {
      PrintStream printStream=new PrintStream(new FileOutputStream(f));
      System.setOut(printStream);
    }
    List<String> allowedNamespaces=options.valuesOf(allowedNamespacesOption);
    boolean processObjectProperties=(Boolean)options.valueOf(""String_Node_Str"");
    boolean processDataProperties=(Boolean)options.valueOf(""String_Node_Str"");
    boolean processClasses=(Boolean)options.valueOf(""String_Node_Str"");
    Enrichment e=new Enrichment(ks,resource,threshold,maxNrOfResults,useInference,false,chunksize,maxExecutionTimeInSeconds,omitExistingAxioms);
    e.setAllowedNamespaces(allowedNamespaces);
    e.setIterativeMode(iterativeMode);
    e.setProcessObjectProperties(processObjectProperties);
    e.setProcessDataProperties(processDataProperties);
    e.setProcessClasses(processClasses);
    e.start();
    if (options.has(""String_Node_Str"")) {
      List<AlgorithmRun> runs=e.getAlgorithmRuns();
      List<OWLAxiom> axioms=new LinkedList<OWLAxiom>();
      for (      AlgorithmRun run : runs) {
        axioms.addAll(e.toRDF(run.getAxioms(),run.getAlgorithm(),run.getParameters(),ks));
      }
      Model model=e.getModel(axioms);
      OutputStream os=options.has(""String_Node_Str"") ? new FileOutputStream((File)options.valueOf(""String_Node_Str"")) : System.out;
      if (options.valueOf(""String_Node_Str"").equals(""String_Node_Str"")) {
        if (options.has(""String_Node_Str"")) {
          model.write(new FileOutputStream(f),""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
          model.write(System.out,""String_Node_Str"");
          System.out.println(""String_Node_Str"");
        }
      }
 else       if (options.valueOf(""String_Node_Str"").equals(""String_Node_Str"")) {
        if (options.has(""String_Node_Str"")) {
          model.write(new FileOutputStream(f),""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
          model.write(System.out,""String_Node_Str"");
          System.out.println(""String_Node_Str"");
        }
      }
 else       if (options.valueOf(""String_Node_Str"").equals(""String_Node_Str"")) {
        if (options.has(""String_Node_Str"")) {
          model.write(new FileOutputStream(f),""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
          model.write(System.out,""String_Node_Str"");
          System.out.println(""String_Node_Str"");
        }
      }
    }
    if (options.has(""String_Node_Str"")) {
      File file=(File)options.valueOf(""String_Node_Str"");
      try {
        OWLOntology ontology=e.getGeneratedOntology(options.has(""String_Node_Str""));
        OutputStream os=new BufferedOutputStream(new FileOutputStream(file));
        OWLManager.createOWLOntologyManager().saveOntology(ontology,new RDFXMLOntologyFormat(),os);
      }
 catch (      OWLOntologyStorageException e1) {
        throw new Error(""String_Node_Str"");
      }
    }
  }
}"
9358,"/** 
 * Set the file-based cache directory. Default is the temporary folder of the operating system retrieved by using java.io.tmpdir,  i.e. in most cases <table> <tr><th>OS</th><th>Directory</th></tr> <tr><td>Linux</td><td>/tmp/</td></tr> <tr><td>Windows</td><td>C:\temp</td></tr> </table>
 * @param cacheDir the absolute cache directory path
 */
public void setCacheDir(String cacheDir){
  this.cacheDir=cacheDir;
}","/** 
 * Set the file-based cache directory. Default is the temporary folder of the operating system retrieved by using java.io.tmpdir, i.e. in most cases <table> <tr><th>OS</th><th>Directory</th></tr> <tr><td>Linux</td><td>/tmp/</td></tr> <tr><td>Windows</td><td>C:\temp</td></tr> </table>
 * @param cacheDir the absolute cache directory path
 */
public void setCacheDir(String cacheDir){
  this.cacheDir=cacheDir;
}"
9359,"@Override public String toString(){
  String out=String.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  out+=String.format(""String_Node_Str"",""String_Node_Str"",qef.getId());
  out+=String.format(""String_Node_Str"",""String_Node_Str"",cacheDir);
  out+=String.format(""String_Node_Str"",""String_Node_Str"",queryDelay);
  return out;
}","@Override public String toString(){
  String out=String.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (qef != null) {
    out+=String.format(""String_Node_Str"",""String_Node_Str"",qef.getId());
  }
 else {
    out+=String.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  out+=String.format(""String_Node_Str"",""String_Node_Str"",cacheDir);
  out+=String.format(""String_Node_Str"",""String_Node_Str"",queryDelay);
  return out;
}"
9360,"public void setBaseDir(String baseDir){
  if (baseDir.startsWith(""String_Node_Str""))   baseDir=baseDir.substring(5);
  this.baseDir=baseDir;
}","public void setBaseDir(String baseDir){
  this.baseDir=baseDir;
}"
9361,"/** 
 * @param args
 * @throws ParseException 
 * @throws IOException 
 * @throws ReasoningMethodUnsupportedException 
 */
public static void main(String[] args) throws ParseException, IOException, ReasoningMethodUnsupportedException {
  System.out.println(""String_Node_Str"");
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  File file=new File(args[args.length - 1]);
  if (!file.exists()) {
    System.out.println(""String_Node_Str"" + file + ""String_Node_Str"");
    System.exit(0);
  }
  Resource confFile=new FileSystemResource(file);
  List<Resource> springConfigResources=new ArrayList<Resource>();
  try {
    IConfiguration configuration=new ConfParserConfiguration(confFile);
    ApplicationContextBuilder builder=new DefaultApplicationContextBuilder();
    ApplicationContext context=builder.buildApplicationContext(configuration,springConfigResources);
    CLI cli;
    if (context.containsBean(""String_Node_Str"")) {
      cli=(CLI)context.getBean(""String_Node_Str"");
    }
 else {
      cli=new CLI();
    }
    cli.setContext(context);
    cli.setConfFile(file);
    cli.run();
  }
 catch (  Exception e) {
    e.printStackTrace();
    String stacktraceFileName=""String_Node_Str"";
    Throwable primaryCause=findPrimaryCause(e);
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",e);
    logger.error(""String_Node_Str"" + stacktraceFileName);
    FileOutputStream fos=new FileOutputStream(stacktraceFileName);
    PrintStream ps=new PrintStream(fos);
    e.printStackTrace(ps);
  }
}","/** 
 * @param args
 * @throws ParseException 
 * @throws IOException 
 * @throws ReasoningMethodUnsupportedException 
 */
public static void main(String[] args) throws ParseException, IOException, ReasoningMethodUnsupportedException {
  System.out.println(""String_Node_Str"");
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  File file=new File(args[args.length - 1]);
  if (!file.exists()) {
    System.out.println(""String_Node_Str"" + file + ""String_Node_Str"");
    System.exit(0);
  }
  Resource confFile=new FileSystemResource(file);
  List<Resource> springConfigResources=new ArrayList<Resource>();
  try {
    IConfiguration configuration=new ConfParserConfiguration(confFile);
    ApplicationContextBuilder builder=new DefaultApplicationContextBuilder();
    ApplicationContext context=builder.buildApplicationContext(configuration,springConfigResources);
    CLI cli;
    if (context.containsBean(""String_Node_Str"")) {
      cli=(CLI)context.getBean(""String_Node_Str"");
    }
 else {
      cli=new CLI();
    }
    cli.setContext(context);
    cli.setConfFile(file);
    cli.run();
  }
 catch (  Exception e) {
    String stacktraceFileName=""String_Node_Str"";
    Throwable primaryCause=findPrimaryCause(e);
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",e);
    logger.error(""String_Node_Str"" + stacktraceFileName);
    FileOutputStream fos=new FileOutputStream(stacktraceFileName);
    PrintStream ps=new PrintStream(fos);
    e.printStackTrace(ps);
  }
}"
9362,"public ConfParserConfiguration(Resource source){
  try {
    if (!(source instanceof InputStreamResource)) {
      baseDir=source.getFile().getAbsoluteFile().getParentFile().toURI().toString();
    }
 else {
      baseDir=null;
    }
    parser=new ConfParser(source.getInputStream());
    parser.Start();
    Rendering rendering=Rendering.MANCHESTER_SYNTAX;
    ConfFileOption renderingOption=parser.getConfOptionsByProperty(""String_Node_Str"");
    if (renderingOption != null) {
      String syntax=renderingOption.getPropertyValue();
      for (      Rendering r : Rendering.values()) {
        if (syntax.equals(r.getName())) {
          rendering=r;
        }
      }
    }
    ToStringRenderer.getInstance().setRenderer(rendering.getRenderer());
  }
 catch (  ParseException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public ConfParserConfiguration(Resource source){
  try {
    if (!(source instanceof InputStreamResource)) {
      baseDir=source.getFile().getAbsoluteFile().getParentFile().getAbsolutePath();
    }
 else {
      baseDir=null;
    }
    parser=new ConfParser(source.getInputStream());
    parser.Start();
    Rendering rendering=Rendering.MANCHESTER_SYNTAX;
    ConfFileOption renderingOption=parser.getConfOptionsByProperty(""String_Node_Str"");
    if (renderingOption != null) {
      String syntax=renderingOption.getPropertyValue();
      for (      Rendering r : Rendering.values()) {
        if (syntax.equals(r.getName())) {
          rendering=r;
        }
      }
    }
    ToStringRenderer.getInstance().setRenderer(rendering.getRenderer());
  }
 catch (  ParseException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
9363,"@Override public void init() throws ComponentInitException {
  setReasoning(getReasoningString());
  if (sparql != null) {
    StringBuilder sb=new StringBuilder();
    sb.append(url.toString());
    sb.append(""String_Node_Str"").append(URLencodeUTF8.encode(sparql));
    sb.append(""String_Node_Str"");
    for (    String graph : defaultGraphURIs) {
      sb.append(""String_Node_Str"").append(URLencodeUTF8.encode(graph));
    }
    for (    String graph : namedGraphURIs) {
      sb.append(""String_Node_Str"").append(URLencodeUTF8.encode(graph));
    }
    logger.info(sb.toString());
    try {
      url=new URL(sb.toString());
    }
 catch (    MalformedURLException e) {
      throw new RuntimeException(e);
    }
  }
 else   if (url == null) {
    try {
      Path path;
      if (fileName.startsWith(""String_Node_Str"")) {
        path=Paths.get(fileName);
      }
 else {
        path=Paths.get(baseDir,fileName);
      }
      System.out.println(path);
      System.out.println(path.normalize());
      System.out.println(path.normalize().toUri());
      url=path.normalize().toUri().toURL();
    }
 catch (    MalformedURLException e) {
      throw new RuntimeException(e);
    }
  }
}","@Override public void init() throws ComponentInitException {
  setReasoning(getReasoningString());
  if (sparql != null) {
    StringBuilder sb=new StringBuilder();
    sb.append(url.toString());
    sb.append(""String_Node_Str"").append(URLencodeUTF8.encode(sparql));
    sb.append(""String_Node_Str"");
    for (    String graph : defaultGraphURIs) {
      sb.append(""String_Node_Str"").append(URLencodeUTF8.encode(graph));
    }
    for (    String graph : namedGraphURIs) {
      sb.append(""String_Node_Str"").append(URLencodeUTF8.encode(graph));
    }
    logger.info(sb.toString());
    try {
      url=new URL(sb.toString());
    }
 catch (    MalformedURLException e) {
      throw new RuntimeException(e);
    }
  }
 else   if (url == null) {
    try {
      Path path;
      if (fileName.startsWith(""String_Node_Str"")) {
        path=Paths.get(fileName);
      }
 else {
        path=Paths.get(baseDir,fileName);
      }
      url=path.normalize().toUri().toURL();
    }
 catch (    MalformedURLException e) {
      throw new RuntimeException(e);
    }
  }
}"
9364,"public void setBaseDir(String baseDir){
  this.baseDir=baseDir;
}","public void setBaseDir(String baseDir){
  if (baseDir.startsWith(""String_Node_Str""))   baseDir=baseDir.substring(5);
  this.baseDir=baseDir;
}"
9365,"private <T extends Number & Comparable<T>>List<T> computeSplitValues(OWLDataProperty dp){
  Set<T> valuesSet=new TreeSet<T>();
  Map<OWLIndividual,SortedSet<T>> ind2Values=reasoner.getNumericDatatypeMembers(dp);
  for (  Entry<OWLIndividual,SortedSet<T>> e : ind2Values.entrySet()) {
    valuesSet.addAll(e.getValue());
  }
  List<T> values=new LinkedList<T>(valuesSet);
  Collections.sort(values);
  int nrOfValues=values.size();
  List<T> splitsDP=new LinkedList<T>();
  for (int splitNr=0; splitNr < Math.min(maxNrOfSplits,nrOfValues - 1); splitNr++) {
    int index;
    if (nrOfValues <= maxNrOfSplits) {
      index=splitNr;
    }
 else {
      index=(int)Math.floor(splitNr * (double)nrOfValues / (maxNrOfSplits + 1));
    }
    index=Math.max(0,(int)Math.floor(splitNr * (double)nrOfValues / (maxNrOfSplits) - 1));
    T number1=values.get(index);
    T number2=values.get(index + 1);
    T avg=avg(number1,number2);
    splitsDP.add(avg);
  }
  if (nrOfValues > 0)   splitsDP.add(values.get(nrOfValues - 1));
  return splitsDP;
}","private <T extends Number & Comparable<T>>List<T> computeSplitValues(OWLDataProperty dp){
  Set<T> valuesSet=new TreeSet<T>();
  Map<OWLIndividual,SortedSet<T>> ind2Values=reasoner.getNumericDatatypeMembers(dp);
  for (  Entry<OWLIndividual,SortedSet<T>> e : ind2Values.entrySet()) {
    valuesSet.addAll(e.getValue());
  }
  List<T> values=new LinkedList<T>(valuesSet);
  Collections.sort(values);
  int nrOfValues=values.size();
  List<T> splitsDP=new LinkedList<T>();
  if (nrOfValues > 0) {
    splitsDP.add(values.get(0));
  }
  for (int splitNr=0; splitNr < Math.min(maxNrOfSplits,nrOfValues - 1); splitNr++) {
    int index;
    if (nrOfValues <= maxNrOfSplits) {
      index=splitNr;
    }
 else {
      index=(int)Math.floor(splitNr * (double)nrOfValues / (maxNrOfSplits + 1));
    }
    index=Math.max(index,(int)Math.floor(splitNr * (double)nrOfValues / (maxNrOfSplits) - 1));
    T number1=values.get(index);
    T number2=values.get(index + 1);
    T avg=avg(number1,number2);
    splitsDP.add(avg);
  }
  if (nrOfValues > 1)   splitsDP.add(values.get(nrOfValues - 1));
  return splitsDP;
}"
9366,"/** 
 * Applies all special directives by modifying the conf options.
 */
public void applyAll(){
  ConfFileOption2 prefixOption=directives.get(""String_Node_Str"");
  Map<String,String> prefixes=new TreeMap<>();
  prefixes.put(""String_Node_Str"",OWL.NS);
  prefixes.put(""String_Node_Str"",RDFS.getURI());
  prefixes.put(""String_Node_Str"",RDF.getURI());
  if (prefixOption != null) {
    prefixes.putAll((Map<String,String>)prefixOption.getValueObject());
  }
  for (  ConfFileOption2 option : confOptions) {
    Object valueObject=option.getValue();
    if (valueObject instanceof String) {
      for (      String prefix : prefixes.keySet()) {
        valueObject=((String)valueObject).replaceAll(prefix + ""String_Node_Str"",prefixes.get(prefix));
      }
    }
 else     if (valueObject instanceof Map) {
      valueObject=processStringMap(prefixes,(Map)valueObject);
    }
 else     if (valueObject instanceof Collection) {
      processStringCollection(prefixes,(Collection<?>)valueObject);
    }
 else     if (valueObject instanceof Boolean || valueObject instanceof Integer || valueObject instanceof Double) {
    }
 else {
      throw new Error(""String_Node_Str"" + valueObject.getClass());
    }
    option.setValueObject(valueObject);
  }
}","/** 
 * Applies all special directives by modifying the conf options.
 */
public void applyAll(){
  ConfFileOption2 prefixOption=directives.get(""String_Node_Str"");
  Map<String,String> prefixes=new TreeMap<>();
  prefixes.put(""String_Node_Str"",OWL.NS);
  prefixes.put(""String_Node_Str"",RDFS.getURI());
  prefixes.put(""String_Node_Str"",RDF.getURI());
  if (prefixOption != null) {
    prefixes.putAll((Map<String,String>)prefixOption.getValueObject());
  }
  for (  ConfFileOption2 option : confOptions) {
    Object valueObject=option.getValue();
    if (valueObject instanceof String) {
      String oldValue=(String)valueObject;
      for (      String prefix : prefixes.keySet()) {
        valueObject=oldValue.replaceAll(prefix + ""String_Node_Str"",prefixes.get(prefix));
        if (!oldValue.equals(valueObject))         break;
      }
    }
 else     if (valueObject instanceof Map) {
      valueObject=processStringMap(prefixes,(Map)valueObject);
    }
 else     if (valueObject instanceof Collection) {
      processStringCollection(prefixes,(Collection<?>)valueObject);
    }
 else     if (valueObject instanceof Boolean || valueObject instanceof Integer || valueObject instanceof Double) {
    }
 else {
      throw new Error(""String_Node_Str"" + valueObject.getClass());
    }
    option.setValueObject(valueObject);
  }
}"
9367,"private Map processStringMap(Map<String,String> prefixes,Map inputMap){
  Map newMap=new HashMap();
  for (  Object keyObject : inputMap.keySet()) {
    Object key=keyObject;
    Object value=inputMap.get(key);
    if (keyObject instanceof String) {
      String keyString=(String)keyObject;
      for (      String prefix : prefixes.keySet()) {
        key=keyString.replaceAll(prefix + ""String_Node_Str"",prefixes.get(prefix));
      }
      if (value instanceof String) {
        String valueString=(String)value;
        for (        String prefix : prefixes.keySet()) {
          value=valueString.replaceAll(prefix + ""String_Node_Str"",prefixes.get(prefix));
        }
      }
    }
    newMap.put(key,value);
  }
  return newMap;
}","private Map processStringMap(Map<String,String> prefixes,Map inputMap){
  Map newMap=new HashMap();
  for (  Object keyObject : inputMap.keySet()) {
    Object key=keyObject;
    Object value=inputMap.get(key);
    if (keyObject instanceof String) {
      String keyString=(String)keyObject;
      for (      String prefix : prefixes.keySet()) {
        key=keyString.replaceAll(prefix + ""String_Node_Str"",prefixes.get(prefix));
        if (!key.equals(keyString))         break;
      }
      if (value instanceof String) {
        String valueString=(String)value;
        for (        String prefix : prefixes.keySet()) {
          value=valueString.replaceAll(prefix + ""String_Node_Str"",prefixes.get(prefix));
          if (!value.equals(valueString))           break;
        }
      }
    }
    newMap.put(key,value);
  }
  return newMap;
}"
9368,"public boolean isSymmetric(OWLObjectProperty property){
  String query=""String_Node_Str"" + property + ""String_Node_Str""+ OWL2.SymmetricProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}","public boolean isSymmetric(OWLObjectProperty property){
  String query=""String_Node_Str"" + property.toStringID() + ""String_Node_Str""+ OWL2.SymmetricProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}"
9369,"public boolean isTransitive(OWLObjectProperty property){
  String query=""String_Node_Str"" + property + ""String_Node_Str""+ OWL2.TransitiveProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}","public boolean isTransitive(OWLObjectProperty property){
  String query=""String_Node_Str"" + property.toStringID() + ""String_Node_Str""+ OWL2.TransitiveProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}"
9370,"public boolean isFunctional(OWLDataProperty property){
  String query=""String_Node_Str"" + property + ""String_Node_Str""+ OWL.FunctionalProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}","public boolean isFunctional(OWLDataProperty property){
  String query=""String_Node_Str"" + property.toStringID() + ""String_Node_Str""+ OWL.FunctionalProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}"
9371,"public boolean isIrreflexive(OWLObjectProperty property){
  String query=""String_Node_Str"" + property + ""String_Node_Str""+ OWL2.IrreflexiveProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}","public boolean isIrreflexive(OWLObjectProperty property){
  String query=""String_Node_Str"" + property.toStringID() + ""String_Node_Str""+ OWL2.IrreflexiveProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}"
9372,"public boolean isInverseFunctional(OWLObjectProperty property){
  String query=""String_Node_Str"" + property + ""String_Node_Str""+ OWL.InverseFunctionalProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}","public boolean isInverseFunctional(OWLObjectProperty property){
  String query=""String_Node_Str"" + property.toStringID() + ""String_Node_Str""+ OWL.InverseFunctionalProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}"
9373,"public boolean isAsymmetric(OWLObjectProperty property){
  String query=""String_Node_Str"" + property + ""String_Node_Str""+ OWL2.AsymmetricProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}","public boolean isAsymmetric(OWLObjectProperty property){
  String query=""String_Node_Str"" + property.toStringID() + ""String_Node_Str""+ OWL2.AsymmetricProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}"
9374,"public boolean isReflexive(OWLObjectProperty property){
  String query=""String_Node_Str"" + property + ""String_Node_Str""+ OWL2.ReflexiveProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}","public boolean isReflexive(OWLObjectProperty property){
  String query=""String_Node_Str"" + property.toStringID() + ""String_Node_Str""+ OWL2.ReflexiveProperty.getURI()+ ""String_Node_Str"";
  return qef.createQueryExecution(query).execAsk();
}"
9375,"private boolean isDescriptionAllowed(OWLClassExpression description){
  if (isEquivalenceProblem) {
    if (occursOnFirstLevel(description,classToDescribe)) {
      return false;
    }
    TreeSet<OWLClassExpression> toTest=new TreeSet<OWLClassExpression>();
    if (classToDescribe != null) {
      toTest.add(classToDescribe);
    }
    while (!toTest.isEmpty()) {
      OWLClassExpression d=toTest.pollFirst();
      if (occursOnFirstLevel(description,d)) {
        return false;
      }
      toTest.addAll(reasoner.getEquivalentClasses(d));
    }
  }
 else {
    TreeSet<OWLClassExpression> toTest=new TreeSet<OWLClassExpression>();
    if (classToDescribe != null) {
      toTest.add(classToDescribe);
    }
    while (!toTest.isEmpty()) {
      OWLClassExpression d=toTest.pollFirst();
      if (occursOnFirstLevel(description,d)) {
        return false;
      }
      toTest.addAll(reasoner.getClassHierarchy().getSuperClasses(d));
    }
  }
  return true;
}","private boolean isDescriptionAllowed(OWLClassExpression description){
  if (learningProblem instanceof ClassLearningProblem) {
    if (isEquivalenceProblem) {
      if (occursOnFirstLevel(description,classToDescribe)) {
        return false;
      }
      TreeSet<OWLClassExpression> toTest=new TreeSet<OWLClassExpression>();
      if (classToDescribe != null) {
        toTest.add(classToDescribe);
      }
      while (!toTest.isEmpty()) {
        OWLClassExpression d=toTest.pollFirst();
        if (occursOnFirstLevel(description,d)) {
          return false;
        }
        toTest.addAll(reasoner.getEquivalentClasses(d));
      }
    }
 else {
      TreeSet<OWLClassExpression> toTest=new TreeSet<OWLClassExpression>();
      if (classToDescribe != null) {
        toTest.add(classToDescribe);
      }
      while (!toTest.isEmpty()) {
        OWLClassExpression d=toTest.pollFirst();
        if (occursOnFirstLevel(description,d)) {
          return false;
        }
        toTest.addAll(reasoner.getClassHierarchy().getSuperClasses(d));
      }
    }
    return true;
  }
  return true;
}"
9376,"@Override public void init() throws ComponentInitException {
  if (heuristic == null) {
    heuristic=new StableHeuristic();
  }
  candidates=new TreeSet<SearchTreeNode>(heuristic);
  if (ignoredConcepts != null) {
    Set<OWLClass> usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
    ClassHierarchy classHierarchy=(ClassHierarchy)reasoner.getClassHierarchy().cloneAndRestrict(new HashSet<OWLClassExpression>(usedConcepts));
    classHierarchy.thinOutSubsumptionHierarchy();
  }
  operator=new ELDown3(reasoner,instanceBasedDisjoints);
  operator.setMaxClassExpressionDepth(maxClassExpressionDepth);
  noise=noisePercentage / 100d;
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(maxNrOfResults);
}","@Override public void init() throws ComponentInitException {
  if (heuristic == null) {
    heuristic=new StableHeuristic();
  }
  candidates=new TreeSet<SearchTreeNode>(heuristic);
  if (ignoredConcepts != null) {
    Set<OWLClass> usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
    ClassHierarchy classHierarchy=(ClassHierarchy)reasoner.getClassHierarchy().cloneAndRestrict(new HashSet<OWLClassExpression>(usedConcepts));
    classHierarchy.thinOutSubsumptionHierarchy();
  }
  operator=new ELDown3(reasoner,instanceBasedDisjoints);
  operator.setMaxClassExpressionDepth(maxClassExpressionDepth);
  noise=noisePercentage / 100d;
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(maxNrOfResults);
  timeMonitor=MonitorFactory.getTimeMonitor(""String_Node_Str"");
}"
9377,"public ELLearningAlgorithm(AbstractLearningProblem problem,AbstractReasonerComponent reasoner){
  super(problem,reasoner);
  timeMonitor=MonitorFactory.getTimeMonitor(""String_Node_Str"");
}","public ELLearningAlgorithm(AbstractLearningProblem problem,AbstractReasonerComponent reasoner){
  super(problem,reasoner);
}"
9378,"public Set<OWLObjectProperty> getObjectProperties(OWLClass cls){
  Set<OWLObjectProperty> properties=new TreeSet<>();
  String query=""String_Node_Str"" + cls + ""String_Node_Str"";
  ResultSet rs=executeSelectQuery(query);
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    properties.add(df.getOWLObjectProperty(IRI.create(qs.getResource(""String_Node_Str"").getURI())));
  }
  return properties;
}","public Set<OWLObjectProperty> getObjectProperties(OWLClass cls){
  Set<OWLObjectProperty> properties=new TreeSet<>();
  String query=""String_Node_Str"" + cls.toStringID() + ""String_Node_Str"";
  ResultSet rs=executeSelectQuery(query);
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    properties.add(df.getOWLObjectProperty(IRI.create(qs.getResource(""String_Node_Str"").getURI())));
  }
  return properties;
}"
9379,"public Set<OWLObjectProperty> getObjectPropertiesWithDomain(OWLClass domain){
  Set<OWLObjectProperty> properties=new TreeSet<>();
  String query=""String_Node_Str"" + domain + ""String_Node_Str"";
  ResultSet rs=executeSelectQuery(query);
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    properties.add(df.getOWLObjectProperty(IRI.create(qs.getResource(""String_Node_Str"").getURI())));
  }
  return properties;
}","public Set<OWLObjectProperty> getObjectPropertiesWithDomain(OWLClass domain){
  Set<OWLObjectProperty> properties=new TreeSet<>();
  String query=""String_Node_Str"" + domain.toStringID() + ""String_Node_Str"";
  ResultSet rs=executeSelectQuery(query);
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    properties.add(df.getOWLObjectProperty(IRI.create(qs.getResource(""String_Node_Str"").getURI())));
  }
  return properties;
}"
9380,"@Override public Map<OWLObjectProperty,OWLClassExpression> getObjectPropertyRanges(){
  Map<OWLObjectProperty,OWLClassExpression> result=new HashMap<>();
  String query=SPARQLQueryUtils.PREFIXES + ""String_Node_Str"";
  ResultSet rs=executeSelectQuery(query);
  while (rs.hasNext()) {
    QuerySolution qs=rs.next();
    OWLObjectProperty op=df.getOWLObjectProperty(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLClassExpression range=df.getOWLClass(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    result.put(op,range);
  }
  return result;
}","@Override public Map<OWLObjectProperty,OWLClassExpression> getObjectPropertyRanges(){
  Map<OWLObjectProperty,OWLClassExpression> result=new HashMap<>();
  String query=SPARQLQueryUtils.PREFIXES + ""String_Node_Str"";
  ResultSet rs=executeSelectQuery(query);
  while (rs.hasNext()) {
    QuerySolution qs=rs.next();
    OWLObjectProperty op=df.getOWLObjectProperty(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLClassExpression range=df.getOWLThing();
    if (qs.get(""String_Node_Str"") != null) {
      range=df.getOWLClass(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    }
    result.put(op,range);
  }
  return result;
}"
9381,"@Override public Map<OWLDataProperty,OWLClassExpression> getDataPropertyDomains(){
  Map<OWLDataProperty,OWLClassExpression> result=new HashMap<>();
  String query=SPARQLQueryUtils.PREFIXES + ""String_Node_Str"";
  ResultSet rs=executeSelectQuery(query);
  while (rs.hasNext()) {
    QuerySolution qs=rs.next();
    OWLDataProperty dp=df.getOWLDataProperty(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLClassExpression domain=df.getOWLClass(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    result.put(dp,domain);
  }
  return result;
}","@Override public Map<OWLDataProperty,OWLClassExpression> getDataPropertyDomains(){
  Map<OWLDataProperty,OWLClassExpression> result=new HashMap<>();
  String query=SPARQLQueryUtils.PREFIXES + ""String_Node_Str"";
  ResultSet rs=executeSelectQuery(query);
  while (rs.hasNext()) {
    QuerySolution qs=rs.next();
    OWLDataProperty dp=df.getOWLDataProperty(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLClassExpression domain=df.getOWLThing();
    if (qs.get(""String_Node_Str"") != null) {
      domain=df.getOWLClass(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    }
    result.put(dp,domain);
  }
  return result;
}"
9382,"@Override public Map<OWLObjectProperty,OWLClassExpression> getObjectPropertyDomains(){
  Map<OWLObjectProperty,OWLClassExpression> result=new HashMap<>();
  String query=SPARQLQueryUtils.PREFIXES + ""String_Node_Str"";
  ResultSet rs=executeSelectQuery(query);
  while (rs.hasNext()) {
    QuerySolution qs=rs.next();
    OWLObjectProperty op=df.getOWLObjectProperty(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLClassExpression domain=df.getOWLClass(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    result.put(op,domain);
  }
  return result;
}","@Override public Map<OWLObjectProperty,OWLClassExpression> getObjectPropertyDomains(){
  Map<OWLObjectProperty,OWLClassExpression> result=new HashMap<>();
  String query=SPARQLQueryUtils.PREFIXES + ""String_Node_Str"";
  ResultSet rs=executeSelectQuery(query);
  while (rs.hasNext()) {
    QuerySolution qs=rs.next();
    OWLObjectProperty op=df.getOWLObjectProperty(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLClassExpression domain=df.getOWLThing();
    if (qs.get(""String_Node_Str"") != null) {
      domain=df.getOWLClass(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    }
    result.put(op,domain);
  }
  return result;
}"
9383,"@Override public SortedSet<OWLClassExpression> getSuperClassesImpl(OWLClassExpression description){
  if (description.isAnonymous()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String query=String.format(SPARQLQueryUtils.SELECT_DIRECT_SUPERCLASS_OF_QUERY,description.asOWLClass().toStringID());
  ResultSet rs=executeSelectQuery(query);
  SortedSet<OWLClass> superClasses=asOWLEntities(EntityType.CLASS,rs,""String_Node_Str"");
  superClasses.remove(description);
  return new TreeSet<OWLClassExpression>(superClasses);
}","@Override public SortedSet<OWLClassExpression> getSuperClassesImpl(OWLClassExpression description){
  String query;
  if (description.isAnonymous()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (description.isOWLThing()) {
    return ImmutableSortedSet.of();
  }
 else   if (description.isOWLNothing()) {
    query=String.format(SPARQLQueryUtils.SELECT_LEAF_CLASSES_OWL,description.asOWLClass().toStringID());
  }
 else {
    query=String.format(SPARQLQueryUtils.SELECT_DIRECT_SUPERCLASS_OF_QUERY,description.asOWLClass().toStringID());
  }
  ResultSet rs=executeSelectQuery(query);
  SortedSet<OWLClass> superClasses=asOWLEntities(EntityType.CLASS,rs,""String_Node_Str"");
  superClasses.remove(description);
  return new TreeSet<OWLClassExpression>(superClasses);
}"
9384,"private double precision(String referenceSparqlQuery,String learnedSPARQLQuery){
  List<String> referenceResources=getResult(referenceSparqlQuery);
  if (referenceResources.isEmpty()) {
    logger.error(""String_Node_Str"" + referenceSparqlQuery);
    return 0;
  }
  if (learnedSPARQLQuery.equals(QueryTreeUtils.EMPTY_QUERY_TREE_QUERY)) {
    return referenceResources.size() / (double)kbSize;
  }
  List<String> learnedResources=getResult(learnedSPARQLQuery);
  if (learnedResources.isEmpty()) {
    logger.error(""String_Node_Str"" + learnedSPARQLQuery);
    System.err.println(learnedSPARQLQuery);
    return 0;
  }
  int overlap=Sets.intersection(Sets.newHashSet(referenceResources),Sets.newHashSet(learnedResources)).size();
  double precision=overlap / (double)learnedResources.size();
  return precision;
}","private double precision(String referenceSparqlQuery,String learnedSPARQLQuery){
  List<String> referenceResources=getResult(referenceSparqlQuery);
  if (referenceResources.isEmpty()) {
    logger.error(""String_Node_Str"" + referenceSparqlQuery);
    return 0;
  }
  if (learnedSPARQLQuery.equals(QueryTreeUtils.EMPTY_QUERY_TREE_QUERY)) {
    return referenceResources.size() / (double)kbSize;
  }
  List<String> learnedResources=splitComplexQueries ? getResultSplitted(learnedSPARQLQuery) : getResult(learnedSPARQLQuery);
  if (learnedResources.isEmpty()) {
    logger.error(""String_Node_Str"" + learnedSPARQLQuery);
    System.err.println(learnedSPARQLQuery);
    return 0;
  }
  int overlap=Sets.intersection(Sets.newHashSet(referenceResources),Sets.newHashSet(learnedResources)).size();
  double precision=overlap / (double)learnedResources.size();
  return precision;
}"
9385,"private double recall(String referenceSparqlQuery,String learnedSPARQLQuery){
  if (learnedSPARQLQuery.equals(QueryTreeUtils.EMPTY_QUERY_TREE_QUERY)) {
    return 1.0;
  }
  List<String> referenceResources=getResult(referenceSparqlQuery);
  if (referenceResources.isEmpty()) {
    return 0;
  }
  List<String> learnedResources=getResult(learnedSPARQLQuery);
  if (learnedResources.isEmpty()) {
    return 0;
  }
  int overlap=Sets.intersection(Sets.newHashSet(referenceResources),Sets.newHashSet(learnedResources)).size();
  double recall=overlap / (double)referenceResources.size();
  return recall;
}","private double recall(String referenceSparqlQuery,String learnedSPARQLQuery){
  if (learnedSPARQLQuery.equals(QueryTreeUtils.EMPTY_QUERY_TREE_QUERY)) {
    return 1.0;
  }
  List<String> referenceResources=getResult(referenceSparqlQuery);
  if (referenceResources.isEmpty()) {
    return 0;
  }
  List<String> learnedResources=splitComplexQueries ? getResultSplitted(learnedSPARQLQuery) : getResult(learnedSPARQLQuery);
  if (learnedResources.isEmpty()) {
    return 0;
  }
  int overlap=Sets.intersection(Sets.newHashSet(referenceResources),Sets.newHashSet(learnedResources)).size();
  double recall=overlap / (double)referenceResources.size();
  return recall;
}"
9386,"private List<String> getResult(String sparqlQuery){
  if (splitComplexQueries) {
    return getResultSplitted(sparqlQuery);
  }
  logger.trace(sparqlQuery);
  List<String> resources=cache.get(sparqlQuery);
  if (resources == null) {
    resources=new ArrayList<String>();
    Query query=QueryFactory.create(sparqlQuery);
    String projectVar=query.getProjectVars().get(0).getName();
    ResultSet rs=qef.createQueryExecution(sparqlQuery).execSelect();
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      if (qs.get(projectVar).isURIResource()) {
        resources.add(qs.getResource(projectVar).getURI());
      }
 else       if (qs.get(projectVar).isLiteral()) {
        resources.add(qs.getLiteral(projectVar).toString());
      }
    }
    cache.put(sparqlQuery,resources);
  }
  return resources;
}","private List<String> getResult(String sparqlQuery){
  logger.trace(sparqlQuery);
  List<String> resources=cache.get(sparqlQuery);
  if (resources == null) {
    resources=new ArrayList<String>();
    Query query=QueryFactory.create(sparqlQuery);
    String projectVar=query.getProjectVars().get(0).getName();
    ResultSet rs=qef.createQueryExecution(sparqlQuery).execSelect();
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      if (qs.get(projectVar).isURIResource()) {
        resources.add(qs.getResource(projectVar).getURI());
      }
 else       if (qs.get(projectVar).isLiteral()) {
        resources.add(qs.getLiteral(projectVar).toString());
      }
    }
    cache.put(sparqlQuery,resources);
  }
  return resources;
}"
9387,"@Override public final SortedSet<OWLClassExpression> getSuperClasses(OWLClassExpression concept){
  if (precomputeClassHierarchy) {
    return getClassHierarchy().getSuperClasses(concept);
  }
 else {
    try {
      return getSuperClassesImpl(concept);
    }
 catch (    ReasoningMethodUnsupportedException e) {
      e.printStackTrace();
    }
  }
  return null;
}","@Override public final SortedSet<OWLClassExpression> getSuperClasses(OWLClassExpression concept){
  if (precomputeClassHierarchy) {
    return getClassHierarchy().getSuperClasses(concept,true);
  }
 else {
    try {
      return getSuperClassesImpl(concept);
    }
 catch (    ReasoningMethodUnsupportedException e) {
      e.printStackTrace();
    }
  }
  return null;
}"
9388,"@Override public final SortedSet<OWLClassExpression> getSubClasses(OWLClassExpression concept){
  if (precomputeClassHierarchy) {
    return getClassHierarchy().getSubClasses(concept);
  }
 else {
    try {
      return getSubClassesImpl(concept);
    }
 catch (    ReasoningMethodUnsupportedException e) {
      e.printStackTrace();
    }
  }
  return null;
}","@Override public final SortedSet<OWLClassExpression> getSubClasses(OWLClassExpression concept){
  if (precomputeClassHierarchy) {
    return getClassHierarchy().getSubClasses(concept,true);
  }
 else {
    try {
      return getSubClassesImpl(concept);
    }
 catch (    ReasoningMethodUnsupportedException e) {
      e.printStackTrace();
    }
  }
  return null;
}"
9389,"@SuppressWarnings({""String_Node_Str""}) public Set<OWLClassExpression> refine(OWLClassExpression description,int maxLength,List<OWLClassExpression> knownRefinements,OWLClassExpression currDomain){
  if (!currDomain.isOWLThing() && !topARefinementsLength.containsKey(currDomain)) {
    topARefinementsLength.put(currDomain,0);
  }
  Set<OWLClassExpression> refinements=new TreeSet<OWLClassExpression>();
  Set<OWLClassExpression> tmp=new HashSet<OWLClassExpression>();
  if (description.isOWLThing()) {
    if (currDomain.isOWLThing()) {
      if (maxLength > topRefinementsLength)       computeTopRefinements(maxLength);
      refinements=(TreeSet<OWLClassExpression>)topRefinementsCumulative.get(maxLength).clone();
    }
 else {
      if (maxLength > topARefinementsLength.get(currDomain)) {
        computeTopRefinements(maxLength,currDomain);
      }
      refinements=(TreeSet<OWLClassExpression>)topARefinementsCumulative.get(currDomain).get(maxLength).clone();
    }
  }
 else   if (description.isOWLNothing()) {
  }
 else   if (!description.isAnonymous()) {
    refinements.addAll(subHierarchy.getSubClasses(description));
    refinements.remove(df.getOWLNothing());
  }
 else   if (description instanceof OWLObjectComplementOf) {
    OWLClassExpression operand=((OWLObjectComplementOf)description).getOperand();
    if (!operand.isAnonymous()) {
      tmp=subHierarchy.getSuperClasses(operand);
      for (      OWLClassExpression c : tmp) {
        if (!c.isOWLThing()) {
          refinements.add(df.getOWLObjectComplementOf(c));
        }
      }
    }
  }
 else   if (description instanceof OWLObjectIntersectionOf) {
    List<OWLClassExpression> operands=((OWLObjectIntersectionOf)description).getOperandsAsList();
    for (    OWLClassExpression child : operands) {
      tmp=refine(child,maxLength - OWLClassExpressionUtils.getLength(description) + OWLClassExpressionUtils.getLength(child),null,currDomain);
      for (      OWLClassExpression c : tmp) {
        List<OWLClassExpression> newChildren=new ArrayList<OWLClassExpression>(operands);
        newChildren.add(c);
        newChildren.remove(child);
        Collections.sort(newChildren);
        OWLClassExpression mc=new OWLObjectIntersectionOfImplExt(newChildren);
        mc=ConceptTransformation.cleanConceptNonRecursive(mc);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc);
        if (checkIntersection((OWLObjectIntersectionOf)mc))         refinements.add(mc);
      }
    }
  }
 else   if (description instanceof OWLObjectUnionOf) {
    List<OWLClassExpression> operands=((OWLObjectUnionOf)description).getOperandsAsList();
    for (    OWLClassExpression child : operands) {
      tmp=refine(child,maxLength - OWLClassExpressionUtils.getLength(description) + OWLClassExpressionUtils.getLength(child),null,currDomain);
      for (      OWLClassExpression c : tmp) {
        List<OWLClassExpression> newChildren=new ArrayList<OWLClassExpression>(operands);
        newChildren.remove(child);
        newChildren.add(c);
        Collections.sort(newChildren);
        OWLObjectUnionOf md=new OWLObjectUnionOfImplExt(newChildren);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(md);
        refinements.add(md);
      }
    }
    if (dropDisjuncts) {
      if (operands.size() == 2) {
        refinements.add(operands.get(0));
        refinements.add(operands.get(1));
      }
 else {
        for (int i=0; i < operands.size(); i++) {
          List<OWLClassExpression> newChildren=new LinkedList<OWLClassExpression>(operands);
          newChildren.remove(i);
          OWLObjectUnionOf md=new OWLObjectUnionOfImplExt(newChildren);
          refinements.add(md);
        }
      }
    }
  }
 else   if (description instanceof OWLObjectSomeValuesFrom) {
    OWLObjectPropertyExpression role=((OWLObjectSomeValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectSomeValuesFrom)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    tmp=refine(filler,maxLength - 2,null,range);
    for (    OWLClassExpression c : tmp) {
      refinements.add(df.getOWLObjectSomeValuesFrom(role,c));
    }
    if (!role.isAnonymous()) {
      Set<OWLObjectProperty> moreSpecialRoles=reasoner.getSubProperties(role.asOWLObjectProperty());
      for (      OWLObjectProperty moreSpecialRole : moreSpecialRoles) {
        refinements.add(df.getOWLObjectSomeValuesFrom(moreSpecialRole,filler));
      }
    }
    if (useCardinalityRestrictions) {
      if (maxLength > OWLClassExpressionUtils.getLength(description) && maxNrOfFillers.get(role) > 1) {
        OWLObjectMinCardinality min=df.getOWLObjectMinCardinality(2,role,filler);
        refinements.add(min);
      }
    }
    if (useHasValueConstructor && filler.isOWLThing()) {
      Set<OWLIndividual> frequentInds=frequentValues.get(role);
      if (frequentInds != null) {
        for (        OWLIndividual ind : frequentInds) {
          OWLObjectHasValue ovr=df.getOWLObjectHasValue(role,ind);
          refinements.add(ovr);
          if (useObjectValueNegation) {
            refinements.add(df.getOWLObjectComplementOf(ovr));
          }
        }
      }
    }
  }
 else   if (description instanceof OWLObjectAllValuesFrom) {
    OWLObjectPropertyExpression role=((OWLObjectAllValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectAllValuesFrom)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    tmp=refine(filler,maxLength - 2,null,range);
    for (    OWLClassExpression c : tmp) {
      refinements.add(df.getOWLObjectAllValuesFrom(role,c));
    }
    if (!filler.isOWLNothing() && !filler.isAnonymous() && tmp.size() == 0) {
      refinements.add(df.getOWLObjectAllValuesFrom(role,df.getOWLNothing()));
    }
    if (!role.isAnonymous()) {
      Set<OWLObjectProperty> subProperties=reasoner.getSubProperties(role.asOWLObjectProperty());
      for (      OWLObjectProperty subProperty : subProperties) {
        refinements.add(df.getOWLObjectAllValuesFrom(subProperty,filler));
      }
    }
  }
 else   if (description instanceof OWLObjectCardinalityRestriction) {
    OWLObjectPropertyExpression role=((OWLObjectCardinalityRestriction)description).getProperty();
    OWLClassExpression filler=((OWLObjectCardinalityRestriction)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    int cardinality=((OWLObjectCardinalityRestriction)description).getCardinality();
    if (description instanceof OWLObjectMaxCardinality) {
      if (useNegation || cardinality > 0) {
        tmp=refine(filler,maxLength - 3,null,range);
        for (        OWLClassExpression d : tmp) {
          refinements.add(df.getOWLObjectMaxCardinality(cardinality,role,d));
        }
      }
      if ((useNegation && cardinality > 1) || (!useNegation && cardinality > 2)) {
        refinements.add(df.getOWLObjectMaxCardinality(cardinality - 1,role,filler));
      }
    }
 else     if (description instanceof OWLObjectMinCardinality) {
      tmp=refine(filler,maxLength - 3,null,range);
      for (      OWLClassExpression d : tmp) {
        refinements.add(df.getOWLObjectMinCardinality(cardinality,role,d));
      }
      if (cardinality < maxNrOfFillers.get(role)) {
        refinements.add(df.getOWLObjectMinCardinality(cardinality + 1,role,filler));
      }
    }
  }
 else   if (description instanceof OWLDataSomeValuesFrom) {
    OWLDataPropertyExpression dp=((OWLDataSomeValuesFrom)description).getProperty();
    OWLDataRange dr=((OWLDataSomeValuesFrom)description).getFiller();
    if (dr instanceof OWLDatatypeRestriction) {
      OWLDatatype datatype=((OWLDatatypeRestriction)dr).getDatatype();
      Set<OWLFacetRestriction> facetRestrictions=((OWLDatatypeRestriction)dr).getFacetRestrictions();
      OWLDatatypeRestriction newDatatypeRestriction=null;
      if (datatype.isDouble()) {
        for (        OWLFacetRestriction facetRestriction : facetRestrictions) {
          OWLFacet facet=facetRestriction.getFacet();
          double value=facetRestriction.getFacetValue().parseDouble();
          if (facet == OWLFacet.MAX_INCLUSIVE) {
            int splitIndex=splits.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex - 1;
            if (newSplitIndex >= 0) {
              double newValue=splits.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMaxInclusiveRestriction(newValue);
            }
          }
 else           if (facet == OWLFacet.MIN_INCLUSIVE) {
            int splitIndex=splits.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex + 1;
            if (newSplitIndex < splits.get(dp).size()) {
              double newValue=splits.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMinInclusiveRestriction(newValue);
            }
          }
        }
      }
 else       if (datatype.isInteger()) {
        for (        OWLFacetRestriction facetRestriction : facetRestrictions) {
          OWLFacet facet=facetRestriction.getFacet();
          int value=facetRestriction.getFacetValue().parseInteger();
          if (facet == OWLFacet.MAX_INCLUSIVE) {
            int splitIndex=splitsInt.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex - 1;
            if (newSplitIndex >= 0) {
              int newValue=splitsInt.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMaxInclusiveRestriction(newValue);
            }
          }
 else           if (facet == OWLFacet.MIN_INCLUSIVE) {
            int splitIndex=splitsInt.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex + 1;
            if (newSplitIndex < splitsInt.get(dp).size()) {
              int newValue=splitsInt.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMinInclusiveRestriction(newValue);
            }
          }
        }
      }
      if (newDatatypeRestriction != null) {
        refinements.add(df.getOWLDataSomeValuesFrom(dp,newDatatypeRestriction));
      }
    }
  }
 else   if (description instanceof OWLDataHasValue) {
    OWLDataPropertyExpression dp=((OWLDataHasValue)description).getProperty();
    OWLLiteral value=((OWLDataHasValue)description).getValue();
    if (!dp.isAnonymous()) {
      Set<OWLDataProperty> subDPs=reasoner.getSubProperties(dp.asOWLDataProperty());
      for (      OWLDataProperty subDP : subDPs) {
        refinements.add(df.getOWLDataHasValue(subDP,value));
      }
    }
  }
  if (!description.isOWLThing() && !description.isOWLNothing() && !(description instanceof OWLObjectAllValuesFrom && ((OWLObjectAllValuesFrom)description).getFiller().isOWLNothing())) {
    int topRefLength=maxLength - OWLClassExpressionUtils.getLength(description) - 1;
    if (currDomain.isOWLThing()) {
      if (topRefLength > topRefinementsLength)       computeTopRefinements(topRefLength);
    }
 else     if (topRefLength > topARefinementsLength.get(currDomain))     computeTopRefinements(topRefLength,currDomain);
    if (topRefLength > 0) {
      Set<OWLClassExpression> topRefs;
      if (currDomain.isOWLThing())       topRefs=topRefinementsCumulative.get(topRefLength);
 else       topRefs=topARefinementsCumulative.get(currDomain).get(topRefLength);
      for (      OWLClassExpression c : topRefs) {
        boolean skip=false;
        if (applyAllFilter) {
          if (c instanceof OWLObjectAllValuesFrom) {
            if (description instanceof OWLNaryBooleanClassExpression) {
              for (              OWLClassExpression child : ((OWLNaryBooleanClassExpression)description).getOperands()) {
                if (child instanceof OWLObjectAllValuesFrom) {
                  OWLObjectPropertyExpression r1=((OWLObjectAllValuesFrom)c).getProperty();
                  OWLObjectPropertyExpression r2=((OWLObjectAllValuesFrom)child).getProperty();
                  if (r1.equals(r2)) {
                    skip=true;
                    break;
                  }
                }
              }
            }
          }
        }
        if (disjointChecks && !c.isAnonymous() && !description.isAnonymous()&& isDisjoint(description,c)) {
          skip=true;
        }
        if (!skip) {
          List<OWLClassExpression> operands=Lists.newArrayList(description,c);
          Collections.sort(operands);
          OWLObjectIntersectionOf mc=new OWLObjectIntersectionOfImplExt(operands);
          mc=(OWLObjectIntersectionOf)ConceptTransformation.cleanConceptNonRecursive(mc);
          ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc);
          if (checkIntersection(mc))           refinements.add(mc);
        }
      }
    }
  }
  return refinements;
}","@SuppressWarnings({""String_Node_Str""}) public Set<OWLClassExpression> refine(OWLClassExpression description,int maxLength,List<OWLClassExpression> knownRefinements,OWLClassExpression currDomain){
  if (!currDomain.isOWLThing() && !topARefinementsLength.containsKey(currDomain)) {
    topARefinementsLength.put(currDomain,0);
  }
  Set<OWLClassExpression> refinements=new TreeSet<OWLClassExpression>();
  Set<OWLClassExpression> tmp=new HashSet<OWLClassExpression>();
  if (description.isOWLThing()) {
    if (currDomain.isOWLThing()) {
      if (maxLength > topRefinementsLength)       computeTopRefinements(maxLength);
      refinements=(TreeSet<OWLClassExpression>)topRefinementsCumulative.get(maxLength).clone();
    }
 else {
      if (maxLength > topARefinementsLength.get(currDomain)) {
        computeTopRefinements(maxLength,currDomain);
      }
      refinements=(TreeSet<OWLClassExpression>)topARefinementsCumulative.get(currDomain).get(maxLength).clone();
    }
  }
 else   if (description.isOWLNothing()) {
  }
 else   if (!description.isAnonymous()) {
    refinements.addAll(subHierarchy.getSubClasses(description,true));
    refinements.remove(df.getOWLNothing());
  }
 else   if (description instanceof OWLObjectComplementOf) {
    OWLClassExpression operand=((OWLObjectComplementOf)description).getOperand();
    if (!operand.isAnonymous()) {
      tmp=subHierarchy.getSuperClasses(operand,true);
      for (      OWLClassExpression c : tmp) {
        if (!c.isOWLThing()) {
          refinements.add(df.getOWLObjectComplementOf(c));
        }
      }
    }
  }
 else   if (description instanceof OWLObjectIntersectionOf) {
    List<OWLClassExpression> operands=((OWLObjectIntersectionOf)description).getOperandsAsList();
    for (    OWLClassExpression child : operands) {
      tmp=refine(child,maxLength - OWLClassExpressionUtils.getLength(description) + OWLClassExpressionUtils.getLength(child),null,currDomain);
      for (      OWLClassExpression c : tmp) {
        List<OWLClassExpression> newChildren=new ArrayList<OWLClassExpression>(operands);
        newChildren.add(c);
        newChildren.remove(child);
        Collections.sort(newChildren);
        OWLClassExpression mc=new OWLObjectIntersectionOfImplExt(newChildren);
        mc=ConceptTransformation.cleanConceptNonRecursive(mc);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc);
        if (checkIntersection((OWLObjectIntersectionOf)mc))         refinements.add(mc);
      }
    }
  }
 else   if (description instanceof OWLObjectUnionOf) {
    List<OWLClassExpression> operands=((OWLObjectUnionOf)description).getOperandsAsList();
    for (    OWLClassExpression child : operands) {
      tmp=refine(child,maxLength - OWLClassExpressionUtils.getLength(description) + OWLClassExpressionUtils.getLength(child),null,currDomain);
      for (      OWLClassExpression c : tmp) {
        List<OWLClassExpression> newChildren=new ArrayList<OWLClassExpression>(operands);
        newChildren.remove(child);
        newChildren.add(c);
        Collections.sort(newChildren);
        OWLObjectUnionOf md=new OWLObjectUnionOfImplExt(newChildren);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(md);
        refinements.add(md);
      }
    }
    if (dropDisjuncts) {
      if (operands.size() == 2) {
        refinements.add(operands.get(0));
        refinements.add(operands.get(1));
      }
 else {
        for (int i=0; i < operands.size(); i++) {
          List<OWLClassExpression> newChildren=new LinkedList<OWLClassExpression>(operands);
          newChildren.remove(i);
          OWLObjectUnionOf md=new OWLObjectUnionOfImplExt(newChildren);
          refinements.add(md);
        }
      }
    }
  }
 else   if (description instanceof OWLObjectSomeValuesFrom) {
    OWLObjectPropertyExpression role=((OWLObjectSomeValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectSomeValuesFrom)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    tmp=refine(filler,maxLength - 2,null,range);
    for (    OWLClassExpression c : tmp) {
      refinements.add(df.getOWLObjectSomeValuesFrom(role,c));
    }
    if (!role.isAnonymous()) {
      Set<OWLObjectProperty> moreSpecialRoles=reasoner.getSubProperties(role.asOWLObjectProperty());
      for (      OWLObjectProperty moreSpecialRole : moreSpecialRoles) {
        refinements.add(df.getOWLObjectSomeValuesFrom(moreSpecialRole,filler));
      }
    }
    if (useCardinalityRestrictions) {
      if (maxLength > OWLClassExpressionUtils.getLength(description) && maxNrOfFillers.get(role) > 1) {
        OWLObjectMinCardinality min=df.getOWLObjectMinCardinality(2,role,filler);
        refinements.add(min);
      }
    }
    if (useHasValueConstructor && filler.isOWLThing()) {
      Set<OWLIndividual> frequentInds=frequentValues.get(role);
      if (frequentInds != null) {
        for (        OWLIndividual ind : frequentInds) {
          OWLObjectHasValue ovr=df.getOWLObjectHasValue(role,ind);
          refinements.add(ovr);
          if (useObjectValueNegation) {
            refinements.add(df.getOWLObjectComplementOf(ovr));
          }
        }
      }
    }
  }
 else   if (description instanceof OWLObjectAllValuesFrom) {
    OWLObjectPropertyExpression role=((OWLObjectAllValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectAllValuesFrom)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    tmp=refine(filler,maxLength - 2,null,range);
    for (    OWLClassExpression c : tmp) {
      refinements.add(df.getOWLObjectAllValuesFrom(role,c));
    }
    if (!filler.isOWLNothing() && !filler.isAnonymous() && tmp.size() == 0) {
      refinements.add(df.getOWLObjectAllValuesFrom(role,df.getOWLNothing()));
    }
    if (!role.isAnonymous()) {
      Set<OWLObjectProperty> subProperties=reasoner.getSubProperties(role.asOWLObjectProperty());
      for (      OWLObjectProperty subProperty : subProperties) {
        refinements.add(df.getOWLObjectAllValuesFrom(subProperty,filler));
      }
    }
  }
 else   if (description instanceof OWLObjectCardinalityRestriction) {
    OWLObjectPropertyExpression role=((OWLObjectCardinalityRestriction)description).getProperty();
    OWLClassExpression filler=((OWLObjectCardinalityRestriction)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    int cardinality=((OWLObjectCardinalityRestriction)description).getCardinality();
    if (description instanceof OWLObjectMaxCardinality) {
      if (useNegation || cardinality > 0) {
        tmp=refine(filler,maxLength - 3,null,range);
        for (        OWLClassExpression d : tmp) {
          refinements.add(df.getOWLObjectMaxCardinality(cardinality,role,d));
        }
      }
      if ((useNegation && cardinality > 1) || (!useNegation && cardinality > 2)) {
        refinements.add(df.getOWLObjectMaxCardinality(cardinality - 1,role,filler));
      }
    }
 else     if (description instanceof OWLObjectMinCardinality) {
      tmp=refine(filler,maxLength - 3,null,range);
      for (      OWLClassExpression d : tmp) {
        refinements.add(df.getOWLObjectMinCardinality(cardinality,role,d));
      }
      if (cardinality < maxNrOfFillers.get(role)) {
        refinements.add(df.getOWLObjectMinCardinality(cardinality + 1,role,filler));
      }
    }
  }
 else   if (description instanceof OWLDataSomeValuesFrom) {
    OWLDataPropertyExpression dp=((OWLDataSomeValuesFrom)description).getProperty();
    OWLDataRange dr=((OWLDataSomeValuesFrom)description).getFiller();
    if (dr instanceof OWLDatatypeRestriction) {
      OWLDatatype datatype=((OWLDatatypeRestriction)dr).getDatatype();
      Set<OWLFacetRestriction> facetRestrictions=((OWLDatatypeRestriction)dr).getFacetRestrictions();
      OWLDatatypeRestriction newDatatypeRestriction=null;
      if (datatype.isDouble()) {
        for (        OWLFacetRestriction facetRestriction : facetRestrictions) {
          OWLFacet facet=facetRestriction.getFacet();
          double value=facetRestriction.getFacetValue().parseDouble();
          if (facet == OWLFacet.MAX_INCLUSIVE) {
            int splitIndex=splits.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex - 1;
            if (newSplitIndex >= 0) {
              double newValue=splits.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMaxInclusiveRestriction(newValue);
            }
          }
 else           if (facet == OWLFacet.MIN_INCLUSIVE) {
            int splitIndex=splits.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex + 1;
            if (newSplitIndex < splits.get(dp).size()) {
              double newValue=splits.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMinInclusiveRestriction(newValue);
            }
          }
        }
      }
 else       if (datatype.isInteger()) {
        for (        OWLFacetRestriction facetRestriction : facetRestrictions) {
          OWLFacet facet=facetRestriction.getFacet();
          int value=facetRestriction.getFacetValue().parseInteger();
          if (facet == OWLFacet.MAX_INCLUSIVE) {
            int splitIndex=splitsInt.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex - 1;
            if (newSplitIndex >= 0) {
              int newValue=splitsInt.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMaxInclusiveRestriction(newValue);
            }
          }
 else           if (facet == OWLFacet.MIN_INCLUSIVE) {
            int splitIndex=splitsInt.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex + 1;
            if (newSplitIndex < splitsInt.get(dp).size()) {
              int newValue=splitsInt.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMinInclusiveRestriction(newValue);
            }
          }
        }
      }
      if (newDatatypeRestriction != null) {
        refinements.add(df.getOWLDataSomeValuesFrom(dp,newDatatypeRestriction));
      }
    }
  }
 else   if (description instanceof OWLDataHasValue) {
    OWLDataPropertyExpression dp=((OWLDataHasValue)description).getProperty();
    OWLLiteral value=((OWLDataHasValue)description).getValue();
    if (!dp.isAnonymous()) {
      Set<OWLDataProperty> subDPs=reasoner.getSubProperties(dp.asOWLDataProperty());
      for (      OWLDataProperty subDP : subDPs) {
        refinements.add(df.getOWLDataHasValue(subDP,value));
      }
    }
  }
  if (!description.isOWLThing() && !description.isOWLNothing() && !(description instanceof OWLObjectAllValuesFrom && ((OWLObjectAllValuesFrom)description).getFiller().isOWLNothing())) {
    int topRefLength=maxLength - OWLClassExpressionUtils.getLength(description) - 1;
    if (currDomain.isOWLThing()) {
      if (topRefLength > topRefinementsLength)       computeTopRefinements(topRefLength);
    }
 else     if (topRefLength > topARefinementsLength.get(currDomain))     computeTopRefinements(topRefLength,currDomain);
    if (topRefLength > 0) {
      Set<OWLClassExpression> topRefs;
      if (currDomain.isOWLThing())       topRefs=topRefinementsCumulative.get(topRefLength);
 else       topRefs=topARefinementsCumulative.get(currDomain).get(topRefLength);
      for (      OWLClassExpression c : topRefs) {
        boolean skip=false;
        if (applyAllFilter) {
          if (c instanceof OWLObjectAllValuesFrom) {
            if (description instanceof OWLNaryBooleanClassExpression) {
              for (              OWLClassExpression child : ((OWLNaryBooleanClassExpression)description).getOperands()) {
                if (child instanceof OWLObjectAllValuesFrom) {
                  OWLObjectPropertyExpression r1=((OWLObjectAllValuesFrom)c).getProperty();
                  OWLObjectPropertyExpression r2=((OWLObjectAllValuesFrom)child).getProperty();
                  if (r1.equals(r2)) {
                    skip=true;
                    break;
                  }
                }
              }
            }
          }
        }
        if (disjointChecks && !c.isAnonymous() && !description.isAnonymous()&& isDisjoint(description,c)) {
          skip=true;
        }
        if (!skip) {
          List<OWLClassExpression> operands=Lists.newArrayList(description,c);
          Collections.sort(operands);
          OWLObjectIntersectionOf mc=new OWLObjectIntersectionOfImplExt(operands);
          mc=(OWLObjectIntersectionOf)ConceptTransformation.cleanConceptNonRecursive(mc);
          ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc);
          if (checkIntersection(mc))           refinements.add(mc);
        }
      }
    }
  }
  return refinements;
}"
9390,"private SortedSet<OWLClassExpression> getClassCandidatesRecursive(OWLClassExpression index,OWLClassExpression upperClass){
  SortedSet<OWLClassExpression> candidates=new TreeSet<OWLClassExpression>();
  for (  OWLClassExpression candidate : subHierarchy.getSubClasses(upperClass)) {
    if (!isDisjoint(candidate,index)) {
      boolean meaningful;
      if (instanceBasedDisjoints) {
        SortedSet<OWLIndividual> tmp=reasoner.getIndividuals(index);
        tmp.removeAll(reasoner.getIndividuals(candidate));
        meaningful=tmp.size() != 0;
      }
 else {
        meaningful=!isDisjoint(df.getOWLObjectComplementOf(candidate),index);
      }
      if (meaningful) {
        candidates.add(candidate);
      }
 else {
        candidates.addAll(getClassCandidatesRecursive(index,candidate));
      }
    }
  }
  return candidates;
}","private SortedSet<OWLClassExpression> getClassCandidatesRecursive(OWLClassExpression index,OWLClassExpression upperClass){
  SortedSet<OWLClassExpression> candidates=new TreeSet<OWLClassExpression>();
  for (  OWLClassExpression candidate : subHierarchy.getSubClasses(upperClass,true)) {
    if (!isDisjoint(candidate,index)) {
      boolean meaningful;
      if (instanceBasedDisjoints) {
        SortedSet<OWLIndividual> tmp=reasoner.getIndividuals(index);
        tmp.removeAll(reasoner.getIndividuals(candidate));
        meaningful=tmp.size() != 0;
      }
 else {
        meaningful=!isDisjoint(df.getOWLObjectComplementOf(candidate),index);
      }
      if (meaningful) {
        candidates.add(candidate);
      }
 else {
        candidates.addAll(getClassCandidatesRecursive(index,candidate));
      }
    }
  }
  return candidates;
}"
9391,"private Set<OWLClass> getClassCandidatesRecursive(OWLClassExpression index,Set<OWLClass> existingClasses,OWLClassExpression upperClass){
  Set<OWLClass> candidates=new TreeSet<OWLClass>();
  for (  OWLClassExpression d : sh.getSubClasses(upperClass)) {
    if (!d.isOWLNothing()) {
      OWLClass candidate=d.asOWLClass();
      if (!isDisjoint(candidate,index) && checkSubClasses(existingClasses,candidate) && checkDisjoints(existingClasses,candidate)) {
        if (!isDisjoint(df.getOWLObjectComplementOf(candidate),index) && checkSuperClasses(existingClasses,candidate)) {
          candidates.add(candidate);
        }
 else {
          candidates.addAll(getClassCandidatesRecursive(index,existingClasses,candidate));
        }
      }
    }
  }
  return candidates;
}","private Set<OWLClass> getClassCandidatesRecursive(OWLClassExpression index,Set<OWLClass> existingClasses,OWLClassExpression upperClass){
  Set<OWLClass> candidates=new TreeSet<OWLClass>();
  for (  OWLClassExpression d : sh.getSubClasses(upperClass,true)) {
    if (!d.isOWLNothing()) {
      OWLClass candidate=d.asOWLClass();
      if (!isDisjoint(candidate,index) && checkSubClasses(existingClasses,candidate) && checkDisjoints(existingClasses,candidate)) {
        if (!isDisjoint(df.getOWLObjectComplementOf(candidate),index) && checkSuperClasses(existingClasses,candidate)) {
          candidates.add(candidate);
        }
 else {
          candidates.addAll(getClassCandidatesRecursive(index,existingClasses,candidate));
        }
      }
    }
  }
  return candidates;
}"
9392,"@Override public SortedSet<OWLClassExpression> getSuperClassesImpl(OWLClassExpression description){
  if (description.isAnonymous()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String query=String.format(SPARQLQueryUtils.SELECT_DIRECT_SUPERCLASS_OF_QUERY,description.asOWLClass().toStringID());
  ResultSet rs=executeSelectQuery(query);
  SortedSet<OWLClass> superClasses=asOWLEntities(EntityType.CLASS,rs,""String_Node_Str"");
  superClasses.remove(description);
  return new TreeSet<OWLClassExpression>(superClasses);
}","@Override public SortedSet<OWLClassExpression> getSuperClassesImpl(OWLClassExpression description){
  if (description.isAnonymous()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String query=String.format(SPARQLQueryUtils.SELECT_DIRECT_SUPERCLASS_OF_QUERY,description.asOWLClass().toStringID());
  ResultSet rs=executeSelectQuery(query);
  SortedSet<OWLClass> superClasses=asOWLEntities(EntityType.CLASS,rs,""String_Node_Str"");
  superClasses.remove(description);
  System.out.println(""String_Node_Str"" + description + ""String_Node_Str""+ superClasses);
  return new TreeSet<OWLClassExpression>(superClasses);
}"
9393,"private void reset(){
  variables.clear();
  properties.clear();
  sparql=""String_Node_Str"";
  intersection=new HashMap<Integer,Boolean>();
  mapping.reset();
}","private void reset(){
  variables.clear();
  properties.clear();
  sparql=""String_Node_Str"";
  intersection=new HashMap<Integer,Boolean>();
  mapping.reset();
  cnt=1;
}"
9394,"@Override public SortedSet<T> getParents(T entity,boolean direct){
  SortedSet<T> result=hierarchyUp.get(entity);
  if (result == null) {
    logger.error(""String_Node_Str"" + entity + ""String_Node_Str"");
    return new TreeSet<T>();
  }
  result.remove(entity);
  if (!direct) {
    for (    T parent : result) {
      result.addAll(getParents(parent,direct));
    }
  }
  return new TreeSet<T>(result);
}","@Override public SortedSet<T> getParents(T entity,boolean direct){
  SortedSet<T> result=hierarchyUp.get(entity);
  if (result == null) {
    logger.error(""String_Node_Str"" + entity + ""String_Node_Str"");
    return new TreeSet<T>();
  }
  result.remove(entity);
  if (!direct) {
    SortedSet<T> tmp=new TreeSet<T>();
    for (    T parent : result) {
      tmp.addAll(getParents(parent,direct));
    }
    result.addAll(tmp);
  }
  return new TreeSet<T>(result);
}"
9395,"@Override public SortedSet<T> getChildren(T entity,boolean direct){
  SortedSet<T> result=hierarchyDown.get(entity);
  if (result == null) {
    logger.error(""String_Node_Str"" + entity + ""String_Node_Str"");
    return new TreeSet<T>();
  }
  result.remove(entity);
  if (!direct) {
    for (    T child : result) {
      result.addAll(getChildren(child,direct));
    }
  }
  return new TreeSet<T>(result);
}","@Override public SortedSet<T> getChildren(T entity,boolean direct){
  SortedSet<T> result=hierarchyDown.get(entity);
  if (result == null) {
    logger.error(""String_Node_Str"" + entity + ""String_Node_Str"");
    return new TreeSet<T>();
  }
  result.remove(entity);
  if (!direct) {
    SortedSet<T> tmp=new TreeSet<T>();
    for (    T child : result) {
      tmp.addAll(getChildren(child,direct));
    }
    result.addAll(tmp);
  }
  return new TreeSet<T>(result);
}"
9396,"/** 
 * @param cache a cache object
 * @param sparqlEndpoint the Endpoint the sparql queries will be send to
 */
public SPARQLTasks(final Cache cache,final SparqlEndpoint sparqlEndpoint){
  this.cache=cache;
  this.sparqlEndpoint=sparqlEndpoint;
  reasoner=new SPARQLReasoner(sparqlEndpoint,null);
}","/** 
 * @param cache a cache object
 * @param sparqlEndpoint the Endpoint the sparql queries will be send to
 */
public SPARQLTasks(final Cache cache,final SparqlEndpoint sparqlEndpoint){
  this.cache=cache;
  this.sparqlEndpoint=sparqlEndpoint;
  reasoner=new SPARQLReasoner(sparqlEndpoint);
}"
9397,"private boolean occursOnFirstLevel(OWLClassExpression description,OWLClassExpression cls){
  if (cls.isOWLThing()) {
    return false;
  }
  return description.containsConjunct(cls) || (description instanceof OWLObjectUnionOf && ((OWLObjectUnionOf)description).getOperands().contains(cls));
}","private boolean occursOnFirstLevel(OWLClassExpression description,OWLClassExpression cls){
  if (cls.isOWLThing()) {
    return false;
  }
  return (description instanceof OWLNaryBooleanClassExpression && ((OWLNaryBooleanClassExpression)description).getOperands().contains(cls));
}"
9398,"public double getAccuracyOrTooWeakExact(OWLClassExpression description,double noise){
  nanoStartTime=System.nanoTime();
  if (heuristic.equals(HeuristicType.JACCARD)) {
    TreeSet<OWLIndividual> coveredInstancesSet=new TreeSet<OWLIndividual>();
    for (    OWLIndividual ind : classInstances) {
      if (getReasoner().hasType(description,ind)) {
        coveredInstancesSet.add(ind);
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    if (coveredInstancesSet.size() / (double)classInstances.size() <= 1 - noise) {
      return -1;
    }
    TreeSet<OWLIndividual> additionalInstancesSet=new TreeSet<OWLIndividual>();
    for (    OWLIndividual ind : superClassInstances) {
      if (getReasoner().hasType(description,ind)) {
        additionalInstancesSet.add(ind);
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    Set<OWLIndividual> union=Helper.union(classInstancesSet,additionalInstancesSet);
    return Heuristics.getJaccardCoefficient(coveredInstancesSet.size(),union.size());
  }
 else   if (heuristic.equals(HeuristicType.AMEASURE) || heuristic.equals(HeuristicType.FMEASURE) || heuristic.equals(HeuristicType.PRED_ACC)) {
    int additionalInstances=0;
    if (useInstanceChecks) {
      for (      OWLIndividual ind : superClassInstances) {
        if (getReasoner().hasType(description,ind)) {
          additionalInstances++;
        }
        if (terminationTimeExpired()) {
          return 0;
        }
      }
    }
 else {
      SortedSet<OWLIndividual> individuals=getReasoner().getIndividuals(description);
      individuals.retainAll(superClassInstances);
      additionalInstances=individuals.size();
    }
    int coveredInstances=0;
    if (useInstanceChecks) {
      for (      OWLIndividual ind : classInstances) {
        if (getReasoner().hasType(description,ind)) {
          coveredInstances++;
        }
        if (terminationTimeExpired()) {
          return 0;
        }
      }
    }
 else {
      SortedSet<OWLIndividual> individuals=getReasoner().getIndividuals(description);
      individuals.retainAll(classInstances);
      coveredInstances=individuals.size();
    }
    System.out.println(description + ""String_Node_Str"" + coveredInstances+ ""String_Node_Str""+ classInstances.size());
    double recall=coveredInstances / (double)classInstances.size();
    double precision=(additionalInstances + coveredInstances == 0) ? 0 : coveredInstances / (double)(coveredInstances + additionalInstances);
    if (heuristic.equals(HeuristicType.AMEASURE)) {
      if ((coverageFactor * recall + 1) / (double)(coverageFactor + 1) < (1 - noise)) {
        return -1;
      }
 else {
        return Heuristics.getAScore(recall,precision,coverageFactor);
      }
    }
 else     if (heuristic.equals(HeuristicType.FMEASURE)) {
      if (((1 + Math.sqrt(coverageFactor)) * recall) / (Math.sqrt(coverageFactor) + 1) < 1 - noise) {
        return -1;
      }
 else {
        return getFMeasure(recall,precision);
      }
    }
 else     if (heuristic.equals(HeuristicType.PRED_ACC)) {
      if ((coverageFactor * coveredInstances + superClassInstances.size()) / (double)(coverageFactor * classInstances.size() + superClassInstances.size()) < 1 - noise) {
        return -1;
      }
 else {
        return (coverageFactor * coveredInstances + superClassInstances.size() - additionalInstances) / (double)(coverageFactor * classInstances.size() + superClassInstances.size());
      }
    }
  }
 else   if (heuristic.equals(HeuristicType.GEN_FMEASURE)) {
    TreeSet<OWLIndividual> icPos=new TreeSet<OWLIndividual>();
    TreeSet<OWLIndividual> icNeg=new TreeSet<OWLIndividual>();
    OWLClassExpression descriptionNeg=df.getOWLObjectComplementOf(description);
    for (    OWLIndividual ind : classAndSuperClassInstances) {
      if (getReasoner().hasType(description,ind)) {
        icPos.add(ind);
      }
 else       if (getReasoner().hasType(descriptionNeg,ind)) {
        icNeg.add(ind);
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    Set<OWLIndividual> tmp1Pos=Helper.intersection(icPos,classInstancesSet);
    Set<OWLIndividual> tmp1Neg=Helper.intersection(icNeg,negatedClassInstances);
    int tmp1Size=tmp1Pos.size() + tmp1Neg.size();
    int icSize=icPos.size() + icNeg.size();
    double prec=(icSize == 0) ? 0 : tmp1Size / (double)icSize;
    double rec=tmp1Size / (double)(classInstances.size() + negatedClassInstances.size());
    if (rec <= 0.0000001) {
      return -1;
    }
    return getFMeasure(rec,prec);
  }
  throw new Error(""String_Node_Str"");
}","public double getAccuracyOrTooWeakExact(OWLClassExpression description,double noise){
  nanoStartTime=System.nanoTime();
  if (heuristic.equals(HeuristicType.JACCARD)) {
    TreeSet<OWLIndividual> coveredInstancesSet=new TreeSet<OWLIndividual>();
    for (    OWLIndividual ind : classInstances) {
      if (getReasoner().hasType(description,ind)) {
        coveredInstancesSet.add(ind);
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    if (coveredInstancesSet.size() / (double)classInstances.size() <= 1 - noise) {
      return -1;
    }
    TreeSet<OWLIndividual> additionalInstancesSet=new TreeSet<OWLIndividual>();
    for (    OWLIndividual ind : superClassInstances) {
      if (getReasoner().hasType(description,ind)) {
        additionalInstancesSet.add(ind);
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    Set<OWLIndividual> union=Helper.union(classInstancesSet,additionalInstancesSet);
    return Heuristics.getJaccardCoefficient(coveredInstancesSet.size(),union.size());
  }
 else   if (heuristic.equals(HeuristicType.AMEASURE) || heuristic.equals(HeuristicType.FMEASURE) || heuristic.equals(HeuristicType.PRED_ACC)) {
    int additionalInstances=0;
    if (useInstanceChecks) {
      for (      OWLIndividual ind : superClassInstances) {
        if (getReasoner().hasType(description,ind)) {
          additionalInstances++;
        }
        if (terminationTimeExpired()) {
          return 0;
        }
      }
    }
 else {
      SortedSet<OWLIndividual> individuals=getReasoner().getIndividuals(description);
      individuals.retainAll(superClassInstances);
      additionalInstances=individuals.size();
    }
    int coveredInstances=0;
    if (useInstanceChecks) {
      for (      OWLIndividual ind : classInstances) {
        if (getReasoner().hasType(description,ind)) {
          coveredInstances++;
        }
        if (terminationTimeExpired()) {
          return 0;
        }
      }
    }
 else {
      SortedSet<OWLIndividual> individuals=getReasoner().getIndividuals(description);
      individuals.retainAll(classInstances);
      coveredInstances=individuals.size();
    }
    double recall=coveredInstances / (double)classInstances.size();
    double precision=(additionalInstances + coveredInstances == 0) ? 0 : coveredInstances / (double)(coveredInstances + additionalInstances);
    if (heuristic.equals(HeuristicType.AMEASURE)) {
      if ((coverageFactor * recall + 1) / (double)(coverageFactor + 1) < (1 - noise)) {
        return -1;
      }
 else {
        return Heuristics.getAScore(recall,precision,coverageFactor);
      }
    }
 else     if (heuristic.equals(HeuristicType.FMEASURE)) {
      if (((1 + Math.sqrt(coverageFactor)) * recall) / (Math.sqrt(coverageFactor) + 1) < 1 - noise) {
        return -1;
      }
 else {
        return getFMeasure(recall,precision);
      }
    }
 else     if (heuristic.equals(HeuristicType.PRED_ACC)) {
      if ((coverageFactor * coveredInstances + superClassInstances.size()) / (double)(coverageFactor * classInstances.size() + superClassInstances.size()) < 1 - noise) {
        return -1;
      }
 else {
        return (coverageFactor * coveredInstances + superClassInstances.size() - additionalInstances) / (double)(coverageFactor * classInstances.size() + superClassInstances.size());
      }
    }
  }
 else   if (heuristic.equals(HeuristicType.GEN_FMEASURE)) {
    TreeSet<OWLIndividual> icPos=new TreeSet<OWLIndividual>();
    TreeSet<OWLIndividual> icNeg=new TreeSet<OWLIndividual>();
    OWLClassExpression descriptionNeg=df.getOWLObjectComplementOf(description);
    for (    OWLIndividual ind : classAndSuperClassInstances) {
      if (getReasoner().hasType(description,ind)) {
        icPos.add(ind);
      }
 else       if (getReasoner().hasType(descriptionNeg,ind)) {
        icNeg.add(ind);
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    Set<OWLIndividual> tmp1Pos=Helper.intersection(icPos,classInstancesSet);
    Set<OWLIndividual> tmp1Neg=Helper.intersection(icNeg,negatedClassInstances);
    int tmp1Size=tmp1Pos.size() + tmp1Neg.size();
    int icSize=icPos.size() + icNeg.size();
    double prec=(icSize == 0) ? 0 : tmp1Size / (double)icSize;
    double rec=tmp1Size / (double)(classInstances.size() + negatedClassInstances.size());
    if (rec <= 0.0000001) {
      return -1;
    }
    return getFMeasure(rec,prec);
  }
  throw new Error(""String_Node_Str"");
}"
9399,"public static void main(String[] args) throws Exception {
  String ontologyPath=""String_Node_Str"";
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLOntology ontology=man.loadOntologyFromOntologyDocument(new File(ontologyPath));
  AbstractKnowledgeSource source=new OWLAPIOntology(ontology);
  source.init();
  AbstractReasonerComponent reasoner=new FastInstanceChecker(source);
  reasoner.init();
  ClassLearningProblem lp=new ClassLearningProblem(reasoner);
  lp.setClassToDescribe(new OWLClassImpl(IRI.create(""String_Node_Str"")));
  lp.init();
  AbstractCELA la=new CELOE(lp,reasoner);
  la.init();
  la.start();
  List<? extends EvaluatedDescription> currentlyBestEvaluatedDescriptions=la.getCurrentlyBestEvaluatedDescriptions(0.8);
  System.out.println(currentlyBestEvaluatedDescriptions);
}","public static void main(String[] args) throws Exception {
  ToStringRenderer.getInstance().setRenderer(new DLSyntaxObjectRenderer());
  String ontologyPath=""String_Node_Str"";
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLOntology ontology=man.loadOntologyFromOntologyDocument(new File(ontologyPath));
  AbstractKnowledgeSource source=new OWLAPIOntology(ontology);
  source.init();
  AbstractReasonerComponent reasoner=new ClosedWorldReasoner(source);
  reasoner.init();
  ClassLearningProblem lp=new ClassLearningProblem(reasoner);
  lp.setClassToDescribe(new OWLClassImpl(IRI.create(""String_Node_Str"")));
  lp.init();
  final AbstractCELA la=new CELOE(lp,reasoner);
  la.init();
  Timer timer=new Timer();
  timer.schedule(new TimerTask(){
    int progress=0;
    List<EvaluatedDescriptionClass> result;
    @Override public void run(){
      if (la.isRunning()) {
        System.out.println(la.getCurrentlyBestEvaluatedDescriptions());
      }
    }
  }
,1000,500);
  la.start();
  timer.cancel();
  List<? extends EvaluatedDescription> currentlyBestEvaluatedDescriptions=la.getCurrentlyBestEvaluatedDescriptions(0.8);
  System.out.println(currentlyBestEvaluatedDescriptions);
}"
9400,"@SuppressWarnings(""String_Node_Str"") public SortedSet<OWLIndividual> getIndividualsImplFast(OWLClassExpression description) throws ReasoningMethodUnsupportedException {
  if (description.isOWLThing()) {
    return (TreeSet<OWLIndividual>)individuals.clone();
  }
 else   if (description.isOWLNothing()) {
    return new TreeSet<OWLIndividual>();
  }
 else   if (!description.isAnonymous()) {
    if (classInstancesPos.containsKey(description.asOWLClass())) {
      return (TreeSet<OWLIndividual>)classInstancesPos.get(description).clone();
    }
 else {
      return new TreeSet<OWLIndividual>();
    }
  }
 else   if (description instanceof OWLObjectComplementOf) {
    OWLClassExpression operand=((OWLObjectComplementOf)description).getOperand();
    if (!operand.isAnonymous()) {
      return (TreeSet<OWLIndividual>)classInstancesNeg.get(operand).clone();
    }
    return Helper.difference((TreeSet<OWLIndividual>)individuals.clone(),getIndividualsImpl(operand));
  }
 else   if (description instanceof OWLObjectUnionOf) {
    SortedSet<OWLIndividual> ret=new TreeSet<OWLIndividual>();
    for (    OWLClassExpression operand : ((OWLObjectUnionOf)description).getOperands()) {
      ret.addAll(getIndividualsImpl(operand));
    }
    return ret;
  }
 else   if (description instanceof OWLObjectIntersectionOf) {
    Iterator<OWLClassExpression> iterator=((OWLObjectIntersectionOf)description).getOperands().iterator();
    SortedSet<OWLIndividual> ret=getIndividualsImpl(iterator.next());
    while (iterator.hasNext()) {
      ret.retainAll(getIndividualsImpl(iterator.next()));
    }
    return ret;
  }
 else   if (description instanceof OWLObjectSomeValuesFrom) {
    SortedSet<OWLIndividual> returnSet=new TreeSet<OWLIndividual>();
    OWLObjectPropertyExpression property=((OWLObjectSomeValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectSomeValuesFrom)description).getFiller();
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    Map<OWLIndividual,SortedSet<OWLIndividual>> mapping=opPos.get(property.asOWLObjectProperty());
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : mapping.entrySet()) {
      SortedSet<OWLIndividual> inds=entry.getValue();
      for (      OWLIndividual ind : inds) {
        if (targetSet.contains(ind)) {
          returnSet.add(entry.getKey());
          break;
        }
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLObjectAllValuesFrom) {
    OWLObjectPropertyExpression property=((OWLObjectAllValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectAllValuesFrom)description).getFiller();
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,SortedSet<OWLIndividual>> mapping=opPos.get(property.asOWLObjectProperty());
    SortedSet<OWLIndividual> returnSet=(SortedSet<OWLIndividual>)individuals.clone();
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : mapping.entrySet()) {
      SortedSet<OWLIndividual> inds=entry.getValue();
      for (      OWLIndividual ind : inds) {
        if (!targetSet.contains(ind)) {
          returnSet.remove(entry.getKey());
          break;
        }
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLObjectMinCardinality) {
    OWLObjectPropertyExpression property=((OWLObjectMinCardinality)description).getProperty();
    OWLClassExpression filler=((OWLObjectMinCardinality)description).getFiller();
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,SortedSet<OWLIndividual>> mapping=opPos.get(property.asOWLObjectProperty());
    SortedSet<OWLIndividual> returnSet=new TreeSet<OWLIndividual>();
    int number=((OWLObjectMinCardinality)description).getCardinality();
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : mapping.entrySet()) {
      int nrOfFillers=0;
      int index=0;
      SortedSet<OWLIndividual> inds=entry.getValue();
      if (inds.size() < number) {
        continue;
      }
      for (      OWLIndividual ind : inds) {
        if (nrOfFillers >= number) {
          returnSet.add(entry.getKey());
          break;
        }
        if (inds.size() - index < number) {
          break;
        }
        if (targetSet.contains(ind)) {
          nrOfFillers++;
        }
        index++;
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLObjectMaxCardinality) {
    OWLObjectPropertyExpression property=((OWLObjectMaxCardinality)description).getProperty();
    OWLClassExpression filler=((OWLObjectMaxCardinality)description).getFiller();
    int number=((OWLObjectMaxCardinality)description).getCardinality();
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,SortedSet<OWLIndividual>> mapping=opPos.get(property.asOWLObjectProperty());
    SortedSet<OWLIndividual> returnSet=(SortedSet<OWLIndividual>)individuals.clone();
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : mapping.entrySet()) {
      int nrOfFillers=0;
      int index=0;
      SortedSet<OWLIndividual> inds=entry.getValue();
      if (number < inds.size()) {
        returnSet.add(entry.getKey());
        continue;
      }
      for (      OWLIndividual ind : inds) {
        if (nrOfFillers >= number) {
          break;
        }
        if (inds.size() - index < number) {
          returnSet.add(entry.getKey());
          break;
        }
        if (targetSet.contains(ind)) {
          nrOfFillers++;
        }
        index++;
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLObjectHasValue) {
    OWLObjectPropertyExpression property=((OWLObjectHasValue)description).getProperty();
    OWLIndividual value=((OWLObjectHasValue)description).getValue();
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    Map<OWLIndividual,SortedSet<OWLIndividual>> mapping=opPos.get(property.asOWLObjectProperty());
    SortedSet<OWLIndividual> returnSet=new TreeSet<OWLIndividual>();
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : mapping.entrySet()) {
      if (entry.getValue().contains(value)) {
        returnSet.add(entry.getKey());
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLDataSomeValuesFrom) {
    OWLDataPropertyExpression property=((OWLDataSomeValuesFrom)description).getProperty();
    OWLDataRange filler=((OWLDataSomeValuesFrom)description).getFiller();
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    if (filler.isDatatype()) {
      return new TreeSet<OWLIndividual>(dpPos.get(property).keySet());
    }
 else     if (filler instanceof OWLDatatypeRestriction) {
      OWLDatatype datatype=((OWLDatatypeRestriction)filler).getDatatype();
      Set<OWLFacetRestriction> facetRestrictions=((OWLDatatypeRestriction)filler).getFacetRestrictions();
      if (datatype.isDouble()) {
        double min=-Double.MAX_VALUE;
        double max=Double.MAX_VALUE;
        for (        OWLFacetRestriction facet : facetRestrictions) {
          if (facet.getFacet() == OWLFacet.MIN_INCLUSIVE) {
            min=facet.getFacetValue().parseDouble();
          }
 else           if (facet.getFacet() == OWLFacet.MAX_INCLUSIVE) {
            max=facet.getFacetValue().parseDouble();
          }
        }
        Map<OWLIndividual,SortedSet<Double>> mapping=dd.get(property);
        SortedSet<OWLIndividual> returnSet=new TreeSet<OWLIndividual>();
        for (        Entry<OWLIndividual,SortedSet<Double>> entry : mapping.entrySet()) {
          if (entry.getValue().last() < min || entry.getValue().first() > max) {
            continue;
          }
          for (          Double value : entry.getValue()) {
            if (value >= min && value <= max) {
              returnSet.add(entry.getKey());
              break;
            }
          }
        }
        return returnSet;
      }
    }
  }
 else   if (description instanceof OWLDataHasValue) {
    OWLDataPropertyExpression property=((OWLDataHasValue)description).getProperty();
    OWLLiteral value=((OWLDataHasValue)description).getValue();
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    SortedSet<OWLIndividual> returnSet=new TreeSet<OWLIndividual>();
    Map<OWLIndividual,SortedSet<OWLLiteral>> mapping=dpPos.get(property);
    for (    Entry<OWLIndividual,SortedSet<OWLLiteral>> entry : mapping.entrySet()) {
      if (entry.getValue().contains(value)) {
        returnSet.add(entry.getKey());
      }
    }
    return returnSet;
  }
  throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") public SortedSet<OWLIndividual> getIndividualsImplFast(OWLClassExpression description) throws ReasoningMethodUnsupportedException {
  if (description.isOWLThing()) {
    return (TreeSet<OWLIndividual>)individuals.clone();
  }
 else   if (description.isOWLNothing()) {
    return new TreeSet<OWLIndividual>();
  }
 else   if (!description.isAnonymous()) {
    if (classInstancesPos.containsKey(description.asOWLClass())) {
      return (TreeSet<OWLIndividual>)classInstancesPos.get(description).clone();
    }
 else {
      return new TreeSet<OWLIndividual>();
    }
  }
 else   if (description instanceof OWLObjectComplementOf) {
    OWLClassExpression operand=((OWLObjectComplementOf)description).getOperand();
    if (!operand.isAnonymous()) {
      if (isDefaultNegation()) {
        return new TreeSet<OWLIndividual>(Sets.difference(individuals,classInstancesPos.get(operand)));
      }
 else {
        return (TreeSet<OWLIndividual>)classInstancesNeg.get(operand).clone();
      }
    }
    return Helper.difference((TreeSet<OWLIndividual>)individuals.clone(),getIndividualsImpl(operand));
  }
 else   if (description instanceof OWLObjectUnionOf) {
    SortedSet<OWLIndividual> ret=new TreeSet<OWLIndividual>();
    for (    OWLClassExpression operand : ((OWLObjectUnionOf)description).getOperands()) {
      ret.addAll(getIndividualsImpl(operand));
    }
    return ret;
  }
 else   if (description instanceof OWLObjectIntersectionOf) {
    Iterator<OWLClassExpression> iterator=((OWLObjectIntersectionOf)description).getOperands().iterator();
    SortedSet<OWLIndividual> ret=getIndividualsImpl(iterator.next());
    while (iterator.hasNext()) {
      ret.retainAll(getIndividualsImpl(iterator.next()));
    }
    return ret;
  }
 else   if (description instanceof OWLObjectSomeValuesFrom) {
    SortedSet<OWLIndividual> returnSet=new TreeSet<OWLIndividual>();
    OWLObjectPropertyExpression property=((OWLObjectSomeValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectSomeValuesFrom)description).getFiller();
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    Map<OWLIndividual,SortedSet<OWLIndividual>> mapping=opPos.get(property.asOWLObjectProperty());
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : mapping.entrySet()) {
      SortedSet<OWLIndividual> inds=entry.getValue();
      for (      OWLIndividual ind : inds) {
        if (targetSet.contains(ind)) {
          returnSet.add(entry.getKey());
          break;
        }
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLObjectAllValuesFrom) {
    OWLObjectPropertyExpression property=((OWLObjectAllValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectAllValuesFrom)description).getFiller();
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,SortedSet<OWLIndividual>> mapping=opPos.get(property.asOWLObjectProperty());
    SortedSet<OWLIndividual> returnSet=(SortedSet<OWLIndividual>)individuals.clone();
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : mapping.entrySet()) {
      SortedSet<OWLIndividual> inds=entry.getValue();
      for (      OWLIndividual ind : inds) {
        if (!targetSet.contains(ind)) {
          returnSet.remove(entry.getKey());
          break;
        }
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLObjectMinCardinality) {
    OWLObjectPropertyExpression property=((OWLObjectMinCardinality)description).getProperty();
    OWLClassExpression filler=((OWLObjectMinCardinality)description).getFiller();
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,SortedSet<OWLIndividual>> mapping=opPos.get(property.asOWLObjectProperty());
    SortedSet<OWLIndividual> returnSet=new TreeSet<OWLIndividual>();
    int number=((OWLObjectMinCardinality)description).getCardinality();
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : mapping.entrySet()) {
      int nrOfFillers=0;
      int index=0;
      SortedSet<OWLIndividual> inds=entry.getValue();
      if (inds.size() < number) {
        continue;
      }
      for (      OWLIndividual ind : inds) {
        if (nrOfFillers >= number) {
          returnSet.add(entry.getKey());
          break;
        }
        if (inds.size() - index < number) {
          break;
        }
        if (targetSet.contains(ind)) {
          nrOfFillers++;
        }
        index++;
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLObjectMaxCardinality) {
    OWLObjectPropertyExpression property=((OWLObjectMaxCardinality)description).getProperty();
    OWLClassExpression filler=((OWLObjectMaxCardinality)description).getFiller();
    int number=((OWLObjectMaxCardinality)description).getCardinality();
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    SortedSet<OWLIndividual> targetSet=getIndividualsImpl(filler);
    Map<OWLIndividual,SortedSet<OWLIndividual>> mapping=opPos.get(property.asOWLObjectProperty());
    SortedSet<OWLIndividual> returnSet=(SortedSet<OWLIndividual>)individuals.clone();
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : mapping.entrySet()) {
      int nrOfFillers=0;
      int index=0;
      SortedSet<OWLIndividual> inds=entry.getValue();
      if (number < inds.size()) {
        returnSet.add(entry.getKey());
        continue;
      }
      for (      OWLIndividual ind : inds) {
        if (nrOfFillers >= number) {
          break;
        }
        if (inds.size() - index < number) {
          returnSet.add(entry.getKey());
          break;
        }
        if (targetSet.contains(ind)) {
          nrOfFillers++;
        }
        index++;
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLObjectHasValue) {
    OWLObjectPropertyExpression property=((OWLObjectHasValue)description).getProperty();
    OWLIndividual value=((OWLObjectHasValue)description).getValue();
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    Map<OWLIndividual,SortedSet<OWLIndividual>> mapping=opPos.get(property.asOWLObjectProperty());
    SortedSet<OWLIndividual> returnSet=new TreeSet<OWLIndividual>();
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : mapping.entrySet()) {
      if (entry.getValue().contains(value)) {
        returnSet.add(entry.getKey());
      }
    }
    return returnSet;
  }
 else   if (description instanceof OWLDataSomeValuesFrom) {
    OWLDataPropertyExpression property=((OWLDataSomeValuesFrom)description).getProperty();
    OWLDataRange filler=((OWLDataSomeValuesFrom)description).getFiller();
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    if (filler.isDatatype()) {
      return new TreeSet<OWLIndividual>(dpPos.get(property).keySet());
    }
 else     if (filler instanceof OWLDatatypeRestriction) {
      OWLDatatype datatype=((OWLDatatypeRestriction)filler).getDatatype();
      Set<OWLFacetRestriction> facetRestrictions=((OWLDatatypeRestriction)filler).getFacetRestrictions();
      if (datatype.isDouble()) {
        double min=-Double.MAX_VALUE;
        double max=Double.MAX_VALUE;
        for (        OWLFacetRestriction facet : facetRestrictions) {
          if (facet.getFacet() == OWLFacet.MIN_INCLUSIVE) {
            min=facet.getFacetValue().parseDouble();
          }
 else           if (facet.getFacet() == OWLFacet.MAX_INCLUSIVE) {
            max=facet.getFacetValue().parseDouble();
          }
        }
        Map<OWLIndividual,SortedSet<Double>> mapping=dd.get(property);
        SortedSet<OWLIndividual> returnSet=new TreeSet<OWLIndividual>();
        for (        Entry<OWLIndividual,SortedSet<Double>> entry : mapping.entrySet()) {
          if (entry.getValue().last() < min || entry.getValue().first() > max) {
            continue;
          }
          for (          Double value : entry.getValue()) {
            if (value >= min && value <= max) {
              returnSet.add(entry.getKey());
              break;
            }
          }
        }
        return returnSet;
      }
    }
  }
 else   if (description instanceof OWLDataHasValue) {
    OWLDataPropertyExpression property=((OWLDataHasValue)description).getProperty();
    OWLLiteral value=((OWLDataHasValue)description).getValue();
    if (property.isAnonymous()) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    SortedSet<OWLIndividual> returnSet=new TreeSet<OWLIndividual>();
    Map<OWLIndividual,SortedSet<OWLLiteral>> mapping=dpPos.get(property);
    for (    Entry<OWLIndividual,SortedSet<OWLLiteral>> entry : mapping.entrySet()) {
      if (entry.getValue().contains(value)) {
        returnSet.add(entry.getKey());
      }
    }
    return returnSet;
  }
  throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
}"
9401,"@Override public void init() throws ComponentInitException {
  if (endpointURL == null) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (instances == null) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (recursionDepth == 0) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (ontologySchemaUrls == null) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  Monitor monComp=MonitorFactory.start(""String_Node_Str"").start();
  Monitor monIndexer=MonitorFactory.start(""String_Node_Str"").start();
  indexer=new SchemaIndexer();
  indexer.setOntologySchemaUrls(ontologySchemaUrls);
  indexer.init();
  monIndexer.stop();
  TypeOntology typeOntology=new TypeOntology();
  Monitor monQueryingABox;
  QueryExecutor executor=new QueryExecutor();
  String queryString;
  Set<String> instancesSet=new HashSet<String>(instances);
  Set<String> alreadyQueried=new HashSet<String>();
  Monitor typizeModel;
  if (sparqlQuery == null) {
    ABoxQueryGenerator aGenerator=new ABoxQueryGenerator();
    for (int i=0; i < recursionDepth; i++) {
      if (instancesSet.isEmpty()) {
        log.warn(""String_Node_Str"",i,instancesSet.size());
      }
      log.info(""String_Node_Str"",i,instancesSet.size());
      queryString=aGenerator.createQuery(instancesSet,aboxfilter);
      log.debug(""String_Node_Str"",queryString);
      monQueryingABox=MonitorFactory.start(""String_Node_Str"");
      try {
        executor.executeQuery(queryString,endpointURL,model,defaultGraphURI);
      }
 catch (      Throwable t) {
        t.printStackTrace();
      }
      monQueryingABox.stop();
      typizeModel=MonitorFactory.start(""String_Node_Str"");
      model=typeOntology.addTypetoJena(model,instances,null);
      typizeModel.stop();
      alreadyQueried.addAll(instancesSet);
      instancesSet=difference(alreadyQueried,model);
    }
    log.info(""String_Node_Str"",recursionDepth,instancesSet.size());
  }
 else {
    monQueryingABox=MonitorFactory.getTimeMonitor(""String_Node_Str"").start();
    executor.executeQuery(sparqlQuery,endpointURL,model,null);
    monQueryingABox.stop();
  }
  TBoxQueryGenerator tGenerator=new TBoxQueryGenerator();
  queryString=tGenerator.createQuery(alreadyQueried,tboxfilter);
  Monitor monQueryingTBox=MonitorFactory.start(""String_Node_Str"");
  executor.executeQuery(queryString,endpointURL,model,defaultGraphURI);
  monQueryingTBox.stop();
  Monitor monIndexing=MonitorFactory.start(""String_Node_Str"");
  Set<OntClass> classes=model.listClasses().toSet();
  for (  OntClass ontClass : classes) {
    OntModel hierarchy=indexer.getHierarchyForURI(ontClass.getURI());
    if (hierarchy != null) {
      model.add(hierarchy);
      log.debug(""String_Node_Str"",model);
    }
  }
  monIndexing.stop();
  monComp.stop();
}","@Override public void init() throws ComponentInitException {
  if (endpointURL == null) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (instances == null) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (recursionDepth == 0) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (ontologySchemaUrls == null) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  Monitor monComp=MonitorFactory.start(""String_Node_Str"").start();
  Monitor monIndexer=MonitorFactory.start(""String_Node_Str"").start();
  indexer=new SchemaIndexer();
  indexer.setOntologySchemaUrls(ontologySchemaUrls);
  indexer.init();
  monIndexer.stop();
  TypeOntology typeOntology=new TypeOntology();
  Monitor monQueryingABox;
  QueryExecutor executor=new QueryExecutor();
  String queryString;
  Set<String> instancesSet=new HashSet<String>(instances);
  Set<String> alreadyQueried=new HashSet<String>();
  Monitor typizeModel;
  if (sparqlQuery == null) {
    ABoxQueryGenerator aGenerator=new ABoxQueryGenerator();
    for (int i=0; i < recursionDepth; i++) {
      if (instancesSet.isEmpty()) {
        log.warn(""String_Node_Str"",i,instancesSet.size());
      }
      log.info(""String_Node_Str"",i,instancesSet.size());
      queryString=aGenerator.createQuery(instancesSet,aboxfilter);
      log.debug(""String_Node_Str"",queryString);
      monQueryingABox=MonitorFactory.start(""String_Node_Str"");
      try {
        executor.executeQuery(queryString,endpointURL,model,defaultGraphURI);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      monQueryingABox.stop();
      typizeModel=MonitorFactory.start(""String_Node_Str"");
      model=typeOntology.addTypetoJena(model,instances,null);
      typizeModel.stop();
      alreadyQueried.addAll(instancesSet);
      instancesSet=difference(alreadyQueried,model);
    }
    log.info(""String_Node_Str"",recursionDepth,instancesSet.size());
  }
 else {
    monQueryingABox=MonitorFactory.getTimeMonitor(""String_Node_Str"").start();
    executor.executeQuery(sparqlQuery,endpointURL,model,null);
    monQueryingABox.stop();
  }
  TBoxQueryGenerator tGenerator=new TBoxQueryGenerator();
  queryString=tGenerator.createQuery(alreadyQueried,tboxfilter);
  Monitor monQueryingTBox=MonitorFactory.start(""String_Node_Str"");
  executor.executeQuery(queryString,endpointURL,model,defaultGraphURI);
  monQueryingTBox.stop();
  Monitor monIndexing=MonitorFactory.start(""String_Node_Str"");
  Set<OntClass> classes=model.listClasses().toSet();
  for (  OntClass ontClass : classes) {
    OntModel hierarchy=indexer.getHierarchyForURI(ontClass.getURI());
    if (hierarchy != null) {
      model.add(hierarchy);
      log.debug(""String_Node_Str"",model);
    }
  }
  monIndexing.stop();
  monComp.stop();
}"
9402,"public static Set<String> individualListToStringSet(List<OWLIndividual> individuals){
  Set<String> ret=new TreeSet<String>();
  for (  OWLIndividual ind : individuals) {
    ret.add(ind.toString());
  }
  return ret;
}","public static Set<String> individualListToStringSet(List<OWLIndividual> individuals){
  Set<String> ret=new TreeSet<String>();
  for (  OWLIndividual ind : individuals) {
    ret.add(ind.toStringID());
  }
  return ret;
}"
9403,"public static Set<String> individualSetToStringSet(Set<OWLIndividual> individuals){
  Set<String> ret=new TreeSet<String>();
  for (  OWLIndividual ind : individuals) {
    ret.add(ind.toString());
  }
  return ret;
}","public static Set<String> individualSetToStringSet(Set<OWLIndividual> individuals){
  Set<String> ret=new TreeSet<String>();
  for (  OWLIndividual ind : individuals) {
    ret.add(ind.toStringID());
  }
  return ret;
}"
9404,"@Test public void someOnlyTest() throws ComponentInitException, LearningProblemUnsupportedException {
  SortedSet<OWLIndividual> posExamples=new TreeSet<OWLIndividual>();
  posExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  posExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  posExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  SortedSet<OWLIndividual> negExamples=new TreeSet<OWLIndividual>();
  negExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  negExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  negExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  negExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  SortedSetTuple<OWLIndividual> examples=new SortedSetTuple<OWLIndividual>(posExamples,negExamples);
  ComponentManager cm=ComponentManager.getInstance();
  SparqlSimpleExtractor ks=cm.knowledgeSource(SparqlSimpleExtractor.class);
  ks.setInstances(new ArrayList<String>(Datastructures.individualSetToStringSet(examples.getCompleteSet())));
  ks.setEndpointURL(""String_Node_Str"");
  ks.setRecursionDepth(1);
  ArrayList<String> ontologyUrls=new ArrayList<String>();
  ontologyUrls.add(""String_Node_Str"");
  ks.setOntologySchemaUrls(ontologyUrls);
  ks.setAboxfilter(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  ks.setTboxfilter(""String_Node_Str"");
  ks.init();
  AbstractReasonerComponent rc=cm.reasoner(FastInstanceChecker.class,ks);
  rc.init();
  PosNegLPStandard lp=cm.learningProblem(PosNegLPStandard.class,rc);
  lp.setPositiveExamples(posExamples);
  lp.setNegativeExamples(negExamples);
  lp.setAccuracyMethod(""String_Node_Str"");
  lp.setUseApproximations(false);
  lp.init();
  CELOE la=cm.learningAlgorithm(CELOE.class,lp,rc);
  la.setMaxExecutionTimeInSeconds(10);
  la.init();
  RhoDRDown op=(RhoDRDown)la.getOperator();
  op.setUseNegation(false);
  op.setUseAllConstructor(true);
  op.setUseCardinalityRestrictions(false);
  op.setUseHasValueConstructor(true);
  la.setNoisePercentage(20);
  la.init();
  la.start();
  cm.freeAllComponents();
  OWLClassExpression desc=la.getCurrentlyBestDescription();
}","@Test public void someOnlyTest() throws ComponentInitException, LearningProblemUnsupportedException {
  SortedSet<OWLIndividual> posExamples=new TreeSet<OWLIndividual>();
  posExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  posExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  posExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  SortedSet<OWLIndividual> negExamples=new TreeSet<OWLIndividual>();
  negExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  negExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  negExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  negExamples.add(new OWLNamedIndividualImpl(IRI.create(""String_Node_Str"")));
  SortedSetTuple<OWLIndividual> examples=new SortedSetTuple<OWLIndividual>(posExamples,negExamples);
  SparqlSimpleExtractor ks=new SparqlSimpleExtractor();
  ks.setInstances(new ArrayList<String>(Datastructures.individualSetToStringSet(examples.getCompleteSet())));
  ks.setEndpointURL(""String_Node_Str"");
  ks.setRecursionDepth(1);
  ArrayList<String> ontologyUrls=new ArrayList<String>();
  ontologyUrls.add(""String_Node_Str"");
  ks.setOntologySchemaUrls(ontologyUrls);
  ks.setAboxfilter(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  ks.setTboxfilter(""String_Node_Str"");
  ks.init();
  AbstractReasonerComponent rc=new FastInstanceChecker(ks);
  rc.init();
  PosNegLPStandard lp=new PosNegLPStandard(rc);
  lp.setPositiveExamples(posExamples);
  lp.setNegativeExamples(negExamples);
  lp.setAccuracyMethod(""String_Node_Str"");
  lp.setUseApproximations(false);
  lp.init();
  CELOE la=new CELOE(lp,rc);
  la.setMaxExecutionTimeInSeconds(10);
  la.init();
  RhoDRDown op=(RhoDRDown)la.getOperator();
  op.setUseNegation(false);
  op.setUseAllConstructor(true);
  op.setUseCardinalityRestrictions(false);
  op.setUseHasValueConstructor(true);
  la.setNoisePercentage(20);
  la.init();
  la.start();
  OWLClassExpression desc=la.getCurrentlyBestDescription();
}"
9405,"private boolean occursOnFirstLevel(OWLClassExpression description,OWLClassExpression cls){
  return description.containsConjunct(cls) || (description instanceof OWLObjectUnionOf && ((OWLObjectUnionOf)description).getOperands().contains(cls));
}","private boolean occursOnFirstLevel(OWLClassExpression description,OWLClassExpression cls){
  if (cls.isOWLThing()) {
    return false;
  }
  return description.containsConjunct(cls) || (description instanceof OWLObjectUnionOf && ((OWLObjectUnionOf)description).getOperands().contains(cls));
}"
9406,"public ConfParserConfiguration(Resource source){
  try {
    if (!(source instanceof InputStreamResource)) {
      baseDir=source.getFile().getParentFile().toURI().toString();
    }
 else {
      baseDir=null;
    }
    parser=new ConfParser(source.getInputStream());
    parser.Start();
  }
 catch (  ParseException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public ConfParserConfiguration(Resource source){
  try {
    if (!(source instanceof InputStreamResource)) {
      baseDir=source.getFile().getAbsoluteFile().getParentFile().toURI().toString();
    }
 else {
      baseDir=null;
    }
    parser=new ConfParser(source.getInputStream());
    parser.Start();
  }
 catch (  ParseException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
9407,"@SuppressWarnings({""String_Node_Str""}) public Set<OWLClassExpression> refine(OWLClassExpression description,int maxLength,List<OWLClassExpression> knownRefinements,OWLClassExpression currDomain){
  if (!currDomain.isOWLThing() && !topARefinementsLength.containsKey(currDomain)) {
    topARefinementsLength.put(currDomain,0);
  }
  Set<OWLClassExpression> refinements=new TreeSet<OWLClassExpression>();
  Set<OWLClassExpression> tmp=new HashSet<OWLClassExpression>();
  if (description.isOWLThing()) {
    if (currDomain.isOWLThing()) {
      if (maxLength > topRefinementsLength)       computeTopRefinements(maxLength);
      refinements=(TreeSet<OWLClassExpression>)topRefinementsCumulative.get(maxLength).clone();
    }
 else {
      if (maxLength > topARefinementsLength.get(currDomain)) {
        computeTopRefinements(maxLength,currDomain);
      }
      refinements=(TreeSet<OWLClassExpression>)topARefinementsCumulative.get(currDomain).get(maxLength).clone();
    }
  }
 else   if (description.isOWLNothing()) {
  }
 else   if (!description.isAnonymous()) {
    refinements.addAll(subHierarchy.getSubClasses(description));
    refinements.remove(df.getOWLNothing());
  }
 else   if (description instanceof OWLObjectComplementOf) {
    OWLClassExpression operand=((OWLObjectComplementOf)description).getOperand();
    if (!operand.isAnonymous()) {
      tmp=subHierarchy.getSuperClasses(operand);
      for (      OWLClassExpression c : tmp) {
        if (!c.isOWLThing()) {
          refinements.add(df.getOWLObjectComplementOf(c));
        }
      }
    }
  }
 else   if (description instanceof OWLObjectIntersectionOf) {
    List<OWLClassExpression> operands=((OWLObjectIntersectionOf)description).getOperandsAsList();
    for (    OWLClassExpression child : operands) {
      tmp=refine(child,maxLength - OWLClassExpressionUtils.getLength(description) + OWLClassExpressionUtils.getLength(child),null,currDomain);
      for (      OWLClassExpression c : tmp) {
        List<OWLClassExpression> newChildren=new ArrayList<OWLClassExpression>(operands);
        newChildren.add(c);
        newChildren.remove(child);
        Collections.sort(newChildren);
        OWLClassExpression mc=new OWLObjectIntersectionOfImplExt(newChildren);
        mc=ConceptTransformation.cleanConceptNonRecursive(mc);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc);
        if (checkIntersection((OWLObjectIntersectionOf)mc))         refinements.add(mc);
      }
    }
  }
 else   if (description instanceof OWLObjectUnionOf) {
    List<OWLClassExpression> operands=((OWLObjectUnionOf)description).getOperandsAsList();
    for (    OWLClassExpression child : operands) {
      tmp=refine(child,maxLength - OWLClassExpressionUtils.getLength(description) + OWLClassExpressionUtils.getLength(child),null,currDomain);
      for (      OWLClassExpression c : tmp) {
        List<OWLClassExpression> newChildren=new ArrayList<OWLClassExpression>(operands);
        newChildren.remove(child);
        newChildren.add(c);
        Collections.sort(newChildren);
        OWLObjectUnionOf md=new OWLObjectUnionOfImplExt(newChildren);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(md);
        refinements.add(md);
      }
    }
    if (dropDisjuncts) {
      if (operands.size() == 2) {
        refinements.add(operands.get(0));
        refinements.add(operands.get(1));
      }
 else {
        for (int i=0; i < operands.size(); i++) {
          List<OWLClassExpression> newChildren=new LinkedList<OWLClassExpression>(operands);
          newChildren.remove(i);
          OWLObjectUnionOf md=new OWLObjectUnionOfImplExt(newChildren);
          refinements.add(md);
        }
      }
    }
  }
 else   if (description instanceof OWLObjectSomeValuesFrom) {
    OWLObjectPropertyExpression role=((OWLObjectSomeValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectSomeValuesFrom)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    tmp=refine(filler,maxLength - 2,null,range);
    for (    OWLClassExpression c : tmp) {
      refinements.add(df.getOWLObjectSomeValuesFrom(role,c));
    }
    if (!role.isAnonymous()) {
      Set<OWLObjectProperty> moreSpecialRoles=reasoner.getSubProperties(role.asOWLObjectProperty());
      for (      OWLObjectProperty moreSpecialRole : moreSpecialRoles) {
        refinements.add(df.getOWLObjectSomeValuesFrom(moreSpecialRole,filler));
      }
    }
    if (useCardinalityRestrictions) {
      if (maxLength > OWLClassExpressionUtils.getLength(description) && maxNrOfFillers.get(role) > 1) {
        OWLObjectMinCardinality min=df.getOWLObjectMinCardinality(2,role,filler);
        refinements.add(min);
      }
    }
    if (useHasValueConstructor && filler.isOWLThing()) {
      Set<OWLIndividual> frequentInds=frequentValues.get(role);
      if (frequentInds != null) {
        for (        OWLIndividual ind : frequentInds) {
          OWLObjectHasValue ovr=df.getOWLObjectHasValue(role,ind);
          refinements.add(ovr);
          if (useObjectValueNegation) {
            refinements.add(df.getOWLObjectComplementOf(ovr));
          }
        }
      }
    }
  }
 else   if (description instanceof OWLObjectAllValuesFrom) {
    OWLObjectPropertyExpression role=((OWLObjectAllValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectAllValuesFrom)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    tmp=refine(filler,maxLength - 2,null,range);
    for (    OWLClassExpression c : tmp) {
      refinements.add(df.getOWLObjectAllValuesFrom(role,c));
    }
    if (!filler.isAnonymous() && tmp.size() == 0) {
      refinements.add(df.getOWLObjectAllValuesFrom(role,df.getOWLNothing()));
    }
    if (!role.isAnonymous()) {
      Set<OWLObjectProperty> subProperties=reasoner.getSubProperties(role.asOWLObjectProperty());
      for (      OWLObjectProperty subProperty : subProperties) {
        refinements.add(df.getOWLObjectAllValuesFrom(subProperty,filler));
      }
    }
  }
 else   if (description instanceof OWLObjectCardinalityRestriction) {
    OWLObjectPropertyExpression role=((OWLObjectCardinalityRestriction)description).getProperty();
    OWLClassExpression filler=((OWLObjectCardinalityRestriction)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    int cardinality=((OWLObjectCardinalityRestriction)description).getCardinality();
    if (description instanceof OWLObjectMaxCardinality) {
      if (useNegation || cardinality > 0) {
        tmp=refine(filler,maxLength - 3,null,range);
        for (        OWLClassExpression d : tmp) {
          refinements.add(df.getOWLObjectMaxCardinality(cardinality,role,d));
        }
      }
      if ((useNegation && cardinality > 1) || (!useNegation && cardinality > 2)) {
        refinements.add(df.getOWLObjectMaxCardinality(cardinality - 1,role,filler));
      }
    }
 else     if (description instanceof OWLObjectMinCardinality) {
      tmp=refine(filler,maxLength - 3,null,range);
      for (      OWLClassExpression d : tmp) {
        refinements.add(df.getOWLObjectMinCardinality(cardinality,role,d));
      }
      if (cardinality < maxNrOfFillers.get(role)) {
        refinements.add(df.getOWLObjectMinCardinality(cardinality + 1,role,filler));
      }
    }
  }
 else   if (description instanceof OWLDataSomeValuesFrom) {
    OWLDataPropertyExpression dp=((OWLDataSomeValuesFrom)description).getProperty();
    OWLDataRange dr=((OWLDataSomeValuesFrom)description).getFiller();
    if (dr instanceof OWLDatatypeRestriction) {
      OWLDatatype datatype=((OWLDatatypeRestriction)dr).getDatatype();
      Set<OWLFacetRestriction> facetRestrictions=((OWLDatatypeRestriction)dr).getFacetRestrictions();
      OWLDatatypeRestriction newDatatypeRestriction=null;
      if (datatype.isDouble()) {
        for (        OWLFacetRestriction facetRestriction : facetRestrictions) {
          OWLFacet facet=facetRestriction.getFacet();
          double value=facetRestriction.getFacetValue().parseDouble();
          if (facet == OWLFacet.MAX_INCLUSIVE) {
            int splitIndex=splits.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex - 1;
            if (newSplitIndex >= 0) {
              double newValue=splits.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMaxInclusiveRestriction(newValue);
            }
          }
 else           if (facet == OWLFacet.MIN_INCLUSIVE) {
            int splitIndex=splits.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex + 1;
            if (newSplitIndex < splits.get(dp).size()) {
              double newValue=splits.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMinInclusiveRestriction(newValue);
            }
          }
        }
      }
 else       if (datatype.isInteger()) {
        for (        OWLFacetRestriction facetRestriction : facetRestrictions) {
          OWLFacet facet=facetRestriction.getFacet();
          int value=facetRestriction.getFacetValue().parseInteger();
          if (facet == OWLFacet.MAX_INCLUSIVE) {
            int splitIndex=splitsInt.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex - 1;
            if (newSplitIndex >= 0) {
              int newValue=splitsInt.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMaxInclusiveRestriction(newValue);
            }
          }
 else           if (facet == OWLFacet.MIN_INCLUSIVE) {
            int splitIndex=splitsInt.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex + 1;
            if (newSplitIndex < splitsInt.get(dp).size()) {
              int newValue=splitsInt.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMinInclusiveRestriction(newValue);
            }
          }
        }
      }
      if (newDatatypeRestriction != null) {
        refinements.add(df.getOWLDataSomeValuesFrom(dp,newDatatypeRestriction));
      }
    }
  }
 else   if (description instanceof OWLDataHasValue) {
    OWLDataPropertyExpression dp=((OWLDataHasValue)description).getProperty();
    OWLLiteral value=((OWLDataHasValue)description).getValue();
    if (!dp.isAnonymous()) {
      Set<OWLDataProperty> subDPs=reasoner.getSubProperties(dp.asOWLDataProperty());
      for (      OWLDataProperty subDP : subDPs) {
        refinements.add(df.getOWLDataHasValue(subDP,value));
      }
    }
  }
  if (!description.isOWLThing() && !description.isOWLNothing() && !(description instanceof OWLObjectAllValuesFrom && ((OWLObjectAllValuesFrom)description).getFiller().isOWLNothing())) {
    int topRefLength=maxLength - OWLClassExpressionUtils.getLength(description) - 1;
    if (currDomain.isOWLThing()) {
      if (topRefLength > topRefinementsLength)       computeTopRefinements(topRefLength);
    }
 else     if (topRefLength > topARefinementsLength.get(currDomain))     computeTopRefinements(topRefLength,(OWLClass)currDomain);
    if (topRefLength > 0) {
      Set<OWLClassExpression> topRefs;
      if (currDomain.isOWLThing())       topRefs=topRefinementsCumulative.get(topRefLength);
 else       topRefs=topARefinementsCumulative.get(currDomain).get(topRefLength);
      for (      OWLClassExpression c : topRefs) {
        boolean skip=false;
        if (applyAllFilter) {
          if (c instanceof OWLObjectAllValuesFrom) {
            if (description instanceof OWLNaryBooleanClassExpression) {
              for (              OWLClassExpression child : ((OWLNaryBooleanClassExpression)description).getOperands()) {
                if (child instanceof OWLObjectAllValuesFrom) {
                  OWLObjectPropertyExpression r1=((OWLObjectAllValuesFrom)c).getProperty();
                  OWLObjectPropertyExpression r2=((OWLObjectAllValuesFrom)child).getProperty();
                  if (r1.equals(r2)) {
                    skip=true;
                    break;
                  }
                }
              }
            }
          }
        }
        if (disjointChecks && !c.isAnonymous() && !description.isAnonymous()&& isDisjoint(description,c)) {
          skip=true;
        }
        if (!skip) {
          List<OWLClassExpression> operands=Lists.newArrayList(description,c);
          Collections.sort(operands);
          OWLObjectIntersectionOf mc=new OWLObjectIntersectionOfImplExt(operands);
          mc=(OWLObjectIntersectionOf)ConceptTransformation.cleanConceptNonRecursive(mc);
          ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc);
          if (checkIntersection(mc))           refinements.add(mc);
        }
      }
    }
  }
  return refinements;
}","@SuppressWarnings({""String_Node_Str""}) public Set<OWLClassExpression> refine(OWLClassExpression description,int maxLength,List<OWLClassExpression> knownRefinements,OWLClassExpression currDomain){
  if (!currDomain.isOWLThing() && !topARefinementsLength.containsKey(currDomain)) {
    topARefinementsLength.put(currDomain,0);
  }
  Set<OWLClassExpression> refinements=new TreeSet<OWLClassExpression>();
  Set<OWLClassExpression> tmp=new HashSet<OWLClassExpression>();
  if (description.isOWLThing()) {
    if (currDomain.isOWLThing()) {
      if (maxLength > topRefinementsLength)       computeTopRefinements(maxLength);
      refinements=(TreeSet<OWLClassExpression>)topRefinementsCumulative.get(maxLength).clone();
    }
 else {
      if (maxLength > topARefinementsLength.get(currDomain)) {
        computeTopRefinements(maxLength,currDomain);
      }
      refinements=(TreeSet<OWLClassExpression>)topARefinementsCumulative.get(currDomain).get(maxLength).clone();
    }
  }
 else   if (description.isOWLNothing()) {
  }
 else   if (!description.isAnonymous()) {
    refinements.addAll(subHierarchy.getSubClasses(description));
    refinements.remove(df.getOWLNothing());
  }
 else   if (description instanceof OWLObjectComplementOf) {
    OWLClassExpression operand=((OWLObjectComplementOf)description).getOperand();
    if (!operand.isAnonymous()) {
      tmp=subHierarchy.getSuperClasses(operand);
      for (      OWLClassExpression c : tmp) {
        if (!c.isOWLThing()) {
          refinements.add(df.getOWLObjectComplementOf(c));
        }
      }
    }
  }
 else   if (description instanceof OWLObjectIntersectionOf) {
    List<OWLClassExpression> operands=((OWLObjectIntersectionOf)description).getOperandsAsList();
    for (    OWLClassExpression child : operands) {
      tmp=refine(child,maxLength - OWLClassExpressionUtils.getLength(description) + OWLClassExpressionUtils.getLength(child),null,currDomain);
      for (      OWLClassExpression c : tmp) {
        List<OWLClassExpression> newChildren=new ArrayList<OWLClassExpression>(operands);
        newChildren.add(c);
        newChildren.remove(child);
        Collections.sort(newChildren);
        OWLClassExpression mc=new OWLObjectIntersectionOfImplExt(newChildren);
        mc=ConceptTransformation.cleanConceptNonRecursive(mc);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc);
        if (checkIntersection((OWLObjectIntersectionOf)mc))         refinements.add(mc);
      }
    }
  }
 else   if (description instanceof OWLObjectUnionOf) {
    List<OWLClassExpression> operands=((OWLObjectUnionOf)description).getOperandsAsList();
    for (    OWLClassExpression child : operands) {
      tmp=refine(child,maxLength - OWLClassExpressionUtils.getLength(description) + OWLClassExpressionUtils.getLength(child),null,currDomain);
      for (      OWLClassExpression c : tmp) {
        List<OWLClassExpression> newChildren=new ArrayList<OWLClassExpression>(operands);
        newChildren.remove(child);
        newChildren.add(c);
        Collections.sort(newChildren);
        OWLObjectUnionOf md=new OWLObjectUnionOfImplExt(newChildren);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(md);
        refinements.add(md);
      }
    }
    if (dropDisjuncts) {
      if (operands.size() == 2) {
        refinements.add(operands.get(0));
        refinements.add(operands.get(1));
      }
 else {
        for (int i=0; i < operands.size(); i++) {
          List<OWLClassExpression> newChildren=new LinkedList<OWLClassExpression>(operands);
          newChildren.remove(i);
          OWLObjectUnionOf md=new OWLObjectUnionOfImplExt(newChildren);
          refinements.add(md);
        }
      }
    }
  }
 else   if (description instanceof OWLObjectSomeValuesFrom) {
    OWLObjectPropertyExpression role=((OWLObjectSomeValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectSomeValuesFrom)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    tmp=refine(filler,maxLength - 2,null,range);
    for (    OWLClassExpression c : tmp) {
      refinements.add(df.getOWLObjectSomeValuesFrom(role,c));
    }
    if (!role.isAnonymous()) {
      Set<OWLObjectProperty> moreSpecialRoles=reasoner.getSubProperties(role.asOWLObjectProperty());
      for (      OWLObjectProperty moreSpecialRole : moreSpecialRoles) {
        refinements.add(df.getOWLObjectSomeValuesFrom(moreSpecialRole,filler));
      }
    }
    if (useCardinalityRestrictions) {
      if (maxLength > OWLClassExpressionUtils.getLength(description) && maxNrOfFillers.get(role) > 1) {
        OWLObjectMinCardinality min=df.getOWLObjectMinCardinality(2,role,filler);
        refinements.add(min);
      }
    }
    if (useHasValueConstructor && filler.isOWLThing()) {
      Set<OWLIndividual> frequentInds=frequentValues.get(role);
      if (frequentInds != null) {
        for (        OWLIndividual ind : frequentInds) {
          OWLObjectHasValue ovr=df.getOWLObjectHasValue(role,ind);
          refinements.add(ovr);
          if (useObjectValueNegation) {
            refinements.add(df.getOWLObjectComplementOf(ovr));
          }
        }
      }
    }
  }
 else   if (description instanceof OWLObjectAllValuesFrom) {
    OWLObjectPropertyExpression role=((OWLObjectAllValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectAllValuesFrom)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    tmp=refine(filler,maxLength - 2,null,range);
    for (    OWLClassExpression c : tmp) {
      refinements.add(df.getOWLObjectAllValuesFrom(role,c));
    }
    if (!filler.isOWLNothing() && !filler.isAnonymous() && tmp.size() == 0) {
      refinements.add(df.getOWLObjectAllValuesFrom(role,df.getOWLNothing()));
    }
    if (!role.isAnonymous()) {
      Set<OWLObjectProperty> subProperties=reasoner.getSubProperties(role.asOWLObjectProperty());
      for (      OWLObjectProperty subProperty : subProperties) {
        refinements.add(df.getOWLObjectAllValuesFrom(subProperty,filler));
      }
    }
  }
 else   if (description instanceof OWLObjectCardinalityRestriction) {
    OWLObjectPropertyExpression role=((OWLObjectCardinalityRestriction)description).getProperty();
    OWLClassExpression filler=((OWLObjectCardinalityRestriction)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    int cardinality=((OWLObjectCardinalityRestriction)description).getCardinality();
    if (description instanceof OWLObjectMaxCardinality) {
      if (useNegation || cardinality > 0) {
        tmp=refine(filler,maxLength - 3,null,range);
        for (        OWLClassExpression d : tmp) {
          refinements.add(df.getOWLObjectMaxCardinality(cardinality,role,d));
        }
      }
      if ((useNegation && cardinality > 1) || (!useNegation && cardinality > 2)) {
        refinements.add(df.getOWLObjectMaxCardinality(cardinality - 1,role,filler));
      }
    }
 else     if (description instanceof OWLObjectMinCardinality) {
      tmp=refine(filler,maxLength - 3,null,range);
      for (      OWLClassExpression d : tmp) {
        refinements.add(df.getOWLObjectMinCardinality(cardinality,role,d));
      }
      if (cardinality < maxNrOfFillers.get(role)) {
        refinements.add(df.getOWLObjectMinCardinality(cardinality + 1,role,filler));
      }
    }
  }
 else   if (description instanceof OWLDataSomeValuesFrom) {
    OWLDataPropertyExpression dp=((OWLDataSomeValuesFrom)description).getProperty();
    OWLDataRange dr=((OWLDataSomeValuesFrom)description).getFiller();
    if (dr instanceof OWLDatatypeRestriction) {
      OWLDatatype datatype=((OWLDatatypeRestriction)dr).getDatatype();
      Set<OWLFacetRestriction> facetRestrictions=((OWLDatatypeRestriction)dr).getFacetRestrictions();
      OWLDatatypeRestriction newDatatypeRestriction=null;
      if (datatype.isDouble()) {
        for (        OWLFacetRestriction facetRestriction : facetRestrictions) {
          OWLFacet facet=facetRestriction.getFacet();
          double value=facetRestriction.getFacetValue().parseDouble();
          if (facet == OWLFacet.MAX_INCLUSIVE) {
            int splitIndex=splits.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex - 1;
            if (newSplitIndex >= 0) {
              double newValue=splits.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMaxInclusiveRestriction(newValue);
            }
          }
 else           if (facet == OWLFacet.MIN_INCLUSIVE) {
            int splitIndex=splits.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex + 1;
            if (newSplitIndex < splits.get(dp).size()) {
              double newValue=splits.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMinInclusiveRestriction(newValue);
            }
          }
        }
      }
 else       if (datatype.isInteger()) {
        for (        OWLFacetRestriction facetRestriction : facetRestrictions) {
          OWLFacet facet=facetRestriction.getFacet();
          int value=facetRestriction.getFacetValue().parseInteger();
          if (facet == OWLFacet.MAX_INCLUSIVE) {
            int splitIndex=splitsInt.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex - 1;
            if (newSplitIndex >= 0) {
              int newValue=splitsInt.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMaxInclusiveRestriction(newValue);
            }
          }
 else           if (facet == OWLFacet.MIN_INCLUSIVE) {
            int splitIndex=splitsInt.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex + 1;
            if (newSplitIndex < splitsInt.get(dp).size()) {
              int newValue=splitsInt.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMinInclusiveRestriction(newValue);
            }
          }
        }
      }
      if (newDatatypeRestriction != null) {
        refinements.add(df.getOWLDataSomeValuesFrom(dp,newDatatypeRestriction));
      }
    }
  }
 else   if (description instanceof OWLDataHasValue) {
    OWLDataPropertyExpression dp=((OWLDataHasValue)description).getProperty();
    OWLLiteral value=((OWLDataHasValue)description).getValue();
    if (!dp.isAnonymous()) {
      Set<OWLDataProperty> subDPs=reasoner.getSubProperties(dp.asOWLDataProperty());
      for (      OWLDataProperty subDP : subDPs) {
        refinements.add(df.getOWLDataHasValue(subDP,value));
      }
    }
  }
  if (!description.isOWLThing() && !description.isOWLNothing() && !(description instanceof OWLObjectAllValuesFrom && ((OWLObjectAllValuesFrom)description).getFiller().isOWLNothing())) {
    int topRefLength=maxLength - OWLClassExpressionUtils.getLength(description) - 1;
    if (currDomain.isOWLThing()) {
      if (topRefLength > topRefinementsLength)       computeTopRefinements(topRefLength);
    }
 else     if (topRefLength > topARefinementsLength.get(currDomain))     computeTopRefinements(topRefLength,(OWLClass)currDomain);
    if (topRefLength > 0) {
      Set<OWLClassExpression> topRefs;
      if (currDomain.isOWLThing())       topRefs=topRefinementsCumulative.get(topRefLength);
 else       topRefs=topARefinementsCumulative.get(currDomain).get(topRefLength);
      for (      OWLClassExpression c : topRefs) {
        boolean skip=false;
        if (applyAllFilter) {
          if (c instanceof OWLObjectAllValuesFrom) {
            if (description instanceof OWLNaryBooleanClassExpression) {
              for (              OWLClassExpression child : ((OWLNaryBooleanClassExpression)description).getOperands()) {
                if (child instanceof OWLObjectAllValuesFrom) {
                  OWLObjectPropertyExpression r1=((OWLObjectAllValuesFrom)c).getProperty();
                  OWLObjectPropertyExpression r2=((OWLObjectAllValuesFrom)child).getProperty();
                  if (r1.equals(r2)) {
                    skip=true;
                    break;
                  }
                }
              }
            }
          }
        }
        if (disjointChecks && !c.isAnonymous() && !description.isAnonymous()&& isDisjoint(description,c)) {
          skip=true;
        }
        if (!skip) {
          List<OWLClassExpression> operands=Lists.newArrayList(description,c);
          Collections.sort(operands);
          OWLObjectIntersectionOf mc=new OWLObjectIntersectionOfImplExt(operands);
          mc=(OWLObjectIntersectionOf)ConceptTransformation.cleanConceptNonRecursive(mc);
          ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc);
          if (checkIntersection(mc))           refinements.add(mc);
        }
      }
    }
  }
  return refinements;
}"
9408,"@Override public void init() throws ComponentInitException {
  allExamples=Helper.union(positiveExamples,negativeExamples);
  if (reasoner != null && !reasoner.getIndividuals().containsAll(allExamples)) {
    Set<OWLIndividual> missing=Helper.difference(allExamples,reasoner.getIndividuals());
    double percentage=(double)(missing.size() / allExamples.size());
    percentage=Math.round(percentage * 1000) / 1000;
    String str=""String_Node_Str"" + percentage + ""String_Node_Str"";
    str+=missing.toString();
    if (missing.size() == allExamples.size()) {
      throw new ComponentInitException(str);
    }
    if (percentage < 0.10) {
      logger.warn(str);
    }
 else {
      logger.error(str);
    }
  }
}","@Override public void init() throws ComponentInitException {
  if (positiveExamples.isEmpty()) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (negativeExamples.isEmpty()) {
    logger.warn(""String_Node_Str"" + ""String_Node_Str"");
  }
  SetView<OWLIndividual> overlap=Sets.intersection(positiveExamples,negativeExamples);
  if (!overlap.isEmpty()) {
    logger.warn(""String_Node_Str"");
  }
  allExamples=Helper.union(positiveExamples,negativeExamples);
  if (reasoner != null && !reasoner.getIndividuals().containsAll(allExamples)) {
    Set<OWLIndividual> missing=Helper.difference(allExamples,reasoner.getIndividuals());
    double percentage=(double)(missing.size() / allExamples.size());
    percentage=Math.round(percentage * 1000) / 1000;
    String str=""String_Node_Str"" + percentage + ""String_Node_Str"";
    str+=missing.toString();
    if (missing.size() == allExamples.size()) {
      throw new ComponentInitException(str);
    }
    if (percentage < 0.10) {
      logger.warn(str);
    }
 else {
      logger.error(str);
    }
  }
}"
9409,"@Autowired(required=false) public void setOperator(RhoDRDown operator){
  this.operator=operator;
}","@Autowired(required=false) public void setOperator(LengthLimitedRefinementOperator operator){
  this.operator=operator;
}"
9410,"public RhoDRDown getOperator(){
  return operator;
}","public LengthLimitedRefinementOperator getOperator(){
  return operator;
}"
9411,"@Override public void init() throws ComponentInitException {
  if (getReasoner().getReasonerType() == ReasonerType.DIG) {
    throw new ComponentInitException(""String_Node_Str"" + getName());
  }
  if (!logLevel.equals(CommonConfigOptions.logLevelDefault))   logger.setLevel(Level.toLevel(logLevel,Level.toLevel(CommonConfigOptions.logLevelDefault)));
  if (searchTreeFile == null)   searchTreeFile=new File(defaultSearchTreeFile);
  if (writeSearchTree)   Files.clearFile(searchTreeFile);
  if (heuristic == null) {
    if (getLearningProblem() instanceof PosOnlyLP) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      heuristic=new MultiHeuristic(((PosNegLP)getLearningProblem()).getPositiveExamples().size(),((PosNegLP)getLearningProblem()).getNegativeExamples().size(),negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
    }
  }
 else {
    if (heuristic instanceof MultiHeuristic) {
      MultiHeuristic mh=((MultiHeuristic)heuristic);
      if (mh.getNrOfNegativeExamples() == 0) {
        mh.setNrOfNegativeExamples(((PosNegLP)getLearningProblem()).getNegativeExamples().size());
      }
      int nrPosEx=((PosNegLP)getLearningProblem()).getPositiveExamples().size();
      int nrNegEx=((PosNegLP)getLearningProblem()).getNegativeExamples().size();
      if (mh.getNrOfExamples() == 0) {
        mh.setNrOfExamples(nrPosEx + nrNegEx);
      }
      if (mh.getNrOfNegativeExamples() == 0) {
        mh.setNrOfNegativeExamples(nrNegEx);
      }
    }
  }
  if (learningProblem instanceof PosNegLPStandard) {
    if (((PosNegLPStandard)learningProblem).isUseApproximations()) {
      System.err.println(""String_Node_Str"");
    }
    if (!((PosNegLPStandard)learningProblem).getAccuracyMethod().equals(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
    }
  }
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  if (allowedRoles != null) {
    Helper.checkRoles(reasoner,allowedRoles);
    usedRoles=allowedRoles;
  }
 else   if (ignoredRoles != null) {
    Helper.checkRoles(reasoner,ignoredRoles);
    usedRoles=Helper.difference(reasoner.getObjectProperties(),ignoredRoles);
  }
 else {
    usedRoles=reasoner.getObjectProperties();
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  if (improveSubsumptionHierarchy)   classHierarchy.thinOutSubsumptionHierarchy();
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setReasoner(reasoner);
    ((RhoDRDown)operator).init();
  }
  ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
  ((RhoDRDown)operator).setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  ((RhoDRDown)operator).setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  algorithm=new ROLearner2(learningProblem,reasoner,operator,heuristic,startClass,noisePercentage / (double)100,writeSearchTree,replaceSearchTree,searchTreeFile,useTooWeakList,useOverlyGeneralList,useShortConceptConstruction,usePropernessChecks,maxPosOnlyExpansion,maxExecutionTimeInSeconds,minExecutionTimeInSeconds,guaranteeXgoodDescriptions,maxClassDescriptionTests,forceRefinementLengthIncrease,terminateOnNoiseReached,negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
}","@Override public void init() throws ComponentInitException {
  if (getReasoner().getReasonerType() == ReasonerType.DIG) {
    throw new ComponentInitException(""String_Node_Str"" + getName());
  }
  if (!logLevel.equals(CommonConfigOptions.logLevelDefault))   logger.setLevel(Level.toLevel(logLevel,Level.toLevel(CommonConfigOptions.logLevelDefault)));
  if (searchTreeFile == null)   searchTreeFile=new File(defaultSearchTreeFile);
  if (writeSearchTree)   Files.clearFile(searchTreeFile);
  if (heuristic == null) {
    if (getLearningProblem() instanceof PosOnlyLP) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      heuristic=new MultiHeuristic(((PosNegLP)getLearningProblem()).getPositiveExamples().size(),((PosNegLP)getLearningProblem()).getNegativeExamples().size(),negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
    }
  }
 else {
    if (heuristic instanceof MultiHeuristic) {
      MultiHeuristic mh=((MultiHeuristic)heuristic);
      if (mh.getNrOfNegativeExamples() == 0) {
        mh.setNrOfNegativeExamples(((PosNegLP)getLearningProblem()).getNegativeExamples().size());
      }
      int nrPosEx=((PosNegLP)getLearningProblem()).getPositiveExamples().size();
      int nrNegEx=((PosNegLP)getLearningProblem()).getNegativeExamples().size();
      if (mh.getNrOfExamples() == 0) {
        mh.setNrOfExamples(nrPosEx + nrNegEx);
      }
      if (mh.getNrOfNegativeExamples() == 0) {
        mh.setNrOfNegativeExamples(nrNegEx);
      }
    }
  }
  if (learningProblem instanceof PosNegLPStandard) {
    if (((PosNegLPStandard)learningProblem).isUseApproximations()) {
      System.err.println(""String_Node_Str"");
    }
    if (!((PosNegLPStandard)learningProblem).getAccuracyMethod().equals(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
    }
  }
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  if (allowedRoles != null) {
    Helper.checkRoles(reasoner,allowedRoles);
    usedRoles=allowedRoles;
  }
 else   if (ignoredRoles != null) {
    Helper.checkRoles(reasoner,ignoredRoles);
    usedRoles=Helper.difference(reasoner.getObjectProperties(),ignoredRoles);
  }
 else {
    usedRoles=reasoner.getObjectProperties();
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  if (improveSubsumptionHierarchy)   classHierarchy.thinOutSubsumptionHierarchy();
  if (operator == null) {
    operator=new RhoDRDown();
    if (operator instanceof CustomStartRefinementOperator) {
      ((CustomStartRefinementOperator)operator).setStartClass(startClass);
    }
    if (operator instanceof ReasoningBasedRefinementOperator) {
      ((ReasoningBasedRefinementOperator)operator).setReasoner(reasoner);
    }
    operator.init();
  }
  if (operator instanceof CustomHierarchyRefinementOperator) {
    ((CustomHierarchyRefinementOperator)operator).setClassHierarchy(classHierarchy);
    ((CustomHierarchyRefinementOperator)operator).setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
    ((CustomHierarchyRefinementOperator)operator).setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  }
  algorithm=new ROLearner2(learningProblem,reasoner,operator,heuristic,startClass,noisePercentage / (double)100,writeSearchTree,replaceSearchTree,searchTreeFile,useTooWeakList,useOverlyGeneralList,useShortConceptConstruction,usePropernessChecks,maxPosOnlyExpansion,maxExecutionTimeInSeconds,minExecutionTimeInSeconds,guaranteeXgoodDescriptions,maxClassDescriptionTests,forceRefinementLengthIncrease,terminateOnNoiseReached,negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
}"
9412,"public RhoDRDown getRefinementOperator(){
  return operator;
}","public LengthLimitedRefinementOperator getRefinementOperator(){
  return operator;
}"
9413,"protected <T extends Number & Comparable<Number>>Map<OWLIndividual,SortedSet<T>> getNumericDatatypeMembersImpl(OWLDataProperty datatypeProperty) throws ReasoningMethodUnsupportedException {
  Map<OWLIndividual,SortedSet<OWLLiteral>> mapping=getDatatypeMembersImpl(datatypeProperty);
  Map<OWLIndividual,SortedSet<T>> ret=new TreeMap<OWLIndividual,SortedSet<T>>();
  for (  Entry<OWLIndividual,SortedSet<OWLLiteral>> e : mapping.entrySet()) {
    SortedSet<OWLLiteral> values=e.getValue();
    SortedSet<T> numericValues=new TreeSet<T>();
    for (    OWLLiteral lit : values) {
      try {
        numericValues.add((T)numberFormat.parse(lit.getLiteral()));
      }
 catch (      ParseException e1) {
        e1.printStackTrace();
      }
    }
    ret.put(e.getKey(),numericValues);
  }
  return ret;
}","protected <T extends Number & Comparable<Number>>Map<OWLIndividual,SortedSet<T>> getNumericDatatypeMembersImpl(OWLDataProperty datatypeProperty) throws ReasoningMethodUnsupportedException {
  Map<OWLIndividual,SortedSet<OWLLiteral>> mapping=getDatatypeMembersImpl(datatypeProperty);
  Map<OWLIndividual,SortedSet<T>> ret=new TreeMap<OWLIndividual,SortedSet<T>>();
  for (  Entry<OWLIndividual,SortedSet<OWLLiteral>> entry : mapping.entrySet()) {
    OWLIndividual ind=entry.getKey();
    SortedSet<OWLLiteral> values=entry.getValue();
    SortedSet<T> numericValues=new TreeSet<T>();
    for (    OWLLiteral lit : values) {
      try {
        Number number=numberFormat.parse(lit.getLiteral());
        if (number instanceof Long) {
          number=Double.valueOf(number.toString());
        }
        numericValues.add((T)(number));
      }
 catch (      ParseException e) {
        e.printStackTrace();
      }
    }
    ret.put(ind,numericValues);
  }
  return ret;
}"
9414,"@Override public void setAsText(String s) throws IllegalArgumentException {
  ManchesterOWLSyntaxParser parser=OWLManager.createManchesterParser();
  parser.setStringToParse(s);
  try {
    description=parser.parseClassExpression();
  }
 catch (  Exception e) {
    throw new IllegalArgumentException(e);
  }
}","@Override public void setAsText(String s) throws IllegalArgumentException {
  description=new OWLClassImpl(IRI.create(s));
}"
9415,"public void init() throws ComponentInitException {
  if (isInitialised) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  for (  OWLObjectProperty op : reasoner.getObjectProperties()) {
    opDomains.put(op,reasoner.getDomain(op));
    opRanges.put(op,reasoner.getRange(op));
    if (useHasValueConstructor) {
      Map<OWLIndividual,Integer> opMap=new TreeMap<OWLIndividual,Integer>();
      valueFrequency.put(op,opMap);
      Collection<SortedSet<OWLIndividual>> fillerSets=reasoner.getPropertyMembers(op).values();
      for (      SortedSet<OWLIndividual> fillerSet : fillerSets) {
        for (        OWLIndividual i : fillerSet) {
          Integer value=opMap.get(i);
          if (value != null) {
            opMap.put(i,value + 1);
          }
 else {
            opMap.put(i,1);
          }
        }
      }
      Set<OWLIndividual> frequentInds=new TreeSet<OWLIndividual>();
      for (      OWLIndividual i : opMap.keySet()) {
        if (opMap.get(i) >= frequencyThreshold) {
          frequentInds.add(i);
        }
      }
      frequentValues.put(op,frequentInds);
    }
  }
  for (  OWLDataProperty dp : reasoner.getDatatypeProperties()) {
    dpDomains.put(dp,reasoner.getDomain(dp));
    if (useDataHasValueConstructor) {
      Map<OWLLiteral,Integer> dpMap=new TreeMap<OWLLiteral,Integer>();
      dataValueFrequency.put(dp,dpMap);
      Collection<SortedSet<OWLLiteral>> fillerSets=reasoner.getDatatypeMembers(dp).values();
      for (      SortedSet<OWLLiteral> fillerSet : fillerSets) {
        for (        OWLLiteral i : fillerSet) {
          Integer value=dpMap.get(i);
          if (value != null) {
            dpMap.put(i,value + 1);
          }
 else {
            dpMap.put(i,1);
          }
        }
      }
      Set<OWLLiteral> frequentInds=new TreeSet<OWLLiteral>();
      for (      OWLLiteral i : dpMap.keySet()) {
        if (dpMap.get(i) >= frequencyThreshold) {
          logger.trace(""String_Node_Str"" + i + ""String_Node_Str""+ dpMap.get(i)+ ""String_Node_Str""+ frequencyThreshold);
          frequentInds.add(i);
        }
      }
      frequentDataValues.put(dp,frequentInds);
    }
  }
  valueFrequency=null;
  dataValueFrequency.clear();
  for (  OWLDataProperty dp : reasoner.getNumericDataProperties()) {
    computeSplits(dp);
  }
  for (  OWLDataProperty dp : reasoner.getDoubleDatatypeProperties()) {
    computeSplits(dp);
  }
  if (useCardinalityRestrictions) {
    for (    OWLObjectProperty op : reasoner.getObjectProperties()) {
      int maxFillers=0;
      Map<OWLIndividual,SortedSet<OWLIndividual>> opMembers=reasoner.getPropertyMembers(op);
      for (      SortedSet<OWLIndividual> inds : opMembers.values()) {
        if (inds.size() > maxFillers)         maxFillers=inds.size();
        if (maxFillers >= cardinalityLimit) {
          maxFillers=cardinalityLimit;
          break;
        }
      }
      maxNrOfFillers.put(op,maxFillers);
    }
  }
  isInitialised=true;
}","public void init() throws ComponentInitException {
  if (isInitialised) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  for (  OWLObjectProperty op : reasoner.getObjectProperties()) {
    opDomains.put(op,reasoner.getDomain(op));
    opRanges.put(op,reasoner.getRange(op));
    if (useHasValueConstructor) {
      Map<OWLIndividual,Integer> opMap=new TreeMap<OWLIndividual,Integer>();
      valueFrequency.put(op,opMap);
      Collection<SortedSet<OWLIndividual>> fillerSets=reasoner.getPropertyMembers(op).values();
      for (      SortedSet<OWLIndividual> fillerSet : fillerSets) {
        for (        OWLIndividual i : fillerSet) {
          Integer value=opMap.get(i);
          if (value != null) {
            opMap.put(i,value + 1);
          }
 else {
            opMap.put(i,1);
          }
        }
      }
      Set<OWLIndividual> frequentInds=new TreeSet<OWLIndividual>();
      for (      OWLIndividual i : opMap.keySet()) {
        if (opMap.get(i) >= frequencyThreshold) {
          frequentInds.add(i);
        }
      }
      frequentValues.put(op,frequentInds);
    }
  }
  for (  OWLDataProperty dp : reasoner.getDatatypeProperties()) {
    dpDomains.put(dp,reasoner.getDomain(dp));
    if (useDataHasValueConstructor) {
      Map<OWLLiteral,Integer> dpMap=new TreeMap<OWLLiteral,Integer>();
      dataValueFrequency.put(dp,dpMap);
      Collection<SortedSet<OWLLiteral>> fillerSets=reasoner.getDatatypeMembers(dp).values();
      for (      SortedSet<OWLLiteral> fillerSet : fillerSets) {
        for (        OWLLiteral i : fillerSet) {
          Integer value=dpMap.get(i);
          if (value != null) {
            dpMap.put(i,value + 1);
          }
 else {
            dpMap.put(i,1);
          }
        }
      }
      Set<OWLLiteral> frequentInds=new TreeSet<OWLLiteral>();
      for (      OWLLiteral i : dpMap.keySet()) {
        if (dpMap.get(i) >= frequencyThreshold) {
          logger.trace(""String_Node_Str"" + i + ""String_Node_Str""+ dpMap.get(i)+ ""String_Node_Str""+ frequencyThreshold);
          frequentInds.add(i);
        }
      }
      frequentDataValues.put(dp,frequentInds);
    }
  }
  valueFrequency=null;
  dataValueFrequency.clear();
  for (  OWLDataProperty dp : reasoner.getNumericDataProperties()) {
    computeSplits2(dp);
  }
  for (  OWLDataProperty dp : reasoner.getDoubleDatatypeProperties()) {
    computeSplits(dp);
  }
  if (useCardinalityRestrictions) {
    for (    OWLObjectProperty op : reasoner.getObjectProperties()) {
      int maxFillers=0;
      Map<OWLIndividual,SortedSet<OWLIndividual>> opMembers=reasoner.getPropertyMembers(op);
      for (      SortedSet<OWLIndividual> inds : opMembers.values()) {
        if (inds.size() > maxFillers)         maxFillers=inds.size();
        if (maxFillers >= cardinalityLimit) {
          maxFillers=cardinalityLimit;
          break;
        }
      }
      maxNrOfFillers.put(op,maxFillers);
    }
  }
  if (startClass == null) {
    startClass=df.getOWLThing();
  }
  isInitialised=true;
}"
9416,"/** 
 * Compute a (partial) solution that covers as much positive examples as possible.
 * @return
 */
private EvaluatedQueryTree<String> computeBestPartialSolution(){
  logger.info(""String_Node_Str"");
  bestCurrentScore=Double.NEGATIVE_INFINITY;
  partialSolutionStartTime=System.currentTimeMillis();
  initTodoList(currentPosExampleTrees,currentNegExampleTrees);
  EvaluatedQueryTree<String> bestPartialSolutionTree=null;
  EvaluatedQueryTree<String> currentElement;
  QueryTree<String> currentTree;
  TObjectIntMap<QueryTree<String>> index=new TObjectIntHashMap<QueryTree<String>>(this.currentPosExampleTrees.size() + this.currentNegExampleTrees.size());
  Set<Set<QueryTree<String>>> processedCombinations=new HashSet<>();
  while (!partialSolutionTerminationCriteriaSatisfied()) {
    logger.trace(""String_Node_Str"" + todoList.size());
    currentElement=todoList.poll();
    currentTree=currentElement.getTree();
    logger.trace(""String_Node_Str"" + currentElement.getTreeScore() + ""String_Node_Str""+ solutionAsString(currentElement.getEvaluatedDescription()));
    String s=""String_Node_Str"";
    for (    QueryTree<String> tree : currentElement.getBaseQueryTrees()) {
      s+=this.tree2Individual.get(tree) + ""String_Node_Str"";
    }
    System.out.println(s);
    Iterator<QueryTree<String>> it=currentElement.getFalseNegatives().iterator();
    while (it.hasNext() && !isPartialSolutionTimeExpired() && !isTimeExpired()) {
      QueryTree<String> uncoveredTree=it.next();
      Set<QueryTree<String>> baseQueryTrees=Sets.newHashSet(currentElement.getBaseQueryTrees());
      baseQueryTrees.add(uncoveredTree);
      if (!processedCombinations.add(baseQueryTrees)) {
        System.err.println(""String_Node_Str"");
        continue;
      }
      lggMon.start();
      QueryTree<String> lgg=lggGenerator.getLGG(currentTree,uncoveredTree);
      lggMon.stop();
      Set<EvaluatedQueryTree<String>> solutions=evaluate(lgg,true);
      for (      EvaluatedQueryTree<String> solution : solutions) {
        solution.setBaseQueryTrees(baseQueryTrees);
        expressionTests++;
        double score=solution.getScore();
        double mas=heuristic.getMaximumAchievableScore(solution);
        if (score >= bestCurrentScore) {
          if (score > bestCurrentScore) {
            logger.info(""String_Node_Str"" + solution.getTreeScore());
            logger.info(""String_Node_Str"" + solutionAsString(solution.getEvaluatedDescription()));
            bestCurrentScore=score;
            bestPartialSolutionTree=solution;
          }
          if (bestCurrentScore == 1.0 || mas > score) {
            todo(solution);
          }
        }
 else         if (bestCurrentScore == 1.0 || mas >= bestCurrentScore) {
          todo(solution);
        }
 else {
          logger.trace(""String_Node_Str"" + solution.getTreeScore());
          todo(solution);
        }
        currentPartialSolutions.add(solution);
      }
    }
    currentPartialSolutions.add(currentElement);
  }
  long endTime=System.currentTimeMillis();
  logger.info(""String_Node_Str"" + (endTime - partialSolutionStartTime) + ""String_Node_Str"");
  EvaluatedDescription bestPartialSolution=bestPartialSolutionTree.getEvaluatedDescription();
  logger.info(""String_Node_Str"" + solutionAsString(bestPartialSolution) + ""String_Node_Str""+ bestPartialSolution.getScore()+ ""String_Node_Str"");
  logger.trace(""String_Node_Str"" + lggMon.getTotal() + ""String_Node_Str"");
  logger.trace(""String_Node_Str"" + lggMon.getAvg() + ""String_Node_Str"");
  logger.info(""String_Node_Str"" + lggMon.getHits());
  logger.trace(""String_Node_Str"" + subMon.getTotal() + ""String_Node_Str"");
  logger.trace(""String_Node_Str"" + subMon.getAvg() + ""String_Node_Str"");
  logger.trace(""String_Node_Str"" + subMon.getHits());
  return bestPartialSolutionTree;
}","/** 
 * Compute a (partial) solution that covers as much positive examples as possible.
 * @return
 */
private EvaluatedQueryTree<String> computeBestPartialSolution(){
  logger.info(""String_Node_Str"");
  bestCurrentScore=Double.NEGATIVE_INFINITY;
  partialSolutionStartTime=System.currentTimeMillis();
  initTodoList(currentPosExampleTrees,currentNegExampleTrees);
  EvaluatedQueryTree<String> bestPartialSolutionTree=null;
  EvaluatedQueryTree<String> currentElement;
  QueryTree<String> currentTree;
  TObjectIntMap<QueryTree<String>> index=new TObjectIntHashMap<QueryTree<String>>(this.currentPosExampleTrees.size() + this.currentNegExampleTrees.size());
  Set<Set<QueryTree<String>>> processedCombinations=new HashSet<>();
  while (!partialSolutionTerminationCriteriaSatisfied()) {
    logger.trace(""String_Node_Str"" + todoList.size());
    currentElement=todoList.poll();
    currentTree=currentElement.getTree();
    logger.trace(""String_Node_Str"" + currentElement.getTreeScore() + ""String_Node_Str""+ solutionAsString(currentElement.getEvaluatedDescription()));
    Iterator<QueryTree<String>> it=currentElement.getFalseNegatives().iterator();
    while (it.hasNext() && !isPartialSolutionTimeExpired() && !isTimeExpired()) {
      QueryTree<String> uncoveredTree=it.next();
      Set<QueryTree<String>> baseQueryTrees=Sets.newHashSet(currentElement.getBaseQueryTrees());
      baseQueryTrees.add(uncoveredTree);
      if (!processedCombinations.add(baseQueryTrees)) {
        continue;
      }
      lggMon.start();
      QueryTree<String> lgg=lggGenerator.getLGG(currentTree,uncoveredTree);
      lggMon.stop();
      Set<EvaluatedQueryTree<String>> solutions=evaluate(lgg,true);
      for (      EvaluatedQueryTree<String> solution : solutions) {
        solution.setBaseQueryTrees(baseQueryTrees);
        expressionTests++;
        double score=solution.getScore();
        double mas=heuristic.getMaximumAchievableScore(solution);
        if (score >= bestCurrentScore) {
          if (score > bestCurrentScore) {
            logger.info(""String_Node_Str"" + solution.getTreeScore());
            logger.info(""String_Node_Str"" + solutionAsString(solution.getEvaluatedDescription()));
            bestCurrentScore=score;
            bestPartialSolutionTree=solution;
          }
          if (bestCurrentScore == 1.0 || mas > score) {
            todo(solution);
          }
        }
 else         if (bestCurrentScore == 1.0 || mas >= bestCurrentScore) {
          todo(solution);
        }
 else {
          logger.trace(""String_Node_Str"" + solution.getTreeScore());
          todo(solution);
        }
        currentPartialSolutions.add(solution);
      }
    }
    currentPartialSolutions.add(currentElement);
  }
  long endTime=System.currentTimeMillis();
  logger.info(""String_Node_Str"" + (endTime - partialSolutionStartTime) + ""String_Node_Str"");
  EvaluatedDescription bestPartialSolution=bestPartialSolutionTree.getEvaluatedDescription();
  logger.info(""String_Node_Str"" + solutionAsString(bestPartialSolution) + ""String_Node_Str""+ bestPartialSolution.getScore()+ ""String_Node_Str"");
  logger.trace(""String_Node_Str"" + lggMon.getTotal() + ""String_Node_Str"");
  logger.trace(""String_Node_Str"" + lggMon.getAvg() + ""String_Node_Str"");
  logger.info(""String_Node_Str"" + lggMon.getHits());
  logger.trace(""String_Node_Str"" + subMon.getTotal() + ""String_Node_Str"");
  logger.trace(""String_Node_Str"" + subMon.getAvg() + ""String_Node_Str"");
  logger.trace(""String_Node_Str"" + subMon.getHits());
  return bestPartialSolutionTree;
}"
9417,"/** 
 * Returns all triple patterns in given SPARQL query that have the given node either in subject or in object position, i.e.  the ingoing and outgoing triple patterns.
 * @param query The SPARQL query.
 * @param node
 * @return
 */
public Set<Triple> extractNonOptionalTriplePatterns(Query query,Node node){
  Set<Triple> triplePatterns=new HashSet<Triple>();
  triplePatterns.addAll(extractIngoingTriplePatterns(query,node));
  triplePatterns.addAll(extractOutgoingTriplePatterns(query,node));
  triplePatterns.removeAll(optionalTriplePattern);
  return triplePatterns;
}","/** 
 * Returns all triple patterns in given SPARQL query that have the given node either in subject or in object position, i.e.  the incoming and outgoing triple patterns.
 * @param query The SPARQL query.
 * @param node
 * @return
 */
public Set<Triple> extractNonOptionalTriplePatterns(Query query,Node node){
  Set<Triple> triplePatterns=new HashSet<Triple>();
  triplePatterns.addAll(extractIngoingTriplePatterns(query,node));
  triplePatterns.addAll(extractOutgoingTriplePatterns(query,node));
  triplePatterns.removeAll(optionalTriplePattern);
  return triplePatterns;
}"
9418,"private double precision(String referenceSparqlQuery,String learnedSPARQLQuery){
  List<String> referenceResources=getResult(referenceSparqlQuery);
  if (referenceResources.isEmpty()) {
    logger.error(""String_Node_Str"" + referenceSparqlQuery);
    return 0;
  }
  List<String> learnedResources=getResultSplitted(learnedSPARQLQuery);
  System.err.println(learnedSPARQLQuery);
  if (learnedResources.isEmpty()) {
    logger.error(""String_Node_Str"" + learnedSPARQLQuery);
    System.err.println(learnedSPARQLQuery);
    return 0;
  }
  int overlap=Sets.intersection(Sets.newHashSet(referenceResources),Sets.newHashSet(learnedResources)).size();
  double precision=overlap / (double)learnedResources.size();
  return precision;
}","private double precision(String referenceSparqlQuery,String learnedSPARQLQuery){
  List<String> referenceResources=getResult(referenceSparqlQuery);
  if (referenceResources.isEmpty()) {
    logger.error(""String_Node_Str"" + referenceSparqlQuery);
    return 0;
  }
  List<String> learnedResources=getResultSplitted(learnedSPARQLQuery);
  if (learnedResources.isEmpty()) {
    logger.error(""String_Node_Str"" + learnedSPARQLQuery);
    System.err.println(learnedSPARQLQuery);
    return 0;
  }
  int overlap=Sets.intersection(Sets.newHashSet(referenceResources),Sets.newHashSet(learnedResources)).size();
  double precision=overlap / (double)learnedResources.size();
  return precision;
}"
9419,"public void run(){
  List<String> sparqlQueries=loadSPARQLQueries();
  logger.info(""String_Node_Str"" + sparqlQueries.size());
  int minNrOfExamples=3;
  int maxNrOfExamples=10;
  int stepSize=2;
  double[] noiseIntervals={0.0,0.2,0.4};
  for (int nrOfExamples=minNrOfExamples; nrOfExamples < maxNrOfExamples; nrOfExamples=Math.min(nrOfExamples + stepSize,maxNrOfExamples)) {
    for (int i=0; i < noiseIntervals.length; i++) {
      double noise=noiseIntervals[i];
      FileAppender appender=null;
      try {
        appender=new FileAppender(new SimpleLayout(),""String_Node_Str"" + nrOfExamples + ""String_Node_Str""+ noise+ ""String_Node_Str"",false);
        Logger.getRootLogger().addAppender(appender);
      }
 catch (      IOException e1) {
        e1.printStackTrace();
      }
      logger.info(""String_Node_Str"" + nrOfExamples + ""String_Node_Str""+ noise);
      DescriptiveStatistics bestReturnedSolutionPrecisionStats=new DescriptiveStatistics();
      DescriptiveStatistics bestReturnedSolutionRecallStats=new DescriptiveStatistics();
      DescriptiveStatistics bestReturnedSolutionFMeasureStats=new DescriptiveStatistics();
      DescriptiveStatistics bestSolutionPrecisionStats=new DescriptiveStatistics();
      DescriptiveStatistics bestSolutionRecallStats=new DescriptiveStatistics();
      DescriptiveStatistics bestSolutionFMeasureStats=new DescriptiveStatistics();
      DescriptiveStatistics bestSolutionPositionStats=new DescriptiveStatistics();
      for (      String sparqlQuery : sparqlQueries) {
        if (!sparqlQuery.contains(""String_Node_Str""))         continue;
        logger.info(""String_Node_Str"");
        logger.info(""String_Node_Str"" + sparqlQuery);
        int possibleNrOfExamples=Math.min(getResultCount(sparqlQuery),nrOfExamples);
        try {
          Map<OWLIndividual,QueryTree<String>> generatedExamples=generateExamples(sparqlQuery,possibleNrOfExamples,noise);
          PosNegLPStandard lp=new PosNegLPStandard();
          lp.setPositiveExamples(generatedExamples.keySet());
          QTL2Disjunctive la=new QTL2Disjunctive(lp,qef);
          la.setAllowedNamespaces(allowedNamespaces);
          la.setIgnoredPropperties(ignoredProperties);
          la.setTreeFactory(queryTreeFactory);
          la.setPositiveExampleTrees(generatedExamples);
          la.init();
          la.start();
          List<EvaluatedQueryTree<String>> solutions=new ArrayList<EvaluatedQueryTree<String>>(la.getSolutions());
          EvaluatedQueryTree<String> bestSolution=solutions.get(0);
          logger.info(""String_Node_Str"" + solutions.size() + ""String_Node_Str"");
          logger.info(""String_Node_Str"" + bestSolution.asEvaluatedDescription());
          logger.info(""String_Node_Str"" + bestSolution.getTreeScore());
          String learnedSPARQLQuery=bestSolution.getTree().toSPARQLQueryString(true,false);
          double precision=precision(sparqlQuery,learnedSPARQLQuery);
          bestReturnedSolutionPrecisionStats.addValue(precision);
          double recall=recall(sparqlQuery,learnedSPARQLQuery);
          bestReturnedSolutionRecallStats.addValue(recall);
          double fmeasure=fMeasure(sparqlQuery,learnedSPARQLQuery);
          bestReturnedSolutionFMeasureStats.addValue(fmeasure);
          logger.info(String.format(""String_Node_Str"",precision,recall,fmeasure));
          EvaluatedQueryTree<String> bestMatchingTree=findBestMatchingTree(solutions,sparqlQuery);
          int position=solutions.indexOf(bestMatchingTree);
          bestSolutionPositionStats.addValue(position);
          if (position > 0) {
            logger.info(""String_Node_Str"" + position);
            logger.info(""String_Node_Str"" + bestMatchingTree.asEvaluatedDescription());
            logger.info(""String_Node_Str"" + bestMatchingTree.getTreeScore());
            String bestLearnedSPARQLQuery=bestMatchingTree.getTree().toSPARQLQueryString(true,false);
            precision=precision(sparqlQuery,bestLearnedSPARQLQuery);
            recall=recall(sparqlQuery,bestLearnedSPARQLQuery);
            fmeasure=fMeasure(sparqlQuery,bestLearnedSPARQLQuery);
            logger.info(String.format(""String_Node_Str"",precision,recall,fmeasure));
          }
 else {
            logger.info(""String_Node_Str"");
          }
          bestSolutionRecallStats.addValue(recall);
          bestSolutionPrecisionStats.addValue(precision);
          bestSolutionFMeasureStats.addValue(fmeasure);
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"",e);
          System.exit(0);
        }
      }
      Logger.getRootLogger().removeAppender(appender);
      String result=""String_Node_Str"";
      result+=""String_Node_Str"" + bestReturnedSolutionPrecisionStats;
      result+=""String_Node_Str"" + bestReturnedSolutionRecallStats;
      result+=""String_Node_Str"" + bestReturnedSolutionFMeasureStats;
      result+=""String_Node_Str"" + Arrays.toString(bestSolutionPositionStats.getValues());
      result+=""String_Node_Str"" + bestSolutionPositionStats;
      result+=""String_Node_Str"" + bestSolutionPrecisionStats;
      result+=""String_Node_Str"" + bestSolutionRecallStats;
      result+=""String_Node_Str"" + bestSolutionFMeasureStats;
      logger.info(result);
      try {
        Files.write(result,new File(""String_Node_Str"" + nrOfExamples + ""String_Node_Str""+ noise+ ""String_Node_Str""),Charsets.UTF_8);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}","public void run(){
  List<String> sparqlQueries=loadSPARQLQueries();
  logger.info(""String_Node_Str"" + sparqlQueries.size());
  int minNrOfExamples=3;
  int maxNrOfExamples=10;
  int stepSize=2;
  double[] noiseIntervals={0.0,0.2,0.4};
  for (int nrOfExamples=minNrOfExamples; nrOfExamples < maxNrOfExamples; nrOfExamples=Math.min(nrOfExamples + stepSize,maxNrOfExamples)) {
    for (int i=0; i < noiseIntervals.length; i++) {
      double noise=noiseIntervals[i];
      FileAppender appender=null;
      try {
        appender=new FileAppender(new SimpleLayout(),""String_Node_Str"" + nrOfExamples + ""String_Node_Str""+ noise+ ""String_Node_Str"",false);
        Logger.getRootLogger().addAppender(appender);
      }
 catch (      IOException e1) {
        e1.printStackTrace();
      }
      logger.info(""String_Node_Str"" + nrOfExamples + ""String_Node_Str""+ noise);
      DescriptiveStatistics bestReturnedSolutionPrecisionStats=new DescriptiveStatistics();
      DescriptiveStatistics bestReturnedSolutionRecallStats=new DescriptiveStatistics();
      DescriptiveStatistics bestReturnedSolutionFMeasureStats=new DescriptiveStatistics();
      DescriptiveStatistics bestSolutionPrecisionStats=new DescriptiveStatistics();
      DescriptiveStatistics bestSolutionRecallStats=new DescriptiveStatistics();
      DescriptiveStatistics bestSolutionFMeasureStats=new DescriptiveStatistics();
      DescriptiveStatistics bestSolutionPositionStats=new DescriptiveStatistics();
      for (      String sparqlQuery : sparqlQueries) {
        logger.info(""String_Node_Str"");
        logger.info(""String_Node_Str"" + sparqlQuery);
        int possibleNrOfExamples=Math.min(getResultCount(sparqlQuery),nrOfExamples);
        try {
          Map<OWLIndividual,QueryTree<String>> generatedExamples=generateExamples(sparqlQuery,possibleNrOfExamples,noise);
          PosNegLPStandard lp=new PosNegLPStandard();
          lp.setPositiveExamples(generatedExamples.keySet());
          QTL2Disjunctive la=new QTL2Disjunctive(lp,qef);
          la.setAllowedNamespaces(allowedNamespaces);
          la.setIgnoredPropperties(ignoredProperties);
          la.setTreeFactory(queryTreeFactory);
          la.setPositiveExampleTrees(generatedExamples);
          la.init();
          la.start();
          List<EvaluatedQueryTree<String>> solutions=new ArrayList<EvaluatedQueryTree<String>>(la.getSolutions());
          EvaluatedQueryTree<String> bestSolution=solutions.get(0);
          logger.info(""String_Node_Str"" + solutions.size() + ""String_Node_Str"");
          logger.info(""String_Node_Str"" + bestSolution.asEvaluatedDescription());
          logger.info(""String_Node_Str"" + bestSolution.getTreeScore());
          String learnedSPARQLQuery=bestSolution.getTree().toSPARQLQueryString(true,false);
          double precision=precision(sparqlQuery,learnedSPARQLQuery);
          bestReturnedSolutionPrecisionStats.addValue(precision);
          double recall=recall(sparqlQuery,learnedSPARQLQuery);
          bestReturnedSolutionRecallStats.addValue(recall);
          double fmeasure=fMeasure(sparqlQuery,learnedSPARQLQuery);
          bestReturnedSolutionFMeasureStats.addValue(fmeasure);
          logger.info(String.format(""String_Node_Str"",precision,recall,fmeasure));
          EvaluatedQueryTree<String> bestMatchingTree=findBestMatchingTree(solutions,sparqlQuery);
          int position=solutions.indexOf(bestMatchingTree);
          bestSolutionPositionStats.addValue(position);
          if (position > 0) {
            logger.info(""String_Node_Str"" + position);
            logger.info(""String_Node_Str"" + bestMatchingTree.asEvaluatedDescription());
            logger.info(""String_Node_Str"" + bestMatchingTree.getTreeScore());
            String bestLearnedSPARQLQuery=bestMatchingTree.getTree().toSPARQLQueryString(true,false);
            precision=precision(sparqlQuery,bestLearnedSPARQLQuery);
            recall=recall(sparqlQuery,bestLearnedSPARQLQuery);
            fmeasure=fMeasure(sparqlQuery,bestLearnedSPARQLQuery);
            logger.info(String.format(""String_Node_Str"",precision,recall,fmeasure));
          }
 else {
            logger.info(""String_Node_Str"");
          }
          bestSolutionRecallStats.addValue(recall);
          bestSolutionPrecisionStats.addValue(precision);
          bestSolutionFMeasureStats.addValue(fmeasure);
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"",e);
          System.exit(0);
        }
      }
      Logger.getRootLogger().removeAppender(appender);
      String result=""String_Node_Str"";
      result+=""String_Node_Str"" + bestReturnedSolutionPrecisionStats;
      result+=""String_Node_Str"" + bestReturnedSolutionRecallStats;
      result+=""String_Node_Str"" + bestReturnedSolutionFMeasureStats;
      result+=""String_Node_Str"" + Arrays.toString(bestSolutionPositionStats.getValues());
      result+=""String_Node_Str"" + bestSolutionPositionStats;
      result+=""String_Node_Str"" + bestSolutionPrecisionStats;
      result+=""String_Node_Str"" + bestSolutionRecallStats;
      result+=""String_Node_Str"" + bestSolutionFMeasureStats;
      logger.info(result);
      try {
        Files.write(result,new File(""String_Node_Str"" + nrOfExamples + ""String_Node_Str""+ noise+ ""String_Node_Str""),Charsets.UTF_8);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}"
9420,"private void filterOutGeneralTypes(Multimap<Var,Triple> var2Triples){
  for (  Var var : var2Triples.keySet()) {
    Collection<Triple> triples=var2Triples.get(var);
    Set<Node> types2Remove=new HashSet<>();
    for (    Triple triple : triples) {
      if (triple.getPredicate().matches(RDF.type.asNode()) && triple.getObject().isURI()) {
        types2Remove.addAll(getSuperClasses(triple.getObject()));
      }
    }
    for (Iterator<Triple> iterator=triples.iterator(); iterator.hasNext(); ) {
      Triple triple=iterator.next();
      if (triple.getPredicate().matches(RDF.type.asNode()) && types2Remove.contains(triple.getObject())) {
        iterator.remove();
      }
    }
  }
}","private void filterOutGeneralTypes(Multimap<Var,Triple> var2Triples){
  for (  Var subject : var2Triples.keySet()) {
    Collection<Triple> triplePatterns=var2Triples.get(subject);
    Collection<Triple> triplesPatterns2Remove=new HashSet<Triple>();
    for (    Triple tp : triplePatterns) {
      if (tp.getObject().isURI() && !triplesPatterns2Remove.contains(tp)) {
        Set<Node> superClasses=getSuperClasses(tp.getObject());
        triplesPatterns2Remove.addAll(triplePatterns.stream().filter(t -> superClasses.contains(t.getObject())).collect(Collectors.toSet()));
      }
    }
    triplePatterns.removeAll(triplesPatterns2Remove);
  }
}"
9421,"@Override public void start(){
  stop=false;
  isRunning=true;
  reset();
  nanoStartTime=System.nanoTime();
  double highestAccuracy=0.0;
  OENode nextNode;
  addNode(startClass,null);
  int loop=0;
  while (!terminationCriteriaSatisfied()) {
    if (!singleSuggestionMode && bestEvaluatedDescriptions.getBestAccuracy() > highestAccuracy) {
      highestAccuracy=bestEvaluatedDescriptions.getBestAccuracy();
      expressionTestCountLastImprovement=expressionTests;
      timeLastImprovement=System.nanoTime();
      logger.info(""String_Node_Str"" + dfPercent.format(highestAccuracy) + ""String_Node_Str""+ descriptionToString(bestEvaluatedDescriptions.getBest().getDescription()));
    }
    nextNode=getNextNodeToExpand();
    int horizExp=nextNode.getHorizontalExpansion();
    Monitor mon=MonitorFactory.start(""String_Node_Str"");
    TreeSet<OWLClassExpression> refinements=refineNode(nextNode);
    mon.stop();
    while (refinements.size() != 0) {
      OWLClassExpression refinement=refinements.pollFirst();
      int length=OWLClassExpressionUtils.getLength(refinement);
      if (length > horizExp && OWLClassExpressionUtils.getLength(refinement) <= maxDepth) {
        Monitor mon2=MonitorFactory.start(""String_Node_Str"");
        addNode(refinement,nextNode);
        mon2.stop();
        if (terminationCriteriaSatisfied()) {
          break;
        }
      }
    }
    updateMinMaxHorizExp(nextNode);
    if (writeSearchTree) {
      String treeString=""String_Node_Str"" + bestEvaluatedDescriptions.getBest() + ""String_Node_Str"";
      if (refinements.size() > 1) {
        treeString+=""String_Node_Str"";
        for (        OWLClassExpression n : refinements) {
          treeString+=""String_Node_Str"" + n + ""String_Node_Str"";
        }
      }
      treeString+=startNode.toTreeString(baseURI,prefixes);
      treeString+=""String_Node_Str"";
      if (replaceSearchTree)       Files.createFile(new File(searchTreeFile),treeString);
 else       Files.appendToFile(new File(searchTreeFile),treeString);
    }
    loop++;
  }
  if (stop) {
    logger.info(""String_Node_Str"" + expressionTests + ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
  }
 else {
    totalRuntimeNs=System.nanoTime() - nanoStartTime;
    logger.info(""String_Node_Str"" + Helper.prettyPrintNanoSeconds(totalRuntimeNs) + ""String_Node_Str""+ expressionTests+ ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
    logger.info(reasoner.toString());
  }
  if (singleSuggestionMode) {
    bestEvaluatedDescriptions.add(bestDescription,bestAccuracy,learningProblem);
  }
  logger.info(""String_Node_Str"" + getSolutionString());
  isRunning=false;
}","@Override public void start(){
  stop=false;
  isRunning=true;
  reset();
  nanoStartTime=System.nanoTime();
  double highestAccuracy=0.0;
  OENode nextNode;
  addNode(startClass,null);
  int loop=0;
  while (!terminationCriteriaSatisfied()) {
    if (!singleSuggestionMode && bestEvaluatedDescriptions.getBestAccuracy() > highestAccuracy) {
      highestAccuracy=bestEvaluatedDescriptions.getBestAccuracy();
      expressionTestCountLastImprovement=expressionTests;
      timeLastImprovement=System.nanoTime();
      logger.info(""String_Node_Str"" + dfPercent.format(highestAccuracy) + ""String_Node_Str""+ descriptionToString(bestEvaluatedDescriptions.getBest().getDescription()));
    }
    nextNode=getNextNodeToExpand();
    int horizExp=nextNode.getHorizontalExpansion();
    Monitor mon=MonitorFactory.start(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + nextNode);
    TreeSet<OWLClassExpression> refinements=refineNode(nextNode);
    System.out.println(""String_Node_Str"" + refinements.size() + ""String_Node_Str"");
    mon.stop();
    while (refinements.size() != 0) {
      OWLClassExpression refinement=refinements.pollFirst();
      int length=OWLClassExpressionUtils.getLength(refinement);
      if (length > horizExp && OWLClassExpressionUtils.getDepth(refinement) <= maxDepth) {
        Monitor mon2=MonitorFactory.start(""String_Node_Str"");
        addNode(refinement,nextNode);
        mon2.stop();
        if (terminationCriteriaSatisfied()) {
          break;
        }
      }
    }
    updateMinMaxHorizExp(nextNode);
    if (writeSearchTree) {
      String treeString=""String_Node_Str"" + bestEvaluatedDescriptions.getBest() + ""String_Node_Str"";
      if (refinements.size() > 1) {
        treeString+=""String_Node_Str"";
        for (        OWLClassExpression n : refinements) {
          treeString+=""String_Node_Str"" + n + ""String_Node_Str"";
        }
      }
      treeString+=startNode.toTreeString(baseURI,prefixes);
      treeString+=""String_Node_Str"";
      if (replaceSearchTree)       Files.createFile(new File(searchTreeFile),treeString);
 else       Files.appendToFile(new File(searchTreeFile),treeString);
    }
    loop++;
  }
  if (stop) {
    logger.info(""String_Node_Str"" + expressionTests + ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
  }
 else {
    totalRuntimeNs=System.nanoTime() - nanoStartTime;
    logger.info(""String_Node_Str"" + Helper.prettyPrintNanoSeconds(totalRuntimeNs) + ""String_Node_Str""+ expressionTests+ ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
    logger.info(reasoner.toString());
  }
  if (singleSuggestionMode) {
    bestEvaluatedDescriptions.add(bestDescription,bestAccuracy,learningProblem);
  }
  logger.info(""String_Node_Str"" + getSolutionString());
  isRunning=false;
  System.err.println(MonitorFactory.start(""String_Node_Str""));
  System.err.println(MonitorFactory.start(""String_Node_Str""));
}"
9422,"@Override public void start(){
  stop=false;
  isRunning=true;
  reset();
  nanoStartTime=System.nanoTime();
  double highestAccuracy=0.0;
  OENode nextNode;
  addNode(startClass,null);
  int loop=0;
  while (!terminationCriteriaSatisfied()) {
    if (!singleSuggestionMode && bestEvaluatedDescriptions.getBestAccuracy() > highestAccuracy) {
      highestAccuracy=bestEvaluatedDescriptions.getBestAccuracy();
      expressionTestCountLastImprovement=expressionTests;
      timeLastImprovement=System.nanoTime();
      long durationInMillis=getCurrentRuntimeInMilliSeconds();
      String durationStr=getDurationAsString(durationInMillis);
      logger.info(""String_Node_Str"" + dfPercent.format(highestAccuracy) + ""String_Node_Str""+ durationStr+ ""String_Node_Str""+ descriptionToString(bestEvaluatedDescriptions.getBest().getDescription()));
    }
    nextNode=getNextNodeToExpand();
    int horizExp=nextNode.getHorizontalExpansion();
    Monitor mon=MonitorFactory.start(""String_Node_Str"");
    System.out.print(""String_Node_Str"" + nextNode);
    TreeSet<OWLClassExpression> refinements=refineNode(nextNode);
    System.out.println(""String_Node_Str"" + OWLClassExpressionUtils.getLength(nextNode.getDescription()) + ""String_Node_Str""+ heuristic.getNodeScore(nextNode)+ ""String_Node_Str""+ refinements.size());
    mon.stop();
    while (refinements.size() != 0) {
      OWLClassExpression refinement=refinements.pollFirst();
      int length=OWLClassExpressionUtils.getLength(refinement);
      if (length > horizExp && OWLClassExpressionUtils.getDepth(refinement) <= maxDepth) {
        Monitor mon2=MonitorFactory.start(""String_Node_Str"");
        addNode(refinement,nextNode);
        mon2.stop();
        if (terminationCriteriaSatisfied()) {
          break;
        }
      }
 else {
      }
    }
    updateMinMaxHorizExp(nextNode);
    if (writeSearchTree) {
      String treeString=""String_Node_Str"" + bestEvaluatedDescriptions.getBest() + ""String_Node_Str"";
      if (refinements.size() > 1) {
        treeString+=""String_Node_Str"";
        for (        OWLClassExpression n : refinements) {
          treeString+=""String_Node_Str"" + n + ""String_Node_Str"";
        }
      }
      treeString+=startNode.toTreeString(baseURI,prefixes);
      treeString+=""String_Node_Str"";
      if (replaceSearchTree)       Files.createFile(new File(searchTreeFile),treeString);
 else       Files.appendToFile(new File(searchTreeFile),treeString);
    }
    loop++;
  }
  if (stop) {
    logger.info(""String_Node_Str"" + expressionTests + ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
  }
 else {
    totalRuntimeNs=System.nanoTime() - nanoStartTime;
    logger.info(""String_Node_Str"" + Helper.prettyPrintNanoSeconds(totalRuntimeNs) + ""String_Node_Str""+ expressionTests+ ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
    logger.info(reasoner.toString());
  }
  if (singleSuggestionMode) {
    bestEvaluatedDescriptions.add(bestDescription,bestAccuracy,learningProblem);
  }
  logger.info(""String_Node_Str"" + getSolutionString());
  isRunning=false;
  System.err.println(MonitorFactory.start(""String_Node_Str""));
  System.err.println(MonitorFactory.start(""String_Node_Str""));
  System.err.println(MonitorFactory.start(""String_Node_Str""));
}","@Override public void start(){
  stop=false;
  isRunning=true;
  reset();
  nanoStartTime=System.nanoTime();
  double highestAccuracy=0.0;
  OENode nextNode;
  addNode(startClass,null);
  int loop=0;
  while (!terminationCriteriaSatisfied()) {
    if (!singleSuggestionMode && bestEvaluatedDescriptions.getBestAccuracy() > highestAccuracy) {
      highestAccuracy=bestEvaluatedDescriptions.getBestAccuracy();
      expressionTestCountLastImprovement=expressionTests;
      timeLastImprovement=System.nanoTime();
      long durationInMillis=getCurrentRuntimeInMilliSeconds();
      String durationStr=getDurationAsString(durationInMillis);
      logger.info(""String_Node_Str"" + dfPercent.format(highestAccuracy) + ""String_Node_Str""+ durationStr+ ""String_Node_Str""+ descriptionToString(bestEvaluatedDescriptions.getBest().getDescription()));
    }
    nextNode=getNextNodeToExpand();
    int horizExp=nextNode.getHorizontalExpansion();
    Monitor mon=MonitorFactory.start(""String_Node_Str"");
    TreeSet<OWLClassExpression> refinements=refineNode(nextNode);
    mon.stop();
    while (refinements.size() != 0) {
      OWLClassExpression refinement=refinements.pollFirst();
      int length=OWLClassExpressionUtils.getLength(refinement);
      if (length > horizExp && OWLClassExpressionUtils.getDepth(refinement) <= maxDepth) {
        Monitor mon2=MonitorFactory.start(""String_Node_Str"");
        addNode(refinement,nextNode);
        mon2.stop();
        if (terminationCriteriaSatisfied()) {
          break;
        }
      }
 else {
      }
    }
    updateMinMaxHorizExp(nextNode);
    if (writeSearchTree) {
      String treeString=""String_Node_Str"" + bestEvaluatedDescriptions.getBest() + ""String_Node_Str"";
      if (refinements.size() > 1) {
        treeString+=""String_Node_Str"";
        for (        OWLClassExpression n : refinements) {
          treeString+=""String_Node_Str"" + n + ""String_Node_Str"";
        }
      }
      treeString+=startNode.toTreeString(baseURI,prefixes);
      treeString+=""String_Node_Str"";
      if (replaceSearchTree)       Files.createFile(new File(searchTreeFile),treeString);
 else       Files.appendToFile(new File(searchTreeFile),treeString);
    }
    loop++;
  }
  if (stop) {
    logger.info(""String_Node_Str"" + expressionTests + ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
  }
 else {
    totalRuntimeNs=System.nanoTime() - nanoStartTime;
    logger.info(""String_Node_Str"" + Helper.prettyPrintNanoSeconds(totalRuntimeNs) + ""String_Node_Str""+ expressionTests+ ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
    logger.info(reasoner.toString());
  }
  if (singleSuggestionMode) {
    bestEvaluatedDescriptions.add(bestDescription,bestAccuracy,learningProblem);
  }
  logger.info(""String_Node_Str"" + getSolutionString());
  isRunning=false;
  System.err.println(MonitorFactory.start(""String_Node_Str""));
  System.err.println(MonitorFactory.start(""String_Node_Str""));
  System.err.println(MonitorFactory.start(""String_Node_Str""));
}"
9423,"protected Set<OWLDataProperty> getNumericDataPropertiesImpl() throws ReasoningMethodUnsupportedException {
  return getIntDatatypePropertiesImpl();
}","protected Set<OWLDataProperty> getNumericDataPropertiesImpl() throws ReasoningMethodUnsupportedException {
  return Sets.union(getIntDatatypePropertiesImpl(),getDoubleDatatypePropertiesImpl());
}"
9424,"private void computeApp(OWLClassExpression domain){
  SortedSet<OWLIndividual> individuals1=reasoner.getIndividuals(domain);
  Set<OWLObjectProperty> mostGeneral=reasoner.getObjectProperties();
  Set<OWLObjectProperty> applicableRoles=new TreeSet<OWLObjectProperty>();
  for (  OWLObjectProperty role : mostGeneral) {
    OWLClassExpression d=opDomains.get(role);
    Set<OWLIndividual> individuals2=new HashSet<OWLIndividual>();
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : reasoner.getPropertyMembers(role).entrySet()) {
      OWLIndividual ind=entry.getKey();
      if (!entry.getValue().isEmpty()) {
        individuals2.add(ind);
      }
    }
    boolean disjoint=Sets.intersection(individuals1,individuals2).isEmpty();
    if (!disjoint) {
      applicableRoles.add(role);
    }
  }
  appOP.put(domain,applicableRoles);
  Set<OWLDataProperty> mostGeneralBDPs=reasoner.getBooleanDatatypeProperties();
  Set<OWLDataProperty> applicableBDPs=new TreeSet<OWLDataProperty>();
  for (  OWLDataProperty role : mostGeneralBDPs) {
    OWLClassExpression d=dpDomains.get(role);
    if (!isDisjoint(domain,d))     applicableBDPs.add(role);
  }
  appBD.put(domain,applicableBDPs);
  Set<OWLDataProperty> mostGeneralNumericDPs=reasoner.getNumericDataProperties();
  Set<OWLDataProperty> applicableNumericDPs=new TreeSet<OWLDataProperty>();
  for (  OWLDataProperty role : mostGeneralNumericDPs) {
    OWLClassExpression d=dpDomains.get(role);
    if (!isDisjoint(domain,d))     applicableNumericDPs.add(role);
  }
  Set<OWLDataProperty> mostGeneralSDPs=reasoner.getStringDatatypeProperties();
  Set<OWLDataProperty> applicableSDPs=new TreeSet<OWLDataProperty>();
  for (  OWLDataProperty role : mostGeneralSDPs) {
    OWLClassExpression d=dpDomains.get(role);
    if (!isDisjoint(domain,d))     applicableSDPs.add(role);
  }
  appSD.put(domain,applicableSDPs);
}","private void computeApp(OWLClassExpression domain){
  SortedSet<OWLIndividual> individuals1=reasoner.getIndividuals(domain);
  Set<OWLObjectProperty> mostGeneral=reasoner.getObjectProperties();
  Set<OWLObjectProperty> applicableRoles=new TreeSet<OWLObjectProperty>();
  for (  OWLObjectProperty role : mostGeneral) {
    OWLClassExpression d=opDomains.get(role);
    Set<OWLIndividual> individuals2=new HashSet<OWLIndividual>();
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : reasoner.getPropertyMembers(role).entrySet()) {
      OWLIndividual ind=entry.getKey();
      if (!entry.getValue().isEmpty()) {
        individuals2.add(ind);
      }
    }
    boolean disjoint=Sets.intersection(individuals1,individuals2).isEmpty();
    if (!disjoint) {
      applicableRoles.add(role);
    }
  }
  appOP.put(domain,applicableRoles);
  Set<OWLDataProperty> mostGeneralBDPs=reasoner.getBooleanDatatypeProperties();
  Set<OWLDataProperty> applicableBDPs=new TreeSet<OWLDataProperty>();
  for (  OWLDataProperty role : mostGeneralBDPs) {
    OWLClassExpression d=dpDomains.get(role);
    if (!isDisjoint(domain,d))     applicableBDPs.add(role);
  }
  appBD.put(domain,applicableBDPs);
  Set<OWLDataProperty> mostGeneralNumericDPs=reasoner.getNumericDataProperties();
  Set<OWLDataProperty> applicableNumericDPs=new TreeSet<OWLDataProperty>();
  for (  OWLDataProperty role : mostGeneralNumericDPs) {
    OWLClassExpression d=dpDomains.get(role);
    if (!isDisjoint(domain,d))     applicableNumericDPs.add(role);
  }
  appNumeric.put(domain,applicableNumericDPs);
  Set<OWLDataProperty> mostGeneralSDPs=reasoner.getStringDatatypeProperties();
  Set<OWLDataProperty> applicableSDPs=new TreeSet<OWLDataProperty>();
  for (  OWLDataProperty role : mostGeneralSDPs) {
    OWLClassExpression d=dpDomains.get(role);
    if (!isDisjoint(domain,d))     applicableSDPs.add(role);
  }
  appSD.put(domain,applicableSDPs);
}"
9425,"@Override public void start(){
  stop=false;
  isRunning=true;
  reset();
  nanoStartTime=System.nanoTime();
  double highestAccuracy=0.0;
  OENode nextNode;
  addNode(startClass,null);
  int loop=0;
  while (!terminationCriteriaSatisfied()) {
    if (!singleSuggestionMode && bestEvaluatedDescriptions.getBestAccuracy() > highestAccuracy) {
      highestAccuracy=bestEvaluatedDescriptions.getBestAccuracy();
      expressionTestCountLastImprovement=expressionTests;
      timeLastImprovement=System.nanoTime();
      logger.info(""String_Node_Str"" + dfPercent.format(highestAccuracy) + ""String_Node_Str""+ descriptionToString(bestEvaluatedDescriptions.getBest().getDescription()));
    }
    nextNode=getNextNodeToExpand();
    int horizExp=nextNode.getHorizontalExpansion();
    Monitor mon=MonitorFactory.start(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + nextNode);
    TreeSet<OWLClassExpression> refinements=refineNode(nextNode);
    System.out.println(""String_Node_Str"" + refinements.size() + ""String_Node_Str"");
    mon.stop();
    while (refinements.size() != 0) {
      OWLClassExpression refinement=refinements.pollFirst();
      int length=OWLClassExpressionUtils.getLength(refinement);
      if (length > horizExp && OWLClassExpressionUtils.getDepth(refinement) <= maxDepth) {
        Monitor mon2=MonitorFactory.start(""String_Node_Str"");
        addNode(refinement,nextNode);
        mon2.stop();
        if (terminationCriteriaSatisfied()) {
          break;
        }
      }
    }
    updateMinMaxHorizExp(nextNode);
    if (writeSearchTree) {
      String treeString=""String_Node_Str"" + bestEvaluatedDescriptions.getBest() + ""String_Node_Str"";
      if (refinements.size() > 1) {
        treeString+=""String_Node_Str"";
        for (        OWLClassExpression n : refinements) {
          treeString+=""String_Node_Str"" + n + ""String_Node_Str"";
        }
      }
      treeString+=startNode.toTreeString(baseURI,prefixes);
      treeString+=""String_Node_Str"";
      if (replaceSearchTree)       Files.createFile(new File(searchTreeFile),treeString);
 else       Files.appendToFile(new File(searchTreeFile),treeString);
    }
    loop++;
  }
  if (stop) {
    logger.info(""String_Node_Str"" + expressionTests + ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
  }
 else {
    totalRuntimeNs=System.nanoTime() - nanoStartTime;
    logger.info(""String_Node_Str"" + Helper.prettyPrintNanoSeconds(totalRuntimeNs) + ""String_Node_Str""+ expressionTests+ ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
    logger.info(reasoner.toString());
  }
  if (singleSuggestionMode) {
    bestEvaluatedDescriptions.add(bestDescription,bestAccuracy,learningProblem);
  }
  logger.info(""String_Node_Str"" + getSolutionString());
  isRunning=false;
  System.err.println(MonitorFactory.start(""String_Node_Str""));
  System.err.println(MonitorFactory.start(""String_Node_Str""));
}","@Override public void start(){
  stop=false;
  isRunning=true;
  reset();
  nanoStartTime=System.nanoTime();
  double highestAccuracy=0.0;
  OENode nextNode;
  addNode(startClass,null);
  int loop=0;
  while (!terminationCriteriaSatisfied()) {
    if (!singleSuggestionMode && bestEvaluatedDescriptions.getBestAccuracy() > highestAccuracy) {
      highestAccuracy=bestEvaluatedDescriptions.getBestAccuracy();
      expressionTestCountLastImprovement=expressionTests;
      timeLastImprovement=System.nanoTime();
      logger.info(""String_Node_Str"" + dfPercent.format(highestAccuracy) + ""String_Node_Str""+ descriptionToString(bestEvaluatedDescriptions.getBest().getDescription()));
    }
    nextNode=getNextNodeToExpand();
    int horizExp=nextNode.getHorizontalExpansion();
    Monitor mon=MonitorFactory.start(""String_Node_Str"");
    TreeSet<OWLClassExpression> refinements=refineNode(nextNode);
    mon.stop();
    while (refinements.size() != 0) {
      OWLClassExpression refinement=refinements.pollFirst();
      int length=OWLClassExpressionUtils.getLength(refinement);
      if (length > horizExp && OWLClassExpressionUtils.getDepth(refinement) <= maxDepth) {
        Monitor mon2=MonitorFactory.start(""String_Node_Str"");
        addNode(refinement,nextNode);
        mon2.stop();
        if (terminationCriteriaSatisfied()) {
          break;
        }
      }
    }
    updateMinMaxHorizExp(nextNode);
    if (writeSearchTree) {
      String treeString=""String_Node_Str"" + bestEvaluatedDescriptions.getBest() + ""String_Node_Str"";
      if (refinements.size() > 1) {
        treeString+=""String_Node_Str"";
        for (        OWLClassExpression n : refinements) {
          treeString+=""String_Node_Str"" + n + ""String_Node_Str"";
        }
      }
      treeString+=startNode.toTreeString(baseURI,prefixes);
      treeString+=""String_Node_Str"";
      if (replaceSearchTree)       Files.createFile(new File(searchTreeFile),treeString);
 else       Files.appendToFile(new File(searchTreeFile),treeString);
    }
    loop++;
  }
  if (stop) {
    logger.info(""String_Node_Str"" + expressionTests + ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
  }
 else {
    totalRuntimeNs=System.nanoTime() - nanoStartTime;
    logger.info(""String_Node_Str"" + Helper.prettyPrintNanoSeconds(totalRuntimeNs) + ""String_Node_Str""+ expressionTests+ ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
    logger.info(reasoner.toString());
  }
  if (singleSuggestionMode) {
    bestEvaluatedDescriptions.add(bestDescription,bestAccuracy,learningProblem);
  }
  logger.info(""String_Node_Str"" + getSolutionString());
  isRunning=false;
}"
9426,"/** 
 * This method modifies the subsumption hierarchy such that for each class, there is only a single path to reach it via upward and downward refinement respectively.
 */
public void thinOutSubsumptionHierarchy(){
  TreeMap<OWLClassExpression,SortedSet<OWLClassExpression>> hierarchyDownNew=new TreeMap<OWLClassExpression,SortedSet<OWLClassExpression>>();
  TreeMap<OWLClassExpression,SortedSet<OWLClassExpression>> hierarchyUpNew=new TreeMap<OWLClassExpression,SortedSet<OWLClassExpression>>();
  Set<OWLClassExpression> conceptsInSubsumptionHierarchy=new TreeSet<OWLClassExpression>();
  conceptsInSubsumptionHierarchy.addAll(subsumptionHierarchyUp.keySet());
  conceptsInSubsumptionHierarchy.addAll(subsumptionHierarchyDown.keySet());
  for (  OWLClassExpression c : conceptsInSubsumptionHierarchy) {
    hierarchyDownNew.put(c,new TreeSet<OWLClassExpression>());
    hierarchyUpNew.put(c,new TreeSet<OWLClassExpression>());
  }
  for (  OWLClassExpression c : conceptsInSubsumptionHierarchy) {
    SortedSet<OWLClassExpression> moreGeneral=subsumptionHierarchyUp.get(c);
    if (moreGeneral != null && moreGeneral.size() != 0) {
      OWLClassExpression chosenParent=moreGeneral.first();
      hierarchyDownNew.get(chosenParent).add(c);
    }
  }
  for (  OWLClassExpression c : conceptsInSubsumptionHierarchy) {
    SortedSet<OWLClassExpression> moreSpecial=subsumptionHierarchyDown.get(c);
    if (moreSpecial != null && moreSpecial.size() != 0) {
      OWLClassExpression chosenParent=moreSpecial.first();
      hierarchyUpNew.get(chosenParent).add(c);
    }
  }
  subsumptionHierarchyDown=hierarchyDownNew;
  subsumptionHierarchyUp=hierarchyUpNew;
}","/** 
 * This method modifies the subsumption hierarchy such that for each class, there is only a single path to reach it via upward and downward refinement respectively.
 */
public void thinOutSubsumptionHierarchy(){
  TreeMap<OWLClassExpression,SortedSet<OWLClassExpression>> hierarchyDownNew=new TreeMap<OWLClassExpression,SortedSet<OWLClassExpression>>();
  TreeMap<OWLClassExpression,SortedSet<OWLClassExpression>> hierarchyUpNew=new TreeMap<OWLClassExpression,SortedSet<OWLClassExpression>>();
  Set<OWLClassExpression> conceptsInSubsumptionHierarchy=new TreeSet<OWLClassExpression>();
  conceptsInSubsumptionHierarchy.addAll(subsumptionHierarchyUp.keySet());
  conceptsInSubsumptionHierarchy.addAll(subsumptionHierarchyDown.keySet());
  for (  OWLClassExpression c : conceptsInSubsumptionHierarchy) {
    hierarchyDownNew.put(c,new TreeSet<OWLClassExpression>());
    hierarchyUpNew.put(c,new TreeSet<OWLClassExpression>());
  }
  for (  OWLClassExpression c : conceptsInSubsumptionHierarchy) {
    SortedSet<OWLClassExpression> moreGeneral=subsumptionHierarchyUp.get(c);
    if (moreGeneral != null && moreGeneral.size() != 0) {
      OWLClassExpression chosenParent=moreGeneral.first();
      hierarchyDownNew.get(chosenParent).add(c);
    }
  }
  for (  OWLClassExpression c : conceptsInSubsumptionHierarchy) {
    SortedSet<OWLClassExpression> moreSpecial=subsumptionHierarchyDown.get(c);
    if (moreSpecial != null && moreSpecial.size() != 0) {
      OWLClassExpression chosenParent=moreSpecial.first();
      hierarchyUpNew.get(chosenParent).add(c);
    }
  }
  hierarchyDownNew.put(df.getOWLThing(),subsumptionHierarchyDown.get(df.getOWLThing()));
  hierarchyUpNew.put(df.getOWLNothing(),subsumptionHierarchyUp.get(df.getOWLNothing()));
  subsumptionHierarchyDown=hierarchyDownNew;
  subsumptionHierarchyUp=hierarchyUpNew;
}"
9427,"@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<OWLClass>();
  atomicRoles=new TreeSet<OWLObjectProperty>();
  datatypeProperties=new TreeSet<OWLDataProperty>();
  individuals=new TreeSet<OWLIndividual>();
  df=new OWLDataFactoryImpl();
  manager=OWLManager.createOWLOntologyManager();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLOntologyKnowledgeSource) {
      ontology=((OWLOntologyKnowledgeSource)source).createOWLOntology(manager);
      owlAPIOntologies.add(ontology);
    }
 else {
      throw new ComponentInitException(""String_Node_Str"" + source.getClass().getName());
    }
    atomicConcepts.addAll(ontology.getClassesInSignature(Imports.INCLUDED));
    atomicRoles.addAll(ontology.getObjectPropertiesInSignature(Imports.INCLUDED));
    datatypeProperties.addAll(ontology.getDataPropertiesInSignature(Imports.INCLUDED));
    individuals.addAll(ontology.getIndividualsInSignature(Imports.INCLUDED));
    OWLDocumentFormat format=manager.getOntologyFormat(ontology);
    if (format instanceof PrefixDocumentFormat) {
      prefixes.putAll(((PrefixDocumentFormat)format).getPrefixName2PrefixMap());
      baseURI=((PrefixDocumentFormat)format).getDefaultPrefix();
      prefixes.remove(""String_Node_Str"");
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<OWLOntology>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<OWLOntologyChange>();
    for (    OWLOntology ont : owlAPIOntologies) {
      for (      OWLImportsDeclaration importDeclaration : ont.getImportsDeclarations()) {
        addImports.add(new AddImport(ontology,importDeclaration));
      }
    }
    manager.applyChanges(addImports);
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  initBaseReasoner();
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS);
  }
 else {
    PelletExplanation expGen=new PelletExplanation(ontology);
    System.out.println(expGen.getInconsistencyExplanation());
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY);
    throw new ComponentInitException(""String_Node_Str"");
  }
  df=manager.getOWLDataFactory();
  Set<OWLDataProperty> numericDataProperties=new HashSet<OWLDataProperty>();
  for (  OWLDataProperty dataProperty : datatypeProperties) {
    Collection<OWLDataRange> ranges=EntitySearcher.getRanges(dataProperty,owlAPIOntologies);
    Iterator<OWLDataRange> it=ranges.iterator();
    if (it.hasNext()) {
      OWLDataRange range=it.next();
      if (range.isDatatype() && range.asOWLDatatype().isBuiltIn()) {
        datatype2Properties.put(range.asOWLDatatype().getBuiltInDatatype(),dataProperty);
        if (isNumericDatatype(range.asOWLDatatype())) {
          numericDataProperties.add(dataProperty);
        }
      }
    }
 else {
      datatype2Properties.put(OWL2Datatype.XSD_STRING,dataProperty);
    }
  }
  Iterator<OWLClass> it=atomicConcepts.iterator();
  while (it.hasNext()) {
    OWLClass cls=(OWLClass)it.next();
    if (cls.getIRI().isReservedVocabulary()) {
      it.remove();
    }
  }
}","@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<OWLClass>();
  atomicRoles=new TreeSet<OWLObjectProperty>();
  datatypeProperties=new TreeSet<OWLDataProperty>();
  individuals=new TreeSet<OWLIndividual>();
  df=new OWLDataFactoryImpl();
  manager=OWLManager.createOWLOntologyManager();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLOntologyKnowledgeSource) {
      ontology=((OWLOntologyKnowledgeSource)source).createOWLOntology(manager);
      owlAPIOntologies.add(ontology);
    }
 else {
      throw new ComponentInitException(""String_Node_Str"" + source.getClass().getName());
    }
    atomicConcepts.addAll(ontology.getClassesInSignature(Imports.INCLUDED));
    atomicRoles.addAll(ontology.getObjectPropertiesInSignature(Imports.INCLUDED));
    datatypeProperties.addAll(ontology.getDataPropertiesInSignature(Imports.INCLUDED));
    individuals.addAll(ontology.getIndividualsInSignature(Imports.INCLUDED));
    OWLDocumentFormat format=manager.getOntologyFormat(ontology);
    if (format instanceof PrefixDocumentFormat) {
      prefixes.putAll(((PrefixDocumentFormat)format).getPrefixName2PrefixMap());
      baseURI=((PrefixDocumentFormat)format).getDefaultPrefix();
      prefixes.remove(""String_Node_Str"");
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<OWLOntology>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<OWLOntologyChange>();
    for (    OWLOntology ont : owlAPIOntologies) {
      for (      OWLImportsDeclaration importDeclaration : ont.getImportsDeclarations()) {
        addImports.add(new AddImport(ontology,importDeclaration));
      }
    }
    manager.applyChanges(addImports);
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  initBaseReasoner();
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS);
  }
 else {
    PelletExplanation expGen=new PelletExplanation(ontology);
    System.out.println(expGen.getInconsistencyExplanation());
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY);
    throw new ComponentInitException(""String_Node_Str"");
  }
  df=manager.getOWLDataFactory();
  Set<OWLDataProperty> numericDataProperties=new HashSet<OWLDataProperty>();
  for (  OWLDataProperty dataProperty : datatypeProperties) {
    Collection<OWLDataRange> ranges=EntitySearcher.getRanges(dataProperty,owlAPIOntologies);
    Iterator<OWLDataRange> it=ranges.iterator();
    if (it.hasNext()) {
      OWLDataRange range=it.next();
      if (range.isDatatype() && range.asOWLDatatype().isBuiltIn()) {
        datatype2Properties.put(range.asOWLDatatype().getBuiltInDatatype(),dataProperty);
        if (isNumericDatatype(range.asOWLDatatype())) {
          numericDataProperties.add(dataProperty);
        }
      }
    }
 else {
      datatype2Properties.put(OWL2Datatype.XSD_STRING,dataProperty);
    }
  }
  Iterator<OWLClass> it=atomicConcepts.iterator();
  while (it.hasNext()) {
    OWLClass cls=(OWLClass)it.next();
    if (cls.getIRI().isReservedVocabulary()) {
      it.remove();
    }
  }
  minimizer=new OWLClassExpressionMinimizer(df,this);
}"
9428,"@Override public OWLClassExpression getDomainImpl(OWLDataProperty datatypeProperty){
  NodeSet<OWLClass> nodeSet=reasoner.getDataPropertyDomains(datatypeProperty,true);
  OWLClassExpression domain=asIntersection(nodeSet);
  logger.trace(""String_Node_Str"" + datatypeProperty + ""String_Node_Str""+ domain+ ""String_Node_Str"");
  return domain;
}","@Override public OWLClassExpression getDomainImpl(OWLDataProperty dataProperty){
  Set<OWLClassExpression> domains=new HashSet<OWLClassExpression>();
  domains.addAll(EntitySearcher.getDomains(dataProperty,ontology));
  NodeSet<OWLDataProperty> superProperties=reasoner.getSuperDataProperties(dataProperty,false);
  for (  OWLDataProperty supProp : superProperties.getFlattened()) {
    domains.addAll(EntitySearcher.getDomains(supProp,ontology));
  }
  NodeSet<OWLClass> nodeSet=reasoner.getDataPropertyDomains(dataProperty,true);
  domains.addAll(nodeSet.getFlattened());
  domains.remove(df.getOWLThing());
  OWLClassExpression domain;
  if (domains.size() > 1) {
    domain=df.getOWLObjectIntersectionOf(domains);
    domain=minimizer.minimize(domain);
  }
 else   if (domains.size() == 1) {
    domain=domains.iterator().next();
  }
 else {
    domain=df.getOWLThing();
  }
  logger.trace(""String_Node_Str"",dataProperty,domain);
  return domain;
}"
9429,"private void computeMgrRecursive(OWLClass domain,Set<OWLObjectProperty> currProperties,Set<OWLObjectProperty> mgrTmp){
  for (  OWLObjectProperty prop : currProperties) {
    if (appOP.get(domain).contains(prop))     mgrTmp.add(prop);
 else     computeMgrRecursive(domain,reasoner.getSubProperties(prop),mgrTmp);
  }
}","private void computeMgrRecursive(OWLClassExpression domain,Set<OWLObjectProperty> currProperties,Set<OWLObjectProperty> mgrTmp){
  for (  OWLObjectProperty prop : currProperties) {
    if (appOP.get(domain).contains(prop))     mgrTmp.add(prop);
 else     computeMgrRecursive(domain,reasoner.getSubProperties(prop),mgrTmp);
  }
}"
9430,"public SortedSet<OWLClassExpression> getNegClassCandidates(OWLClass index){
  return getNegClassCandidatesRecursive(index,df.getOWLNothing());
}","public SortedSet<OWLClassExpression> getNegClassCandidates(OWLClassExpression index){
  return getNegClassCandidatesRecursive(index,df.getOWLNothing());
}"
9431,"private void computeApp(OWLClass domain){
  SortedSet<OWLIndividual> individuals1=reasoner.getIndividuals(domain);
  Set<OWLObjectProperty> mostGeneral=reasoner.getObjectProperties();
  Set<OWLObjectProperty> applicableRoles=new TreeSet<OWLObjectProperty>();
  for (  OWLObjectProperty role : mostGeneral) {
    OWLClassExpression d=opDomains.get(role);
    Set<OWLIndividual> individuals2=new HashSet<OWLIndividual>();
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : reasoner.getPropertyMembers(role).entrySet()) {
      OWLIndividual ind=entry.getKey();
      if (!entry.getValue().isEmpty()) {
        individuals2.add(ind);
      }
    }
    boolean disjoint=Sets.intersection(individuals1,individuals2).isEmpty();
    if (!disjoint) {
      applicableRoles.add(role);
    }
  }
  appOP.put(domain,applicableRoles);
  Set<OWLDataProperty> mostGeneralBDPs=reasoner.getBooleanDatatypeProperties();
  Set<OWLDataProperty> applicableBDPs=new TreeSet<OWLDataProperty>();
  for (  OWLDataProperty role : mostGeneralBDPs) {
    OWLClassExpression d=dpDomains.get(role);
    if (!isDisjoint(domain,d))     applicableBDPs.add(role);
  }
  appBD.put(domain,applicableBDPs);
  Set<OWLDataProperty> mostGeneralNumericDPs=reasoner.getNumericDataProperties();
  Set<OWLDataProperty> applicableNumericDPs=new TreeSet<OWLDataProperty>();
  for (  OWLDataProperty role : mostGeneralNumericDPs) {
    OWLClassExpression d=dpDomains.get(role);
    if (!isDisjoint(domain,d))     applicableNumericDPs.add(role);
  }
  Set<OWLDataProperty> mostGeneralSDPs=reasoner.getStringDatatypeProperties();
  Set<OWLDataProperty> applicableSDPs=new TreeSet<OWLDataProperty>();
  for (  OWLDataProperty role : mostGeneralSDPs) {
    OWLClassExpression d=dpDomains.get(role);
    if (!isDisjoint(domain,d))     applicableSDPs.add(role);
  }
  appSD.put(domain,applicableSDPs);
}","private void computeApp(OWLClassExpression domain){
  SortedSet<OWLIndividual> individuals1=reasoner.getIndividuals(domain);
  Set<OWLObjectProperty> mostGeneral=reasoner.getObjectProperties();
  Set<OWLObjectProperty> applicableRoles=new TreeSet<OWLObjectProperty>();
  for (  OWLObjectProperty role : mostGeneral) {
    OWLClassExpression d=opDomains.get(role);
    Set<OWLIndividual> individuals2=new HashSet<OWLIndividual>();
    for (    Entry<OWLIndividual,SortedSet<OWLIndividual>> entry : reasoner.getPropertyMembers(role).entrySet()) {
      OWLIndividual ind=entry.getKey();
      if (!entry.getValue().isEmpty()) {
        individuals2.add(ind);
      }
    }
    boolean disjoint=Sets.intersection(individuals1,individuals2).isEmpty();
    if (!disjoint) {
      applicableRoles.add(role);
    }
  }
  appOP.put(domain,applicableRoles);
  Set<OWLDataProperty> mostGeneralBDPs=reasoner.getBooleanDatatypeProperties();
  Set<OWLDataProperty> applicableBDPs=new TreeSet<OWLDataProperty>();
  for (  OWLDataProperty role : mostGeneralBDPs) {
    OWLClassExpression d=dpDomains.get(role);
    if (!isDisjoint(domain,d))     applicableBDPs.add(role);
  }
  appBD.put(domain,applicableBDPs);
  Set<OWLDataProperty> mostGeneralNumericDPs=reasoner.getNumericDataProperties();
  Set<OWLDataProperty> applicableNumericDPs=new TreeSet<OWLDataProperty>();
  for (  OWLDataProperty role : mostGeneralNumericDPs) {
    OWLClassExpression d=dpDomains.get(role);
    if (!isDisjoint(domain,d))     applicableNumericDPs.add(role);
  }
  Set<OWLDataProperty> mostGeneralSDPs=reasoner.getStringDatatypeProperties();
  Set<OWLDataProperty> applicableSDPs=new TreeSet<OWLDataProperty>();
  for (  OWLDataProperty role : mostGeneralSDPs) {
    OWLClassExpression d=dpDomains.get(role);
    if (!isDisjoint(domain,d))     applicableSDPs.add(role);
  }
  appSD.put(domain,applicableSDPs);
}"
9432,"private void computeTopRefinements(int maxLength,OWLClass domain){
  long topComputationTimeStartNs=System.nanoTime();
  if (domain == null && m.size() == 0)   computeM();
  if (domain != null && !mA.containsKey(domain))   computeM(domain);
  int refinementsLength;
  if (domain == null) {
    refinementsLength=topRefinementsLength;
  }
 else {
    if (!topARefinementsLength.containsKey(domain))     topARefinementsLength.put(domain,0);
    refinementsLength=topARefinementsLength.get(domain);
  }
  for (int i=refinementsLength + 1; i <= maxLength; i++) {
    combos.put(i,MathOperations.getCombos(i,mMaxLength));
    if (domain == null) {
      topRefinements.put(i,new TreeSet<OWLClassExpression>());
    }
 else {
      if (!topARefinements.containsKey(domain))       topARefinements.put(domain,new TreeMap<Integer,SortedSet<OWLClassExpression>>());
      topARefinements.get(domain).put(i,new TreeSet<OWLClassExpression>());
    }
    for (    List<Integer> combo : combos.get(i)) {
      if (combo.size() == 1) {
        if (domain == null)         topRefinements.get(i).addAll(m.get(i));
 else         topARefinements.get(domain).get(i).addAll(mA.get(domain).get(i));
      }
 else {
        boolean validCombo=true;
        for (        Integer j : combo) {
          if ((domain == null && m.get(j).size() == 0) || (domain != null && mA.get(domain).get(j).size() == 0))           validCombo=false;
        }
        if (validCombo) {
          SortedSet<OWLObjectUnionOf> baseSet=new TreeSet<OWLObjectUnionOf>();
          for (          Integer j : combo) {
            if (domain == null)             baseSet=MathOperations.incCrossProduct(baseSet,m.get(j));
 else             baseSet=MathOperations.incCrossProduct(baseSet,mA.get(domain).get(j));
          }
          for (          OWLClassExpression concept : baseSet) {
            ConceptTransformation.transformToOrderedForm(concept);
          }
          if (applyExistsFilter) {
            Iterator<OWLObjectUnionOf> it=baseSet.iterator();
            while (it.hasNext()) {
              if (MathOperations.containsDoubleObjectSomeRestriction(it.next()))               it.remove();
            }
          }
          if (domain == null)           topRefinements.get(i).addAll(baseSet);
 else           topARefinements.get(domain).get(i).addAll(baseSet);
        }
      }
    }
    TreeSet<OWLClassExpression> cumulativeRefinements=new TreeSet<OWLClassExpression>();
    for (int j=1; j <= i; j++) {
      if (domain == null) {
        cumulativeRefinements.addAll(topRefinements.get(j));
      }
 else {
        cumulativeRefinements.addAll(topARefinements.get(domain).get(j));
      }
    }
    if (domain == null) {
      topRefinementsCumulative.put(i,cumulativeRefinements);
    }
 else {
      if (!topARefinementsCumulative.containsKey(domain))       topARefinementsCumulative.put(domain,new TreeMap<Integer,TreeSet<OWLClassExpression>>());
      topARefinementsCumulative.get(domain).put(i,cumulativeRefinements);
    }
  }
  if (domain == null)   topRefinementsLength=maxLength;
 else   topARefinementsLength.put(domain,maxLength);
  topComputationTimeNs+=System.nanoTime() - topComputationTimeStartNs;
}","private void computeTopRefinements(int maxLength,OWLClassExpression domain){
  long topComputationTimeStartNs=System.nanoTime();
  if (domain == null && m.size() == 0)   computeM();
  if (domain != null && !mA.containsKey(domain))   computeM(domain);
  int refinementsLength;
  if (domain == null) {
    refinementsLength=topRefinementsLength;
  }
 else {
    if (!topARefinementsLength.containsKey(domain))     topARefinementsLength.put(domain,0);
    refinementsLength=topARefinementsLength.get(domain);
  }
  for (int i=refinementsLength + 1; i <= maxLength; i++) {
    combos.put(i,MathOperations.getCombos(i,mMaxLength));
    if (domain == null) {
      topRefinements.put(i,new TreeSet<OWLClassExpression>());
    }
 else {
      if (!topARefinements.containsKey(domain))       topARefinements.put(domain,new TreeMap<Integer,SortedSet<OWLClassExpression>>());
      topARefinements.get(domain).put(i,new TreeSet<OWLClassExpression>());
    }
    for (    List<Integer> combo : combos.get(i)) {
      if (combo.size() == 1) {
        if (domain == null)         topRefinements.get(i).addAll(m.get(i));
 else         topARefinements.get(domain).get(i).addAll(mA.get(domain).get(i));
      }
 else {
        boolean validCombo=true;
        for (        Integer j : combo) {
          if ((domain == null && m.get(j).size() == 0) || (domain != null && mA.get(domain).get(j).size() == 0))           validCombo=false;
        }
        if (validCombo) {
          SortedSet<OWLObjectUnionOf> baseSet=new TreeSet<OWLObjectUnionOf>();
          for (          Integer j : combo) {
            if (domain == null)             baseSet=MathOperations.incCrossProduct(baseSet,m.get(j));
 else             baseSet=MathOperations.incCrossProduct(baseSet,mA.get(domain).get(j));
          }
          for (          OWLClassExpression concept : baseSet) {
            ConceptTransformation.transformToOrderedForm(concept);
          }
          if (applyExistsFilter) {
            Iterator<OWLObjectUnionOf> it=baseSet.iterator();
            while (it.hasNext()) {
              if (MathOperations.containsDoubleObjectSomeRestriction(it.next()))               it.remove();
            }
          }
          if (domain == null)           topRefinements.get(i).addAll(baseSet);
 else           topARefinements.get(domain).get(i).addAll(baseSet);
        }
      }
    }
    TreeSet<OWLClassExpression> cumulativeRefinements=new TreeSet<OWLClassExpression>();
    for (int j=1; j <= i; j++) {
      if (domain == null) {
        cumulativeRefinements.addAll(topRefinements.get(j));
      }
 else {
        cumulativeRefinements.addAll(topARefinements.get(domain).get(j));
      }
    }
    if (domain == null) {
      topRefinementsCumulative.put(i,cumulativeRefinements);
    }
 else {
      if (!topARefinementsCumulative.containsKey(domain))       topARefinementsCumulative.put(domain,new TreeMap<Integer,TreeSet<OWLClassExpression>>());
      topARefinementsCumulative.get(domain).put(i,cumulativeRefinements);
    }
  }
  if (domain == null)   topRefinementsLength=maxLength;
 else   topARefinementsLength.put(domain,maxLength);
  topComputationTimeNs+=System.nanoTime() - topComputationTimeStartNs;
}"
9433,"public SortedSet<OWLClassExpression> getClassCandidates(OWLClass index){
  return getClassCandidatesRecursive(index,df.getOWLThing());
}","public SortedSet<OWLClassExpression> getClassCandidates(OWLClassExpression index){
  return getClassCandidatesRecursive(index,df.getOWLThing());
}"
9434,"@SuppressWarnings({""String_Node_Str""}) public Set<OWLClassExpression> refine(OWLClassExpression description,int maxLength,List<OWLClassExpression> knownRefinements,OWLClassExpression currDomain){
  if (!currDomain.isOWLThing() && !topARefinementsLength.containsKey(currDomain)) {
    topARefinementsLength.put((OWLClass)currDomain,0);
  }
  Set<OWLClassExpression> refinements=new TreeSet<OWLClassExpression>();
  Set<OWLClassExpression> tmp=new HashSet<OWLClassExpression>();
  if (description.isOWLThing()) {
    if (currDomain.isOWLThing()) {
      if (maxLength > topRefinementsLength)       computeTopRefinements(maxLength);
      refinements=(TreeSet<OWLClassExpression>)topRefinementsCumulative.get(maxLength).clone();
    }
 else {
      if (maxLength > topARefinementsLength.get(currDomain)) {
        computeTopRefinements(maxLength,(OWLClass)currDomain);
      }
      refinements=(TreeSet<OWLClassExpression>)topARefinementsCumulative.get(currDomain).get(maxLength).clone();
    }
  }
 else   if (description.isOWLNothing()) {
  }
 else   if (!description.isAnonymous()) {
    refinements.addAll(subHierarchy.getSubClasses(description));
    refinements.remove(df.getOWLNothing());
  }
 else   if (description instanceof OWLObjectComplementOf) {
    OWLClassExpression operand=((OWLObjectComplementOf)description).getOperand();
    if (!operand.isAnonymous()) {
      tmp=subHierarchy.getSuperClasses(operand);
      for (      OWLClassExpression c : tmp) {
        if (!c.isOWLThing()) {
          refinements.add(df.getOWLObjectComplementOf(c));
        }
      }
    }
  }
 else   if (description instanceof OWLObjectIntersectionOf) {
    List<OWLClassExpression> operands=((OWLObjectIntersectionOf)description).getOperandsAsList();
    for (    OWLClassExpression child : operands) {
      tmp=refine(child,maxLength - OWLClassExpressionUtils.getLength(description) + OWLClassExpressionUtils.getLength(child),null,currDomain);
      for (      OWLClassExpression c : tmp) {
        List<OWLClassExpression> newChildren=new ArrayList<OWLClassExpression>(((OWLObjectIntersectionOf)description).getOperands());
        newChildren.add(c);
        newChildren.remove(child);
        Collections.sort(newChildren);
        OWLClassExpression mc=df.getOWLObjectIntersectionOf(newChildren);
        mc=ConceptTransformation.cleanConceptNonRecursive(mc);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc);
        if (checkIntersection((OWLObjectIntersectionOf)mc))         refinements.add(mc);
      }
    }
  }
 else   if (description instanceof OWLObjectUnionOf) {
    List<OWLClassExpression> operands=((OWLObjectUnionOf)description).getOperandsAsList();
    for (    OWLClassExpression child : operands) {
      tmp=refine(child,maxLength - OWLClassExpressionUtils.getLength(description) + OWLClassExpressionUtils.getLength(child),null,currDomain);
      for (      OWLClassExpression c : tmp) {
        List<OWLClassExpression> newChildren=new ArrayList<OWLClassExpression>(operands);
        newChildren.remove(child);
        newChildren.add(c);
        Collections.sort(newChildren);
        OWLObjectUnionOf md=df.getOWLObjectUnionOf(newChildren);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(md);
        refinements.add(md);
      }
    }
    if (dropDisjuncts) {
      if (operands.size() == 2) {
        refinements.add(operands.get(0));
        refinements.add(operands.get(1));
      }
 else {
        for (int i=0; i < operands.size(); i++) {
          List<OWLClassExpression> newChildren=new LinkedList<OWLClassExpression>(operands);
          newChildren.remove(i);
          OWLObjectUnionOf md=df.getOWLObjectUnionOf(newChildren);
          refinements.add(md);
        }
      }
    }
  }
 else   if (description instanceof OWLObjectSomeValuesFrom) {
    OWLObjectPropertyExpression role=((OWLObjectSomeValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectSomeValuesFrom)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    tmp=refine(filler,maxLength - 2,null,range);
    for (    OWLClassExpression c : tmp) {
      refinements.add(df.getOWLObjectSomeValuesFrom(role,c));
    }
    if (!role.isAnonymous()) {
      Set<OWLObjectProperty> moreSpecialRoles=reasoner.getSubProperties(role.asOWLObjectProperty());
      for (      OWLObjectProperty moreSpecialRole : moreSpecialRoles) {
        refinements.add(df.getOWLObjectSomeValuesFrom(moreSpecialRole,filler));
      }
    }
    if (useCardinalityRestrictions) {
      if (maxLength > OWLClassExpressionUtils.getLength(description) && maxNrOfFillers.get(role) > 1) {
        OWLObjectMinCardinality min=df.getOWLObjectMinCardinality(2,role,filler);
        refinements.add(min);
      }
    }
    if (useHasValueConstructor && filler.isOWLThing()) {
      Set<OWLIndividual> frequentInds=frequentValues.get(role);
      if (frequentInds != null) {
        for (        OWLIndividual ind : frequentInds) {
          OWLObjectHasValue ovr=df.getOWLObjectHasValue(role,ind);
          refinements.add(ovr);
          if (useObjectValueNegation) {
            refinements.add(df.getOWLObjectComplementOf(ovr));
          }
        }
      }
    }
  }
 else   if (description instanceof OWLObjectAllValuesFrom) {
    OWLObjectPropertyExpression role=((OWLObjectAllValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectAllValuesFrom)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    tmp=refine(filler,maxLength - 2,null,range);
    for (    OWLClassExpression c : tmp) {
      refinements.add(df.getOWLObjectAllValuesFrom(role,c));
    }
    if (!filler.isAnonymous() && tmp.size() == 0) {
      refinements.add(df.getOWLObjectAllValuesFrom(role,df.getOWLNothing()));
    }
    if (!role.isAnonymous()) {
      Set<OWLObjectProperty> subProperties=reasoner.getSubProperties(role.asOWLObjectProperty());
      for (      OWLObjectProperty subProperty : subProperties) {
        refinements.add(df.getOWLObjectAllValuesFrom(subProperty,filler));
      }
    }
  }
 else   if (description instanceof OWLObjectCardinalityRestriction) {
    OWLObjectPropertyExpression role=((OWLObjectCardinalityRestriction)description).getProperty();
    OWLClassExpression filler=((OWLObjectCardinalityRestriction)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    int cardinality=((OWLObjectCardinalityRestriction)description).getCardinality();
    if (description instanceof OWLObjectMaxCardinality) {
      if (useNegation || cardinality > 0) {
        tmp=refine(filler,maxLength - 3,null,range);
        for (        OWLClassExpression d : tmp) {
          refinements.add(df.getOWLObjectMaxCardinality(cardinality,role,d));
        }
      }
      if ((useNegation && cardinality > 1) || (!useNegation && cardinality > 2)) {
        refinements.add(df.getOWLObjectMaxCardinality(cardinality - 1,role,filler));
      }
    }
 else     if (description instanceof OWLObjectMinCardinality) {
      tmp=refine(filler,maxLength - 3,null,range);
      for (      OWLClassExpression d : tmp) {
        refinements.add(df.getOWLObjectMinCardinality(cardinality,role,d));
      }
      if (cardinality < maxNrOfFillers.get(role)) {
        refinements.add(df.getOWLObjectMinCardinality(cardinality + 1,role,filler));
      }
    }
  }
 else   if (description instanceof OWLDataSomeValuesFrom) {
    OWLDataPropertyExpression dp=((OWLDataSomeValuesFrom)description).getProperty();
    OWLDataRange dr=((OWLDataSomeValuesFrom)description).getFiller();
    if (dr instanceof OWLDatatypeRestriction) {
      OWLDatatype datatype=((OWLDatatypeRestriction)dr).getDatatype();
      Set<OWLFacetRestriction> facetRestrictions=((OWLDatatypeRestriction)dr).getFacetRestrictions();
      OWLDatatypeRestriction newDatatypeRestriction=null;
      if (datatype.isDouble()) {
        for (        OWLFacetRestriction facetRestriction : facetRestrictions) {
          OWLFacet facet=facetRestriction.getFacet();
          double value=facetRestriction.getFacetValue().parseDouble();
          if (facet == OWLFacet.MAX_INCLUSIVE) {
            int splitIndex=splits.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex - 1;
            if (newSplitIndex >= 0) {
              double newValue=splits.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMaxInclusiveRestriction(newValue);
            }
          }
 else           if (facet == OWLFacet.MIN_INCLUSIVE) {
            int splitIndex=splits.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex + 1;
            if (newSplitIndex < splits.get(dp).size()) {
              double newValue=splits.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMinInclusiveRestriction(newValue);
            }
          }
        }
      }
 else       if (datatype.isInteger()) {
        for (        OWLFacetRestriction facetRestriction : facetRestrictions) {
          OWLFacet facet=facetRestriction.getFacet();
          int value=facetRestriction.getFacetValue().parseInteger();
          if (facet == OWLFacet.MAX_INCLUSIVE) {
            int splitIndex=splitsInt.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex - 1;
            if (newSplitIndex >= 0) {
              int newValue=splitsInt.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMaxInclusiveRestriction(newValue);
            }
          }
 else           if (facet == OWLFacet.MIN_INCLUSIVE) {
            int splitIndex=splitsInt.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex + 1;
            if (newSplitIndex < splitsInt.get(dp).size()) {
              int newValue=splitsInt.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMinInclusiveRestriction(newValue);
            }
          }
        }
      }
      if (newDatatypeRestriction != null) {
        refinements.add(df.getOWLDataSomeValuesFrom(dp,newDatatypeRestriction));
      }
    }
  }
 else   if (description instanceof OWLDataHasValue) {
    OWLDataPropertyExpression dp=((OWLDataHasValue)description).getProperty();
    OWLLiteral value=((OWLDataHasValue)description).getValue();
    if (!dp.isAnonymous()) {
      Set<OWLDataProperty> subDPs=reasoner.getSubProperties(dp.asOWLDataProperty());
      for (      OWLDataProperty subDP : subDPs) {
        refinements.add(df.getOWLDataHasValue(subDP,value));
      }
    }
  }
  if (!description.isOWLThing() && !description.isOWLNothing() && !(description instanceof OWLObjectAllValuesFrom && ((OWLObjectAllValuesFrom)description).getFiller().isOWLNothing())) {
    int topRefLength=maxLength - OWLClassExpressionUtils.getLength(description) - 1;
    if (currDomain.isOWLThing()) {
      if (topRefLength > topRefinementsLength)       computeTopRefinements(topRefLength);
    }
 else     if (topRefLength > topARefinementsLength.get(currDomain))     computeTopRefinements(topRefLength,(OWLClass)currDomain);
    if (topRefLength > 0) {
      Set<OWLClassExpression> topRefs;
      if (currDomain.isOWLThing())       topRefs=topRefinementsCumulative.get(topRefLength);
 else       topRefs=topARefinementsCumulative.get(currDomain).get(topRefLength);
      for (      OWLClassExpression c : topRefs) {
        boolean skip=false;
        if (applyAllFilter) {
          if (c instanceof OWLObjectAllValuesFrom) {
            if (description instanceof OWLNaryBooleanClassExpression) {
              for (              OWLClassExpression child : ((OWLNaryBooleanClassExpression)description).getOperands()) {
                if (child instanceof OWLObjectAllValuesFrom) {
                  OWLObjectPropertyExpression r1=((OWLObjectAllValuesFrom)c).getProperty();
                  OWLObjectPropertyExpression r2=((OWLObjectAllValuesFrom)child).getProperty();
                  if (r1.equals(r2)) {
                    skip=true;
                    break;
                  }
                }
              }
            }
          }
        }
        if (disjointChecks && !c.isAnonymous() && !description.isAnonymous()&& isDisjoint(description,c)) {
          skip=true;
        }
        if (!skip) {
          List<OWLClassExpression> operands=Lists.newArrayList(description,c);
          Collections.sort(operands);
          OWLObjectIntersectionOf mc=df.getOWLObjectIntersectionOf(operands);
          mc=(OWLObjectIntersectionOf)ConceptTransformation.cleanConceptNonRecursive(mc);
          ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc);
          if (checkIntersection(mc))           refinements.add(mc);
        }
      }
    }
  }
  return refinements;
}","@SuppressWarnings({""String_Node_Str""}) public Set<OWLClassExpression> refine(OWLClassExpression description,int maxLength,List<OWLClassExpression> knownRefinements,OWLClassExpression currDomain){
  if (!currDomain.isOWLThing() && !topARefinementsLength.containsKey(currDomain)) {
    topARefinementsLength.put(currDomain,0);
  }
  Set<OWLClassExpression> refinements=new TreeSet<OWLClassExpression>();
  Set<OWLClassExpression> tmp=new HashSet<OWLClassExpression>();
  if (description.isOWLThing()) {
    if (currDomain.isOWLThing()) {
      if (maxLength > topRefinementsLength)       computeTopRefinements(maxLength);
      refinements=(TreeSet<OWLClassExpression>)topRefinementsCumulative.get(maxLength).clone();
    }
 else {
      if (maxLength > topARefinementsLength.get(currDomain)) {
        computeTopRefinements(maxLength,currDomain);
      }
      refinements=(TreeSet<OWLClassExpression>)topARefinementsCumulative.get(currDomain).get(maxLength).clone();
    }
  }
 else   if (description.isOWLNothing()) {
  }
 else   if (!description.isAnonymous()) {
    refinements.addAll(subHierarchy.getSubClasses(description));
    refinements.remove(df.getOWLNothing());
  }
 else   if (description instanceof OWLObjectComplementOf) {
    OWLClassExpression operand=((OWLObjectComplementOf)description).getOperand();
    if (!operand.isAnonymous()) {
      tmp=subHierarchy.getSuperClasses(operand);
      for (      OWLClassExpression c : tmp) {
        if (!c.isOWLThing()) {
          refinements.add(df.getOWLObjectComplementOf(c));
        }
      }
    }
  }
 else   if (description instanceof OWLObjectIntersectionOf) {
    List<OWLClassExpression> operands=((OWLObjectIntersectionOf)description).getOperandsAsList();
    for (    OWLClassExpression child : operands) {
      tmp=refine(child,maxLength - OWLClassExpressionUtils.getLength(description) + OWLClassExpressionUtils.getLength(child),null,currDomain);
      for (      OWLClassExpression c : tmp) {
        List<OWLClassExpression> newChildren=new ArrayList<OWLClassExpression>(((OWLObjectIntersectionOf)description).getOperands());
        newChildren.add(c);
        newChildren.remove(child);
        Collections.sort(newChildren);
        OWLClassExpression mc=df.getOWLObjectIntersectionOf(newChildren);
        mc=ConceptTransformation.cleanConceptNonRecursive(mc);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc);
        if (checkIntersection((OWLObjectIntersectionOf)mc))         refinements.add(mc);
      }
    }
  }
 else   if (description instanceof OWLObjectUnionOf) {
    List<OWLClassExpression> operands=((OWLObjectUnionOf)description).getOperandsAsList();
    for (    OWLClassExpression child : operands) {
      tmp=refine(child,maxLength - OWLClassExpressionUtils.getLength(description) + OWLClassExpressionUtils.getLength(child),null,currDomain);
      for (      OWLClassExpression c : tmp) {
        List<OWLClassExpression> newChildren=new ArrayList<OWLClassExpression>(operands);
        newChildren.remove(child);
        newChildren.add(c);
        Collections.sort(newChildren);
        OWLObjectUnionOf md=df.getOWLObjectUnionOf(newChildren);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(md);
        refinements.add(md);
      }
    }
    if (dropDisjuncts) {
      if (operands.size() == 2) {
        refinements.add(operands.get(0));
        refinements.add(operands.get(1));
      }
 else {
        for (int i=0; i < operands.size(); i++) {
          List<OWLClassExpression> newChildren=new LinkedList<OWLClassExpression>(operands);
          newChildren.remove(i);
          OWLObjectUnionOf md=df.getOWLObjectUnionOf(newChildren);
          refinements.add(md);
        }
      }
    }
  }
 else   if (description instanceof OWLObjectSomeValuesFrom) {
    OWLObjectPropertyExpression role=((OWLObjectSomeValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectSomeValuesFrom)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    tmp=refine(filler,maxLength - 2,null,range);
    for (    OWLClassExpression c : tmp) {
      refinements.add(df.getOWLObjectSomeValuesFrom(role,c));
    }
    if (!role.isAnonymous()) {
      Set<OWLObjectProperty> moreSpecialRoles=reasoner.getSubProperties(role.asOWLObjectProperty());
      for (      OWLObjectProperty moreSpecialRole : moreSpecialRoles) {
        refinements.add(df.getOWLObjectSomeValuesFrom(moreSpecialRole,filler));
      }
    }
    if (useCardinalityRestrictions) {
      if (maxLength > OWLClassExpressionUtils.getLength(description) && maxNrOfFillers.get(role) > 1) {
        OWLObjectMinCardinality min=df.getOWLObjectMinCardinality(2,role,filler);
        refinements.add(min);
      }
    }
    if (useHasValueConstructor && filler.isOWLThing()) {
      Set<OWLIndividual> frequentInds=frequentValues.get(role);
      if (frequentInds != null) {
        for (        OWLIndividual ind : frequentInds) {
          OWLObjectHasValue ovr=df.getOWLObjectHasValue(role,ind);
          refinements.add(ovr);
          if (useObjectValueNegation) {
            refinements.add(df.getOWLObjectComplementOf(ovr));
          }
        }
      }
    }
  }
 else   if (description instanceof OWLObjectAllValuesFrom) {
    OWLObjectPropertyExpression role=((OWLObjectAllValuesFrom)description).getProperty();
    OWLClassExpression filler=((OWLObjectAllValuesFrom)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    tmp=refine(filler,maxLength - 2,null,range);
    for (    OWLClassExpression c : tmp) {
      refinements.add(df.getOWLObjectAllValuesFrom(role,c));
    }
    if (!filler.isAnonymous() && tmp.size() == 0) {
      refinements.add(df.getOWLObjectAllValuesFrom(role,df.getOWLNothing()));
    }
    if (!role.isAnonymous()) {
      Set<OWLObjectProperty> subProperties=reasoner.getSubProperties(role.asOWLObjectProperty());
      for (      OWLObjectProperty subProperty : subProperties) {
        refinements.add(df.getOWLObjectAllValuesFrom(subProperty,filler));
      }
    }
  }
 else   if (description instanceof OWLObjectCardinalityRestriction) {
    OWLObjectPropertyExpression role=((OWLObjectCardinalityRestriction)description).getProperty();
    OWLClassExpression filler=((OWLObjectCardinalityRestriction)description).getFiller();
    OWLClassExpression range=opRanges.get(role);
    int cardinality=((OWLObjectCardinalityRestriction)description).getCardinality();
    if (description instanceof OWLObjectMaxCardinality) {
      if (useNegation || cardinality > 0) {
        tmp=refine(filler,maxLength - 3,null,range);
        for (        OWLClassExpression d : tmp) {
          refinements.add(df.getOWLObjectMaxCardinality(cardinality,role,d));
        }
      }
      if ((useNegation && cardinality > 1) || (!useNegation && cardinality > 2)) {
        refinements.add(df.getOWLObjectMaxCardinality(cardinality - 1,role,filler));
      }
    }
 else     if (description instanceof OWLObjectMinCardinality) {
      tmp=refine(filler,maxLength - 3,null,range);
      for (      OWLClassExpression d : tmp) {
        refinements.add(df.getOWLObjectMinCardinality(cardinality,role,d));
      }
      if (cardinality < maxNrOfFillers.get(role)) {
        refinements.add(df.getOWLObjectMinCardinality(cardinality + 1,role,filler));
      }
    }
  }
 else   if (description instanceof OWLDataSomeValuesFrom) {
    OWLDataPropertyExpression dp=((OWLDataSomeValuesFrom)description).getProperty();
    OWLDataRange dr=((OWLDataSomeValuesFrom)description).getFiller();
    if (dr instanceof OWLDatatypeRestriction) {
      OWLDatatype datatype=((OWLDatatypeRestriction)dr).getDatatype();
      Set<OWLFacetRestriction> facetRestrictions=((OWLDatatypeRestriction)dr).getFacetRestrictions();
      OWLDatatypeRestriction newDatatypeRestriction=null;
      if (datatype.isDouble()) {
        for (        OWLFacetRestriction facetRestriction : facetRestrictions) {
          OWLFacet facet=facetRestriction.getFacet();
          double value=facetRestriction.getFacetValue().parseDouble();
          if (facet == OWLFacet.MAX_INCLUSIVE) {
            int splitIndex=splits.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex - 1;
            if (newSplitIndex >= 0) {
              double newValue=splits.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMaxInclusiveRestriction(newValue);
            }
          }
 else           if (facet == OWLFacet.MIN_INCLUSIVE) {
            int splitIndex=splits.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex + 1;
            if (newSplitIndex < splits.get(dp).size()) {
              double newValue=splits.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMinInclusiveRestriction(newValue);
            }
          }
        }
      }
 else       if (datatype.isInteger()) {
        for (        OWLFacetRestriction facetRestriction : facetRestrictions) {
          OWLFacet facet=facetRestriction.getFacet();
          int value=facetRestriction.getFacetValue().parseInteger();
          if (facet == OWLFacet.MAX_INCLUSIVE) {
            int splitIndex=splitsInt.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex - 1;
            if (newSplitIndex >= 0) {
              int newValue=splitsInt.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMaxInclusiveRestriction(newValue);
            }
          }
 else           if (facet == OWLFacet.MIN_INCLUSIVE) {
            int splitIndex=splitsInt.get(dp).lastIndexOf(value);
            if (splitIndex == -1)             throw new Error(""String_Node_Str"");
            int newSplitIndex=splitIndex + 1;
            if (newSplitIndex < splitsInt.get(dp).size()) {
              int newValue=splitsInt.get(dp).get(newSplitIndex);
              newDatatypeRestriction=df.getOWLDatatypeMinInclusiveRestriction(newValue);
            }
          }
        }
      }
      if (newDatatypeRestriction != null) {
        refinements.add(df.getOWLDataSomeValuesFrom(dp,newDatatypeRestriction));
      }
    }
  }
 else   if (description instanceof OWLDataHasValue) {
    OWLDataPropertyExpression dp=((OWLDataHasValue)description).getProperty();
    OWLLiteral value=((OWLDataHasValue)description).getValue();
    if (!dp.isAnonymous()) {
      Set<OWLDataProperty> subDPs=reasoner.getSubProperties(dp.asOWLDataProperty());
      for (      OWLDataProperty subDP : subDPs) {
        refinements.add(df.getOWLDataHasValue(subDP,value));
      }
    }
  }
  if (!description.isOWLThing() && !description.isOWLNothing() && !(description instanceof OWLObjectAllValuesFrom && ((OWLObjectAllValuesFrom)description).getFiller().isOWLNothing())) {
    int topRefLength=maxLength - OWLClassExpressionUtils.getLength(description) - 1;
    if (currDomain.isOWLThing()) {
      if (topRefLength > topRefinementsLength)       computeTopRefinements(topRefLength);
    }
 else     if (topRefLength > topARefinementsLength.get(currDomain))     computeTopRefinements(topRefLength,(OWLClass)currDomain);
    if (topRefLength > 0) {
      Set<OWLClassExpression> topRefs;
      if (currDomain.isOWLThing())       topRefs=topRefinementsCumulative.get(topRefLength);
 else       topRefs=topARefinementsCumulative.get(currDomain).get(topRefLength);
      for (      OWLClassExpression c : topRefs) {
        boolean skip=false;
        if (applyAllFilter) {
          if (c instanceof OWLObjectAllValuesFrom) {
            if (description instanceof OWLNaryBooleanClassExpression) {
              for (              OWLClassExpression child : ((OWLNaryBooleanClassExpression)description).getOperands()) {
                if (child instanceof OWLObjectAllValuesFrom) {
                  OWLObjectPropertyExpression r1=((OWLObjectAllValuesFrom)c).getProperty();
                  OWLObjectPropertyExpression r2=((OWLObjectAllValuesFrom)child).getProperty();
                  if (r1.equals(r2)) {
                    skip=true;
                    break;
                  }
                }
              }
            }
          }
        }
        if (disjointChecks && !c.isAnonymous() && !description.isAnonymous()&& isDisjoint(description,c)) {
          skip=true;
        }
        if (!skip) {
          List<OWLClassExpression> operands=Lists.newArrayList(description,c);
          Collections.sort(operands);
          OWLObjectIntersectionOf mc=df.getOWLObjectIntersectionOf(operands);
          mc=(OWLObjectIntersectionOf)ConceptTransformation.cleanConceptNonRecursive(mc);
          ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc);
          if (checkIntersection(mc))           refinements.add(mc);
        }
      }
    }
  }
  return refinements;
}"
9435,"private void computeMostGeneralNumericDPRecursive(OWLClass domain,Set<OWLDataProperty> currProperties,Set<OWLDataProperty> mgddTmp){
  for (  OWLDataProperty prop : currProperties) {
    if (appNumeric.get(domain).contains(prop))     mgddTmp.add(prop);
 else     computeMostGeneralNumericDPRecursive(domain,reasoner.getSubProperties(prop),mgddTmp);
  }
}","private void computeMostGeneralNumericDPRecursive(OWLClassExpression domain,Set<OWLDataProperty> currProperties,Set<OWLDataProperty> mgddTmp){
  for (  OWLDataProperty prop : currProperties) {
    if (appNumeric.get(domain).contains(prop))     mgddTmp.add(prop);
 else     computeMostGeneralNumericDPRecursive(domain,reasoner.getSubProperties(prop),mgddTmp);
  }
}"
9436,"private void computeMgbdRecursive(OWLClass domain,Set<OWLDataProperty> currProperties,Set<OWLDataProperty> mgbdTmp){
  for (  OWLDataProperty prop : currProperties) {
    if (appBD.get(domain).contains(prop))     mgbdTmp.add(prop);
 else     computeMgbdRecursive(domain,reasoner.getSubProperties(prop),mgbdTmp);
  }
}","private void computeMgbdRecursive(OWLClassExpression domain,Set<OWLDataProperty> currProperties,Set<OWLDataProperty> mgbdTmp){
  for (  OWLDataProperty prop : currProperties) {
    if (appBD.get(domain).contains(prop))     mgbdTmp.add(prop);
 else     computeMgbdRecursive(domain,reasoner.getSubProperties(prop),mgbdTmp);
  }
}"
9437,"private void computeMostGeneralStringDPRecursive(OWLClass domain,Set<OWLDataProperty> currProperties,Set<OWLDataProperty> mgddTmp){
  for (  OWLDataProperty prop : currProperties) {
    if (appSD.get(domain).contains(prop))     mgddTmp.add(prop);
 else     computeMostGeneralStringDPRecursive(domain,reasoner.getSubProperties(prop),mgddTmp);
  }
}","private void computeMostGeneralStringDPRecursive(OWLClassExpression domain,Set<OWLDataProperty> currProperties,Set<OWLDataProperty> mgddTmp){
  for (  OWLDataProperty prop : currProperties) {
    if (appSD.get(domain).contains(prop))     mgddTmp.add(prop);
 else     computeMostGeneralStringDPRecursive(domain,reasoner.getSubProperties(prop),mgddTmp);
  }
}"
9438,"private void computeM(OWLClass nc){
  long mComputationTimeStartNs=System.nanoTime();
  mA.put(nc,new TreeMap<Integer,SortedSet<OWLClassExpression>>());
  for (int i=1; i <= mMaxLength; i++) {
    mA.get(nc).put(i,new TreeSet<OWLClassExpression>());
  }
  SortedSet<OWLClassExpression> m1=getClassCandidates(nc);
  mA.get(nc).put(1,m1);
  SortedSet<OWLClassExpression> m2=new TreeSet<OWLClassExpression>();
  if (useNegation) {
    m2=getNegClassCandidates(nc);
    mA.get(nc).put(2,m2);
  }
  computeMg(nc);
  if (useBooleanDatatypes) {
    Set<OWLDataProperty> booleanDPs=mgbd.get(nc);
    for (    OWLDataProperty dp : booleanDPs) {
      m2.add(df.getOWLDataHasValue(dp,df.getOWLLiteral(true)));
      m2.add(df.getOWLDataHasValue(dp,df.getOWLLiteral(false)));
    }
  }
  mA.get(nc).put(2,m2);
  SortedSet<OWLClassExpression> m3=new TreeSet<OWLClassExpression>();
  if (useExistsConstructor) {
    for (    OWLObjectProperty r : mgr.get(nc)) {
      m3.add(df.getOWLObjectSomeValuesFrom(r,df.getOWLThing()));
    }
  }
  if (useAllConstructor) {
    for (    OWLObjectProperty r : mgr.get(nc)) {
      m3.add(df.getOWLObjectAllValuesFrom(r,df.getOWLThing()));
    }
  }
  if (useNumericDatatypes) {
    Set<OWLDataProperty> numericDPs=mgNumeric.get(nc);
    for (    OWLDataProperty dp : numericDPs) {
      if (splits.get(dp).size() > 0) {
        double min=splits.get(dp).get(0);
        double max=splits.get(dp).get(splits.get(dp).size() - 1);
        m3.add(df.getOWLDataSomeValuesFrom(dp,df.getOWLDatatypeMinInclusiveRestriction(min)));
        m3.add(df.getOWLDataSomeValuesFrom(dp,df.getOWLDatatypeMaxInclusiveRestriction(max)));
      }
    }
  }
  if (useDataHasValueConstructor) {
    Set<OWLDataProperty> stringDPs=mgsd.get(nc);
    for (    OWLDataProperty dp : stringDPs) {
      Set<OWLLiteral> freqValues=frequentDataValues.get(dp);
      for (      OWLLiteral lit : freqValues) {
        m3.add(df.getOWLDataHasValue(dp,lit));
      }
    }
  }
  mA.get(nc).put(3,m3);
  SortedSet<OWLClassExpression> m4=new TreeSet<OWLClassExpression>();
  if (useCardinalityRestrictions) {
    for (    OWLObjectProperty r : mgr.get(nc)) {
      int maxFillers=maxNrOfFillers.get(r);
      if ((useNegation && maxFillers > 0) || (!useNegation && maxFillers > 1))       m4.add(df.getOWLObjectMaxCardinality(maxFillers - 1,r,df.getOWLThing()));
    }
  }
  mA.get(nc).put(4,m4);
  mComputationTimeNs+=System.nanoTime() - mComputationTimeStartNs;
}","private void computeM(OWLClassExpression nc){
  long mComputationTimeStartNs=System.nanoTime();
  mA.put(nc,new TreeMap<Integer,SortedSet<OWLClassExpression>>());
  for (int i=1; i <= mMaxLength; i++) {
    mA.get(nc).put(i,new TreeSet<OWLClassExpression>());
  }
  SortedSet<OWLClassExpression> m1=getClassCandidates(nc);
  mA.get(nc).put(1,m1);
  SortedSet<OWLClassExpression> m2=new TreeSet<OWLClassExpression>();
  if (useNegation) {
    m2=getNegClassCandidates(nc);
    mA.get(nc).put(2,m2);
  }
  computeMg(nc);
  if (useBooleanDatatypes) {
    Set<OWLDataProperty> booleanDPs=mgbd.get(nc);
    for (    OWLDataProperty dp : booleanDPs) {
      m2.add(df.getOWLDataHasValue(dp,df.getOWLLiteral(true)));
      m2.add(df.getOWLDataHasValue(dp,df.getOWLLiteral(false)));
    }
  }
  mA.get(nc).put(2,m2);
  SortedSet<OWLClassExpression> m3=new TreeSet<OWLClassExpression>();
  if (useExistsConstructor) {
    for (    OWLObjectProperty r : mgr.get(nc)) {
      m3.add(df.getOWLObjectSomeValuesFrom(r,df.getOWLThing()));
    }
  }
  if (useAllConstructor) {
    for (    OWLObjectProperty r : mgr.get(nc)) {
      m3.add(df.getOWLObjectAllValuesFrom(r,df.getOWLThing()));
    }
  }
  if (useNumericDatatypes) {
    Set<OWLDataProperty> numericDPs=mgNumeric.get(nc);
    for (    OWLDataProperty dp : numericDPs) {
      if (splits.get(dp).size() > 0) {
        double min=splits.get(dp).get(0);
        double max=splits.get(dp).get(splits.get(dp).size() - 1);
        m3.add(df.getOWLDataSomeValuesFrom(dp,df.getOWLDatatypeMinInclusiveRestriction(min)));
        m3.add(df.getOWLDataSomeValuesFrom(dp,df.getOWLDatatypeMaxInclusiveRestriction(max)));
      }
    }
  }
  if (useDataHasValueConstructor) {
    Set<OWLDataProperty> stringDPs=mgsd.get(nc);
    for (    OWLDataProperty dp : stringDPs) {
      Set<OWLLiteral> freqValues=frequentDataValues.get(dp);
      for (      OWLLiteral lit : freqValues) {
        m3.add(df.getOWLDataHasValue(dp,lit));
      }
    }
  }
  mA.get(nc).put(3,m3);
  SortedSet<OWLClassExpression> m4=new TreeSet<OWLClassExpression>();
  if (useCardinalityRestrictions) {
    for (    OWLObjectProperty r : mgr.get(nc)) {
      int maxFillers=maxNrOfFillers.get(r);
      if ((useNegation && maxFillers > 0) || (!useNegation && maxFillers > 1))       m4.add(df.getOWLObjectMaxCardinality(maxFillers - 1,r,df.getOWLThing()));
    }
  }
  mA.get(nc).put(4,m4);
  mComputationTimeNs+=System.nanoTime() - mComputationTimeStartNs;
}"
9439,"private void computeMg(OWLClass domain){
  if (appOP.get(domain) == null)   computeApp(domain);
  mgr.put(domain,new TreeSet<OWLObjectProperty>());
  mgbd.put(domain,new TreeSet<OWLDataProperty>());
  mgNumeric.put(domain,new TreeSet<OWLDataProperty>());
  mgsd.put(domain,new TreeSet<OWLDataProperty>());
  SortedSet<OWLObjectProperty> mostGeneral=reasoner.getMostGeneralProperties();
  computeMgrRecursive(domain,mostGeneral,mgr.get(domain));
  SortedSet<OWLDataProperty> mostGeneralDP=reasoner.getMostGeneralDatatypeProperties();
  Set<OWLDataProperty> mostGeneralBDP=Helper.intersection(mostGeneralDP,reasoner.getBooleanDatatypeProperties());
  Set<OWLDataProperty> mostGeneralNumericDPs=Helper.intersection(mostGeneralDP,reasoner.getNumericDataProperties());
  Set<OWLDataProperty> mostGeneralStringDPs=Helper.intersection(mostGeneralDP,reasoner.getStringDatatypeProperties());
  computeMgbdRecursive(domain,mostGeneralBDP,mgbd.get(domain));
  computeMostGeneralNumericDPRecursive(domain,mostGeneralNumericDPs,mgNumeric.get(domain));
  computeMostGeneralStringDPRecursive(domain,mostGeneralStringDPs,mgsd.get(domain));
}","private void computeMg(OWLClassExpression domain){
  if (appOP.get(domain) == null)   computeApp(domain);
  mgr.put(domain,new TreeSet<OWLObjectProperty>());
  mgbd.put(domain,new TreeSet<OWLDataProperty>());
  mgNumeric.put(domain,new TreeSet<OWLDataProperty>());
  mgsd.put(domain,new TreeSet<OWLDataProperty>());
  SortedSet<OWLObjectProperty> mostGeneral=reasoner.getMostGeneralProperties();
  computeMgrRecursive(domain,mostGeneral,mgr.get(domain));
  SortedSet<OWLDataProperty> mostGeneralDP=reasoner.getMostGeneralDatatypeProperties();
  Set<OWLDataProperty> mostGeneralBDP=Helper.intersection(mostGeneralDP,reasoner.getBooleanDatatypeProperties());
  Set<OWLDataProperty> mostGeneralNumericDPs=Helper.intersection(mostGeneralDP,reasoner.getNumericDataProperties());
  Set<OWLDataProperty> mostGeneralStringDPs=Helper.intersection(mostGeneralDP,reasoner.getStringDatatypeProperties());
  computeMgbdRecursive(domain,mostGeneralBDP,mgbd.get(domain));
  computeMostGeneralNumericDPRecursive(domain,mostGeneralNumericDPs,mgNumeric.get(domain));
  computeMostGeneralStringDPRecursive(domain,mostGeneralStringDPs,mgsd.get(domain));
}"
9440,"private int getLength(EvaluatedDescription ed){
  int length=0;
  OWLClassExpression d=ed.getDescription();
  if (d instanceof OWLNaryBooleanClassExpression) {
    for (    OWLClassExpression child : ((OWLNaryBooleanClassExpression)d).getOperands()) {
      if (child instanceof OWLObjectSomeValuesFrom && ((OWLObjectSomeValuesFrom)child).getProperty().asOWLObjectProperty() == OWLPunningDetector.punningProperty) {
        length+=OWLClassExpressionUtils.getLength(((OWLObjectSomeValuesFrom)child).getFiller());
      }
 else {
        length+=OWLClassExpressionUtils.getLength(child);
      }
    }
  }
  return length;
}","private int getLength(EvaluatedDescription ed){
  int length=0;
  OWLClassExpression ce=ed.getDescription();
  if (ce instanceof OWLNaryBooleanClassExpression) {
    Set<OWLClassExpression> operands=((OWLNaryBooleanClassExpression)ce).getOperands();
    for (    OWLClassExpression child : operands) {
      if (child instanceof OWLObjectSomeValuesFrom && ((OWLObjectSomeValuesFrom)child).getProperty().asOWLObjectProperty() == OWLPunningDetector.punningProperty) {
        length+=OWLClassExpressionUtils.getLength(((OWLObjectSomeValuesFrom)child).getFiller());
      }
 else {
        length+=OWLClassExpressionUtils.getLength(child);
      }
    }
    length+=operands.size() - 1;
  }
 else {
    length=OWLClassExpressionUtils.getLength(ce);
  }
  return length;
}"
9441,"public void setHeuristic(HeuristicType heuristic){
  this.heuristic=heuristic;
}","public void setHeuristic(HeuristicType heuristic){
  this.heuristic=heuristic;
  if (heuristic == HeuristicType.AMEASURE) {
    accuracyMethod=""String_Node_Str"";
  }
 else   if (heuristic == HeuristicType.FMEASURE) {
    accuracyMethod=""String_Node_Str"";
  }
 else   if (heuristic == HeuristicType.GEN_FMEASURE) {
    accuracyMethod=""String_Node_Str"";
  }
 else   if (heuristic == HeuristicType.JACCARD) {
    accuracyMethod=""String_Node_Str"";
  }
 else   if (heuristic == HeuristicType.PRED_ACC) {
    accuracyMethod=""String_Node_Str"";
  }
}"
9442,"public double getPredAccuracyOrTooWeakExact(Description description,double noise){
  int maxNotCovered=(int)Math.ceil(noise * positiveExamples.size());
  int notCoveredPos=0;
  int notCoveredNeg=0;
  for (  Individual example : positiveExamples) {
    if (!getReasoner().hasType(description,example)) {
      notCoveredPos++;
      if (notCoveredPos >= maxNotCovered) {
        System.out.println(description + ""String_Node_Str"" + notCoveredPos+ ""String_Node_Str""+ (negativeExamples.size() - notCoveredNeg));
        return -1;
      }
    }
  }
  for (  Individual example : negativeExamples) {
    if (!getReasoner().hasType(description,example)) {
      notCoveredNeg++;
    }
  }
  System.out.println(description + ""String_Node_Str"" + notCoveredPos+ ""String_Node_Str""+ (negativeExamples.size() - notCoveredNeg));
  return (positiveExamples.size() - notCoveredPos + notCoveredNeg) / (double)allExamples.size();
}","public double getPredAccuracyOrTooWeakExact(Description description,double noise){
  int maxNotCovered=(int)Math.ceil(noise * positiveExamples.size());
  int notCoveredPos=0;
  int notCoveredNeg=0;
  for (  Individual example : positiveExamples) {
    if (!getReasoner().hasType(description,example)) {
      notCoveredPos++;
      if (notCoveredPos >= maxNotCovered) {
        return -1;
      }
    }
  }
  for (  Individual example : negativeExamples) {
    if (!getReasoner().hasType(description,example)) {
      notCoveredNeg++;
    }
  }
  return (positiveExamples.size() - notCoveredPos + notCoveredNeg) / (double)allExamples.size();
}"
9443,"private void dematerialize(){
  long dematStartTime=System.currentTimeMillis();
  logger.debug(""String_Node_Str"");
  Set<NamedClass> classes=rc.getNamedClasses();
  int i=1;
  for (  NamedClass atomicConcept : classes) {
    SortedSet<Individual> pos=rc.getIndividuals(atomicConcept);
    classInstancesPos.put(atomicConcept,(TreeSet<Individual>)pos);
    if (isDefaultNegation()) {
      classInstancesNeg.put(atomicConcept,(TreeSet<Individual>)Helper.difference(individuals,pos));
    }
 else {
      Negation negatedAtomicConcept=new Negation(atomicConcept);
      classInstancesNeg.put(atomicConcept,(TreeSet<Individual>)rc.getIndividuals(negatedAtomicConcept));
    }
  }
  logger.debug(""String_Node_Str"");
  for (  ObjectProperty atomicRole : atomicRoles) {
    opPos.put(atomicRole,rc.getPropertyMembers(atomicRole));
  }
  logger.debug(""String_Node_Str"");
  for (  DatatypeProperty atomicRole : datatypeProperties) {
    dpPos.put(atomicRole,rc.getDatatypeMembers(atomicRole));
  }
  for (  DatatypeProperty dp : booleanDatatypeProperties) {
    bdPos.put(dp,(TreeSet<Individual>)rc.getTrueDatatypeMembers(dp));
    bdNeg.put(dp,(TreeSet<Individual>)rc.getFalseDatatypeMembers(dp));
  }
  for (  DatatypeProperty dp : intDatatypeProperties) {
    id.put(dp,rc.getIntDatatypeMembers(dp));
  }
  for (  DatatypeProperty dp : doubleDatatypeProperties) {
    dd.put(dp,rc.getDoubleDatatypeMembers(dp));
  }
  for (  DatatypeProperty dp : stringDatatypeProperties) {
    sd.put(dp,rc.getStringDatatypeMembers(dp));
  }
  List<OWLOntology> ontologies=rc.getOWLAPIOntologies();
  for (  OWLOntology ontology : ontologies) {
    Set<OWLClassAssertionAxiom> axioms=ontology.getAxioms(AxiomType.CLASS_ASSERTION);
    for (    OWLClassAssertionAxiom axiom : axioms) {
      OWLIndividual ind=axiom.getIndividual();
      OWLClassExpression ce=axiom.getClassExpression();
      if (ce instanceof OWLObjectSomeValuesFrom) {
        System.out.println(axiom);
        OWLObjectPropertyExpression propertyExpression=((OWLObjectSomeValuesFrom)ce).getProperty();
        OWLClassExpression filler=((OWLObjectSomeValuesFrom)ce).getFiller();
        if (!propertyExpression.isAnonymous()) {
          ObjectProperty prop=new ObjectProperty(propertyExpression.asOWLObjectProperty().toStringID());
          Map<Individual,SortedSet<Individual>> map=opPos.get(prop);
          if (map == null) {
            map=new HashMap<Individual,SortedSet<Individual>>();
            opPos.put(prop,map);
          }
          Individual individual=new Individual(ind.toStringID());
          SortedSet<Individual> values=map.get(individual);
          if (values == null) {
            values=new TreeSet<Individual>();
            map.put(individual,values);
          }
          if (values.isEmpty()) {
            Individual newIndividual=individualGenerator.newIndividual();
            values.add(newIndividual);
            if (!filler.isOWLThing()) {
              if (!filler.isAnonymous()) {
                NamedClass cls=new NamedClass(filler.asOWLClass().toStringID());
                System.out.println(cls);
                classInstancesPos.get(cls).add(newIndividual);
                Set<OWLClass> superClasses=rc.getReasoner().getSuperClasses(ce,false).getFlattened();
                System.out.println(superClasses);
                superClasses.remove(ontology.getOWLOntologyManager().getOWLDataFactory().getOWLThing());
                for (                OWLClass sup : superClasses) {
                  classInstancesPos.get(OWLAPIConverter.convertClass(sup)).add(newIndividual);
                }
              }
            }
          }
        }
 else {
        }
      }
    }
  }
  if (materializeExistentialRestrictions) {
    logger.debug(""String_Node_Str"");
    ExistentialRestrictionMaterialization materialization=new ExistentialRestrictionMaterialization(rc.getReasoner().getRootOntology());
    int cnt=1;
    for (    NamedClass cls : atomicConcepts) {
      System.out.println(cnt++ + ""String_Node_Str"" + atomicConcepts.size());
      TreeSet<Individual> individuals=classInstancesPos.get(cls);
      Set<OWLClassExpression> superClass=materialization.materialize(cls.getName());
      for (      OWLClassExpression sup : superClass) {
        fill(individuals,DLLearnerDescriptionConvertVisitor.getDLLearnerDescription(sup));
      }
    }
    logger.debug(""String_Node_Str"");
  }
  if (handlePunning) {
    OWLOntology ontology=rc.getReasoner().getRootOntology();
    Individual genericIndividual=new Individual(""String_Node_Str"");
    Map<Individual,SortedSet<Individual>> map=new HashMap<Individual,SortedSet<Individual>>();
    for (    Individual individual : individuals) {
      SortedSet<Individual> objects=new TreeSet<Individual>();
      objects.add(genericIndividual);
      map.put(individual,objects);
    }
    for (    NamedClass cls : atomicConcepts) {
      classInstancesNeg.get(cls).add(genericIndividual);
      if (OWLPunningDetector.hasPunning(ontology,cls)) {
        Individual clsAsInd=new Individual(cls.getName());
        SortedSet<Individual> individuals=classInstancesPos.get(cls);
        for (        Individual individual : individuals) {
          SortedSet<Individual> objects=map.get(individual);
          if (objects == null) {
            objects=new TreeSet<Individual>();
            map.put(individual,objects);
          }
          objects.add(clsAsInd);
        }
      }
    }
    opPos.put(OWLPunningDetector.punningProperty,map);
    atomicRoles=new TreeSet<ObjectProperty>(atomicRoles);
    atomicRoles.add(OWLPunningDetector.punningProperty);
    atomicRoles=Collections.unmodifiableSet(atomicRoles);
  }
  long dematDuration=System.currentTimeMillis() - dematStartTime;
  logger.debug(""String_Node_Str"" + dematDuration + ""String_Node_Str"");
}","private void dematerialize(){
  long dematStartTime=System.currentTimeMillis();
  logger.debug(""String_Node_Str"");
  Set<NamedClass> classes=rc.getNamedClasses();
  int i=1;
  for (  NamedClass atomicConcept : classes) {
    SortedSet<Individual> pos=rc.getIndividuals(atomicConcept);
    classInstancesPos.put(atomicConcept,(TreeSet<Individual>)pos);
    if (isDefaultNegation()) {
      classInstancesNeg.put(atomicConcept,(TreeSet<Individual>)Helper.difference(individuals,pos));
    }
 else {
      Negation negatedAtomicConcept=new Negation(atomicConcept);
      classInstancesNeg.put(atomicConcept,(TreeSet<Individual>)rc.getIndividuals(negatedAtomicConcept));
    }
  }
  logger.debug(""String_Node_Str"");
  for (  ObjectProperty atomicRole : atomicRoles) {
    opPos.put(atomicRole,rc.getPropertyMembers(atomicRole));
  }
  logger.debug(""String_Node_Str"");
  for (  DatatypeProperty atomicRole : datatypeProperties) {
    dpPos.put(atomicRole,rc.getDatatypeMembers(atomicRole));
  }
  for (  DatatypeProperty dp : booleanDatatypeProperties) {
    bdPos.put(dp,(TreeSet<Individual>)rc.getTrueDatatypeMembers(dp));
    bdNeg.put(dp,(TreeSet<Individual>)rc.getFalseDatatypeMembers(dp));
  }
  for (  DatatypeProperty dp : intDatatypeProperties) {
    id.put(dp,rc.getIntDatatypeMembers(dp));
  }
  for (  DatatypeProperty dp : doubleDatatypeProperties) {
    dd.put(dp,rc.getDoubleDatatypeMembers(dp));
  }
  for (  DatatypeProperty dp : stringDatatypeProperties) {
    sd.put(dp,rc.getStringDatatypeMembers(dp));
  }
  List<OWLOntology> ontologies=rc.getOWLAPIOntologies();
  for (  OWLOntology ontology : ontologies) {
    Set<OWLClassAssertionAxiom> axioms=ontology.getAxioms(AxiomType.CLASS_ASSERTION);
    for (    OWLClassAssertionAxiom axiom : axioms) {
      OWLIndividual ind=axiom.getIndividual();
      OWLClassExpression ce=axiom.getClassExpression();
      if (ce instanceof OWLObjectSomeValuesFrom) {
        OWLObjectPropertyExpression propertyExpression=((OWLObjectSomeValuesFrom)ce).getProperty();
        OWLClassExpression filler=((OWLObjectSomeValuesFrom)ce).getFiller();
        if (!propertyExpression.isAnonymous()) {
          ObjectProperty prop=new ObjectProperty(propertyExpression.asOWLObjectProperty().toStringID());
          Map<Individual,SortedSet<Individual>> map=opPos.get(prop);
          if (map == null) {
            map=new HashMap<Individual,SortedSet<Individual>>();
            opPos.put(prop,map);
          }
          Individual individual=new Individual(ind.toStringID());
          SortedSet<Individual> values=map.get(individual);
          if (values == null) {
            values=new TreeSet<Individual>();
            map.put(individual,values);
          }
          if (values.isEmpty()) {
            Individual newIndividual=individualGenerator.newIndividual();
            values.add(newIndividual);
            if (!filler.isOWLThing()) {
              if (!filler.isAnonymous()) {
                NamedClass cls=new NamedClass(filler.asOWLClass().toStringID());
                classInstancesPos.get(cls).add(newIndividual);
                Set<OWLClass> superClasses=rc.getReasoner().getSuperClasses(filler,false).getFlattened();
                superClasses.remove(ontology.getOWLOntologyManager().getOWLDataFactory().getOWLThing());
                for (                OWLClass sup : superClasses) {
                  classInstancesPos.get(OWLAPIConverter.convertClass(sup)).add(newIndividual);
                }
              }
            }
          }
        }
 else {
        }
      }
    }
  }
  if (materializeExistentialRestrictions) {
    logger.debug(""String_Node_Str"");
    ExistentialRestrictionMaterialization materialization=new ExistentialRestrictionMaterialization(rc.getReasoner().getRootOntology());
    int cnt=1;
    for (    NamedClass cls : atomicConcepts) {
      System.out.println(cnt++ + ""String_Node_Str"" + atomicConcepts.size());
      TreeSet<Individual> individuals=classInstancesPos.get(cls);
      Set<OWLClassExpression> superClass=materialization.materialize(cls.getName());
      for (      OWLClassExpression sup : superClass) {
        fill(individuals,DLLearnerDescriptionConvertVisitor.getDLLearnerDescription(sup));
      }
    }
    logger.debug(""String_Node_Str"");
  }
  if (handlePunning) {
    OWLOntology ontology=rc.getReasoner().getRootOntology();
    Individual genericIndividual=new Individual(""String_Node_Str"");
    Map<Individual,SortedSet<Individual>> map=new HashMap<Individual,SortedSet<Individual>>();
    for (    Individual individual : individuals) {
      SortedSet<Individual> objects=new TreeSet<Individual>();
      objects.add(genericIndividual);
      map.put(individual,objects);
    }
    for (    NamedClass cls : atomicConcepts) {
      classInstancesNeg.get(cls).add(genericIndividual);
      if (OWLPunningDetector.hasPunning(ontology,cls)) {
        Individual clsAsInd=new Individual(cls.getName());
        SortedSet<Individual> individuals=classInstancesPos.get(cls);
        for (        Individual individual : individuals) {
          SortedSet<Individual> objects=map.get(individual);
          if (objects == null) {
            objects=new TreeSet<Individual>();
            map.put(individual,objects);
          }
          objects.add(clsAsInd);
        }
      }
    }
    opPos.put(OWLPunningDetector.punningProperty,map);
    atomicRoles=new TreeSet<ObjectProperty>(atomicRoles);
    atomicRoles.add(OWLPunningDetector.punningProperty);
    atomicRoles=Collections.unmodifiableSet(atomicRoles);
  }
  long dematDuration=System.currentTimeMillis() - dematStartTime;
  logger.debug(""String_Node_Str"" + dematDuration + ""String_Node_Str"");
}"
9444,"private static void run() throws OWLOntologyCreationException, ComponentInitException {
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  Set<Individual> posExamples=makeIndividuals(posExampleUris);
  Set<Individual> negExamples=makeIndividuals(negExampleUris);
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLOntology ontology=man.loadOntologyFromOntologyDocument(new File(kbPathStr));
  logger.debug(""String_Node_Str"" + ontology.getAxiomCount() + ""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  KnowledgeSource ks=new OWLAPIOntology(ontology);
  ks.init();
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  OWLAPIReasoner baseReasoner=new OWLAPIReasoner(ks);
  baseReasoner.setReasonerTypeString(""String_Node_Str"");
  baseReasoner.setUseFallbackReasoner(true);
  baseReasoner.init();
  Logger.getLogger(ElkReasoner.class).setLevel(Level.OFF);
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  MaterializableFastInstanceChecker cwReasoner=new MaterializableFastInstanceChecker(ks);
  cwReasoner.setReasonerComponent(baseReasoner);
  cwReasoner.setHandlePunning(false);
  cwReasoner.setUseMaterializationCaching(false);
  cwReasoner.setMaterializeExistentialRestrictions(true);
  cwReasoner.init();
  logger.debug(""String_Node_Str"");
  AbstractReasonerComponent rc=cwReasoner;
  logger.debug(""String_Node_Str"");
  PosNegLPStandard lp=new PosNegLPStandard(rc);
  lp.setPositiveExamples(posExamples);
  lp.setNegativeExamples(negExamples);
  lp.init();
  logger.debug(""String_Node_Str"");
  Description d=new ObjectSomeRestriction(new ObjectProperty(""String_Node_Str""),Thing.instance);
  System.out.println(d + ""String_Node_Str"" + lp.getAccuracyOrTooWeak(d,1.0));
  logger.debug(""String_Node_Str"");
  AbstractCELA la;
  OEHeuristicRuntime heuristic=new OEHeuristicRuntime();
  heuristic.setExpansionPenaltyFactor(0.01);
  CELOE celoe=new CELOE(lp,rc);
  celoe.setHeuristic(heuristic);
  celoe.setMaxExecutionTimeInSeconds(300);
  celoe.setNoisePercentage(50);
  celoe.setMaxNrOfResults(10);
  celoe.setWriteSearchTree(true);
  celoe.setReplaceSearchTree(true);
  la=celoe;
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  RhoDRDown op=new RhoDRDown();
  op.setUseHasValueConstructor(true);
  op.setInstanceBasedDisjoints(true);
  op.setUseNegation(false);
  op.setUseHasValueConstructor(false);
  op.setReasoner(rc);
  op.setSubHierarchy(rc.getClassHierarchy());
  op.setObjectPropertyHierarchy(rc.getObjectPropertyHierarchy());
  op.setDataPropertyHierarchy(rc.getDatatypePropertyHierarchy());
  op.init();
  logger.debug(""String_Node_Str"");
  if (la instanceof CELOE)   ((CELOE)la).setOperator(op);
  la.init();
  la.start();
  logger.debug(""String_Node_Str"");
}","private static void run() throws OWLOntologyCreationException, ComponentInitException {
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  Set<Individual> posExamples=makeIndividuals(posExampleUris);
  Set<Individual> negExamples=makeIndividuals(negExampleUris);
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLOntology ontology=man.loadOntologyFromOntologyDocument(new File(kbPathStr));
  logger.debug(""String_Node_Str"" + ontology.getAxiomCount() + ""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  KnowledgeSource ks=new OWLAPIOntology(ontology);
  ks.init();
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  OWLAPIReasoner baseReasoner=new OWLAPIReasoner(ks);
  baseReasoner.setReasonerTypeString(""String_Node_Str"");
  baseReasoner.setUseFallbackReasoner(true);
  baseReasoner.init();
  Logger.getLogger(ElkReasoner.class).setLevel(Level.OFF);
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  MaterializableFastInstanceChecker cwReasoner=new MaterializableFastInstanceChecker(ks);
  cwReasoner.setReasonerComponent(baseReasoner);
  cwReasoner.setHandlePunning(false);
  cwReasoner.setUseMaterializationCaching(false);
  cwReasoner.setMaterializeExistentialRestrictions(true);
  cwReasoner.init();
  logger.debug(""String_Node_Str"");
  AbstractReasonerComponent rc=cwReasoner;
  logger.debug(""String_Node_Str"");
  PosNegLPStandard lp=new PosNegLPStandard(rc);
  lp.setPositiveExamples(posExamples);
  lp.setNegativeExamples(negExamples);
  lp.init();
  logger.debug(""String_Node_Str"");
  Description d=new Intersection(new NamedClass(""String_Node_Str""),new ObjectSomeRestriction(new ObjectProperty(""String_Node_Str""),Thing.instance));
  System.out.println(d + ""String_Node_Str"" + lp.getAccuracyOrTooWeak(d,1.0));
  logger.debug(""String_Node_Str"");
  AbstractCELA la;
  OEHeuristicRuntime heuristic=new OEHeuristicRuntime();
  heuristic.setExpansionPenaltyFactor(0.1);
  CELOE celoe=new CELOE(lp,rc);
  celoe.setHeuristic(heuristic);
  celoe.setMaxExecutionTimeInSeconds(600);
  celoe.setNoisePercentage(50);
  celoe.setMaxNrOfResults(100);
  celoe.setWriteSearchTree(true);
  celoe.setReplaceSearchTree(true);
  la=celoe;
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  RhoDRDown op=new RhoDRDown();
  op.setUseHasValueConstructor(true);
  op.setInstanceBasedDisjoints(true);
  op.setUseNegation(false);
  op.setUseHasValueConstructor(false);
  op.setReasoner(rc);
  op.setSubHierarchy(rc.getClassHierarchy());
  op.setObjectPropertyHierarchy(rc.getObjectPropertyHierarchy());
  op.setDataPropertyHierarchy(rc.getDatatypePropertyHierarchy());
  op.init();
  Set<Description> refinements=op.refine(d,6);
  for (  Description ref : refinements) {
    System.out.println(ref + ""String_Node_Str"" + lp.getAccuracyOrTooWeak(ref,1.0));
  }
  logger.debug(""String_Node_Str"");
  if (la instanceof CELOE)   ((CELOE)la).setOperator(op);
  la.init();
  la.start();
  logger.debug(""String_Node_Str"");
}"
9445,"private static void run() throws OWLOntologyCreationException, ComponentInitException {
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  Set<Individual> posExamples=makeIndividuals(posExampleUris);
  Set<Individual> negExamples=makeIndividuals(negExampleUris);
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLOntology ontology=man.loadOntologyFromOntologyDocument(new File(kbPathStr));
  logger.debug(""String_Node_Str"" + ontology.getAxiomCount() + ""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  KnowledgeSource ks=new OWLAPIOntology(ontology);
  ks.init();
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  OWLAPIReasoner baseReasoner=new OWLAPIReasoner(ks);
  baseReasoner.setReasonerTypeString(""String_Node_Str"");
  baseReasoner.setUseFallbackReasoner(true);
  baseReasoner.init();
  Logger.getLogger(ElkReasoner.class).setLevel(Level.OFF);
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  MaterializableFastInstanceChecker cwReasoner=new MaterializableFastInstanceChecker(ks);
  cwReasoner.setReasonerComponent(baseReasoner);
  cwReasoner.setHandlePunning(false);
  cwReasoner.setUseMaterializationCaching(false);
  cwReasoner.setMaterializeExistentialRestrictions(true);
  cwReasoner.init();
  logger.debug(""String_Node_Str"");
  AbstractReasonerComponent rc=cwReasoner;
  logger.debug(""String_Node_Str"");
  PosNegLPStandard lp=new PosNegLPStandard(baseReasoner);
  lp.setPositiveExamples(posExamples);
  lp.setNegativeExamples(negExamples);
  lp.init();
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  AbstractCELA la;
  OEHeuristicRuntime heuristic=new OEHeuristicRuntime();
  heuristic.setExpansionPenaltyFactor(0.1);
  CELOE celoe=new CELOE(lp,rc);
  celoe.setHeuristic(heuristic);
  celoe.setMaxExecutionTimeInSeconds(300);
  celoe.setNoisePercentage(50);
  celoe.setMaxNrOfResults(10);
  celoe.setWriteSearchTree(true);
  celoe.setReplaceSearchTree(true);
  la=celoe;
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  RhoDRDown op=new RhoDRDown();
  op.setUseHasValueConstructor(true);
  op.setInstanceBasedDisjoints(true);
  op.setUseNegation(false);
  op.setUseHasValueConstructor(false);
  op.setReasoner(rc);
  op.setSubHierarchy(rc.getClassHierarchy());
  op.setObjectPropertyHierarchy(rc.getObjectPropertyHierarchy());
  op.setDataPropertyHierarchy(rc.getDatatypePropertyHierarchy());
  op.init();
  logger.debug(""String_Node_Str"");
  if (la instanceof CELOE)   ((CELOE)la).setOperator(op);
  la.init();
  la.start();
  logger.debug(""String_Node_Str"");
}","private static void run() throws OWLOntologyCreationException, ComponentInitException {
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  Set<Individual> posExamples=makeIndividuals(posExampleUris);
  Set<Individual> negExamples=makeIndividuals(negExampleUris);
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLOntology ontology=man.loadOntologyFromOntologyDocument(new File(kbPathStr));
  logger.debug(""String_Node_Str"" + ontology.getAxiomCount() + ""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  KnowledgeSource ks=new OWLAPIOntology(ontology);
  ks.init();
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  OWLAPIReasoner baseReasoner=new OWLAPIReasoner(ks);
  baseReasoner.setReasonerTypeString(""String_Node_Str"");
  baseReasoner.setUseFallbackReasoner(true);
  baseReasoner.init();
  Logger.getLogger(ElkReasoner.class).setLevel(Level.OFF);
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  MaterializableFastInstanceChecker cwReasoner=new MaterializableFastInstanceChecker(ks);
  cwReasoner.setReasonerComponent(baseReasoner);
  cwReasoner.setHandlePunning(false);
  cwReasoner.setUseMaterializationCaching(false);
  cwReasoner.setMaterializeExistentialRestrictions(true);
  cwReasoner.init();
  logger.debug(""String_Node_Str"");
  AbstractReasonerComponent rc=cwReasoner;
  logger.debug(""String_Node_Str"");
  PosNegLPStandard lp=new PosNegLPStandard(rc);
  lp.setPositiveExamples(posExamples);
  lp.setNegativeExamples(negExamples);
  lp.init();
  logger.debug(""String_Node_Str"");
  Description d=new ObjectSomeRestriction(new ObjectProperty(""String_Node_Str""),Thing.instance);
  System.out.println(d + ""String_Node_Str"" + lp.getAccuracyOrTooWeak(d,1.0));
  logger.debug(""String_Node_Str"");
  AbstractCELA la;
  OEHeuristicRuntime heuristic=new OEHeuristicRuntime();
  heuristic.setExpansionPenaltyFactor(0.01);
  CELOE celoe=new CELOE(lp,rc);
  celoe.setHeuristic(heuristic);
  celoe.setMaxExecutionTimeInSeconds(300);
  celoe.setNoisePercentage(50);
  celoe.setMaxNrOfResults(10);
  celoe.setWriteSearchTree(true);
  celoe.setReplaceSearchTree(true);
  la=celoe;
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  RhoDRDown op=new RhoDRDown();
  op.setUseHasValueConstructor(true);
  op.setInstanceBasedDisjoints(true);
  op.setUseNegation(false);
  op.setUseHasValueConstructor(false);
  op.setReasoner(rc);
  op.setSubHierarchy(rc.getClassHierarchy());
  op.setObjectPropertyHierarchy(rc.getObjectPropertyHierarchy());
  op.setDataPropertyHierarchy(rc.getDatatypePropertyHierarchy());
  op.init();
  logger.debug(""String_Node_Str"");
  if (la instanceof CELOE)   ((CELOE)la).setOperator(op);
  la.init();
  la.start();
  logger.debug(""String_Node_Str"");
}"
9446,"public static void main(String[] args) throws Exception {
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLDataFactory factory=man.getOWLDataFactory();
  logger.info(""String_Node_Str"");
  OWLOntology ontology=man.loadOntologyFromOntologyDocument(new File(dumpFilePath));
  logger.info(""String_Node_Str"");
  OWLAxiomCBDGenerator cbdGenartor=new OWLAxiomCBDGenerator(ontology);
  OWLOntology cbdOnt=man.createOntology();
  for (  String uri : exampleUris) {
    logger.info(""String_Node_Str"" + uri + ""String_Node_Str"");
    Set<OWLAxiom> cbdAxioms=cbdGenartor.getCBD(factory.getOWLNamedIndividual(IRI.create(uri)),cbdDepth);
    logger.info(""String_Node_Str"");
    man.addAxioms(cbdOnt,cbdAxioms);
    logger.info(""String_Node_Str"");
  }
  man.saveOntology(cbdOnt,new RDFXMLOntologyFormat(),new FileOutputStream(new File(cbdFilePath)));
}","public static void main(String[] args) throws Exception {
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLDataFactory factory=man.getOWLDataFactory();
  logger.info(""String_Node_Str"");
  OWLOntology ontology=man.loadOntologyFromOntologyDocument(new File(dumpFilePath));
  logger.info(""String_Node_Str"");
  OWLAxiomCBDGenerator cbdGenartor=new OWLAxiomCBDGenerator(ontology);
  cbdGenartor.setFetchCompleteRelatedTBox(true);
  OWLOntology cbdOnt=man.createOntology();
  for (  String uri : exampleUris) {
    logger.info(""String_Node_Str"" + uri + ""String_Node_Str"");
    Set<OWLAxiom> cbdAxioms=cbdGenartor.getCBD(factory.getOWLNamedIndividual(IRI.create(uri)),cbdDepth);
    logger.info(""String_Node_Str"",cbdAxioms.size());
    man.addAxioms(cbdOnt,cbdAxioms);
    logger.info(""String_Node_Str"");
  }
  man.saveOntology(cbdOnt,new RDFXMLOntologyFormat(),new FileOutputStream(new File(cbdFilePath)));
}"
9447,"private void computeSuperClasses(OWLClass cls){
  String s=""String_Node_Str"";
  for (int i=0; i < indent; i++) {
    s+=""String_Node_Str"";
  }
  indent++;
  Set<OWLClassExpression> superClasses=new HashSet<OWLClassExpression>();
  superClasses.add(cls);
  Set<OWLClassExpression> superClassExpressions=cls.getSuperClasses(ontology);
  superClassExpressions.remove(cls);
  for (  OWLClassExpression sup : superClassExpressions) {
    sup.accept(this);
    superClasses.addAll(stack.pop());
  }
  stack.push(superClasses);
  map.put(cls,superClasses);
}","private void computeSuperClasses(OWLClass cls){
  visited.add(cls);
  String s=""String_Node_Str"";
  for (int i=0; i < indent; i++) {
    s+=""String_Node_Str"";
  }
  indent++;
  Set<OWLClassExpression> superClasses=new HashSet<OWLClassExpression>();
  superClasses.add(cls);
  Set<OWLClassExpression> superClassExpressions=cls.getSuperClasses(ontology);
  superClassExpressions.remove(cls);
  for (  OWLClassExpression sup : superClassExpressions) {
    if (!visited.contains(sup)) {
      sup.accept(this);
      superClasses.addAll(stack.pop());
    }
 else {
      LOGGER.warn(""String_Node_Str"" + sup + ""String_Node_Str""+ visited);
    }
  }
  stack.push(superClasses);
  map.put(cls,superClasses);
}"
9448,"public static void main(String[] args) throws Exception {
  ToStringRenderer.getInstance().setRenderer(new DLSyntaxObjectRenderer());
  String s=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLOntology ontology=man.loadOntologyFromOntologyDocument(new ByteArrayInputStream(s.getBytes()));
  ExistentialRestrictionMaterialization mat=new ExistentialRestrictionMaterialization(ontology);
  Set<OWLClassExpression> superClassExpressions=mat.materialize(""String_Node_Str"");
  for (  OWLClassExpression sup : superClassExpressions) {
    System.out.println(sup);
  }
}","public static void main(String[] args) throws Exception {
  ToStringRenderer.getInstance().setRenderer(new DLSyntaxObjectRenderer());
  String s=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLOntology ontology=man.loadOntologyFromOntologyDocument(new ByteArrayInputStream(s.getBytes()));
  ExistentialRestrictionMaterialization mat=new ExistentialRestrictionMaterialization(ontology);
  Set<OWLClassExpression> superClassExpressions=mat.materialize(""String_Node_Str"");
  for (  OWLClassExpression sup : superClassExpressions) {
    System.out.println(sup);
  }
}"
9449,"private void computeSuperClasses(OWLClass cls){
  visited.add(cls);
  String s=""String_Node_Str"";
  for (int i=0; i < indent; i++) {
    s+=""String_Node_Str"";
  }
  indent++;
  Set<OWLClassExpression> superClasses=new HashSet<OWLClassExpression>();
  superClasses.add(cls);
  Set<OWLClassExpression> superClassExpressions=cls.getSuperClasses(ontology);
  superClassExpressions.remove(cls);
  for (  OWLClassExpression sup : superClassExpressions) {
    if (!visited.contains(sup)) {
      sup.accept(this);
      superClasses.addAll(stack.pop());
    }
 else {
      LOGGER.warn(""String_Node_Str"" + sup + ""String_Node_Str""+ visited);
    }
  }
  stack.push(superClasses);
  map.put(cls,superClasses);
}","private void computeSuperClasses(OWLClass cls){
  visitedClassExpressions.add(cls);
  String s=""String_Node_Str"";
  for (int i=0; i < indent; i++) {
    s+=""String_Node_Str"";
  }
  indent++;
  Set<OWLClassExpression> superClasses=new HashSet<OWLClassExpression>();
  superClasses.add(cls);
  Set<OWLClassExpression> superClassExpressions=cls.getSuperClasses(ontology);
  superClassExpressions.remove(cls);
  for (  OWLClassExpression sup : superClassExpressions) {
    if (!visitedClassExpressions.contains(sup)) {
      visitedClassExpressions.add(sup);
      sup.accept(this);
      superClasses.addAll(stack.pop());
    }
 else {
    }
  }
  stack.push(superClasses);
  map.put(cls,superClasses);
}"
9450,"public Set<OWLClassExpression> getSuperClasses(OWLClass cls){
  map.clear();
  computeSuperClasses(cls);
  Set<OWLClassExpression> superClasses=map.get(cls);
  superClasses.remove(cls);
  if (onlyIfExistentialOnPath) {
    for (Iterator<OWLClassExpression> iterator=superClasses.iterator(); iterator.hasNext(); ) {
      OWLClassExpression sup=iterator.next();
      if (!(sup instanceof OWLObjectSomeValuesFrom || sup instanceof OWLDataAllValuesFrom)) {
        iterator.remove();
      }
    }
  }
  return superClasses;
}","public Set<OWLClassExpression> getSuperClasses(OWLClass cls){
  visitedClassExpressions=new HashSet<>();
  map.clear();
  computeSuperClasses(cls);
  Set<OWLClassExpression> superClasses=map.get(cls);
  superClasses.remove(cls);
  if (onlyIfExistentialOnPath) {
    for (Iterator<OWLClassExpression> iterator=superClasses.iterator(); iterator.hasNext(); ) {
      OWLClassExpression sup=iterator.next();
      if (!(sup instanceof OWLObjectSomeValuesFrom || sup instanceof OWLDataAllValuesFrom)) {
        iterator.remove();
      }
    }
  }
  return superClasses;
}"
9451,"private void dematerialize(){
  long dematStartTime=System.currentTimeMillis();
  logger.debug(""String_Node_Str"");
  for (  NamedClass atomicConcept : rc.getNamedClasses()) {
    SortedSet<Individual> pos=rc.getIndividuals(atomicConcept);
    classInstancesPos.put(atomicConcept,(TreeSet<Individual>)pos);
    if (isDefaultNegation()) {
      classInstancesNeg.put(atomicConcept,(TreeSet<Individual>)Helper.difference(individuals,pos));
    }
 else {
      Negation negatedAtomicConcept=new Negation(atomicConcept);
      classInstancesNeg.put(atomicConcept,(TreeSet<Individual>)rc.getIndividuals(negatedAtomicConcept));
    }
  }
  logger.debug(""String_Node_Str"");
  for (  ObjectProperty atomicRole : atomicRoles) {
    opPos.put(atomicRole,rc.getPropertyMembers(atomicRole));
  }
  logger.debug(""String_Node_Str"");
  for (  DatatypeProperty atomicRole : datatypeProperties) {
    dpPos.put(atomicRole,rc.getDatatypeMembers(atomicRole));
  }
  for (  DatatypeProperty dp : booleanDatatypeProperties) {
    bdPos.put(dp,(TreeSet<Individual>)rc.getTrueDatatypeMembers(dp));
    bdNeg.put(dp,(TreeSet<Individual>)rc.getFalseDatatypeMembers(dp));
  }
  for (  DatatypeProperty dp : intDatatypeProperties) {
    id.put(dp,rc.getIntDatatypeMembers(dp));
  }
  for (  DatatypeProperty dp : doubleDatatypeProperties) {
    dd.put(dp,rc.getDoubleDatatypeMembers(dp));
  }
  for (  DatatypeProperty dp : stringDatatypeProperties) {
    sd.put(dp,rc.getStringDatatypeMembers(dp));
  }
  if (materializeExistentialRestrictions) {
    ExistentialRestrictionMaterialization materialization=new ExistentialRestrictionMaterialization(rc.getReasoner().getRootOntology());
    for (    NamedClass cls : atomicConcepts) {
      TreeSet<Individual> individuals=classInstancesPos.get(cls);
      Set<OWLClassExpression> superClass=materialization.materialize(cls.getName());
      for (      OWLClassExpression sup : superClass) {
        fill(individuals,DLLearnerDescriptionConvertVisitor.getDLLearnerDescription(sup));
      }
    }
  }
  if (handlePunning) {
    OWLOntology ontology=rc.getReasoner().getRootOntology();
    Individual genericIndividual=new Individual(""String_Node_Str"");
    Map<Individual,SortedSet<Individual>> map=new HashMap<Individual,SortedSet<Individual>>();
    for (    Individual individual : individuals) {
      SortedSet<Individual> objects=new TreeSet<Individual>();
      objects.add(genericIndividual);
      map.put(individual,objects);
    }
    for (    NamedClass cls : atomicConcepts) {
      classInstancesNeg.get(cls).add(genericIndividual);
      if (OWLPunningDetector.hasPunning(ontology,cls)) {
        Individual clsAsInd=new Individual(cls.getName());
        SortedSet<Individual> individuals=classInstancesPos.get(cls);
        for (        Individual individual : individuals) {
          SortedSet<Individual> objects=map.get(individual);
          if (objects == null) {
            objects=new TreeSet<Individual>();
            map.put(individual,objects);
          }
          objects.add(clsAsInd);
        }
      }
    }
    opPos.put(OWLPunningDetector.punningProperty,map);
    atomicRoles=new TreeSet<ObjectProperty>(atomicRoles);
    atomicRoles.add(OWLPunningDetector.punningProperty);
    atomicRoles=Collections.unmodifiableSet(atomicRoles);
  }
  long dematDuration=System.currentTimeMillis() - dematStartTime;
  logger.debug(""String_Node_Str"" + dematDuration + ""String_Node_Str"");
}","private void dematerialize(){
  long dematStartTime=System.currentTimeMillis();
  logger.debug(""String_Node_Str"");
  for (  NamedClass atomicConcept : rc.getNamedClasses()) {
    SortedSet<Individual> pos=rc.getIndividuals(atomicConcept);
    classInstancesPos.put(atomicConcept,(TreeSet<Individual>)pos);
    if (isDefaultNegation()) {
      classInstancesNeg.put(atomicConcept,(TreeSet<Individual>)Helper.difference(individuals,pos));
    }
 else {
      Negation negatedAtomicConcept=new Negation(atomicConcept);
      classInstancesNeg.put(atomicConcept,(TreeSet<Individual>)rc.getIndividuals(negatedAtomicConcept));
    }
  }
  logger.debug(""String_Node_Str"");
  for (  ObjectProperty atomicRole : atomicRoles) {
    opPos.put(atomicRole,rc.getPropertyMembers(atomicRole));
  }
  logger.debug(""String_Node_Str"");
  for (  DatatypeProperty atomicRole : datatypeProperties) {
    dpPos.put(atomicRole,rc.getDatatypeMembers(atomicRole));
  }
  for (  DatatypeProperty dp : booleanDatatypeProperties) {
    bdPos.put(dp,(TreeSet<Individual>)rc.getTrueDatatypeMembers(dp));
    bdNeg.put(dp,(TreeSet<Individual>)rc.getFalseDatatypeMembers(dp));
  }
  for (  DatatypeProperty dp : intDatatypeProperties) {
    id.put(dp,rc.getIntDatatypeMembers(dp));
  }
  for (  DatatypeProperty dp : doubleDatatypeProperties) {
    dd.put(dp,rc.getDoubleDatatypeMembers(dp));
  }
  for (  DatatypeProperty dp : stringDatatypeProperties) {
    sd.put(dp,rc.getStringDatatypeMembers(dp));
  }
  if (materializeExistentialRestrictions) {
    logger.debug(""String_Node_Str"");
    ExistentialRestrictionMaterialization materialization=new ExistentialRestrictionMaterialization(rc.getReasoner().getRootOntology());
    int cnt=0;
    for (    NamedClass cls : atomicConcepts) {
      System.out.println(cnt++ + ""String_Node_Str"" + atomicConcepts.size());
      TreeSet<Individual> individuals=classInstancesPos.get(cls);
      Set<OWLClassExpression> superClass=materialization.materialize(cls.getName());
      for (      OWLClassExpression sup : superClass) {
        fill(individuals,DLLearnerDescriptionConvertVisitor.getDLLearnerDescription(sup));
      }
    }
    logger.debug(""String_Node_Str"");
  }
  if (handlePunning) {
    OWLOntology ontology=rc.getReasoner().getRootOntology();
    Individual genericIndividual=new Individual(""String_Node_Str"");
    Map<Individual,SortedSet<Individual>> map=new HashMap<Individual,SortedSet<Individual>>();
    for (    Individual individual : individuals) {
      SortedSet<Individual> objects=new TreeSet<Individual>();
      objects.add(genericIndividual);
      map.put(individual,objects);
    }
    for (    NamedClass cls : atomicConcepts) {
      classInstancesNeg.get(cls).add(genericIndividual);
      if (OWLPunningDetector.hasPunning(ontology,cls)) {
        Individual clsAsInd=new Individual(cls.getName());
        SortedSet<Individual> individuals=classInstancesPos.get(cls);
        for (        Individual individual : individuals) {
          SortedSet<Individual> objects=map.get(individual);
          if (objects == null) {
            objects=new TreeSet<Individual>();
            map.put(individual,objects);
          }
          objects.add(clsAsInd);
        }
      }
    }
    opPos.put(OWLPunningDetector.punningProperty,map);
    atomicRoles=new TreeSet<ObjectProperty>(atomicRoles);
    atomicRoles.add(OWLPunningDetector.punningProperty);
    atomicRoles=Collections.unmodifiableSet(atomicRoles);
  }
  long dematDuration=System.currentTimeMillis() - dematStartTime;
  logger.debug(""String_Node_Str"" + dematDuration + ""String_Node_Str"");
}"
9452,"@Override public void start(){
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  fetchedRows=0;
  currentlyBestAxioms=new TreeSet<EvaluatedAxiom<T>>();
  if (returnOnlyNewAxioms) {
    getExistingAxioms();
  }
  learnAxioms();
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime));
}","@Override public void start(){
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  fetchedRows=0;
  currentlyBestAxioms=new TreeSet<EvaluatedAxiom<T>>();
  if (returnOnlyNewAxioms) {
    getExistingAxioms();
  }
  learnAxioms();
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime));
  logger.info(""String_Node_Str"" + currentlyBestAxioms.size() + ""String_Node_Str"");
  if (!currentlyBestAxioms.isEmpty()) {
    logger.info(""String_Node_Str"" + currentlyBestAxioms.first());
  }
}"
9453,"public void testEquivalentObjectPropertiesAxiomLearning() throws Exception {
  EquivalentObjectPropertyAxiomLearner l=new EquivalentObjectPropertyAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setPropertyToDescribe(op1);
  l.init();
  l.start();
  EvaluatedAxiom<OWLEquivalentObjectPropertiesAxiom> evAxiom=l.getCurrentlyBestEvaluatedAxiom();
  System.out.println(evAxiom);
  double actualScore=evAxiom.getScore().getAccuracy();
  int cntOp1=130;
  int cntOp2=70;
  int cntOp1_Op2=60;
  double beta=1.0;
  double precision=Heuristics.getConfidenceInterval95WaldAverage(cntOp2,cntOp1_Op2);
  double recall=Heuristics.getConfidenceInterval95WaldAverage(cntOp1,cntOp1_Op2);
  double expectedScore=Heuristics.getFScore(recall,precision,beta);
  assertEquals(""String_Node_Str"",expectedScore,actualScore,0d);
}","public void testEquivalentObjectPropertiesAxiomLearning() throws Exception {
  EquivalentObjectPropertyAxiomLearner l=new EquivalentObjectPropertyAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setEntityToDescribe(op1);
  l.init();
  l.start();
  EvaluatedAxiom<OWLEquivalentObjectPropertiesAxiom> evAxiom=l.getCurrentlyBestEvaluatedAxiom();
  System.out.println(evAxiom);
  double actualScore=evAxiom.getScore().getAccuracy();
  int cntOp1=130;
  int cntOp2=70;
  int cntOp1_Op2=60;
  double beta=1.0;
  double precision=Heuristics.getConfidenceInterval95WaldAverage(cntOp2,cntOp1_Op2);
  double recall=Heuristics.getConfidenceInterval95WaldAverage(cntOp1,cntOp1_Op2);
  double expectedScore=Heuristics.getFScore(recall,precision,beta);
  assertEquals(""String_Node_Str"",expectedScore,actualScore,0d);
}"
9454,"public void testReflexivePropertyAxiomLearning() throws Exception {
  ReflexiveObjectPropertyAxiomLearner l=new ReflexiveObjectPropertyAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setPropertyToDescribe(reflexive);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(nrOfAxioms));
}","public void testReflexivePropertyAxiomLearning() throws Exception {
  ReflexiveObjectPropertyAxiomLearner l=new ReflexiveObjectPropertyAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setEntityToDescribe(reflexive);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(nrOfAxioms));
}"
9455,"public void testPropertyRangeAxiomLearning() throws Exception {
  ObjectPropertyRangeAxiomLearner l=new ObjectPropertyRangeAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setPropertyToDescribe(range);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(nrOfAxioms));
}","public void testPropertyRangeAxiomLearning() throws Exception {
  ObjectPropertyRangeAxiomLearner l=new ObjectPropertyRangeAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setEntityToDescribe(range);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(nrOfAxioms));
}"
9456,"public void testSubPropertyOfAxiomLearning() throws Exception {
  SubObjectPropertyOfAxiomLearner l=new SubObjectPropertyOfAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setPropertyToDescribe(op1);
  l.init();
  l.start();
  EvaluatedAxiom<OWLSubObjectPropertyOfAxiom> evAxiom=l.getCurrentlyBestEvaluatedAxiom();
  System.out.println(evAxiom);
  double actualScore=evAxiom.getScore().getAccuracy();
  int cntOp1=130;
  int cntOp2=70;
  int cntOp1_Op2=60;
  double beta=3.0;
  double precision=Heuristics.getConfidenceInterval95WaldAverage(cntOp2,cntOp1_Op2);
  double recall=Heuristics.getConfidenceInterval95WaldAverage(cntOp1,cntOp1_Op2);
  double expectedScore=Heuristics.getFScore(recall,precision,beta);
  assertEquals(""String_Node_Str"",expectedScore,actualScore,0d);
}","public void testSubPropertyOfAxiomLearning() throws Exception {
  SubObjectPropertyOfAxiomLearner l=new SubObjectPropertyOfAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setEntityToDescribe(op1);
  l.init();
  l.start();
  EvaluatedAxiom<OWLSubObjectPropertyOfAxiom> evAxiom=l.getCurrentlyBestEvaluatedAxiom();
  System.out.println(evAxiom);
  double actualScore=evAxiom.getScore().getAccuracy();
  int cntOp1=130;
  int cntOp2=70;
  int cntOp1_Op2=60;
  double beta=3.0;
  double precision=Heuristics.getConfidenceInterval95WaldAverage(cntOp2,cntOp1_Op2);
  double recall=Heuristics.getConfidenceInterval95WaldAverage(cntOp1,cntOp1_Op2);
  double expectedScore=Heuristics.getFScore(recall,precision,beta);
  assertEquals(""String_Node_Str"",expectedScore,actualScore,0d);
}"
9457,"public void testDisjointDataPropertiesAxiomLearning() throws Exception {
  DisjointDataPropertyAxiomLearner l=new DisjointDataPropertyAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setPropertyToDescribe(disDataProperty);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(nrOfAxioms));
}","public void testDisjointDataPropertiesAxiomLearning() throws Exception {
  DisjointDataPropertyAxiomLearner l=new DisjointDataPropertyAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setEntityToDescribe(disDataProperty);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(nrOfAxioms));
}"
9458,"public void testEquivalentDataPropertiesAxiomLearning() throws Exception {
  EquivalentDataPropertyAxiomLearner l=new EquivalentDataPropertyAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setPropertyToDescribe(equivDataProperty);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(nrOfAxioms));
}","public void testEquivalentDataPropertiesAxiomLearning() throws Exception {
  EquivalentDataPropertyAxiomLearner l=new EquivalentDataPropertyAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setEntityToDescribe(equivDataProperty);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(nrOfAxioms));
}"
9459,"public void testFunctionalPropertyAxiomLearnining() throws Exception {
  FunctionalObjectPropertyAxiomLearner l=new FunctionalObjectPropertyAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setPropertyToDescribe(functional);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(nrOfAxioms));
}","public void testFunctionalPropertyAxiomLearnining() throws Exception {
  FunctionalObjectPropertyAxiomLearner l=new FunctionalObjectPropertyAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setEntityToDescribe(functional);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(nrOfAxioms));
}"
9460,"public void testSymmetricPropertyAxiomLearning() throws Exception {
  SymmetricObjectPropertyAxiomLearner l=new SymmetricObjectPropertyAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setPropertyToDescribe(symmetric);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(nrOfAxioms));
}","public void testSymmetricPropertyAxiomLearning() throws Exception {
  SymmetricObjectPropertyAxiomLearner l=new SymmetricObjectPropertyAxiomLearner(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setEntityToDescribe(symmetric);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(nrOfAxioms));
}"
9461,"@Test public void testRunDBpedia() throws Exception {
  OWLObjectProperty op=df.getOWLObjectProperty(IRI.create(""String_Node_Str""));
  SparqlEndpointKS ks=new SparqlEndpointKS(SparqlEndpoint.getEndpointDBpedia());
  ks.setCache(CacheUtilsH2.createCacheFrontend(""String_Node_Str"",true,TimeUnit.DAYS.toMillis(1)));
  SPARQLReasoner reasoner=new SPARQLReasoner(ks);
  reasoner.init();
  reasoner.precomputePopularities(PopularityType.OBJECT_PROPERTY);
  List<Class<? extends ObjectPropertyAxiomLearner<? extends OWLObjectPropertyAxiom>>> la=new ArrayList<Class<? extends ObjectPropertyAxiomLearner<? extends OWLObjectPropertyAxiom>>>();
  la.add(DisjointObjectPropertyAxiomLearner.class);
  la.add(SubObjectPropertyOfAxiomLearner.class);
  la.add(EquivalentObjectPropertyAxiomLearner.class);
  la.add(FunctionalObjectPropertyAxiomLearner.class);
  la.add(InverseFunctionalObjectPropertyAxiomLearner.class);
  la.add(ReflexiveObjectPropertyAxiomLearner.class);
  la.add(IrreflexiveObjectPropertyAxiomLearner.class);
  for (  Class<? extends ObjectPropertyAxiomLearner<? extends OWLObjectPropertyAxiom>> cls : la) {
    try {
      Constructor<? extends ObjectPropertyAxiomLearner<? extends OWLObjectPropertyAxiom>> constructor=cls.getConstructor(SparqlEndpointKS.class);
      ObjectPropertyAxiomLearner<? extends OWLObjectPropertyAxiom> learner=(ObjectPropertyAxiomLearner<? extends OWLObjectPropertyAxiom>)constructor.newInstance(ks);
      learner.setPropertyToDescribe(op);
      learner.init();
      learner.start();
      List<?> axioms=learner.getCurrentlyBestEvaluatedAxioms(10);
      System.out.println(axioms);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","@Test public void testRunDBpedia() throws Exception {
  OWLObjectProperty op=df.getOWLObjectProperty(IRI.create(""String_Node_Str""));
  SparqlEndpointKS ks=new SparqlEndpointKS(SparqlEndpoint.getEndpointDBpedia());
  ks.setCache(CacheUtilsH2.createCacheFrontend(""String_Node_Str"",true,TimeUnit.DAYS.toMillis(1)));
  SPARQLReasoner reasoner=new SPARQLReasoner(ks);
  reasoner.init();
  reasoner.precomputePopularities(PopularityType.OBJECT_PROPERTY);
  List<Class<? extends ObjectPropertyAxiomLearner<? extends OWLObjectPropertyAxiom>>> la=new ArrayList<Class<? extends ObjectPropertyAxiomLearner<? extends OWLObjectPropertyAxiom>>>();
  la.add(DisjointObjectPropertyAxiomLearner.class);
  la.add(SubObjectPropertyOfAxiomLearner.class);
  la.add(EquivalentObjectPropertyAxiomLearner.class);
  la.add(FunctionalObjectPropertyAxiomLearner.class);
  la.add(InverseFunctionalObjectPropertyAxiomLearner.class);
  la.add(ReflexiveObjectPropertyAxiomLearner.class);
  la.add(IrreflexiveObjectPropertyAxiomLearner.class);
  for (  Class<? extends ObjectPropertyAxiomLearner<? extends OWLObjectPropertyAxiom>> cls : la) {
    try {
      Constructor<? extends ObjectPropertyAxiomLearner<? extends OWLObjectPropertyAxiom>> constructor=cls.getConstructor(SparqlEndpointKS.class);
      ObjectPropertyAxiomLearner<? extends OWLObjectPropertyAxiom> learner=(ObjectPropertyAxiomLearner<? extends OWLObjectPropertyAxiom>)constructor.newInstance(ks);
      learner.setEntityToDescribe(op);
      learner.init();
      learner.start();
      List<?> axioms=learner.getCurrentlyBestEvaluatedAxioms(10);
      System.out.println(axioms);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}"
9462,"public void testObjectPropertyDomainAxiomLearning() throws Exception {
  ObjectPropertyDomainAxiomLearner2 l=new ObjectPropertyDomainAxiomLearner2(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setPropertyToDescribe(op1);
  l.init();
  l.start();
  EvaluatedAxiom<OWLObjectPropertyDomainAxiom> evAxiom=l.getCurrentlyBestEvaluatedAxiom();
  System.out.println(evAxiom);
  double actualScore=evAxiom.getScore().getAccuracy();
  int cntA=100;
  int cntB=50;
  int cntAB=70;
  double beta=3.0;
  double precision=Heuristics.getConfidenceInterval95WaldAverage(cntB,cntAB);
  double recall=Heuristics.getConfidenceInterval95WaldAverage(cntA,cntAB);
  double expectedScore=Heuristics.getFScore(recall,precision,beta);
  assertEquals(""String_Node_Str"",expectedScore,actualScore,0d);
}","public void testObjectPropertyDomainAxiomLearning() throws Exception {
  ObjectPropertyDomainAxiomLearner2 l=new ObjectPropertyDomainAxiomLearner2(ks);
  l.setMaxExecutionTimeInSeconds(maxExecutionTimeInSeconds);
  l.setEntityToDescribe(op1);
  l.init();
  l.start();
  EvaluatedAxiom<OWLObjectPropertyDomainAxiom> evAxiom=l.getCurrentlyBestEvaluatedAxiom();
  System.out.println(evAxiom);
  double actualScore=evAxiom.getScore().getAccuracy();
  int cntA=100;
  int cntB=50;
  int cntAB=70;
  double beta=3.0;
  double precision=Heuristics.getConfidenceInterval95WaldAverage(cntB,cntAB);
  double recall=Heuristics.getConfidenceInterval95WaldAverage(cntA,cntAB);
  double expectedScore=Heuristics.getFScore(recall,precision,beta);
  assertEquals(""String_Node_Str"",expectedScore,actualScore,0d);
}"
9463,"public EvaluatedAxiom<OWLDisjointClassesAxiom> computeDisjointess(OWLClass clsA,OWLClass clsB){
  logger.debug(""String_Node_Str"" + clsA + ""String_Node_Str""+ clsB+ ""String_Node_Str"");
  if (clsA.equals(clsB)) {
    return new EvaluatedAxiom<OWLDisjointClassesAxiom>(df.getOWLDisjointClassesAxiom(clsA,clsB),new AxiomScore(0d,1d));
  }
  ;
  if (reasoner.isSuperClassOf(clsA,clsB) || reasoner.isSuperClassOf(clsB,clsA)) {
    return new EvaluatedAxiom<OWLDisjointClassesAxiom>(df.getOWLDisjointClassesAxiom(clsA,clsB),new AxiomScore(0d,1d));
  }
  ;
  double scoreValue=0;
  int instanceCountA=reasoner.getPopularity(clsA);
  int instanceCountB=reasoner.getPopularity(clsB);
  if (instanceCountA > 0 && instanceCountB > 0) {
    int instanceCountAB=reasoner.getPopularity(df.getOWLObjectIntersectionOf(clsA,clsB));
    double precision=Heuristics.getConfidenceInterval95WaldAverage(instanceCountB,instanceCountAB);
    double recall=Heuristics.getConfidenceInterval95WaldAverage(instanceCountA,instanceCountAB);
    scoreValue=1 - Heuristics.getFScore(recall,precision);
  }
  AxiomScore score=new AxiomScore(scoreValue);
  return new EvaluatedAxiom<OWLDisjointClassesAxiom>(df.getOWLDisjointClassesAxiom(clsA,clsB),score);
}","public EvaluatedAxiom<OWLDisjointClassesAxiom> computeDisjointess(OWLClass clsA,OWLClass clsB){
  logger.debug(""String_Node_Str"" + clsA + ""String_Node_Str""+ clsB+ ""String_Node_Str"");
  if (clsA.equals(clsB)) {
    return new EvaluatedAxiom<OWLDisjointClassesAxiom>(df.getOWLDisjointClassesAxiom(clsA,clsB),new AxiomScore(0d,1d));
  }
  ;
  if (reasoner.isSuperClassOf(clsA,clsB) || reasoner.isSuperClassOf(clsB,clsA)) {
    return new EvaluatedAxiom<OWLDisjointClassesAxiom>(df.getOWLDisjointClassesAxiom(clsA,clsB),new AxiomScore(0d,1d));
  }
  ;
  double scoreValue=0;
  int instanceCountA=reasoner.getPopularity(clsA);
  int instanceCountB=reasoner.getPopularity(clsB);
  if (instanceCountA > 0 && instanceCountB > 0) {
    int instanceCountAB=reasoner.getPopularityOf(df.getOWLObjectIntersectionOf(clsA,clsB));
    double precision=Heuristics.getConfidenceInterval95WaldAverage(instanceCountB,instanceCountAB);
    double recall=Heuristics.getConfidenceInterval95WaldAverage(instanceCountA,instanceCountAB);
    scoreValue=1 - Heuristics.getFScore(recall,precision);
  }
  AxiomScore score=new AxiomScore(scoreValue);
  return new EvaluatedAxiom<OWLDisjointClassesAxiom>(df.getOWLDisjointClassesAxiom(clsA,clsB),score);
}"
9464,"private Set<EvaluatedDescription> computeDisjointessOfSiblings(OWLClass cls){
  Set<EvaluatedDescription> evaluatedDescriptions=new HashSet<EvaluatedDescription>();
  int instanceCountA=reasoner.getPopularity(cls);
  if (instanceCountA > 0) {
    Set<OWLClass> siblingClasses=reasoner.getSiblingClasses(cls);
    for (    OWLClass sib : siblingClasses) {
      int instanceCountB=reasoner.getPopularity(sib);
      if (instanceCountB > 0) {
        int instanceCountAB=reasoner.getPopularity(df.getOWLObjectIntersectionOf(cls,sib));
        double precision=Heuristics.getConfidenceInterval95WaldAverage(instanceCountB,instanceCountAB);
        double recall=Heuristics.getConfidenceInterval95WaldAverage(instanceCountA,instanceCountAB);
        double score=1 - Heuristics.getFScore(recall,precision);
        EvaluatedDescription evalDesc=new EvaluatedDescription(sib,new AxiomScore(score));
        evaluatedDescriptions.add(evalDesc);
      }
    }
  }
  return evaluatedDescriptions;
}","private Set<EvaluatedDescription> computeDisjointessOfSiblings(OWLClass cls){
  Set<EvaluatedDescription> evaluatedDescriptions=new HashSet<EvaluatedDescription>();
  int instanceCountA=reasoner.getPopularity(cls);
  if (instanceCountA > 0) {
    Set<OWLClass> siblingClasses=reasoner.getSiblingClasses(cls);
    for (    OWLClass sib : siblingClasses) {
      int instanceCountB=reasoner.getPopularity(sib);
      if (instanceCountB > 0) {
        int instanceCountAB=reasoner.getPopularityOf(df.getOWLObjectIntersectionOf(cls,sib));
        double precision=Heuristics.getConfidenceInterval95WaldAverage(instanceCountB,instanceCountAB);
        double recall=Heuristics.getConfidenceInterval95WaldAverage(instanceCountA,instanceCountAB);
        double score=1 - Heuristics.getFScore(recall,precision);
        EvaluatedDescription evalDesc=new EvaluatedDescription(sib,new AxiomScore(score));
        evaluatedDescriptions.add(evalDesc);
      }
    }
  }
  return evaluatedDescriptions;
}"
9465,"@Override public Set<OWLObjectPropertyAssertionAxiom> getNegativeExamples(EvaluatedAxiom<OWLInverseFunctionalObjectPropertyAxiom> evaluatedAxiom){
  OWLInverseFunctionalObjectPropertyAxiom axiom=evaluatedAxiom.getAxiom();
  negExamplesQueryTemplate.setIri(""String_Node_Str"",axiom.getProperty().asOWLObjectProperty().toStringID());
  Set<OWLObjectPropertyAssertionAxiom> negExamples=new TreeSet<OWLObjectPropertyAssertionAxiom>();
  ResultSet rs;
  if (workingModel != null) {
    rs=executeSelectQuery(negExamplesQueryTemplate.toString(),workingModel);
  }
 else {
    rs=executeSelectQuery(negExamplesQueryTemplate.toString());
  }
  while (rs.hasNext()) {
    QuerySolution qs=rs.next();
    OWLIndividual object=df.getOWLNamedIndividual(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLIndividual subject=df.getOWLNamedIndividual(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    negExamples.add(df.getOWLObjectPropertyAssertionAxiom(propertyToDescribe,subject,object));
    subject=df.getOWLNamedIndividual(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    negExamples.add(df.getOWLObjectPropertyAssertionAxiom(propertyToDescribe,subject,object));
  }
  return negExamples;
}","@Override public Set<OWLObjectPropertyAssertionAxiom> getNegativeExamples(EvaluatedAxiom<OWLInverseFunctionalObjectPropertyAxiom> evaluatedAxiom){
  OWLInverseFunctionalObjectPropertyAxiom axiom=evaluatedAxiom.getAxiom();
  negExamplesQueryTemplate.setIri(""String_Node_Str"",axiom.getProperty().asOWLObjectProperty().toStringID());
  Set<OWLObjectPropertyAssertionAxiom> negExamples=new TreeSet<OWLObjectPropertyAssertionAxiom>();
  ResultSet rs=executeSelectQuery(negExamplesQueryTemplate.toString());
  while (rs.hasNext()) {
    QuerySolution qs=rs.next();
    OWLIndividual object=df.getOWLNamedIndividual(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLIndividual subject1=df.getOWLNamedIndividual(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLIndividual subject2=df.getOWLNamedIndividual(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    negExamples.add(df.getOWLObjectPropertyAssertionAxiom(propertyToDescribe,subject1,object));
    negExamples.add(df.getOWLObjectPropertyAssertionAxiom(propertyToDescribe,subject2,object));
  }
  return negExamples;
}"
9466,"public static void main(String[] args) throws Exception {
  InverseFunctionalObjectPropertyAxiomLearner l=new InverseFunctionalObjectPropertyAxiomLearner(new SparqlEndpointKS(SparqlEndpoint.getEndpointDBpedia()));
  l.setPropertyToDescribe(new OWLDataFactoryImpl().getOWLObjectProperty(IRI.create(""String_Node_Str"")));
  l.setMaxExecutionTimeInSeconds(5);
  l.setForceSPARQL_1_0_Mode(true);
  l.init();
  l.start();
  List<EvaluatedAxiom<OWLInverseFunctionalObjectPropertyAxiom>> axioms=l.getCurrentlyBestEvaluatedAxioms(5);
  System.out.println(axioms);
  for (  EvaluatedAxiom<OWLInverseFunctionalObjectPropertyAxiom> axiom : axioms) {
    l.explainScore(axiom);
  }
}","public static void main(String[] args) throws Exception {
  InverseFunctionalObjectPropertyAxiomLearner l=new InverseFunctionalObjectPropertyAxiomLearner(new SparqlEndpointKS(SparqlEndpoint.getEndpointDBpediaLiveAKSW()));
  l.setPropertyToDescribe(new OWLDataFactoryImpl().getOWLObjectProperty(IRI.create(""String_Node_Str"")));
  l.setMaxExecutionTimeInSeconds(5);
  l.init();
  l.start();
  List<EvaluatedAxiom<OWLInverseFunctionalObjectPropertyAxiom>> axioms=l.getCurrentlyBestEvaluatedAxioms(5);
  System.out.println(axioms);
  for (  EvaluatedAxiom<OWLInverseFunctionalObjectPropertyAxiom> axiom : axioms) {
    l.explainScore(axiom);
  }
}"
9467,"@Override public Set<OWLObjectPropertyAssertionAxiom> getNegativeExamples(EvaluatedAxiom<T> evaluatedAxiom){
  T axiom=evaluatedAxiom.getAxiom();
  negExamplesQueryTemplate.setIri(""String_Node_Str"",axiom.getProperty().asOWLObjectProperty().toStringID());
  Set<OWLObjectPropertyAssertionAxiom> negExamples=new TreeSet<OWLObjectPropertyAssertionAxiom>();
  ResultSet rs;
  if (workingModel != null) {
    rs=executeSelectQuery(negExamplesQueryTemplate.toString(),workingModel);
  }
 else {
    rs=executeSelectQuery(negExamplesQueryTemplate.toString());
  }
  while (rs.hasNext()) {
    QuerySolution qs=rs.next();
    OWLIndividual subject=df.getOWLNamedIndividual(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLIndividual object=df.getOWLNamedIndividual(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    negExamples.add(df.getOWLObjectPropertyAssertionAxiom(propertyToDescribe,subject,object));
  }
  return negExamples;
}","@Override public Set<OWLObjectPropertyAssertionAxiom> getNegativeExamples(EvaluatedAxiom<T> evaluatedAxiom){
  T axiom=evaluatedAxiom.getAxiom();
  negExamplesQueryTemplate.setIri(""String_Node_Str"",axiom.getProperty().asOWLObjectProperty().toStringID());
  Set<OWLObjectPropertyAssertionAxiom> negExamples=new TreeSet<OWLObjectPropertyAssertionAxiom>();
  ResultSet rs;
  if (workingModel != null) {
    rs=executeSelectQuery(negExamplesQueryTemplate.toString(),workingModel);
  }
 else {
    rs=executeSelectQuery(negExamplesQueryTemplate.toString());
  }
  List<String> vars=rs.getResultVars();
  boolean onlySubject=vars.size() == 1;
  while (rs.hasNext()) {
    QuerySolution qs=rs.next();
    OWLIndividual subject=df.getOWLNamedIndividual(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLIndividual object=df.getOWLNamedIndividual(IRI.create(qs.getResource(onlySubject ? ""String_Node_Str"" : ""String_Node_Str"").getURI()));
    negExamples.add(df.getOWLObjectPropertyAssertionAxiom(propertyToDescribe,subject,object));
  }
  return negExamples;
}"
9468,"@Override public void setPropertyToDescribe(OWLObjectProperty propertyToDescribe){
  super.setPropertyToDescribe(propertyToDescribe);
  POS_FREQUENCY_QUERY.setIri(""String_Node_Str"",propertyToDescribe.toStringID());
  ALREADY_DECLARED_QUERY.setIri(""String_Node_Str"",propertyToDescribe.toStringID());
  GET_SAMPLE_QUERY.setIri(""String_Node_Str"",propertyToDescribe.toStringID());
  IRI type;
  if (axiomType.equals(AxiomType.SYMMETRIC_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_SYMMETRIC_PROPERTY.getIRI();
  }
 else   if (axiomType.equals(AxiomType.ASYMMETRIC_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_ASYMMETRIC_PROPERTY.getIRI();
  }
 else   if (axiomType.equals(AxiomType.FUNCTIONAL_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_FUNCTIONAL_PROPERTY.getIRI();
  }
 else   if (axiomType.equals(AxiomType.INVERSE_FUNCTIONAL_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_INVERSE_FUNCTIONAL_PROPERTY.getIRI();
  }
 else   if (axiomType.equals(AxiomType.REFLEXIVE_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_REFLEXIVE_PROPERTY.getIRI();
  }
 else   if (axiomType.equals(AxiomType.IRREFLEXIVE_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_IRREFLEXIVE_PROPERTY.getIRI();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + axiomType);
  }
  ALREADY_DECLARED_QUERY.setIri(""String_Node_Str"",type.toString());
}","@Override public void setPropertyToDescribe(OWLObjectProperty propertyToDescribe){
  super.setPropertyToDescribe(propertyToDescribe);
  POS_FREQUENCY_QUERY.setIri(""String_Node_Str"",propertyToDescribe.toStringID());
  ALREADY_DECLARED_QUERY.setIri(""String_Node_Str"",propertyToDescribe.toStringID());
  GET_SAMPLE_QUERY.setIri(""String_Node_Str"",propertyToDescribe.toStringID());
  IRI type;
  if (axiomType.equals(AxiomType.SYMMETRIC_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_SYMMETRIC_PROPERTY.getIRI();
  }
 else   if (axiomType.equals(AxiomType.ASYMMETRIC_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_ASYMMETRIC_PROPERTY.getIRI();
  }
 else   if (axiomType.equals(AxiomType.FUNCTIONAL_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_FUNCTIONAL_PROPERTY.getIRI();
  }
 else   if (axiomType.equals(AxiomType.INVERSE_FUNCTIONAL_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_INVERSE_FUNCTIONAL_PROPERTY.getIRI();
  }
 else   if (axiomType.equals(AxiomType.REFLEXIVE_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_REFLEXIVE_PROPERTY.getIRI();
  }
 else   if (axiomType.equals(AxiomType.IRREFLEXIVE_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_IRREFLEXIVE_PROPERTY.getIRI();
  }
 else   if (axiomType.equals(AxiomType.TRANSITIVE_OBJECT_PROPERTY)) {
    type=OWLRDFVocabulary.OWL_TRANSITIVE_PROPERTY.getIRI();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + axiomType);
  }
  ALREADY_DECLARED_QUERY.setIri(""String_Node_Str"",type.toString());
}"
9469,"@Override public Set<OWLObjectPropertyAssertionAxiom> getPositiveExamples(EvaluatedAxiom<T> evAxiom){
  T axiom=evAxiom.getAxiom();
  posExamplesQueryTemplate.setIri(""String_Node_Str"",axiom.getProperty().asOWLObjectProperty().toStringID());
  Set<OWLObjectPropertyAssertionAxiom> posExamples=new TreeSet<OWLObjectPropertyAssertionAxiom>();
  ResultSet rs=executeSelectQuery(posExamplesQueryTemplate.toString());
  while (rs.hasNext()) {
    QuerySolution qs=rs.next();
    OWLIndividual subject=df.getOWLNamedIndividual(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLIndividual object=df.getOWLNamedIndividual(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    posExamples.add(df.getOWLObjectPropertyAssertionAxiom(entityToDescribe,subject,object));
  }
  return posExamples;
}","@Override public Set<OWLObjectPropertyAssertionAxiom> getPositiveExamples(EvaluatedAxiom<T> evAxiom){
  T axiom=evAxiom.getAxiom();
  posExamplesQueryTemplate.setIri(""String_Node_Str"",axiom.getProperty().asOWLObjectProperty().toStringID());
  Set<OWLObjectPropertyAssertionAxiom> posExamples=new TreeSet<OWLObjectPropertyAssertionAxiom>();
  ResultSet rs=executeSelectQuery(posExamplesQueryTemplate.toString());
  List<String> vars=rs.getResultVars();
  boolean onlySubject=vars.size() == 1;
  while (rs.hasNext()) {
    QuerySolution qs=rs.next();
    OWLIndividual subject=df.getOWLNamedIndividual(IRI.create(qs.getResource(""String_Node_Str"").getURI()));
    OWLIndividual object=df.getOWLNamedIndividual(IRI.create(qs.getResource(onlySubject ? ""String_Node_Str"" : ""String_Node_Str"").getURI()));
    posExamples.add(df.getOWLObjectPropertyAssertionAxiom(entityToDescribe,subject,object));
  }
  return posExamples;
}"
9470,"public void simplifyTree(QueryTree<N> tree,List<QueryTree<N>> negTrees){
  if (tree.getChildren().isEmpty()) {
    return;
  }
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(tree,endpoint.getBaseURI(),endpoint.getPrefixes()));
    int i=1;
  }
  List<Object> path;
  boolean pathExists;
  for (  QueryTree<N> leaf : tree.getLeafs()) {
    pathExists=false;
    path=getPathFromRootToNode(leaf);
    pathExists=true;
    for (    QueryTree<N> negTree : negTrees) {
      if (!pathExists(leaf,new ArrayList<Object>(path),negTree)) {
        pathExists=false;
        break;
      }
    }
    if (pathExists) {
      String pathString=""String_Node_Str"" + leaf.getParent().getUserObject() + ""String_Node_Str""+ leaf.getParent().getEdge(leaf)+ ""String_Node_Str""+ leaf.getUserObject()+ ""String_Node_Str"";
      leaf.getParent().removeChild((QueryTreeImpl<N>)leaf);
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + pathString + ""String_Node_Str"");
      }
    }
  }
}","public void simplifyTree(QueryTree<N> tree,List<QueryTree<N>> negTrees){
  if (tree.getChildren().isEmpty()) {
    return;
  }
  System.out.println(tree.getStringRepresentation());
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(tree,endpoint.getBaseURI(),endpoint.getPrefixes()));
    int i=1;
  }
  List<Object> path;
  boolean pathExists;
  for (  QueryTree<N> leaf : tree.getLeafs()) {
    pathExists=false;
    path=getPathFromRootToNode(leaf);
    pathExists=true;
    for (    QueryTree<N> negTree : negTrees) {
      if (!pathExists(leaf,new ArrayList<Object>(path),negTree)) {
        pathExists=false;
        break;
      }
    }
    if (pathExists) {
      String pathString=""String_Node_Str"" + leaf.getParent().getUserObject() + ""String_Node_Str""+ leaf.getParent().getEdge(leaf)+ ""String_Node_Str""+ leaf.getUserObject()+ ""String_Node_Str"";
      leaf.getParent().removeChild((QueryTreeImpl<N>)leaf);
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + pathString + ""String_Node_Str"");
      }
    }
  }
}"
9471,"private TreeSet<Description> refineNode(OENode node){
  nodes.remove(node);
  int horizExp=node.getHorizontalExpansion();
  TreeSet<Description> refinements=(TreeSet<Description>)operator.refine(node.getDescription(),horizExp + 1);
  System.out.println(refinements);
  node.incHorizontalExpansion();
  node.setRefinementCount(refinements.size());
  nodes.add(node);
  return refinements;
}","private TreeSet<Description> refineNode(OENode node){
  nodes.remove(node);
  int horizExp=node.getHorizontalExpansion();
  TreeSet<Description> refinements=(TreeSet<Description>)operator.refine(node.getDescription(),horizExp + 1);
  node.incHorizontalExpansion();
  node.setRefinementCount(refinements.size());
  nodes.add(node);
  return refinements;
}"
9472,"private SortedSet<String> getAllResources(String query){
  SortedSet<String> resources=new TreeSet<String>();
  query=""String_Node_Str"" + query.substring(7) + ""String_Node_Str"";
  ResultSet rs;
  if (selectCache == null) {
    rs=executeSelectQuery(query);
  }
 else {
    String result=selectCache.executeSelectQuery(endpoint,query);
    rs=SparqlQuery.convertJSONtoResultSet(result);
  }
  String uri;
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    uri=qs.getResource(""String_Node_Str"").getURI();
    resources.add(uri);
  }
  return resources;
}","private SortedSet<String> getAllResources(String query){
  SortedSet<String> resources=new TreeSet<String>();
  query=query + ""String_Node_Str"";
  ResultSet rs;
  if (selectCache == null) {
    rs=executeSelectQuery(query);
  }
 else {
    String result=selectCache.executeSelectQuery(endpoint,query);
    rs=SparqlQuery.convertJSONtoResultSet(result);
  }
  String uri;
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    uri=qs.getResource(""String_Node_Str"").getURI();
    resources.add(uri);
  }
  return resources;
}"
9473,"private String computeQuestionBetterPerformance(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources) throws TimeOutException {
  startTime=System.currentTimeMillis();
  this.lgg=lgg;
  this.negTrees=negTrees;
  if (userAnsweredWithNo()) {
    noSequences.add(lastSequence);
  }
  negExamplesCount=negTrees.size();
  determiningNodeIds=getDeterminingNodeIds(lgg,negTrees);
  logger.debug(""String_Node_Str"");
  postLGG=getFilteredTree(lgg);
  PostLGG<N> postGen=new PostLGG<N>((SPARQLEndpointEx)endpoint);
  postGen.simplifyTree(postLGG,negTrees);
  if (logger.isDebugEnabled()) {
    String treeString;
    if (endpoint instanceof SPARQLEndpointEx) {
      treeString=TreeHelper.getAbbreviatedTreeRepresentation(postLGG,((SPARQLEndpointEx)endpoint).getBaseURI(),((SPARQLEndpointEx)endpoint).getPrefixes());
    }
 else {
      treeString=postLGG.getStringRepresentation();
    }
    logger.debug(""String_Node_Str"" + treeString);
    logger.debug(""String_Node_Str"" + postLGG.toSPARQLQueryString());
    logger.debug(""String_Node_Str"" + getAllResources(postLGG.toSPARQLQueryString()).size());
  }
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=null;
  if (generalizeSortedByNegatives) {
    queue=getAllowedGeneralisationsSortedByMatrix(new GeneralisedQueryTree<N>(postLGG),negTrees);
  }
 else {
    queue=getAllowedGeneralisationsSorted2(new GeneralisedQueryTree<N>(postLGG));
  }
  logger.debug(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  GeneralisedQueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  List<GeneralisedQueryTree<N>> gens;
  List<GeneralisedQueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<GeneralisedQueryTree<N>>();
    logger.debug(""String_Node_Str"");
    tree1=getGeneralisedQueryTreeNotContainingNoSequence(queue);
    tmp=tree1;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + tmp.getChanges());
    }
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    neededGeneralisations.add(tmp);
    logger.debug(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      if (generalizeSortedByNegatives) {
        gens=getAllowedGeneralisationsSortedByMatrix(tmp,negTrees);
      }
 else {
        gens=getAllowedGeneralisationsSorted2(tmp);
      }
      if (gens.isEmpty()) {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"");
        }
        break;
      }
      tmp=getGeneralisedQueryTreeNotContainingNoSequence(gens);
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.debug(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
 else {
        neededGeneralisations.add(tmp);
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      if (index == -1) {
        tree2=tmp;
      }
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp;
    }
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + tree2.getQueryTree().getStringRepresentation());
    }
    String newResource=getNewResource2(fSparql(lgg,tree2.getChanges()),knownResources);
    if (isTerminationCriteriaReached()) {
      throw new TimeOutException(maxExecutionTimeInSeconds);
    }
    logger.debug(""String_Node_Str"" + newResource);
    if (!(newResource == null)) {
      logger.debug(""String_Node_Str"");
      List<QueryTreeChange> firstChanges=new ArrayList<QueryTreeChange>(neededGeneralisations.get(0).getChanges());
      while (firstChanges.size() > 1) {
        firstChanges.remove(firstChanges.size() - 1);
        neededGeneralisations.add(0,new GeneralisedQueryTree<N>(getTreeByChanges(lgg,firstChanges),firstChanges));
        firstChanges=new ArrayList<QueryTreeChange>(firstChanges);
      }
      newResource=findMostSpecificResourceTree2(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      logger.debug(""String_Node_Str"");
      return newResource;
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
  return null;
}","private String computeQuestionBetterPerformance(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources) throws TimeOutException {
  startTime=System.currentTimeMillis();
  this.lgg=lgg;
  this.negTrees=negTrees;
  if (userAnsweredWithNo()) {
    noSequences.add(lastSequence);
  }
  negExamplesCount=negTrees.size();
  determiningNodeIds=getDeterminingNodeIds(lgg,negTrees);
  logger.debug(""String_Node_Str"");
  postLGG=getFilteredTree(lgg);
  PostLGG<N> postGen;
  if (endpoint != null) {
    postGen=new PostLGG<N>((SPARQLEndpointEx)endpoint);
  }
 else {
    postGen=new PostLGG<N>();
  }
  postGen.simplifyTree(postLGG,negTrees);
  if (logger.isDebugEnabled()) {
    String treeString;
    if (endpoint instanceof SPARQLEndpointEx) {
      treeString=TreeHelper.getAbbreviatedTreeRepresentation(postLGG,((SPARQLEndpointEx)endpoint).getBaseURI(),((SPARQLEndpointEx)endpoint).getPrefixes());
    }
 else {
      treeString=postLGG.getStringRepresentation();
    }
    logger.debug(""String_Node_Str"" + treeString);
    logger.debug(""String_Node_Str"" + postLGG.toSPARQLQueryString());
    logger.debug(""String_Node_Str"" + getAllResources(postLGG.toSPARQLQueryString()).size());
  }
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=null;
  if (generalizeSortedByNegatives) {
    queue=getAllowedGeneralisationsSortedByMatrix(new GeneralisedQueryTree<N>(postLGG),negTrees);
  }
 else {
    queue=getAllowedGeneralisationsSorted2(new GeneralisedQueryTree<N>(postLGG));
  }
  logger.debug(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  GeneralisedQueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  List<GeneralisedQueryTree<N>> gens;
  List<GeneralisedQueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<GeneralisedQueryTree<N>>();
    logger.debug(""String_Node_Str"");
    tree1=getGeneralisedQueryTreeNotContainingNoSequence(queue);
    tmp=tree1;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + tmp.getChanges());
    }
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    neededGeneralisations.add(tmp);
    logger.debug(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      if (generalizeSortedByNegatives) {
        gens=getAllowedGeneralisationsSortedByMatrix(tmp,negTrees);
      }
 else {
        gens=getAllowedGeneralisationsSorted2(tmp);
      }
      if (gens.isEmpty()) {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"");
        }
        break;
      }
      tmp=getGeneralisedQueryTreeNotContainingNoSequence(gens);
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.debug(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
 else {
        neededGeneralisations.add(tmp);
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      if (index == -1) {
        tree2=tmp;
      }
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp;
    }
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + tree2.getQueryTree().getStringRepresentation());
    }
    String newResource=getNewResource2(fSparql(lgg,tree2.getChanges()),knownResources);
    if (isTerminationCriteriaReached()) {
      throw new TimeOutException(maxExecutionTimeInSeconds);
    }
    logger.debug(""String_Node_Str"" + newResource);
    if (!(newResource == null)) {
      logger.debug(""String_Node_Str"");
      List<QueryTreeChange> firstChanges=new ArrayList<QueryTreeChange>(neededGeneralisations.get(0).getChanges());
      while (firstChanges.size() > 1) {
        firstChanges.remove(firstChanges.size() - 1);
        neededGeneralisations.add(0,new GeneralisedQueryTree<N>(getTreeByChanges(lgg,firstChanges),firstChanges));
        firstChanges=new ArrayList<QueryTreeChange>(firstChanges);
      }
      newResource=findMostSpecificResourceTree2(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      logger.debug(""String_Node_Str"");
      return newResource;
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
  return null;
}"
9474,"public PostLGG(SPARQLEndpointEx endpoint){
  this.endpoint=endpoint;
}","public PostLGG(){
}"
9475,"public void simplifyTree(QueryTree<N> tree,List<QueryTree<N>> negTrees){
  if (tree.getChildren().isEmpty()) {
    return;
  }
  System.out.println(tree.getStringRepresentation());
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(tree,endpoint.getBaseURI(),endpoint.getPrefixes()));
    int i=1;
  }
  List<Object> path;
  boolean pathExists;
  for (  QueryTree<N> leaf : tree.getLeafs()) {
    pathExists=false;
    path=getPathFromRootToNode(leaf);
    pathExists=true;
    for (    QueryTree<N> negTree : negTrees) {
      if (!pathExists(leaf,new ArrayList<Object>(path),negTree)) {
        pathExists=false;
        break;
      }
    }
    if (pathExists) {
      String pathString=""String_Node_Str"" + leaf.getParent().getUserObject() + ""String_Node_Str""+ leaf.getParent().getEdge(leaf)+ ""String_Node_Str""+ leaf.getUserObject()+ ""String_Node_Str"";
      leaf.getParent().removeChild((QueryTreeImpl<N>)leaf);
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + pathString + ""String_Node_Str"");
      }
    }
  }
}","public void simplifyTree(QueryTree<N> tree,List<QueryTree<N>> negTrees){
  if (tree.getChildren().isEmpty()) {
    return;
  }
  if (logger.isDebugEnabled()) {
    String s;
    if (endpoint != null) {
      s=TreeHelper.getAbbreviatedTreeRepresentation(tree,endpoint.getBaseURI(),endpoint.getPrefixes());
    }
 else {
      s=tree.getStringRepresentation();
    }
    logger.debug(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + s);
    int i=1;
  }
  List<Object> path;
  boolean pathExists;
  for (  QueryTree<N> leaf : tree.getLeafs()) {
    pathExists=false;
    path=getPathFromRootToNode(leaf);
    pathExists=true;
    for (    QueryTree<N> negTree : negTrees) {
      if (!pathExists(leaf,new ArrayList<Object>(path),negTree)) {
        pathExists=false;
        break;
      }
    }
    if (pathExists) {
      String pathString=""String_Node_Str"" + leaf.getParent().getUserObject() + ""String_Node_Str""+ leaf.getParent().getEdge(leaf)+ ""String_Node_Str""+ leaf.getUserObject()+ ""String_Node_Str"";
      leaf.getParent().removeChild((QueryTreeImpl<N>)leaf);
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + pathString + ""String_Node_Str"");
      }
    }
  }
}"
9476,"@Override public QueryTree<N> getLGG(List<QueryTree<N>> trees,boolean learnFilters){
  nodeId=0;
  List<QueryTree<N>> treeList=new ArrayList<QueryTree<N>>(trees);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
  }
  for (int i=0; i < treeList.size(); i++) {
    if (logger.isDebugEnabled()) {
      logger.debug(treeList.get(i).getStringRepresentation());
    }
    if (i != treeList.size() - 1) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
  if (trees.size() == 1) {
    return trees.iterator().next();
  }
  Monitor mon=MonitorFactory.getTimeMonitor(""String_Node_Str"");
  mon.start();
  QueryTree<N> lgg=getLGG(treeList.get(0),treeList.get(1),learnFilters);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + lgg.getStringRepresentation());
  }
  for (int i=2; i < treeList.size(); i++) {
    lgg=getLGG(lgg,treeList.get(i),learnFilters);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ lgg.getStringRepresentation());
    }
  }
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
    logger.debug(lgg.getStringRepresentation());
  }
  mon.stop();
  addNumbering(lgg);
  return lgg;
}","@Override public QueryTree<N> getLGG(List<QueryTree<N>> trees,boolean learnFilters){
  nodeId=0;
  List<QueryTree<N>> treeList=new ArrayList<QueryTree<N>>(trees);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
  }
  for (int i=0; i < treeList.size(); i++) {
    if (logger.isDebugEnabled()) {
      logger.debug(treeList.get(i).getStringRepresentation());
    }
    if (i != treeList.size() - 1) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
  if (trees.size() == 1) {
    return trees.iterator().next();
  }
  Monitor mon=MonitorFactory.getTimeMonitor(""String_Node_Str"");
  mon.start();
  QueryTree<N> lgg=computeLGG(treeList.get(0),treeList.get(1),learnFilters);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + lgg.getStringRepresentation());
  }
  for (int i=2; i < treeList.size(); i++) {
    nodeId=0;
    lgg=computeLGG(lgg,treeList.get(i),learnFilters);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ lgg.getStringRepresentation());
    }
  }
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
    logger.debug(lgg.getStringRepresentation());
  }
  mon.stop();
  addNumbering(lgg);
  return lgg;
}"
9477,"@SuppressWarnings({""String_Node_Str""}) public Set<Description> refine(Description description,int maxLength,List<Description> knownRefinements,Description currDomain){
  if (!(currDomain instanceof Thing) && !topARefinementsLength.containsKey(currDomain))   topARefinementsLength.put((NamedClass)currDomain,0);
  Set<Description> refinements=new TreeSet<Description>(conceptComparator);
  Set<Description> tmp=new HashSet<Description>();
  if (description instanceof Thing) {
    if (currDomain instanceof Thing) {
      if (maxLength > topRefinementsLength)       computeTopRefinements(maxLength);
      refinements=(TreeSet<Description>)topRefinementsCumulative.get(maxLength).clone();
    }
 else {
      if (maxLength > topARefinementsLength.get(currDomain)) {
        computeTopRefinements(maxLength,(NamedClass)currDomain);
      }
      refinements=(TreeSet<Description>)topARefinementsCumulative.get(currDomain).get(maxLength).clone();
    }
  }
 else   if (description instanceof Nothing) {
  }
 else   if (description instanceof NamedClass) {
    refinements.addAll(subHierarchy.getSubClasses(description));
    refinements.remove(new Nothing());
  }
 else   if (description instanceof Negation && description.getChild(0) instanceof NamedClass) {
    tmp=subHierarchy.getSuperClasses(description.getChild(0));
    for (    Description c : tmp) {
      if (!(c instanceof Thing))       refinements.add(new Negation(c));
    }
  }
 else   if (description instanceof Intersection) {
    for (    Description child : description.getChildren()) {
      tmp=refine(child,maxLength - description.getLength() + child.getLength(),null,currDomain);
      for (      Description c : tmp) {
        List<Description> newChildren=(List<Description>)((LinkedList<Description>)description.getChildren()).clone();
        newChildren.add(c);
        newChildren.remove(child);
        Intersection mc=new Intersection(newChildren);
        ConceptTransformation.cleanConceptNonRecursive(mc);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc,conceptComparator);
        if (checkIntersection(mc))         refinements.add(mc);
      }
    }
  }
 else   if (description instanceof Union) {
    for (    Description child : description.getChildren()) {
      tmp=refine(child,maxLength - description.getLength() + child.getLength(),null,currDomain);
      for (      Description c : tmp) {
        List<Description> newChildren=new LinkedList<Description>(description.getChildren());
        newChildren.remove(child);
        newChildren.add(c);
        Union md=new Union(newChildren);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(md,conceptComparator);
        refinements.add(md);
      }
    }
    if (dropDisjuncts) {
      if (description.getChildren().size() == 2) {
        refinements.add(description.getChild(0));
        refinements.add(description.getChild(1));
      }
 else {
        for (int i=0; i < description.getChildren().size(); i++) {
          List<Description> newChildren=new LinkedList<Description>(description.getChildren());
          newChildren.remove(i);
          Union md=new Union(newChildren);
          refinements.add(md);
        }
      }
    }
  }
 else   if (description instanceof ObjectSomeRestriction) {
    ObjectPropertyExpression role=((ObjectQuantorRestriction)description).getRole();
    Description range=opRanges.get(role);
    tmp=refine(description.getChild(0),maxLength - 2,null,range);
    for (    Description c : tmp)     refinements.add(new ObjectSomeRestriction(((ObjectQuantorRestriction)description).getRole(),c));
    ObjectProperty ar=(ObjectProperty)role;
    Set<ObjectProperty> moreSpecialRoles=reasoner.getSubProperties(ar);
    for (    ObjectProperty moreSpecialRole : moreSpecialRoles)     refinements.add(new ObjectSomeRestriction(moreSpecialRole,description.getChild(0)));
    if (useCardinalityRestrictions) {
      if (maxLength > description.getLength() && maxNrOfFillers.get(ar) > 1) {
        ObjectMinCardinalityRestriction min=new ObjectMinCardinalityRestriction(2,role,description.getChild(0));
        refinements.add(min);
      }
    }
    if (useHasValueConstructor && description.getChild(0) instanceof Thing) {
      Set<Individual> frequentInds=frequentValues.get(role);
      if (frequentInds != null) {
        for (        Individual ind : frequentInds) {
          ObjectValueRestriction ovr=new ObjectValueRestriction((ObjectProperty)role,ind);
          refinements.add(ovr);
        }
      }
    }
  }
 else   if (description instanceof ObjectAllRestriction) {
    ObjectPropertyExpression role=((ObjectQuantorRestriction)description).getRole();
    Description range=opRanges.get(role);
    tmp=refine(description.getChild(0),maxLength - 2,null,range);
    for (    Description c : tmp) {
      refinements.add(new ObjectAllRestriction(((ObjectQuantorRestriction)description).getRole(),c));
    }
    if (description.getChild(0) instanceof NamedClass && tmp.size() == 0) {
      refinements.add(new ObjectAllRestriction(((ObjectQuantorRestriction)description).getRole(),new Nothing()));
    }
    ObjectProperty ar=(ObjectProperty)role;
    Set<ObjectProperty> moreSpecialRoles=reasoner.getSubProperties(ar);
    for (    ObjectProperty moreSpecialRole : moreSpecialRoles) {
      refinements.add(new ObjectAllRestriction(moreSpecialRole,description.getChild(0)));
    }
  }
 else   if (description instanceof ObjectCardinalityRestriction) {
    ObjectPropertyExpression role=((ObjectCardinalityRestriction)description).getRole();
    Description range=opRanges.get(role);
    int number=((ObjectCardinalityRestriction)description).getCardinality();
    if (description instanceof ObjectMaxCardinalityRestriction) {
      tmp=refine(description.getChild(0),maxLength - 3,null,range);
      for (      Description d : tmp) {
        refinements.add(new ObjectMaxCardinalityRestriction(number,role,d));
      }
      ObjectMaxCardinalityRestriction max=(ObjectMaxCardinalityRestriction)description;
      if (number > 1)       refinements.add(new ObjectMaxCardinalityRestriction(number - 1,max.getRole(),max.getChild(0)));
    }
 else     if (description instanceof ObjectMinCardinalityRestriction) {
      tmp=refine(description.getChild(0),maxLength - 3,null,range);
      for (      Description d : tmp) {
        refinements.add(new ObjectMinCardinalityRestriction(number,role,d));
      }
      ObjectMinCardinalityRestriction min=(ObjectMinCardinalityRestriction)description;
      if (number < maxNrOfFillers.get(min.getRole()))       refinements.add(new ObjectMinCardinalityRestriction(number + 1,min.getRole(),min.getChild(0)));
    }
  }
 else   if (description instanceof DatatypeSomeRestriction) {
    DatatypeSomeRestriction dsr=(DatatypeSomeRestriction)description;
    DatatypeProperty dp=(DatatypeProperty)dsr.getRestrictedPropertyExpression();
    DataRange dr=dsr.getDataRange();
    if (dr instanceof DoubleMaxValue) {
      double value=((DoubleMaxValue)dr).getValue();
      int splitIndex=splits.get(dp).lastIndexOf(value);
      if (splitIndex == -1)       throw new Error(""String_Node_Str"");
      int newSplitIndex=splitIndex - 1;
      if (newSplitIndex >= 0) {
        DoubleMaxValue max=new DoubleMaxValue(splits.get(dp).get(newSplitIndex));
        DatatypeSomeRestriction newDSR=new DatatypeSomeRestriction(dp,max);
        refinements.add(newDSR);
      }
    }
 else     if (dr instanceof DoubleMinValue) {
      double value=((DoubleMinValue)dr).getValue();
      int splitIndex=splits.get(dp).lastIndexOf(value);
      if (splitIndex == -1)       throw new Error(""String_Node_Str"");
      int newSplitIndex=splitIndex + 1;
      if (newSplitIndex < splits.get(dp).size()) {
        DoubleMinValue min=new DoubleMinValue(splits.get(dp).get(newSplitIndex));
        DatatypeSomeRestriction newDSR=new DatatypeSomeRestriction(dp,min);
        refinements.add(newDSR);
      }
    }
  }
 else   if (description instanceof StringValueRestriction) {
    StringValueRestriction svr=(StringValueRestriction)description;
    DatatypeProperty dp=svr.getRestrictedPropertyExpression();
    Set<DatatypeProperty> subDPs=reasoner.getSubProperties(dp);
    for (    DatatypeProperty subDP : subDPs) {
      refinements.add(new StringValueRestriction(subDP,svr.getStringValue()));
    }
  }
  if (!(description instanceof Thing) && !(description instanceof Nothing) && !(description instanceof ObjectAllRestriction && description.getChild(0) instanceof Nothing)) {
    int topRefLength=maxLength - description.getLength() - 1;
    if (currDomain instanceof Thing) {
      if (topRefLength > topRefinementsLength)       computeTopRefinements(topRefLength);
    }
 else     if (topRefLength > topARefinementsLength.get(currDomain))     computeTopRefinements(topRefLength,(NamedClass)currDomain);
    if (topRefLength > 0) {
      Set<Description> topRefs;
      if (currDomain instanceof Thing)       topRefs=topRefinementsCumulative.get(topRefLength);
 else       topRefs=topARefinementsCumulative.get(currDomain).get(topRefLength);
      for (      Description c : topRefs) {
        boolean skip=false;
        if (applyAllFilter) {
          if (c instanceof ObjectAllRestriction) {
            for (            Description child : description.getChildren()) {
              if (child instanceof ObjectAllRestriction) {
                ObjectPropertyExpression r1=((ObjectAllRestriction)c).getRole();
                ObjectPropertyExpression r2=((ObjectAllRestriction)child).getRole();
                if (r1.toString().equals(r2.toString()))                 skip=true;
              }
            }
          }
        }
        if (disjointChecks && c instanceof NamedClass && description instanceof NamedClass&& isDisjoint(description,c)) {
          skip=true;
        }
        if (!skip) {
          Intersection mc=new Intersection();
          mc.addChild(description);
          mc.addChild(c);
          ConceptTransformation.cleanConceptNonRecursive(mc);
          ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc,conceptComparator);
          if (checkIntersection(mc))           refinements.add(mc);
        }
      }
    }
  }
  return refinements;
}","@SuppressWarnings({""String_Node_Str""}) public Set<Description> refine(Description description,int maxLength,List<Description> knownRefinements,Description currDomain){
  if (!(currDomain instanceof Thing) && !topARefinementsLength.containsKey(currDomain))   topARefinementsLength.put((NamedClass)currDomain,0);
  Set<Description> refinements=new TreeSet<Description>(conceptComparator);
  Set<Description> tmp=new HashSet<Description>();
  if (description instanceof Thing) {
    if (currDomain instanceof Thing) {
      if (maxLength > topRefinementsLength)       computeTopRefinements(maxLength);
      refinements=(TreeSet<Description>)topRefinementsCumulative.get(maxLength).clone();
    }
 else {
      if (maxLength > topARefinementsLength.get(currDomain)) {
        computeTopRefinements(maxLength,(NamedClass)currDomain);
      }
      refinements=(TreeSet<Description>)topARefinementsCumulative.get(currDomain).get(maxLength).clone();
    }
  }
 else   if (description instanceof Nothing) {
  }
 else   if (description instanceof NamedClass) {
    refinements.addAll(subHierarchy.getSubClasses(description));
    refinements.remove(new Nothing());
  }
 else   if (description instanceof Negation && description.getChild(0) instanceof NamedClass) {
    tmp=subHierarchy.getSuperClasses(description.getChild(0));
    for (    Description c : tmp) {
      if (!(c instanceof Thing))       refinements.add(new Negation(c));
    }
  }
 else   if (description instanceof Intersection) {
    for (    Description child : description.getChildren()) {
      tmp=refine(child,maxLength - description.getLength() + child.getLength(),null,currDomain);
      for (      Description c : tmp) {
        List<Description> newChildren=(List<Description>)((LinkedList<Description>)description.getChildren()).clone();
        newChildren.add(c);
        newChildren.remove(child);
        Intersection mc=new Intersection(newChildren);
        ConceptTransformation.cleanConceptNonRecursive(mc);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc,conceptComparator);
        if (checkIntersection(mc))         refinements.add(mc);
      }
    }
  }
 else   if (description instanceof Union) {
    for (    Description child : description.getChildren()) {
      tmp=refine(child,maxLength - description.getLength() + child.getLength(),null,currDomain);
      for (      Description c : tmp) {
        List<Description> newChildren=new LinkedList<Description>(description.getChildren());
        newChildren.remove(child);
        newChildren.add(c);
        Union md=new Union(newChildren);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(md,conceptComparator);
        refinements.add(md);
      }
    }
    if (dropDisjuncts) {
      if (description.getChildren().size() == 2) {
        refinements.add(description.getChild(0));
        refinements.add(description.getChild(1));
      }
 else {
        for (int i=0; i < description.getChildren().size(); i++) {
          List<Description> newChildren=new LinkedList<Description>(description.getChildren());
          newChildren.remove(i);
          Union md=new Union(newChildren);
          refinements.add(md);
        }
      }
    }
  }
 else   if (description instanceof ObjectSomeRestriction) {
    ObjectPropertyExpression role=((ObjectQuantorRestriction)description).getRole();
    Description range=opRanges.get(role);
    tmp=refine(description.getChild(0),maxLength - 2,null,range);
    for (    Description c : tmp)     refinements.add(new ObjectSomeRestriction(((ObjectQuantorRestriction)description).getRole(),c));
    ObjectProperty ar=(ObjectProperty)role;
    Set<ObjectProperty> moreSpecialRoles=reasoner.getSubProperties(ar);
    for (    ObjectProperty moreSpecialRole : moreSpecialRoles)     refinements.add(new ObjectSomeRestriction(moreSpecialRole,description.getChild(0)));
    if (useCardinalityRestrictions) {
      if (maxLength > description.getLength() && maxNrOfFillers.get(ar) > 1) {
        ObjectMinCardinalityRestriction min=new ObjectMinCardinalityRestriction(2,role,description.getChild(0));
        refinements.add(min);
      }
    }
    if (useHasValueConstructor && description.getChild(0) instanceof Thing) {
      Set<Individual> frequentInds=frequentValues.get(role);
      if (frequentInds != null) {
        for (        Individual ind : frequentInds) {
          ObjectValueRestriction ovr=new ObjectValueRestriction((ObjectProperty)role,ind);
          refinements.add(ovr);
        }
      }
    }
  }
 else   if (description instanceof ObjectAllRestriction) {
    ObjectPropertyExpression role=((ObjectQuantorRestriction)description).getRole();
    Description range=opRanges.get(role);
    tmp=refine(description.getChild(0),maxLength - 2,null,range);
    for (    Description c : tmp) {
      refinements.add(new ObjectAllRestriction(((ObjectQuantorRestriction)description).getRole(),c));
    }
    if (description.getChild(0) instanceof NamedClass && tmp.size() == 0) {
      refinements.add(new ObjectAllRestriction(((ObjectQuantorRestriction)description).getRole(),new Nothing()));
    }
    ObjectProperty ar=(ObjectProperty)role;
    Set<ObjectProperty> moreSpecialRoles=reasoner.getSubProperties(ar);
    for (    ObjectProperty moreSpecialRole : moreSpecialRoles) {
      refinements.add(new ObjectAllRestriction(moreSpecialRole,description.getChild(0)));
    }
  }
 else   if (description instanceof ObjectCardinalityRestriction) {
    ObjectPropertyExpression role=((ObjectCardinalityRestriction)description).getRole();
    Description range=opRanges.get(role);
    int number=((ObjectCardinalityRestriction)description).getCardinality();
    if (description instanceof ObjectMaxCardinalityRestriction) {
      if (useNegation || number > 0) {
        tmp=refine(description.getChild(0),maxLength - 3,null,range);
        for (        Description d : tmp) {
          refinements.add(new ObjectMaxCardinalityRestriction(number,role,d));
        }
      }
      ObjectMaxCardinalityRestriction max=(ObjectMaxCardinalityRestriction)description;
      if (number > 1)       refinements.add(new ObjectMaxCardinalityRestriction(number - 1,max.getRole(),max.getChild(0)));
    }
 else     if (description instanceof ObjectMinCardinalityRestriction) {
      tmp=refine(description.getChild(0),maxLength - 3,null,range);
      for (      Description d : tmp) {
        refinements.add(new ObjectMinCardinalityRestriction(number,role,d));
      }
      ObjectMinCardinalityRestriction min=(ObjectMinCardinalityRestriction)description;
      if (number < maxNrOfFillers.get(min.getRole()))       refinements.add(new ObjectMinCardinalityRestriction(number + 1,min.getRole(),min.getChild(0)));
    }
  }
 else   if (description instanceof DatatypeSomeRestriction) {
    DatatypeSomeRestriction dsr=(DatatypeSomeRestriction)description;
    DatatypeProperty dp=(DatatypeProperty)dsr.getRestrictedPropertyExpression();
    DataRange dr=dsr.getDataRange();
    if (dr instanceof DoubleMaxValue) {
      double value=((DoubleMaxValue)dr).getValue();
      int splitIndex=splits.get(dp).lastIndexOf(value);
      if (splitIndex == -1)       throw new Error(""String_Node_Str"");
      int newSplitIndex=splitIndex - 1;
      if (newSplitIndex >= 0) {
        DoubleMaxValue max=new DoubleMaxValue(splits.get(dp).get(newSplitIndex));
        DatatypeSomeRestriction newDSR=new DatatypeSomeRestriction(dp,max);
        refinements.add(newDSR);
      }
    }
 else     if (dr instanceof DoubleMinValue) {
      double value=((DoubleMinValue)dr).getValue();
      int splitIndex=splits.get(dp).lastIndexOf(value);
      if (splitIndex == -1)       throw new Error(""String_Node_Str"");
      int newSplitIndex=splitIndex + 1;
      if (newSplitIndex < splits.get(dp).size()) {
        DoubleMinValue min=new DoubleMinValue(splits.get(dp).get(newSplitIndex));
        DatatypeSomeRestriction newDSR=new DatatypeSomeRestriction(dp,min);
        refinements.add(newDSR);
      }
    }
  }
 else   if (description instanceof StringValueRestriction) {
    StringValueRestriction svr=(StringValueRestriction)description;
    DatatypeProperty dp=svr.getRestrictedPropertyExpression();
    Set<DatatypeProperty> subDPs=reasoner.getSubProperties(dp);
    for (    DatatypeProperty subDP : subDPs) {
      refinements.add(new StringValueRestriction(subDP,svr.getStringValue()));
    }
  }
  if (!(description instanceof Thing) && !(description instanceof Nothing) && !(description instanceof ObjectAllRestriction && description.getChild(0) instanceof Nothing)) {
    int topRefLength=maxLength - description.getLength() - 1;
    if (currDomain instanceof Thing) {
      if (topRefLength > topRefinementsLength)       computeTopRefinements(topRefLength);
    }
 else     if (topRefLength > topARefinementsLength.get(currDomain))     computeTopRefinements(topRefLength,(NamedClass)currDomain);
    if (topRefLength > 0) {
      Set<Description> topRefs;
      if (currDomain instanceof Thing)       topRefs=topRefinementsCumulative.get(topRefLength);
 else       topRefs=topARefinementsCumulative.get(currDomain).get(topRefLength);
      for (      Description c : topRefs) {
        boolean skip=false;
        if (applyAllFilter) {
          if (c instanceof ObjectAllRestriction) {
            for (            Description child : description.getChildren()) {
              if (child instanceof ObjectAllRestriction) {
                ObjectPropertyExpression r1=((ObjectAllRestriction)c).getRole();
                ObjectPropertyExpression r2=((ObjectAllRestriction)child).getRole();
                if (r1.toString().equals(r2.toString()))                 skip=true;
              }
            }
          }
        }
        if (disjointChecks && c instanceof NamedClass && description instanceof NamedClass&& isDisjoint(description,c)) {
          skip=true;
        }
        if (!skip) {
          Intersection mc=new Intersection();
          mc.addChild(description);
          mc.addChild(c);
          ConceptTransformation.cleanConceptNonRecursive(mc);
          ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc,conceptComparator);
          if (checkIntersection(mc))           refinements.add(mc);
        }
      }
    }
  }
  return refinements;
}"
9478,"public Set<Entity> getCandidates(Annotation annotation){
  System.out.println(annotation);
  return candidatesTrie.getCandidateEntities(annotation.getMatchedString());
}","public Set<Entity> getCandidates(Annotation annotation){
  return candidatesTrie.getCandidateEntities(annotation.getMatchedString());
}"
9479,"public void addEntry(String s,Entity e,String originalString){
  FullTokenEntitySetPair candidates;
  if (trie.contains(s))   candidates=trie.get(s);
 else   candidates=new FullTokenEntitySetPair(originalString);
  candidates.addEntity(e);
  trie.put(s,candidates);
}","public void addEntry(String s,Entity e,String originalString){
  s=s.trim();
  FullTokenEntitySetPair candidates;
  if (trie.contains(s))   candidates=trie.get(s);
 else   candidates=new FullTokenEntitySetPair(originalString);
  candidates.addEntity(e);
  trie.put(s,candidates);
}"
9480,"public void buildTrie(OWLOntology ontology,NameGenerator nameGenerator){
  this.trie=new PrefixTrie<FullTokenEntitySetPair>();
  Map<Entity,Set<String>> relevantText=entityTextRetriever.getRelevantText(ontology);
  for (  Entity entity : relevantText.keySet()) {
    for (    String text : relevantText.get(entity)) {
      text=StringUtils.join(LinguisticUtil.getInstance().getWordsFromCamelCase(text),""String_Node_Str"");
      text=StringUtils.join(LinguisticUtil.getInstance().getWordsFromUnderscored(text),""String_Node_Str"");
      if (text.trim().isEmpty()) {
        continue;
      }
      text=text.trim();
      addEntry(text,entity);
      addSubsequencesWordNet(entity,text);
      for (      String alternativeText : nameGenerator.getAlternativeText(text)) {
        addEntry(alternativeText.toLowerCase(),entity,text);
      }
    }
  }
}","public void buildTrie(OWLOntology ontology,NameGenerator nameGenerator){
  this.trie=new PrefixTrie<FullTokenEntitySetPair>();
  Map<Entity,Set<String>> relevantText=entityTextRetriever.getRelevantText(ontology);
  for (  Entity entity : relevantText.keySet()) {
    for (    String text : relevantText.get(entity)) {
      text=StringUtils.join(LinguisticUtil.getInstance().getWordsFromCamelCase(text),""String_Node_Str"");
      text=StringUtils.join(LinguisticUtil.getInstance().getWordsFromUnderscored(text),""String_Node_Str"");
      if (text.trim().isEmpty()) {
        continue;
      }
      addEntry(text,entity);
      addSubsequencesWordNet(entity,text);
      for (      String alternativeText : nameGenerator.getAlternativeText(text)) {
        addEntry(alternativeText.toLowerCase(),entity,text);
      }
    }
  }
}"
9481,"@Override public SemanticAnnotation disambiguate(Annotation annotation,Set<Entity> candidateEntities){
  if (!candidateEntities.isEmpty()) {
    List<String> tokenContext=contextExtractor.extractContext(annotation);
    double maxScore=Double.MIN_VALUE;
    Entity bestEntity=null;
    for (    Entity entity : candidateEntities) {
      Set<String> entityContext=StructuralEntityContext.getContextInNaturalLanguage(ontology,entity);
      double score=computeScore(tokenContext,entityContext);
      if (score > maxScore) {
        maxScore=score;
        bestEntity=entity;
      }
    }
    return new SemanticAnnotation(annotation,bestEntity);
  }
  return null;
}","@Override public SemanticAnnotation disambiguate(Annotation annotation,Set<Entity> candidateEntities){
  if (!candidateEntities.isEmpty()) {
    List<String> tokenContext=contextExtractor.extractContext(annotation);
    double maxScore=Double.NEGATIVE_INFINITY;
    Entity bestEntity=null;
    for (    Entity entity : candidateEntities) {
      Set<String> entityContext=StructuralEntityContext.getContextInNaturalLanguage(ontology,entity);
      double score=computeScore(tokenContext,entityContext);
      if (score > maxScore) {
        maxScore=score;
        bestEntity=entity;
      }
    }
    return new SemanticAnnotation(annotation,bestEntity);
  }
  return null;
}"
9482,"public Set<Entity> getCandidates(Annotation annotation){
  return candidatesTrie.getCandidateEntities(annotation.getMatchedString());
}","public Set<Entity> getCandidates(Annotation annotation){
  System.out.println(annotation);
  return candidatesTrie.getCandidateEntities(annotation.getMatchedString());
}"
9483,"/** 
 * Returns for each entity in the ontology all relevant text, i.e. eitherthe annotations or the short form of the IRI as fallback.
 * @return
 */
@Override public Map<Entity,Set<String>> getRelevantText(OWLOntology ontology){
  Map<Entity,Set<String>> entity2RelevantText=new HashMap<Entity,Set<String>>();
  Set<OWLEntity> schemaEntities=new HashSet<OWLEntity>();
  schemaEntities.addAll(ontology.getClassesInSignature());
  schemaEntities.addAll(ontology.getObjectPropertiesInSignature());
  schemaEntities.addAll(ontology.getDataPropertiesInSignature());
  schemaEntities.remove(OWL_THING);
  Map<String,Double> relevantText;
  for (  OWLEntity owlEntity : schemaEntities) {
    Entity entity=OWLAPIConverter.getEntity(owlEntity);
    relevantText=getRelevantText(entity);
    entity2RelevantText.put(entity,relevantText.keySet());
  }
  return entity2RelevantText;
}","/** 
 * Returns for each entity in the ontology all relevant text, i.e. either the annotations or the short form of the IRI as fallback.
 * @return
 */
@Override public Map<Entity,Set<String>> getRelevantText(OWLOntology ontology){
  Map<Entity,Set<String>> entity2RelevantText=new HashMap<Entity,Set<String>>();
  Set<OWLEntity> schemaEntities=new HashSet<OWLEntity>();
  schemaEntities.addAll(ontology.getClassesInSignature());
  schemaEntities.addAll(ontology.getObjectPropertiesInSignature());
  schemaEntities.addAll(ontology.getDataPropertiesInSignature());
  schemaEntities.remove(OWL_THING);
  Map<String,Double> relevantText;
  for (  OWLEntity owlEntity : schemaEntities) {
    Entity entity=OWLAPIConverter.getEntity(owlEntity);
    relevantText=getRelevantText(entity);
    entity2RelevantText.put(entity,relevantText.keySet());
  }
  return entity2RelevantText;
}"
9484,"public double getNodeScore(OENode node){
  double score=node.getAccuracy();
  if (!node.isRoot()) {
    double parentAccuracy=node.getParent().getAccuracy();
    score+=(parentAccuracy - score) * gainBonusFactor;
  }
 else {
    score+=startNodeBonus;
  }
  score-=node.getHorizontalExpansion() * expansionPenaltyFactor;
  score-=node.getRefinementCount() * nodeRefinementPenalty;
  Description expression=node.getExpression();
  System.out.println(expression);
  Set<Entity> entities=expression.getSignature();
  double sum=0;
  for (  Entity entity : entities) {
    double relevance=entityRelevance.containsKey(entity) ? entityRelevance.get(entity) : 0;
    System.out.println(entity + ""String_Node_Str"" + relevance);
    if (!Double.isInfinite(relevance)) {
      sum+=relevance;
    }
  }
  score+=nlpBonusFactor * sum;
  return score;
}","public double getNodeScore(OENode node){
  double score=node.getAccuracy();
  if (!node.isRoot()) {
    double parentAccuracy=node.getParent().getAccuracy();
    score+=(parentAccuracy - score) * gainBonusFactor;
  }
 else {
    score+=startNodeBonus;
  }
  score-=node.getHorizontalExpansion() * expansionPenaltyFactor;
  score-=node.getRefinementCount() * nodeRefinementPenalty;
  Description expression=node.getExpression();
  Set<Entity> entities=expression.getSignature();
  double sum=0;
  for (  Entity entity : entities) {
    double relevance=entityRelevance.containsKey(entity) ? entityRelevance.get(entity) : 0;
    if (!Double.isInfinite(relevance)) {
      sum+=relevance;
    }
  }
  score+=nlpBonusFactor * sum;
  return score;
}"
9485,"@Override public SemanticAnnotation disambiguate(Annotation annotation,Set<Entity> candidateEntities){
  String token=annotation.getToken();
  for (  Entity entity : candidateEntities) {
    Set<String> labels=getLabels(entity);
    for (    String label : labels) {
      if (label.equals(token)) {
        return new SemanticAnnotation(annotation,entity);
      }
    }
    String shortForm=sfp.getShortForm(IRI.create(entity.getURI()));
    if (annotation.equals(shortForm)) {
      return new SemanticAnnotation(annotation,entity);
    }
  }
  return null;
}","@Override public SemanticAnnotation disambiguate(Annotation annotation,Set<Entity> candidateEntities){
  logger.debug(""String_Node_Str"" + annotation);
  logger.debug(""String_Node_Str"" + candidateEntities);
  String token=annotation.getToken().trim();
  for (  Entity entity : candidateEntities) {
    Set<String> labels=getLabels(entity);
    for (    String label : labels) {
      if (label.equals(token)) {
        logger.debug(""String_Node_Str"" + entity);
        return new SemanticAnnotation(annotation,entity);
      }
    }
    String shortForm=sfp.getShortForm(IRI.create(entity.getURI()));
    if (annotation.equals(shortForm)) {
      logger.debug(""String_Node_Str"" + entity);
      return new SemanticAnnotation(annotation,entity);
    }
  }
  return null;
}"
9486,"/** 
 * Returns the total number of documents contained in the index.
 * @return the total number of documents contained in the index
 */
public int getSize(){
  return index.size();
}","/** 
 * Returns the total number of documents contained in the index.
 * @return the total number of documents contained in the index
 */
public int getSize(){
  return size;
}"
9487,"/** 
 * Initializes the semantic index to use   {@code ontology} for finding all labels of an entity and{@code syntacticIndex} to query for documents containing these labels.
 * @param ontology       ontology to retrieve entity labels from
 * @param syntacticIndex index to query for documents containing the labels
 */
public SimpleSemanticIndex(OWLOntology ontology,SyntacticIndex syntacticIndex){
  super(ontology);
  SimpleEntityCandidatesTrie trie=new SimpleEntityCandidatesTrie(new RDFSLabelEntityTextRetriever(ontology),ontology);
  trie.printTrie();
  setSemanticAnnotator(new SemanticAnnotator(new SimpleWordSenseDisambiguation(ontology),new TrieEntityCandidateGenerator(ontology,trie),new TrieLinguisticAnnotator(trie)));
}","/** 
 * Initializes the semantic index to use   {@code ontology} for finding all labels of an entity and{@code syntacticIndex} to query for documents containing these labels.
 * @param ontology       ontology to retrieve entity labels from
 * @param syntacticIndex index to query for documents containing the labels
 */
public SimpleSemanticIndex(OWLOntology ontology,SyntacticIndex syntacticIndex){
  super(ontology);
  SimpleEntityCandidatesTrie trie=new SimpleEntityCandidatesTrie(new RDFSLabelEntityTextRetriever(ontology),ontology);
  setSemanticAnnotator(new SemanticAnnotator(new SimpleWordSenseDisambiguation(ontology),new TrieEntityCandidateGenerator(ontology,trie),new TrieLinguisticAnnotator(trie)));
}"
9488,"@Override public double getNormalizedRelevance(Entity entityA,Entity entityB){
  Set<AnnotatedDocument> documentsA=index.getDocuments(entityA);
  Set<AnnotatedDocument> documentsB=index.getDocuments(entityB);
  Set<AnnotatedDocument> documentsAB=Sets.intersection(documentsA,documentsB);
  int nrOfDocuments=index.getSize();
  double pA=nrOfDocuments == 0 ? 0 : ((double)documentsA.size() / (double)nrOfDocuments);
  double pB=nrOfDocuments == 0 ? 0 : ((double)documentsB.size() / (double)nrOfDocuments);
  double pAB=nrOfDocuments == 0 ? 0 : ((double)documentsAB.size() / (double)nrOfDocuments);
  if (pA * pB == 0) {
    return 0;
  }
  double pmi=Math.log(pAB / pA * pB);
  double normalizedPMI=(pmi / -Math.log(pAB) + 1) / 2;
  return normalizedPMI;
}","@Override public double getNormalizedRelevance(Entity entityA,Entity entityB){
  Set<AnnotatedDocument> documentsA=index.getDocuments(entityA);
  Set<AnnotatedDocument> documentsB=index.getDocuments(entityB);
  Set<AnnotatedDocument> documentsAB=Sets.intersection(documentsA,documentsB);
  int nrOfDocuments=index.getSize();
  double pA=nrOfDocuments == 0 ? 0 : ((double)documentsA.size() / (double)nrOfDocuments);
  double pB=nrOfDocuments == 0 ? 0 : ((double)documentsB.size() / (double)nrOfDocuments);
  double pAB=nrOfDocuments == 0 ? 0 : ((double)documentsAB.size() / (double)nrOfDocuments);
  if (pAB == 0 || pA * pB == 0) {
    return 0;
  }
  double pmi=Math.log(pAB / (pA * pB));
  double denominator=-Math.log(pAB);
  if (denominator == 0) {
    return 0;
  }
  double normalizedPMI=(pmi / denominator + 1) / 2;
  return normalizedPMI;
}"
9489,"public static Map<Entity,Double> getRelevantEntities(Entity entity,OWLOntology ontology,RelevanceMetric metric){
  Map<Entity,Double> relevantEntities=new HashMap<Entity,Double>();
  Set<OWLEntity> owlEntities=new HashSet<OWLEntity>();
  owlEntities.addAll(ontology.getClassesInSignature());
  owlEntities.addAll(ontology.getDataPropertiesInSignature());
  owlEntities.addAll(ontology.getObjectPropertiesInSignature());
  Set<Entity> otherEntities=OWLAPIConverter.getEntities(owlEntities);
  for (  Entity otherEntity : otherEntities) {
    double relevance=metric.getNormalizedRelevance(entity,otherEntity);
    relevantEntities.put(otherEntity,relevance);
  }
  return relevantEntities;
}","public static Map<Entity,Double> getRelevantEntities(Entity entity,OWLOntology ontology,RelevanceMetric metric){
  System.out.println(entity);
  Map<Entity,Double> relevantEntities=new HashMap<Entity,Double>();
  Set<OWLEntity> owlEntities=new HashSet<OWLEntity>();
  owlEntities.addAll(ontology.getClassesInSignature());
  owlEntities.addAll(ontology.getDataPropertiesInSignature());
  owlEntities.addAll(ontology.getObjectPropertiesInSignature());
  Set<Entity> otherEntities=OWLAPIConverter.getEntities(owlEntities);
  otherEntities.remove(entity);
  for (  Entity otherEntity : otherEntities) {
    double relevance=metric.getNormalizedRelevance(entity,otherEntity);
    System.out.println(otherEntity + ""String_Node_Str"" + relevance);
    relevantEntities.put(otherEntity,relevance);
  }
  return relevantEntities;
}"
9490,"/** 
 * Returns the normalized form of the given word. If the word contains spaces, each part separated by spaces is normalized independently and joined afterwards. If there is an error normalizing the given word, the word itself is returned.
 * @param word the word to get normalized form for
 * @return normalized form of the word or the word itself on an error
 */
public String getNormalizedForm(String word){
  StringBuilder res=new StringBuilder();
  boolean first=true;
  ArrayList<String> singleWords=new ArrayList<String>();
  Collections.addAll(singleWords,word.trim().split(""String_Node_Str""));
  for (  String w : singleWords) {
    try {
      if (first) {
        first=false;
      }
 else {
        res.append(""String_Node_Str"");
      }
      res.append(lemmatizeSingleWord(word));
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  return res.toString();
}","/** 
 * Returns the normalized form of the given word. If the word contains spaces, each part separated by spaces is normalized independently and joined afterwards. If there is an error normalizing the given word, the word itself is returned.
 * @param word the word to get normalized form for
 * @return normalized form of the word or the word itself on an error
 */
public String getNormalizedForm(String word){
  StringBuilder res=new StringBuilder();
  boolean first=true;
  ArrayList<String> singleWords=new ArrayList<String>();
  Collections.addAll(singleWords,word.trim().split(""String_Node_Str""));
  for (  String w : singleWords) {
    try {
      if (first) {
        first=false;
      }
 else {
        res.append(""String_Node_Str"");
      }
      res.append(lemmatizeSingleWord(w));
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  return res.toString();
}"
9491,"@Override public Set<Entity> getCandidateEntities(String s){
  return trie.get(s);
}","@Override public Set<Entity> getCandidateEntities(String s){
  Set<Entity> res=trie.get(s);
  return res == null ? new HashSet<Entity>() : trie.get(s);
}"
9492,"@Override public Set<Annotation> annotate(Document document){
  String s=document.getRawContent();
  Set<Annotation> annotations=new HashSet<Annotation>();
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher matcher=pattern.matcher(s);
  while (matcher.find()) {
    annotations.add(new Annotation(document,matcher.start(),matcher.end() - matcher.start()));
  }
  return annotations;
}","@Override public Set<Annotation> annotate(Document document){
  String s=document.getRawContent().trim();
  Set<Annotation> annotations=new HashSet<Annotation>();
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher matcher=pattern.matcher(s);
  int start=0;
  while (matcher.find()) {
    int end=matcher.start();
    annotations.add(new Annotation(document,start,end - start));
    start=matcher.end();
  }
  if (start < s.length() - 1) {
    annotations.add(new Annotation(document,start,s.length() - start));
  }
  return annotations;
}"
9493,"/** 
 * Returns the set of annotated documents which reference the given entity using one of its surface forms.
 * @param entity entity to retrieve documents
 * @return documents referencing given entity
 */
public Set<AnnotatedDocument> getDocuments(Entity entity){
  Set<AnnotatedDocument> annotatedDocuments=index.get(entity);
  return annotatedDocuments;
}","/** 
 * Returns the set of annotated documents which reference the given entity using one of its surface forms.
 * @param entity entity to retrieve documents
 * @return documents referencing given entity
 */
public Set<AnnotatedDocument> getDocuments(Entity entity){
  if (index == null) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  Set<AnnotatedDocument> annotatedDocuments=index.get(entity);
  return annotatedDocuments;
}"
9494,"/** 
 * Precompute the whole index, i.e. iterate over all entities and compute all annotated documents.
 */
public void buildIndex(Set<TextDocument> documents){
  for (  TextDocument document : documents) {
    AnnotatedDocument annotatedDocument=semanticAnnotator.processDocument(document);
    for (    Entity entity : annotatedDocument.getContainedEntities()) {
      Set<AnnotatedDocument> existingAnnotatedDocuments=index.get(entity);
      if (existingAnnotatedDocuments == null) {
        existingAnnotatedDocuments=new HashSet<AnnotatedDocument>();
        index.put(entity,existingAnnotatedDocuments);
      }
      existingAnnotatedDocuments.add(annotatedDocument);
    }
  }
}","public void buildIndex(OWLAnnotationProperty annotationProperty,String language){
  Set<OWLEntity> schemaEntities=new HashSet<OWLEntity>();
  schemaEntities.addAll(ontology.getClassesInSignature());
  schemaEntities.addAll(ontology.getObjectPropertiesInSignature());
  schemaEntities.addAll(ontology.getDataPropertiesInSignature());
  Set<TextDocument> documents=new HashSet<TextDocument>();
  for (  OWLEntity entity : schemaEntities) {
    String label=null;
    Set<OWLAnnotation> annotations=entity.getAnnotations(ontology,annotationProperty);
    for (    OWLAnnotation annotation : annotations) {
      if (annotation.getValue() instanceof OWLLiteral) {
        OWLLiteral val=(OWLLiteral)annotation.getValue();
        if (language != null) {
          if (val.hasLang(language)) {
            label=val.getLiteral();
          }
        }
 else {
          label=val.getLiteral();
        }
      }
    }
    if (label != null) {
      documents.add(new TextDocument(label));
    }
  }
  buildIndex(documents);
}"
9495,"/** 
 * Computes F-beta-Score.
 * @param recall Recall.
 * @param precision Precision.
 * @param beta Weights precision and recall. If beta is >1, then recall is more importantthan precision.
 * @return Harmonic mean of precision and recall weighted by beta.
 */
public static double getFScore(double recall,double precision,double beta){
  return (precision + recall == 0) ? 0 : ((1 + Math.sqrt(beta)) * (precision * recall) / (Math.sqrt(beta) * precision + recall));
}","/** 
 * Computes F-beta-Score.
 * @param recall Recall.
 * @param precision Precision.
 * @param beta Weights precision and recall. If beta is >1, then recall is more importantthan precision.
 * @return Harmonic mean of precision and recall weighted by beta.
 */
public static double getFScore(double recall,double precision,double beta){
  return (precision + recall == 0) ? 0 : ((1 + beta * beta) * (precision * recall) / (beta * beta * precision + recall));
}"
9496,"public OWLAxiom rename(OWLAxiom axiom){
  Map<OWLEntity,OWLEntity> renaming=new HashMap<OWLEntity,OWLEntity>();
  renamer=new OWLClassExpressionRenamer(df,renaming);
  axiom.accept(this);
  return renamedAxiom;
}","public OWLAxiom rename(OWLAxiom axiom){
  Map<OWLEntity,OWLEntity> renaming=new HashMap<OWLEntity,OWLEntity>();
  expressionRenamer=new OWLClassExpressionRenamer(df,renaming);
  axiom.accept(this);
  return renamedAxiom;
}"
9497,"public static void main(String[] args) throws Exception {
  org.apache.log4j.Logger.getRootLogger().addAppender(new ConsoleAppender(new SimpleLayout()));
  org.apache.log4j.Logger.getRootLogger().setLevel(Level.INFO);
  org.apache.log4j.Logger.getLogger(DataPropertyDomainAxiomLearner.class).setLevel(Level.INFO);
  SparqlEndpointKS ks=new SparqlEndpointKS(SparqlEndpoint.getEndpointDBpediaLiveAKSW());
  SPARQLReasoner reasoner=new SPARQLReasoner(ks);
  reasoner.prepareSubsumptionHierarchy();
  ObjectPropertyDomainAxiomLearner l=new ObjectPropertyDomainAxiomLearner(ks);
  l.setReasoner(reasoner);
  l.setPropertyToDescribe(new ObjectProperty(""String_Node_Str""));
  l.setMaxExecutionTimeInSeconds(40);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms());
}","public static void main(String[] args) throws Exception {
  org.apache.log4j.Logger.getRootLogger().addAppender(new ConsoleAppender(new SimpleLayout()));
  org.apache.log4j.Logger.getRootLogger().setLevel(Level.INFO);
  org.apache.log4j.Logger.getLogger(DataPropertyDomainAxiomLearner.class).setLevel(Level.INFO);
  SparqlEndpointKS ks=new SparqlEndpointKS(SparqlEndpoint.getEndpointDBpedia());
  SPARQLReasoner reasoner=new SPARQLReasoner(ks);
  reasoner.prepareSubsumptionHierarchy();
  ObjectPropertyDomainAxiomLearner l=new ObjectPropertyDomainAxiomLearner(ks);
  l.setReasoner(reasoner);
  l.setPropertyToDescribe(new ObjectProperty(""String_Node_Str""));
  l.setMaxExecutionTimeInSeconds(10);
  l.setForceSPARQL_1_0_Mode(true);
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(0.7));
}"
9498,"private Iterator<Triple> execTriples(){
  HttpQuery httpQuery=makeHttpQuery();
  httpQuery.setAccept(modelContentType);
  InputStream in=httpQuery.exec();
  String actualContentType=httpQuery.getContentType();
  if (actualContentType == null || actualContentType.equals(""String_Node_Str"")) {
    actualContentType=modelContentType;
  }
  Lang lang=WebContent.contentTypeToLang(actualContentType);
  if (!lang.isTriples())   throw new QueryException(""String_Node_Str"" + actualContentType + ""String_Node_Str"");
  return RiotReader.createIteratorTriples(in,lang,null);
}","private Iterator<Triple> execTriples(){
  HttpQuery httpQuery=makeHttpQuery();
  httpQuery.setAccept(modelContentType);
  InputStream in=httpQuery.exec();
  String actualContentType=httpQuery.getContentType();
  if (actualContentType == null || actualContentType.equals(""String_Node_Str"")) {
    actualContentType=modelContentType;
  }
  Lang lang=WebContent.contentTypeToLang(actualContentType);
  if (!RDFLanguages.isTriples(lang))   throw new QueryException(""String_Node_Str"" + actualContentType + ""String_Node_Str"");
  return RiotReader.createIteratorTriples(in,lang,null);
}"
9499,"private Model execModel(Model model){
  HttpQuery httpQuery=makeHttpQuery();
  httpQuery.setAccept(WebContent.contentTypeNTriples);
  InputStream in=httpQuery.exec();
  String actualContentType=httpQuery.getContentType();
  if (actualContentType == null || actualContentType.equals(""String_Node_Str"")) {
    actualContentType=modelContentType;
  }
  Lang lang=WebContent.contentTypeToLang(actualContentType);
  if (!lang.isTriples())   throw new QueryException(""String_Node_Str"" + actualContentType + ""String_Node_Str"");
  model.read(in,null,""String_Node_Str"");
  return model;
}","private Model execModel(Model model){
  HttpQuery httpQuery=makeHttpQuery();
  httpQuery.setAccept(WebContent.contentTypeNTriplesAlt);
  InputStream in=httpQuery.exec();
  String actualContentType=httpQuery.getContentType();
  if (actualContentType == null || actualContentType.equals(""String_Node_Str"")) {
    actualContentType=modelContentType;
  }
  Lang lang=WebContent.contentTypeToLang(actualContentType);
  if (!RDFLanguages.isTriples(lang))   throw new QueryException(""String_Node_Str"" + actualContentType + ""String_Node_Str"");
  model.read(in,null,""String_Node_Str"");
  return model;
}"
9500,"/** 
 * Sets the Content Type for CONSTRUCT/DESCRIBE queries provided that the format is supported
 * @param contentType
 */
public void setModelContentType(String contentType){
  Lang lang=WebContent.contentTypeToLang(contentType);
  if (lang == null)   throw new IllegalArgumentException(""String_Node_Str"" + contentType + ""String_Node_Str"");
  if (!lang.isTriples())   throw new IllegalArgumentException(""String_Node_Str"" + contentType + ""String_Node_Str"");
  modelContentType=contentType;
}","/** 
 * Sets the Content Type for CONSTRUCT/DESCRIBE queries provided that the format is supported
 * @param contentType
 */
public void setModelContentType(String contentType){
  Lang lang=WebContent.contentTypeToLang(contentType);
  if (lang == null)   throw new IllegalArgumentException(""String_Node_Str"" + contentType + ""String_Node_Str"");
  if (!RDFLanguages.isTriples(lang))   throw new IllegalArgumentException(""String_Node_Str"" + contentType + ""String_Node_Str"");
  modelContentType=contentType;
}"
9501,"@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  factory=manager.getOWLDataFactory();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  loadedOntologies=new HashSet<OWLOntology>();
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLOntologyKnowledgeSource) {
      ontology=((OWLOntologyKnowledgeSource)source).createOWLOntology(manager);
      owlAPIOntologies.add(ontology);
    }
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      Set<OWLOntology> imports=manager.getImportsClosure(ontology);
      allImports.addAll(imports);
      loadedOntologies.addAll(imports);
      classes.addAll(ontology.getClassesInSignature(true));
      owlObjectProperties.addAll(ontology.getObjectPropertiesInSignature(true));
      owlDatatypeProperties.addAll(ontology.getDataPropertiesInSignature(true));
      owlIndividuals.addAll(ontology.getIndividualsInSignature(true));
      OWLOntologyFormat format=manager.getOntologyFormat(ontology);
      if (format instanceof PrefixOWLOntologyFormat) {
        prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
        baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
        prefixes.remove(""String_Node_Str"");
      }
      for (      OWLClass owlClass : classes)       atomicConcepts.add(new NamedClass(owlClass.toStringID()));
      for (      OWLObjectProperty owlProperty : owlObjectProperties)       atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
      for (      OWLDataProperty owlProperty : owlDatatypeProperties) {
        DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
        Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
        for (        OWLDataRange range : ranges) {
          if (range.isDatatype()) {
            if (range.asOWLDatatype().isBoolean())             booleanDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isDouble())             doubleDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isInteger())             intDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isString())             stringDatatypeProperties.add(dtp);
          }
        }
        datatypeProperties.add(dtp);
      }
      for (      OWLNamedIndividual owlIndividual : owlIndividuals) {
        individuals.add(new Individual(owlIndividual.toStringID()));
      }
    }
 else {
      KB kb=((AbstractKnowledgeSource)source).toKB();
      IRI ontologyIRI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyIRI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  PelletOptions.USE_CLASSIFICATION_MONITOR=PelletOptions.MonitorType.NONE;
  Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
  pelletLogger.setLevel(Level.WARN);
  if (reasoner == null) {
    reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology);
  }
  classifier=PelletIncremantalReasonerFactory.getInstance().createReasoner(reasoner);
}","@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  factory=manager.getOWLDataFactory();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.compareTo(o2);
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  loadedOntologies=new HashSet<OWLOntology>();
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLOntologyKnowledgeSource) {
      ontology=((OWLOntologyKnowledgeSource)source).createOWLOntology(manager);
      owlAPIOntologies.add(ontology);
    }
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      Set<OWLOntology> imports=manager.getImportsClosure(ontology);
      allImports.addAll(imports);
      loadedOntologies.addAll(imports);
      classes.addAll(ontology.getClassesInSignature(true));
      owlObjectProperties.addAll(ontology.getObjectPropertiesInSignature(true));
      owlDatatypeProperties.addAll(ontology.getDataPropertiesInSignature(true));
      owlIndividuals.addAll(ontology.getIndividualsInSignature(true));
      OWLOntologyFormat format=manager.getOntologyFormat(ontology);
      if (format instanceof PrefixOWLOntologyFormat) {
        prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
        baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
        prefixes.remove(""String_Node_Str"");
      }
      for (      OWLClass owlClass : classes)       atomicConcepts.add(new NamedClass(owlClass.toStringID()));
      for (      OWLObjectProperty owlProperty : owlObjectProperties)       atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
      for (      OWLDataProperty owlProperty : owlDatatypeProperties) {
        DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
        Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
        for (        OWLDataRange range : ranges) {
          if (range.isDatatype()) {
            if (range.asOWLDatatype().isBoolean())             booleanDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isDouble())             doubleDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isInteger())             intDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isString())             stringDatatypeProperties.add(dtp);
          }
        }
        datatypeProperties.add(dtp);
      }
      for (      OWLNamedIndividual owlIndividual : owlIndividuals) {
        individuals.add(new Individual(owlIndividual.toStringID()));
      }
    }
 else {
      KB kb=((AbstractKnowledgeSource)source).toKB();
      IRI ontologyIRI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyIRI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  PelletOptions.USE_CLASSIFICATION_MONITOR=PelletOptions.MonitorType.NONE;
  Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
  pelletLogger.setLevel(Level.WARN);
  if (reasoner == null) {
    reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology);
  }
  classifier=PelletIncremantalReasonerFactory.getInstance().createReasoner(reasoner);
}"
9502,"public int compare(OWLNamedObject o1,OWLNamedObject o2){
  return o1.getIRI().compareTo(o2.getIRI());
}","public int compare(OWLNamedObject o1,OWLNamedObject o2){
  return o1.compareTo(o2);
}"
9503,"public SortedSet<Individual> getIndividuals(Description description,int limit){
  if (!(description instanceof NamedClass)) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  SortedSet<Individual> individuals=new TreeSet<Individual>();
  String query=String.format(""String_Node_Str"",((NamedClass)description).getName());
  if (limit != 0) {
    query+=""String_Node_Str"" + limit;
  }
  ResultSet rs=executeSelectQuery(query);
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    individuals.add(new Individual(qs.getResource(""String_Node_Str"").getURI()));
  }
  return individuals;
}","public SortedSet<Individual> getIndividuals(Description description,int limit){
  if (!(description instanceof NamedClass)) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  SortedSet<Individual> individuals=new TreeSet<Individual>();
  String query=String.format(""String_Node_Str"",((NamedClass)description).getName());
  if (limit != 0) {
    query+=""String_Node_Str"" + limit;
  }
  System.out.println(query);
  ResultSet rs=executeSelectQuery(query);
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    if (qs.get(""String_Node_Str"").isURIResource()) {
      individuals.add(new Individual(qs.getResource(""String_Node_Str"").getURI()));
    }
  }
  return individuals;
}"
9504,"private List<EvaluatedAxiom> buildAxioms(Map<ObjectProperty,Integer> property2Count,Set<ObjectProperty> allProperties){
  List<EvaluatedAxiom> axioms=new ArrayList<EvaluatedAxiom>();
  Integer all=property2Count.get(propertyToDescribe);
  property2Count.remove(propertyToDescribe);
  Set<ObjectProperty> completeDisjointProperties=new TreeSet<ObjectProperty>(allProperties);
  completeDisjointProperties.removeAll(property2Count.keySet());
  EvaluatedAxiom evalAxiom;
  for (  ObjectProperty p : completeDisjointProperties) {
    if (usePropertyPopularity) {
      int overlap=0;
      int pop;
      if (ks.isRemote()) {
        pop=reasoner.getPopularity(p);
      }
 else {
        Model model=((LocalModelBasedSparqlEndpointKS)ks).getModel();
        pop=model.listStatements(null,model.getProperty(p.getName()),(RDFNode)null).toSet().size();
      }
      if (pop == 0)       continue;
      double precision=accuracy(pop,overlap);
      double recall=accuracy(popularity,overlap);
      double score=1 - fMEasure(precision,recall);
      evalAxiom=new EvaluatedAxiom(new DisjointObjectPropertyAxiom(propertyToDescribe,p),new AxiomScore(score));
    }
 else {
      evalAxiom=new EvaluatedAxiom(new DisjointObjectPropertyAxiom(propertyToDescribe,p),new AxiomScore(1));
    }
    axioms.add(evalAxiom);
  }
  ObjectProperty p;
  for (  Entry<ObjectProperty,Integer> entry : sortByValues(property2Count)) {
    p=entry.getKey();
    int overlap=entry.getValue();
    int pop;
    if (ks.isRemote()) {
      pop=reasoner.getPopularity(p);
    }
 else {
      Model model=((LocalModelBasedSparqlEndpointKS)ks).getModel();
      pop=model.listStatements(null,model.getProperty(p.getName()),(RDFNode)null).toSet().size();
    }
    if (pop == 0)     continue;
    double precision=accuracy(pop,overlap);
    double recall=accuracy(popularity,overlap);
    double score=1 - fMEasure(precision,recall);
    evalAxiom=new EvaluatedAxiom(new DisjointObjectPropertyAxiom(propertyToDescribe,p),new AxiomScore(score));
  }
  property2Count.put(propertyToDescribe,all);
  return axioms;
}","private List<EvaluatedAxiom> buildAxioms(Map<ObjectProperty,Integer> property2Count,Set<ObjectProperty> allProperties){
  List<EvaluatedAxiom> axioms=new ArrayList<EvaluatedAxiom>();
  Integer all=property2Count.get(propertyToDescribe);
  property2Count.remove(propertyToDescribe);
  Set<ObjectProperty> completeDisjointProperties=new TreeSet<ObjectProperty>(allProperties);
  completeDisjointProperties.removeAll(property2Count.keySet());
  EvaluatedAxiom evalAxiom;
  for (  ObjectProperty p : completeDisjointProperties) {
    if (usePropertyPopularity) {
      int overlap=0;
      int otherPopularity;
      if (ks.isRemote()) {
        otherPopularity=reasoner.getPopularity(p);
      }
 else {
        Model model=((LocalModelBasedSparqlEndpointKS)ks).getModel();
        otherPopularity=model.listStatements(null,model.getProperty(p.getName()),(RDFNode)null).toSet().size();
      }
      if (otherPopularity == 0)       continue;
      double precision=accuracy(otherPopularity,overlap);
      double recall=accuracy(popularity,overlap);
      double score=1 - fMEasure(precision,recall);
      evalAxiom=new EvaluatedAxiom(new DisjointObjectPropertyAxiom(propertyToDescribe,p),new AxiomScore(score,score,popularity,popularity,0));
    }
 else {
      evalAxiom=new EvaluatedAxiom(new DisjointObjectPropertyAxiom(propertyToDescribe,p),new AxiomScore(1));
    }
    axioms.add(evalAxiom);
  }
  ObjectProperty p;
  for (  Entry<ObjectProperty,Integer> entry : sortByValues(property2Count)) {
    p=entry.getKey();
    int overlap=entry.getValue();
    int otherPopularity;
    if (ks.isRemote()) {
      otherPopularity=reasoner.getPopularity(p);
    }
 else {
      Model model=((LocalModelBasedSparqlEndpointKS)ks).getModel();
      otherPopularity=model.listStatements(null,model.getProperty(p.getName()),(RDFNode)null).toSet().size();
    }
    if (otherPopularity == 0)     continue;
    double precision=accuracy(otherPopularity,overlap);
    double recall=accuracy(popularity,overlap);
    double score=1 - fMEasure(precision,recall);
    evalAxiom=new EvaluatedAxiom(new DisjointObjectPropertyAxiom(propertyToDescribe,p),new AxiomScore(score,score,popularity,popularity - overlap,overlap));
  }
  property2Count.put(propertyToDescribe,all);
  return axioms;
}"
9505,"private List<EvaluatedAxiom> buildAxioms(Map<ObjectProperty,Integer> property2Count){
  List<EvaluatedAxiom> axioms=new ArrayList<EvaluatedAxiom>();
  Integer all=property2Count.get(propertyToDescribe);
  property2Count.remove(propertyToDescribe);
  EvaluatedAxiom evalAxiom;
  Set<ObjectProperty> properties;
  for (  Entry<ObjectProperty,Integer> entry : sortByValues(property2Count)) {
    properties=new HashSet<ObjectProperty>();
    properties.add(propertyToDescribe);
    properties.add(entry.getKey());
    int popularity=reasoner.getPropertyCount(entry.getKey());
    int total=Math.max(popularity,all);
    int success=entry.getValue();
    Score score=computeScore(total,success);
    evalAxiom=new EvaluatedAxiom(new EquivalentObjectPropertiesAxiom(properties),score);
    axioms.add(evalAxiom);
  }
  property2Count.put(propertyToDescribe,all);
  return axioms;
}","private List<EvaluatedAxiom> buildAxioms(Map<ObjectProperty,Integer> property2Count){
  List<EvaluatedAxiom> axioms=new ArrayList<EvaluatedAxiom>();
  Integer all=property2Count.get(propertyToDescribe);
  property2Count.remove(propertyToDescribe);
  EvaluatedAxiom evalAxiom;
  List<ObjectProperty> properties;
  for (  Entry<ObjectProperty,Integer> entry : sortByValues(property2Count)) {
    properties=new ArrayList<ObjectProperty>();
    properties.add(propertyToDescribe);
    properties.add(entry.getKey());
    int popularity=reasoner.getPropertyCount(entry.getKey());
    int total=Math.max(popularity,all);
    int success=entry.getValue();
    Score score=computeScore(total,success);
    evalAxiom=new EvaluatedAxiom(new EquivalentObjectPropertiesAxiom(properties),score);
    axioms.add(evalAxiom);
  }
  property2Count.put(propertyToDescribe,all);
  return axioms;
}"
9506,"public EquivalentObjectPropertiesAxiom(Set<ObjectProperty> equivalentProperties){
  this.equivalentProperties=equivalentProperties;
}","public EquivalentObjectPropertiesAxiom(Collection<ObjectProperty> equivalentProperties){
  this.equivalentProperties=equivalentProperties;
}"
9507,"public Set<ObjectProperty> getEquivalentProperties(){
  return equivalentProperties;
}","public Collection<ObjectProperty> getEquivalentProperties(){
  return equivalentProperties;
}"
9508,"public SPARQLReasoner(OntModel model){
  this.model=model;
  classPopularityMap=new HashMap<NamedClass,Integer>();
}","public SPARQLReasoner(OntModel model){
  this.model=model;
  classPopularityMap=new HashMap<NamedClass,Integer>();
  objectPropertyPopularityMap=new HashMap<ObjectProperty,Integer>();
}"
9509,"protected Score computeScore(int total,int success){
  double[] confidenceInterval=Heuristics.getConfidenceInterval95Wald(total,success);
  double accuracy=(confidenceInterval[0] + confidenceInterval[1]) / 2;
  double confidence=confidenceInterval[1] - confidenceInterval[0];
  return new AxiomScore(accuracy,confidence);
}","protected Score computeScore(int total,int success){
  double[] confidenceInterval=Heuristics.getConfidenceInterval95Wald(total,success);
  double accuracy=(confidenceInterval[0] + confidenceInterval[1]) / 2;
  double confidence=confidenceInterval[1] - confidenceInterval[0];
  return new AxiomScore(accuracy,confidence,total,success,total - success);
}"
9510,"public AxiomScore(double accuracy,double confidence){
  this.accuracy=accuracy;
}","public AxiomScore(double accuracy,double confidence,int totalNrOfExamples,int nrOfpositiveExamples,int nrOfnegativeExamples){
  this.accuracy=accuracy;
  this.confidence=confidence;
  this.totalNrOfExamples=totalNrOfExamples;
  this.nrOfpositiveExamples=nrOfpositiveExamples;
  this.nrOfnegativeExamples=nrOfnegativeExamples;
}"
9511,"public OWLOntology createOWLOntology(OWLOntologyManager manager){
  JenaToOwlapiConverter converter=new JenaToOwlapiConverter();
  return converter.convert(this.model,manager);
}","@Override public OWLOntology createOWLOntology(OWLOntologyManager manager){
  JenaToOwlapiConverter converter=new JenaToOwlapiConverter();
  return converter.convert(this.model,manager);
}"
9512,"private int addTypes(OntModel model){
  int changes=0;
  Set<String> dataProperties=new HashSet<String>();
  Set<String> objectProperties=new HashSet<String>();
  Set<String> classes=new HashSet<String>();
  Set<String> individuals=new HashSet<String>();
  Set<Triple> triples=model.getGraph().find(Triple.ANY).toSet();
  ExtendedIterator<OntClass> itClass=model.listNamedClasses();
  while (itClass.hasNext()) {
    classes.add(itClass.next().getURI());
  }
  ExtendedIterator<Individual> itIndividuals=model.listIndividuals();
  while (itIndividuals.hasNext()) {
    individuals.add(itIndividuals.next().getURI());
  }
  ExtendedIterator<DatatypeProperty> itDataProperties=model.listDatatypeProperties();
  while (itDataProperties.hasNext()) {
    dataProperties.add(itDataProperties.next().getURI());
  }
  ExtendedIterator<ObjectProperty> itObjectProperties=model.listObjectProperties();
  while (itObjectProperties.hasNext()) {
    objectProperties.add(itObjectProperties.next().getURI());
  }
  String sUri;
  String pUri;
  String oUri;
  for (  Triple triple : triples) {
    if (triple.getSubject().isBlank() || triple.getPredicate().isBlank() || triple.getObject().isBlank()) {
      System.out.println(triple);
      continue;
    }
    sUri=triple.getSubject().getURI();
    pUri=triple.getPredicate().getURI();
    oUri=triple.getObject().getURI();
    if (individuals.contains(sUri)) {
      log.trace(""String_Node_Str"",triple);
      if (pUri.equals(RDF.type.getURI())) {
        if (!classes.contains(oUri) && !oUri.equals(OWL.Thing.getURI())) {
          model.getResource(oUri).addProperty(RDF.type,OWL.Class);
          classes.add(oUri);
          changes++;
          log.debug(""String_Node_Str"",oUri);
        }
      }
 else       if (model.getResource(oUri).isLiteral()) {
        if (!objectProperties.contains(pUri)) {
          model.createDatatypeProperty(pUri);
          dataProperties.add(pUri);
          log.debug(""String_Node_Str"",pUri);
        }
 else {
          model.createOntProperty(pUri);
          log.info(""String_Node_Str"",pUri);
        }
        changes++;
      }
 else       if (!individuals.contains(oUri)) {
        model.getResource(oUri).addProperty(RDF.type,OWL.Thing);
        individuals.add(oUri);
        if (!dataProperties.contains(pUri)) {
          model.createObjectProperty(pUri);
          objectProperties.add(pUri);
          log.debug(""String_Node_Str"",pUri);
        }
 else {
          model.createOntProperty(pUri);
          log.info(""String_Node_Str"",pUri);
        }
        log.debug(""String_Node_Str"",oUri);
        changes++;
      }
    }
 else     if (classes.contains(sUri)) {
      log.trace(""String_Node_Str"",triple);
      if (!classes.contains(oUri)) {
        model.getResource(oUri).addProperty(RDF.type,OWL.Class);
        classes.add(oUri);
        log.debug(""String_Node_Str"",oUri);
        changes++;
      }
    }
  }
  return changes;
}","private int addTypes(OntModel model){
  int changes=0;
  Set<String> dataProperties=new HashSet<String>();
  Set<String> objectProperties=new HashSet<String>();
  Set<String> classes=new HashSet<String>();
  Set<String> individuals=new HashSet<String>();
  Set<Triple> triples=model.getGraph().find(Triple.ANY).toSet();
  ExtendedIterator<OntClass> itClass=model.listNamedClasses();
  while (itClass.hasNext()) {
    classes.add(itClass.next().getURI());
  }
  ExtendedIterator<Individual> itIndividuals=model.listIndividuals();
  while (itIndividuals.hasNext()) {
    individuals.add(itIndividuals.next().getURI());
  }
  ExtendedIterator<DatatypeProperty> itDataProperties=model.listDatatypeProperties();
  while (itDataProperties.hasNext()) {
    dataProperties.add(itDataProperties.next().getURI());
  }
  ExtendedIterator<ObjectProperty> itObjectProperties=model.listObjectProperties();
  while (itObjectProperties.hasNext()) {
    objectProperties.add(itObjectProperties.next().getURI());
  }
  String sUri;
  String pUri;
  String oUri;
  for (  Triple triple : triples) {
    if (!triple.getSubject().isURI() || !triple.getPredicate().isURI() || !triple.getObject().isURI()) {
      continue;
    }
    sUri=triple.getSubject().getURI();
    pUri=triple.getPredicate().getURI();
    oUri=triple.getObject().getURI();
    if (individuals.contains(sUri)) {
      log.trace(""String_Node_Str"",triple);
      if (pUri.equals(RDF.type.getURI())) {
        if (!classes.contains(oUri) && !oUri.equals(OWL.Thing.getURI())) {
          model.getResource(oUri).addProperty(RDF.type,OWL.Class);
          classes.add(oUri);
          changes++;
          log.debug(""String_Node_Str"",oUri);
        }
      }
 else       if (model.getResource(oUri).isLiteral()) {
        if (!objectProperties.contains(pUri)) {
          model.createDatatypeProperty(pUri);
          dataProperties.add(pUri);
          log.debug(""String_Node_Str"",pUri);
        }
 else {
          model.createOntProperty(pUri);
          log.info(""String_Node_Str"",pUri);
        }
        changes++;
      }
 else       if (!individuals.contains(oUri)) {
        model.getResource(oUri).addProperty(RDF.type,OWL.Thing);
        individuals.add(oUri);
        if (!dataProperties.contains(pUri)) {
          model.createObjectProperty(pUri);
          objectProperties.add(pUri);
          log.debug(""String_Node_Str"",pUri);
        }
 else {
          model.createOntProperty(pUri);
          log.info(""String_Node_Str"",pUri);
        }
        log.debug(""String_Node_Str"",oUri);
        changes++;
      }
    }
 else     if (classes.contains(sUri)) {
      log.trace(""String_Node_Str"",triple);
      if (!classes.contains(oUri)) {
        model.getResource(oUri).addProperty(RDF.type,OWL.Class);
        classes.add(oUri);
        log.debug(""String_Node_Str"",oUri);
        changes++;
      }
    }
  }
  return changes;
}"
9513,"public static void main(String[] args) throws Exception {
  org.apache.log4j.Logger.getRootLogger().addAppender(new ConsoleAppender(new SimpleLayout()));
  org.apache.log4j.Logger.getRootLogger().setLevel(Level.INFO);
  org.apache.log4j.Logger.getLogger(DataPropertyDomainAxiomLearner.class).setLevel(Level.INFO);
  SparqlEndpointKS ks=new SparqlEndpointKS(SparqlEndpoint.getEndpointDBpediaLiveAKSW());
  SPARQLReasoner reasoner=new SPARQLReasoner(ks);
  reasoner.prepareSubsumptionHierarchy();
  ObjectPropertyDomainAxiomLearner l=new ObjectPropertyDomainAxiomLearner(ks);
  l.setReasoner(reasoner);
  l.setPropertyToDescribe(new ObjectProperty(""String_Node_Str""));
  l.setMaxExecutionTimeInSeconds(10);
  l.addFilterNamespace(""String_Node_Str"");
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(10,0.75));
}","public static void main(String[] args) throws Exception {
  org.apache.log4j.Logger.getRootLogger().addAppender(new ConsoleAppender(new SimpleLayout()));
  org.apache.log4j.Logger.getRootLogger().setLevel(Level.INFO);
  org.apache.log4j.Logger.getLogger(DataPropertyDomainAxiomLearner.class).setLevel(Level.INFO);
  SparqlEndpointKS ks=new SparqlEndpointKS(SparqlEndpoint.getEndpointDBpediaLiveAKSW());
  SPARQLReasoner reasoner=new SPARQLReasoner(ks);
  reasoner.prepareSubsumptionHierarchy();
  ObjectPropertyDomainAxiomLearner l=new ObjectPropertyDomainAxiomLearner(ks);
  l.setReasoner(reasoner);
  l.setPropertyToDescribe(new ObjectProperty(""String_Node_Str""));
  l.setMaxExecutionTimeInSeconds(40);
  l.addFilterNamespace(""String_Node_Str"");
  l.init();
  l.start();
  System.out.println(l.getCurrentlyBestEvaluatedAxioms(10,0.3));
}"
9514,"public ObjectPropertyRangeAxiomLearner(SparqlEndpointKS ks){
  this.ks=ks;
}","public ObjectPropertyRangeAxiomLearner(SparqlEndpointKS ks){
  this.ks=ks;
  super.iterativeQueryTemplate=new ParameterizedSparqlString(""String_Node_Str"");
}"
9515,"@Override public void init() throws ComponentInitException {
  if (endpointURL == null) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (instances == null) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (recursionDepth == 0) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (ontologySchemaUrls == null) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  for (  String instance : instances) {
    model.createIndividual(instance,OWL.Thing);
  }
  Monitor monComp=MonitorFactory.start(""String_Node_Str"").start();
  Monitor monIndexer=MonitorFactory.start(""String_Node_Str"").start();
  indexer=new SchemaIndexer();
  indexer.setOntologySchemaUrls(ontologySchemaUrls);
  indexer.init();
  monIndexer.stop();
  TypeOntology typeOntology=new TypeOntology();
  Monitor monQueryingABox;
  QueryExecutor executor=new QueryExecutor();
  String queryString;
  Set<String> instancesSet=new HashSet<String>(instances);
  Set<String> alreadyQueried=new HashSet<String>();
  Monitor typizeModel;
  if (sparqlQuery == null) {
    ABoxQueryGenerator aGenerator=new ABoxQueryGenerator();
    for (int i=0; i < recursionDepth; i++) {
      if (instancesSet.isEmpty()) {
        log.warn(""String_Node_Str"" + i + ""String_Node_Str""+ instancesSet.size()+ ""String_Node_Str"");
      }
      log.info(""String_Node_Str"" + i + ""String_Node_Str""+ instancesSet.size()+ ""String_Node_Str"");
      queryString=aGenerator.createQuery(instancesSet,aboxfilter);
      System.out.println(queryString);
      log.debug(""String_Node_Str"",queryString);
      monQueryingABox=MonitorFactory.start(""String_Node_Str"");
      try {
        executor.executeQuery(queryString,endpointURL,model,defaultGraphURI);
      }
 catch (      Throwable t) {
        t.printStackTrace();
      }
      monQueryingABox.stop();
      typizeModel=MonitorFactory.start(""String_Node_Str"");
      typeOntology.addTypes(model);
      typizeModel.stop();
      alreadyQueried.addAll(instancesSet);
      instancesSet=difference(alreadyQueried,model);
    }
  }
 else {
    monQueryingABox=MonitorFactory.getTimeMonitor(""String_Node_Str"").start();
    executor.executeQuery(sparqlQuery,endpointURL,model,null);
    monQueryingABox.stop();
  }
  TBoxQueryGenerator tGenerator=new TBoxQueryGenerator();
  queryString=tGenerator.createQuery(alreadyQueried,tboxfilter);
  Monitor monQueryingTBox=MonitorFactory.start(""String_Node_Str"");
  executor.executeQuery(queryString,endpointURL,model,defaultGraphURI);
  monQueryingTBox.stop();
  Monitor monIndexing=MonitorFactory.start(""String_Node_Str"");
  Set<OntClass> classes=model.listClasses().toSet();
  for (  OntClass ontClass : classes) {
    OntModel hierarchy=indexer.getHierarchyForURI(ontClass.getURI());
    if (hierarchy != null) {
      model.add(hierarchy);
      log.debug(""String_Node_Str"",model);
    }
  }
  JenaToOwlapiConverter converter=new JenaToOwlapiConverter();
  owlOntology=converter.convert(this.model);
  monIndexing.stop();
  monComp.stop();
  log.info(""String_Node_Str"");
  log.info(JamonMonitorLogger.getStringForAllSortedByLabel());
  log.info(""String_Node_Str"");
}","@Override public void init() throws ComponentInitException {
  if (endpointURL == null) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (instances == null) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (recursionDepth == 0) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  if (ontologySchemaUrls == null) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  Monitor monComp=MonitorFactory.start(""String_Node_Str"").start();
  Monitor monIndexer=MonitorFactory.start(""String_Node_Str"").start();
  indexer=new SchemaIndexer();
  indexer.setOntologySchemaUrls(ontologySchemaUrls);
  indexer.init();
  monIndexer.stop();
  TypeOntology typeOntology=new TypeOntology();
  Monitor monQueryingABox;
  QueryExecutor executor=new QueryExecutor();
  String queryString;
  Set<String> instancesSet=new HashSet<String>(instances);
  Set<String> alreadyQueried=new HashSet<String>();
  Monitor typizeModel;
  if (sparqlQuery == null) {
    ABoxQueryGenerator aGenerator=new ABoxQueryGenerator();
    for (int i=0; i < recursionDepth; i++) {
      if (instancesSet.isEmpty()) {
        log.warn(""String_Node_Str"" + i + ""String_Node_Str""+ instancesSet.size()+ ""String_Node_Str"");
      }
      log.info(""String_Node_Str"" + i + ""String_Node_Str""+ instancesSet.size()+ ""String_Node_Str"");
      queryString=aGenerator.createQuery(instancesSet,aboxfilter);
      log.debug(""String_Node_Str"",queryString);
      monQueryingABox=MonitorFactory.start(""String_Node_Str"");
      try {
        executor.executeQuery(queryString,endpointURL,model,defaultGraphURI);
      }
 catch (      Throwable t) {
        t.printStackTrace();
      }
      monQueryingABox.stop();
      typizeModel=MonitorFactory.start(""String_Node_Str"");
      model=typeOntology.addTypetoJena(model,instances,null);
      typizeModel.stop();
      alreadyQueried.addAll(instancesSet);
      instancesSet=difference(alreadyQueried,model);
    }
  }
 else {
    monQueryingABox=MonitorFactory.getTimeMonitor(""String_Node_Str"").start();
    executor.executeQuery(sparqlQuery,endpointURL,model,null);
    monQueryingABox.stop();
  }
  TBoxQueryGenerator tGenerator=new TBoxQueryGenerator();
  queryString=tGenerator.createQuery(alreadyQueried,tboxfilter);
  Monitor monQueryingTBox=MonitorFactory.start(""String_Node_Str"");
  executor.executeQuery(queryString,endpointURL,model,defaultGraphURI);
  monQueryingTBox.stop();
  Monitor monIndexing=MonitorFactory.start(""String_Node_Str"");
  Set<OntClass> classes=model.listClasses().toSet();
  for (  OntClass ontClass : classes) {
    OntModel hierarchy=indexer.getHierarchyForURI(ontClass.getURI());
    if (hierarchy != null) {
      model.add(hierarchy);
      log.debug(""String_Node_Str"",model);
    }
  }
  JenaToOwlapiConverter converter=new JenaToOwlapiConverter();
  owlOntology=converter.convert(this.model);
  monIndexing.stop();
  monComp.stop();
  log.info(""String_Node_Str"");
  log.info(JamonMonitorLogger.getStringForAllSortedByLabel());
  log.info(""String_Node_Str"");
}"
9516,"public Set<String> difference(Set<String> alreadyQueriedIndividuals,OntModel model){
  Set<String> candidates=new HashSet<String>();
  Set<String> result=new HashSet<String>();
  for (ResIterator it=model.listSubjects(); it.hasNext(); ) {
    candidates.add(it.next().getURI());
  }
  for (NodeIterator it=model.listObjects(); it.hasNext(); ) {
    RDFNode cur=it.next();
    if (cur.isURIResource() && !cur.isAnon()) {
      candidates.add(((Resource)cur).getURI());
    }
  }
  for (  String candidate : candidates) {
    if (!alreadyQueriedIndividuals.contains(candidate)) {
      System.out.println(candidate);
      result.add(candidate);
    }
  }
  return result;
}","public Set<String> difference(Set<String> alreadyQueriedIndividuals,OntModel model){
  Set<String> candidates=new HashSet<String>();
  Set<String> result=new HashSet<String>();
  for (ResIterator it=model.listSubjects(); it.hasNext(); ) {
    candidates.add(it.next().getURI());
  }
  for (NodeIterator it=model.listObjects(); it.hasNext(); ) {
    RDFNode cur=it.next();
    if (cur.isURIResource() && !cur.isAnon()) {
      candidates.add(((Resource)cur).getURI());
    }
  }
  for (  String candidate : candidates) {
    if (!alreadyQueriedIndividuals.contains(candidate)) {
      result.add(candidate);
    }
  }
  return result;
}"
9517,"private void createElementsOfResources(ArrayList<ArrayList<Hypothesis>> hypothesenList,ArrayList<ArrayList<String>> conditionList) throws IOException {
  for (  ArrayList<Hypothesis> hl : hypothesenList) {
    for (    Hypothesis h : hl) {
      if (h.getType().contains(""String_Node_Str"") && h.getUri().contains(""String_Node_Str"")) {
        for (        ArrayList<String> cl : conditionList) {
          if (h.getVariable().equals(cl.get(0))) {
            ElementList el=new ElementList(h.getName() + ""String_Node_Str"",h.getUri(),ServerUtil.getPropertiesForGivenResource(h.getUri(),""String_Node_Str""));
            this.addElements(el);
          }
          if (h.getVariable().equals(cl.get(2))) {
            ElementList el_left=new ElementList(h.getName() + ""String_Node_Str"",h.getUri(),ServerUtil.getPropertiesForGivenResource(h.getUri(),""String_Node_Str""));
            this.addElements(el_left);
          }
        }
      }
    }
  }
}","private void createElementsOfResources(ArrayList<ArrayList<Hypothesis>> hypothesenList,ArrayList<ArrayList<String>> conditionList) throws IOException {
  for (  ArrayList<Hypothesis> hl : hypothesenList) {
    for (    Hypothesis h : hl) {
      if (h.getType().contains(""String_Node_Str"") && h.getUri().contains(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + h.getName() + ""String_Node_Str""+ h.getUri());
        for (        ArrayList<String> cl : conditionList) {
          if (h.getVariable().equals(cl.get(0))) {
            ElementList el=new ElementList(h.getName() + ""String_Node_Str"",h.getUri(),ServerUtil.getPropertiesForGivenResource(h.getUri(),""String_Node_Str""));
            this.addElements(el);
          }
          if (h.getVariable().equals(cl.get(2))) {
            ElementList el_left=new ElementList(h.getName() + ""String_Node_Str"",h.getUri(),ServerUtil.getPropertiesForGivenResource(h.getUri(),""String_Node_Str""));
            this.addElements(el_left);
          }
        }
      }
    }
  }
}"
9518,"private void createElementsOfClasses(ArrayList<ArrayList<Hypothesis>> hypothesenList) throws IOException {
  for (  ArrayList<Hypothesis> hl : hypothesenList) {
    for (    Hypothesis h : hl) {
      if (h.getType().contains(""String_Node_Str"") && h.getUri().contains(""String_Node_Str"")) {
        ElementList el=new ElementList(h.getName(),h.getUri(),ServerUtil.getElementsForGivenClass(h.getUri()));
        this.addElements(el);
      }
    }
  }
}","private void createElementsOfClasses(ArrayList<ArrayList<Hypothesis>> hypothesenList) throws IOException {
  for (  ArrayList<Hypothesis> hl : hypothesenList) {
    for (    Hypothesis h : hl) {
      if (h.getType().contains(""String_Node_Str"") && h.getUri().contains(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + h.getName() + ""String_Node_Str""+ h.getUri());
        ElementList el=new ElementList(h.getName(),h.getUri(),ServerUtil.getElementsForGivenClass(h.getUri()));
        this.addElements(el);
      }
    }
  }
}"
9519,"public ArrayList<Template> createTemplates(String question) throws IOException {
  long start=System.currentTimeMillis();
  ArrayList<Template> resultArrayList=new ArrayList<Template>();
  Set<BasicQueryTemplate> querytemps=null;
  querytemps=btemplator.buildBasicQueries(question);
  if (querytemps.contains(""String_Node_Str"") || querytemps.isEmpty()) {
    String dateiname=""String_Node_Str"";
    String result_string=""String_Node_Str"";
    try {
      BufferedReader br=new BufferedReader(new FileReader(dateiname));
      String thisLine;
      while ((thisLine=br.readLine()) != null) {
        result_string+=thisLine + ""String_Node_Str"";
      }
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"" + e);
    }
    File file=new File(dateiname);
    BufferedWriter bw=new BufferedWriter(new FileWriter(file));
    bw.write(result_string + ""String_Node_Str"" + question);
    bw.flush();
    bw.close();
  }
  long stop_template=System.currentTimeMillis();
  for (  BasicQueryTemplate bqt : querytemps) {
    long start_part1=System.currentTimeMillis();
    ArrayList<ArrayList<String>> condition=new ArrayList<ArrayList<String>>();
    String selectTerm=""String_Node_Str"";
    String having=""String_Node_Str"";
    String filter=""String_Node_Str"";
    String OrderBy=""String_Node_Str"";
    String limit=""String_Node_Str"";
    boolean addTemplate=true;
    try {
      for (      SPARQL_Term terms : bqt.getSelTerms())       selectTerm=selectTerm + (terms.toString()) + ""String_Node_Str"";
    }
 catch (    Exception e) {
      selectTerm=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      for (      Path conditions1 : bqt.getConditions()) {
        ArrayList<String> temp_array=new ArrayList<String>();
        String[] tmp_array=conditions1.toString().split(""String_Node_Str"");
        for (        String s : tmp_array) {
          temp_array.add(s);
        }
        condition.add(temp_array);
      }
    }
 catch (    Exception e) {
      addTemplate=false;
    }
    try {
      for (      SPARQL_Filter tmp : bqt.getFilters())       filter=filter + tmp + ""String_Node_Str"";
    }
 catch (    Exception e) {
      filter=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      for (      SPARQL_Having tmp : bqt.getHavings())       having=having + tmp + ""String_Node_Str"";
    }
 catch (    Exception e) {
      having=""String_Node_Str"";
      addTemplate=false;
    }
    OrderBy=""String_Node_Str"";
    try {
      for (      SPARQL_Term tmp : bqt.getOrderBy()) {
        OrderBy=OrderBy + tmp + ""String_Node_Str"";
      }
      if ((bqt.getOrderBy()).size() == 0)       OrderBy=""String_Node_Str"";
    }
 catch (    Exception e) {
      OrderBy=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      limit=""String_Node_Str"" + bqt.getLimit();
      if (bqt.getLimit() == 0)       limit=""String_Node_Str"";
    }
 catch (    Exception e) {
      limit=""String_Node_Str"";
      addTemplate=false;
    }
    long stop_part1=System.currentTimeMillis();
    if (addTemplate != false) {
      long start_part2=System.currentTimeMillis();
      Template template=new Template(condition,bqt.getQt().toString(),having,filter,selectTerm,OrderBy,limit,question);
      template.setTime_part1(stop_part1 - start_part1);
      boolean add_reverse_template=true;
      ArrayList<Hypothesis> list_of_hypothesis=new ArrayList<Hypothesis>();
      for (      Slot slot : bqt.getSlots()) {
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          boolean no_iaA_found=true;
          for (          ArrayList<String> x : condition) {
            if (x.get(1).equals(""String_Node_Str"") && x.get(2).equals(""String_Node_Str"" + tmp_array[0])) {
              no_iaA_found=false;
              Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
              list_of_hypothesis.add(tmp_hypothesis);
              add_reverse_template=false;
            }
          }
          if (no_iaA_found) {
            Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
            list_of_hypothesis.add(tmp_hypothesis);
          }
        }
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
      }
      ArrayList<ArrayList<Hypothesis>> final_list_set_hypothesis=new ArrayList<ArrayList<Hypothesis>>();
      for (      Hypothesis x : list_of_hypothesis) {
        if (x.getType().contains(""String_Node_Str"") || x.getType().contains(""String_Node_Str"") || x.getType().contains(""String_Node_Str"")) {
          ArrayList<String> result=new ArrayList<String>();
          try {
            if (x.getType().contains(""String_Node_Str"")) {
              result=Index_utils.searchIndexForClass(x.getUri(),myindex);
            }
 else {
              result=Index_utils.searchIndexForResource(x.getUri(),myindex);
            }
          }
 catch (          SQLException e) {
            e.printStackTrace();
          }
          for (          String s : result) {
            ArrayList<Hypothesis> new_list=new ArrayList<Hypothesis>();
            for (            Hypothesis h : list_of_hypothesis) {
              if (h.getUri().equals(x.getUri())) {
                if (s != null) {
                  Hypothesis new_h=new Hypothesis(h.getVariable(),h.getName(),s,h.getType(),1.0);
                  new_list.add(new_h);
                }
 else {
                  Hypothesis new_h=new Hypothesis(h.getVariable(),h.getName(),h.getUri(),h.getType(),1.0);
                  new_list.add(new_h);
                }
              }
 else {
                Hypothesis new_h=new Hypothesis(h.getVariable(),h.getName(),h.getUri(),h.getType(),h.getRank());
                new_list.add(new_h);
              }
            }
            final_list_set_hypothesis.add(new_list);
          }
        }
      }
      HashMap<String,String> hm=new HashMap<String,String>();
      for (      ArrayList<Hypothesis> x : final_list_set_hypothesis) {
        for (        Hypothesis h : x) {
          if (h.getType().contains(""String_Node_Str"")) {
            ArrayList<String> result=new ArrayList<String>();
            try {
              if (hm.containsKey(h.getUri().toLowerCase())) {
                result.add(hm.get(h.getUri().toLowerCase()));
              }
 else {
                result=Index_utils.searchIndexForProperty(h.getUri(),myindex);
                if (!result.isEmpty())                 hm.put(h.getUri().toLowerCase(),result.get(0));
              }
              if (!result.isEmpty()) {
                h.setUri(result.get(0));
                h.setRank(0.0);
              }
            }
 catch (            SQLException e) {
              e.printStackTrace();
            }
          }
        }
      }
      template.setHypothesen(final_list_set_hypothesis);
      Template template_reverse_conditions=new Template(template.getCondition(),template.getQueryType(),template.getHaving(),template.getFilter(),template.getSelectTerm(),template.getOrderBy(),template.getLimit(),template.getQuestion());
      ArrayList<ArrayList<String>> condition_template_reverse_conditions=template_reverse_conditions.getCondition();
      ArrayList<ArrayList<String>> condition_reverse_new=new ArrayList<ArrayList<String>>();
      if (add_reverse_template) {
        for (        ArrayList<String> x : condition_template_reverse_conditions) {
          ArrayList<String> new_list=new ArrayList<String>();
          new_list.add(x.get(2));
          new_list.add(x.get(1));
          new_list.add(x.get(0));
          condition_reverse_new.add(new_list);
        }
      }
      long stop=System.currentTimeMillis();
      template_reverse_conditions.setOverallTime(stop - start);
      template.setOverallTime(stop - start);
      template_reverse_conditions.setTime_Templator(stop_template - start);
      template.setTime_Templator(stop_template - start);
      template_reverse_conditions.setCondition(condition_reverse_new);
      template_reverse_conditions.setHypothesen(template.getHypothesen());
      long start_elements=System.currentTimeMillis();
      Elements elm=new Elements(template.getCondition(),template.getHypothesen());
      long stop_elements=System.currentTimeMillis();
      template.setTime_generateElements(stop_elements - start_elements);
      long stop_part2=System.currentTimeMillis();
      template.setTime_part2(stop_part2 - start_part2);
      if (elm.isElementEmty() == false) {
        template.setElm(elm);
        resultArrayList.add(template);
      }
      if (add_reverse_template) {
        start_elements=System.currentTimeMillis();
        Elements elm_reverse=new Elements(template_reverse_conditions.getCondition(),template_reverse_conditions.getHypothesen());
        stop_elements=System.currentTimeMillis();
        template_reverse_conditions.setTime_generateElements(stop_elements - start_elements);
        template_reverse_conditions.setTime_part1(stop_part1 - start_part1);
        template_reverse_conditions.setTime_part2(stop_part2 - start_part2);
        if (elm_reverse.isElementEmty() == false) {
          template_reverse_conditions.setElm(elm_reverse);
          resultArrayList.add(template_reverse_conditions);
        }
      }
    }
  }
  return resultArrayList;
}","public ArrayList<Template> createTemplates(String question) throws IOException {
  long start=System.currentTimeMillis();
  ArrayList<Template> resultArrayList=new ArrayList<Template>();
  Set<BasicQueryTemplate> querytemps=null;
  querytemps=btemplator.buildBasicQueries(question);
  if (querytemps.contains(""String_Node_Str"") || querytemps.isEmpty()) {
    String dateiname=""String_Node_Str"";
    String result_string=""String_Node_Str"";
    try {
      BufferedReader br=new BufferedReader(new FileReader(dateiname));
      String thisLine;
      while ((thisLine=br.readLine()) != null) {
        result_string+=thisLine + ""String_Node_Str"";
      }
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"" + e);
    }
    File file=new File(dateiname);
    BufferedWriter bw=new BufferedWriter(new FileWriter(file));
    bw.write(result_string + ""String_Node_Str"" + question);
    bw.flush();
    bw.close();
  }
  long stop_template=System.currentTimeMillis();
  for (  BasicQueryTemplate bqt : querytemps) {
    long start_part1=System.currentTimeMillis();
    ArrayList<ArrayList<String>> condition=new ArrayList<ArrayList<String>>();
    String selectTerm=""String_Node_Str"";
    String having=""String_Node_Str"";
    String filter=""String_Node_Str"";
    String OrderBy=""String_Node_Str"";
    String limit=""String_Node_Str"";
    boolean addTemplate=true;
    try {
      for (      SPARQL_Term terms : bqt.getSelTerms())       selectTerm=selectTerm + (terms.toString()) + ""String_Node_Str"";
    }
 catch (    Exception e) {
      selectTerm=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      for (      Path conditions1 : bqt.getConditions()) {
        ArrayList<String> temp_array=new ArrayList<String>();
        String[] tmp_array=conditions1.toString().split(""String_Node_Str"");
        for (        String s : tmp_array) {
          s=s.replace(""String_Node_Str"",""String_Node_Str"");
          temp_array.add(s);
        }
        condition.add(temp_array);
      }
    }
 catch (    Exception e) {
      addTemplate=false;
    }
    try {
      for (      SPARQL_Filter tmp : bqt.getFilters())       filter=filter + tmp + ""String_Node_Str"";
    }
 catch (    Exception e) {
      filter=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      for (      SPARQL_Having tmp : bqt.getHavings())       having=having + tmp + ""String_Node_Str"";
    }
 catch (    Exception e) {
      having=""String_Node_Str"";
      addTemplate=false;
    }
    OrderBy=""String_Node_Str"";
    try {
      for (      SPARQL_Term tmp : bqt.getOrderBy()) {
        OrderBy=OrderBy + tmp + ""String_Node_Str"";
      }
      if ((bqt.getOrderBy()).size() == 0)       OrderBy=""String_Node_Str"";
    }
 catch (    Exception e) {
      OrderBy=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      limit=""String_Node_Str"" + bqt.getLimit();
      if (bqt.getLimit() == 0)       limit=""String_Node_Str"";
    }
 catch (    Exception e) {
      limit=""String_Node_Str"";
      addTemplate=false;
    }
    long stop_part1=System.currentTimeMillis();
    if (addTemplate != false) {
      long start_part2=System.currentTimeMillis();
      Template template=new Template(condition,bqt.getQt().toString(),having,filter,selectTerm,OrderBy,limit,question);
      for (      ArrayList<String> al : condition) {
        String con_temp=""String_Node_Str"";
        for (        String s : al) {
          con_temp+=""String_Node_Str"" + s;
        }
        System.out.println(""String_Node_Str"" + con_temp);
      }
      template.setTime_part1(stop_part1 - start_part1);
      boolean add_reverse_template=true;
      ArrayList<Hypothesis> list_of_hypothesis=new ArrayList<Hypothesis>();
      for (      Slot slot : bqt.getSlots()) {
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          boolean no_iaA_found=true;
          for (          ArrayList<String> x : condition) {
            if (x.get(1).equals(""String_Node_Str"") && x.get(2).equals(""String_Node_Str"" + tmp_array[0])) {
              no_iaA_found=false;
              Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
              list_of_hypothesis.add(tmp_hypothesis);
              add_reverse_template=false;
            }
          }
          if (no_iaA_found) {
            Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
            list_of_hypothesis.add(tmp_hypothesis);
          }
        }
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
      }
      ArrayList<ArrayList<Hypothesis>> final_list_set_hypothesis=new ArrayList<ArrayList<Hypothesis>>();
      System.out.println(""String_Node_Str"");
      for (      Hypothesis x : list_of_hypothesis) {
        x.printAll();
      }
      System.out.println(""String_Node_Str"");
      for (      Hypothesis x : list_of_hypothesis) {
        if (x.getType().contains(""String_Node_Str"") || x.getType().contains(""String_Node_Str"") || x.getType().contains(""String_Node_Str"")) {
          ArrayList<String> result=new ArrayList<String>();
          try {
            if (x.getType().contains(""String_Node_Str"")) {
              result=Index_utils.searchIndexForClass(x.getUri(),myindex);
            }
 else {
              result=Index_utils.searchIndexForResource(x.getUri(),myindex);
            }
          }
 catch (          SQLException e) {
            e.printStackTrace();
          }
          for (          String s : result) {
            ArrayList<Hypothesis> new_list=new ArrayList<Hypothesis>();
            for (            Hypothesis h : list_of_hypothesis) {
              if (h.getUri().equals(x.getUri())) {
                if (s != null) {
                  Hypothesis new_h=new Hypothesis(h.getVariable(),h.getName(),s,h.getType(),1.0);
                  new_list.add(new_h);
                }
 else {
                  Hypothesis new_h=new Hypothesis(h.getVariable(),h.getName(),h.getUri(),h.getType(),1.0);
                  new_list.add(new_h);
                }
              }
 else {
                Hypothesis new_h=new Hypothesis(h.getVariable(),h.getName(),h.getUri(),h.getType(),h.getRank());
                new_list.add(new_h);
              }
            }
            final_list_set_hypothesis.add(new_list);
          }
        }
      }
      System.out.println(""String_Node_Str"");
      for (      ArrayList<Hypothesis> lh : final_list_set_hypothesis) {
        for (        Hypothesis x : lh) {
          x.printAll();
        }
      }
      System.out.println(""String_Node_Str"");
      HashMap<String,String> hm=new HashMap<String,String>();
      for (      ArrayList<Hypothesis> x : final_list_set_hypothesis) {
        for (        Hypothesis h : x) {
          if (h.getType().contains(""String_Node_Str"")) {
            ArrayList<String> result=new ArrayList<String>();
            try {
              if (hm.containsKey(h.getUri().toLowerCase())) {
                result.add(hm.get(h.getUri().toLowerCase()));
              }
 else {
                result=Index_utils.searchIndexForProperty(h.getUri(),myindex);
                if (!result.isEmpty())                 hm.put(h.getUri().toLowerCase(),result.get(0));
              }
              if (!result.isEmpty()) {
                h.setUri(result.get(0));
                h.setRank(0.0);
              }
            }
 catch (            SQLException e) {
              e.printStackTrace();
            }
          }
        }
      }
      System.out.println(""String_Node_Str"");
      for (      ArrayList<Hypothesis> lh : final_list_set_hypothesis) {
        for (        Hypothesis x : lh) {
          x.printAll();
        }
      }
      System.out.println(""String_Node_Str"");
      template.setHypothesen(final_list_set_hypothesis);
      Template template_reverse_conditions=new Template(template.getCondition(),template.getQueryType(),template.getHaving(),template.getFilter(),template.getSelectTerm(),template.getOrderBy(),template.getLimit(),template.getQuestion());
      ArrayList<ArrayList<String>> condition_template_reverse_conditions=template_reverse_conditions.getCondition();
      ArrayList<ArrayList<String>> condition_reverse_new=new ArrayList<ArrayList<String>>();
      if (add_reverse_template) {
        for (        ArrayList<String> x : condition_template_reverse_conditions) {
          ArrayList<String> new_list=new ArrayList<String>();
          new_list.add(x.get(2));
          new_list.add(x.get(1));
          new_list.add(x.get(0));
          condition_reverse_new.add(new_list);
        }
      }
      long stop=System.currentTimeMillis();
      template_reverse_conditions.setOverallTime(stop - start);
      template.setOverallTime(stop - start);
      template_reverse_conditions.setTime_Templator(stop_template - start);
      template.setTime_Templator(stop_template - start);
      template_reverse_conditions.setCondition(condition_reverse_new);
      template_reverse_conditions.setHypothesen(template.getHypothesen());
      long start_elements=System.currentTimeMillis();
      Elements elm=new Elements(template.getCondition(),template.getHypothesen());
      long stop_elements=System.currentTimeMillis();
      template.setTime_generateElements(stop_elements - start_elements);
      long stop_part2=System.currentTimeMillis();
      template.setTime_part2(stop_part2 - start_part2);
      if (elm.isElementEmty() == false) {
        template.setElm(elm);
        resultArrayList.add(template);
      }
      if (add_reverse_template) {
        start_elements=System.currentTimeMillis();
        Elements elm_reverse=new Elements(template_reverse_conditions.getCondition(),template_reverse_conditions.getHypothesen());
        stop_elements=System.currentTimeMillis();
        template_reverse_conditions.setTime_generateElements(stop_elements - start_elements);
        template_reverse_conditions.setTime_part1(stop_part1 - start_part1);
        template_reverse_conditions.setTime_part2(stop_part2 - start_part2);
        if (elm_reverse.isElementEmty() == false) {
          template_reverse_conditions.setElm(elm_reverse);
          resultArrayList.add(template_reverse_conditions);
        }
      }
    }
  }
  return resultArrayList;
}"
9520,"public static double nld(String orig,String eing){
  double result=computeLevenshteinDistance(orig,eing);
  double length=Math.max(orig.length(),eing.length());
  if (result == 0.0) {
    return 1.0;
  }
 else {
    double result_nld=result / length;
    return result_nld;
  }
}","public static double nld(String orig,String eing){
  double result=computeLevenshteinDistance(orig,eing);
  double length=Math.max(orig.length(),eing.length());
  if (result == 0.0) {
    return 1.0;
  }
 else {
    double result_nld=result / length;
    double result1=1 - result_nld;
    return result1;
  }
}"
9521,"public static void doSort(ArrayList<QueryPair> qp){
  boolean change=true;
  while (change) {
    change=false;
    for (int i=0; i < qp.size() - 1; i++) {
      if (qp.get(i).getRank() < qp.get(i + 1).getRank()) {
        change=true;
        QueryPair one=qp.get(i);
        QueryPair two=qp.get(i + 1);
        qp.set(i,two);
        qp.set(i + 1,one);
      }
    }
  }
  for (  QueryPair p : qp) {
    p.printAll();
  }
}","public static void doSort(ArrayList<QueryPair> qp){
  boolean change=true;
  while (change) {
    change=false;
    for (int i=0; i < qp.size() - 1; i++) {
      if (qp.get(i).getRank() < qp.get(i + 1).getRank()) {
        change=true;
        QueryPair one=qp.get(i);
        QueryPair two=qp.get(i + 1);
        qp.set(i,two);
        qp.set(i + 1,one);
      }
    }
  }
}"
9522,"/** 
 * Creates Queries
 * @param t
 * @return
 */
public static ArrayList<QueryPair> returnSetOfQueries(Template t,String type){
  ArrayList<QueryPair> queryList=new ArrayList<QueryPair>();
  String condition=""String_Node_Str"";
  for (  ArrayList<String> conditionList : t.getCondition()) {
    for (    String s : conditionList)     condition+=s + ""String_Node_Str"";
    condition+=""String_Node_Str"";
  }
  ArrayList<ArrayList<Hypothesis>> givenHypothesenList=new ArrayList<ArrayList<Hypothesis>>();
  if (type.contains(""String_Node_Str"")) {
    givenHypothesenList=t.getHypothesenLevensthein();
  }
 else {
    givenHypothesenList=t.getHypothesen();
  }
  for (  ArrayList<Hypothesis> hypothesenList : givenHypothesenList) {
    String condition_new=condition;
    double global_rank=0;
    boolean addQuery=true;
    for (    Hypothesis h : hypothesenList) {
      condition_new=condition_new.replace(h.getVariable(),""String_Node_Str"" + h.getUri() + ""String_Node_Str"");
      if (!h.getUri().contains(""String_Node_Str"")) {
        addQuery=false;
      }
      condition_new=condition_new.replace(""String_Node_Str"",""String_Node_Str"");
      global_rank=global_rank + h.getRank();
    }
    String query=""String_Node_Str"" + t.getQueryType() + ""String_Node_Str""+ t.getSelectTerm()+ ""String_Node_Str""+ condition_new+ ""String_Node_Str""+ t.getFilter()+ ""String_Node_Str""+ t.getOrderBy()+ ""String_Node_Str""+ t.getHaving()+ ""String_Node_Str""+ t.getLimit();
    QueryPair qp=new QueryPair(query,global_rank);
    if (addQuery)     queryList.add(qp);
  }
  return queryList;
}","/** 
 * Creates Queries
 * @param t
 * @return
 */
public static ArrayList<QueryPair> returnSetOfQueries(Template t,String type){
  ArrayList<QueryPair> queryList=new ArrayList<QueryPair>();
  String condition=""String_Node_Str"";
  for (  ArrayList<String> conditionList : t.getCondition()) {
    for (    String s : conditionList)     condition+=s + ""String_Node_Str"";
    condition+=""String_Node_Str"";
  }
  ArrayList<ArrayList<Hypothesis>> givenHypothesenList=new ArrayList<ArrayList<Hypothesis>>();
  if (type.contains(""String_Node_Str"")) {
    givenHypothesenList=t.getHypothesenLevensthein();
  }
 else   if (type.contains(""String_Node_Str"")) {
    givenHypothesenList=t.getHypothesenWordnet();
  }
 else {
    if (!type.contains(""String_Node_Str""))     System.err.println(""String_Node_Str"" + type + ""String_Node_Str"");
    givenHypothesenList=t.getHypothesen();
  }
  for (  ArrayList<Hypothesis> hypothesenList : givenHypothesenList) {
    String condition_new=condition;
    double global_rank=0;
    boolean addQuery=true;
    for (    Hypothesis h : hypothesenList) {
      condition_new=condition_new.replace(h.getVariable(),""String_Node_Str"" + h.getUri() + ""String_Node_Str"");
      if (!h.getUri().contains(""String_Node_Str"")) {
        addQuery=false;
      }
      condition_new=condition_new.replace(""String_Node_Str"",""String_Node_Str"");
      condition_new=condition_new.replace(""String_Node_Str"",""String_Node_Str"");
      global_rank=global_rank + h.getRank();
    }
    String query=""String_Node_Str"" + t.getQueryType() + ""String_Node_Str""+ t.getSelectTerm()+ ""String_Node_Str""+ condition_new+ ""String_Node_Str""+ t.getFilter()+ ""String_Node_Str""+ t.getOrderBy()+ ""String_Node_Str""+ t.getHaving()+ ""String_Node_Str""+ t.getLimit();
    QueryPair qp=new QueryPair(query,global_rank);
    if (addQuery)     queryList.add(qp);
  }
  return queryList;
}"
9523,"private static String getListOfElements(String verarbeitungsurl){
  String result=""String_Node_Str"";
  HttpURLConnection connection=null;
  BufferedReader rd=null;
  StringBuilder sb=null;
  String line=null;
  URL serverAddress=null;
  try {
    serverAddress=new URL(verarbeitungsurl);
    connection=null;
    connection=(HttpURLConnection)serverAddress.openConnection();
    connection.setRequestMethod(""String_Node_Str"");
    connection.setDoOutput(true);
    connection.setReadTimeout(getTimeToTimeoutOnServer());
    connection.connect();
    rd=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    sb=new StringBuilder();
    while ((line=rd.readLine()) != null) {
      sb.append(line + '\n');
    }
    result=sb.toString();
  }
 catch (  MalformedURLException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  IOException e) {
    System.out.println(""String_Node_Str"");
  }
 finally {
    connection.disconnect();
    rd=null;
    sb=null;
    connection=null;
  }
  return result;
}","private static String getListOfElements(String verarbeitungsurl){
  String result=""String_Node_Str"";
  HttpURLConnection connection=null;
  BufferedReader rd=null;
  StringBuilder sb=null;
  String line=null;
  URL serverAddress=null;
  try {
    serverAddress=new URL(verarbeitungsurl);
    connection=null;
    connection=(HttpURLConnection)serverAddress.openConnection();
    connection.setRequestMethod(""String_Node_Str"");
    connection.setDoOutput(true);
    connection.setReadTimeout(getTimeToTimeoutOnServer());
    connection.connect();
    rd=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    sb=new StringBuilder();
    while ((line=rd.readLine()) != null) {
      sb.append(line + '\n');
    }
    result=sb.toString();
  }
 catch (  MalformedURLException e) {
    System.err.println(""String_Node_Str"" + verarbeitungsurl + ""String_Node_Str"");
  }
catch (  IOException e) {
    System.err.println(""String_Node_Str"");
  }
 finally {
    try {
      connection.disconnect();
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"");
    }
    rd=null;
    sb=null;
    connection=null;
  }
  return result;
}"
9524,"/** 
 * Uses an URI of a Class to get the Elements of the Class and the related URIs
 * @param classUri
 * @return
 * @throws IOException
 */
public static HashMap<String,String> getElementsForGivenClass(String classUri) throws IOException {
  String query=""String_Node_Str"" + classUri + ""String_Node_Str"";
  String result=""String_Node_Str"";
  result=getListOfElements(query);
  return generateList(result);
}","/** 
 * Uses an URI of a Class to get the Elements of the Class and the related URIs
 * @param classUri
 * @return
 * @throws IOException
 */
public static HashMap<String,String> getElementsForGivenClass(String classUri) throws IOException {
  String query=""String_Node_Str"" + classUri + ""String_Node_Str"";
  String query_final=ServerUtil.getServer_Prefix() + ""String_Node_Str"" + ServerUtil.createServerRequest(query)+ ""String_Node_Str"";
  String result=""String_Node_Str"";
  result=getListOfElements(query_final);
  return generateList(result);
}"
9525,"public static ArrayList<String> searchIndexForProperty(String string,SQLiteIndex myindex) throws SQLException {
  HashMap<String,Float> hm=new HashMap<String,Float>();
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  String result=null;
  ArrayList<String> result_List=new ArrayList<String>();
  result=myindex.getPropertyURI(string.toLowerCase());
  if (result != null) {
    result_List.add(result);
    hm.put(result,1.0f);
  }
 else {
    result_List.add(""String_Node_Str"" + string.toLowerCase().replace(""String_Node_Str"",""String_Node_Str""));
    hm.put(result,0.0f);
  }
  return result_List;
}","public static ArrayList<String> searchIndexForProperty(String string,SQLiteIndex myindex) throws SQLException {
  HashMap<String,Float> hm=new HashMap<String,Float>();
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  String result=null;
  ArrayList<String> result_List=new ArrayList<String>();
  result=myindex.getPropertyURI(string.toLowerCase());
  System.err.println(""String_Node_Str"" + result);
  if (result != null) {
    result_List.add(result);
    hm.put(result,1.0f);
    System.err.println(""String_Node_Str"" + string.toLowerCase());
  }
 else {
    System.err.println(""String_Node_Str"" + string.toLowerCase());
    result_List.add(""String_Node_Str"" + string.toLowerCase().replace(""String_Node_Str"",""String_Node_Str""));
    hm.put(result,0.0f);
  }
  System.err.println(""String_Node_Str"");
  return result_List;
}"
9526,"public String getPropertyURI(String string) throws SQLException {
  Statement stat=conn.createStatement();
  ResultSet rs;
  try {
    rs=stat.executeQuery(""String_Node_Str"" + string.toLowerCase() + ""String_Node_Str"");
    return rs.getString(""String_Node_Str"");
  }
 catch (  Exception e) {
    return null;
  }
}","public String getPropertyURI(String string) throws SQLException {
  Statement stat=conn.createStatement();
  ResultSet rs;
  ArrayList<String> al=new ArrayList<String>();
  try {
    rs=stat.executeQuery(""String_Node_Str"" + string.toLowerCase() + ""String_Node_Str"");
    while (rs.next()) {
      String result_string=rs.getString(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + result_string);
      boolean found=false;
      for (      String s : al) {
        if (s.equals(result_string))         found=true;
      }
      if (found == false)       al.add(result_string);
    }
    rs=stat.executeQuery(""String_Node_Str"" + string.toLowerCase() + ""String_Node_Str"");
    while (rs.next()) {
      String result_string=rs.getString(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + result_string);
      boolean found=false;
      for (      String s : al) {
        if (s.equals(result_string))         found=true;
      }
      if (found == false)       al.add(result_string);
    }
    System.out.println(""String_Node_Str"" + al.size());
    if (al.size() == 1)     return al.get(0);
 else {
      boolean found=false;
      for (      String s : al) {
        if (s.contains(""String_Node_Str"")) {
          System.out.println(""String_Node_Str"" + s);
          found=true;
          return s;
        }
      }
      if (found == false) {
        System.out.println(""String_Node_Str"" + al.get(0));
        return al.get(0);
      }
    }
    return null;
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"");
    return null;
  }
}"
9527,"public ArrayList<Template> createTemplates(String question) throws IOException {
  long start=System.currentTimeMillis();
  ArrayList<Template> resultArrayList=new ArrayList<Template>();
  Set<BasicQueryTemplate> querytemps=null;
  querytemps=btemplator.buildBasicQueries(question);
  if (querytemps.contains(""String_Node_Str"") || querytemps.isEmpty()) {
    String dateiname=""String_Node_Str"";
    String result_string=""String_Node_Str"";
    try {
      BufferedReader br=new BufferedReader(new FileReader(dateiname));
      String thisLine;
      while ((thisLine=br.readLine()) != null) {
        result_string+=thisLine + ""String_Node_Str"";
      }
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"" + e);
    }
    File file=new File(dateiname);
    BufferedWriter bw=new BufferedWriter(new FileWriter(file));
    bw.write(result_string + ""String_Node_Str"" + question);
    bw.flush();
    bw.close();
  }
  long stop_template=System.currentTimeMillis();
  for (  BasicQueryTemplate bqt : querytemps) {
    long start_part1=System.currentTimeMillis();
    ArrayList<ArrayList<String>> condition=new ArrayList<ArrayList<String>>();
    String selectTerm=""String_Node_Str"";
    String having=""String_Node_Str"";
    String filter=""String_Node_Str"";
    String OrderBy=""String_Node_Str"";
    String limit=""String_Node_Str"";
    boolean addTemplate=true;
    try {
      for (      SPARQL_Term terms : bqt.getSelTerms())       selectTerm=selectTerm + (terms.toString()) + ""String_Node_Str"";
    }
 catch (    Exception e) {
      selectTerm=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      for (      Path conditions1 : bqt.getConditions()) {
        ArrayList<String> temp_array=new ArrayList<String>();
        String[] tmp_array=conditions1.toString().split(""String_Node_Str"");
        for (        String s : tmp_array) {
          s=s.replace(""String_Node_Str"",""String_Node_Str"");
          temp_array.add(s);
        }
        condition.add(temp_array);
      }
    }
 catch (    Exception e) {
      addTemplate=false;
    }
    try {
      for (      SPARQL_Filter tmp : bqt.getFilters())       filter=filter + tmp + ""String_Node_Str"";
    }
 catch (    Exception e) {
      filter=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      for (      SPARQL_Having tmp : bqt.getHavings())       having=having + tmp + ""String_Node_Str"";
    }
 catch (    Exception e) {
      having=""String_Node_Str"";
      addTemplate=false;
    }
    OrderBy=""String_Node_Str"";
    try {
      for (      SPARQL_Term tmp : bqt.getOrderBy()) {
        OrderBy=OrderBy + tmp + ""String_Node_Str"";
      }
      if ((bqt.getOrderBy()).size() == 0)       OrderBy=""String_Node_Str"";
    }
 catch (    Exception e) {
      OrderBy=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      limit=""String_Node_Str"" + bqt.getLimit();
      if (bqt.getLimit() == 0)       limit=""String_Node_Str"";
    }
 catch (    Exception e) {
      limit=""String_Node_Str"";
      addTemplate=false;
    }
    long stop_part1=System.currentTimeMillis();
    if (addTemplate != false) {
      long start_part2=System.currentTimeMillis();
      Template template=new Template(condition,bqt.getQt().toString(),having,filter,selectTerm,OrderBy,limit,question);
      for (      ArrayList<String> al : condition) {
        String con_temp=""String_Node_Str"";
        for (        String s : al) {
          con_temp+=""String_Node_Str"" + s;
        }
        System.out.println(""String_Node_Str"" + con_temp);
      }
      template.setTime_part1(stop_part1 - start_part1);
      boolean add_reverse_template=true;
      ArrayList<Hypothesis> list_of_hypothesis=new ArrayList<Hypothesis>();
      for (      Slot slot : bqt.getSlots()) {
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          boolean no_iaA_found=true;
          for (          ArrayList<String> x : condition) {
            if (x.get(1).equals(""String_Node_Str"") && x.get(2).equals(""String_Node_Str"" + tmp_array[0])) {
              no_iaA_found=false;
              Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
              list_of_hypothesis.add(tmp_hypothesis);
              add_reverse_template=false;
            }
          }
          if (no_iaA_found) {
            Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
            list_of_hypothesis.add(tmp_hypothesis);
          }
        }
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
      }
      ArrayList<ArrayList<Hypothesis>> final_list_set_hypothesis=new ArrayList<ArrayList<Hypothesis>>();
      System.out.println(""String_Node_Str"");
      for (      Hypothesis x : list_of_hypothesis) {
        x.printAll();
      }
      System.out.println(""String_Node_Str"");
      for (      Hypothesis x : list_of_hypothesis) {
        if (x.getType().contains(""String_Node_Str"") || x.getType().contains(""String_Node_Str"") || x.getType().contains(""String_Node_Str"")) {
          ArrayList<String> result=new ArrayList<String>();
          try {
            if (x.getType().contains(""String_Node_Str"")) {
              result=Index_utils.searchIndexForClass(x.getUri(),myindex);
            }
 else {
              result=Index_utils.searchIndexForResource(x.getUri(),myindex);
            }
          }
 catch (          SQLException e) {
            e.printStackTrace();
          }
          for (          String s : result) {
            ArrayList<Hypothesis> new_list=new ArrayList<Hypothesis>();
            for (            Hypothesis h : list_of_hypothesis) {
              if (h.getUri().equals(x.getUri())) {
                if (s != null) {
                  Hypothesis new_h=new Hypothesis(h.getVariable(),h.getName(),s,h.getType(),1.0);
                  new_list.add(new_h);
                }
 else {
                  Hypothesis new_h=new Hypothesis(h.getVariable(),h.getName(),h.getUri(),h.getType(),1.0);
                  new_list.add(new_h);
                }
              }
 else {
                Hypothesis new_h=new Hypothesis(h.getVariable(),h.getName(),h.getUri(),h.getType(),h.getRank());
                new_list.add(new_h);
              }
            }
            final_list_set_hypothesis.add(new_list);
          }
        }
      }
      System.out.println(""String_Node_Str"");
      for (      ArrayList<Hypothesis> lh : final_list_set_hypothesis) {
        for (        Hypothesis x : lh) {
          x.printAll();
        }
      }
      System.out.println(""String_Node_Str"");
      HashMap<String,String> hm=new HashMap<String,String>();
      for (      ArrayList<Hypothesis> x : final_list_set_hypothesis) {
        for (        Hypothesis h : x) {
          if (h.getType().contains(""String_Node_Str"")) {
            ArrayList<String> result=new ArrayList<String>();
            try {
              if (hm.containsKey(h.getUri().toLowerCase())) {
                result.add(hm.get(h.getUri().toLowerCase()));
              }
 else {
                result=Index_utils.searchIndexForProperty(h.getUri(),myindex);
                if (!result.isEmpty())                 hm.put(h.getUri().toLowerCase(),result.get(0));
              }
              if (!result.isEmpty()) {
                h.setUri(result.get(0));
                h.setRank(0.0);
              }
            }
 catch (            SQLException e) {
              e.printStackTrace();
            }
          }
        }
      }
      System.out.println(""String_Node_Str"");
      for (      ArrayList<Hypothesis> lh : final_list_set_hypothesis) {
        for (        Hypothesis x : lh) {
          x.printAll();
        }
      }
      System.out.println(""String_Node_Str"");
      template.setHypothesen(final_list_set_hypothesis);
      Template template_reverse_conditions=new Template(template.getCondition(),template.getQueryType(),template.getHaving(),template.getFilter(),template.getSelectTerm(),template.getOrderBy(),template.getLimit(),template.getQuestion());
      ArrayList<ArrayList<String>> condition_template_reverse_conditions=template_reverse_conditions.getCondition();
      ArrayList<ArrayList<String>> condition_reverse_new=new ArrayList<ArrayList<String>>();
      if (add_reverse_template) {
        for (        ArrayList<String> x : condition_template_reverse_conditions) {
          ArrayList<String> new_list=new ArrayList<String>();
          new_list.add(x.get(2));
          new_list.add(x.get(1));
          new_list.add(x.get(0));
          condition_reverse_new.add(new_list);
        }
      }
      long stop=System.currentTimeMillis();
      template_reverse_conditions.setOverallTime(stop - start);
      template.setOverallTime(stop - start);
      template_reverse_conditions.setTime_Templator(stop_template - start);
      template.setTime_Templator(stop_template - start);
      template_reverse_conditions.setCondition(condition_reverse_new);
      template_reverse_conditions.setHypothesen(template.getHypothesen());
      long start_elements=System.currentTimeMillis();
      Elements elm=new Elements(template.getCondition(),template.getHypothesen());
      long stop_elements=System.currentTimeMillis();
      template.setTime_generateElements(stop_elements - start_elements);
      long stop_part2=System.currentTimeMillis();
      template.setTime_part2(stop_part2 - start_part2);
      if (elm.isElementEmty() == false) {
        template.setElm(elm);
        resultArrayList.add(template);
      }
      if (add_reverse_template) {
        start_elements=System.currentTimeMillis();
        Elements elm_reverse=new Elements(template_reverse_conditions.getCondition(),template_reverse_conditions.getHypothesen());
        stop_elements=System.currentTimeMillis();
        template_reverse_conditions.setTime_generateElements(stop_elements - start_elements);
        template_reverse_conditions.setTime_part1(stop_part1 - start_part1);
        template_reverse_conditions.setTime_part2(stop_part2 - start_part2);
        if (elm_reverse.isElementEmty() == false) {
          template_reverse_conditions.setElm(elm_reverse);
          resultArrayList.add(template_reverse_conditions);
        }
      }
    }
  }
  return resultArrayList;
}","public ArrayList<Template> createTemplates(String question) throws IOException {
  long start=System.currentTimeMillis();
  ArrayList<Template> resultArrayList=new ArrayList<Template>();
  Set<BasicQueryTemplate> querytemps=null;
  querytemps=btemplator.buildBasicQueries(question);
  if (querytemps.contains(""String_Node_Str"") || querytemps.isEmpty()) {
    String dateiname=""String_Node_Str"";
    String result_string=""String_Node_Str"";
    try {
      BufferedReader br=new BufferedReader(new FileReader(dateiname));
      String thisLine;
      while ((thisLine=br.readLine()) != null) {
        result_string+=thisLine + ""String_Node_Str"";
      }
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"" + e);
    }
    File file=new File(dateiname);
    BufferedWriter bw=new BufferedWriter(new FileWriter(file));
    bw.write(result_string + ""String_Node_Str"" + question);
    bw.flush();
    bw.close();
  }
  long stop_template=System.currentTimeMillis();
  for (  BasicQueryTemplate bqt : querytemps) {
    long start_part1=System.currentTimeMillis();
    ArrayList<ArrayList<String>> condition=new ArrayList<ArrayList<String>>();
    String selectTerm=""String_Node_Str"";
    String having=""String_Node_Str"";
    String filter=""String_Node_Str"";
    String OrderBy=""String_Node_Str"";
    String limit=""String_Node_Str"";
    boolean addTemplate=true;
    try {
      for (      SPARQL_Term terms : bqt.getSelTerms())       selectTerm=selectTerm + (terms.toString()) + ""String_Node_Str"";
    }
 catch (    Exception e) {
      selectTerm=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      for (      Path conditions1 : bqt.getConditions()) {
        ArrayList<String> temp_array=new ArrayList<String>();
        String[] tmp_array=conditions1.toString().split(""String_Node_Str"");
        for (        String s : tmp_array) {
          s=s.replace(""String_Node_Str"",""String_Node_Str"");
          temp_array.add(s);
        }
        condition.add(temp_array);
      }
    }
 catch (    Exception e) {
      addTemplate=false;
    }
    try {
      for (      SPARQL_Filter tmp : bqt.getFilters())       filter=filter + tmp + ""String_Node_Str"";
    }
 catch (    Exception e) {
      filter=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      for (      SPARQL_Having tmp : bqt.getHavings())       having=having + tmp + ""String_Node_Str"";
    }
 catch (    Exception e) {
      having=""String_Node_Str"";
      addTemplate=false;
    }
    OrderBy=""String_Node_Str"";
    try {
      for (      SPARQL_Term tmp : bqt.getOrderBy()) {
        OrderBy=OrderBy + tmp + ""String_Node_Str"";
      }
      if ((bqt.getOrderBy()).size() == 0)       OrderBy=""String_Node_Str"";
    }
 catch (    Exception e) {
      OrderBy=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      limit=""String_Node_Str"" + bqt.getLimit();
      if (bqt.getLimit() == 0)       limit=""String_Node_Str"";
    }
 catch (    Exception e) {
      limit=""String_Node_Str"";
      addTemplate=false;
    }
    long stop_part1=System.currentTimeMillis();
    if (addTemplate != false) {
      long start_part2=System.currentTimeMillis();
      Template template=new Template(condition,bqt.getQt().toString(),having,filter,selectTerm,OrderBy,limit,question);
      for (      ArrayList<String> al : condition) {
        String con_temp=""String_Node_Str"";
        for (        String s : al) {
          con_temp+=""String_Node_Str"" + s;
        }
        System.out.println(""String_Node_Str"" + con_temp);
      }
      template.setTime_part1(stop_part1 - start_part1);
      boolean add_reverse_template=true;
      ArrayList<Hypothesis> list_of_hypothesis=new ArrayList<Hypothesis>();
      for (      Slot slot : bqt.getSlots()) {
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          boolean no_iaA_found=true;
          for (          ArrayList<String> x : condition) {
            if (x.get(1).equals(""String_Node_Str"") && x.get(2).equals(""String_Node_Str"" + tmp_array[0])) {
              no_iaA_found=false;
              Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
              list_of_hypothesis.add(tmp_hypothesis);
              add_reverse_template=false;
            }
          }
          if (no_iaA_found) {
            Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
            list_of_hypothesis.add(tmp_hypothesis);
          }
        }
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],tmp_array[1],""String_Node_Str"",0.0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
      }
      ArrayList<ArrayList<Hypothesis>> final_list_set_hypothesis=new ArrayList<ArrayList<Hypothesis>>();
      for (      Hypothesis x : list_of_hypothesis) {
        if (x.getType().contains(""String_Node_Str"") || x.getType().contains(""String_Node_Str"") || x.getType().contains(""String_Node_Str"")) {
          ArrayList<String> result=new ArrayList<String>();
          try {
            if (x.getType().contains(""String_Node_Str"")) {
              result=Index_utils.searchIndexForClass(x.getUri(),myindex);
            }
 else {
              result=Index_utils.searchIndexForResource(x.getUri(),myindex);
            }
          }
 catch (          SQLException e) {
            e.printStackTrace();
          }
          for (          String s : result) {
            ArrayList<Hypothesis> new_list=new ArrayList<Hypothesis>();
            for (            Hypothesis h : list_of_hypothesis) {
              if (h.getUri().equals(x.getUri())) {
                if (s != null) {
                  Hypothesis new_h=new Hypothesis(h.getVariable(),h.getName(),s,h.getType(),1.0);
                  new_list.add(new_h);
                }
 else {
                  Hypothesis new_h=new Hypothesis(h.getVariable(),h.getName(),h.getUri(),h.getType(),1.0);
                  new_list.add(new_h);
                }
              }
 else {
                Hypothesis new_h=new Hypothesis(h.getVariable(),h.getName(),h.getUri(),h.getType(),h.getRank());
                new_list.add(new_h);
              }
            }
            final_list_set_hypothesis.add(new_list);
          }
        }
      }
      HashMap<String,String> hm=new HashMap<String,String>();
      for (      ArrayList<Hypothesis> x : final_list_set_hypothesis) {
        for (        Hypothesis h : x) {
          if (h.getType().contains(""String_Node_Str"")) {
            ArrayList<String> result=new ArrayList<String>();
            try {
              if (hm.containsKey(h.getUri().toLowerCase())) {
                result.add(hm.get(h.getUri().toLowerCase()));
              }
 else {
                result=Index_utils.searchIndexForProperty(h.getUri(),myindex);
                if (!result.isEmpty())                 hm.put(h.getUri().toLowerCase(),result.get(0));
              }
              if (!result.isEmpty()) {
                h.setUri(result.get(0));
                h.setRank(0.0);
              }
            }
 catch (            SQLException e) {
              e.printStackTrace();
            }
          }
        }
      }
      for (      ArrayList<Hypothesis> al : final_list_set_hypothesis) {
        for (        Hypothesis h : al) {
          if (!h.getUri().contains(""String_Node_Str"")) {
            if (h.getType().contains(""String_Node_Str"")) {
              try {
                ArrayList<String> tmp=Index_utils.searchIndexForClass(h.getUri(),myindex);
                System.out.println(""String_Node_Str"" + tmp.size());
                if (tmp.size() > 0)                 h.setUri(tmp.get(0));
              }
 catch (              SQLException e) {
                e.printStackTrace();
              }
            }
            if (h.getType().contains(""String_Node_Str"")) {
              try {
                ArrayList<String> tmp=Index_utils.searchIndexForResource(h.getUri(),myindex);
                System.out.println(""String_Node_Str"" + tmp.size());
                if (tmp.size() > 0)                 h.setUri(tmp.get(0));
              }
 catch (              SQLException e) {
                e.printStackTrace();
              }
            }
          }
        }
      }
      template.setHypothesen(final_list_set_hypothesis);
      Template template_reverse_conditions=new Template(template.getCondition(),template.getQueryType(),template.getHaving(),template.getFilter(),template.getSelectTerm(),template.getOrderBy(),template.getLimit(),template.getQuestion());
      ArrayList<ArrayList<String>> condition_template_reverse_conditions=template_reverse_conditions.getCondition();
      ArrayList<ArrayList<String>> condition_reverse_new=new ArrayList<ArrayList<String>>();
      if (add_reverse_template) {
        for (        ArrayList<String> x : condition_template_reverse_conditions) {
          ArrayList<String> new_list=new ArrayList<String>();
          new_list.add(x.get(2));
          new_list.add(x.get(1));
          new_list.add(x.get(0));
          condition_reverse_new.add(new_list);
        }
      }
      long stop=System.currentTimeMillis();
      template_reverse_conditions.setOverallTime(stop - start);
      template.setOverallTime(stop - start);
      template_reverse_conditions.setTime_Templator(stop_template - start);
      template.setTime_Templator(stop_template - start);
      template_reverse_conditions.setCondition(condition_reverse_new);
      template_reverse_conditions.setHypothesen(template.getHypothesen());
      long start_elements=System.currentTimeMillis();
      Elements elm=new Elements(template.getCondition(),template.getHypothesen());
      long stop_elements=System.currentTimeMillis();
      template.setTime_generateElements(stop_elements - start_elements);
      long stop_part2=System.currentTimeMillis();
      template.setTime_part2(stop_part2 - start_part2);
      if (elm.isElementEmty() == false) {
        template.setElm(elm);
        resultArrayList.add(template);
      }
      if (add_reverse_template) {
        start_elements=System.currentTimeMillis();
        Elements elm_reverse=new Elements(template_reverse_conditions.getCondition(),template_reverse_conditions.getHypothesen());
        stop_elements=System.currentTimeMillis();
        template_reverse_conditions.setTime_generateElements(stop_elements - start_elements);
        template_reverse_conditions.setTime_part1(stop_part1 - start_part1);
        template_reverse_conditions.setTime_part2(stop_part2 - start_part2);
        if (elm_reverse.isElementEmty() == false) {
          template_reverse_conditions.setElm(elm_reverse);
          resultArrayList.add(template_reverse_conditions);
        }
      }
    }
  }
  return resultArrayList;
}"
9528,"private static ArrayList<String> createAnswerArray(String string){
  Pattern p=Pattern.compile(""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
  Matcher m=p.matcher(string);
  String[] bla=string.split(""String_Node_Str"");
  ArrayList<String> result=new ArrayList<String>();
  for (  String s : bla) {
    m=p.matcher(s);
    while (m.find()) {
      String temp=m.group(1);
      temp=temp.replace(""String_Node_Str"",""String_Node_Str"");
      temp=temp.replace(""String_Node_Str"",""String_Node_Str"");
      result.add(temp);
    }
  }
  if (string.matches(""String_Node_Str"") || string.matches(""String_Node_Str""))   result.add(string);
  return result;
}","private static ArrayList<String> createAnswerArray(String string){
  Pattern p=Pattern.compile(""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
  Matcher m=p.matcher(string);
  String[] bla=string.split(""String_Node_Str"");
  ArrayList<String> result=new ArrayList<String>();
  for (  String s : bla) {
    m=p.matcher(s);
    while (m.find()) {
      String temp=m.group(1);
      temp=temp.replace(""String_Node_Str"",""String_Node_Str"");
      temp=temp.replace(""String_Node_Str"",""String_Node_Str"");
      temp=temp.replace(""String_Node_Str"",""String_Node_Str"");
      temp=temp.replace(""String_Node_Str"",""String_Node_Str"");
      temp=temp.replace(""String_Node_Str"",""String_Node_Str"");
      temp=temp.replace(""String_Node_Str"",""String_Node_Str"");
      result.add(temp);
    }
  }
  if (string.matches(""String_Node_Str"") || string.matches(""String_Node_Str""))   result.add(string);
  return result;
}"
9529,"private static boolean checkAnswer(String answer){
  if (answer.contains(""String_Node_Str"") || answer.contains(""String_Node_Str"") || answer.contains(""String_Node_Str"")|| answer.contains(""String_Node_Str"")|| answer.contains(""String_Node_Str""))   return false;
 else   return true;
}","private static boolean checkAnswer(String answer){
  if (answer.contains(""String_Node_Str"") || answer.contains(""String_Node_Str"") || answer.contains(""String_Node_Str"")|| answer.contains(""String_Node_Str"")|| answer.contains(""String_Node_Str"")|| answer.contains(""String_Node_Str""))   return false;
 else   return true;
}"
9530,"private static String createXML(ArrayList<queryInformation> list){
  java.util.Date now=new java.util.Date();
  java.text.SimpleDateFormat sdf=new java.text.SimpleDateFormat(""String_Node_Str"");
  String systemid=sdf.format(now);
  System.out.println(""String_Node_Str"");
  String xmlDocument=""String_Node_Str"";
  int counter=0;
  System.out.println(""String_Node_Str"" + list.size());
  for (  queryInformation s : list) {
    if (!s.getResult().isEmpty()) {
      String tmp;
      if (counter == 0) {
        counter=counter + 1;
        xmlDocument=""String_Node_Str"" + s.getXMLtype() + ""String_Node_Str"";
      }
      tmp=""String_Node_Str"" + s.getId() + ""String_Node_Str""+ s.getQuery()+ ""String_Node_Str"";
      Set<String> setString=new HashSet<String>();
      for (      String z : s.getResult()) {
        setString.add(z);
      }
      for (      String i : setString) {
        String input=""String_Node_Str"";
        if (i.contains(""String_Node_Str""))         input=""String_Node_Str"" + i + ""String_Node_Str"";
 else         if (i.contains(""String_Node_Str"") || i.contains(""String_Node_Str""))         input=""String_Node_Str"" + i + ""String_Node_Str"";
 else         if (i.matches(""String_Node_Str""))         input=""String_Node_Str"" + i + ""String_Node_Str"";
 else         input=""String_Node_Str"" + i + ""String_Node_Str"";
        tmp+=""String_Node_Str"" + input + ""String_Node_Str"";
      }
      tmp+=""String_Node_Str"";
      xmlDocument+=tmp;
    }
  }
  xmlDocument+=""String_Node_Str"";
  File file;
  FileWriter writer;
  file=new File(""String_Node_Str"" + systemid.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  try {
    writer=new FileWriter(file,true);
    writer.write(xmlDocument);
    writer.flush();
    writer.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  System.out.println(""String_Node_Str"");
  return systemid;
}","private static String createXML(ArrayList<queryInformation> list){
  java.util.Date now=new java.util.Date();
  java.text.SimpleDateFormat sdf=new java.text.SimpleDateFormat(""String_Node_Str"");
  String systemid=sdf.format(now);
  System.out.println(""String_Node_Str"");
  String xmlDocument=""String_Node_Str"";
  int counter=0;
  System.out.println(""String_Node_Str"" + list.size());
  for (  queryInformation s : list) {
    if (!s.getResult().isEmpty()) {
      String tmp;
      if (counter == 0) {
        counter=counter + 1;
        xmlDocument=""String_Node_Str"" + s.getXMLtype() + ""String_Node_Str"";
      }
      tmp=""String_Node_Str"" + s.getId() + ""String_Node_Str""+ s.getQuery()+ ""String_Node_Str"";
      Set<String> setString=new HashSet<String>();
      for (      String z : s.getResult()) {
        setString.add(z);
      }
      for (      String i : setString) {
        String input=""String_Node_Str"";
        if (i.contains(""String_Node_Str""))         input=""String_Node_Str"" + i + ""String_Node_Str"";
 else         if (i.contains(""String_Node_Str"") || i.contains(""String_Node_Str""))         input=""String_Node_Str"" + i + ""String_Node_Str"";
 else         if (i.matches(""String_Node_Str""))         input=""String_Node_Str"" + i + ""String_Node_Str"";
 else         if (i.matches(""String_Node_Str""))         input=""String_Node_Str"" + i + ""String_Node_Str"";
 else         input=""String_Node_Str"" + i + ""String_Node_Str"";
        tmp+=""String_Node_Str"" + input + ""String_Node_Str"";
      }
      tmp+=""String_Node_Str"";
      xmlDocument+=tmp;
    }
  }
  xmlDocument+=""String_Node_Str"";
  File file;
  FileWriter writer;
  file=new File(""String_Node_Str"" + systemid.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  try {
    writer=new FileWriter(file,true);
    writer.write(xmlDocument);
    writer.flush();
    writer.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  System.out.println(""String_Node_Str"");
  return systemid;
}"
9531,"/** 
 * @param args
 * @throws IOException 
 * @throws JWNLException 
 * @throws InterruptedException 
 * @throws ClassNotFoundException 
 * @throws SQLException 
 */
public static void main(String[] args) throws IOException, JWNLException, InterruptedException, ClassNotFoundException, SQLException {
  System.out.println(""String_Node_Str"");
  long startInitTime=System.currentTimeMillis();
  BasicTemplator btemplator=new BasicTemplator();
  SQLiteIndex myindex=new SQLiteIndex();
  WordNet wordnet=new WordNet();
  StanfordLemmatizer lemmatiser=new StanfordLemmatizer();
  long stopInitTime=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (stopInitTime - startInitTime) + ""String_Node_Str"");
  boolean schleife=true;
  boolean doing=true;
  while (schleife == true) {
    BufferedReader in=new BufferedReader(new InputStreamReader(System.in));
    String line;
    doing=true;
    try {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      line=in.readLine();
      if (line.contains(""String_Node_Str"")) {
        schleife=false;
        System.out.println(""String_Node_Str"");
        System.exit(0);
      }
      if (line.contains(""String_Node_Str"") && schleife == true) {
        TimeZone.setDefault(TimeZone.getTimeZone(""String_Node_Str""));
        line=""String_Node_Str"";
        ArrayList<queryInformation> list_of_structs=new ArrayList<queryInformation>();
        list_of_structs=generateStruct(line,true);
        long startTime=System.currentTimeMillis();
        int anzahl=0;
        int anzahl_query_with_answers=0;
        int yago_querys=0;
        for (        queryInformation qi : list_of_structs) {
          anzahl=anzahl + 1;
          System.out.println(""String_Node_Str"");
          if (qi.getId() == ""String_Node_Str"" || qi.getId() == null)           System.out.println(""String_Node_Str"");
          String question=qi.getQuery();
          ArrayList<String> answers=MainInterface.startQuestioning(question,btemplator,myindex,wordnet,lemmatiser);
          qi.setResult(answers);
        }
        String systemid=""String_Node_Str"";
        systemid=createXML(list_of_structs);
        String filename_for_evaluation=""String_Node_Str"" + systemid.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
        String execute=""String_Node_Str"" + filename_for_evaluation + ""String_Node_Str"";
        System.out.println(""String_Node_Str"" + execute);
        Runtime r=Runtime.getRuntime();
        Process p=r.exec(execute);
        String open_file=""String_Node_Str"" + systemid.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
        execute=""String_Node_Str"" + open_file;
        p=r.exec(execute);
      }
 else       if (schleife == true && doing == true) {
        long startTime=System.currentTimeMillis();
        queryInformation result=new queryInformation(line,""String_Node_Str"",""String_Node_Str"",false,false,false,""String_Node_Str"",false);
        MainInterface.startQuestioning(line,btemplator,myindex,wordnet,lemmatiser);
        ArrayList<String> ergebnis=result.getResult();
        Set<String> setString=new HashSet<String>();
        for (        String i : ergebnis) {
          setString.add(i);
        }
        for (        String z : setString) {
          System.out.println(z);
        }
        long endTime=System.currentTimeMillis();
        System.out.println(""String_Node_Str"" + (endTime - startTime) + ""String_Node_Str"");
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","/** 
 * @param args
 * @throws IOException 
 * @throws JWNLException 
 * @throws InterruptedException 
 * @throws ClassNotFoundException 
 * @throws SQLException 
 */
public static void main(String[] args) throws IOException, JWNLException, InterruptedException, ClassNotFoundException, SQLException {
  System.out.println(""String_Node_Str"");
  long startInitTime=System.currentTimeMillis();
  BasicTemplator btemplator=new BasicTemplator();
  SQLiteIndex myindex=new SQLiteIndex();
  WordNet wordnet=new WordNet();
  StanfordLemmatizer lemmatiser=new StanfordLemmatizer();
  long stopInitTime=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (stopInitTime - startInitTime) + ""String_Node_Str"");
  boolean schleife=true;
  boolean doing=true;
  while (schleife == true) {
    BufferedReader in=new BufferedReader(new InputStreamReader(System.in));
    String line;
    doing=true;
    try {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      line=in.readLine();
      if (line.contains(""String_Node_Str"")) {
        schleife=false;
        System.out.println(""String_Node_Str"");
        System.exit(0);
      }
      if (line.contains(""String_Node_Str"") && schleife == true) {
        TimeZone.setDefault(TimeZone.getTimeZone(""String_Node_Str""));
        line=""String_Node_Str"";
        line=""String_Node_Str"";
        ArrayList<queryInformation> list_of_structs=new ArrayList<queryInformation>();
        list_of_structs=generateStruct(line,true);
        long startTime=System.currentTimeMillis();
        int anzahl=0;
        int anzahl_query_with_answers=0;
        int yago_querys=0;
        for (        queryInformation qi : list_of_structs) {
          anzahl=anzahl + 1;
          System.out.println(""String_Node_Str"");
          if (qi.getId() == ""String_Node_Str"" || qi.getId() == null)           System.out.println(""String_Node_Str"");
          String question=qi.getQuery();
          ArrayList<String> answers=MainInterface.startQuestioning(question,btemplator,myindex,wordnet,lemmatiser);
          qi.setResult(answers);
        }
        String systemid=""String_Node_Str"";
        systemid=createXML(list_of_structs);
        String filename_for_evaluation=""String_Node_Str"" + systemid.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
        String execute=""String_Node_Str"" + filename_for_evaluation + ""String_Node_Str"";
        System.out.println(""String_Node_Str"" + execute);
        Runtime r=Runtime.getRuntime();
        Process p=r.exec(execute);
        String open_file=""String_Node_Str"" + systemid.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
        execute=""String_Node_Str"" + open_file;
        p=r.exec(execute);
      }
 else       if (schleife == true && doing == true) {
        long startTime=System.currentTimeMillis();
        queryInformation result=new queryInformation(line,""String_Node_Str"",""String_Node_Str"",false,false,false,""String_Node_Str"",false);
        MainInterface.startQuestioning(line,btemplator,myindex,wordnet,lemmatiser);
        ArrayList<String> ergebnis=result.getResult();
        Set<String> setString=new HashSet<String>();
        for (        String i : ergebnis) {
          setString.add(i);
        }
        for (        String z : setString) {
          System.out.println(z);
        }
        long endTime=System.currentTimeMillis();
        System.out.println(""String_Node_Str"" + (endTime - startTime) + ""String_Node_Str"");
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}"
9532,"private OWLOntology computeCoherentOntologyRootBased(OWLOntology ontology){
  OWLOntologyManager man=incoherentOntology.getOWLOntologyManager();
  factory=man.getOWLDataFactory();
  logger.info(""String_Node_Str"");
  long startTime=System.currentTimeMillis();
  StructureBasedRootClassFinder rootFinder=new StructureBasedRootClassFinder(reasoner);
  Set<OWLClass> unsatClasses=rootFinder.getRootUnsatisfiableClasses();
  Set<OWLClass> derivedUnsatClasses=rootFinder.getDerivedUnsatisfiableClasses();
  logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
  int rootCnt=unsatClasses.size();
  int derivedCnt=derivedUnsatClasses.size();
  int cnt=rootCnt + derivedCnt;
  int unsatPropCnt=unsatObjectProperties.size();
  logger.info(""String_Node_Str"" + cnt + ""String_Node_Str""+ rootCnt+ ""String_Node_Str"");
  if (unsatClasses.isEmpty()) {
    return incoherentOntology;
  }
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  entity2ModuleMap.putAll(extractModules(unsatClasses));
  logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  entity2Explanations.putAll(getInitialExplanations(unsatClasses));
  if (computeParallel) {
    entity2Explanations.putAll(getInitialExplanations(unsatObjectProperties));
  }
  logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
  if (computeParallel) {
    cnt+=unsatPropCnt;
  }
  while (cnt >= 0) {
    removeAppropriateAxiom();
    logger.info(""String_Node_Str"");
    startTime=System.currentTimeMillis();
    reasoner.classify();
    logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
    logger.info(""String_Node_Str"");
    startTime=System.currentTimeMillis();
    rootFinder=new StructureBasedRootClassFinder(reasoner);
    unsatClasses=rootFinder.getRootUnsatisfiableClasses();
    derivedUnsatClasses=rootFinder.getDerivedUnsatisfiableClasses();
    rootCnt=unsatClasses.size();
    derivedCnt=derivedUnsatClasses.size();
    logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
    logger.info(""String_Node_Str"" + (rootCnt + derivedCnt) + ""String_Node_Str""+ rootCnt+ ""String_Node_Str"");
    if (computeParallel) {
      unsatObjectProperties=getUnsatisfiableObjectProperties(reasoner);
      logger.info(""String_Node_Str"" + unsatObjectProperties.size());
    }
    if (cnt - (rootCnt + derivedCnt) >= 1 || (unsatPropCnt - unsatObjectProperties.size()) >= 1) {
      cnt=rootCnt + derivedCnt;
      save(""String_Node_Str"" + cnt + ""String_Node_Str""+ unsatPropCnt+ ""String_Node_Str"");
      cnt=rootCnt + derivedCnt;
      unsatPropCnt=unsatObjectProperties.size();
      if (computeParallel) {
        cnt+=unsatPropCnt;
      }
    }
    logger.info(""String_Node_Str"");
    startTime=System.currentTimeMillis();
    refillExplanations(unsatClasses,entity2Explanations);
    if (computeParallel) {
      refillExplanations(unsatObjectProperties,entity2Explanations);
    }
    logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
    System.gc();
  }
  entity2Explanations.clear();
  entity2ModuleMap.clear();
  if (!computeParallel) {
    unsatObjectProperties=getUnsatisfiableObjectProperties(reasoner);
    logger.info(""String_Node_Str"" + unsatObjectProperties.size());
    entity2ModuleMap.putAll(extractModules(unsatObjectProperties));
    while (!unsatObjectProperties.isEmpty()) {
      removeAppropriateAxiom();
      logger.info(""String_Node_Str"");
      startTime=System.currentTimeMillis();
      reasoner.classify();
      logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
      unsatObjectProperties=getUnsatisfiableObjectProperties(reasoner);
      logger.info(""String_Node_Str"" + unsatObjectProperties.size());
      if ((unsatPropCnt - unsatObjectProperties.size()) >= 1) {
        save(""String_Node_Str"" + cnt + ""String_Node_Str""+ unsatPropCnt+ ""String_Node_Str"");
        unsatPropCnt=unsatObjectProperties.size();
      }
      logger.info(""String_Node_Str"");
      startTime=System.currentTimeMillis();
      refillExplanations(unsatObjectProperties,entity2Explanations);
      logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
      System.gc();
    }
  }
  try {
    incoherentOntology.getOWLOntologyManager().saveOntology(getOntologyWithAnnotations(incoherentOntology),new RDFXMLOntologyFormat(),new BufferedOutputStream(new FileOutputStream(""String_Node_Str"")));
  }
 catch (  OWLOntologyStorageException e) {
    e.printStackTrace();
  }
catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
  return getOntologyWithAnnotations(incoherentOntology);
}","private OWLOntology computeCoherentOntologyRootBased(OWLOntology ontology){
  OWLOntologyManager man=incoherentOntology.getOWLOntologyManager();
  factory=man.getOWLDataFactory();
  logger.info(""String_Node_Str"");
  long startTime=System.currentTimeMillis();
  StructureBasedRootClassFinder rootFinder=new StructureBasedRootClassFinder(reasoner);
  Set<OWLClass> unsatClasses=rootFinder.getRootUnsatisfiableClasses();
  Set<OWLClass> derivedUnsatClasses=rootFinder.getDerivedUnsatisfiableClasses();
  logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
  int rootCnt=unsatClasses.size();
  int derivedCnt=derivedUnsatClasses.size();
  int cnt=rootCnt + derivedCnt;
  int unsatPropCnt=unsatObjectProperties.size();
  logger.info(""String_Node_Str"" + cnt + ""String_Node_Str""+ rootCnt+ ""String_Node_Str"");
  if (unsatClasses.isEmpty()) {
    unsatClasses=derivedUnsatClasses;
  }
  if (unsatClasses.isEmpty()) {
    return incoherentOntology;
  }
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  entity2ModuleMap.putAll(extractModules(unsatClasses));
  logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  entity2Explanations.putAll(getInitialExplanations(unsatClasses));
  if (computeParallel) {
    entity2Explanations.putAll(getInitialExplanations(unsatObjectProperties));
  }
  logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
  if (computeParallel) {
    cnt+=unsatPropCnt;
  }
  while (cnt >= 0) {
    removeAppropriateAxiom();
    logger.info(""String_Node_Str"");
    startTime=System.currentTimeMillis();
    reasoner.classify();
    logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
    logger.info(""String_Node_Str"");
    startTime=System.currentTimeMillis();
    rootFinder=new StructureBasedRootClassFinder(reasoner);
    unsatClasses=rootFinder.getRootUnsatisfiableClasses();
    derivedUnsatClasses=rootFinder.getDerivedUnsatisfiableClasses();
    rootCnt=unsatClasses.size();
    derivedCnt=derivedUnsatClasses.size();
    logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
    logger.info(""String_Node_Str"" + (rootCnt + derivedCnt) + ""String_Node_Str""+ rootCnt+ ""String_Node_Str"");
    if (unsatClasses.isEmpty()) {
      unsatClasses=derivedUnsatClasses;
    }
    if (computeParallel) {
      unsatObjectProperties=getUnsatisfiableObjectProperties(reasoner);
      logger.info(""String_Node_Str"" + unsatObjectProperties.size());
    }
    if (cnt - (rootCnt + derivedCnt) >= 1 || (unsatPropCnt - unsatObjectProperties.size()) >= 1) {
      cnt=rootCnt + derivedCnt;
      save(""String_Node_Str"" + cnt + ""String_Node_Str""+ unsatPropCnt+ ""String_Node_Str"");
      cnt=rootCnt + derivedCnt;
      unsatPropCnt=unsatObjectProperties.size();
      if (computeParallel) {
        cnt+=unsatPropCnt;
      }
    }
    logger.info(""String_Node_Str"");
    startTime=System.currentTimeMillis();
    refillExplanations(unsatClasses,entity2Explanations);
    if (computeParallel) {
      refillExplanations(unsatObjectProperties,entity2Explanations);
    }
    logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
    System.gc();
  }
  entity2Explanations.clear();
  entity2ModuleMap.clear();
  if (!computeParallel) {
    unsatObjectProperties=getUnsatisfiableObjectProperties(reasoner);
    logger.info(""String_Node_Str"" + unsatObjectProperties.size());
    entity2ModuleMap.putAll(extractModules(unsatObjectProperties));
    while (!unsatObjectProperties.isEmpty()) {
      removeAppropriateAxiom();
      logger.info(""String_Node_Str"");
      startTime=System.currentTimeMillis();
      reasoner.classify();
      logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
      unsatObjectProperties=getUnsatisfiableObjectProperties(reasoner);
      logger.info(""String_Node_Str"" + unsatObjectProperties.size());
      if ((unsatPropCnt - unsatObjectProperties.size()) >= 1) {
        save(""String_Node_Str"" + cnt + ""String_Node_Str""+ unsatPropCnt+ ""String_Node_Str"");
        unsatPropCnt=unsatObjectProperties.size();
      }
      logger.info(""String_Node_Str"");
      startTime=System.currentTimeMillis();
      refillExplanations(unsatObjectProperties,entity2Explanations);
      logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
      System.gc();
    }
  }
  try {
    incoherentOntology.getOWLOntologyManager().saveOntology(getOntologyWithAnnotations(incoherentOntology),new RDFXMLOntologyFormat(),new BufferedOutputStream(new FileOutputStream(""String_Node_Str"")));
  }
 catch (  OWLOntologyStorageException e) {
    e.printStackTrace();
  }
catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
  return getOntologyWithAnnotations(incoherentOntology);
}"
9533,"public void printAll(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + condition);
  int anzahl=1;
  for (  ArrayList<Hypothesis> x : hypothesen) {
    System.out.println(""String_Node_Str"" + anzahl + ""String_Node_Str"");
    for (    Hypothesis z : x) {
      z.printAll();
    }
  }
  System.out.print(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + selectTerm);
  System.out.println(""String_Node_Str"" + having);
  System.out.println(""String_Node_Str"" + filter);
  System.out.println(""String_Node_Str"" + OrderBy);
  System.out.println(""String_Node_Str"" + limit);
  System.out.println(""String_Node_Str"");
}","public void printAll(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + condition);
  int anzahl=1;
  for (  ArrayList<Hypothesis> x : hypothesen) {
    System.out.println(""String_Node_Str"" + anzahl + ""String_Node_Str"");
    anzahl+=1;
    for (    Hypothesis z : x) {
      z.printAll();
    }
  }
  System.out.print(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + selectTerm);
  System.out.println(""String_Node_Str"" + having);
  System.out.println(""String_Node_Str"" + filter);
  System.out.println(""String_Node_Str"" + OrderBy);
  System.out.println(""String_Node_Str"" + limit);
  System.out.println(""String_Node_Str"");
}"
9534,"public ArrayList<Template> createTemplates(String question){
  ArrayList<Template> resultArrayList=new ArrayList<Template>();
  Set<BasicQueryTemplate> querytemps=btemplator.buildBasicQueries(question);
  for (  BasicQueryTemplate bqt : querytemps) {
    ArrayList<ArrayList<String>> condition=new ArrayList<ArrayList<String>>();
    ArrayList<ArrayList<Hypothesis>> hypotesen=new ArrayList<ArrayList<Hypothesis>>();
    String selectTerm=""String_Node_Str"";
    String having=""String_Node_Str"";
    String filter=""String_Node_Str"";
    String OrderBy=""String_Node_Str"";
    String limit=""String_Node_Str"";
    String condition_String=""String_Node_Str"";
    boolean addTemplate=true;
    try {
      for (      SPARQL_Term terms : bqt.getSelTerms())       selectTerm=selectTerm + (terms.toString()) + ""String_Node_Str"";
    }
 catch (    Exception e) {
      selectTerm=""String_Node_Str"";
      addTemplate=false;
    }
    ArrayList<String> temp_array=new ArrayList<String>();
    try {
      for (      Path conditions1 : bqt.getConditions())       condition_String=condition_String + (conditions1.toString()) + ""String_Node_Str"";
      for (      Path conditions1 : bqt.getConditions()) {
        temp_array.clear();
        String[] tmp_array=conditions1.toString().split(""String_Node_Str"");
        for (        String s : tmp_array) {
          temp_array.add(s);
        }
        condition.add(temp_array);
      }
    }
 catch (    Exception e) {
      condition_String=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      for (      SPARQL_Filter tmp : bqt.getFilters())       filter=filter + tmp + ""String_Node_Str"";
    }
 catch (    Exception e) {
      filter=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      for (      SPARQL_Having tmp : bqt.getHavings())       having=having + tmp + ""String_Node_Str"";
    }
 catch (    Exception e) {
      having=""String_Node_Str"";
      addTemplate=false;
    }
    OrderBy=""String_Node_Str"";
    try {
      for (      SPARQL_Term tmp : bqt.getOrderBy()) {
        OrderBy=OrderBy + tmp + ""String_Node_Str"";
      }
      if ((bqt.getOrderBy()).size() == 0)       OrderBy=""String_Node_Str"";
    }
 catch (    Exception e) {
      OrderBy=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      limit=""String_Node_Str"" + bqt.getLimit();
      if (bqt.getLimit() == 0)       limit=""String_Node_Str"";
    }
 catch (    Exception e) {
      limit=""String_Node_Str"";
      addTemplate=false;
    }
    if (addTemplate != false) {
      Template template=new Template(condition,having,filter,selectTerm,OrderBy,limit);
      ArrayList<Hypothesis> list_of_hypothesis=new ArrayList<Hypothesis>();
      for (      Slot slot : bqt.getSlots()) {
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],""String_Node_Str"",0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],""String_Node_Str"",0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],""String_Node_Str"",0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
      }
      ArrayList<ArrayList<Hypothesis>> final_list_set_hypothesis=new ArrayList<ArrayList<Hypothesis>>();
      for (      Hypothesis x : list_of_hypothesis) {
        if (x.getType().contains(""String_Node_Str"")) {
          ArrayList<String> result=new ArrayList<String>();
          try {
            result=utils_new.searchIndex(x.getUri(),3,myindex);
          }
 catch (          SQLException e) {
            e.printStackTrace();
          }
          for (          String s : result) {
            ArrayList<Hypothesis> new_list=new ArrayList<Hypothesis>();
            new_list=list_of_hypothesis;
            for (            Hypothesis z : new_list) {
              if (z.getUri().equals(x.getUri())) {
                z.setUri(s);
                z.setRank(1);
              }
            }
            final_list_set_hypothesis.add(new_list);
          }
        }
      }
      for (      ArrayList<Hypothesis> x : final_list_set_hypothesis) {
        for (        Hypothesis h : x) {
          if (h.getType().contains(""String_Node_Str"")) {
            ArrayList<String> result=new ArrayList<String>();
            try {
              result=utils_new.searchIndex(h.getUri(),1,myindex);
              if (!result.isEmpty()) {
                h.setUri(result.get(0));
                h.setRank(1);
              }
 else {
                h.setRank(0);
              }
            }
 catch (            SQLException e) {
              e.printStackTrace();
            }
          }
        }
      }
      template.setHypothesen(final_list_set_hypothesis);
      Template template_reverse_conditions=new Template(template.getCondition(),template.getHaving(),template.getFilter(),template.getSelectTerm(),template.getOrderBy(),template.getLimit());
      ArrayList<ArrayList<String>> condition_template_reverse_conditions=template_reverse_conditions.getCondition();
      ArrayList<ArrayList<String>> condition_reverse_new=new ArrayList<ArrayList<String>>();
      for (      ArrayList<String> x : condition_template_reverse_conditions) {
        ArrayList<String> new_list=new ArrayList<String>();
        new_list.add(x.get(2));
        new_list.add(x.get(1));
        new_list.add(x.get(0));
        condition_reverse_new.add(new_list);
      }
      template_reverse_conditions.setCondition(condition_reverse_new);
      resultArrayList.add(template);
      resultArrayList.add(template_reverse_conditions);
    }
  }
  for (  Template temp : resultArrayList) {
    temp.printAll();
  }
  return resultArrayList;
}","public ArrayList<Template> createTemplates(String question){
  ArrayList<Template> resultArrayList=new ArrayList<Template>();
  Set<BasicQueryTemplate> querytemps=btemplator.buildBasicQueries(question);
  for (  BasicQueryTemplate bqt : querytemps) {
    ArrayList<ArrayList<String>> condition=new ArrayList<ArrayList<String>>();
    String selectTerm=""String_Node_Str"";
    String having=""String_Node_Str"";
    String filter=""String_Node_Str"";
    String OrderBy=""String_Node_Str"";
    String limit=""String_Node_Str"";
    boolean addTemplate=true;
    try {
      for (      SPARQL_Term terms : bqt.getSelTerms())       selectTerm=selectTerm + (terms.toString()) + ""String_Node_Str"";
    }
 catch (    Exception e) {
      selectTerm=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      for (      Path conditions1 : bqt.getConditions()) {
        ArrayList<String> temp_array=new ArrayList<String>();
        String[] tmp_array=conditions1.toString().split(""String_Node_Str"");
        for (        String s : tmp_array) {
          temp_array.add(s);
        }
        condition.add(temp_array);
      }
    }
 catch (    Exception e) {
      addTemplate=false;
    }
    try {
      for (      SPARQL_Filter tmp : bqt.getFilters())       filter=filter + tmp + ""String_Node_Str"";
    }
 catch (    Exception e) {
      filter=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      for (      SPARQL_Having tmp : bqt.getHavings())       having=having + tmp + ""String_Node_Str"";
    }
 catch (    Exception e) {
      having=""String_Node_Str"";
      addTemplate=false;
    }
    OrderBy=""String_Node_Str"";
    try {
      for (      SPARQL_Term tmp : bqt.getOrderBy()) {
        OrderBy=OrderBy + tmp + ""String_Node_Str"";
      }
      if ((bqt.getOrderBy()).size() == 0)       OrderBy=""String_Node_Str"";
    }
 catch (    Exception e) {
      OrderBy=""String_Node_Str"";
      addTemplate=false;
    }
    try {
      limit=""String_Node_Str"" + bqt.getLimit();
      if (bqt.getLimit() == 0)       limit=""String_Node_Str"";
    }
 catch (    Exception e) {
      limit=""String_Node_Str"";
      addTemplate=false;
    }
    if (addTemplate != false) {
      Template template=new Template(condition,having,filter,selectTerm,OrderBy,limit);
      ArrayList<Hypothesis> list_of_hypothesis=new ArrayList<Hypothesis>();
      for (      Slot slot : bqt.getSlots()) {
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],""String_Node_Str"",0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],""String_Node_Str"",0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
        if (slot.toString().contains(""String_Node_Str"")) {
          String tmp=slot.toString().replace(""String_Node_Str"",""String_Node_Str"");
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
          String[] tmp_array=tmp.split(""String_Node_Str"");
          Hypothesis tmp_hypothesis=new Hypothesis(""String_Node_Str"" + tmp_array[0],tmp_array[1],""String_Node_Str"",0);
          list_of_hypothesis.add(tmp_hypothesis);
        }
      }
      ArrayList<ArrayList<Hypothesis>> final_list_set_hypothesis=new ArrayList<ArrayList<Hypothesis>>();
      for (      Hypothesis x : list_of_hypothesis) {
        if (x.getType().contains(""String_Node_Str"")) {
          ArrayList<String> result=new ArrayList<String>();
          try {
            result=utils_new.searchIndex(x.getUri(),3,myindex);
          }
 catch (          SQLException e) {
            e.printStackTrace();
          }
          for (          String s : result) {
            ArrayList<Hypothesis> new_list=new ArrayList<Hypothesis>();
            for (            Hypothesis h : list_of_hypothesis) {
              if (h.getUri().equals(x.getUri())) {
                Hypothesis new_h=new Hypothesis(h.getVariable(),s,h.getType(),1);
                new_list.add(new_h);
              }
 else {
                Hypothesis new_h=new Hypothesis(h.getVariable(),h.getUri(),h.getType(),h.getRank());
                new_list.add(new_h);
              }
            }
            final_list_set_hypothesis.add(new_list);
          }
        }
      }
      for (      ArrayList<Hypothesis> x : final_list_set_hypothesis) {
        for (        Hypothesis h : x) {
          if (h.getType().contains(""String_Node_Str"") || h.getType().contains(""String_Node_Str"")) {
            ArrayList<String> result=new ArrayList<String>();
            try {
              result=utils_new.searchIndex(h.getUri(),1,myindex);
              if (!result.isEmpty()) {
                h.setUri(result.get(0));
                h.setRank(1);
              }
 else {
                String tmp=""String_Node_Str"" + h.getUri().toLowerCase();
                h.setUri(tmp);
                h.setRank(0);
              }
            }
 catch (            SQLException e) {
              e.printStackTrace();
            }
          }
        }
      }
      template.setHypothesen(final_list_set_hypothesis);
      Template template_reverse_conditions=new Template(template.getCondition(),template.getHaving(),template.getFilter(),template.getSelectTerm(),template.getOrderBy(),template.getLimit());
      ArrayList<ArrayList<String>> condition_template_reverse_conditions=template_reverse_conditions.getCondition();
      ArrayList<ArrayList<String>> condition_reverse_new=new ArrayList<ArrayList<String>>();
      for (      ArrayList<String> x : condition_template_reverse_conditions) {
        ArrayList<String> new_list=new ArrayList<String>();
        new_list.add(x.get(2));
        new_list.add(x.get(1));
        new_list.add(x.get(0));
        condition_reverse_new.add(new_list);
      }
      template_reverse_conditions.setCondition(condition_reverse_new);
      resultArrayList.add(template);
      resultArrayList.add(template_reverse_conditions);
    }
  }
  return resultArrayList;
}"
9535,"/** 
 * @param args
 * @throws SQLException 
 * @throws ClassNotFoundException 
 * @throws MalformedURLException 
 */
public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, SQLException {
  TemplateBuilder testobject=new TemplateBuilder();
  String question=""String_Node_Str"";
  testobject.createTemplates(question);
  question=""String_Node_Str"";
  testobject.createTemplates(question);
  question=""String_Node_Str"";
  testobject.createTemplates(question);
  question=""String_Node_Str"";
  testobject.createTemplates(question);
}","/** 
 * @param args
 * @throws SQLException 
 * @throws ClassNotFoundException 
 * @throws IOException 
 */
public static void main(String[] args) throws ClassNotFoundException, SQLException, IOException {
  ArrayList<Template> temp_list_result=new ArrayList<Template>();
  TemplateBuilder testobject=new TemplateBuilder();
  ArrayList<queryInformation> list_of_structs=new ArrayList<queryInformation>();
  list_of_structs=generateStruct(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  for (  queryInformation s : list_of_structs) {
    System.out.println(""String_Node_Str"");
    ArrayList<Template> temp_list=new ArrayList<Template>();
    temp_list=testobject.createTemplates(s.getQuery().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    for (    Template t : temp_list) {
      temp_list_result.add(t);
    }
  }
  String result=""String_Node_Str"";
  for (  Template t : temp_list_result) {
    result+=""String_Node_Str"";
    result+=""String_Node_Str"" + t.getCondition() + ""String_Node_Str"";
    int anzahl=1;
    for (    ArrayList<Hypothesis> x : t.getHypothesen()) {
      result+=""String_Node_Str"" + anzahl + ""String_Node_Str"";
      anzahl+=1;
      for (      Hypothesis z : x) {
        result+=""String_Node_Str"" + ""String_Node_Str"";
        result+=""String_Node_Str"" + z.getVariable() + ""String_Node_Str"";
        result+=""String_Node_Str"" + z.getUri() + ""String_Node_Str"";
        result+=""String_Node_Str"" + z.getType() + ""String_Node_Str"";
        result+=""String_Node_Str"" + z.getRank() + ""String_Node_Str"";
        result+=""String_Node_Str"" + ""String_Node_Str"";
      }
    }
    result+=""String_Node_Str"";
    result+=""String_Node_Str"" + t.getSelectTerm() + ""String_Node_Str"";
    result+=""String_Node_Str"" + t.getHaving() + ""String_Node_Str"";
    result+=""String_Node_Str"" + t.getFilter() + ""String_Node_Str"";
    result+=""String_Node_Str"" + t.getOrderBy() + ""String_Node_Str"";
    result+=""String_Node_Str"" + t.getLimit() + ""String_Node_Str"";
    result+=""String_Node_Str"";
  }
  File file=new File(""String_Node_Str"");
  BufferedWriter bw=new BufferedWriter(new FileWriter(file));
  bw.write(result);
  bw.flush();
  bw.close();
}"
9536,"@Override public OWLOntology getCoherentOntology(OWLOntology ontology,boolean preferRoots){
  this.ontology=ontology;
  this.incoherentOntology=getOntologyWithoutAnnotations(ontology);
  File diffFile=new File(new File(ontology.getOWLOntologyManager().getOntologyDocumentIRI(ontology).toURI()).getParent() + ""String_Node_Str"" + DIFF_ONTOLOGY_NAME);
  try {
    if (diffFile.exists()) {
      diffOntology=manager.loadOntologyFromOntologyDocument(diffFile);
    }
 else {
      diffOntology=manager.createOntology(IRI.create(""String_Node_Str""));
    }
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  removedTransitiveAxioms=incoherentOntology.getAxioms(AxiomType.TRANSITIVE_OBJECT_PROPERTY);
  incoherentOntology.getOWLOntologyManager().removeAxioms(incoherentOntology,removedTransitiveAxioms);
  manager=incoherentOntology.getOWLOntologyManager();
  factory=manager.getOWLDataFactory();
  long startTime=System.currentTimeMillis();
  reasoner=new IncrementalClassifier(incoherentOntology);
  reasoner.classify();
  logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
  unsatObjectProperties=getUnsatisfiableObjectProperties(reasoner);
  logger.info(""String_Node_Str"" + unsatObjectProperties.size());
  if (computeParallel) {
    entity2ModuleMap.putAll(extractModules(unsatObjectProperties));
  }
  if (preferRoots) {
    return computeCoherentOntologyRootBased(incoherentOntology);
  }
 else {
    return computeCoherentOntology(incoherentOntology);
  }
}","@Override public OWLOntology getCoherentOntology(OWLOntology ontology,boolean preferRoots){
  this.ontology=ontology;
  this.incoherentOntology=getOntologyWithoutAnnotations(ontology);
  new File(""String_Node_Str"").mkdir();
  File diffFile=new File(""String_Node_Str"" + DIFF_ONTOLOGY_NAME);
  try {
    if (diffFile.exists()) {
      diffOntology=manager.loadOntologyFromOntologyDocument(diffFile);
    }
 else {
      diffOntology=manager.createOntology(IRI.create(""String_Node_Str""));
    }
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  removedTransitiveAxioms=incoherentOntology.getAxioms(AxiomType.TRANSITIVE_OBJECT_PROPERTY);
  incoherentOntology.getOWLOntologyManager().removeAxioms(incoherentOntology,removedTransitiveAxioms);
  manager=incoherentOntology.getOWLOntologyManager();
  factory=manager.getOWLDataFactory();
  long startTime=System.currentTimeMillis();
  reasoner=new IncrementalClassifier(incoherentOntology);
  reasoner.classify();
  logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
  unsatObjectProperties=getUnsatisfiableObjectProperties(reasoner);
  logger.info(""String_Node_Str"" + unsatObjectProperties.size());
  if (computeParallel) {
    entity2ModuleMap.putAll(extractModules(unsatObjectProperties));
  }
  if (preferRoots) {
    return computeCoherentOntologyRootBased(incoherentOntology);
  }
 else {
    return computeCoherentOntology(incoherentOntology);
  }
}"
9537,"public static void main(String[] args) throws Exception {
  Logger.getRootLogger().setLevel(Level.INFO);
  Logger.getRootLogger().removeAllAppenders();
  Logger.getRootLogger().addAppender(new ConsoleAppender(new SimpleLayout()));
  Logger.getRootLogger().addAppender(new FileAppender(new SimpleLayout(),""String_Node_Str""));
  if (args.length != 3) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  String filename=args[0];
  String target=args[1];
  double stepSize=Double.parseDouble(args[2]);
  System.out.println(""String_Node_Str"");
  InputStream is=new BufferedInputStream(new FileInputStream(filename));
  if (args[0].endsWith(""String_Node_Str"")) {
    is=new CompressorStreamFactory().createCompressorInputStream(""String_Node_Str"",is);
  }
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLOntology schema=man.loadOntologyFromOntologyDocument(is);
  System.out.println(""String_Node_Str"");
  GreedyCohaerencyExtractor ge=new GreedyCohaerencyExtractor();
  ge.getCoherentOntology(schema,target,stepSize);
}","public static void main(String[] args) throws Exception {
  Logger.getRootLogger().setLevel(Level.INFO);
  Logger.getRootLogger().removeAllAppenders();
  Logger.getRootLogger().addAppender(new ConsoleAppender(new SimpleLayout()));
  Logger.getRootLogger().addAppender(new FileAppender(new SimpleLayout(),""String_Node_Str""));
  if (args.length != 3) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  String filename=args[0];
  String target=args[1];
  double stepSize=Double.parseDouble(args[2]);
  System.out.println(""String_Node_Str"");
  InputStream is=new BufferedInputStream(new FileInputStream(filename));
  if (args[0].endsWith(""String_Node_Str"")) {
    is=new CompressorStreamFactory().createCompressorInputStream(""String_Node_Str"",is);
  }
  OWLOntologyManager man=OWLManager.createOWLOntologyManager();
  OWLOntology schema=man.loadOntologyFromOntologyDocument(is);
  man.removeAxioms(schema,schema.getAxioms(AxiomType.ANNOTATION_ASSERTION));
  System.out.println(""String_Node_Str"");
  GreedyCohaerencyExtractor ge=new GreedyCohaerencyExtractor();
  ge.getCoherentOntology(schema,target,stepSize);
}"
9538,"public void setHeuristic(OEHeuristicRuntime heuristic){
  this.heuristic=heuristic;
}","@Autowired(required=false) public void setHeuristic(OEHeuristicRuntime heuristic){
  this.heuristic=heuristic;
}"
9539,"private void runSPARQL1_0_Mode(){
  Model model=ModelFactory.createDefaultModel();
  int limit=1000;
  int offset=0;
  String baseQuery=""String_Node_Str"";
  String query=String.format(baseQuery,classToDescribe.getName(),classToDescribe.getName(),limit,offset);
  System.out.println(query);
  Model newModel=executeConstructQuery(query);
  Map<NamedClass,Integer> result=new HashMap<NamedClass,Integer>();
  NamedClass cls;
  while (newModel.size() != 0) {
    model.add(newModel);
    query=""String_Node_Str"";
    ResultSet rs=executeSelectQuery(query,model);
    int total=rs.next().getLiteral(""String_Node_Str"").getInt();
    query=""String_Node_Str"" + ""String_Node_Str"";
    rs=executeSelectQuery(query,model);
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      if (qs.getResource(""String_Node_Str"") != null && !qs.getResource(""String_Node_Str"").isAnon()) {
        cls=new NamedClass(qs.getResource(""String_Node_Str"").getURI());
        int newCnt=qs.getLiteral(""String_Node_Str"").getInt();
        result.put(cls,newCnt);
      }
    }
    if (!result.isEmpty()) {
      currentlyBestEvaluatedDescriptions=buildEvaluatedClassDescriptions(result,allClasses,total);
    }
    offset+=limit;
    query=String.format(baseQuery,classToDescribe.getName(),classToDescribe.getName(),limit,offset);
    newModel=executeConstructQuery(query);
  }
}","private void runSPARQL1_0_Mode(){
  Model model=ModelFactory.createDefaultModel();
  int limit=1000;
  int offset=0;
  String baseQuery=""String_Node_Str"";
  String query=String.format(baseQuery,classToDescribe.getName(),classToDescribe.getName(),limit,offset);
  Model newModel=executeConstructQuery(query);
  Map<NamedClass,Integer> result=new HashMap<NamedClass,Integer>();
  NamedClass cls;
  while (newModel.size() != 0) {
    model.add(newModel);
    query=""String_Node_Str"";
    ResultSet rs=executeSelectQuery(query,model);
    int total=rs.next().getLiteral(""String_Node_Str"").getInt();
    query=""String_Node_Str"" + ""String_Node_Str"";
    rs=executeSelectQuery(query,model);
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      if (qs.getResource(""String_Node_Str"") != null && !qs.getResource(""String_Node_Str"").isAnon()) {
        cls=new NamedClass(qs.getResource(""String_Node_Str"").getURI());
        int newCnt=qs.getLiteral(""String_Node_Str"").getInt();
        result.put(cls,newCnt);
      }
    }
    if (!result.isEmpty()) {
      currentlyBestEvaluatedDescriptions=buildEvaluatedClassDescriptions(result,allClasses,total);
    }
    offset+=limit;
    query=String.format(baseQuery,classToDescribe.getName(),classToDescribe.getName(),limit,offset);
    newModel=executeConstructQuery(query);
  }
}"
9540,"private void runSPARQL1_0_Mode(){
  Model model=ModelFactory.createDefaultModel();
  int limit=1000;
  int offset=0;
  String baseQuery=""String_Node_Str"";
  String query=String.format(baseQuery,propertyToDescribe.getName(),limit,offset);
  Model newModel=executeConstructQuery(query);
  Map<ObjectProperty,Integer> result=new HashMap<ObjectProperty,Integer>();
  while (!terminationCriteriaSatisfied() && newModel.size() != 0) {
    model.add(newModel);
    query=""String_Node_Str"";
    ObjectProperty prop;
    Integer oldCnt;
    ResultSet rs=executeSelectQuery(query,model);
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      prop=new ObjectProperty(qs.getResource(""String_Node_Str"").getURI());
      int newCnt=qs.getLiteral(""String_Node_Str"").getInt();
      oldCnt=result.get(prop);
      if (oldCnt == null) {
        oldCnt=Integer.valueOf(newCnt);
      }
      result.put(prop,oldCnt);
      qs.getLiteral(""String_Node_Str"").getInt();
    }
    if (!result.isEmpty()) {
      currentlyBestAxioms=buildAxioms(result,allObjectProperties);
    }
    offset+=limit;
    query=String.format(baseQuery,propertyToDescribe.getName(),propertyToDescribe.getName(),limit,offset);
    newModel=executeConstructQuery(query);
  }
}","private void runSPARQL1_0_Mode(){
  Model model=ModelFactory.createDefaultModel();
  int limit=1000;
  int offset=0;
  String baseQuery=""String_Node_Str"";
  String query=String.format(baseQuery,propertyToDescribe.getName(),limit,offset);
  Model newModel=executeConstructQuery(query);
  Map<ObjectProperty,Integer> result=new HashMap<ObjectProperty,Integer>();
  while (!terminationCriteriaSatisfied() && newModel.size() != 0) {
    model.add(newModel);
    query=""String_Node_Str"";
    ObjectProperty prop;
    Integer oldCnt;
    ResultSet rs=executeSelectQuery(query,model);
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      prop=new ObjectProperty(qs.getResource(""String_Node_Str"").getURI());
      int newCnt=qs.getLiteral(""String_Node_Str"").getInt();
      oldCnt=result.get(prop);
      if (oldCnt == null) {
        oldCnt=Integer.valueOf(newCnt);
      }
      result.put(prop,oldCnt);
      qs.getLiteral(""String_Node_Str"").getInt();
    }
    if (!result.isEmpty()) {
      currentlyBestAxioms=buildAxioms(result,allObjectProperties);
    }
    offset+=limit;
    query=String.format(baseQuery,propertyToDescribe.getName(),limit,offset);
    newModel=executeConstructQuery(query);
  }
}"
9541,"public Set<NamedClass> getAllClasses(){
  Set<NamedClass> classes=new TreeSet<NamedClass>();
  String query=""String_Node_Str"";
  SparqlQuery sq=new SparqlQuery(query,sparqlEndpoint);
  ResultSet q=sq.send(false);
  while (q.hasNext()) {
    QuerySolution qs=q.next();
    if (qs.getResource(""String_Node_Str"").isURIResource()) {
      classes.add(new NamedClass(qs.getResource(""String_Node_Str"").getURI()));
    }
  }
  classes.remove(OWL.Nothing.toStringID());
  classes.remove(OWL.Thing.toStringID());
  return classes;
}","public Set<NamedClass> getAllClasses(){
  Set<NamedClass> classes=new TreeSet<NamedClass>();
  String query=""String_Node_Str"";
  SparqlQuery sq=new SparqlQuery(query,sparqlEndpoint);
  ResultSet q=sq.send(false);
  while (q.hasNext()) {
    QuerySolution qs=q.next();
    if (qs.getResource(""String_Node_Str"").isURIResource()) {
      classes.add(new NamedClass(qs.getResource(""String_Node_Str"").getURI()));
    }
  }
  classes.remove(new NamedClass(OWL.Nothing.toStringID()));
  classes.remove(new NamedClass(OWL.Thing.toStringID()));
  return classes;
}"
9542,"@Override public void start(){
  stop=false;
  isRunning=true;
  reset();
  treeStartTime=System.nanoTime();
  ELDescriptionTree top=new ELDescriptionTree(reasoner,Thing.instance);
  addDescriptionTree(top,null);
  int loop=0;
  while (!stop && !stoppingCriteriaSatisfied()) {
    SearchTreeNode best=candidates.pollLast();
    List<ELDescriptionTree> refinements=operator.refine(best.getDescriptionTree());
    for (    ELDescriptionTree refinement : refinements) {
      addDescriptionTree(refinement,best);
    }
    loop++;
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + best);
      logger.trace(startNode.getTreeString());
      logger.trace(""String_Node_Str"" + loop + ""String_Node_Str"");
    }
  }
  logger.info(""String_Node_Str"" + bestEvaluatedDescriptions.getBest());
  isRunning=false;
}","@Override public void start(){
  stop=false;
  isRunning=true;
  reset();
  treeStartTime=System.nanoTime();
  ELDescriptionTree top=new ELDescriptionTree(reasoner,Thing.instance);
  addDescriptionTree(top,null);
  int loop=0;
  while (!stop && !stoppingCriteriaSatisfied()) {
    SearchTreeNode best=candidates.pollLast();
    List<ELDescriptionTree> refinements=operator.refine(best.getDescriptionTree());
    for (    ELDescriptionTree refinement : refinements) {
      addDescriptionTree(refinement,best);
    }
    loop++;
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + best);
      logger.trace(startNode.getTreeString());
      logger.trace(""String_Node_Str"" + loop + ""String_Node_Str"");
    }
  }
  logger.info(""String_Node_Str"" + bestEvaluatedDescriptions.getBest() + ""String_Node_Str""+ Helper.prettyPrintNanoSeconds(System.nanoTime() - treeStartTime)+ ""String_Node_Str"");
  isRunning=false;
}"
9543,"private boolean stoppingCriteriaSatisfied(){
  if (bestCurrentScore <= minimumTreeScore) {
    return true;
  }
  int maxPosRemaining=(int)Math.ceil(startPosExamplesSize * 0.05d);
  return (currentPosExamples.size() <= maxPosRemaining);
}","private boolean stoppingCriteriaSatisfied(){
  if (currentPosExamples.size() == 0) {
    return true;
  }
  if (bestCurrentScore <= minimumTreeScore) {
    return true;
  }
  if (tryFullCoverage) {
    return false;
  }
 else {
    int maxPosRemaining=(int)Math.ceil(startPosExamplesSize * 0.05d);
    return (currentPosExamples.size() <= maxPosRemaining);
  }
}"
9544,"@Override public void start(){
  stop=false;
  isRunning=true;
  reset();
  int treeCount=0;
  while (!stop && !stoppingCriteriaSatisfied()) {
    treeStartTime=System.nanoTime();
    ELDescriptionTree startTree=new ELDescriptionTree(reasoner,startClass);
    addDescriptionTree(startTree,null);
    bestCurrentScore=Double.NEGATIVE_INFINITY;
    int loop=0;
    while (!stop && !treeCriteriaSatisfied()) {
      SearchTreeNode best=candidates.pollLast();
      List<ELDescriptionTree> refinements=operator.refine(best.getDescriptionTree());
      for (      ELDescriptionTree refinement : refinements) {
        addDescriptionTree(refinement,best);
      }
      loop++;
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + best);
        logger.trace(startNode.getTreeString());
        logger.trace(""String_Node_Str"" + loop + ""String_Node_Str"");
      }
    }
    if (bestCurrentScore > minimumTreeScore) {
      currentSolution.add(bestCurrentNode.getDescriptionTree());
      Description bestDescription=bestCurrentNode.getDescriptionTree().transformToDescription();
      if (treeCount == 0) {
        bestEvaluatedDescription=learningProblem.evaluate(bestDescription);
      }
 else {
        Union union=new Union(bestEvaluatedDescription.getDescription(),bestDescription);
        bestEvaluatedDescription=learningProblem.evaluate(union);
      }
      Iterator<Individual> it=currentPosExamples.iterator();
      int posCov=0;
      while (it.hasNext()) {
        Individual ind=it.next();
        if (reasoner.hasType(bestDescription,ind)) {
          it.remove();
          posCov++;
        }
      }
      it=currentNegExamples.iterator();
      int negCov=0;
      while (it.hasNext()) {
        Individual ind=it.next();
        if (reasoner.hasType(bestDescription,ind)) {
          it.remove();
          negCov++;
        }
      }
      logger.info(""String_Node_Str"" + bestDescription.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ posCov+ ""String_Node_Str""+ currentPosExamples.size()+ ""String_Node_Str""+ negCov+ ""String_Node_Str""+ currentNegExamples.size()+ ""String_Node_Str""+ bestCurrentNode.getScore()+ ""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"" + bestCurrentNode.getDescriptionTree().transformToDescription().toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ bestCurrentNode.getScore());
    }
    logger.info(trees.size() + ""String_Node_Str"");
    posWeight=Math.max(1.0,posWeight - 0.1);
    candidates.clear();
    trees.clear();
    treeCount++;
  }
  Description niceDescription=minimizer.minimizeClone(bestEvaluatedDescription.getDescription());
  bestEvaluatedDescription=learningProblem.evaluate(niceDescription);
  logger.info(""String_Node_Str"" + bestEvaluatedDescription.getDescription().toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ bestEvaluatedDescription.getAccuracy()+ ""String_Node_Str"");
  isRunning=false;
}","@Override public void start(){
  stop=false;
  isRunning=true;
  reset();
  int treeCount=0;
  while (!stop && !stoppingCriteriaSatisfied()) {
    treeStartTime=System.nanoTime();
    ELDescriptionTree startTree=new ELDescriptionTree(reasoner,startClass);
    addDescriptionTree(startTree,null);
    bestCurrentScore=Double.NEGATIVE_INFINITY;
    int loop=0;
    while (!stop && !treeCriteriaSatisfied()) {
      SearchTreeNode best=candidates.pollLast();
      List<ELDescriptionTree> refinements=operator.refine(best.getDescriptionTree());
      for (      ELDescriptionTree refinement : refinements) {
        addDescriptionTree(refinement,best);
      }
      loop++;
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + best);
        logger.trace(startNode.getTreeString());
        logger.trace(""String_Node_Str"" + loop + ""String_Node_Str"");
      }
    }
    if (bestCurrentScore > minimumTreeScore) {
      currentSolution.add(bestCurrentNode.getDescriptionTree());
      Description bestDescription=bestCurrentNode.getDescriptionTree().transformToDescription();
      Description bestCombinedDescription=bestDescription;
      if (treeCount == 0) {
        bestEvaluatedDescription=learningProblem.evaluate(bestDescription);
      }
 else {
        bestCombinedDescription=new Union(bestEvaluatedDescription.getDescription(),bestDescription);
        bestEvaluatedDescription=learningProblem.evaluate(bestCombinedDescription);
      }
      Iterator<Individual> it=currentPosExamples.iterator();
      int posCov=0;
      while (it.hasNext()) {
        Individual ind=it.next();
        if (reasoner.hasType(bestDescription,ind)) {
          it.remove();
          posCov++;
        }
      }
      it=currentNegExamples.iterator();
      int negCov=0;
      while (it.hasNext()) {
        Individual ind=it.next();
        if (reasoner.hasType(bestDescription,ind)) {
          it.remove();
          negCov++;
        }
      }
      logger.info(""String_Node_Str"" + bestDescription.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ posCov+ ""String_Node_Str""+ currentPosExamples.size()+ ""String_Node_Str""+ negCov+ ""String_Node_Str""+ currentNegExamples.size()+ ""String_Node_Str""+ bestCurrentNode.getScore()+ ""String_Node_Str"");
      logger.info(""String_Node_Str"" + df.format(bestEvaluatedDescription.getAccuracy()));
    }
 else {
      logger.info(""String_Node_Str"" + bestCurrentNode.getDescriptionTree().transformToDescription().toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ bestCurrentNode.getScore());
    }
    logger.info(trees.size() + ""String_Node_Str"");
    posWeight=Math.max(1.0,posWeight - 0.1);
    candidates.clear();
    trees.clear();
    treeCount++;
  }
  Description niceDescription=minimizer.minimizeClone(bestEvaluatedDescription.getDescription());
  bestEvaluatedDescription=learningProblem.evaluate(niceDescription);
  logger.info(""String_Node_Str"" + bestEvaluatedDescription.getDescription().toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ bestEvaluatedDescription.getAccuracy()+ ""String_Node_Str"");
  isRunning=false;
}"
9545,"private void reset(){
  candidates.clear();
  trees.clear();
  currentSolution.clear();
  bestEvaluatedDescription=learningProblem.evaluate(Thing.instance);
  currentPosExamples=((PosNegLP)getLearningProblem()).getPositiveExamples();
  currentNegExamples=((PosNegLP)getLearningProblem()).getNegativeExamples();
  startPosExamplesSize=currentPosExamples.size();
}","private void reset(){
  candidates.clear();
  trees.clear();
  currentSolution.clear();
  bestEvaluatedDescription=learningProblem.evaluate(Thing.instance);
  currentPosExamples=new TreeSet<Individual>(((PosNegLP)getLearningProblem()).getPositiveExamples());
  currentNegExamples=new TreeSet<Individual>(((PosNegLP)getLearningProblem()).getNegativeExamples());
  startPosExamplesSize=currentPosExamples.size();
}"
9546,"private void runSPARQL1_0_Mode(){
  Model model=ModelFactory.createDefaultModel();
  int limit=1000;
  int offset=0;
  String baseQuery=""String_Node_Str"";
  String query=String.format(baseQuery,classToDescribe.getName(),classToDescribe.getName(),limit,offset);
  System.out.println(query);
  Model newModel=executeConstructQuery(query);
  Map<NamedClass,Integer> result=new HashMap<NamedClass,Integer>();
  NamedClass cls;
  Integer oldCnt;
  while (newModel.size() != 0) {
    model.add(newModel);
    query=""String_Node_Str"";
    ResultSet rs=executeSelectQuery(query,model);
    int total=rs.next().getLiteral(""String_Node_Str"").getInt();
    query=""String_Node_Str"" + ""String_Node_Str"";
    rs=executeSelectQuery(query,model);
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      System.out.println(qs);
      if (qs.getResource(""String_Node_Str"") != null && !qs.getResource(""String_Node_Str"").isAnon()) {
        cls=new NamedClass(qs.getResource(""String_Node_Str"").getURI());
        int newCnt=qs.getLiteral(""String_Node_Str"").getInt();
        oldCnt=result.get(cls);
        if (oldCnt == null) {
          oldCnt=Integer.valueOf(newCnt);
        }
 else {
          oldCnt+=newCnt;
        }
        result.put(cls,oldCnt);
      }
    }
    if (!result.isEmpty()) {
      currentlyBestEvaluatedDescriptions=buildEvaluatedClassDescriptions(result,allClasses,total);
    }
    offset+=limit;
    query=String.format(baseQuery,classToDescribe.getName(),classToDescribe.getName(),limit,offset);
    newModel=executeConstructQuery(query);
  }
}","private void runSPARQL1_0_Mode(){
  Model model=ModelFactory.createDefaultModel();
  int limit=1000;
  int offset=0;
  String baseQuery=""String_Node_Str"";
  String query=String.format(baseQuery,classToDescribe.getName(),classToDescribe.getName(),limit,offset);
  System.out.println(query);
  Model newModel=executeConstructQuery(query);
  Map<NamedClass,Integer> result=new HashMap<NamedClass,Integer>();
  NamedClass cls;
  while (newModel.size() != 0) {
    model.add(newModel);
    query=""String_Node_Str"";
    ResultSet rs=executeSelectQuery(query,model);
    int total=rs.next().getLiteral(""String_Node_Str"").getInt();
    query=""String_Node_Str"" + ""String_Node_Str"";
    rs=executeSelectQuery(query,model);
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      if (qs.getResource(""String_Node_Str"") != null && !qs.getResource(""String_Node_Str"").isAnon()) {
        cls=new NamedClass(qs.getResource(""String_Node_Str"").getURI());
        int newCnt=qs.getLiteral(""String_Node_Str"").getInt();
        result.put(cls,newCnt);
      }
    }
    if (!result.isEmpty()) {
      currentlyBestEvaluatedDescriptions=buildEvaluatedClassDescriptions(result,allClasses,total);
    }
    offset+=limit;
    query=String.format(baseQuery,classToDescribe.getName(),classToDescribe.getName(),limit,offset);
    newModel=executeConstructQuery(query);
  }
}"
9547,"private void runSPARQL1_1_Mode(){
  int limit=1000;
  int offset=0;
  String queryTemplate=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String query;
  Map<DatatypeProperty,Integer> result=new HashMap<DatatypeProperty,Integer>();
  DatatypeProperty prop;
  Integer oldCnt;
  boolean repeat=true;
  ResultSet rs=null;
  while (!terminationCriteriaSatisfied() && repeat) {
    query=String.format(queryTemplate,propertyToDescribe,limit,offset);
    rs=executeSelectQuery(query);
    QuerySolution qs;
    repeat=false;
    while (rs.hasNext()) {
      qs=rs.next();
      prop=new DatatypeProperty(qs.getResource(""String_Node_Str"").getURI());
      int newCnt=qs.getLiteral(""String_Node_Str"").getInt();
      oldCnt=result.get(prop);
      if (oldCnt == null) {
        oldCnt=Integer.valueOf(newCnt);
      }
      result.put(prop,oldCnt);
      qs.getLiteral(""String_Node_Str"").getInt();
      repeat=true;
    }
    if (!result.isEmpty()) {
      currentlyBestAxioms=buildAxioms(result,allDataProperties);
      offset+=1000;
    }
  }
}","private void runSPARQL1_1_Mode(){
  int limit=1000;
  int offset=0;
  String queryTemplate=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String query;
  Map<DatatypeProperty,Integer> result=new HashMap<DatatypeProperty,Integer>();
  DatatypeProperty prop;
  Integer oldCnt;
  boolean repeat=true;
  ResultSet rs=null;
  while (!terminationCriteriaSatisfied() && repeat) {
    query=String.format(queryTemplate,propertyToDescribe,limit,offset);
    rs=executeSelectQuery(query);
    QuerySolution qs;
    repeat=false;
    while (rs.hasNext()) {
      qs=rs.next();
      prop=new DatatypeProperty(qs.getResource(""String_Node_Str"").getURI());
      int newCnt=qs.getLiteral(""String_Node_Str"").getInt();
      oldCnt=result.get(prop);
      if (oldCnt == null) {
        oldCnt=Integer.valueOf(newCnt);
      }
      result.put(prop,oldCnt);
      repeat=true;
    }
    if (!result.isEmpty()) {
      currentlyBestAxioms=buildAxioms(result,allDataProperties);
      offset+=1000;
    }
  }
}"
9548,"private void runSPARQL1_0_Mode(){
  Model model=ModelFactory.createDefaultModel();
  int limit=1000;
  int offset=0;
  String baseQuery=""String_Node_Str"";
  String query=String.format(baseQuery,propertyToDescribe.getName(),limit,offset);
  Model newModel=executeConstructQuery(query);
  Map<ObjectProperty,Integer> result=new HashMap<ObjectProperty,Integer>();
  while (!terminationCriteriaSatisfied() && newModel.size() != 0) {
    model.add(newModel);
    query=""String_Node_Str"";
    ObjectProperty prop;
    Integer oldCnt;
    ResultSet rs=executeSelectQuery(query,model);
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      prop=new ObjectProperty(qs.getResource(""String_Node_Str"").getURI());
      int newCnt=qs.getLiteral(""String_Node_Str"").getInt();
      oldCnt=result.get(prop);
      if (oldCnt == null) {
        oldCnt=Integer.valueOf(newCnt);
      }
      result.put(prop,oldCnt);
      qs.getLiteral(""String_Node_Str"").getInt();
    }
    if (!result.isEmpty()) {
      currentlyBestAxioms=buildAxioms(result);
    }
    offset+=limit;
    query=String.format(baseQuery,propertyToDescribe.getName(),propertyToDescribe.getName(),limit,offset);
    newModel=executeConstructQuery(query);
  }
}","private void runSPARQL1_0_Mode(){
  Model model=ModelFactory.createDefaultModel();
  int limit=1000;
  int offset=0;
  String baseQuery=""String_Node_Str"";
  String query=String.format(baseQuery,propertyToDescribe.getName(),limit,offset);
  Model newModel=executeConstructQuery(query);
  Map<ObjectProperty,Integer> result=new HashMap<ObjectProperty,Integer>();
  while (!terminationCriteriaSatisfied() && newModel.size() != 0) {
    model.add(newModel);
    query=""String_Node_Str"";
    ObjectProperty prop;
    Integer oldCnt;
    ResultSet rs=executeSelectQuery(query,model);
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      prop=new ObjectProperty(qs.getResource(""String_Node_Str"").getURI());
      int newCnt=qs.getLiteral(""String_Node_Str"").getInt();
      oldCnt=result.get(prop);
      if (oldCnt == null) {
        oldCnt=Integer.valueOf(newCnt);
      }
      result.put(prop,oldCnt);
      qs.getLiteral(""String_Node_Str"").getInt();
    }
    if (!result.isEmpty()) {
      currentlyBestAxioms=buildAxioms(result);
    }
    offset+=limit;
    query=String.format(baseQuery,propertyToDescribe.getName(),limit,offset);
    newModel=executeConstructQuery(query);
  }
}"
9549,"private void runSPARQL1_0_Mode(){
  Model model=ModelFactory.createDefaultModel();
  int limit=1000;
  int offset=0;
  String baseQuery=""String_Node_Str"";
  String query=String.format(baseQuery,propertyToDescribe.getName(),limit,offset);
  Model newModel=executeConstructQuery(query);
  Map<ObjectProperty,Integer> result=new HashMap<ObjectProperty,Integer>();
  while (!terminationCriteriaSatisfied() && newModel.size() != 0) {
    model.add(newModel);
    query=""String_Node_Str"";
    ObjectProperty prop;
    Integer oldCnt;
    ResultSet rs=executeSelectQuery(query,model);
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      prop=new ObjectProperty(qs.getResource(""String_Node_Str"").getURI());
      int newCnt=qs.getLiteral(""String_Node_Str"").getInt();
      oldCnt=result.get(prop);
      if (oldCnt == null) {
        oldCnt=Integer.valueOf(newCnt);
      }
      result.put(prop,oldCnt);
      qs.getLiteral(""String_Node_Str"").getInt();
    }
    if (!result.isEmpty()) {
      currentlyBestAxioms=buildAxioms(result);
    }
    offset+=limit;
    query=String.format(baseQuery,propertyToDescribe.getName(),propertyToDescribe.getName(),limit,offset);
    newModel=executeConstructQuery(query);
  }
}","private void runSPARQL1_0_Mode(){
  Model model=ModelFactory.createDefaultModel();
  int limit=1000;
  int offset=0;
  String baseQuery=""String_Node_Str"";
  String query=String.format(baseQuery,propertyToDescribe.getName(),limit,offset);
  Model newModel=executeConstructQuery(query);
  Map<ObjectProperty,Integer> result=new HashMap<ObjectProperty,Integer>();
  while (!terminationCriteriaSatisfied() && newModel.size() != 0) {
    model.add(newModel);
    query=""String_Node_Str"";
    ObjectProperty prop;
    Integer oldCnt;
    ResultSet rs=executeSelectQuery(query,model);
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      prop=new ObjectProperty(qs.getResource(""String_Node_Str"").getURI());
      int newCnt=qs.getLiteral(""String_Node_Str"").getInt();
      oldCnt=result.get(prop);
      if (oldCnt == null) {
        oldCnt=Integer.valueOf(newCnt);
      }
      result.put(prop,oldCnt);
      qs.getLiteral(""String_Node_Str"").getInt();
    }
    if (!result.isEmpty()) {
      currentlyBestAxioms=buildAxioms(result);
    }
    offset+=limit;
    query=String.format(baseQuery,propertyToDescribe.getName(),limit,offset);
    newModel=executeConstructQuery(query);
  }
}"
9550,"@Override public String toManchesterSyntaxString(String baseURI,Map<String,String> prefixes){
  return ""String_Node_Str"";
}","@Override public String toManchesterSyntaxString(String baseURI,Map<String,String> prefixes){
  return role.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"" + inverseRole.toManchesterSyntaxString(baseURI,prefixes);
}"
9551,"@Override public void init() throws ComponentInitException {
  if (endpoint == null) {
    endpoint=new SparqlEndpoint(url,defaultGraphURIs,namedGraphURIs);
  }
  supportsSPARQL_1_1=new SPARQLTasks(endpoint).supportsSPARQL_1_1();
}","@Override public void init() throws ComponentInitException {
  if (!initialized) {
    if (endpoint == null) {
      endpoint=new SparqlEndpoint(url,defaultGraphURIs,namedGraphURIs);
    }
    supportsSPARQL_1_1=new SPARQLTasks(endpoint).supportsSPARQL_1_1();
    initialized=true;
  }
}"
9552,"/** 
 * Converts Jena result set to JSON.
 * @param resultSet The result set to transform, must be rewindable to prevent errors.
 * @return JSON representation of the result set.
 */
public static String convertResultSetToJSON(ResultSetRewindable resultSet){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  ResultSetFormatter.outputAsJSON(baos,resultSet);
  resultSet.reset();
  try {
    return baos.toString(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new Error(e);
  }
}","/** 
 * Converts Jena result set to JSON.
 * @param resultSet The result set to transform, must be rewindable to prevent errors.
 * @return JSON representation of the result set.
 */
public static String convertResultSetToJSON(ResultSet resultSet){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  ResultSetFormatter.outputAsJSON(baos,resultSet);
  try {
    return baos.toString(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new Error(e);
  }
}"
9553,"public int getPropertyCount(ObjectProperty property){
  String query=String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",property.getName());
  ResultSet rs=executeSelectQuery(query);
  int cnt=rs.next().get(rs.getResultVars().get(0)).asLiteral().getInt();
  return cnt;
}","public int getPropertyCount(ObjectProperty property){
  String query=String.format(""String_Node_Str"",property.getName());
  ResultSet rs=executeSelectQuery(query);
  int cnt=rs.next().get(rs.getResultVars().get(0)).asLiteral().getInt();
  return cnt;
}"
9554,"public SortedSet<ObjectProperty> getInverseObjectProperties(ObjectProperty property){
  SortedSet<ObjectProperty> inverseObjectProperties=new TreeSet<ObjectProperty>();
  String query=""String_Node_Str"" + ""String_Node_Str"".replace(""String_Node_Str"",property.getName()).replace(""String_Node_Str"",OWL.inverseOf.getURI());
  System.out.println(query);
  ResultSet rs=executeSelectQuery(query);
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    inverseObjectProperties.add(new ObjectProperty(qs.getResource(""String_Node_Str"").getURI()));
  }
  return inverseObjectProperties;
}","public SortedSet<ObjectProperty> getInverseObjectProperties(ObjectProperty property){
  SortedSet<ObjectProperty> inverseObjectProperties=new TreeSet<ObjectProperty>();
  String query=""String_Node_Str"" + ""String_Node_Str"".replace(""String_Node_Str"",property.getName()).replace(""String_Node_Str"",OWL.inverseOf.getURI());
  ResultSet rs=executeSelectQuery(query);
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    inverseObjectProperties.add(new ObjectProperty(qs.getResource(""String_Node_Str"").getURI()));
  }
  return inverseObjectProperties;
}"
9555,"@Override public OWLOntology getCoherentOntology(OWLOntology ontology){
  this.ontology=ontology;
  ontology.getOWLOntologyManager().removeAxioms(ontology,ontology.getAxioms(AxiomType.TRANSITIVE_OBJECT_PROPERTY));
  this.incoherentOntology=getOntologyWithoutAnnotations(ontology);
  reasoner=new IncrementalClassifier(incoherentOntology);
  reasoner.classify();
  OWLOntologyManager man=incoherentOntology.getOWLOntologyManager();
  StructureBasedRootClassFinder rootFinder=new StructureBasedRootClassFinder(reasoner);
  rootFinder.computeRootDerivedClasses();
  Set<OWLClass> unsatClasses=rootFinder.getRootUnsatisfiableClasses();
  int cnt=unsatClasses.size();
  if (unsatClasses.isEmpty()) {
    return incoherentOntology;
  }
  cls2ModuleMap=extractModules(unsatClasses);
  Map<OWLClass,Set<Set<OWLAxiom>>> cls2Explanations=getInitialExplanationsForUnsatClasses(unsatClasses);
  while (!unsatClasses.isEmpty()) {
    Map<OWLAxiom,Integer> axiom2CountMap=getAxiomFrequency(cls2Explanations);
    List<Entry<OWLAxiom,Integer>> sortedEntries=MapUtils.sortByValues(axiom2CountMap);
    for (    Entry<OWLAxiom,Integer> entry : sortedEntries) {
      System.out.println(entry.getKey() + ""String_Node_Str"" + entry.getValue());
    }
    OWLAxiom toRemove=sortedEntries.get(0).getKey();
    System.out.println(""String_Node_Str"" + toRemove);
    man.removeAxiom(incoherentOntology,toRemove);
    man.applyChange(new RemoveAxiom(incoherentOntology,toRemove));
    removeFromExplanations(cls2Explanations,toRemove);
    removeFromModules(toRemove);
    reasoner.classify();
    rootFinder=new StructureBasedRootClassFinder(reasoner);
    rootFinder.computeRootDerivedClasses();
    unsatClasses=rootFinder.getRootUnsatisfiableClasses();
    System.out.println(""String_Node_Str"" + unsatClasses.size());
    if (cnt - unsatClasses.size() >= 10) {
      OWLOntology toSave=getOntologyWithAnnotations(incoherentOntology);
      try {
        toSave.getOWLOntologyManager().saveOntology(incoherentOntology,new RDFXMLOntologyFormat(),new BufferedOutputStream(new FileOutputStream(""String_Node_Str"" + unsatClasses.size() + ""String_Node_Str"")));
      }
 catch (      OWLOntologyStorageException e) {
        e.printStackTrace();
      }
catch (      FileNotFoundException e) {
        e.printStackTrace();
      }
      cnt=unsatClasses.size();
    }
    refillExplanations(unsatClasses,cls2Explanations);
    System.gc();
  }
  try {
    incoherentOntology.getOWLOntologyManager().saveOntology(incoherentOntology,new RDFXMLOntologyFormat(),new BufferedOutputStream(new FileOutputStream(""String_Node_Str"")));
  }
 catch (  OWLOntologyStorageException e) {
    e.printStackTrace();
  }
catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
  System.out.println(incoherentOntology.getLogicalAxiomCount());
  return getOntologyWithAnnotations(incoherentOntology);
}","@Override public OWLOntology getCoherentOntology(OWLOntology ontology){
  this.ontology=ontology;
  ontology.getOWLOntologyManager().removeAxioms(ontology,ontology.getAxioms(AxiomType.TRANSITIVE_OBJECT_PROPERTY));
  this.incoherentOntology=getOntologyWithoutAnnotations(ontology);
  reasoner=new IncrementalClassifier(incoherentOntology);
  reasoner.classify();
  OWLOntologyManager man=incoherentOntology.getOWLOntologyManager();
  StructureBasedRootClassFinder rootFinder=new StructureBasedRootClassFinder(reasoner);
  rootFinder.computeRootDerivedClasses();
  Set<OWLClass> unsatClasses=rootFinder.getRootUnsatisfiableClasses();
  Set<OWLClass> derivedUnsatClasses=rootFinder.getDerivedUnsatisfiableClasses();
  int rootCnt=unsatClasses.size();
  int derivedCnt=derivedUnsatClasses.size();
  int cnt=rootCnt + derivedCnt;
  logger.info(""String_Node_Str"" + cnt + ""String_Node_Str""+ rootCnt+ ""String_Node_Str"");
  if (unsatClasses.isEmpty()) {
    return incoherentOntology;
  }
  logger.info(""String_Node_Str"");
  cls2ModuleMap=extractModules(unsatClasses);
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  Map<OWLClass,Set<Set<OWLAxiom>>> cls2Explanations=getInitialExplanationsForUnsatClasses(unsatClasses);
  logger.info(""String_Node_Str"");
  while (!unsatClasses.isEmpty()) {
    Map<OWLAxiom,Integer> axiom2CountMap=getAxiomFrequency(cls2Explanations);
    List<Entry<OWLAxiom,Integer>> sortedEntries=MapUtils.sortByValues(axiom2CountMap);
    for (    Entry<OWLAxiom,Integer> entry : sortedEntries) {
      System.out.println(entry.getKey() + ""String_Node_Str"" + entry.getValue());
    }
    OWLAxiom toRemove=sortedEntries.get(0).getKey();
    logger.info(""String_Node_Str"" + toRemove + ""String_Node_Str"");
    man.removeAxiom(incoherentOntology,toRemove);
    man.applyChange(new RemoveAxiom(incoherentOntology,toRemove));
    removeFromExplanations(cls2Explanations,toRemove);
    removeFromModules(toRemove);
    reasoner.classify();
    rootFinder=new StructureBasedRootClassFinder(reasoner);
    rootFinder.computeRootDerivedClasses();
    unsatClasses=rootFinder.getRootUnsatisfiableClasses();
    rootCnt=unsatClasses.size();
    derivedUnsatClasses=rootFinder.getDerivedUnsatisfiableClasses();
    derivedCnt=derivedUnsatClasses.size();
    logger.info(""String_Node_Str"" + (rootCnt + derivedCnt) + ""String_Node_Str""+ rootCnt+ ""String_Node_Str"");
    if (cnt - (rootCnt + derivedCnt) >= 10) {
      cnt=rootCnt + derivedCnt;
      OWLOntology toSave=getOntologyWithAnnotations(incoherentOntology);
      try {
        toSave.getOWLOntologyManager().saveOntology(incoherentOntology,new RDFXMLOntologyFormat(),new BufferedOutputStream(new FileOutputStream(""String_Node_Str"" + cnt + ""String_Node_Str"")));
      }
 catch (      OWLOntologyStorageException e) {
        e.printStackTrace();
      }
catch (      FileNotFoundException e) {
        e.printStackTrace();
      }
      cnt=rootCnt + derivedCnt;
    }
    logger.info(""String_Node_Str"");
    refillExplanations(unsatClasses,cls2Explanations);
    logger.info(""String_Node_Str"");
    System.gc();
  }
  try {
    incoherentOntology.getOWLOntologyManager().saveOntology(incoherentOntology,new RDFXMLOntologyFormat(),new BufferedOutputStream(new FileOutputStream(""String_Node_Str"")));
  }
 catch (  OWLOntologyStorageException e) {
    e.printStackTrace();
  }
catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
  System.out.println(incoherentOntology.getLogicalAxiomCount());
  return getOntologyWithAnnotations(incoherentOntology);
}"
9556,"@Override public void init() throws ComponentInitException {
  Set<NamedClass> usedConcepts;
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  classHierarchy.thinOutSubsumptionHierarchy();
  if (heuristic == null) {
    heuristic=new OEHeuristicRuntime();
  }
  minimizer=new DescriptionMinimizer(reasoner);
  if (startClass == null) {
    startClass=Thing.instance;
  }
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setStartClass(startClass);
    ((RhoDRDown)operator).setReasoner(reasoner);
  }
  ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
  ((RhoDRDown)operator).setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  ((RhoDRDown)operator).setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  ((RhoDRDown)operator).init();
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  if (writeSearchTree) {
    File f=new File(searchTreeFile);
    Files.clearFile(f);
  }
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(maxNrOfResults);
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=noisePercentage / 100d;
  filterFollowsFromKB=filterDescriptionsFollowingFromKB && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (reuseExistingDescription && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}","@Override public void init() throws ComponentInitException {
  Set<NamedClass> usedConcepts;
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  classHierarchy.thinOutSubsumptionHierarchy();
  if (heuristic == null) {
    heuristic=new OEHeuristicRuntime();
  }
  minimizer=new DescriptionMinimizer(reasoner);
  if (startClass == null) {
    startClass=Thing.instance;
  }
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setStartClass(startClass);
    ((RhoDRDown)operator).setReasoner(reasoner);
    ((RhoDRDown)operator).init();
  }
  ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
  ((RhoDRDown)operator).setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  ((RhoDRDown)operator).setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  if (writeSearchTree) {
    File f=new File(searchTreeFile);
    Files.clearFile(f);
  }
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(maxNrOfResults);
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=noisePercentage / 100d;
  filterFollowsFromKB=filterDescriptionsFollowingFromKB && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (reuseExistingDescription && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}"
9557,"@Override public void init() throws ComponentInitException {
  Set<NamedClass> usedConcepts;
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  classHierarchy.thinOutSubsumptionHierarchy();
  if (heuristic == null) {
    heuristic=new OEHeuristicRuntime();
  }
  minimizer=new DescriptionMinimizer(reasoner);
  if (startClass == null) {
    startClass=Thing.instance;
  }
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setStartClass(startClass);
    ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
    ((RhoDRDown)operator).setReasoner(reasoner);
    ((RhoDRDown)operator).init();
  }
 else {
    ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
  }
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  if (writeSearchTree) {
    File f=new File(searchTreeFile);
    Files.clearFile(f);
  }
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(maxNrOfResults);
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=noisePercentage / 100d;
  filterFollowsFromKB=filterDescriptionsFollowingFromKB && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (reuseExistingDescription && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}","@Override public void init() throws ComponentInitException {
  Set<NamedClass> usedConcepts;
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  classHierarchy.thinOutSubsumptionHierarchy();
  if (heuristic == null) {
    heuristic=new OEHeuristicRuntime();
  }
  minimizer=new DescriptionMinimizer(reasoner);
  if (startClass == null) {
    startClass=Thing.instance;
  }
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setStartClass(startClass);
    ((RhoDRDown)operator).setReasoner(reasoner);
  }
  ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
  ((RhoDRDown)operator).setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  ((RhoDRDown)operator).setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  ((RhoDRDown)operator).init();
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  if (writeSearchTree) {
    File f=new File(searchTreeFile);
    Files.clearFile(f);
  }
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(maxNrOfResults);
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=noisePercentage / 100d;
  filterFollowsFromKB=filterDescriptionsFollowingFromKB && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (reuseExistingDescription && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}"
9558,"@Override public void init() throws ComponentInitException {
  if (getReasoner().getReasonerType() == ReasonerType.DIG) {
    throw new ComponentInitException(""String_Node_Str"" + getName());
  }
  if (!logLevel.equals(CommonConfigOptions.logLevelDefault))   logger.setLevel(Level.toLevel(logLevel,Level.toLevel(CommonConfigOptions.logLevelDefault)));
  if (searchTreeFile == null)   searchTreeFile=new File(defaultSearchTreeFile);
  if (writeSearchTree)   Files.clearFile(searchTreeFile);
  if (heuristic == null) {
    if (heuristicStr == ""String_Node_Str"")     heuristic=new LexicographicHeuristic();
 else     if (heuristicStr == ""String_Node_Str"") {
      if (learningProblem instanceof PosOnlyLP) {
        throw new RuntimeException(""String_Node_Str"");
      }
      heuristic=new FlexibleHeuristic(((PosNegLP)getLearningProblem()).getNegativeExamples().size(),((PosNegLP)getLearningProblem()).getPercentPerLengthUnit());
    }
 else {
      if (getLearningProblem() instanceof PosOnlyLP) {
        throw new RuntimeException(""String_Node_Str"");
      }
 else {
        heuristic=new MultiHeuristic(((PosNegLP)getLearningProblem()).getPositiveExamples().size(),((PosNegLP)getLearningProblem()).getNegativeExamples().size(),negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
      }
    }
  }
  if (learningProblem instanceof PosNegLPStandard) {
    if (((PosNegLPStandard)learningProblem).isUseApproximations()) {
      System.err.println(""String_Node_Str"");
    }
    if (!((PosNegLPStandard)learningProblem).getAccuracyMethod().equals(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
    }
  }
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  if (allowedRoles != null) {
    Helper.checkRoles(reasoner,allowedRoles);
    usedRoles=allowedRoles;
  }
 else   if (ignoredRoles != null) {
    Helper.checkRoles(reasoner,ignoredRoles);
    usedRoles=Helper.difference(reasoner.getObjectProperties(),ignoredRoles);
  }
 else {
    usedRoles=reasoner.getObjectProperties();
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  if (improveSubsumptionHierarchy)   classHierarchy.thinOutSubsumptionHierarchy();
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
    ((RhoDRDown)operator).setReasoner(reasoner);
    ((RhoDRDown)operator).init();
  }
 else {
    operator.setSubHierarchy(classHierarchy);
  }
  algorithm=new ROLearner2(learningProblem,reasoner,operator,heuristic,startClass,noisePercentage / (double)100,writeSearchTree,replaceSearchTree,searchTreeFile,useTooWeakList,useOverlyGeneralList,useShortConceptConstruction,usePropernessChecks,maxPosOnlyExpansion,maxExecutionTimeInSeconds,minExecutionTimeInSeconds,guaranteeXgoodDescriptions,maxClassDescriptionTests,forceRefinementLengthIncrease,terminateOnNoiseReached,negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
}","@Override public void init() throws ComponentInitException {
  if (getReasoner().getReasonerType() == ReasonerType.DIG) {
    throw new ComponentInitException(""String_Node_Str"" + getName());
  }
  if (!logLevel.equals(CommonConfigOptions.logLevelDefault))   logger.setLevel(Level.toLevel(logLevel,Level.toLevel(CommonConfigOptions.logLevelDefault)));
  if (searchTreeFile == null)   searchTreeFile=new File(defaultSearchTreeFile);
  if (writeSearchTree)   Files.clearFile(searchTreeFile);
  if (heuristic == null) {
    if (getLearningProblem() instanceof PosOnlyLP) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      heuristic=new MultiHeuristic(((PosNegLP)getLearningProblem()).getPositiveExamples().size(),((PosNegLP)getLearningProblem()).getNegativeExamples().size(),negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
    }
  }
 else {
    if (heuristic instanceof MultiHeuristic) {
      MultiHeuristic mh=((MultiHeuristic)heuristic);
      if (mh.getNrOfNegativeExamples() == 0) {
        mh.setNrOfNegativeExamples(((PosNegLP)getLearningProblem()).getNegativeExamples().size());
      }
      int nrPosEx=((PosNegLP)getLearningProblem()).getPositiveExamples().size();
      int nrNegEx=((PosNegLP)getLearningProblem()).getNegativeExamples().size();
      if (mh.getNrOfExamples() == 0) {
        mh.setNrOfExamples(nrPosEx + nrNegEx);
      }
      if (mh.getNrOfNegativeExamples() == 0) {
        mh.setNrOfNegativeExamples(nrNegEx);
      }
    }
  }
  if (learningProblem instanceof PosNegLPStandard) {
    if (((PosNegLPStandard)learningProblem).isUseApproximations()) {
      System.err.println(""String_Node_Str"");
    }
    if (!((PosNegLPStandard)learningProblem).getAccuracyMethod().equals(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
    }
  }
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  if (allowedRoles != null) {
    Helper.checkRoles(reasoner,allowedRoles);
    usedRoles=allowedRoles;
  }
 else   if (ignoredRoles != null) {
    Helper.checkRoles(reasoner,ignoredRoles);
    usedRoles=Helper.difference(reasoner.getObjectProperties(),ignoredRoles);
  }
 else {
    usedRoles=reasoner.getObjectProperties();
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  if (improveSubsumptionHierarchy)   classHierarchy.thinOutSubsumptionHierarchy();
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setReasoner(reasoner);
  }
  ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
  ((RhoDRDown)operator).setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  ((RhoDRDown)operator).setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  ((RhoDRDown)operator).init();
  algorithm=new ROLearner2(learningProblem,reasoner,operator,heuristic,startClass,noisePercentage / (double)100,writeSearchTree,replaceSearchTree,searchTreeFile,useTooWeakList,useOverlyGeneralList,useShortConceptConstruction,usePropernessChecks,maxPosOnlyExpansion,maxExecutionTimeInSeconds,minExecutionTimeInSeconds,guaranteeXgoodDescriptions,maxClassDescriptionTests,forceRefinementLengthIncrease,terminateOnNoiseReached,negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
}"
9559,"@SuppressWarnings({""String_Node_Str""}) public Set<Description> refine(Description description,int maxLength,List<Description> knownRefinements,Description currDomain){
  if (!(currDomain instanceof Thing) && !topARefinementsLength.containsKey(currDomain))   topARefinementsLength.put((NamedClass)currDomain,0);
  Set<Description> refinements=new TreeSet<Description>(conceptComparator);
  Set<Description> tmp=new HashSet<Description>();
  if (description instanceof Thing) {
    if (currDomain instanceof Thing) {
      if (maxLength > topRefinementsLength)       computeTopRefinements(maxLength);
      refinements=(TreeSet<Description>)topRefinementsCumulative.get(maxLength).clone();
    }
 else {
      if (maxLength > topARefinementsLength.get(currDomain)) {
        computeTopRefinements(maxLength,(NamedClass)currDomain);
      }
      refinements=(TreeSet<Description>)topARefinementsCumulative.get(currDomain).get(maxLength).clone();
    }
  }
 else   if (description instanceof Nothing) {
  }
 else   if (description instanceof NamedClass) {
    refinements.addAll(subHierarchy.getSubClasses(description));
    refinements.remove(new Nothing());
  }
 else   if (description instanceof Negation && description.getChild(0) instanceof NamedClass) {
    tmp=subHierarchy.getSuperClasses(description.getChild(0));
    for (    Description c : tmp) {
      if (!(c instanceof Thing))       refinements.add(new Negation(c));
    }
  }
 else   if (description instanceof Intersection) {
    for (    Description child : description.getChildren()) {
      tmp=refine(child,maxLength - description.getLength() + child.getLength(),null,currDomain);
      for (      Description c : tmp) {
        List<Description> newChildren=(List<Description>)((LinkedList<Description>)description.getChildren()).clone();
        newChildren.add(c);
        newChildren.remove(child);
        Intersection mc=new Intersection(newChildren);
        ConceptTransformation.cleanConceptNonRecursive(mc);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc,conceptComparator);
        if (checkIntersection(mc))         refinements.add(mc);
      }
    }
  }
 else   if (description instanceof Union) {
    for (    Description child : description.getChildren()) {
      tmp=refine(child,maxLength - description.getLength() + child.getLength(),null,currDomain);
      for (      Description c : tmp) {
        List<Description> newChildren=new LinkedList<Description>(description.getChildren());
        newChildren.remove(child);
        newChildren.add(c);
        Union md=new Union(newChildren);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(md,conceptComparator);
        refinements.add(md);
      }
    }
    if (dropDisjuncts) {
      if (description.getChildren().size() == 2) {
        refinements.add(description.getChild(0));
        refinements.add(description.getChild(1));
      }
 else {
        for (int i=0; i < description.getChildren().size(); i++) {
          List<Description> newChildren=new LinkedList<Description>(description.getChildren());
          newChildren.remove(i);
          Union md=new Union(newChildren);
          refinements.add(md);
        }
      }
    }
  }
 else   if (description instanceof ObjectSomeRestriction) {
    ObjectPropertyExpression role=((ObjectQuantorRestriction)description).getRole();
    Description range=opRanges.get(role);
    tmp=refine(description.getChild(0),maxLength - 2,null,range);
    for (    Description c : tmp)     refinements.add(new ObjectSomeRestriction(((ObjectQuantorRestriction)description).getRole(),c));
    ObjectProperty ar=(ObjectProperty)role;
    Set<ObjectProperty> moreSpecialRoles=reasoner.getSubProperties(ar);
    for (    ObjectProperty moreSpecialRole : moreSpecialRoles)     refinements.add(new ObjectSomeRestriction(moreSpecialRole,description.getChild(0)));
    if (useCardinalityRestrictions) {
      if (maxLength > description.getLength() && maxNrOfFillers.get(ar) > 1) {
        ObjectMinCardinalityRestriction min=new ObjectMinCardinalityRestriction(2,role,description.getChild(0));
        refinements.add(min);
      }
    }
    if (useHasValueConstructor && description.getChild(0) instanceof Thing) {
      Set<Individual> frequentInds=frequentValues.get(role);
      if (frequentInds != null) {
        for (        Individual ind : frequentInds) {
          ObjectValueRestriction ovr=new ObjectValueRestriction((ObjectProperty)role,ind);
          refinements.add(ovr);
        }
      }
    }
  }
 else   if (description instanceof ObjectAllRestriction) {
    ObjectPropertyExpression role=((ObjectQuantorRestriction)description).getRole();
    Description range=opRanges.get(role);
    tmp=refine(description.getChild(0),maxLength - 2,null,range);
    for (    Description c : tmp) {
      refinements.add(new ObjectAllRestriction(((ObjectQuantorRestriction)description).getRole(),c));
    }
    if (description.getChild(0) instanceof NamedClass && tmp.size() == 0) {
      refinements.add(new ObjectAllRestriction(((ObjectQuantorRestriction)description).getRole(),new Nothing()));
    }
    ObjectProperty ar=(ObjectProperty)role;
    Set<ObjectProperty> moreSpecialRoles=reasoner.getSubProperties(ar);
    for (    ObjectProperty moreSpecialRole : moreSpecialRoles) {
      refinements.add(new ObjectAllRestriction(moreSpecialRole,description.getChild(0)));
    }
  }
 else   if (description instanceof ObjectCardinalityRestriction) {
    ObjectPropertyExpression role=((ObjectCardinalityRestriction)description).getRole();
    Description range=opRanges.get(role);
    int number=((ObjectCardinalityRestriction)description).getCardinality();
    if (description instanceof ObjectMaxCardinalityRestriction) {
      tmp=refine(description.getChild(0),maxLength - 3,null,range);
      for (      Description d : tmp) {
        refinements.add(new ObjectMaxCardinalityRestriction(number,role,d));
      }
      ObjectMaxCardinalityRestriction max=(ObjectMaxCardinalityRestriction)description;
      if (number > 1)       refinements.add(new ObjectMaxCardinalityRestriction(number - 1,max.getRole(),max.getChild(0)));
    }
 else     if (description instanceof ObjectMinCardinalityRestriction) {
      tmp=refine(description.getChild(0),maxLength - 3,null,range);
      for (      Description d : tmp) {
        refinements.add(new ObjectMinCardinalityRestriction(number,role,d));
      }
      ObjectMinCardinalityRestriction min=(ObjectMinCardinalityRestriction)description;
      if (number < maxNrOfFillers.get(min.getRole()))       refinements.add(new ObjectMinCardinalityRestriction(number + 1,min.getRole(),min.getChild(0)));
    }
  }
 else   if (description instanceof DatatypeSomeRestriction) {
    DatatypeSomeRestriction dsr=(DatatypeSomeRestriction)description;
    DatatypeProperty dp=(DatatypeProperty)dsr.getRestrictedPropertyExpression();
    DataRange dr=dsr.getDataRange();
    if (dr instanceof DoubleMaxValue) {
      double value=((DoubleMaxValue)dr).getValue();
      int splitIndex=splits.get(dp).lastIndexOf(value);
      if (splitIndex == -1)       throw new Error(""String_Node_Str"");
      int newSplitIndex=splitIndex - 1;
      if (newSplitIndex >= 0) {
        DoubleMaxValue max=new DoubleMaxValue(splits.get(dp).get(newSplitIndex));
        DatatypeSomeRestriction newDSR=new DatatypeSomeRestriction(dp,max);
        refinements.add(newDSR);
      }
    }
 else     if (dr instanceof DoubleMinValue) {
      double value=((DoubleMinValue)dr).getValue();
      int splitIndex=splits.get(dp).lastIndexOf(value);
      if (splitIndex == -1)       throw new Error(""String_Node_Str"");
      int newSplitIndex=splitIndex + 1;
      if (newSplitIndex < splits.get(dp).size()) {
        DoubleMinValue min=new DoubleMinValue(splits.get(dp).get(newSplitIndex));
        DatatypeSomeRestriction newDSR=new DatatypeSomeRestriction(dp,min);
        refinements.add(newDSR);
      }
    }
  }
 else   if (description instanceof StringValueRestriction) {
    StringValueRestriction svr=(StringValueRestriction)description;
    DatatypeProperty dp=svr.getRestrictedPropertyExpression();
    Set<DatatypeProperty> subDPs=reasoner.getSubProperties(dp);
    for (    DatatypeProperty subDP : subDPs) {
      refinements.add(new StringValueRestriction(subDP,svr.getStringValue()));
    }
  }
  if (!(description instanceof Thing) && !(description instanceof Nothing) && !(description instanceof ObjectAllRestriction && description.getChild(0) instanceof Nothing)) {
    int topRefLength=maxLength - description.getLength() - 1;
    if (currDomain instanceof Thing) {
      if (topRefLength > topRefinementsLength)       computeTopRefinements(topRefLength);
    }
 else     if (topRefLength > topARefinementsLength.get(currDomain))     computeTopRefinements(topRefLength,(NamedClass)currDomain);
    if (topRefLength > 0) {
      Set<Description> topRefs;
      if (currDomain instanceof Thing)       topRefs=topRefinementsCumulative.get(topRefLength);
 else       topRefs=topARefinementsCumulative.get(currDomain).get(topRefLength);
      for (      Description c : topRefs) {
        boolean skip=false;
        if (applyAllFilter) {
          if (c instanceof ObjectAllRestriction) {
            for (            Description child : description.getChildren()) {
              if (child instanceof ObjectAllRestriction) {
                ObjectPropertyExpression r1=((ObjectAllRestriction)c).getRole();
                ObjectPropertyExpression r2=((ObjectAllRestriction)child).getRole();
                if (r1.toString().equals(r2.toString()))                 skip=true;
              }
            }
          }
        }
        if (disjointChecks && c instanceof NamedClass && description instanceof NamedClass&& isDisjoint(description,c)) {
          skip=true;
        }
        if (!skip) {
          Intersection mc=new Intersection();
          mc.addChild(description);
          mc.addChild(c);
          ConceptTransformation.cleanConceptNonRecursive(mc);
          ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc,conceptComparator);
          if (checkIntersection(mc))           refinements.add(mc);
        }
      }
    }
  }
  return refinements;
}","@SuppressWarnings({""String_Node_Str""}) public Set<Description> refine(Description description,int maxLength,List<Description> knownRefinements,Description currDomain){
  if (!(currDomain instanceof Thing) && !topARefinementsLength.containsKey(currDomain))   topARefinementsLength.put((NamedClass)currDomain,0);
  Set<Description> refinements=new TreeSet<Description>(conceptComparator);
  Set<Description> tmp=new HashSet<Description>();
  if (description instanceof Thing) {
    if (currDomain instanceof Thing) {
      if (maxLength > topRefinementsLength)       computeTopRefinements(maxLength);
      refinements=(TreeSet<Description>)topRefinementsCumulative.get(maxLength).clone();
    }
 else {
      if (maxLength > topARefinementsLength.get(currDomain)) {
        computeTopRefinements(maxLength,(NamedClass)currDomain);
      }
      refinements=(TreeSet<Description>)topARefinementsCumulative.get(currDomain).get(maxLength).clone();
    }
  }
 else   if (description instanceof Nothing) {
  }
 else   if (description instanceof NamedClass) {
    refinements.addAll(subHierarchy.getSubClasses(description));
    refinements.remove(new Nothing());
  }
 else   if (description instanceof Negation && description.getChild(0) instanceof NamedClass) {
    tmp=subHierarchy.getSuperClasses(description.getChild(0));
    for (    Description c : tmp) {
      if (!(c instanceof Thing))       refinements.add(new Negation(c));
    }
  }
 else   if (description instanceof Intersection) {
    for (    Description child : description.getChildren()) {
      tmp=refine(child,maxLength - description.getLength() + child.getLength(),null,currDomain);
      for (      Description c : tmp) {
        List<Description> newChildren=(List<Description>)((LinkedList<Description>)description.getChildren()).clone();
        newChildren.add(c);
        newChildren.remove(child);
        Intersection mc=new Intersection(newChildren);
        ConceptTransformation.cleanConceptNonRecursive(mc);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc,conceptComparator);
        if (checkIntersection(mc))         refinements.add(mc);
      }
    }
  }
 else   if (description instanceof Union) {
    for (    Description child : description.getChildren()) {
      tmp=refine(child,maxLength - description.getLength() + child.getLength(),null,currDomain);
      for (      Description c : tmp) {
        List<Description> newChildren=new LinkedList<Description>(description.getChildren());
        newChildren.remove(child);
        newChildren.add(c);
        Union md=new Union(newChildren);
        ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(md,conceptComparator);
        refinements.add(md);
      }
    }
    if (dropDisjuncts) {
      if (description.getChildren().size() == 2) {
        refinements.add(description.getChild(0));
        refinements.add(description.getChild(1));
      }
 else {
        for (int i=0; i < description.getChildren().size(); i++) {
          List<Description> newChildren=new LinkedList<Description>(description.getChildren());
          newChildren.remove(i);
          Union md=new Union(newChildren);
          refinements.add(md);
        }
      }
    }
  }
 else   if (description instanceof ObjectSomeRestriction) {
    ObjectPropertyExpression role=((ObjectQuantorRestriction)description).getRole();
    Description range=opRanges.get(role);
    tmp=refine(description.getChild(0),maxLength - 2,null,range);
    for (    Description c : tmp)     refinements.add(new ObjectSomeRestriction(((ObjectQuantorRestriction)description).getRole(),c));
    ObjectProperty ar=(ObjectProperty)role;
    Set<ObjectProperty> moreSpecialRoles=objectPropertyHierarchy.getMoreSpecialRoles(ar);
    for (    ObjectProperty moreSpecialRole : moreSpecialRoles)     refinements.add(new ObjectSomeRestriction(moreSpecialRole,description.getChild(0)));
    if (useCardinalityRestrictions) {
      if (maxLength > description.getLength() && maxNrOfFillers.get(ar) > 1) {
        ObjectMinCardinalityRestriction min=new ObjectMinCardinalityRestriction(2,role,description.getChild(0));
        refinements.add(min);
      }
    }
    if (useHasValueConstructor && description.getChild(0) instanceof Thing) {
      Set<Individual> frequentInds=frequentValues.get(role);
      if (frequentInds != null) {
        for (        Individual ind : frequentInds) {
          ObjectValueRestriction ovr=new ObjectValueRestriction((ObjectProperty)role,ind);
          refinements.add(ovr);
        }
      }
    }
  }
 else   if (description instanceof ObjectAllRestriction) {
    ObjectPropertyExpression role=((ObjectQuantorRestriction)description).getRole();
    Description range=opRanges.get(role);
    tmp=refine(description.getChild(0),maxLength - 2,null,range);
    for (    Description c : tmp) {
      refinements.add(new ObjectAllRestriction(((ObjectQuantorRestriction)description).getRole(),c));
    }
    if (description.getChild(0) instanceof NamedClass && tmp.size() == 0) {
      refinements.add(new ObjectAllRestriction(((ObjectQuantorRestriction)description).getRole(),new Nothing()));
    }
    ObjectProperty ar=(ObjectProperty)role;
    Set<ObjectProperty> moreSpecialRoles=objectPropertyHierarchy.getMoreSpecialRoles(ar);
    for (    ObjectProperty moreSpecialRole : moreSpecialRoles) {
      refinements.add(new ObjectAllRestriction(moreSpecialRole,description.getChild(0)));
    }
  }
 else   if (description instanceof ObjectCardinalityRestriction) {
    ObjectPropertyExpression role=((ObjectCardinalityRestriction)description).getRole();
    Description range=opRanges.get(role);
    int number=((ObjectCardinalityRestriction)description).getCardinality();
    if (description instanceof ObjectMaxCardinalityRestriction) {
      tmp=refine(description.getChild(0),maxLength - 3,null,range);
      for (      Description d : tmp) {
        refinements.add(new ObjectMaxCardinalityRestriction(number,role,d));
      }
      ObjectMaxCardinalityRestriction max=(ObjectMaxCardinalityRestriction)description;
      if (number > 1)       refinements.add(new ObjectMaxCardinalityRestriction(number - 1,max.getRole(),max.getChild(0)));
    }
 else     if (description instanceof ObjectMinCardinalityRestriction) {
      tmp=refine(description.getChild(0),maxLength - 3,null,range);
      for (      Description d : tmp) {
        refinements.add(new ObjectMinCardinalityRestriction(number,role,d));
      }
      ObjectMinCardinalityRestriction min=(ObjectMinCardinalityRestriction)description;
      if (number < maxNrOfFillers.get(min.getRole()))       refinements.add(new ObjectMinCardinalityRestriction(number + 1,min.getRole(),min.getChild(0)));
    }
  }
 else   if (description instanceof DatatypeSomeRestriction) {
    DatatypeSomeRestriction dsr=(DatatypeSomeRestriction)description;
    DatatypeProperty dp=(DatatypeProperty)dsr.getRestrictedPropertyExpression();
    DataRange dr=dsr.getDataRange();
    if (dr instanceof DoubleMaxValue) {
      double value=((DoubleMaxValue)dr).getValue();
      int splitIndex=splits.get(dp).lastIndexOf(value);
      if (splitIndex == -1)       throw new Error(""String_Node_Str"");
      int newSplitIndex=splitIndex - 1;
      if (newSplitIndex >= 0) {
        DoubleMaxValue max=new DoubleMaxValue(splits.get(dp).get(newSplitIndex));
        DatatypeSomeRestriction newDSR=new DatatypeSomeRestriction(dp,max);
        refinements.add(newDSR);
      }
    }
 else     if (dr instanceof DoubleMinValue) {
      double value=((DoubleMinValue)dr).getValue();
      int splitIndex=splits.get(dp).lastIndexOf(value);
      if (splitIndex == -1)       throw new Error(""String_Node_Str"");
      int newSplitIndex=splitIndex + 1;
      if (newSplitIndex < splits.get(dp).size()) {
        DoubleMinValue min=new DoubleMinValue(splits.get(dp).get(newSplitIndex));
        DatatypeSomeRestriction newDSR=new DatatypeSomeRestriction(dp,min);
        refinements.add(newDSR);
      }
    }
  }
 else   if (description instanceof StringValueRestriction) {
    StringValueRestriction svr=(StringValueRestriction)description;
    DatatypeProperty dp=svr.getRestrictedPropertyExpression();
    Set<DatatypeProperty> subDPs=reasoner.getSubProperties(dp);
    for (    DatatypeProperty subDP : subDPs) {
      refinements.add(new StringValueRestriction(subDP,svr.getStringValue()));
    }
  }
  if (!(description instanceof Thing) && !(description instanceof Nothing) && !(description instanceof ObjectAllRestriction && description.getChild(0) instanceof Nothing)) {
    int topRefLength=maxLength - description.getLength() - 1;
    if (currDomain instanceof Thing) {
      if (topRefLength > topRefinementsLength)       computeTopRefinements(topRefLength);
    }
 else     if (topRefLength > topARefinementsLength.get(currDomain))     computeTopRefinements(topRefLength,(NamedClass)currDomain);
    if (topRefLength > 0) {
      Set<Description> topRefs;
      if (currDomain instanceof Thing)       topRefs=topRefinementsCumulative.get(topRefLength);
 else       topRefs=topARefinementsCumulative.get(currDomain).get(topRefLength);
      for (      Description c : topRefs) {
        boolean skip=false;
        if (applyAllFilter) {
          if (c instanceof ObjectAllRestriction) {
            for (            Description child : description.getChildren()) {
              if (child instanceof ObjectAllRestriction) {
                ObjectPropertyExpression r1=((ObjectAllRestriction)c).getRole();
                ObjectPropertyExpression r2=((ObjectAllRestriction)child).getRole();
                if (r1.toString().equals(r2.toString()))                 skip=true;
              }
            }
          }
        }
        if (disjointChecks && c instanceof NamedClass && description instanceof NamedClass&& isDisjoint(description,c)) {
          skip=true;
        }
        if (!skip) {
          Intersection mc=new Intersection();
          mc.addChild(description);
          mc.addChild(c);
          ConceptTransformation.cleanConceptNonRecursive(mc);
          ConceptTransformation.transformToOrderedNegationNormalFormNonRecursive(mc,conceptComparator);
          if (checkIntersection(mc))           refinements.add(mc);
        }
      }
    }
  }
  return refinements;
}"
9560,"@Override public void init() throws ComponentInitException {
  if (getReasoner().getReasonerType() == ReasonerType.DIG) {
    throw new ComponentInitException(""String_Node_Str"" + getName());
  }
  if (!logLevel.equals(CommonConfigOptions.logLevelDefault))   logger.setLevel(Level.toLevel(logLevel,Level.toLevel(CommonConfigOptions.logLevelDefault)));
  if (searchTreeFile == null)   searchTreeFile=new File(defaultSearchTreeFile);
  if (writeSearchTree)   Files.clearFile(searchTreeFile);
  if (heuristic == null) {
    if (getLearningProblem() instanceof PosOnlyLP) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      heuristic=new MultiHeuristic(((PosNegLP)getLearningProblem()).getPositiveExamples().size(),((PosNegLP)getLearningProblem()).getNegativeExamples().size(),negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
    }
  }
 else {
    if (heuristic instanceof MultiHeuristic) {
      MultiHeuristic mh=((MultiHeuristic)heuristic);
      if (mh.getNrOfNegativeExamples() == 0) {
        mh.setNrOfNegativeExamples(((PosNegLP)getLearningProblem()).getNegativeExamples().size());
      }
      int nrPosEx=((PosNegLP)getLearningProblem()).getPositiveExamples().size();
      int nrNegEx=((PosNegLP)getLearningProblem()).getNegativeExamples().size();
      if (mh.getNrOfExamples() == 0) {
        mh.setNrOfExamples(nrPosEx + nrNegEx);
      }
      if (mh.getNrOfNegativeExamples() == 0) {
        mh.setNrOfNegativeExamples(nrNegEx);
      }
    }
  }
  if (learningProblem instanceof PosNegLPStandard) {
    if (((PosNegLPStandard)learningProblem).isUseApproximations()) {
      System.err.println(""String_Node_Str"");
    }
    if (!((PosNegLPStandard)learningProblem).getAccuracyMethod().equals(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
    }
  }
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  if (allowedRoles != null) {
    Helper.checkRoles(reasoner,allowedRoles);
    usedRoles=allowedRoles;
  }
 else   if (ignoredRoles != null) {
    Helper.checkRoles(reasoner,ignoredRoles);
    usedRoles=Helper.difference(reasoner.getObjectProperties(),ignoredRoles);
  }
 else {
    usedRoles=reasoner.getObjectProperties();
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  if (improveSubsumptionHierarchy)   classHierarchy.thinOutSubsumptionHierarchy();
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setReasoner(reasoner);
  }
  ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
  ((RhoDRDown)operator).setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  ((RhoDRDown)operator).setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  ((RhoDRDown)operator).init();
  algorithm=new ROLearner2(learningProblem,reasoner,operator,heuristic,startClass,noisePercentage / (double)100,writeSearchTree,replaceSearchTree,searchTreeFile,useTooWeakList,useOverlyGeneralList,useShortConceptConstruction,usePropernessChecks,maxPosOnlyExpansion,maxExecutionTimeInSeconds,minExecutionTimeInSeconds,guaranteeXgoodDescriptions,maxClassDescriptionTests,forceRefinementLengthIncrease,terminateOnNoiseReached,negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
}","@Override public void init() throws ComponentInitException {
  if (getReasoner().getReasonerType() == ReasonerType.DIG) {
    throw new ComponentInitException(""String_Node_Str"" + getName());
  }
  if (!logLevel.equals(CommonConfigOptions.logLevelDefault))   logger.setLevel(Level.toLevel(logLevel,Level.toLevel(CommonConfigOptions.logLevelDefault)));
  if (searchTreeFile == null)   searchTreeFile=new File(defaultSearchTreeFile);
  if (writeSearchTree)   Files.clearFile(searchTreeFile);
  if (heuristic == null) {
    if (getLearningProblem() instanceof PosOnlyLP) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      heuristic=new MultiHeuristic(((PosNegLP)getLearningProblem()).getPositiveExamples().size(),((PosNegLP)getLearningProblem()).getNegativeExamples().size(),negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
    }
  }
 else {
    if (heuristic instanceof MultiHeuristic) {
      MultiHeuristic mh=((MultiHeuristic)heuristic);
      if (mh.getNrOfNegativeExamples() == 0) {
        mh.setNrOfNegativeExamples(((PosNegLP)getLearningProblem()).getNegativeExamples().size());
      }
      int nrPosEx=((PosNegLP)getLearningProblem()).getPositiveExamples().size();
      int nrNegEx=((PosNegLP)getLearningProblem()).getNegativeExamples().size();
      if (mh.getNrOfExamples() == 0) {
        mh.setNrOfExamples(nrPosEx + nrNegEx);
      }
      if (mh.getNrOfNegativeExamples() == 0) {
        mh.setNrOfNegativeExamples(nrNegEx);
      }
    }
  }
  if (learningProblem instanceof PosNegLPStandard) {
    if (((PosNegLPStandard)learningProblem).isUseApproximations()) {
      System.err.println(""String_Node_Str"");
    }
    if (!((PosNegLPStandard)learningProblem).getAccuracyMethod().equals(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
    }
  }
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  if (allowedRoles != null) {
    Helper.checkRoles(reasoner,allowedRoles);
    usedRoles=allowedRoles;
  }
 else   if (ignoredRoles != null) {
    Helper.checkRoles(reasoner,ignoredRoles);
    usedRoles=Helper.difference(reasoner.getObjectProperties(),ignoredRoles);
  }
 else {
    usedRoles=reasoner.getObjectProperties();
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  if (improveSubsumptionHierarchy)   classHierarchy.thinOutSubsumptionHierarchy();
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setReasoner(reasoner);
    ((RhoDRDown)operator).init();
  }
  ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
  ((RhoDRDown)operator).setObjectPropertyHierarchy(reasoner.getObjectPropertyHierarchy());
  ((RhoDRDown)operator).setDataPropertyHierarchy(reasoner.getDatatypePropertyHierarchy());
  algorithm=new ROLearner2(learningProblem,reasoner,operator,heuristic,startClass,noisePercentage / (double)100,writeSearchTree,replaceSearchTree,searchTreeFile,useTooWeakList,useOverlyGeneralList,useShortConceptConstruction,usePropernessChecks,maxPosOnlyExpansion,maxExecutionTimeInSeconds,minExecutionTimeInSeconds,guaranteeXgoodDescriptions,maxClassDescriptionTests,forceRefinementLengthIncrease,terminateOnNoiseReached,negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
}"
9561,"public RhoDRDown(AbstractReasonerComponent reasoningService,ClassHierarchy subHierarchy,boolean applyAllFilter,boolean applyExistsFilter,boolean useAllConstructor,boolean useExistsConstructor,boolean useHasValueConstructor,int valueFrequencyThreshold,boolean useCardinalityRestrictions,boolean useNegation,boolean useBooleanDatatypes,boolean useDoubleDatatypes,NamedClass startClass,int cardinalityLimit,boolean useStringDatatypes,boolean instanceBasedDisjoints){
  this.reasoner=reasoningService;
  this.subHierarchy=subHierarchy;
  this.applyAllFilter=applyAllFilter;
  this.applyExistsFilter=applyExistsFilter;
  this.useAllConstructor=useAllConstructor;
  this.useExistsConstructor=useExistsConstructor;
  this.useHasValueConstructor=useHasValueConstructor;
  this.frequencyThreshold=valueFrequencyThreshold;
  this.useCardinalityRestrictions=useCardinalityRestrictions;
  this.cardinalityLimit=cardinalityLimit;
  this.useNegation=useNegation;
  this.useBooleanDatatypes=useBooleanDatatypes;
  this.useDoubleDatatypes=useDoubleDatatypes;
  this.useStringDatatypes=useStringDatatypes;
  this.instanceBasedDisjoints=instanceBasedDisjoints;
  if (startClass != null) {
    this.startClass=startClass;
  }
  init();
}","public RhoDRDown(){
}"
9562,"public void init(){
  for (  ObjectProperty op : reasoner.getObjectProperties()) {
    opDomains.put(op,reasoner.getDomain(op));
    opRanges.put(op,reasoner.getRange(op));
    if (useHasValueConstructor) {
      Map<Individual,Integer> opMap=new TreeMap<Individual,Integer>();
      valueFrequency.put(op,opMap);
      Collection<SortedSet<Individual>> fillerSets=reasoner.getPropertyMembers(op).values();
      for (      SortedSet<Individual> fillerSet : fillerSets) {
        for (        Individual i : fillerSet) {
          Integer value=opMap.get(i);
          if (value != null) {
            opMap.put(i,value + 1);
          }
 else {
            opMap.put(i,1);
          }
        }
      }
      Set<Individual> frequentInds=new TreeSet<Individual>();
      for (      Individual i : opMap.keySet()) {
        if (opMap.get(i) >= frequencyThreshold) {
          frequentInds.add(i);
        }
      }
      frequentValues.put(op,frequentInds);
    }
  }
  for (  DatatypeProperty dp : reasoner.getDatatypeProperties()) {
    dpDomains.put(dp,reasoner.getDomain(dp));
    if (useDataHasValueConstructor) {
      Map<Constant,Integer> dpMap=new TreeMap<Constant,Integer>();
      dataValueFrequency.put(dp,dpMap);
      Collection<SortedSet<Constant>> fillerSets=reasoner.getDatatypeMembers(dp).values();
      for (      SortedSet<Constant> fillerSet : fillerSets) {
        for (        Constant i : fillerSet) {
          Integer value=dpMap.get(i);
          if (value != null) {
            dpMap.put(i,value + 1);
          }
 else {
            dpMap.put(i,1);
          }
        }
      }
      Set<Constant> frequentInds=new TreeSet<Constant>();
      for (      Constant i : dpMap.keySet()) {
        if (dpMap.get(i) >= frequencyThreshold) {
          logger.trace(""String_Node_Str"" + i + ""String_Node_Str""+ dpMap.get(i)+ ""String_Node_Str""+ frequencyThreshold);
          frequentInds.add(i);
        }
      }
      frequentDataValues.put(dp,frequentInds);
    }
  }
  valueFrequency=null;
  dataValueFrequency=null;
  for (  DatatypeProperty dp : reasoner.getDoubleDatatypeProperties()) {
    computeSplits(dp);
  }
  if (useCardinalityRestrictions) {
    for (    ObjectProperty op : reasoner.getObjectProperties()) {
      int maxFillers=0;
      Map<Individual,SortedSet<Individual>> opMembers=reasoner.getPropertyMembers(op);
      for (      SortedSet<Individual> inds : opMembers.values()) {
        if (inds.size() > maxFillers)         maxFillers=inds.size();
        if (maxFillers >= cardinalityLimit) {
          maxFillers=cardinalityLimit;
          break;
        }
      }
      maxNrOfFillers.put(op,maxFillers);
    }
  }
}","public void init() throws ComponentInitException {
  if (isInitialised) {
    throw new ComponentInitException(""String_Node_Str"");
  }
  for (  ObjectProperty op : reasoner.getObjectProperties()) {
    opDomains.put(op,reasoner.getDomain(op));
    opRanges.put(op,reasoner.getRange(op));
    if (useHasValueConstructor) {
      Map<Individual,Integer> opMap=new TreeMap<Individual,Integer>();
      valueFrequency.put(op,opMap);
      Collection<SortedSet<Individual>> fillerSets=reasoner.getPropertyMembers(op).values();
      for (      SortedSet<Individual> fillerSet : fillerSets) {
        for (        Individual i : fillerSet) {
          Integer value=opMap.get(i);
          if (value != null) {
            opMap.put(i,value + 1);
          }
 else {
            opMap.put(i,1);
          }
        }
      }
      Set<Individual> frequentInds=new TreeSet<Individual>();
      for (      Individual i : opMap.keySet()) {
        if (opMap.get(i) >= frequencyThreshold) {
          frequentInds.add(i);
        }
      }
      frequentValues.put(op,frequentInds);
    }
  }
  for (  DatatypeProperty dp : reasoner.getDatatypeProperties()) {
    dpDomains.put(dp,reasoner.getDomain(dp));
    if (useDataHasValueConstructor) {
      Map<Constant,Integer> dpMap=new TreeMap<Constant,Integer>();
      dataValueFrequency.put(dp,dpMap);
      Collection<SortedSet<Constant>> fillerSets=reasoner.getDatatypeMembers(dp).values();
      for (      SortedSet<Constant> fillerSet : fillerSets) {
        for (        Constant i : fillerSet) {
          Integer value=dpMap.get(i);
          if (value != null) {
            dpMap.put(i,value + 1);
          }
 else {
            dpMap.put(i,1);
          }
        }
      }
      Set<Constant> frequentInds=new TreeSet<Constant>();
      for (      Constant i : dpMap.keySet()) {
        if (dpMap.get(i) >= frequencyThreshold) {
          logger.trace(""String_Node_Str"" + i + ""String_Node_Str""+ dpMap.get(i)+ ""String_Node_Str""+ frequencyThreshold);
          frequentInds.add(i);
        }
      }
      frequentDataValues.put(dp,frequentInds);
    }
  }
  valueFrequency=null;
  dataValueFrequency=null;
  System.out.println(""String_Node_Str"" + frequentDataValues);
  for (  DatatypeProperty dp : reasoner.getDoubleDatatypeProperties()) {
    computeSplits(dp);
  }
  if (useCardinalityRestrictions) {
    for (    ObjectProperty op : reasoner.getObjectProperties()) {
      int maxFillers=0;
      Map<Individual,SortedSet<Individual>> opMembers=reasoner.getPropertyMembers(op);
      for (      SortedSet<Individual> inds : opMembers.values()) {
        if (inds.size() > maxFillers)         maxFillers=inds.size();
        if (maxFillers >= cardinalityLimit) {
          maxFillers=cardinalityLimit;
          break;
        }
      }
      maxNrOfFillers.put(op,maxFillers);
    }
    isInitialised=true;
  }
}"
9563,"@Test public void invertedOperatorTest() throws ParseException {
  AbstractReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.RHO1);
  RhoDRDown rho=new RhoDRDown(rs);
  rho.setDropDisjuncts(true);
  RefinementOperator operator=new OperatorInverter(rho);
  Description concept=KBParser.parseConcept(""String_Node_Str"");
  Set<Description> refinements=operator.refine(concept,6);
  for (  Description refinement : refinements) {
    System.out.println(refinement);
  }
  assertTrue(refinements.size() == 4);
}","@Test public void invertedOperatorTest() throws ParseException {
  AbstractReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.RHO1);
  RhoDRDown rho=new RhoDRDown();
  rho.setReasoner(rs);
  rho.setDropDisjuncts(true);
  RefinementOperator operator=new OperatorInverter(rho);
  Description concept=KBParser.parseConcept(""String_Node_Str"");
  Set<Description> refinements=operator.refine(concept,6);
  for (  Description refinement : refinements) {
    System.out.println(refinement);
  }
  assertTrue(refinements.size() == 4);
}"
9564,"@Test public void rhoDRDownTest2() throws ParseException {
  AbstractReasonerComponent reasoner=TestOntologies.getTestOntology(TestOntology.EPC_OE);
  baseURI=reasoner.getBaseURI();
  RhoDRDown op=new RhoDRDown(reasoner);
  Description concept=KBParser.parseConcept(""String_Node_Str"");
  Set<Description> results=op.refine(concept,10);
  for (  Description result : results) {
    System.out.println(result.toString(""String_Node_Str"",null));
  }
  int desiredResultSize=116;
  if (results.size() != desiredResultSize) {
    System.out.println(results.size() + ""String_Node_Str"" + desiredResultSize+ ""String_Node_Str"");
  }
  assertTrue(results.size() == desiredResultSize);
}","@Test public void rhoDRDownTest2() throws ParseException {
  AbstractReasonerComponent reasoner=TestOntologies.getTestOntology(TestOntology.EPC_OE);
  baseURI=reasoner.getBaseURI();
  RhoDRDown op=new RhoDRDown();
  op.setReasoner(reasoner);
  Description concept=KBParser.parseConcept(""String_Node_Str"");
  Set<Description> results=op.refine(concept,10);
  for (  Description result : results) {
    System.out.println(result.toString(""String_Node_Str"",null));
  }
  int desiredResultSize=116;
  if (results.size() != desiredResultSize) {
    System.out.println(results.size() + ""String_Node_Str"" + desiredResultSize+ ""String_Node_Str"");
  }
  assertTrue(results.size() == desiredResultSize);
}"
9565,"@Test public void rhoDownTestPellet(){
  Logger.getRootLogger().setLevel(Level.TRACE);
  AbstractReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.FATHER);
  RhoDRDown rho=new RhoDRDown(rs);
  NamedClass nc=new NamedClass(""String_Node_Str"");
  Set<Description> refinements=rho.refine(nc,5);
  for (  Description refinement : refinements) {
    System.out.println(refinement);
  }
  System.out.println(rs.getObjectPropertyHierarchy());
  assertTrue(refinements.size() == 8);
}","@Test public void rhoDownTestPellet(){
  Logger.getRootLogger().setLevel(Level.TRACE);
  AbstractReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.FATHER);
  RhoDRDown rho=new RhoDRDown();
  rho.setReasoner(rs);
  NamedClass nc=new NamedClass(""String_Node_Str"");
  Set<Description> refinements=rho.refine(nc,5);
  for (  Description refinement : refinements) {
    System.out.println(refinement);
  }
  System.out.println(rs.getObjectPropertyHierarchy());
  assertTrue(refinements.size() == 8);
}"
9566,"@Test public void rhoDRDownTest3() throws ParseException, LearningProblemUnsupportedException {
  AbstractReasonerComponent reasoner=TestOntologies.getTestOntology(TestOntology.KRK_ZERO_ONE);
  baseURI=reasoner.getBaseURI();
  ComponentManager cm=ComponentManager.getInstance();
  AbstractLearningProblem lp=cm.learningProblem(PosNegLPStandard.class,reasoner);
  OCEL la=cm.learningAlgorithm(OCEL.class,lp,reasoner);
  Set<NamedClass> ignoredConcepts=new TreeSet<NamedClass>();
  ignoredConcepts.add(new NamedClass(""String_Node_Str""));
  ignoredConcepts.add(new NamedClass(""String_Node_Str""));
  Set<NamedClass> usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  classHierarchy.thinOutSubsumptionHierarchy();
  System.out.println(""String_Node_Str"");
  RhoDRDown op=new RhoDRDown(reasoner);
  Description concept=KBParser.parseConcept(""String_Node_Str"");
  Set<Description> results=op.refine(concept,8);
  for (  Description result : results) {
    System.out.println(result.toString(""String_Node_Str"",null));
  }
  int desiredResultSize=8;
  if (results.size() != desiredResultSize) {
    System.out.println(results.size() + ""String_Node_Str"" + desiredResultSize+ ""String_Node_Str"");
  }
  assertTrue(results.size() == desiredResultSize);
}","@Test public void rhoDRDownTest3() throws ParseException, LearningProblemUnsupportedException {
  AbstractReasonerComponent reasoner=TestOntologies.getTestOntology(TestOntology.KRK_ZERO_ONE);
  baseURI=reasoner.getBaseURI();
  ComponentManager cm=ComponentManager.getInstance();
  AbstractLearningProblem lp=cm.learningProblem(PosNegLPStandard.class,reasoner);
  OCEL la=cm.learningAlgorithm(OCEL.class,lp,reasoner);
  Set<NamedClass> ignoredConcepts=new TreeSet<NamedClass>();
  ignoredConcepts.add(new NamedClass(""String_Node_Str""));
  ignoredConcepts.add(new NamedClass(""String_Node_Str""));
  Set<NamedClass> usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  classHierarchy.thinOutSubsumptionHierarchy();
  System.out.println(""String_Node_Str"");
  RhoDRDown op=new RhoDRDown();
  op.setReasoner(reasoner);
  Description concept=KBParser.parseConcept(""String_Node_Str"");
  Set<Description> results=op.refine(concept,8);
  for (  Description result : results) {
    System.out.println(result.toString(""String_Node_Str"",null));
  }
  int desiredResultSize=8;
  if (results.size() != desiredResultSize) {
    System.out.println(results.size() + ""String_Node_Str"" + desiredResultSize+ ""String_Node_Str"");
  }
  assertTrue(results.size() == desiredResultSize);
}"
9567,"@Test public void rhoDRDownTest4() throws ParseException, LearningProblemUnsupportedException {
  AbstractReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.RHO1);
  RefinementOperator operator=new RhoDRDown(rs);
  Description concept=KBParser.parseConcept(""String_Node_Str"");
  Set<Description> refinements=operator.refine(concept,6);
  for (  Description refinement : refinements) {
    System.out.println(refinement);
  }
}","@Test public void rhoDRDownTest4() throws ParseException, LearningProblemUnsupportedException {
  AbstractReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.RHO1);
  RefinementOperator operator=new RhoDRDown();
  ((RhoDRDown)operator).setReasoner(rs);
  Description concept=KBParser.parseConcept(""String_Node_Str"");
  Set<Description> refinements=operator.refine(concept,6);
  for (  Description refinement : refinements) {
    System.out.println(refinement);
  }
}"
9568,"/** 
 * Applies the RhoDRDown operator to a concept and checks that the number of refinements is correct.
 */
@Test public void rhoDRDownTest(){
  try {
    String file=""String_Node_Str"";
    ComponentManager cm=ComponentManager.getInstance();
    AbstractKnowledgeSource ks=cm.knowledgeSource(OWLFile.class);
    try {
      cm.applyConfigEntry(ks,""String_Node_Str"",new File(file).toURI().toURL());
    }
 catch (    MalformedURLException e) {
      e.printStackTrace();
    }
    ks.init();
    AbstractReasonerComponent rc=cm.reasoner(OWLAPIReasoner.class,ks);
    rc.init();
    baseURI=rc.getBaseURI();
    RhoDRDown op=new RhoDRDown(rc);
    Description concept=KBParser.parseConcept(uri(""String_Node_Str""));
    Set<Description> results=op.refine(concept,4,null);
    for (    Description result : results) {
      System.out.println(result);
    }
    int desiredResultSize=141;
    if (results.size() != desiredResultSize) {
      System.out.println(results.size() + ""String_Node_Str"" + desiredResultSize+ ""String_Node_Str"");
    }
    assertTrue(results.size() == desiredResultSize);
  }
 catch (  ComponentInitException e) {
    e.printStackTrace();
  }
catch (  ParseException e) {
    e.printStackTrace();
  }
}","/** 
 * Applies the RhoDRDown operator to a concept and checks that the number of refinements is correct.
 */
@Test public void rhoDRDownTest(){
  try {
    String file=""String_Node_Str"";
    ComponentManager cm=ComponentManager.getInstance();
    AbstractKnowledgeSource ks=cm.knowledgeSource(OWLFile.class);
    try {
      cm.applyConfigEntry(ks,""String_Node_Str"",new File(file).toURI().toURL());
    }
 catch (    MalformedURLException e) {
      e.printStackTrace();
    }
    ks.init();
    AbstractReasonerComponent rc=cm.reasoner(OWLAPIReasoner.class,ks);
    rc.init();
    baseURI=rc.getBaseURI();
    RhoDRDown op=new RhoDRDown();
    op.setReasoner(rc);
    Description concept=KBParser.parseConcept(uri(""String_Node_Str""));
    Set<Description> results=op.refine(concept,4,null);
    for (    Description result : results) {
      System.out.println(result);
    }
    int desiredResultSize=141;
    if (results.size() != desiredResultSize) {
      System.out.println(results.size() + ""String_Node_Str"" + desiredResultSize+ ""String_Node_Str"");
    }
    assertTrue(results.size() == desiredResultSize);
  }
 catch (  ComponentInitException e) {
    e.printStackTrace();
  }
catch (  ParseException e) {
    e.printStackTrace();
  }
}"
9569,"@Test public void rhoDRDownTest5() throws ParseException, LearningProblemUnsupportedException {
  AbstractReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.SWORE);
  RefinementOperator operator=new RhoDRDown(rs);
  Description concept=KBParser.parseConcept(""String_Node_Str"");
  System.out.println(concept);
  Set<Description> refinements=operator.refine(concept,7);
  for (  Description refinement : refinements) {
    System.out.println(refinement);
  }
}","@Test public void rhoDRDownTest5() throws ParseException, LearningProblemUnsupportedException {
  AbstractReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.SWORE);
  RefinementOperator operator=new RhoDRDown();
  ((RhoDRDown)operator).setReasoner(rs);
  Description concept=KBParser.parseConcept(""String_Node_Str"");
  System.out.println(concept);
  Set<Description> refinements=operator.refine(concept,7);
  for (  Description refinement : refinements) {
    System.out.println(refinement);
  }
}"
9570,"public void run() throws IOException {
  if (writeSpringConfiguration) {
    SpringConfigurationXMLBeanConverter converter=new SpringConfigurationXMLBeanConverter();
    XmlObject xml;
    if (configuration == null) {
      Resource confFileR=new FileSystemResource(confFile);
      configuration=new ConfParserConfiguration(confFileR);
      xml=converter.convert(configuration);
    }
 else {
      xml=converter.convert(configuration);
    }
    String springFilename=confFile.getCanonicalPath().replace(""String_Node_Str"",""String_Node_Str"");
    File springFile=new File(springFilename);
    if (springFile.exists()) {
      logger.warn(""String_Node_Str"" + springFilename + ""String_Node_Str"");
    }
 else {
      Files.createFile(springFile,xml.toString());
    }
  }
  if (performCrossValidation) {
    AbstractReasonerComponent rs=context.getBean(AbstractReasonerComponent.class);
    PosNegLP lp=context.getBean(PosNegLP.class);
    AbstractCELA la=context.getBean(AbstractCELA.class);
    new CrossValidation(la,lp,rs,nrOfFolds,false);
  }
 else {
    LearningAlgorithm algorithm=context.getBean(LearningAlgorithm.class);
    algorithm.start();
  }
}","public void run() throws IOException {
  if (writeSpringConfiguration) {
    SpringConfigurationXMLBeanConverter converter=new SpringConfigurationXMLBeanConverter();
    XmlObject xml;
    if (configuration == null) {
      Resource confFileR=new FileSystemResource(confFile);
      configuration=new ConfParserConfiguration(confFileR);
      xml=converter.convert(configuration);
    }
 else {
      xml=converter.convert(configuration);
    }
    String springFilename=confFile.getCanonicalPath().replace(""String_Node_Str"",""String_Node_Str"");
    File springFile=new File(springFilename);
    if (springFile.exists()) {
      logger.warn(""String_Node_Str"" + springFilename + ""String_Node_Str"");
    }
 else {
      Files.createFile(springFile,xml.toString());
    }
  }
  if (performCrossValidation) {
    AbstractReasonerComponent rs=context.getBean(AbstractReasonerComponent.class);
    PosNegLP lp=context.getBean(PosNegLP.class);
    AbstractCELA la=context.getBean(AbstractCELA.class);
    new CrossValidation(la,lp,rs,nrOfFolds,false);
  }
 else {
    knowledgeSource=context.getBean(KnowledgeSource.class);
    algorithm=context.getBean(LearningAlgorithm.class);
    algorithm.start();
  }
}"
9571,"public static void getAllConfs(File f,String path,HashMap<String,ArrayList<String>> confs){
  path=path + File.separator;
  String[] act=f.list();
  for (int i=0; i < act.length; i++) {
    if (new File(path + act[i]).isDirectory()) {
      getAllConfs(new File(path + act[i]),path + act[i],confs);
    }
 else     if (act[i].endsWith(""String_Node_Str"")) {
      if (confs.get(path) == null) {
        confs.put(path,new ArrayList<String>());
      }
      confs.get(path).add(act[i].substring(0,act[i].length() - 5));
      conffiles.add(path + act[i]);
    }
  }
}","public static void getAllConfs(File f,String path,Map<String,ArrayList<String>> confs){
  path=path + File.separator;
  String[] act=f.list();
  for (int i=0; i < act.length; i++) {
    if (new File(path + act[i]).isDirectory()) {
      getAllConfs(new File(path + act[i]),path + act[i],confs);
    }
 else     if (act[i].endsWith(""String_Node_Str"")) {
      if (confs.get(path) == null) {
        confs.put(path,new ArrayList<String>());
      }
      confs.get(path).add(act[i].substring(0,act[i].length() - 5));
      conffiles.add(path + act[i]);
    }
  }
}"
9572,"/** 
 * This test runs all conf files in the examples directory. Each conf file corresponds to one unit test, which is succesful if a concept was learned. This unit test takes several hours.
 * @throws ComponentInitException If any component initialisation exception occurs in the process.
 */
@Test public void testAllConfFiles() throws ComponentInitException {
  boolean randomize=true;
  boolean testGP=false;
  int sparql=0;
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  Logger logger=Logger.getRootLogger();
  logger.removeAllAppenders();
  logger.addAppender(consoleAppender);
  logger.setLevel(Level.WARN);
  HashMap<String,ArrayList<String>> confFiles=new HashMap<String,ArrayList<String>>();
  String exampleDir=""String_Node_Str"" + File.separator + ""String_Node_Str"";
  File f=new File(exampleDir);
  QuickStart.getAllConfs(f,exampleDir,confFiles);
  List<String> examples=new LinkedList<String>();
  for (  Map.Entry<String,ArrayList<String>> entry : confFiles.entrySet()) {
    for (    String file : entry.getValue()) {
      examples.add(entry.getKey() + file + ""String_Node_Str"");
    }
  }
  if (randomize) {
    Collections.shuffle(examples,new Random());
  }
 else {
    Collections.sort(examples);
  }
  SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
  Set<String> ignore=new TreeSet<String>();
  ignore.add(""String_Node_Str"");
  ignore.add(""String_Node_Str"");
  ignore.add(""String_Node_Str"");
  ignore.add(""String_Node_Str"");
  ignore.add(""String_Node_Str"");
  int failedCounter=0;
  int counter=1;
  int total=examples.size();
  for (  String conf : examples) {
    boolean ignored=false;
    for (    String ignoredConfExpression : ignore) {
      if (conf.contains(ignoredConfExpression)) {
        ignored=true;
        break;
      }
    }
    if (ignored) {
      System.out.println(""String_Node_Str"" + conf + ""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"" + conf + ""String_Node_Str""+ counter+ ""String_Node_Str""+ total+ ""String_Node_Str""+ sdf.format(new Date())+ ""String_Node_Str"");
      long startTime=System.nanoTime();
      boolean success=false, started=false;
      try {
        CLI start=new CLI(new File(conf));
        start.init();
        start.run();
        boolean isSparql=start.getKnowledgeSource() instanceof SparqlKnowledgeSource;
        LearningAlgorithm algorithm=start.getLearningAlgorithm();
        if ((testGP || !(algorithm instanceof GP)) && (sparql == 0 || (sparql == 1 && isSparql) || (sparql == 2 && !isSparql))) {
          started=true;
          if (algorithm instanceof AbstractCELA) {
            assert(((AbstractCELA)algorithm).getCurrentlyBestDescription() != null);
          }
          success=true;
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        assert(false);
        e.printStackTrace();
        failedCounter++;
      }
      long timeNeeded=System.nanoTime() - startTime;
      ComponentManager.getInstance().freeAllComponents();
      if (!success && started) {
        System.out.println(""String_Node_Str"");
      }
      if (started) {
        System.out.println(""String_Node_Str"" + conf + ""String_Node_Str""+ Helper.prettyPrintNanoSeconds(timeNeeded)+ ""String_Node_Str"");
      }
    }
    counter++;
  }
  System.out.println(""String_Node_Str"" + failedCounter + ""String_Node_Str"");
}","/** 
 * This test runs all conf files in the examples directory. Each conf file corresponds to one unit test, which is succesful if a concept was learned. This unit test takes several hours.
 * @throws ComponentInitException If any component initialisation exception occurs in the process.
 */
@Test public void testAllConfFiles() throws ComponentInitException {
  boolean randomize=false;
  boolean testGP=false;
  int sparql=0;
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  Logger logger=Logger.getRootLogger();
  logger.removeAllAppenders();
  logger.addAppender(consoleAppender);
  logger.setLevel(Level.WARN);
  Map<String,ArrayList<String>> confFiles=new TreeMap<String,ArrayList<String>>();
  String exampleDir=""String_Node_Str"" + File.separator + ""String_Node_Str"";
  File f=new File(exampleDir);
  QuickStart.getAllConfs(f,exampleDir,confFiles);
  List<String> examples=new LinkedList<String>();
  for (  Map.Entry<String,ArrayList<String>> entry : confFiles.entrySet()) {
    for (    String file : entry.getValue()) {
      examples.add(entry.getKey() + file + ""String_Node_Str"");
    }
  }
  if (randomize) {
    Collections.shuffle(examples,new Random());
  }
 else {
    Collections.sort(examples);
  }
  SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
  Set<String> ignore=new TreeSet<String>();
  ignore.add(""String_Node_Str"");
  ignore.add(""String_Node_Str"");
  ignore.add(""String_Node_Str"");
  ignore.add(""String_Node_Str"");
  ignore.add(""String_Node_Str"");
  int failedCounter=0;
  int counter=1;
  int total=examples.size();
  for (  String conf : examples) {
    boolean ignored=false;
    for (    String ignoredConfExpression : ignore) {
      if (conf.contains(ignoredConfExpression)) {
        ignored=true;
        break;
      }
    }
    if (ignored) {
      System.out.println(""String_Node_Str"" + conf + ""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"" + conf + ""String_Node_Str""+ counter+ ""String_Node_Str""+ total+ ""String_Node_Str""+ sdf.format(new Date())+ ""String_Node_Str"");
      long startTime=System.nanoTime();
      boolean success=false, started=false;
      try {
        CLI start=new CLI(new File(conf));
        start.init();
        start.run();
        boolean isSparql=start.getKnowledgeSource() instanceof SparqlKnowledgeSource;
        LearningAlgorithm algorithm=start.getLearningAlgorithm();
        if ((testGP || !(algorithm instanceof GP)) && (sparql == 0 || (sparql == 1 && isSparql) || (sparql == 2 && !isSparql))) {
          started=true;
          if (algorithm instanceof AbstractCELA) {
            assert(((AbstractCELA)algorithm).getCurrentlyBestDescription() != null);
          }
          success=true;
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        assert(false);
        e.printStackTrace();
        failedCounter++;
      }
      long timeNeeded=System.nanoTime() - startTime;
      ComponentManager.getInstance().freeAllComponents();
      if (!success && started) {
        System.out.println(""String_Node_Str"");
      }
      if (started) {
        System.out.println(""String_Node_Str"" + conf + ""String_Node_Str""+ Helper.prettyPrintNanoSeconds(timeNeeded)+ ""String_Node_Str"");
      }
    }
    counter++;
  }
  System.out.println(""String_Node_Str"" + failedCounter + ""String_Node_Str"");
}"
9573,"private PdbRdfModel extractDataForPdbAndChain(PdbRdfModel model,String pdbID,String chainID){
  PdbRdfModel construct=new PdbRdfModel();
  String queryString=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  if (chainID.length() == 1 && pdbID.length() == 4) {
    queryString+=""String_Node_Str"" + pdbID.toUpperCase() + ""String_Node_Str""+ chainID.toUpperCase()+ ""String_Node_Str"";
  }
  queryString+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  System.out.println(queryString);
  Query query=QueryFactory.create(queryString);
  QueryExecution qe=QueryExecutionFactory.create(query,model);
  construct.add(qe.execConstruct());
  qe.close();
  return construct;
}","private PdbRdfModel extractDataForPdbAndChain(PdbRdfModel model,String pdbID,String chainID){
  PdbRdfModel construct=new PdbRdfModel();
  String queryString=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  if (chainID.length() == 1 && pdbID.length() == 4) {
    queryString+=""String_Node_Str"" + pdbID.toUpperCase() + ""String_Node_Str""+ chainID.toUpperCase()+ ""String_Node_Str"";
  }
  queryString+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  System.out.println(queryString);
  Query query=QueryFactory.create(queryString);
  QueryExecution qe=QueryExecutionFactory.create(query,model);
  construct.add(qe.execConstruct());
  qe.close();
  return construct;
}"
9574,"private HashMap<Integer,Resource> createPositionResidueMap(){
  HashMap<Integer,Resource> posres=new HashMap<Integer,Resource>(150);
  Property iib=ResourceFactory.createProperty(""String_Node_Str"",""String_Node_Str"");
  ResIterator firstAAs=this.getFirstAA();
  while (firstAAs.hasNext()) {
    Resource firstAA=firstAAs.next();
    Resource nextAA=firstAA;
    Resource currentAA=firstAA;
    do {
      currentAA=nextAA;
      posres.put(new Integer(this.getResiduePosition(currentAA)),currentAA);
      nextAA=_pdbIdModel.getProperty(currentAA,iib).getResource();
    }
 while (currentAA.hasProperty(iib));
  }
  return posres;
}","private HashMap<Integer,Resource> createPositionResidueMap(){
  HashMap<Integer,Resource> posres=new HashMap<Integer,Resource>(150);
  Property iib=ResourceFactory.createProperty(""String_Node_Str"",""String_Node_Str"");
  ResIterator firstAAs=this.getFirstAA();
  while (firstAAs.hasNext()) {
    Resource firstAA=firstAAs.next();
    Resource currentAA=firstAA;
    posres.put(new Integer(this.getResiduePosition(currentAA)),currentAA);
    while (currentAA.hasProperty(iib)) {
      currentAA=_pdbIdModel.getProperty(currentAA,iib).getResource();
      posres.put(new Integer(this.getResiduePosition(currentAA)),currentAA);
    }
  }
  return posres;
}"
9575,"private int getResiduePosition(Resource res){
  Property hasChainPosition=ResourceFactory.createProperty(""String_Node_Str"",""String_Node_Str"");
  Property label=ResourceFactory.createProperty(""String_Node_Str"",""String_Node_Str"");
  ResourceFactory.createResource();
  NodeIterator residuePosition=_pdbIdModel.listObjectsOfProperty(res,hasChainPosition);
  ArrayList<RDFNode> positionNodes=new ArrayList<RDFNode>();
  ArrayList<String> positionLabels=new ArrayList<String>();
  while (residuePosition.hasNext()) {
    RDFNode positionNode=residuePosition.next();
    positionNodes.add(positionNode);
    NodeIterator positionLabelNodes=_pdbIdModel.listObjectsOfProperty(positionNode.asResource(),label);
    while (positionLabelNodes.hasNext()) {
      positionLabels.add(positionLabelNodes.next().toString());
    }
  }
  Integer position=null;
  if (positionNodes.size() == 1 && positionLabels.size() == 1) {
    String positionLabel=positionLabels.get(0);
    String a=new String(""String_Node_Str"");
    String b=new String(""String_Node_Str"");
    position=Integer.parseInt(positionLabel.substring(positionLabel.indexOf(a) + a.length(),positionLabel.indexOf(b)));
  }
 else {
    position=new Integer(0);
    _logger.error(""String_Node_Str"");
  }
  return position.intValue();
}","private int getResiduePosition(Resource res){
  Property hasChainPosition=ResourceFactory.createProperty(""String_Node_Str"",""String_Node_Str"");
  Property hasValue=ResourceFactory.createProperty(""String_Node_Str"",""String_Node_Str"");
  ResourceFactory.createResource();
  NodeIterator residuePosition=_pdbIdModel.listObjectsOfProperty(res,hasChainPosition);
  ArrayList<RDFNode> positionNodes=new ArrayList<RDFNode>();
  ArrayList<Integer> positionLabels=new ArrayList<Integer>();
  while (residuePosition.hasNext()) {
    RDFNode positionNode=residuePosition.next();
    positionNodes.add(positionNode);
    NodeIterator positionLabelNodes=_pdbIdModel.listObjectsOfProperty(positionNode.asResource(),hasValue);
    while (positionLabelNodes.hasNext()) {
      positionLabels.add(positionLabelNodes.next().asLiteral().getInt());
    }
  }
  Integer position=null;
  if (positionNodes.size() == 1 && positionLabels.size() == 1) {
    position=positionLabels.get(0);
  }
 else {
    position=new Integer(0);
    _logger.error(""String_Node_Str"");
  }
  return position.intValue();
}"
9576,"@Autowired public void setLearningProblem(AbstractLearningProblem learningProblem){
  this.learningProblem=learningProblem;
}","@Autowired public void setLearningProblem(LearningProblem learningProblem){
  this.learningProblem=learningProblem;
}"
9577,"public AbstractLearningProblem getLearningProblem(){
  return learningProblem;
}","public LearningProblem getLearningProblem(){
  return learningProblem;
}"
9578,"public void create_Sparql_query(String question) throws JWNLException, IOException {
  ArrayList<String> lstquery=new ArrayList<String>();
  lstquery=getQuery(question);
  for (  String query : lstquery) {
    if (getIterationdepth() == -1) {
      String tmp=new String();
      String s=null;
      BufferedReader in=null;
      try {
        in=new BufferedReader(new InputStreamReader(new FileInputStream(""String_Node_Str"")));
        while (null != (s=in.readLine())) {
          tmp=tmp + ""String_Node_Str"" + s;
        }
      }
 catch (      FileNotFoundException ex) {
      }
catch (      Exception ex) {
        System.out.println(ex);
      }
 finally {
        if (in != null)         try {
          in.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      String out=null;
      if (query == ""String_Node_Str"" || query == ""String_Node_Str"")       query=""String_Node_Str"";
      out=tmp + ""String_Node_Str"" + question+ ""String_Node_Str""+ query+ ""String_Node_Str"";
      BufferedWriter outfile=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(""String_Node_Str"")));
      outfile.write(out);
      outfile.close();
    }
    if (getIterationdepth() == 0) {
      String tmp=new String();
      String s=null;
      BufferedReader in=null;
      try {
        in=new BufferedReader(new InputStreamReader(new FileInputStream(""String_Node_Str"")));
        while (null != (s=in.readLine())) {
          tmp=tmp + ""String_Node_Str"" + s;
        }
      }
 catch (      FileNotFoundException ex) {
      }
catch (      Exception ex) {
        System.out.println(ex);
      }
 finally {
        if (in != null)         try {
          in.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      String answer;
      answer=sendServerQuestionRequest(query);
      System.out.println(""String_Node_Str"" + answer);
      String out=tmp + ""String_Node_Str"" + question+ ""String_Node_Str""+ answer+ ""String_Node_Str"";
      BufferedWriter outfile=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(""String_Node_Str"")));
      outfile.write(out);
      outfile.close();
    }
    if (getIterationdepth() == 1) {
    }
    if (getIterationdepth() == 2) {
    }
  }
}","public void create_Sparql_query(String question) throws JWNLException, IOException {
  ArrayList<String> lstquery=new ArrayList<String>();
  lstquery=getQuery(question);
  for (  String query : lstquery) {
    if (getIterationdepth() == -1) {
      String tmp=new String();
      String s=null;
      BufferedReader in=null;
      try {
        in=new BufferedReader(new InputStreamReader(new FileInputStream(""String_Node_Str"")));
        while (null != (s=in.readLine())) {
          tmp=tmp + ""String_Node_Str"" + s;
        }
      }
 catch (      FileNotFoundException ex) {
      }
catch (      Exception ex) {
        System.out.println(ex);
      }
 finally {
        if (in != null)         try {
          in.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      String out=null;
      if (query == ""String_Node_Str"" || query == ""String_Node_Str"")       query=""String_Node_Str"";
      out=tmp + ""String_Node_Str"" + question+ ""String_Node_Str""+ query+ ""String_Node_Str"";
      BufferedWriter outfile=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(""String_Node_Str"")));
      outfile.write(out);
      outfile.close();
    }
    if (getIterationdepth() == 0) {
      String tmp=new String();
      String s=null;
      BufferedReader in=null;
      try {
        in=new BufferedReader(new InputStreamReader(new FileInputStream(""String_Node_Str"")));
        while (null != (s=in.readLine())) {
          tmp=tmp + ""String_Node_Str"" + s;
        }
      }
 catch (      FileNotFoundException ex) {
      }
catch (      Exception ex) {
        System.out.println(ex);
      }
 finally {
        if (in != null)         try {
          in.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      String answer;
      answer=sendServerQuestionRequest(query);
      System.out.println(query);
      System.out.println(""String_Node_Str"" + answer);
      String out=tmp + ""String_Node_Str"" + ""String_Node_Str""+ question+ ""String_Node_Str""+ ""String_Node_Str""+ query+ ""String_Node_Str""+ answer+ ""String_Node_Str"";
      BufferedWriter outfile=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(""String_Node_Str"")));
      outfile.write(out);
      outfile.close();
    }
    if (getIterationdepth() == 1) {
    }
    if (getIterationdepth() == 2) {
    }
  }
}"
9579,"private String createAnswer(String string){
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  return string;
}","private String createAnswer(String string){
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  string=string.replace(""String_Node_Str"",""String_Node_Str"");
  return string;
}"
9580,"/** 
 * Method gets a String and takes the information from the templator to creat a Sparql query.
 * @param question question in natural language
 * @return ArrayList of Sparql queries.
 */
private ArrayList<String> getQuery(String question){
  ArrayList<String> lstquery=new ArrayList<String>();
  Set<BasicQueryTemplate> querytemps=btemplator.buildBasicQueries(question);
  for (  BasicQueryTemplate temp : querytemps) {
    String query;
    String selTerms=""String_Node_Str"";
    for (    SPARQL_Term terms : temp.getSelTerms())     selTerms=selTerms + (terms.toString()) + ""String_Node_Str"";
    String conditions=""String_Node_Str"";
    for (    Path condition : temp.getConditions())     conditions=conditions + (condition.toString()) + ""String_Node_Str"";
    String filters=""String_Node_Str"";
    for (    SPARQL_Filter tmp : temp.getFilters())     filters=filters + tmp + ""String_Node_Str"";
    System.out.println(""String_Node_Str"");
    query=""String_Node_Str"" + temp.getQt().toString() + ""String_Node_Str""+ selTerms+ ""String_Node_Str""+ conditions.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ filters;
    String[] slots=null;
    for (    Slot slot : temp.getSlots()) {
      String tmp=slot.toString();
      tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
      tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
      tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
      tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
      tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
      String[] array=tmp.split(""String_Node_Str"");
      String replace;
      if (array[0].length() < 2)       replace=""String_Node_Str"" + array[0] + ""String_Node_Str"";
 else       replace=""String_Node_Str"" + array[0];
      query=query.replace(replace,""String_Node_Str"" + hm.get(array[1].toLowerCase()) + ""String_Node_Str"");
    }
    lstquery.add(query);
  }
  return lstquery;
}","/** 
 * Method gets a String and takes the information from the templator to creat a Sparql query.
 * @param question question in natural language
 * @return ArrayList of Sparql queries.
 */
private ArrayList<String> getQuery(String question){
  ArrayList<String> lstquery=new ArrayList<String>();
  Set<BasicQueryTemplate> querytemps=btemplator.buildBasicQueries(question);
  for (  BasicQueryTemplate temp : querytemps) {
    String query;
    String selTerms=""String_Node_Str"";
    for (    SPARQL_Term terms : temp.getSelTerms())     selTerms=selTerms + (terms.toString()) + ""String_Node_Str"";
    String conditions=""String_Node_Str"";
    for (    Path condition : temp.getConditions())     conditions=conditions + (condition.toString()) + ""String_Node_Str"";
    String filters=""String_Node_Str"";
    for (    SPARQL_Filter tmp : temp.getFilters())     filters=filters + tmp + ""String_Node_Str"";
    System.out.println(""String_Node_Str"");
    query=""String_Node_Str"" + temp.getQt().toString() + ""String_Node_Str""+ selTerms+ ""String_Node_Str""+ conditions.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ filters;
    String conditions_new=""String_Node_Str"";
    for (    Path condition : temp.getConditions()) {
      String[] tmp_upside=condition.toString().split(""String_Node_Str"");
      String tmp_conditions_new=""String_Node_Str"";
      for (      String con : tmp_upside)       tmp_conditions_new=con + ""String_Node_Str"" + tmp_conditions_new;
      tmp_conditions_new=tmp_conditions_new.replace(""String_Node_Str"",""String_Node_Str"");
      tmp_conditions_new=tmp_conditions_new + ""String_Node_Str"";
      conditions_new=conditions_new + tmp_conditions_new;
    }
    System.out.println(""String_Node_Str"" + conditions);
    System.out.println(""String_Node_Str"" + conditions_new);
    String query_upside_down=""String_Node_Str"" + temp.getQt().toString() + ""String_Node_Str""+ selTerms+ ""String_Node_Str""+ conditions_new.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ filters;
    String[] slots=null;
    for (    Slot slot : temp.getSlots()) {
      String tmp=slot.toString();
      tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
      tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
      tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
      tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
      tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
      String[] array=tmp.split(""String_Node_Str"");
      String replace;
      if (array[0].length() < 2)       replace=""String_Node_Str"" + array[0] + ""String_Node_Str"";
 else       replace=""String_Node_Str"" + array[0];
      String hm_result=hm.get(array[1].toLowerCase());
      try {
        if (hm_result.contains(""String_Node_Str""))         hm_result=hm_result.replace(""String_Node_Str"",""String_Node_Str"");
      }
 catch (      Exception e) {
      }
      query=query.replace(replace,""String_Node_Str"" + hm_result + ""String_Node_Str"");
      query_upside_down=query_upside_down.replace(replace,""String_Node_Str"" + hm_result + ""String_Node_Str"");
    }
    lstquery.add(query);
    lstquery.add(query_upside_down);
  }
  return lstquery;
}"
9581,"private Description rewriteNode(OENode node){
  Description description=node.getDescription();
  Description niceDescription=minimizer.minimizeClone(description);
  ConceptTransformation.replaceRange(niceDescription,reasoner);
  return niceDescription;
}","private Description rewriteNode(OENode node){
  Description description=node.getDescription();
  Description niceDescription;
  if (useMinimizer) {
    niceDescription=minimizer.minimizeClone(description);
  }
 else {
    niceDescription=description;
  }
  ConceptTransformation.replaceRange(niceDescription,reasoner);
  return niceDescription;
}"
9582,"private TreeSet<ObjectProperty> getFirstObjectProperties(NodeSet<OWLObjectPropertyExpression> nodeSet){
  TreeSet<ObjectProperty> roles=new TreeSet<ObjectProperty>(roleComparator);
  for (  Node<OWLObjectPropertyExpression> node : nodeSet) {
    if (node.isBottomNode() || node.isTopNode()) {
      continue;
    }
    OWLObjectPropertyExpression property=node.getRepresentativeElement();
    roles.add(new ObjectProperty(property.asOWLObjectProperty().toStringID()));
  }
  roles.remove(new ObjectProperty(factory.getOWLTopObjectProperty().toStringID()));
  roles.remove(new ObjectProperty(factory.getOWLBottomObjectProperty().toStringID()));
  return roles;
}","private TreeSet<ObjectProperty> getFirstObjectProperties(NodeSet<OWLObjectPropertyExpression> nodeSet){
  TreeSet<ObjectProperty> roles=new TreeSet<ObjectProperty>(roleComparator);
  for (  Node<OWLObjectPropertyExpression> node : nodeSet) {
    if (node.isBottomNode() || node.isTopNode()) {
      continue;
    }
    OWLObjectPropertyExpression property=node.getRepresentativeElement();
    if (!property.isAnonymous()) {
      roles.add(new ObjectProperty(property.asOWLObjectProperty().toStringID()));
    }
  }
  roles.remove(new ObjectProperty(factory.getOWLTopObjectProperty().toStringID()));
  roles.remove(new ObjectProperty(factory.getOWLBottomObjectProperty().toStringID()));
  return roles;
}"
9583,"public static void main(String args[]) throws IOException {
  int nrOfFolds=5;
  String baseDir=""String_Node_Str"";
  String outputFile=""String_Node_Str"";
  String content=""String_Node_Str"";
  String[] tools=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String topics[]=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String topiclabels[]=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String tool : tools) {
    content+=""String_Node_Str"" + tool;
  }
  content+=""String_Node_Str"";
  for (int i=0; i < topics.length; i++) {
    content+=topiclabels[i] + ""String_Node_Str"";
    for (    String tool : tools) {
      String conf=baseDir + tool + ""String_Node_Str""+ topics[i]+ ""String_Node_Str"";
      File confFile=new File(conf);
      System.out.print(""String_Node_Str"" + confFile);
      CLI cli=new CLI(confFile);
      cli.init();
      System.out.println(""String_Node_Str"" + confFile + ""String_Node_Str"");
      ApplicationContext context=cli.getContext();
      AbstractReasonerComponent rs=context.getBean(AbstractReasonerComponent.class);
      PosNegLP lp=context.getBean(PosNegLP.class);
      AbstractCELA la=context.getBean(AbstractCELA.class);
      CrossValidation cv=new CrossValidation(la,lp,rs,nrOfFolds,false);
      content+=Math.round(cv.getfMeasure().getMean()) + ""String_Node_Str"";
    }
    content+=""String_Node_Str"";
  }
  Files.createFile(new File(baseDir + outputFile),content);
}","public static void main(String args[]) throws IOException {
  int nrOfFolds=5;
  String baseDir=""String_Node_Str"";
  String outputFile=""String_Node_Str"";
  String content=""String_Node_Str"";
  String[] tools=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String topics[]=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String topiclabels[]=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String tool : tools) {
    content+=""String_Node_Str"" + tool;
  }
  content+=""String_Node_Str"";
  for (int i=0; i < topics.length; i++) {
    content+=topiclabels[i] + ""String_Node_Str"";
    for (    String tool : tools) {
      String conf=baseDir + tool + ""String_Node_Str""+ topics[i]+ ""String_Node_Str"";
      File confFile=new File(conf);
      System.out.print(""String_Node_Str"" + confFile);
      CLI cli=new CLI(confFile);
      cli.init();
      System.out.println(""String_Node_Str"" + confFile + ""String_Node_Str"");
      ApplicationContext context=cli.getContext();
      AbstractReasonerComponent rs=context.getBean(AbstractReasonerComponent.class);
      PosNegLP lp=context.getBean(PosNegLP.class);
      AbstractCELA la=context.getBean(AbstractCELA.class);
      CrossValidation cv=new CrossValidation(la,lp,rs,nrOfFolds,false);
      content+=Math.round(cv.getfMeasure().getMean()) + ""String_Node_Str"";
    }
    content+=""String_Node_Str"";
  }
  Files.createFile(new File(baseDir + outputFile),content);
}"
9584,"/** 
 * gets synonyms, attribute etc. from WordNet and construct grammar entries  INPUT:  array of tokens and array of POStags, from which preprocessor constructs a list of pairs (token,pos) OUTPUT: list of (treestring,dude) 
 */
public List<String[]> build(String taggedstring,List<Pair<String,String>> tokenPOSpairs){
  List<String[]> result=new ArrayList<String[]>();
  for (  Pair<String,String> pair : tokenPOSpairs) {
    String token=pair.fst;
    String pos=pair.snd;
    String type=""String_Node_Str"";
    if (equalsOneOf(pos,noun)) {
      if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        type=""String_Node_Str"";
      }
 else       if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        type=""String_Node_Str"";
      }
 else       if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        type=""String_Node_Str"";
      }
      List<String> words=new ArrayList<String>();
      words.add(token);
      if (!pos.equals(""String_Node_Str"") && !pos.equals(""String_Node_Str"") && !pos.equals(""String_Node_Str"")) {
      }
      String tokenfluent=token.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      String slotX=""String_Node_Str"" + type + ""String_Node_Str"";
      String slotP=""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ type+ ""String_Node_Str"";
      String slotC=""String_Node_Str"" + tokenfluent + ""String_Node_Str"";
      for (Iterator<String> i=words.iterator(); i.hasNext(); ) {
        String next=i.next().replaceAll(""String_Node_Str"",""String_Node_Str"");
        slotX+=next;
        slotP+=next;
        slotC+=next;
        if (i.hasNext()) {
          slotX+=""String_Node_Str"";
          slotP+=""String_Node_Str"";
          slotC+=""String_Node_Str"";
        }
      }
      String treetoken=""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"";
      if (token.trim().contains(""String_Node_Str"")) {
        String[] tokenParts=token.split(""String_Node_Str"");
        treetoken=""String_Node_Str"";
        for (        String t : tokenParts) {
          treetoken+=""String_Node_Str"" + t.toLowerCase() + ""String_Node_Str"";
        }
        treetoken=treetoken.trim();
      }
      if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        String[] dpEntry1={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""};
        String[] dpEntry2={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""};
        result.add(dpEntry1);
        result.add(dpEntry2);
        String[] npEntry1={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""};
        String[] npEntry2={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""};
        result.add(npEntry1);
        result.add(npEntry2);
      }
 else       if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        String[] dpEntry1={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + slotX + ""String_Node_Str""};
        String[] dpEntry2={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + slotX + ""String_Node_Str""};
        result.add(dpEntry1);
        result.add(dpEntry2);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] dpEntry1={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""+ ""String_Node_Str""+ tokenfluent+ ""String_Node_Str""+ slotC+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] dpEntry2={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""+ ""String_Node_Str""+ tokenfluent+ ""String_Node_Str""+ slotC+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] npEntry={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""+ ""String_Node_Str""+ tokenfluent+ ""String_Node_Str""+ slotC+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(dpEntry1);
        result.add(dpEntry2);
        result.add(npEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String jjtoken=token.substring(0,token.indexOf(""String_Node_Str""));
        String nntoken=token.substring(token.indexOf(""String_Node_Str"") + 1);
        String slotfluent=""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ token;
        String slotnn=""String_Node_Str"" + nntoken + ""String_Node_Str""+ nntoken;
        String slotnnc=""String_Node_Str"" + nntoken + ""String_Node_Str""+ nntoken;
        String slotjj=""String_Node_Str"" + jjtoken + ""String_Node_Str""+ jjtoken;
        String[] dpEntry1={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotfluent+ ""String_Node_Str""+ ""String_Node_Str""+ jjtoken+ ""String_Node_Str""+ nntoken+ ""String_Node_Str""+ slotnn+ ""String_Node_Str""+ slotjj+ ""String_Node_Str""+ ""String_Node_Str""+ jjtoken+ ""String_Node_Str""+ nntoken+ ""String_Node_Str""+ slotnnc+ ""String_Node_Str""+ slotjj+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] dpEntry2={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotfluent+ ""String_Node_Str""+ ""String_Node_Str""+ jjtoken+ ""String_Node_Str""+ nntoken+ ""String_Node_Str""+ slotnn+ ""String_Node_Str""+ slotjj+ ""String_Node_Str""+ ""String_Node_Str""+ jjtoken+ ""String_Node_Str""+ nntoken+ ""String_Node_Str""+ slotnnc+ ""String_Node_Str""+ slotjj+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] npEntry={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotfluent+ ""String_Node_Str""+ ""String_Node_Str""+ jjtoken+ ""String_Node_Str""+ nntoken+ ""String_Node_Str""+ slotnn+ ""String_Node_Str""+ slotjj+ ""String_Node_Str""+ ""String_Node_Str""+ jjtoken+ ""String_Node_Str""+ nntoken+ ""String_Node_Str""+ slotnnc+ ""String_Node_Str""+ slotjj+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(dpEntry1);
        result.add(dpEntry2);
        result.add(npEntry);
      }
 else       if (pos.equals(""String_Node_Str"") && token.contains(""String_Node_Str"")) {
        String[] tokens=token.split(""String_Node_Str"");
        String nntoken=tokens[tokens.length - 1];
        String slotfluent=""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ token;
        String slotnn=""String_Node_Str"" + nntoken + ""String_Node_Str""+ nntoken;
        String semantics=""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotfluent+ ""String_Node_Str""+ ""String_Node_Str""+ nntoken+ ""String_Node_Str"";
        String slots=slotnn;
        for (int i=0; i < (tokens.length - 1); i++) {
          semantics+=""String_Node_Str"" + tokens[i] + ""String_Node_Str"";
          slots+=""String_Node_Str"" + tokens[i] + ""String_Node_Str""+ tokens[i];
        }
        semantics+=""String_Node_Str"" + slots + ""String_Node_Str"";
        String[] npEntry={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",semantics};
        result.add(npEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String slot=""String_Node_Str"" + token + ""String_Node_Str""+ type+ ""String_Node_Str""+ token;
        String[] nnentry={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ token+ ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(nnentry);
      }
    }
 else     if (equalsOneOf(pos,verb)) {
      String slot;
      String symslot;
      slot=""String_Node_Str"" + token + ""String_Node_Str""+ token;
      symslot=""String_Node_Str"" + token + ""String_Node_Str""+ token;
      if (pos.equals(""String_Node_Str"")) {
        String[] passEntry1={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] passEntry2={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(passEntry1);
        result.add(passEntry2);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] passpartEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(passpartEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] passEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(passEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] passEntry1={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""};
        String[] passEntry2={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""};
        result.add(passEntry1);
        result.add(passEntry2);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] gerundinEntry1={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] gerundinEntry2={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(gerundinEntry1);
        result.add(gerundinEntry2);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] passEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] passEntry2={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""};
        String[] whEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(passEntry);
        result.add(passEntry2);
        result.add(whEntry);
      }
 else       if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        String[] vEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(vEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] whEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(whEntry);
      }
 else       if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        String[] gerEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] wasGerEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""};
        result.add(gerEntry);
        result.add(wasGerEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String dateSlot=""String_Node_Str"" + token + ""String_Node_Str""+ token+ ""String_Node_Str""+ token+ ""String_Node_Str"";
        String tokenSlot=""String_Node_Str"" + token + ""String_Node_Str""+ token;
        String[] whenEntry1={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ dateSlot+ ""String_Node_Str""};
        String[] whenEntry2={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ ""String_Node_Str""+ tokenSlot+ ""String_Node_Str""};
        result.add(whenEntry1);
        result.add(whenEntry2);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String placeSlot=""String_Node_Str"" + token + ""String_Node_Str""+ token+ ""String_Node_Str""+ token+ ""String_Node_Str"";
        String tokenSlot=""String_Node_Str"" + token + ""String_Node_Str""+ token;
        String[] whereEntry1={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ placeSlot+ ""String_Node_Str""};
        String[] whereEntry2={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ ""String_Node_Str""+ tokenSlot+ ""String_Node_Str""};
        result.add(whereEntry1);
        result.add(whereEntry2);
      }
    }
 else     if (equalsOneOf(pos,adjective)) {
      String slot=""String_Node_Str"" + token + ""String_Node_Str""+ token;
      if (pos.equals(""String_Node_Str"")) {
        String[] adjEntry={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(adjEntry);
      }
      if (pos.equals(""String_Node_Str"")) {
        String[] howEntry={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(howEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String pol=polarity(token);
        String comp;
        if (pol.equals(""String_Node_Str"")) {
          comp=""String_Node_Str"";
        }
 else {
          comp=""String_Node_Str"";
        }
        String[] compEntry1={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ token+ ""String_Node_Str""+ comp+ ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(compEntry1);
        String[] compEntry2={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ token+ ""String_Node_Str""+ comp+ ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(compEntry2);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String pol=polarity(token);
        String comp;
        if (pol.equals(""String_Node_Str"")) {
          comp=""String_Node_Str"";
        }
 else {
          comp=""String_Node_Str"";
        }
        String[] superEntry1={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ comp+ ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(superEntry1);
        String[] superEntry2={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ comp+ ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(superEntry2);
        String[] superEntry3={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ comp+ ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(superEntry3);
      }
    }
 else     if (equalsOneOf(pos,preps)) {
      String slot=""String_Node_Str"" + token + ""String_Node_Str""+ token;
      String[] npAdjunct={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ slot+ ""String_Node_Str""+ ""String_Node_Str""};
      String[] vpAdjunct={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ slot+ ""String_Node_Str""+ ""String_Node_Str""};
      result.add(npAdjunct);
      result.add(vpAdjunct);
    }
  }
  return result;
}","/** 
 * gets synonyms, attribute etc. from WordNet and construct grammar entries  INPUT:  array of tokens and array of POStags, from which preprocessor constructs a list of pairs (token,pos) OUTPUT: list of (treestring,dude) 
 */
public List<String[]> build(String taggedstring,List<Pair<String,String>> tokenPOSpairs){
  List<String[]> result=new ArrayList<String[]>();
  for (  Pair<String,String> pair : tokenPOSpairs) {
    String token=pair.fst;
    String pos=pair.snd;
    String type=""String_Node_Str"";
    if (equalsOneOf(pos,noun)) {
      if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        type=""String_Node_Str"";
      }
 else       if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        type=""String_Node_Str"";
      }
 else       if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        type=""String_Node_Str"";
      }
      List<String> words=new ArrayList<String>();
      words.add(token);
      if (!pos.equals(""String_Node_Str"") && !pos.equals(""String_Node_Str"") && !pos.equals(""String_Node_Str"")) {
      }
      String tokenfluent=token.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      String slotX=""String_Node_Str"" + type + ""String_Node_Str"";
      String slotP=""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ type+ ""String_Node_Str"";
      String slotC=""String_Node_Str"" + tokenfluent + ""String_Node_Str"";
      for (Iterator<String> i=words.iterator(); i.hasNext(); ) {
        String next=i.next().replaceAll(""String_Node_Str"",""String_Node_Str"");
        slotX+=next;
        slotP+=next;
        slotC+=next;
        if (i.hasNext()) {
          slotX+=""String_Node_Str"";
          slotP+=""String_Node_Str"";
          slotC+=""String_Node_Str"";
        }
      }
      String treetoken=""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"";
      if (token.trim().contains(""String_Node_Str"")) {
        String[] tokenParts=token.split(""String_Node_Str"");
        treetoken=""String_Node_Str"";
        for (        String t : tokenParts) {
          treetoken+=""String_Node_Str"" + t.toLowerCase() + ""String_Node_Str"";
        }
        treetoken=treetoken.trim();
      }
      if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        String[] dpEntry1={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""};
        String[] dpEntry2={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""};
        result.add(dpEntry1);
        result.add(dpEntry2);
        String[] npEntry1={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""};
        String[] npEntry2={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""};
        result.add(npEntry1);
        result.add(npEntry2);
      }
 else       if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        String[] dpEntry1={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + slotX + ""String_Node_Str""};
        String[] dpEntry2={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + slotX + ""String_Node_Str""};
        result.add(dpEntry1);
        result.add(dpEntry2);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] dpEntry1={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""+ ""String_Node_Str""+ tokenfluent+ ""String_Node_Str""+ slotC+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] dpEntry2={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""+ ""String_Node_Str""+ tokenfluent+ ""String_Node_Str""+ slotC+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] npEntry={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotP+ ""String_Node_Str""+ ""String_Node_Str""+ tokenfluent+ ""String_Node_Str""+ slotC+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(dpEntry1);
        result.add(dpEntry2);
        result.add(npEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String jjtoken=token.substring(0,token.indexOf(""String_Node_Str""));
        String nntoken=token.substring(token.indexOf(""String_Node_Str"") + 1);
        String slotfluent=""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ token;
        String slotnn=""String_Node_Str"" + nntoken + ""String_Node_Str""+ nntoken;
        String slotnnc=""String_Node_Str"" + nntoken + ""String_Node_Str""+ nntoken;
        String slotjj=""String_Node_Str"" + jjtoken + ""String_Node_Str""+ jjtoken;
        String[] dpEntry1={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotfluent+ ""String_Node_Str""+ ""String_Node_Str""+ jjtoken+ ""String_Node_Str""+ nntoken+ ""String_Node_Str""+ slotnn+ ""String_Node_Str""+ slotjj+ ""String_Node_Str""+ ""String_Node_Str""+ jjtoken+ ""String_Node_Str""+ nntoken+ ""String_Node_Str""+ slotnnc+ ""String_Node_Str""+ slotjj+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] dpEntry2={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotfluent+ ""String_Node_Str""+ ""String_Node_Str""+ jjtoken+ ""String_Node_Str""+ nntoken+ ""String_Node_Str""+ slotnn+ ""String_Node_Str""+ slotjj+ ""String_Node_Str""+ ""String_Node_Str""+ jjtoken+ ""String_Node_Str""+ nntoken+ ""String_Node_Str""+ slotnnc+ ""String_Node_Str""+ slotjj+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] npEntry={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotfluent+ ""String_Node_Str""+ ""String_Node_Str""+ jjtoken+ ""String_Node_Str""+ nntoken+ ""String_Node_Str""+ slotnn+ ""String_Node_Str""+ slotjj+ ""String_Node_Str""+ ""String_Node_Str""+ jjtoken+ ""String_Node_Str""+ nntoken+ ""String_Node_Str""+ slotnnc+ ""String_Node_Str""+ slotjj+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(dpEntry1);
        result.add(dpEntry2);
        result.add(npEntry);
      }
 else       if (pos.equals(""String_Node_Str"") && token.contains(""String_Node_Str"")) {
        String[] tokens=token.split(""String_Node_Str"");
        String nntoken=tokens[tokens.length - 1];
        String slotfluent=""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ token;
        String slotnn=""String_Node_Str"" + nntoken + ""String_Node_Str""+ nntoken;
        String semantics=""String_Node_Str"" + tokenfluent + ""String_Node_Str""+ slotfluent+ ""String_Node_Str""+ ""String_Node_Str""+ nntoken+ ""String_Node_Str"";
        String slots=slotnn;
        for (int i=0; i < (tokens.length - 1); i++) {
          semantics+=""String_Node_Str"" + tokens[i] + ""String_Node_Str"";
          slots+=""String_Node_Str"" + tokens[i] + ""String_Node_Str""+ tokens[i];
        }
        semantics+=""String_Node_Str"" + slots + ""String_Node_Str"";
        String[] npEntry={token,""String_Node_Str"" + treetoken + ""String_Node_Str"",semantics};
        result.add(npEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String slot=""String_Node_Str"" + token + ""String_Node_Str""+ type+ ""String_Node_Str""+ token;
        String[] nnentry={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ token+ ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(nnentry);
      }
    }
 else     if (equalsOneOf(pos,verb)) {
      String slot;
      String symslot;
      slot=""String_Node_Str"" + token + ""String_Node_Str""+ token;
      symslot=""String_Node_Str"" + token + ""String_Node_Str""+ token;
      if (pos.equals(""String_Node_Str"")) {
        String[] passEntry1={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] passEntry2={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(passEntry1);
        result.add(passEntry2);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] passpartEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(passpartEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] passEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(passEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] passEntry1={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""};
        String[] passEntry2={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""};
        result.add(passEntry1);
        result.add(passEntry2);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] gerundinEntry1={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] gerundinEntry2={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(gerundinEntry1);
        result.add(gerundinEntry2);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] passEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] passEntry2={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""};
        String[] whEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(passEntry);
        result.add(passEntry2);
        result.add(whEntry);
      }
 else       if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        String[] vEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(vEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String[] whEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        result.add(whEntry);
      }
 else       if (pos.equals(""String_Node_Str"") || pos.equals(""String_Node_Str"")) {
        String[] gerEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""+ ""String_Node_Str""};
        String[] wasGerEntry={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ symslot+ ""String_Node_Str""};
        result.add(gerEntry);
        result.add(wasGerEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String dateSlot=""String_Node_Str"" + token + ""String_Node_Str""+ token+ ""String_Node_Str""+ token+ ""String_Node_Str"";
        String tokenSlot=""String_Node_Str"" + token + ""String_Node_Str""+ token;
        String[] whenEntry1={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ dateSlot+ ""String_Node_Str""};
        String[] whenEntry2={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ ""String_Node_Str""+ tokenSlot+ ""String_Node_Str""};
        result.add(whenEntry1);
        result.add(whenEntry2);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String placeSlot=""String_Node_Str"" + token + ""String_Node_Str""+ token+ ""String_Node_Str""+ token+ ""String_Node_Str"";
        String tokenSlot=""String_Node_Str"" + token + ""String_Node_Str""+ token;
        String[] whereEntry1={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ placeSlot+ ""String_Node_Str""};
        String[] whereEntry2={token,""String_Node_Str"" + token + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ ""String_Node_Str""+ tokenSlot+ ""String_Node_Str""};
        result.add(whereEntry1);
        result.add(whereEntry2);
      }
    }
 else     if (equalsOneOf(pos,adjective)) {
      String slot=""String_Node_Str"" + token + ""String_Node_Str""+ token;
      if (pos.equals(""String_Node_Str"")) {
        String[] adjEntry={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(adjEntry);
      }
      if (pos.equals(""String_Node_Str"")) {
        String[] howEntry={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(howEntry);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String pol=polarity(token);
        String comp;
        if (pol.equals(""String_Node_Str"")) {
          comp=""String_Node_Str"";
        }
 else {
          comp=""String_Node_Str"";
        }
        String[] compEntry1={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ token+ ""String_Node_Str""+ comp+ ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(compEntry1);
        String[] compEntry2={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ token+ ""String_Node_Str""+ comp+ ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(compEntry2);
      }
 else       if (pos.equals(""String_Node_Str"")) {
        String pol=polarity(token);
        String comp;
        if (pol.equals(""String_Node_Str"")) {
          comp=""String_Node_Str"";
        }
 else {
          comp=""String_Node_Str"";
        }
        String[] superEntry1={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ comp+ ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(superEntry1);
        String[] superEntry2={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ comp+ ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(superEntry2);
        String[] superEntry3={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ comp+ ""String_Node_Str""+ slot+ ""String_Node_Str""};
        result.add(superEntry3);
      }
    }
 else     if (equalsOneOf(pos,preps)) {
      String slot=""String_Node_Str"" + token + ""String_Node_Str""+ token;
      String[] npAdjunct={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ slot+ ""String_Node_Str""+ ""String_Node_Str""};
      String[] vpAdjunct={token,""String_Node_Str"" + token.toLowerCase() + ""String_Node_Str"",""String_Node_Str"" + token + ""String_Node_Str""+ slot+ ""String_Node_Str""+ ""String_Node_Str""};
      result.add(npAdjunct);
      result.add(vpAdjunct);
    }
  }
  return result;
}"
9585,"public ArrayList<String> getPropertys(String element) throws IOException {
  sendServerPropertyRequest(element);
  return do_parsing(""String_Node_Str"");
}","public ArrayList<String> getPropertys(String element) throws IOException {
  try {
    sendServerPropertyRequest(element);
    return do_parsing(""String_Node_Str"");
  }
 catch (  Exception e) {
    return null;
  }
}"
9586,"private List<String> getCandidateURIsSortedBySimilarity(Slot slot){
  logger.info(""String_Node_Str"" + slot.getWords() + ""String_Node_Str"");
  mon.start();
  List<String> sortedURIs=new ArrayList<String>();
  SolrSearch index=getIndexBySlotType(slot);
  Map<String,SolrQueryResultSet> uriCache=getCacheBySlotType(slot);
  SortedSet<SolrQueryResultItem> tmp;
  SolrQueryResultSet rs;
  List<String> words;
  if (slot.getSlotType() == SlotType.RESOURCE) {
    words=slot.getWords();
  }
 else {
    words=pruneList(slot.getWords());
  }
  for (  String word : words) {
    tmp=new TreeSet<SolrQueryResultItem>(new SolrQueryResultStringSimilarityComparator(word));
    rs=uriCache.get(word);
    if (rs == null) {
      rs=index.getResourcesWithScores(word,50);
      uriCache.put(word,rs);
    }
    tmp.addAll(rs.getItems());
    int i=0;
    for (    SolrQueryResultItem item : tmp) {
      sortedURIs.add(item.getUri());
      if (i == MAX_URIS_PER_SLOT) {
        break;
      }
      i++;
    }
    tmp.clear();
  }
  slot2URI.put(slot,sortedURIs);
  mon.stop();
  logger.info(""String_Node_Str"" + mon.getLastValue() + ""String_Node_Str"");
  logger.info(""String_Node_Str"" + sortedURIs);
  return sortedURIs;
}","private List<String> getCandidateURIsSortedBySimilarity(Slot slot){
  logger.info(""String_Node_Str"" + slot.getWords() + ""String_Node_Str"");
  mon.start();
  List<String> sortedURIs=new ArrayList<String>();
  SolrSearch index=getIndexBySlotType(slot);
  Map<String,SolrQueryResultSet> uriCache=getCacheBySlotType(slot);
  SortedSet<SolrQueryResultItem> tmp;
  SolrQueryResultSet rs;
  List<String> words;
  if (slot.getSlotType() == SlotType.RESOURCE) {
    words=slot.getWords();
  }
 else {
    words=pruneList(slot.getWords());
  }
  for (  String word : words) {
    tmp=new TreeSet<SolrQueryResultItem>(new SolrQueryResultStringSimilarityComparator(word));
    rs=uriCache.get(word);
    if (rs == null) {
      rs=index.getResourcesWithScores(word,50);
      uriCache.put(word,rs);
    }
    tmp.addAll(rs.getItems());
    for (    SolrQueryResultItem item : tmp) {
      if (!sortedURIs.contains(item.getUri())) {
        sortedURIs.add(item.getUri());
      }
      if (sortedURIs.size() == MAX_URIS_PER_SLOT) {
        break;
      }
    }
    tmp.clear();
  }
  slot2URI.put(slot,sortedURIs);
  mon.stop();
  logger.info(""String_Node_Str"" + mon.getLastValue() + ""String_Node_Str"");
  logger.info(""String_Node_Str"" + sortedURIs);
  return sortedURIs;
}"
9587,"@Override public int compare(SolrQueryResultItem item1,SolrQueryResultItem item2){
  double sim1=Similarity.getSimilarity(s,item1.getLabel());
  double sim2=Similarity.getSimilarity(s,item2.getLabel());
  if (sim1 < sim2) {
    return 1;
  }
 else   if (sim1 > sim2) {
    return -1;
  }
 else {
    return item1.getLabel().compareTo(item2.getLabel());
  }
}","@Override public int compare(SolrQueryResultItem item1,SolrQueryResultItem item2){
  double sim1=0;
  if (cache.containsKey(item1.getLabel())) {
    sim1=cache.get(item1.getLabel());
  }
 else {
    sim1=Similarity.getSimilarity(s,item1.getLabel());
    cache.put(item1.getLabel(),sim1);
  }
  double sim2=0;
  if (cache.containsKey(item2.getLabel())) {
    sim2=cache.get(item2.getLabel());
  }
 else {
    sim2=Similarity.getSimilarity(s,item2.getLabel());
    cache.put(item2.getLabel(),sim2);
  }
  if (sim1 < sim2) {
    return 1;
  }
 else   if (sim1 > sim2) {
    return -1;
  }
 else {
    int val=item1.getLabel().compareTo(item2.getLabel());
    if (val == 0) {
      return item1.getUri().compareTo(item2.getUri());
    }
    return val;
  }
}"
9588,"public SolrQueryResultStringSimilarityComparator(String s){
  this.s=s;
}","public SolrQueryResultStringSimilarityComparator(String s){
  this.s=s;
  cache=new HashMap<String,Double>();
}"
9589,"@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  stringDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  Set<OWLImportsDeclaration> directImports=new HashSet<OWLImportsDeclaration>();
  for (  AbstractKnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      try {
        if (source instanceof OWLAPIOntology) {
          ontology=((OWLAPIOntology)source).getOWLOntolgy();
          manager=ontology.getOWLOntologyManager();
        }
 else         if (source instanceof SparqlKnowledgeSource) {
          ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
          manager=ontology.getOWLOntologyManager();
        }
 else {
          ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url.toURI()));
        }
        owlAPIOntologies.add(ontology);
        directImports.addAll(ontology.getImportsDeclarations());
        try {
          Set<OWLOntology> imports=manager.getImportsClosure(ontology);
          allImports.addAll(imports);
          for (          OWLOntology ont : imports) {
            classes.addAll(ont.getClassesInSignature());
            owlObjectProperties.addAll(ont.getObjectPropertiesInSignature());
            owlDatatypeProperties.addAll(ont.getDataPropertiesInSignature());
            owlIndividuals.addAll(ont.getIndividualsInSignature());
          }
        }
 catch (        UnknownOWLOntologyException uooe) {
          logger.error(""String_Node_Str"");
        }
        OWLOntologyFormat format=manager.getOntologyFormat(ontology);
        if (format instanceof PrefixOWLOntologyFormat) {
          prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
          baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
          prefixes.remove(""String_Node_Str"");
        }
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
catch (      URISyntaxException e) {
        e.printStackTrace();
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyURI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyURI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<OWLOntology>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<OWLOntologyChange>();
    for (    OWLImportsDeclaration i : directImports) {
      addImports.add(new AddImport(ontology,i));
    }
    manager.applyChanges(addImports);
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  ReasonerProgressMonitor progressMonitor=new NullReasonerProgressMonitor();
  FreshEntityPolicy freshEntityPolicy=FreshEntityPolicy.ALLOW;
  long timeOut=Integer.MAX_VALUE;
  IndividualNodeSetPolicy individualNodeSetPolicy=IndividualNodeSetPolicy.BY_NAME;
  OWLReasonerConfiguration conf=new SimpleConfiguration(progressMonitor,freshEntityPolicy,timeOut,individualNodeSetPolicy);
  if (getReasonerTypeString().equals(""String_Node_Str"")) {
    try {
      reasoner=new FaCTPlusPlusReasonerFactory().createNonBufferingReasoner(ontology,conf);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
  }
 else   if (getReasonerTypeString().equals(""String_Node_Str"")) {
    reasoner=new ReasonerFactory().createNonBufferingReasoner(ontology,conf);
  }
 else   if (getReasonerTypeString().equals(""String_Node_Str"")) {
    reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(owlAPIOntologies.iterator().next(),conf);
    Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
    pelletLogger.setLevel(Level.WARN);
  }
 else {
    try {
      OWLlinkHTTPXMLReasonerFactory factory=new OWLlinkHTTPXMLReasonerFactory();
      URL url=new URL(getOwlLinkURL());
      OWLlinkReasonerConfiguration config=new OWLlinkReasonerConfiguration(url);
      reasoner=factory.createNonBufferingReasoner(ontology,config);
      System.out.println(reasoner.getReasonerName());
    }
 catch (    Exception e) {
      throw new ComponentInitException(e);
    }
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS);
  }
 else {
    throw new ComponentInitException(""String_Node_Str"");
  }
  factory=manager.getOWLDataFactory();
  for (  OWLClass owlClass : classes)   atomicConcepts.add(new NamedClass(owlClass.toStringID()));
  for (  OWLObjectProperty owlProperty : owlObjectProperties)   atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
  for (  OWLDataProperty owlProperty : owlDatatypeProperties) {
    DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
    Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
    Iterator<OWLDataRange> it=ranges.iterator();
    if (it.hasNext()) {
      OWLDataRange range=it.next();
      if (range.isDatatype()) {
        URI uri=((OWLDatatype)range).getIRI().toURI();
        if (uri.equals(OWL2Datatype.BOOLEAN.getURI()))         booleanDatatypeProperties.add(dtp);
 else         if (uri.equals(OWL2Datatype.DOUBLE.getURI()))         doubleDatatypeProperties.add(dtp);
 else         if (uri.equals(OWL2Datatype.INT.getURI()))         intDatatypeProperties.add(dtp);
 else         if (uri.equals(OWL2Datatype.STRING.getURI()))         stringDatatypeProperties.add(dtp);
      }
    }
 else {
      stringDatatypeProperties.add(dtp);
    }
    datatypeProperties.add(dtp);
  }
  for (  OWLNamedIndividual owlIndividual : owlIndividuals) {
    individuals.add(new Individual(owlIndividual.toStringID()));
  }
}","@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  stringDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  Set<OWLImportsDeclaration> directImports=new HashSet<OWLImportsDeclaration>();
  for (  AbstractKnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      try {
        if (source instanceof OWLAPIOntology) {
          ontology=((OWLAPIOntology)source).getOWLOntolgy();
          manager=ontology.getOWLOntologyManager();
        }
 else         if (source instanceof SparqlKnowledgeSource) {
          ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
          manager=ontology.getOWLOntologyManager();
        }
 else {
          ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url.toURI()));
        }
        owlAPIOntologies.add(ontology);
        directImports.addAll(ontology.getImportsDeclarations());
        try {
          Set<OWLOntology> imports=manager.getImportsClosure(ontology);
          allImports.addAll(imports);
          for (          OWLOntology ont : imports) {
            classes.addAll(ont.getClassesInSignature());
            owlObjectProperties.addAll(ont.getObjectPropertiesInSignature());
            owlDatatypeProperties.addAll(ont.getDataPropertiesInSignature());
            owlIndividuals.addAll(ont.getIndividualsInSignature());
          }
        }
 catch (        UnknownOWLOntologyException uooe) {
          logger.error(""String_Node_Str"");
        }
        OWLOntologyFormat format=manager.getOntologyFormat(ontology);
        if (format instanceof PrefixOWLOntologyFormat) {
          prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
          baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
          prefixes.remove(""String_Node_Str"");
        }
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
catch (      URISyntaxException e) {
        e.printStackTrace();
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyURI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyURI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<OWLOntology>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<OWLOntologyChange>();
    for (    OWLImportsDeclaration i : directImports) {
      addImports.add(new AddImport(ontology,i));
    }
    manager.applyChanges(addImports);
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  ReasonerProgressMonitor progressMonitor=new NullReasonerProgressMonitor();
  FreshEntityPolicy freshEntityPolicy=FreshEntityPolicy.ALLOW;
  long timeOut=Integer.MAX_VALUE;
  IndividualNodeSetPolicy individualNodeSetPolicy=IndividualNodeSetPolicy.BY_NAME;
  OWLReasonerConfiguration conf=new SimpleConfiguration(progressMonitor,freshEntityPolicy,timeOut,individualNodeSetPolicy);
  if (getReasonerTypeString().equals(""String_Node_Str"")) {
    try {
      reasoner=new FaCTPlusPlusReasonerFactory().createNonBufferingReasoner(ontology,conf);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
  }
 else   if (getReasonerTypeString().equals(""String_Node_Str"")) {
    reasoner=new ReasonerFactory().createNonBufferingReasoner(ontology,conf);
  }
 else   if (getReasonerTypeString().equals(""String_Node_Str"")) {
    reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology,conf);
    Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
    pelletLogger.setLevel(Level.WARN);
  }
 else {
    try {
      OWLlinkHTTPXMLReasonerFactory factory=new OWLlinkHTTPXMLReasonerFactory();
      URL url=new URL(getOwlLinkURL());
      OWLlinkReasonerConfiguration config=new OWLlinkReasonerConfiguration(url);
      reasoner=factory.createNonBufferingReasoner(ontology,config);
      System.out.println(reasoner.getReasonerName());
    }
 catch (    Exception e) {
      throw new ComponentInitException(e);
    }
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS);
  }
 else {
    throw new ComponentInitException(""String_Node_Str"");
  }
  factory=manager.getOWLDataFactory();
  for (  OWLClass owlClass : classes)   atomicConcepts.add(new NamedClass(owlClass.toStringID()));
  for (  OWLObjectProperty owlProperty : owlObjectProperties)   atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
  for (  OWLDataProperty owlProperty : owlDatatypeProperties) {
    DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
    Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
    Iterator<OWLDataRange> it=ranges.iterator();
    if (it.hasNext()) {
      OWLDataRange range=it.next();
      if (range.isDatatype()) {
        URI uri=((OWLDatatype)range).getIRI().toURI();
        if (uri.equals(OWL2Datatype.BOOLEAN.getURI()))         booleanDatatypeProperties.add(dtp);
 else         if (uri.equals(OWL2Datatype.DOUBLE.getURI()))         doubleDatatypeProperties.add(dtp);
 else         if (uri.equals(OWL2Datatype.INT.getURI()))         intDatatypeProperties.add(dtp);
 else         if (uri.equals(OWL2Datatype.STRING.getURI()))         stringDatatypeProperties.add(dtp);
      }
    }
 else {
      stringDatatypeProperties.add(dtp);
    }
    datatypeProperties.add(dtp);
  }
  for (  OWLNamedIndividual owlIndividual : owlIndividuals) {
    individuals.add(new Individual(owlIndividual.toStringID()));
  }
}"
9590,"private Query convert(DRS drs,Query query,boolean negate){
  redundantEqualRenaming(drs);
  if (!restructureEmpty(drs)) {
    return null;
  }
  for (  DiscourseReferent referent : drs.getDRs()) {
    if (referent.isMarked()) {
      SPARQL_Term term=new SPARQL_Term(referent.toString().replace(""String_Node_Str"",""String_Node_Str""));
      term.setIsVariable(true);
      query.addSelTerm(term);
    }
    if (referent.isNonexistential()) {
      SPARQL_Term term=new SPARQL_Term(referent.getValue());
      term.setIsVariable(true);
      SPARQL_Filter f=new SPARQL_Filter();
      f.addNotBound(term);
      query.addFilter(f);
    }
    for (    Slot s : slots) {
      if (s.getAnchor().equals(referent.toString())) {
        template.addSlot(s);
        break;
      }
    }
  }
  Set<SPARQL_Triple> statements=new HashSet<SPARQL_Triple>();
  for (  DRS_Condition condition : drs.getConditions()) {
    Set<SPARQL_Triple> scondition=convertCondition(condition,query).getConditions();
    statements.addAll(scondition);
    if (negate) {
      for (int i=0; i < scondition.size(); ++i) {
        SPARQL_Term term=((SPARQL_Triple)scondition.toArray()[i]).getVariable();
        if (query.isSelTerm(term)) {
          SPARQL_Filter f=new SPARQL_Filter();
          f.addNotBound(term);
          query.addFilter(f);
        }
      }
    }
  }
  if (query.getSelTerms().size() == 0)   query.setQt(SPARQL_QueryType.ASK);
  query.setConditions(statements);
  return query;
}","private Query convert(DRS drs,Query query,boolean negate){
  redundantEqualRenaming(drs);
  if (!restructureEmpty(drs)) {
    return null;
  }
  for (  DiscourseReferent referent : drs.collectDRs()) {
    if (referent.isMarked()) {
      SPARQL_Term term=new SPARQL_Term(referent.toString().replace(""String_Node_Str"",""String_Node_Str""));
      term.setIsVariable(true);
      query.addSelTerm(term);
    }
    if (referent.isNonexistential()) {
      SPARQL_Term term=new SPARQL_Term(referent.getValue());
      term.setIsVariable(true);
      SPARQL_Filter f=new SPARQL_Filter();
      f.addNotBound(term);
      query.addFilter(f);
    }
    for (    Slot s : slots) {
      if (s.getAnchor().equals(referent.getValue()) || s.getAnchor().equals(referent.toString())) {
        template.addSlot(s);
        break;
      }
    }
  }
  Set<SPARQL_Triple> statements=new HashSet<SPARQL_Triple>();
  for (  DRS_Condition condition : drs.getConditions()) {
    Set<SPARQL_Triple> scondition=convertCondition(condition,query).getConditions();
    statements.addAll(scondition);
    if (negate) {
      for (int i=0; i < scondition.size(); ++i) {
        SPARQL_Term term=((SPARQL_Triple)scondition.toArray()[i]).getVariable();
        if (query.isSelTerm(term)) {
          SPARQL_Filter f=new SPARQL_Filter();
          f.addNotBound(term);
          query.addFilter(f);
        }
      }
    }
  }
  if (query.getSelTerms().size() == 0)   query.setQt(SPARQL_QueryType.ASK);
  query.setConditions(statements);
  return query;
}"
9591,"public Set<Template> buildTemplates(String s){
  boolean clearAgain=true;
  String tagged;
  if (UNTAGGED_INPUT) {
    s=pp.normalize(s);
    tagged=tagger.tag(s);
    logger.trace(""String_Node_Str"" + tagged);
  }
 else {
    tagged=s;
    s=extractSentence(tagged);
  }
  String newtagged;
  if (USE_NER) {
    newtagged=pp.condenseNominals(pp.findNEs(tagged,s));
  }
 else   newtagged=pp.condenseNominals(tagged);
  newtagged=pp.condense(newtagged);
  logger.trace(""String_Node_Str"" + newtagged);
  p.parse(newtagged,g);
  if (p.getDerivationTrees().isEmpty()) {
    p.clear(g,p.getTemps());
    clearAgain=false;
    logger.error(""String_Node_Str"" + s + ""String_Node_Str"");
  }
 else {
    try {
      p.buildDerivedTrees(g);
    }
 catch (    ParseException e) {
      logger.error(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"",e);
    }
  }
  Hashtable<String,String> postable=new Hashtable<String,String>();
  for (  String st : newtagged.split(""String_Node_Str"")) {
    postable.put(st.substring(0,st.indexOf(""String_Node_Str"")).toLowerCase(),st.substring(st.indexOf(""String_Node_Str"") + 1));
    ;
  }
  Set<DRS> drses=new HashSet<DRS>();
  Set<Template> templates=new HashSet<Template>();
  for (  Dude dude : p.getDudes()) {
    UDRS udrs=d2u.convert(dude);
    if (udrs != null) {
      for (      DRS drs : udrs.initResolve()) {
        List<Slot> slots=new ArrayList<Slot>();
        slots.addAll(dude.getSlots());
        d2s.setSlots(slots);
        d2s.redundantEqualRenaming(drs);
        if (!containsModuloRenaming(drses,drs)) {
          drses.add(drs);
          try {
            Template temp=d2s.convert(drs,slots);
            if (temp == null) {
              continue;
            }
            List<String> newwords;
            String word;
            String pos;
            for (            Slot slot : temp.getSlots()) {
              if (!slot.getWords().isEmpty()) {
                word=slot.getWords().get(0);
                pos=postable.get(word.toLowerCase().replace(""String_Node_Str"",""String_Node_Str""));
                POS wordnetpos=null;
                if (pos != null) {
                  if (equalsOneOf(pos,noun)) {
                    wordnetpos=POS.NOUN;
                  }
 else                   if (equalsOneOf(pos,adjective)) {
                    wordnetpos=POS.ADJECTIVE;
                  }
 else                   if (equalsOneOf(pos,verb)) {
                    wordnetpos=POS.VERB;
                  }
                }
                List<String> strings=new ArrayList<String>();
                if (wordnetpos != null && wordnetpos.equals(POS.ADJECTIVE)) {
                  strings=wordnet.getAttributes(word);
                }
                newwords=new ArrayList<String>();
                newwords.add(word);
                newwords.addAll(strings);
                if (wordnetpos != null && !slot.getSlotType().equals(SlotType.RESOURCE)) {
                  newwords.addAll(wordnet.getBestSynonyms(wordnetpos,getLemmatizedWord(word)));
                  for (                  String att : getLemmatizedWords(strings)) {
                    newwords.addAll(wordnet.getBestSynonyms(wordnetpos,att));
                  }
                }
                if (newwords.isEmpty()) {
                }
                if (newwords.isEmpty()) {
                  newwords.add(slot.getWords().get(0));
                }
                List<String> newwordslist=new ArrayList<String>();
                newwordslist.addAll(newwords);
                slot.setWords(newwordslist);
              }
            }
            templates.add(temp);
          }
 catch (          java.lang.ClassCastException e) {
            continue;
          }
          if (ONE_SCOPE_ONLY) {
            break;
          }
        }
      }
    }
  }
  if (clearAgain) {
    p.clear(g,p.getTemps());
  }
  System.gc();
  return templates;
}","public Set<Template> buildTemplates(String s){
  boolean clearAgain=true;
  String tagged;
  if (UNTAGGED_INPUT) {
    s=pp.normalize(s);
    tagged=tagger.tag(s);
    logger.trace(""String_Node_Str"" + tagged);
  }
 else {
    tagged=s;
    s=extractSentence(tagged);
  }
  String newtagged;
  if (USE_NER) {
    newtagged=pp.condenseNominals(pp.findNEs(tagged,s));
  }
 else   newtagged=pp.condenseNominals(tagged);
  newtagged=pp.condense(newtagged);
  logger.trace(""String_Node_Str"" + newtagged);
  p.parse(newtagged,g);
  if (p.getDerivationTrees().isEmpty()) {
    p.clear(g,p.getTemps());
    clearAgain=false;
    logger.error(""String_Node_Str"" + s + ""String_Node_Str"");
  }
 else {
    try {
      p.buildDerivedTrees(g);
    }
 catch (    ParseException e) {
      logger.error(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"",e);
    }
  }
  Hashtable<String,String> postable=new Hashtable<String,String>();
  for (  String st : newtagged.split(""String_Node_Str"")) {
    postable.put(st.substring(0,st.indexOf(""String_Node_Str"")).toLowerCase(),st.substring(st.indexOf(""String_Node_Str"") + 1));
    ;
  }
  Set<DRS> drses=new HashSet<DRS>();
  Set<Template> templates=new HashSet<Template>();
  for (  Dude dude : p.getDudes()) {
    UDRS udrs=d2u.convert(dude);
    if (udrs != null) {
      for (      DRS drs : udrs.initResolve()) {
        List<Slot> slots=new ArrayList<Slot>();
        slots.addAll(dude.getSlots());
        d2s.setSlots(slots);
        d2s.redundantEqualRenaming(drs);
        if (!containsModuloRenaming(drses,drs)) {
          System.out.println(dude);
          System.out.println(drs);
          for (          Slot sl : slots) {
            System.out.println(sl.toString());
          }
          drses.add(drs);
          try {
            Template temp=d2s.convert(drs,slots);
            if (temp == null) {
              continue;
            }
            List<String> newwords;
            String word;
            String pos;
            for (            Slot slot : temp.getSlots()) {
              if (!slot.getWords().isEmpty()) {
                word=slot.getWords().get(0);
                pos=postable.get(word.toLowerCase().replace(""String_Node_Str"",""String_Node_Str""));
                POS wordnetpos=null;
                if (pos != null) {
                  if (equalsOneOf(pos,noun)) {
                    wordnetpos=POS.NOUN;
                  }
 else                   if (equalsOneOf(pos,adjective)) {
                    wordnetpos=POS.ADJECTIVE;
                  }
 else                   if (equalsOneOf(pos,verb)) {
                    wordnetpos=POS.VERB;
                  }
                }
                List<String> strings=new ArrayList<String>();
                if (wordnetpos != null && wordnetpos.equals(POS.ADJECTIVE)) {
                  strings=wordnet.getAttributes(word);
                }
                newwords=new ArrayList<String>();
                newwords.addAll(slot.getWords());
                newwords.addAll(strings);
                if (wordnetpos != null && !slot.getSlotType().equals(SlotType.RESOURCE)) {
                  newwords.addAll(wordnet.getBestSynonyms(wordnetpos,getLemmatizedWord(word)));
                  for (                  String att : getLemmatizedWords(strings)) {
                    newwords.addAll(wordnet.getBestSynonyms(wordnetpos,att));
                  }
                }
                if (newwords.isEmpty()) {
                }
                if (newwords.isEmpty()) {
                  newwords.add(slot.getWords().get(0));
                }
                List<String> newwordslist=new ArrayList<String>();
                newwordslist.addAll(newwords);
                slot.setWords(newwordslist);
              }
            }
            templates.add(temp);
          }
 catch (          java.lang.ClassCastException e) {
            continue;
          }
          if (ONE_SCOPE_ONLY) {
            break;
          }
        }
      }
    }
  }
  if (clearAgain) {
    p.clear(g,p.getTemps());
  }
  System.gc();
  return templates;
}"
9592,"/** 
 * @param args
 * @throws NoTemplateFoundException 
 * @throws IOException 
 * @throws FileNotFoundException 
 * @throws InvalidFileFormatException 
 */
public static void main(String[] args) throws NoTemplateFoundException, InvalidFileFormatException, FileNotFoundException, IOException {
  String question=""String_Node_Str"";
  SPARQLTemplateBasedLearner learner=new SPARQLTemplateBasedLearner();
  SparqlEndpoint endpoint=new SparqlEndpoint(new URL(""String_Node_Str""),Collections.<String>singletonList(""String_Node_Str""),Collections.<String>emptyList());
  learner.setEndpoint(endpoint);
  learner.setQuestion(question);
  learner.learnSPARQLQueries();
  System.out.println(""String_Node_Str"" + learner.getBestSPARQLQuery());
  System.out.println(""String_Node_Str"" + learner.getTemplates().iterator().next().getLexicalAnswerType());
}","/** 
 * @param args
 * @throws NoTemplateFoundException 
 * @throws IOException 
 * @throws FileNotFoundException 
 * @throws InvalidFileFormatException 
 */
public static void main(String[] args) throws NoTemplateFoundException, InvalidFileFormatException, FileNotFoundException, IOException {
  String question=""String_Node_Str"";
  SPARQLTemplateBasedLearner learner=new SPARQLTemplateBasedLearner();
  learner.setUseIdealTagger(true);
  SparqlEndpoint endpoint=new SparqlEndpoint(new URL(""String_Node_Str""),Collections.<String>singletonList(""String_Node_Str""),Collections.<String>emptyList());
  learner.setEndpoint(endpoint);
  learner.setQuestion(question);
  learner.learnSPARQLQueries();
  System.out.println(""String_Node_Str"" + learner.getBestSPARQLQuery());
  System.out.println(""String_Node_Str"" + learner.getTemplates().iterator().next().getLexicalAnswerType());
}"
9593,"public void learnSPARQLQueries() throws NoTemplateFoundException {
  reset();
  logger.info(""String_Node_Str"");
  mon.start();
  templates=templateGenerator.buildTemplates(question);
  mon.stop();
  logger.info(""String_Node_Str"" + mon.getLastValue() + ""String_Node_Str"");
  if (templates.isEmpty()) {
    throw new NoTemplateFoundException();
  }
  logger.info(""String_Node_Str"");
  for (  Template t : templates) {
    logger.info(t);
  }
  Set<WeightedQuery> weightedQueries=getWeightedSPARQLQueries(templates);
  sparqlQueryCandidates=new ArrayList<Query>();
  int i=0;
  for (  WeightedQuery wQ : weightedQueries) {
    sparqlQueryCandidates.add(wQ.getQuery());
    if (i == maxTestedQueries) {
      break;
    }
  }
  if (useRemoteEndpointValidation) {
    validateAgainstRemoteEndpoint(sparqlQueryCandidates);
  }
 else {
    validateAgainstLocalModel(sparqlQueryCandidates);
  }
}","public void learnSPARQLQueries() throws NoTemplateFoundException {
  reset();
  logger.info(""String_Node_Str"");
  mon.start();
  templates=templateGenerator.buildTemplates(question);
  mon.stop();
  logger.info(""String_Node_Str"" + mon.getLastValue() + ""String_Node_Str"");
  if (templates.isEmpty()) {
    throw new NoTemplateFoundException();
  }
  logger.info(""String_Node_Str"");
  for (  Template t : templates) {
    logger.info(t);
  }
  Set<WeightedQuery> weightedQueries=getWeightedSPARQLQueries(templates);
  sparqlQueryCandidates=new ArrayList<Query>();
  int i=0;
  for (  WeightedQuery wQ : weightedQueries) {
    sparqlQueryCandidates.add(wQ.getQuery());
    if (i == maxTestedQueries) {
      break;
    }
    i++;
  }
  if (useRemoteEndpointValidation) {
    validateAgainstRemoteEndpoint(sparqlQueryCandidates);
  }
 else {
    validateAgainstLocalModel(sparqlQueryCandidates);
  }
}"
9594,"private Set<WeightedQuery> getWeightedSPARQLQueries(Set<Template> templates){
  double alpha=0.7;
  double beta=1 - alpha;
  Map<Slot,Set<Allocation>> slot2Allocations=new HashMap<Slot,Set<Allocation>>();
  Set<WeightedQuery> allQueries=new TreeSet<WeightedQuery>();
  Set<Allocation> allAllocations;
  for (  Template t : templates) {
    allAllocations=new HashSet<Allocation>();
    for (    Slot slot : t.getSlots()) {
      Set<Allocation> allocations=computeAllocation(slot);
      allAllocations.addAll(allocations);
      slot2Allocations.put(slot,allocations);
    }
    int min=Integer.MAX_VALUE;
    int max=Integer.MIN_VALUE;
    for (    Allocation a : allAllocations) {
      if (a.getInDegree() < min) {
        min=a.getInDegree();
      }
      if (a.getInDegree() > max) {
        max=a.getInDegree();
      }
    }
    for (    Allocation a : allAllocations) {
      double prominence=a.getInDegree() / (max - min);
      a.setProminence(prominence);
      double score=alpha * a.getSimilarity() + beta * a.getProminence();
      a.setScore(score);
    }
    Set<WeightedQuery> queries=new HashSet<WeightedQuery>();
    Query cleanQuery=t.getQuery();
    queries.add(new WeightedQuery(cleanQuery));
    Set<WeightedQuery> tmp=new HashSet<WeightedQuery>();
    for (    Slot slot : t.getSlots()) {
      for (      Allocation a : slot2Allocations.get(slot)) {
        for (        WeightedQuery query : queries) {
          if (slot.getSlotType() == SlotType.SYMPROPERTY) {
            Query reversedQuery=new Query(query.getQuery());
            reversedQuery.getTriplesWithVar(slot.getAnchor()).iterator().next().reverse();
            reversedQuery.replaceVarWithURI(slot.getAnchor(),a.getUri());
            WeightedQuery w=new WeightedQuery(reversedQuery);
            double newScore=query.getScore() + a.getScore();
            w.setScore(newScore);
            tmp.add(w);
          }
          Query q=new Query(query.getQuery());
          q.replaceVarWithURI(slot.getAnchor(),a.getUri());
          WeightedQuery w=new WeightedQuery(q);
          double newScore=query.getScore() + a.getScore();
          w.setScore(newScore);
          tmp.add(w);
        }
      }
      queries.clear();
      queries.addAll(tmp);
      tmp.clear();
    }
    for (    WeightedQuery q : queries) {
      q.setScore(q.getScore() / t.getSlots().size());
    }
    allQueries.addAll(queries);
    List<Query> qList=new ArrayList<Query>();
    for (    WeightedQuery wQ : queries) {
      qList.add(wQ.getQuery());
    }
    template2Queries.put(t,qList);
  }
  return allQueries;
}","private Set<WeightedQuery> getWeightedSPARQLQueries(Set<Template> templates){
  double alpha=0.7;
  double beta=1 - alpha;
  Map<Slot,Set<Allocation>> slot2Allocations=new HashMap<Slot,Set<Allocation>>();
  Set<WeightedQuery> allQueries=new TreeSet<WeightedQuery>();
  Set<Allocation> allAllocations;
  for (  Template t : templates) {
    allAllocations=new HashSet<Allocation>();
    for (    Slot slot : t.getSlots()) {
      Set<Allocation> allocations=computeAllocation(slot);
      allAllocations.addAll(allocations);
      slot2Allocations.put(slot,allocations);
    }
    int min=Integer.MAX_VALUE;
    int max=Integer.MIN_VALUE;
    for (    Allocation a : allAllocations) {
      if (a.getInDegree() < min) {
        min=a.getInDegree();
      }
      if (a.getInDegree() > max) {
        max=a.getInDegree();
      }
    }
    for (    Allocation a : allAllocations) {
      double prominence=a.getInDegree() / (max - min);
      a.setProminence(prominence);
      double score=alpha * a.getSimilarity() + beta * a.getProminence();
      a.setScore(score);
    }
    Set<WeightedQuery> queries=new HashSet<WeightedQuery>();
    Query cleanQuery=t.getQuery();
    queries.add(new WeightedQuery(cleanQuery));
    Set<WeightedQuery> tmp=new HashSet<WeightedQuery>();
    for (    Slot slot : t.getSlots()) {
      if (!slot2Allocations.get(slot).isEmpty()) {
        for (        Allocation a : slot2Allocations.get(slot)) {
          for (          WeightedQuery query : queries) {
            if (slot.getSlotType() == SlotType.SYMPROPERTY) {
              Query reversedQuery=new Query(query.getQuery());
              reversedQuery.getTriplesWithVar(slot.getAnchor()).iterator().next().reverse();
              reversedQuery.replaceVarWithURI(slot.getAnchor(),a.getUri());
              WeightedQuery w=new WeightedQuery(reversedQuery);
              double newScore=query.getScore() + a.getScore();
              w.setScore(newScore);
              tmp.add(w);
            }
            Query q=new Query(query.getQuery());
            q.replaceVarWithURI(slot.getAnchor(),a.getUri());
            WeightedQuery w=new WeightedQuery(q);
            double newScore=query.getScore() + a.getScore();
            w.setScore(newScore);
            tmp.add(w);
          }
        }
        queries.clear();
        queries.addAll(tmp);
        tmp.clear();
      }
    }
    for (    WeightedQuery q : queries) {
      q.setScore(q.getScore() / t.getSlots().size());
    }
    allQueries.addAll(queries);
    List<Query> qList=new ArrayList<Query>();
    for (    WeightedQuery wQ : queries) {
      qList.add(wQ.getQuery());
    }
    template2Queries.put(t,qList);
  }
  return allQueries;
}"
9595,"private Set<WeightedQuery> getWeightedSPARQLQueries(Set<Template> templates){
  double alpha=0.7;
  double beta=1 - alpha;
  Map<Slot,Set<Allocation>> slot2Allocations=new HashMap<Slot,Set<Allocation>>();
  Set<WeightedQuery> allQueries=new TreeSet<WeightedQuery>();
  Set<Allocation> allAllocations;
  for (  Template t : templates) {
    allAllocations=new HashSet<Allocation>();
    for (    Slot slot : t.getSlots()) {
      Set<Allocation> allocations=computeAllocation(slot);
      allAllocations.addAll(allocations);
      slot2Allocations.put(slot,allocations);
    }
    int min=Integer.MAX_VALUE;
    int max=Integer.MIN_VALUE;
    for (    Allocation a : allAllocations) {
      if (a.getInDegree() < min) {
        min=a.getInDegree();
      }
      if (a.getInDegree() > max) {
        max=a.getInDegree();
      }
    }
    for (    Allocation a : allAllocations) {
      double prominence=a.getInDegree() / (max - min);
      a.setProminence(prominence);
      double score=alpha * a.getSimilarity() + beta * a.getProminence();
      a.setScore(score);
    }
    Set<WeightedQuery> queries=new HashSet<WeightedQuery>();
    Query cleanQuery=t.getQuery();
    queries.add(new WeightedQuery(cleanQuery));
    Set<WeightedQuery> tmp=new HashSet<WeightedQuery>();
    for (    Slot slot : t.getSlots()) {
      for (      Allocation a : slot2Allocations.get(slot)) {
        for (        WeightedQuery query : queries) {
          if (slot.getSlotType() == SlotType.SYMPROPERTY) {
            Query reversedQuery=new Query(query.getQuery());
            reversedQuery.getTriplesWithVar(slot.getAnchor()).iterator().next().reverse();
            reversedQuery.replaceVarWithURI(slot.getAnchor(),a.getUri());
            WeightedQuery w=new WeightedQuery(reversedQuery);
            double newScore=query.getScore() + a.getScore();
            w.setScore(newScore);
            tmp.add(w);
          }
          Query q=new Query(query.getQuery());
          q.replaceVarWithURI(slot.getAnchor(),a.getUri());
          WeightedQuery w=new WeightedQuery(q);
          double newScore=query.getScore() + a.getScore();
          w.setScore(newScore);
          tmp.add(w);
        }
      }
      queries.clear();
      queries.addAll(tmp);
      tmp.clear();
    }
    for (    WeightedQuery q : queries) {
      q.setScore(q.getScore() / t.getSlots().size());
    }
    allQueries.addAll(queries);
  }
  return allQueries;
}","private Set<WeightedQuery> getWeightedSPARQLQueries(Set<Template> templates){
  double alpha=0.7;
  double beta=1 - alpha;
  Map<Slot,Set<Allocation>> slot2Allocations=new HashMap<Slot,Set<Allocation>>();
  Set<WeightedQuery> allQueries=new TreeSet<WeightedQuery>();
  Set<Allocation> allAllocations;
  for (  Template t : templates) {
    allAllocations=new HashSet<Allocation>();
    for (    Slot slot : t.getSlots()) {
      Set<Allocation> allocations=computeAllocation(slot);
      allAllocations.addAll(allocations);
      slot2Allocations.put(slot,allocations);
    }
    int min=Integer.MAX_VALUE;
    int max=Integer.MIN_VALUE;
    for (    Allocation a : allAllocations) {
      if (a.getInDegree() < min) {
        min=a.getInDegree();
      }
      if (a.getInDegree() > max) {
        max=a.getInDegree();
      }
    }
    for (    Allocation a : allAllocations) {
      double prominence=a.getInDegree() / (max - min);
      a.setProminence(prominence);
      double score=alpha * a.getSimilarity() + beta * a.getProminence();
      a.setScore(score);
    }
    Set<WeightedQuery> queries=new HashSet<WeightedQuery>();
    Query cleanQuery=t.getQuery();
    queries.add(new WeightedQuery(cleanQuery));
    Set<WeightedQuery> tmp=new HashSet<WeightedQuery>();
    for (    Slot slot : t.getSlots()) {
      for (      Allocation a : slot2Allocations.get(slot)) {
        for (        WeightedQuery query : queries) {
          if (slot.getSlotType() == SlotType.SYMPROPERTY) {
            Query reversedQuery=new Query(query.getQuery());
            reversedQuery.getTriplesWithVar(slot.getAnchor()).iterator().next().reverse();
            reversedQuery.replaceVarWithURI(slot.getAnchor(),a.getUri());
            WeightedQuery w=new WeightedQuery(reversedQuery);
            double newScore=query.getScore() + a.getScore();
            w.setScore(newScore);
            tmp.add(w);
          }
          Query q=new Query(query.getQuery());
          q.replaceVarWithURI(slot.getAnchor(),a.getUri());
          WeightedQuery w=new WeightedQuery(q);
          double newScore=query.getScore() + a.getScore();
          w.setScore(newScore);
          tmp.add(w);
        }
      }
      queries.clear();
      queries.addAll(tmp);
      tmp.clear();
    }
    for (    WeightedQuery q : queries) {
      q.setScore(q.getScore() / t.getSlots().size());
    }
    allQueries.addAll(queries);
    List<Query> qList=new ArrayList<Query>();
    for (    WeightedQuery wQ : queries) {
      qList.add(wQ.getQuery());
    }
    template2Queries.put(t,qList);
  }
  return allQueries;
}"
9596,"@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  stringDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  AbstractKnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      try {
        if (source instanceof OWLAPIOntology) {
          ontology=((OWLAPIOntology)source).getOWLOntolgy();
          manager=ontology.getOWLOntologyManager();
        }
 else         if (source instanceof SparqlKnowledgeSource) {
          ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
          manager=ontology.getOWLOntologyManager();
        }
 else {
          ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url.toURI()));
        }
        owlAPIOntologies.add(ontology);
        try {
          Set<OWLOntology> imports=manager.getImportsClosure(ontology);
          allImports.addAll(imports);
          for (          OWLOntology ont : imports) {
            classes.addAll(ont.getClassesInSignature());
            owlObjectProperties.addAll(ont.getObjectPropertiesInSignature());
            owlDatatypeProperties.addAll(ont.getDataPropertiesInSignature());
            owlIndividuals.addAll(ont.getIndividualsInSignature());
          }
        }
 catch (        UnknownOWLOntologyException uooe) {
          logger.error(""String_Node_Str"");
        }
        OWLOntologyFormat format=manager.getOntologyFormat(ontology);
        if (format instanceof PrefixOWLOntologyFormat) {
          prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
          baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
          prefixes.remove(""String_Node_Str"");
        }
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
catch (      URISyntaxException e) {
        e.printStackTrace();
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyURI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyURI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<OWLOntology>(owlAPIOntologies));
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  ReasonerProgressMonitor progressMonitor=new NullReasonerProgressMonitor();
  FreshEntityPolicy freshEntityPolicy=FreshEntityPolicy.ALLOW;
  long timeOut=Integer.MAX_VALUE;
  IndividualNodeSetPolicy individualNodeSetPolicy=IndividualNodeSetPolicy.BY_NAME;
  OWLReasonerConfiguration conf=new SimpleConfiguration(progressMonitor,freshEntityPolicy,timeOut,individualNodeSetPolicy);
  if (getReasonerTypeString().equals(""String_Node_Str"")) {
    try {
      reasoner=new FaCTPlusPlusReasonerFactory().createNonBufferingReasoner(ontology,conf);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
  }
 else   if (getReasonerTypeString().equals(""String_Node_Str"")) {
    reasoner=new ReasonerFactory().createNonBufferingReasoner(ontology,conf);
  }
 else   if (getReasonerTypeString().equals(""String_Node_Str"")) {
    reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology,conf);
    Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
    pelletLogger.setLevel(Level.WARN);
  }
 else {
    try {
      OWLlinkHTTPXMLReasonerFactory factory=new OWLlinkHTTPXMLReasonerFactory();
      URL url=new URL(getOwlLinkURL());
      OWLlinkReasonerConfiguration config=new OWLlinkReasonerConfiguration(url);
      reasoner=factory.createNonBufferingReasoner(ontology,config);
      System.out.println(reasoner.getReasonerName());
    }
 catch (    Exception e) {
      throw new ComponentInitException(e);
    }
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS);
  }
 else {
    throw new ComponentInitException(""String_Node_Str"");
  }
  factory=manager.getOWLDataFactory();
  for (  OWLClass owlClass : classes)   atomicConcepts.add(new NamedClass(owlClass.toStringID()));
  for (  OWLObjectProperty owlProperty : owlObjectProperties)   atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
  for (  OWLDataProperty owlProperty : owlDatatypeProperties) {
    DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
    Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
    Iterator<OWLDataRange> it=ranges.iterator();
    if (it.hasNext()) {
      OWLDataRange range=it.next();
      if (range.isDatatype()) {
        URI uri=((OWLDatatype)range).getIRI().toURI();
        if (uri.equals(OWL2Datatype.BOOLEAN.getURI()))         booleanDatatypeProperties.add(dtp);
 else         if (uri.equals(OWL2Datatype.DOUBLE.getURI()))         doubleDatatypeProperties.add(dtp);
 else         if (uri.equals(OWL2Datatype.INT.getURI()))         intDatatypeProperties.add(dtp);
 else         if (uri.equals(OWL2Datatype.STRING.getURI()))         stringDatatypeProperties.add(dtp);
      }
    }
 else {
      stringDatatypeProperties.add(dtp);
    }
    datatypeProperties.add(dtp);
  }
  for (  OWLNamedIndividual owlIndividual : owlIndividuals) {
    individuals.add(new Individual(owlIndividual.toStringID()));
  }
}","@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  stringDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  Set<OWLImportsDeclaration> directImports=new HashSet<OWLImportsDeclaration>();
  for (  AbstractKnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      try {
        if (source instanceof OWLAPIOntology) {
          ontology=((OWLAPIOntology)source).getOWLOntolgy();
          manager=ontology.getOWLOntologyManager();
        }
 else         if (source instanceof SparqlKnowledgeSource) {
          ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
          manager=ontology.getOWLOntologyManager();
        }
 else {
          ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url.toURI()));
        }
        owlAPIOntologies.add(ontology);
        directImports.addAll(ontology.getImportsDeclarations());
        try {
          Set<OWLOntology> imports=manager.getImportsClosure(ontology);
          allImports.addAll(imports);
          for (          OWLOntology ont : imports) {
            classes.addAll(ont.getClassesInSignature());
            owlObjectProperties.addAll(ont.getObjectPropertiesInSignature());
            owlDatatypeProperties.addAll(ont.getDataPropertiesInSignature());
            owlIndividuals.addAll(ont.getIndividualsInSignature());
          }
        }
 catch (        UnknownOWLOntologyException uooe) {
          logger.error(""String_Node_Str"");
        }
        OWLOntologyFormat format=manager.getOntologyFormat(ontology);
        if (format instanceof PrefixOWLOntologyFormat) {
          prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
          baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
          prefixes.remove(""String_Node_Str"");
        }
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
catch (      URISyntaxException e) {
        e.printStackTrace();
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyURI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyURI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<OWLOntology>(owlAPIOntologies));
    List<OWLOntologyChange> addImports=new ArrayList<OWLOntologyChange>();
    for (    OWLImportsDeclaration i : directImports) {
      addImports.add(new AddImport(ontology,i));
    }
    manager.applyChanges(addImports);
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  ReasonerProgressMonitor progressMonitor=new NullReasonerProgressMonitor();
  FreshEntityPolicy freshEntityPolicy=FreshEntityPolicy.ALLOW;
  long timeOut=Integer.MAX_VALUE;
  IndividualNodeSetPolicy individualNodeSetPolicy=IndividualNodeSetPolicy.BY_NAME;
  OWLReasonerConfiguration conf=new SimpleConfiguration(progressMonitor,freshEntityPolicy,timeOut,individualNodeSetPolicy);
  if (getReasonerTypeString().equals(""String_Node_Str"")) {
    try {
      reasoner=new FaCTPlusPlusReasonerFactory().createNonBufferingReasoner(ontology,conf);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
  }
 else   if (getReasonerTypeString().equals(""String_Node_Str"")) {
    reasoner=new ReasonerFactory().createNonBufferingReasoner(ontology,conf);
  }
 else   if (getReasonerTypeString().equals(""String_Node_Str"")) {
    reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(owlAPIOntologies.iterator().next(),conf);
    Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
    pelletLogger.setLevel(Level.WARN);
  }
 else {
    try {
      OWLlinkHTTPXMLReasonerFactory factory=new OWLlinkHTTPXMLReasonerFactory();
      URL url=new URL(getOwlLinkURL());
      OWLlinkReasonerConfiguration config=new OWLlinkReasonerConfiguration(url);
      reasoner=factory.createNonBufferingReasoner(ontology,config);
      System.out.println(reasoner.getReasonerName());
    }
 catch (    Exception e) {
      throw new ComponentInitException(e);
    }
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS);
  }
 else {
    throw new ComponentInitException(""String_Node_Str"");
  }
  factory=manager.getOWLDataFactory();
  for (  OWLClass owlClass : classes)   atomicConcepts.add(new NamedClass(owlClass.toStringID()));
  for (  OWLObjectProperty owlProperty : owlObjectProperties)   atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
  for (  OWLDataProperty owlProperty : owlDatatypeProperties) {
    DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
    Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
    Iterator<OWLDataRange> it=ranges.iterator();
    if (it.hasNext()) {
      OWLDataRange range=it.next();
      if (range.isDatatype()) {
        URI uri=((OWLDatatype)range).getIRI().toURI();
        if (uri.equals(OWL2Datatype.BOOLEAN.getURI()))         booleanDatatypeProperties.add(dtp);
 else         if (uri.equals(OWL2Datatype.DOUBLE.getURI()))         doubleDatatypeProperties.add(dtp);
 else         if (uri.equals(OWL2Datatype.INT.getURI()))         intDatatypeProperties.add(dtp);
 else         if (uri.equals(OWL2Datatype.STRING.getURI()))         stringDatatypeProperties.add(dtp);
      }
    }
 else {
      stringDatatypeProperties.add(dtp);
    }
    datatypeProperties.add(dtp);
  }
  for (  OWLNamedIndividual owlIndividual : owlIndividuals) {
    individuals.add(new Individual(owlIndividual.toStringID()));
  }
}"
9597,"@Override public void init() throws ComponentInitException {
  Set<NamedClass> usedConcepts;
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  classHierarchy.thinOutSubsumptionHierarchy();
  if (heuristic == null) {
    heuristic=new OEHeuristicRuntime();
  }
  minimizer=new DescriptionMinimizer(reasoner);
  startClass=Thing.instance;
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setStartClass(startClass);
    ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
    ((RhoDRDown)operator).setReasoner(reasoner);
    ((RhoDRDown)operator).init();
  }
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  if (writeSearchTree) {
    File f=new File(searchTreeFile);
    Files.clearFile(f);
  }
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(maxNrOfResults);
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=noisePercentage / 100d;
  filterFollowsFromKB=filterDescriptionsFollowingFromKB && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (reuseExistingDescription && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}","@Override public void init() throws ComponentInitException {
  Set<NamedClass> usedConcepts;
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  classHierarchy.thinOutSubsumptionHierarchy();
  if (heuristic == null) {
    heuristic=new OEHeuristicRuntime();
  }
  minimizer=new DescriptionMinimizer(reasoner);
  startClass=Thing.instance;
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setStartClass(startClass);
    ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
    ((RhoDRDown)operator).setReasoner(reasoner);
    ((RhoDRDown)operator).init();
  }
 else {
    ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
  }
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  if (writeSearchTree) {
    File f=new File(searchTreeFile);
    Files.clearFile(f);
  }
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(maxNrOfResults);
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=noisePercentage / 100d;
  filterFollowsFromKB=filterDescriptionsFollowingFromKB && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (reuseExistingDescription && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}"
9598,"private Query convertCondition(DRS_Condition condition,Query query){
  if (condition.isComplexCondition()) {
    if (!isSilent()) {
      System.out.print(""String_Node_Str"" + condition.toString());
    }
    Complex_DRS_Condition complex=(Complex_DRS_Condition)condition;
    DRS restrictor=complex.getRestrictor();
    DRS_Quantifier quant=complex.getQuantifier();
    DRS scope=complex.getScope();
    for (    DRS_Condition cond : restrictor.getConditions()) {
      query=convertCondition(cond,query);
    }
    for (    DRS_Condition cond : scope.getConditions()) {
      query=convertCondition(cond,query);
    }
    DiscourseReferent ref=complex.getReferent();
    String sref=ref.getValue();
    String fresh;
    if (!isSilent()) {
      System.out.print(""String_Node_Str"" + quant);
    }
switch (quant) {
case HOWMANY:
      query.addSelTerm(new SPARQL_Term(sref,SPARQL_Aggregate.COUNT));
    break;
case EVERY:
  break;
case NO:
SPARQL_Filter f=new SPARQL_Filter();
f.addNotBound(new SPARQL_Term(sref));
query.addFilter(f);
break;
case FEW:
break;
case MANY:
break;
case MOST:
break;
case SOME:
break;
case THELEAST:
fresh=""String_Node_Str"" + createFresh();
query.addSelTerm(new SPARQL_Term(sref,SPARQL_Aggregate.COUNT,fresh));
query.addOrderBy(new SPARQL_Term(fresh,SPARQL_OrderBy.ASC));
query.setLimit(1);
break;
case THEMOST:
fresh=""String_Node_Str"" + createFresh();
query.addSelTerm(new SPARQL_Term(sref,SPARQL_Aggregate.COUNT,fresh));
query.addOrderBy(new SPARQL_Term(fresh,SPARQL_OrderBy.DESC));
query.setLimit(1);
break;
}
}
 else if (condition.isNegatedCondition()) {
if (!isSilent()) {
System.out.print(""String_Node_Str"" + condition.toString());
}
Negated_DRS neg=(Negated_DRS)condition;
query=convert(neg.getDRS(),query,true);
}
 else {
Simple_DRS_Condition simple=(Simple_DRS_Condition)condition;
if (!isSilent()) {
System.out.print(isSilent() + ""String_Node_Str"" + condition.toString());
}
int arity=simple.getArguments().size();
String predicate=simple.getPredicate();
if (predicate.startsWith(""String_Node_Str"")) {
for (Slot s : slots) {
if (s.getAnchor().equals(predicate)) {
s.setToken(predicate);
predicate=""String_Node_Str"" + createFresh();
s.setAnchor(predicate);
template.addSlot(s);
break;
}
 else if (s.getToken().equals(predicate)) {
predicate=s.getAnchor();
}
}
}
SPARQL_Property prop=new SPARQL_Property(predicate);
prop.setIsVariable(true);
boolean literal=false;
if (simple.getArguments().size() > 1 && simple.getArguments().get(1).getValue().matches(""String_Node_Str"")) {
literal=true;
}
if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(0).getValue(),SPARQL_Aggregate.COUNT,simple.getArguments().get(1).getValue()));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(1).getValue(),SPARQL_Aggregate.SUM));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.GT)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.GTEQ)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.LT)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.LTEQ)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(0).getValue(),true));
query.addOrderBy(new SPARQL_Term(simple.getArguments().get(0).getValue(),SPARQL_OrderBy.DESC));
query.setLimit(1);
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(0).getValue(),true));
query.addOrderBy(new SPARQL_Term(simple.getArguments().get(0).getValue(),SPARQL_OrderBy.ASC));
query.setLimit(1);
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.EQ)));
return query;
}
if (arity == 1) {
SPARQL_Term term=new SPARQL_Term(simple.getArguments().get(0).getValue(),false);
term.setIsVariable(true);
query.addCondition(new SPARQL_Triple(term,new SPARQL_Property(""String_Node_Str"",new SPARQL_Prefix(""String_Node_Str"",""String_Node_Str"")),prop));
}
 else if (arity == 2) {
String arg1=simple.getArguments().get(0).getValue();
SPARQL_Term term1=new SPARQL_Term(arg1,false);
term1.setIsVariable(true);
String arg2=simple.getArguments().get(1).getValue();
SPARQL_Term term2=new SPARQL_Term(arg2,false);
term2.setIsVariable(true);
query.addCondition(new SPARQL_Triple(term1,prop,term2));
}
 else if (arity > 2) {
}
}
return query;
}","private Query convertCondition(DRS_Condition condition,Query query){
  if (condition.isComplexCondition()) {
    if (!isSilent()) {
      System.out.print(""String_Node_Str"" + condition.toString());
    }
    Complex_DRS_Condition complex=(Complex_DRS_Condition)condition;
    DRS restrictor=complex.getRestrictor();
    DRS_Quantifier quant=complex.getQuantifier();
    DRS scope=complex.getScope();
    for (    DRS_Condition cond : restrictor.getConditions()) {
      query=convertCondition(cond,query);
    }
    for (    DRS_Condition cond : scope.getConditions()) {
      query=convertCondition(cond,query);
    }
    DiscourseReferent ref=complex.getReferent();
    String sref=ref.getValue();
    String fresh;
    if (!isSilent()) {
      System.out.print(""String_Node_Str"" + quant);
    }
switch (quant) {
case HOWMANY:
      query.addSelTerm(new SPARQL_Term(sref,SPARQL_Aggregate.COUNT));
    break;
case EVERY:
  break;
case NO:
SPARQL_Filter f=new SPARQL_Filter();
f.addNotBound(new SPARQL_Term(sref));
query.addFilter(f);
break;
case FEW:
break;
case MANY:
break;
case MOST:
break;
case SOME:
break;
case THELEAST:
fresh=""String_Node_Str"" + createFresh();
query.addSelTerm(new SPARQL_Term(sref,SPARQL_Aggregate.COUNT,fresh));
query.addOrderBy(new SPARQL_Term(fresh,SPARQL_OrderBy.ASC));
query.setLimit(1);
break;
case THEMOST:
fresh=""String_Node_Str"" + createFresh();
query.addSelTerm(new SPARQL_Term(sref,SPARQL_Aggregate.COUNT,fresh));
query.addOrderBy(new SPARQL_Term(fresh,SPARQL_OrderBy.DESC));
query.setLimit(1);
break;
}
}
 else if (condition.isNegatedCondition()) {
if (!isSilent()) {
System.out.print(""String_Node_Str"" + condition.toString());
}
Negated_DRS neg=(Negated_DRS)condition;
query=convert(neg.getDRS(),query,true);
}
 else {
Simple_DRS_Condition simple=(Simple_DRS_Condition)condition;
if (!isSilent()) {
System.out.print(isSilent() + ""String_Node_Str"" + condition.toString());
}
int arity=simple.getArguments().size();
String predicate=simple.getPredicate();
if (predicate.startsWith(""String_Node_Str"")) {
for (Slot s : slots) {
if (s.getAnchor().equals(predicate)) {
s.setToken(predicate);
predicate=""String_Node_Str"" + createFresh();
s.setAnchor(predicate);
template.addSlot(s);
break;
}
 else if (s.getToken().equals(predicate)) {
predicate=s.getAnchor();
}
}
}
SPARQL_Property prop=new SPARQL_Property(predicate);
prop.setIsVariable(true);
boolean literal=false;
if (simple.getArguments().size() > 1 && simple.getArguments().get(1).getValue().matches(""String_Node_Str"")) {
literal=true;
}
if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(0).getValue(),SPARQL_Aggregate.COUNT,simple.getArguments().get(1).getValue()));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(1).getValue(),SPARQL_Aggregate.SUM));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),false),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.GT)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),false),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.GTEQ)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),false),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.LT)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),false),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.LTEQ)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(0).getValue(),false));
query.addOrderBy(new SPARQL_Term(simple.getArguments().get(0).getValue(),SPARQL_OrderBy.DESC));
query.setLimit(1);
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(0).getValue(),false));
query.addOrderBy(new SPARQL_Term(simple.getArguments().get(0).getValue(),SPARQL_OrderBy.ASC));
query.setLimit(1);
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.EQ)));
return query;
}
if (arity == 1) {
SPARQL_Term term=new SPARQL_Term(simple.getArguments().get(0).getValue(),false);
term.setIsVariable(true);
query.addCondition(new SPARQL_Triple(term,new SPARQL_Property(""String_Node_Str"",new SPARQL_Prefix(""String_Node_Str"",""String_Node_Str"")),prop));
}
 else if (arity == 2) {
String arg1=simple.getArguments().get(0).getValue();
SPARQL_Term term1=new SPARQL_Term(arg1,false);
term1.setIsVariable(true);
String arg2=simple.getArguments().get(1).getValue();
SPARQL_Term term2=new SPARQL_Term(arg2,false);
term2.setIsVariable(true);
query.addCondition(new SPARQL_Triple(term1,prop,term2));
}
 else if (arity > 2) {
}
}
return query;
}"
9599,"public Set<Template> buildTemplates(String s){
  boolean clearAgain=true;
  String tagged;
  if (UNTAGGED_INPUT) {
    s=pp.normalize(s);
    tagged=tagger.tag(s);
    logger.trace(""String_Node_Str"" + tagged);
  }
 else {
    tagged=s;
  }
  String newtagged=pp.condenseNominals(pp.findNEs(tagged,s));
  newtagged=pp.condense(newtagged);
  logger.trace(""String_Node_Str"" + newtagged);
  p.parse(newtagged,g);
  if (p.getDerivationTrees().isEmpty()) {
    p.clear(g,p.getTemps());
    clearAgain=false;
    logger.error(""String_Node_Str"" + s + ""String_Node_Str"");
  }
 else {
    try {
      p.buildDerivedTrees(g);
    }
 catch (    ParseException e) {
      logger.error(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"",e);
    }
  }
  Hashtable<String,String> postable=new Hashtable<String,String>();
  for (  String st : newtagged.split(""String_Node_Str"")) {
    postable.put(st.substring(0,st.indexOf(""String_Node_Str"")),st.substring(st.indexOf(""String_Node_Str"") + 1));
    ;
  }
  Set<DRS> drses=new HashSet<DRS>();
  Set<Template> templates=new HashSet<Template>();
  for (  Dude dude : p.getDudes()) {
    UDRS udrs=d2u.convert(dude);
    if (udrs != null) {
      for (      DRS drs : udrs.initResolve()) {
        List<Slot> slots=new ArrayList<Slot>();
        slots.addAll(dude.getSlots());
        d2s.setSlots(slots);
        d2s.redundantEqualRenaming(drs);
        if (!containsModuloRenaming(drses,drs)) {
          drses.add(drs);
          try {
            Template temp=d2s.convert(drs,slots);
            List<String> newwords;
            String word;
            String pos;
            for (            Slot slot : temp.getSlots()) {
              if (!slot.getWords().isEmpty()) {
                word=slot.getWords().get(0);
                pos=postable.get(word.replace(""String_Node_Str"",""String_Node_Str""));
                POS wordnetpos=null;
                if (equalsOneOf(pos,noun)) {
                  wordnetpos=POS.NOUN;
                }
 else                 if (equalsOneOf(pos,adjective)) {
                  wordnetpos=POS.ADJECTIVE;
                }
 else                 if (equalsOneOf(pos,verb)) {
                  wordnetpos=POS.VERB;
                }
                List<String> strings=new ArrayList<String>();
                if (wordnetpos.equals(POS.ADJECTIVE)) {
                  strings=wordnet.getAttributes(word);
                }
                newwords=new ArrayList<String>();
                newwords.add(word);
                newwords.addAll(strings);
                newwords.addAll(wordnet.getBestSynonyms(wordnetpos,getLemmatizedWord(word)));
                for (                String att : getLemmatizedWords(strings)) {
                  newwords.addAll(wordnet.getBestSynonyms(wordnetpos,att));
                }
                if (newwords.isEmpty()) {
                  newwords.add(slot.getWords().get(0));
                }
                List<String> newwordslist=new ArrayList<String>();
                newwordslist.addAll(newwords);
                slot.setWords(newwordslist);
              }
            }
            templates.add(temp);
          }
 catch (          java.lang.ClassCastException e) {
            continue;
          }
          if (ONE_SCOPE_ONLY) {
            break;
          }
        }
      }
    }
  }
  if (clearAgain) {
    p.clear(g,p.getTemps());
  }
  System.gc();
  return templates;
}","public Set<Template> buildTemplates(String s){
  boolean clearAgain=true;
  String tagged;
  if (UNTAGGED_INPUT) {
    s=pp.normalize(s);
    tagged=tagger.tag(s);
    logger.trace(""String_Node_Str"" + tagged);
  }
 else {
    tagged=s;
  }
  String newtagged=pp.condenseNominals(pp.findNEs(tagged,s));
  newtagged=pp.condense(newtagged);
  logger.trace(""String_Node_Str"" + newtagged);
  p.parse(newtagged,g);
  if (p.getDerivationTrees().isEmpty()) {
    p.clear(g,p.getTemps());
    clearAgain=false;
    logger.error(""String_Node_Str"" + s + ""String_Node_Str"");
  }
 else {
    try {
      p.buildDerivedTrees(g);
    }
 catch (    ParseException e) {
      logger.error(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"",e);
    }
  }
  Hashtable<String,String> postable=new Hashtable<String,String>();
  for (  String st : newtagged.split(""String_Node_Str"")) {
    postable.put(st.substring(0,st.indexOf(""String_Node_Str"")).toLowerCase(),st.substring(st.indexOf(""String_Node_Str"") + 1));
    ;
  }
  Set<DRS> drses=new HashSet<DRS>();
  Set<Template> templates=new HashSet<Template>();
  for (  Dude dude : p.getDudes()) {
    UDRS udrs=d2u.convert(dude);
    if (udrs != null) {
      for (      DRS drs : udrs.initResolve()) {
        List<Slot> slots=new ArrayList<Slot>();
        slots.addAll(dude.getSlots());
        d2s.setSlots(slots);
        d2s.redundantEqualRenaming(drs);
        if (!containsModuloRenaming(drses,drs)) {
          System.out.println(dude);
          System.out.println(drs);
          for (          Slot sl : slots) {
            System.out.println(sl.toString());
          }
          drses.add(drs);
          try {
            Template temp=d2s.convert(drs,slots);
            List<String> newwords;
            String word;
            String pos;
            for (            Slot slot : temp.getSlots()) {
              if (!slot.getWords().isEmpty()) {
                word=slot.getWords().get(0);
                pos=postable.get(word.toLowerCase().replace(""String_Node_Str"",""String_Node_Str""));
                POS wordnetpos=null;
                if (pos != null) {
                  if (equalsOneOf(pos,noun)) {
                    wordnetpos=POS.NOUN;
                  }
 else                   if (equalsOneOf(pos,adjective)) {
                    wordnetpos=POS.ADJECTIVE;
                  }
 else                   if (equalsOneOf(pos,verb)) {
                    wordnetpos=POS.VERB;
                  }
                }
                List<String> strings=new ArrayList<String>();
                if (wordnetpos != null && wordnetpos.equals(POS.ADJECTIVE)) {
                  strings=wordnet.getAttributes(word);
                }
                newwords=new ArrayList<String>();
                newwords.add(word);
                newwords.addAll(strings);
                if (wordnetpos != null) {
                  newwords.addAll(wordnet.getBestSynonyms(wordnetpos,getLemmatizedWord(word)));
                  for (                  String att : getLemmatizedWords(strings)) {
                    newwords.addAll(wordnet.getBestSynonyms(wordnetpos,att));
                  }
                }
                if (newwords.isEmpty()) {
                  newwords.add(slot.getWords().get(0));
                }
                List<String> newwordslist=new ArrayList<String>();
                newwordslist.addAll(newwords);
                slot.setWords(newwordslist);
              }
            }
            templates.add(temp);
          }
 catch (          java.lang.ClassCastException e) {
            continue;
          }
          if (ONE_SCOPE_ONLY) {
            break;
          }
        }
      }
    }
  }
  if (clearAgain) {
    p.clear(g,p.getTemps());
  }
  System.gc();
  return templates;
}"
9600,"@SuppressWarnings(""String_Node_Str"") public SortedSet<Individual> getIndividualsImplFast(Description description) throws ReasoningMethodUnsupportedException {
  if (description instanceof NamedClass) {
    return (TreeSet<Individual>)classInstancesPos.get((NamedClass)description).clone();
  }
 else   if (description instanceof Negation) {
    if (description.getChild(0) instanceof NamedClass) {
      return (TreeSet<Individual>)classInstancesNeg.get((NamedClass)description.getChild(0)).clone();
    }
    return Helper.difference((TreeSet<Individual>)individuals.clone(),getIndividualsImpl(description.getChild(0)));
  }
 else   if (description instanceof Thing) {
    return (TreeSet<Individual>)individuals.clone();
  }
 else   if (description instanceof Nothing) {
    return new TreeSet<Individual>();
  }
 else   if (description instanceof Union) {
    SortedSet<Individual> ret=getIndividualsImpl(description.getChild(0));
    int childNr=0;
    for (    Description child : description.getChildren()) {
      if (childNr != 0) {
        ret.addAll(getIndividualsImpl(child));
      }
      childNr++;
    }
    return ret;
  }
 else   if (description instanceof Intersection) {
    SortedSet<Individual> ret=getIndividualsImpl(description.getChild(0));
    int childNr=0;
    for (    Description child : description.getChildren()) {
      if (childNr != 0) {
        ret.retainAll(getIndividualsImpl(child));
      }
      childNr++;
    }
    return ret;
  }
 else   if (description instanceof ObjectSomeRestriction) {
    SortedSet<Individual> targetSet=getIndividualsImpl(description.getChild(0));
    SortedSet<Individual> returnSet=new TreeSet<Individual>();
    ObjectPropertyExpression ope=((ObjectSomeRestriction)description).getRole();
    if (!(ope instanceof ObjectProperty)) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    ObjectProperty op=(ObjectProperty)ope;
    Map<Individual,SortedSet<Individual>> mapping=opPos.get(op);
    for (    Entry<Individual,SortedSet<Individual>> entry : mapping.entrySet()) {
      SortedSet<Individual> inds=entry.getValue();
      for (      Individual ind : inds) {
        if (targetSet.contains(ind)) {
          returnSet.add(entry.getKey());
          continue;
        }
      }
    }
    return returnSet;
  }
 else   if (description instanceof ObjectAllRestriction) {
    SortedSet<Individual> targetSet=getIndividualsImpl(description.getChild(0));
    ObjectPropertyExpression ope=((ObjectAllRestriction)description).getRole();
    if (!(ope instanceof ObjectProperty)) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    ObjectProperty op=(ObjectProperty)ope;
    Map<Individual,SortedSet<Individual>> mapping=opPos.get(op);
    SortedSet<Individual> returnSet=(SortedSet<Individual>)individuals.clone();
    for (    Entry<Individual,SortedSet<Individual>> entry : mapping.entrySet()) {
      SortedSet<Individual> inds=entry.getValue();
      for (      Individual ind : inds) {
        if (!targetSet.contains(ind)) {
          returnSet.remove(entry.getKey());
          continue;
        }
      }
    }
    return returnSet;
  }
 else   if (description instanceof ObjectMinCardinalityRestriction) {
    ObjectPropertyExpression ope=((ObjectCardinalityRestriction)description).getRole();
    if (!(ope instanceof ObjectProperty)) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    ObjectProperty op=(ObjectProperty)ope;
    Description child=description.getChild(0);
    Map<Individual,SortedSet<Individual>> mapping=opPos.get(op);
    SortedSet<Individual> targetSet=getIndividualsImpl(child);
    SortedSet<Individual> returnSet=new TreeSet<Individual>();
    int number=((ObjectCardinalityRestriction)description).getNumber();
    for (    Entry<Individual,SortedSet<Individual>> entry : mapping.entrySet()) {
      int nrOfFillers=0;
      int index=0;
      SortedSet<Individual> inds=entry.getValue();
      if (inds.size() < number) {
        continue;
      }
      for (      Individual ind : inds) {
        if (nrOfFillers >= number) {
          returnSet.add(entry.getKey());
          break;
        }
        if (inds.size() - index < number) {
          break;
        }
        if (targetSet.contains(ind)) {
          nrOfFillers++;
        }
        index++;
      }
    }
    return returnSet;
  }
 else   if (description instanceof ObjectMaxCardinalityRestriction) {
    ObjectPropertyExpression ope=((ObjectCardinalityRestriction)description).getRole();
    if (!(ope instanceof ObjectProperty)) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    ObjectProperty op=(ObjectProperty)ope;
    Description child=description.getChild(0);
    Map<Individual,SortedSet<Individual>> mapping=opPos.get(op);
    SortedSet<Individual> targetSet=getIndividualsImpl(child);
    SortedSet<Individual> returnSet=(SortedSet<Individual>)individuals.clone();
    int number=((ObjectCardinalityRestriction)description).getNumber();
    for (    Entry<Individual,SortedSet<Individual>> entry : mapping.entrySet()) {
      int nrOfFillers=0;
      int index=0;
      SortedSet<Individual> inds=entry.getValue();
      if (number < inds.size()) {
        returnSet.add(entry.getKey());
        continue;
      }
      for (      Individual ind : inds) {
        if (nrOfFillers >= number) {
          break;
        }
        if (inds.size() - index < number) {
          returnSet.add(entry.getKey());
          break;
        }
        if (targetSet.contains(ind)) {
          nrOfFillers++;
        }
        index++;
      }
    }
    return returnSet;
  }
 else   if (description instanceof ObjectValueRestriction) {
    Individual i=((ObjectValueRestriction)description).getIndividual();
    ObjectProperty op=(ObjectProperty)((ObjectValueRestriction)description).getRestrictedPropertyExpression();
    Map<Individual,SortedSet<Individual>> mapping=opPos.get(op);
    SortedSet<Individual> returnSet=new TreeSet<Individual>();
    for (    Entry<Individual,SortedSet<Individual>> entry : mapping.entrySet()) {
      if (entry.getValue().contains(i)) {
        returnSet.add(entry.getKey());
      }
    }
    return returnSet;
  }
 else   if (description instanceof BooleanValueRestriction) {
    DatatypeProperty dp=((BooleanValueRestriction)description).getRestrictedPropertyExpression();
    boolean value=((BooleanValueRestriction)description).getBooleanValue();
    if (value) {
      return (TreeSet<Individual>)bdPos.get(dp).clone();
    }
 else {
      return (TreeSet<Individual>)bdNeg.get(dp).clone();
    }
  }
 else   if (description instanceof DatatypeSomeRestriction) {
    DatatypeSomeRestriction dsr=(DatatypeSomeRestriction)description;
    DatatypeProperty dp=(DatatypeProperty)dsr.getRestrictedPropertyExpression();
    DataRange dr=dsr.getDataRange();
    Map<Individual,SortedSet<Double>> mapping=dd.get(dp);
    SortedSet<Individual> returnSet=new TreeSet<Individual>();
    if (dr instanceof DoubleMaxValue) {
      for (      Entry<Individual,SortedSet<Double>> entry : mapping.entrySet()) {
        if (entry.getValue().first() <= ((DoubleMaxValue)dr).getValue()) {
          returnSet.add(entry.getKey());
        }
      }
    }
 else     if (dr instanceof DoubleMinValue) {
      for (      Entry<Individual,SortedSet<Double>> entry : mapping.entrySet()) {
        if (entry.getValue().last() >= ((DoubleMinValue)dr).getValue()) {
          returnSet.add(entry.getKey());
        }
      }
    }
  }
  throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") public SortedSet<Individual> getIndividualsImplFast(Description description) throws ReasoningMethodUnsupportedException {
  if (description instanceof NamedClass) {
    if (((NamedClass)description).getName().equals(""String_Node_Str"")) {
      return new TreeSet<Individual>();
    }
    return (TreeSet<Individual>)classInstancesPos.get((NamedClass)description).clone();
  }
 else   if (description instanceof Negation) {
    if (description.getChild(0) instanceof NamedClass) {
      return (TreeSet<Individual>)classInstancesNeg.get((NamedClass)description.getChild(0)).clone();
    }
    return Helper.difference((TreeSet<Individual>)individuals.clone(),getIndividualsImpl(description.getChild(0)));
  }
 else   if (description instanceof Thing) {
    return (TreeSet<Individual>)individuals.clone();
  }
 else   if (description instanceof Nothing) {
    return new TreeSet<Individual>();
  }
 else   if (description instanceof Union) {
    SortedSet<Individual> ret=getIndividualsImpl(description.getChild(0));
    int childNr=0;
    for (    Description child : description.getChildren()) {
      if (childNr != 0) {
        ret.addAll(getIndividualsImpl(child));
      }
      childNr++;
    }
    return ret;
  }
 else   if (description instanceof Intersection) {
    SortedSet<Individual> ret=getIndividualsImpl(description.getChild(0));
    int childNr=0;
    for (    Description child : description.getChildren()) {
      if (childNr != 0) {
        ret.retainAll(getIndividualsImpl(child));
      }
      childNr++;
    }
    return ret;
  }
 else   if (description instanceof ObjectSomeRestriction) {
    SortedSet<Individual> targetSet=getIndividualsImpl(description.getChild(0));
    SortedSet<Individual> returnSet=new TreeSet<Individual>();
    ObjectPropertyExpression ope=((ObjectSomeRestriction)description).getRole();
    if (!(ope instanceof ObjectProperty)) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    ObjectProperty op=(ObjectProperty)ope;
    Map<Individual,SortedSet<Individual>> mapping=opPos.get(op);
    for (    Entry<Individual,SortedSet<Individual>> entry : mapping.entrySet()) {
      SortedSet<Individual> inds=entry.getValue();
      for (      Individual ind : inds) {
        if (targetSet.contains(ind)) {
          returnSet.add(entry.getKey());
          continue;
        }
      }
    }
    return returnSet;
  }
 else   if (description instanceof ObjectAllRestriction) {
    SortedSet<Individual> targetSet=getIndividualsImpl(description.getChild(0));
    ObjectPropertyExpression ope=((ObjectAllRestriction)description).getRole();
    if (!(ope instanceof ObjectProperty)) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    ObjectProperty op=(ObjectProperty)ope;
    Map<Individual,SortedSet<Individual>> mapping=opPos.get(op);
    SortedSet<Individual> returnSet=(SortedSet<Individual>)individuals.clone();
    for (    Entry<Individual,SortedSet<Individual>> entry : mapping.entrySet()) {
      SortedSet<Individual> inds=entry.getValue();
      for (      Individual ind : inds) {
        if (!targetSet.contains(ind)) {
          returnSet.remove(entry.getKey());
          continue;
        }
      }
    }
    return returnSet;
  }
 else   if (description instanceof ObjectMinCardinalityRestriction) {
    ObjectPropertyExpression ope=((ObjectCardinalityRestriction)description).getRole();
    if (!(ope instanceof ObjectProperty)) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    ObjectProperty op=(ObjectProperty)ope;
    Description child=description.getChild(0);
    Map<Individual,SortedSet<Individual>> mapping=opPos.get(op);
    SortedSet<Individual> targetSet=getIndividualsImpl(child);
    SortedSet<Individual> returnSet=new TreeSet<Individual>();
    int number=((ObjectCardinalityRestriction)description).getNumber();
    for (    Entry<Individual,SortedSet<Individual>> entry : mapping.entrySet()) {
      int nrOfFillers=0;
      int index=0;
      SortedSet<Individual> inds=entry.getValue();
      if (inds.size() < number) {
        continue;
      }
      for (      Individual ind : inds) {
        if (nrOfFillers >= number) {
          returnSet.add(entry.getKey());
          break;
        }
        if (inds.size() - index < number) {
          break;
        }
        if (targetSet.contains(ind)) {
          nrOfFillers++;
        }
        index++;
      }
    }
    return returnSet;
  }
 else   if (description instanceof ObjectMaxCardinalityRestriction) {
    ObjectPropertyExpression ope=((ObjectCardinalityRestriction)description).getRole();
    if (!(ope instanceof ObjectProperty)) {
      throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
    }
    ObjectProperty op=(ObjectProperty)ope;
    Description child=description.getChild(0);
    Map<Individual,SortedSet<Individual>> mapping=opPos.get(op);
    SortedSet<Individual> targetSet=getIndividualsImpl(child);
    SortedSet<Individual> returnSet=(SortedSet<Individual>)individuals.clone();
    int number=((ObjectCardinalityRestriction)description).getNumber();
    for (    Entry<Individual,SortedSet<Individual>> entry : mapping.entrySet()) {
      int nrOfFillers=0;
      int index=0;
      SortedSet<Individual> inds=entry.getValue();
      if (number < inds.size()) {
        returnSet.add(entry.getKey());
        continue;
      }
      for (      Individual ind : inds) {
        if (nrOfFillers >= number) {
          break;
        }
        if (inds.size() - index < number) {
          returnSet.add(entry.getKey());
          break;
        }
        if (targetSet.contains(ind)) {
          nrOfFillers++;
        }
        index++;
      }
    }
    return returnSet;
  }
 else   if (description instanceof ObjectValueRestriction) {
    Individual i=((ObjectValueRestriction)description).getIndividual();
    ObjectProperty op=(ObjectProperty)((ObjectValueRestriction)description).getRestrictedPropertyExpression();
    Map<Individual,SortedSet<Individual>> mapping=opPos.get(op);
    SortedSet<Individual> returnSet=new TreeSet<Individual>();
    for (    Entry<Individual,SortedSet<Individual>> entry : mapping.entrySet()) {
      if (entry.getValue().contains(i)) {
        returnSet.add(entry.getKey());
      }
    }
    return returnSet;
  }
 else   if (description instanceof BooleanValueRestriction) {
    DatatypeProperty dp=((BooleanValueRestriction)description).getRestrictedPropertyExpression();
    boolean value=((BooleanValueRestriction)description).getBooleanValue();
    if (value) {
      return (TreeSet<Individual>)bdPos.get(dp).clone();
    }
 else {
      return (TreeSet<Individual>)bdNeg.get(dp).clone();
    }
  }
 else   if (description instanceof DatatypeSomeRestriction) {
    DatatypeSomeRestriction dsr=(DatatypeSomeRestriction)description;
    DatatypeProperty dp=(DatatypeProperty)dsr.getRestrictedPropertyExpression();
    DataRange dr=dsr.getDataRange();
    Map<Individual,SortedSet<Double>> mapping=dd.get(dp);
    SortedSet<Individual> returnSet=new TreeSet<Individual>();
    if (dr instanceof DoubleMaxValue) {
      for (      Entry<Individual,SortedSet<Double>> entry : mapping.entrySet()) {
        if (entry.getValue().first() <= ((DoubleMaxValue)dr).getValue()) {
          returnSet.add(entry.getKey());
        }
      }
    }
 else     if (dr instanceof DoubleMinValue) {
      for (      Entry<Individual,SortedSet<Double>> entry : mapping.entrySet()) {
        if (entry.getValue().last() >= ((DoubleMinValue)dr).getValue()) {
          returnSet.add(entry.getKey());
        }
      }
    }
  }
  throw new ReasoningMethodUnsupportedException(""String_Node_Str"" + description + ""String_Node_Str"");
}"
9601,"public void replaceVarWithURI(String var,String uri){
  SPARQL_Value subject;
  SPARQL_Value property;
  SPARQL_Value object;
  uri=""String_Node_Str"" + uri + ""String_Node_Str"";
  for (  SPARQL_Triple triple : conditions) {
    subject=triple.getVariable();
    property=triple.getProperty();
    object=triple.getValue();
    if (subject.isVariable()) {
      if (subject.getName().equals(var)) {
        subject.setName(uri);
        subject.setIsVariable(false);
      }
    }
    if (property.isVariable()) {
      if (property.getName().equals(var)) {
        property.setName(uri);
        property.setIsVariable(false);
      }
    }
    if (object.isVariable()) {
      if (object.getName().equals(var)) {
        object.setName(uri);
        object.setIsVariable(false);
      }
    }
  }
}","public void replaceVarWithURI(String var,String uri){
  SPARQL_Term subject;
  SPARQL_Property property;
  SPARQL_Value object;
  uri=""String_Node_Str"" + uri + ""String_Node_Str"";
  for (  SPARQL_Triple triple : conditions) {
    subject=triple.getVariable();
    property=triple.getProperty();
    object=triple.getValue();
    if (subject.isVariable()) {
      if (subject.getName().equals(var)) {
        subject.setName(uri);
        subject.setIsVariable(false);
        subject.setIsURI(true);
      }
    }
    if (property.isVariable()) {
      if (property.getName().equals(var)) {
        property.setName(uri);
        property.setIsVariable(false);
      }
    }
    if (object.isVariable()) {
      if (object.getName().equals(var)) {
        object.setName(uri);
        object.setIsVariable(false);
        if (object instanceof SPARQL_Term) {
          ((SPARQL_Term)object).setIsURI(true);
        }
      }
    }
  }
}"
9602,"public Query(Query query){
  Set<SPARQL_Term> selTerms=new HashSet<SPARQL_Term>();
  for (  SPARQL_Term term : query.getSelTerms()) {
    SPARQL_Term newTerm=new SPARQL_Term(term.getName());
    newTerm.setIsVariable(term.isVariable());
    newTerm.setAggregate(term.getAggregate());
    newTerm.setOrderBy(term.getOrderBy());
    selTerms.add(newTerm);
  }
  this.selTerms=selTerms;
  Set<SPARQL_Prefix> prefixes=new HashSet<SPARQL_Prefix>();
  for (  SPARQL_Prefix prefix : query.getPrefixes()) {
    SPARQL_Prefix newPrefix=new SPARQL_Prefix(prefix.getName(),prefix.getUrl());
    prefixes.add(newPrefix);
  }
  this.prefixes=prefixes;
  Set<SPARQL_Triple> conditions=new HashSet<SPARQL_Triple>();
  for (  SPARQL_Triple condition : query.getConditions()) {
    SPARQL_Term variable=new SPARQL_Term(condition.getVariable().getName());
    variable.setIsVariable(condition.getVariable().isVariable());
    variable.setIsURI(condition.getVariable().isURI);
    SPARQL_Property property=new SPARQL_Property(condition.getProperty().getName());
    property.setIsVariable(condition.getProperty().isVariable());
    property.setPrefix(condition.getProperty().getPrefix());
    SPARQL_Term value=new SPARQL_Term(condition.getValue().getName());
    if (condition.getValue() instanceof SPARQL_Term) {
      value.setIsURI(((SPARQL_Term)condition.getValue()).isURI);
    }
    value.setIsVariable(condition.getValue().isVariable());
    SPARQL_Triple newCondition=new SPARQL_Triple(variable,property,value);
    conditions.add(newCondition);
  }
  this.conditions=conditions;
  Set<SPARQL_Term> orderBy=new HashSet<SPARQL_Term>();
  for (  SPARQL_Term order : query.getOrderBy()) {
    SPARQL_Term newTerm=new SPARQL_Term(order.getName());
    newTerm.setIsVariable(order.isVariable());
    newTerm.setAggregate(order.getAggregate());
    newTerm.setOrderBy(order.getOrderBy());
    selTerms.add(newTerm);
  }
  Set<SPARQL_Filter> filters=new HashSet<SPARQL_Filter>();
  for (  SPARQL_Filter filter : query.getFilters()) {
    for (    SPARQL_Pair term : filter.getTerms()) {
    }
  }
  this.filter=filters;
  this.orderBy=orderBy;
  this.limit=query.getLimit();
  this.offset=query.getOffset();
}","public Query(Query query){
  Set<SPARQL_Term> selTerms=new HashSet<SPARQL_Term>();
  for (  SPARQL_Term term : query.getSelTerms()) {
    SPARQL_Term newTerm=new SPARQL_Term(term.getName());
    newTerm.setIsVariable(term.isVariable());
    newTerm.setIsURI(newTerm.isURI);
    newTerm.setAggregate(term.getAggregate());
    newTerm.setOrderBy(term.getOrderBy());
    selTerms.add(newTerm);
  }
  this.selTerms=selTerms;
  Set<SPARQL_Prefix> prefixes=new HashSet<SPARQL_Prefix>();
  for (  SPARQL_Prefix prefix : query.getPrefixes()) {
    SPARQL_Prefix newPrefix=new SPARQL_Prefix(prefix.getName(),prefix.getUrl());
    prefixes.add(newPrefix);
  }
  this.prefixes=prefixes;
  Set<SPARQL_Triple> conditions=new HashSet<SPARQL_Triple>();
  for (  SPARQL_Triple condition : query.getConditions()) {
    SPARQL_Term variable=new SPARQL_Term(condition.getVariable().getName());
    variable.setIsVariable(condition.getVariable().isVariable());
    variable.setIsURI(condition.getVariable().isURI);
    SPARQL_Property property=new SPARQL_Property(condition.getProperty().getName());
    property.setIsVariable(condition.getProperty().isVariable());
    property.setPrefix(condition.getProperty().getPrefix());
    SPARQL_Term value=new SPARQL_Term(condition.getValue().getName());
    if (condition.getValue() instanceof SPARQL_Term) {
      value.setIsURI(((SPARQL_Term)condition.getValue()).isURI);
    }
    value.setIsVariable(condition.getValue().isVariable());
    SPARQL_Triple newCondition=new SPARQL_Triple(variable,property,value);
    conditions.add(newCondition);
  }
  this.conditions=conditions;
  Set<SPARQL_Term> orderBy=new HashSet<SPARQL_Term>();
  for (  SPARQL_Term order : query.getOrderBy()) {
    SPARQL_Term newTerm=new SPARQL_Term(order.getName());
    newTerm.setIsVariable(order.isVariable());
    newTerm.setAggregate(order.getAggregate());
    newTerm.setOrderBy(order.getOrderBy());
    selTerms.add(newTerm);
  }
  Set<SPARQL_Filter> filters=new HashSet<SPARQL_Filter>();
  for (  SPARQL_Filter filter : query.getFilters()) {
    for (    SPARQL_Pair term : filter.getTerms()) {
    }
  }
  this.filter=filters;
  this.orderBy=orderBy;
  this.limit=query.getLimit();
  this.offset=query.getOffset();
}"
9603,"public void reverse(){
  SPARQL_Term newVariable=new SPARQL_Term(this.value.getName());
  newVariable.setIsVariable(this.value.isVariable());
  SPARQL_Value newValue=new SPARQL_Value(this.variable.getName());
  newValue.setIsVariable(this.variable.isVariable());
  this.variable=newVariable;
  this.value=newValue;
}","public void reverse(){
  SPARQL_Term newVariable=new SPARQL_Term(this.value.getName());
  newVariable.setIsVariable(this.value.isVariable());
  if (value instanceof SPARQL_Term) {
    newVariable.setIsURI(((SPARQL_Term)value).isURI);
  }
  SPARQL_Term newValue=new SPARQL_Term(this.variable.getName());
  newValue.setIsVariable(this.variable.isVariable());
  newValue.setIsURI(variable.isURI);
  this.variable=newVariable;
  this.value=newValue;
}"
9604,"private Query convertCondition(DRS_Condition condition,Query query){
  if (condition.isComplexCondition()) {
    if (!isSilent()) {
      System.out.print(""String_Node_Str"" + condition.toString());
    }
    Complex_DRS_Condition complex=(Complex_DRS_Condition)condition;
    DRS restrictor=complex.getRestrictor();
    DRS_Quantifier quant=complex.getQuantifier();
    DRS scope=complex.getScope();
    for (    DRS_Condition cond : restrictor.getConditions()) {
      query=convertCondition(cond,query);
    }
    for (    DRS_Condition cond : scope.getConditions()) {
      query=convertCondition(cond,query);
    }
    DiscourseReferent ref=complex.getReferent();
    String sref=ref.getValue();
    String fresh;
    if (!isSilent()) {
      System.out.print(""String_Node_Str"" + quant);
    }
switch (quant) {
case HOWMANY:
      query.addSelTerm(new SPARQL_Term(sref,SPARQL_Aggregate.COUNT));
    break;
case EVERY:
  break;
case NO:
SPARQL_Filter f=new SPARQL_Filter();
f.addNotBound(new SPARQL_Term(sref));
query.addFilter(f);
break;
case FEW:
break;
case MANY:
break;
case MOST:
break;
case SOME:
break;
case THELEAST:
fresh=""String_Node_Str"" + createFresh();
query.addSelTerm(new SPARQL_Term(sref,SPARQL_Aggregate.COUNT,fresh));
query.addOrderBy(new SPARQL_Term(fresh,SPARQL_OrderBy.ASC));
query.setLimit(1);
break;
case THEMOST:
fresh=""String_Node_Str"" + createFresh();
query.addSelTerm(new SPARQL_Term(sref,SPARQL_Aggregate.COUNT,fresh));
query.addOrderBy(new SPARQL_Term(fresh,SPARQL_OrderBy.DESC));
query.setLimit(1);
break;
}
}
 else if (condition.isNegatedCondition()) {
if (!isSilent()) {
System.out.print(""String_Node_Str"" + condition.toString());
}
Negated_DRS neg=(Negated_DRS)condition;
query=convert(neg.getDRS(),query,true);
}
 else {
Simple_DRS_Condition simple=(Simple_DRS_Condition)condition;
if (!isSilent()) {
System.out.print(isSilent() + ""String_Node_Str"" + condition.toString());
}
int arity=simple.getArguments().size();
String predicate=simple.getPredicate();
if (predicate.startsWith(""String_Node_Str"")) {
for (Slot s : slots) {
if (s.getAnchor().equals(predicate)) {
s.setToken(predicate);
predicate=""String_Node_Str"" + createFresh();
s.setAnchor(predicate);
template.addSlot(s);
break;
}
 else if (s.getToken().equals(predicate)) {
predicate=s.getAnchor();
}
}
}
SPARQL_Property prop=new SPARQL_Property(predicate);
prop.setIsVariable(true);
boolean literal=false;
if (simple.getArguments().size() > 1 && simple.getArguments().get(1).getValue().matches(""String_Node_Str"")) {
literal=true;
}
if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(0).getValue(),SPARQL_Aggregate.COUNT,simple.getArguments().get(1).getValue()));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(1).getValue(),SPARQL_Aggregate.SUM));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.GT)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.GTEQ)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.LT)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.LTEQ)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(0).getValue(),true));
query.addOrderBy(new SPARQL_Term(simple.getArguments().get(0).getValue(),SPARQL_OrderBy.DESC));
query.setLimit(1);
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(0).getValue(),true));
query.addOrderBy(new SPARQL_Term(simple.getArguments().get(0).getValue(),SPARQL_OrderBy.ASC));
query.setLimit(1);
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.EQ)));
return query;
}
if (arity == 1) {
SPARQL_Term term=new SPARQL_Term(simple.getArguments().get(0).getValue(),false);
query.addCondition(new SPARQL_Triple(term,new SPARQL_Property(""String_Node_Str"",new SPARQL_Prefix(""String_Node_Str"",""String_Node_Str"")),prop));
}
 else if (arity == 2) {
String arg1=simple.getArguments().get(0).getValue();
String arg2=simple.getArguments().get(1).getValue();
query.addCondition(new SPARQL_Triple(new SPARQL_Term(arg1,false),prop,new SPARQL_Term(arg2,false)));
}
 else if (arity > 2) {
}
}
return query;
}","private Query convertCondition(DRS_Condition condition,Query query){
  if (condition.isComplexCondition()) {
    if (!isSilent()) {
      System.out.print(""String_Node_Str"" + condition.toString());
    }
    Complex_DRS_Condition complex=(Complex_DRS_Condition)condition;
    DRS restrictor=complex.getRestrictor();
    DRS_Quantifier quant=complex.getQuantifier();
    DRS scope=complex.getScope();
    for (    DRS_Condition cond : restrictor.getConditions()) {
      query=convertCondition(cond,query);
    }
    for (    DRS_Condition cond : scope.getConditions()) {
      query=convertCondition(cond,query);
    }
    DiscourseReferent ref=complex.getReferent();
    String sref=ref.getValue();
    String fresh;
    if (!isSilent()) {
      System.out.print(""String_Node_Str"" + quant);
    }
switch (quant) {
case HOWMANY:
      query.addSelTerm(new SPARQL_Term(sref,SPARQL_Aggregate.COUNT));
    break;
case EVERY:
  break;
case NO:
SPARQL_Filter f=new SPARQL_Filter();
f.addNotBound(new SPARQL_Term(sref));
query.addFilter(f);
break;
case FEW:
break;
case MANY:
break;
case MOST:
break;
case SOME:
break;
case THELEAST:
fresh=""String_Node_Str"" + createFresh();
query.addSelTerm(new SPARQL_Term(sref,SPARQL_Aggregate.COUNT,fresh));
query.addOrderBy(new SPARQL_Term(fresh,SPARQL_OrderBy.ASC));
query.setLimit(1);
break;
case THEMOST:
fresh=""String_Node_Str"" + createFresh();
query.addSelTerm(new SPARQL_Term(sref,SPARQL_Aggregate.COUNT,fresh));
query.addOrderBy(new SPARQL_Term(fresh,SPARQL_OrderBy.DESC));
query.setLimit(1);
break;
}
}
 else if (condition.isNegatedCondition()) {
if (!isSilent()) {
System.out.print(""String_Node_Str"" + condition.toString());
}
Negated_DRS neg=(Negated_DRS)condition;
query=convert(neg.getDRS(),query,true);
}
 else {
Simple_DRS_Condition simple=(Simple_DRS_Condition)condition;
if (!isSilent()) {
System.out.print(isSilent() + ""String_Node_Str"" + condition.toString());
}
int arity=simple.getArguments().size();
String predicate=simple.getPredicate();
if (predicate.startsWith(""String_Node_Str"")) {
for (Slot s : slots) {
if (s.getAnchor().equals(predicate)) {
s.setToken(predicate);
predicate=""String_Node_Str"" + createFresh();
s.setAnchor(predicate);
template.addSlot(s);
break;
}
 else if (s.getToken().equals(predicate)) {
predicate=s.getAnchor();
}
}
}
SPARQL_Property prop=new SPARQL_Property(predicate);
prop.setIsVariable(true);
boolean literal=false;
if (simple.getArguments().size() > 1 && simple.getArguments().get(1).getValue().matches(""String_Node_Str"")) {
literal=true;
}
if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(0).getValue(),SPARQL_Aggregate.COUNT,simple.getArguments().get(1).getValue()));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(1).getValue(),SPARQL_Aggregate.SUM));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.GT)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.GTEQ)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.LT)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.LTEQ)));
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(0).getValue(),true));
query.addOrderBy(new SPARQL_Term(simple.getArguments().get(0).getValue(),SPARQL_OrderBy.DESC));
query.setLimit(1);
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addSelTerm(new SPARQL_Term(simple.getArguments().get(0).getValue(),true));
query.addOrderBy(new SPARQL_Term(simple.getArguments().get(0).getValue(),SPARQL_OrderBy.ASC));
query.setLimit(1);
return query;
}
 else if (predicate.equals(""String_Node_Str"")) {
query.addFilter(new SPARQL_Filter(new SPARQL_Pair(new SPARQL_Term(simple.getArguments().get(0).getValue(),true),new SPARQL_Term(simple.getArguments().get(1).getValue(),literal),SPARQL_PairType.EQ)));
return query;
}
if (arity == 1) {
SPARQL_Term term=new SPARQL_Term(simple.getArguments().get(0).getValue(),false);
term.setIsVariable(true);
query.addCondition(new SPARQL_Triple(term,new SPARQL_Property(""String_Node_Str"",new SPARQL_Prefix(""String_Node_Str"",""String_Node_Str"")),prop));
}
 else if (arity == 2) {
String arg1=simple.getArguments().get(0).getValue();
SPARQL_Term term1=new SPARQL_Term(arg1,false);
term1.setIsVariable(true);
String arg2=simple.getArguments().get(1).getValue();
SPARQL_Term term2=new SPARQL_Term(arg2,false);
term2.setIsVariable(true);
query.addCondition(new SPARQL_Triple(term1,prop,term2));
}
 else if (arity > 2) {
}
}
return query;
}"
9605,"/** 
 * @param args
 * @throws NoTemplateFoundException 
 * @throws IOException 
 * @throws FileNotFoundException 
 * @throws InvalidFileFormatException 
 */
public static void main(String[] args) throws NoTemplateFoundException, InvalidFileFormatException, FileNotFoundException, IOException {
  String question=""String_Node_Str"";
  SPARQLTemplateBasedLearner learner=new SPARQLTemplateBasedLearner();
  SparqlEndpoint endpoint=new SparqlEndpoint(new URL(""String_Node_Str""),Collections.<String>singletonList(""String_Node_Str""),Collections.<String>emptyList());
  learner.setEndpoint(endpoint);
  learner.setQuestion(question);
  learner.learnSPARQLQueries();
  System.out.println(learner.getBestSPARQLQuery());
  System.out.println(learner.getTemplates().iterator().next().getLexicalAnswerType());
}","/** 
 * @param args
 * @throws NoTemplateFoundException 
 * @throws IOException 
 * @throws FileNotFoundException 
 * @throws InvalidFileFormatException 
 */
public static void main(String[] args) throws NoTemplateFoundException, InvalidFileFormatException, FileNotFoundException, IOException {
  String question=""String_Node_Str"";
  SPARQLTemplateBasedLearner learner=new SPARQLTemplateBasedLearner();
  SparqlEndpoint endpoint=new SparqlEndpoint(new URL(""String_Node_Str""),Collections.<String>singletonList(""String_Node_Str""),Collections.<String>emptyList());
  learner.setEndpoint(endpoint);
  learner.setQuestion(question);
  learner.learnSPARQLQueries();
  System.out.println(""String_Node_Str"" + learner.getBestSPARQLQuery());
  System.out.println(""String_Node_Str"" + learner.getTemplates().iterator().next().getLexicalAnswerType());
}"
9606,"public Query(Query query){
  Set<SPARQL_Term> selTerms=new HashSet<SPARQL_Term>();
  for (  SPARQL_Term term : query.getSelTerms()) {
    SPARQL_Term newTerm=new SPARQL_Term(term.getName());
    newTerm.setIsVariable(term.isVariable());
    newTerm.setAggregate(term.getAggregate());
    newTerm.setOrderBy(term.getOrderBy());
    selTerms.add(newTerm);
  }
  this.selTerms=selTerms;
  Set<SPARQL_Prefix> prefixes=new HashSet<SPARQL_Prefix>();
  for (  SPARQL_Prefix prefix : query.getPrefixes()) {
    SPARQL_Prefix newPrefix=new SPARQL_Prefix(prefix.getName(),prefix.getUrl());
    prefixes.add(newPrefix);
  }
  this.prefixes=prefixes;
  Set<SPARQL_Triple> conditions=new HashSet<SPARQL_Triple>();
  for (  SPARQL_Triple condition : query.getConditions()) {
    SPARQL_Term variable=new SPARQL_Term(condition.getVariable().getName());
    variable.setIsVariable(condition.getVariable().isVariable());
    SPARQL_Property property=new SPARQL_Property(condition.getProperty().getName());
    property.setIsVariable(condition.getProperty().isVariable());
    property.setPrefix(condition.getProperty().getPrefix());
    SPARQL_Value value=new SPARQL_Term(condition.getValue().getName());
    value.setIsVariable(condition.getValue().isVariable());
    SPARQL_Triple newCondition=new SPARQL_Triple(variable,property,value);
    conditions.add(newCondition);
  }
  this.conditions=conditions;
  Set<SPARQL_Term> orderBy=new HashSet<SPARQL_Term>();
  for (  SPARQL_Term order : query.getOrderBy()) {
    SPARQL_Term newTerm=new SPARQL_Term(order.getName());
    newTerm.setIsVariable(order.isVariable());
    newTerm.setAggregate(order.getAggregate());
    newTerm.setOrderBy(order.getOrderBy());
    selTerms.add(newTerm);
  }
  Set<SPARQL_Filter> filters=new HashSet<SPARQL_Filter>();
  for (  SPARQL_Filter filter : query.getFilters()) {
    for (    SPARQL_Pair term : filter.getTerms()) {
    }
  }
  this.filter=filters;
  this.orderBy=orderBy;
  this.limit=query.getLimit();
  this.offset=query.getOffset();
}","public Query(Query query){
  Set<SPARQL_Term> selTerms=new HashSet<SPARQL_Term>();
  for (  SPARQL_Term term : query.getSelTerms()) {
    SPARQL_Term newTerm=new SPARQL_Term(term.getName());
    newTerm.setIsVariable(term.isVariable());
    newTerm.setAggregate(term.getAggregate());
    newTerm.setOrderBy(term.getOrderBy());
    selTerms.add(newTerm);
  }
  this.selTerms=selTerms;
  Set<SPARQL_Prefix> prefixes=new HashSet<SPARQL_Prefix>();
  for (  SPARQL_Prefix prefix : query.getPrefixes()) {
    SPARQL_Prefix newPrefix=new SPARQL_Prefix(prefix.getName(),prefix.getUrl());
    prefixes.add(newPrefix);
  }
  this.prefixes=prefixes;
  Set<SPARQL_Triple> conditions=new HashSet<SPARQL_Triple>();
  for (  SPARQL_Triple condition : query.getConditions()) {
    SPARQL_Term variable=new SPARQL_Term(condition.getVariable().getName());
    variable.setIsVariable(condition.getVariable().isVariable());
    variable.setIsURI(condition.getVariable().isURI);
    SPARQL_Property property=new SPARQL_Property(condition.getProperty().getName());
    property.setIsVariable(condition.getProperty().isVariable());
    property.setPrefix(condition.getProperty().getPrefix());
    SPARQL_Term value=new SPARQL_Term(condition.getValue().getName());
    if (condition.getValue() instanceof SPARQL_Term) {
      value.setIsURI(((SPARQL_Term)condition.getValue()).isURI);
    }
    value.setIsVariable(condition.getValue().isVariable());
    SPARQL_Triple newCondition=new SPARQL_Triple(variable,property,value);
    conditions.add(newCondition);
  }
  this.conditions=conditions;
  Set<SPARQL_Term> orderBy=new HashSet<SPARQL_Term>();
  for (  SPARQL_Term order : query.getOrderBy()) {
    SPARQL_Term newTerm=new SPARQL_Term(order.getName());
    newTerm.setIsVariable(order.isVariable());
    newTerm.setAggregate(order.getAggregate());
    newTerm.setOrderBy(order.getOrderBy());
    selTerms.add(newTerm);
  }
  Set<SPARQL_Filter> filters=new HashSet<SPARQL_Filter>();
  for (  SPARQL_Filter filter : query.getFilters()) {
    for (    SPARQL_Pair term : filter.getTerms()) {
    }
  }
  this.filter=filters;
  this.orderBy=orderBy;
  this.limit=query.getLimit();
  this.offset=query.getOffset();
}"
9607,"public void replaceVarWithPrefixedURI(String var,String uri){
  SPARQL_Value subject;
  SPARQL_Value property;
  SPARQL_Value object;
  for (  SPARQL_Triple triple : conditions) {
    subject=triple.getVariable();
    property=triple.getProperty();
    object=triple.getValue();
    if (subject.isVariable()) {
      if (subject.getName().equals(var)) {
        subject.setName(uri);
        subject.setIsVariable(false);
      }
    }
    if (property.isVariable()) {
      if (property.getName().equals(var)) {
        property.setName(uri);
        property.setIsVariable(false);
      }
    }
    if (object.isVariable()) {
      if (object.getName().equals(var)) {
        object.setName(uri);
        object.setIsVariable(false);
      }
    }
  }
}","public void replaceVarWithPrefixedURI(String var,String uri){
  SPARQL_Term subject;
  SPARQL_Property property;
  SPARQL_Value object;
  for (  SPARQL_Triple triple : conditions) {
    subject=triple.getVariable();
    property=triple.getProperty();
    object=triple.getValue();
    if (subject.isVariable()) {
      if (subject.getName().equals(var)) {
        subject.setName(uri);
        subject.setIsVariable(false);
        subject.setIsURI(true);
      }
    }
    if (property.isVariable()) {
      if (property.getName().equals(var)) {
        property.setName(uri);
        property.setIsVariable(false);
      }
    }
    if (object.isVariable()) {
      if (object.getName().equals(var)) {
        object.setName(uri);
        object.setIsVariable(false);
        if (object instanceof SPARQL_Term) {
          ((SPARQL_Term)object).setIsURI(true);
        }
      }
    }
  }
}"
9608,"public static void main(String[] args){
  System.setProperty(""String_Node_Str"",System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
  WordNetDatabase database=WordNetDatabase.getFileInstance();
  System.out.println(database.getBaseFormCandidates(""String_Node_Str"",SynsetType.NOUN)[1]);
  WordNet wordnet=new WordNet();
  System.out.println(wordnet.getAttributes(""String_Node_Str""));
  System.out.println(wordnet.getBestSynonyms(""String_Node_Str"",""String_Node_Str""));
  System.out.println(wordnet.getAttributes(""String_Node_Str""));
  System.out.println(wordnet.getBestSynonyms(""String_Node_Str"",""String_Node_Str""));
  System.out.println(wordnet.getAttributes(""String_Node_Str""));
}","public static void main(String[] args){
  System.setProperty(""String_Node_Str"",System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
  WordNetDatabase database=WordNetDatabase.getFileInstance();
  System.out.println(database.getBaseFormCandidates(""String_Node_Str"",SynsetType.NOUN)[1]);
  WordNet wordnet=new WordNet();
  System.out.println(wordnet.getAttributes(""String_Node_Str""));
  System.out.println(wordnet.getBestSynonyms(""String_Node_Str""));
  System.out.println(wordnet.getAttributes(""String_Node_Str""));
  System.out.println(wordnet.getBestSynonyms(""String_Node_Str""));
  System.out.println(wordnet.getAttributes(""String_Node_Str""));
}"
9609,"@Override public ApplicationContext buildApplicationContext(IConfiguration configuration,List<Resource> springConfigurationLocations) throws IOException {
  ConfigurableApplicationContext context=null;
  BeanDefinitionRegistryPostProcessor beanDefinitionRegistryPostProcessor=new ConfigurationBasedBeanDefinitionRegistryPostProcessor(configuration);
  List<Resource> allSpringConfigFiles=new ArrayList<Resource>();
  allSpringConfigFiles.add(new ClassPathResource(""String_Node_Str""));
  allSpringConfigFiles.addAll(springConfigurationLocations);
  String[] springConfigurationFiles=new String[allSpringConfigFiles.size()];
  int ctr=0;
  for (  Resource springConfigurationLocation : allSpringConfigFiles) {
    springConfigurationFiles[ctr]=springConfigurationLocation.getFile().toURI().toString();
    ctr++;
  }
  context=new ClassPathXmlApplicationContext(springConfigurationFiles,false);
  context.addBeanFactoryPostProcessor(beanDefinitionRegistryPostProcessor);
  context.refresh();
  return context;
}","@Override public ApplicationContext buildApplicationContext(IConfiguration configuration,List<Resource> springConfigurationLocations) throws IOException {
  ConfigurableApplicationContext context=null;
  BeanDefinitionRegistryPostProcessor beanDefinitionRegistryPostProcessor=new ConfigurationBasedBeanDefinitionRegistryPostProcessor(configuration);
  List<Resource> allSpringConfigFiles=new ArrayList<Resource>();
  allSpringConfigFiles.add(new ClassPathResource(""String_Node_Str""));
  allSpringConfigFiles.addAll(springConfigurationLocations);
  String[] springConfigurationFiles=new String[allSpringConfigFiles.size()];
  int ctr=0;
  for (  Resource springConfigurationLocation : allSpringConfigFiles) {
    try {
      springConfigurationFiles[ctr]=springConfigurationLocation.getURL().toURI().toString();
    }
 catch (    URISyntaxException e) {
      e.printStackTrace();
    }
    ctr++;
  }
  context=new ClassPathXmlApplicationContext(springConfigurationFiles,false);
  context.addBeanFactoryPostProcessor(beanDefinitionRegistryPostProcessor);
  context.refresh();
  return context;
}"
9610,"public static int getMaxExecutionTimeInSeconds(){
  return maxExecutionTimeInSeconds;
}","public int getMaxExecutionTimeInSeconds(){
  return maxExecutionTimeInSeconds;
}"
9611,"public static void setMaxExecutionTimeInSeconds(int maxExecutionTimeInSeconds){
  ClassLearningProblem.maxExecutionTimeInSeconds=maxExecutionTimeInSeconds;
}","public void setMaxExecutionTimeInSeconds(int maxExecutionTimeInSeconds){
  this.maxExecutionTimeInSeconds=maxExecutionTimeInSeconds;
}"
9612,"public FastInstanceChecker(Set<AbstractKnowledgeSource> sources){
  super(sources);
}","public FastInstanceChecker(AbstractKnowledgeSource... sources){
  super(new HashSet<AbstractKnowledgeSource>(Arrays.asList(sources)));
}"
9613,"private List<EvaluatedAxiom> applyCELOE(SparqlEndpointKS ks,NamedClass nc,boolean equivalence) throws ComponentInitException {
  SPARQLReasoner sr=new SPARQLReasoner(ks);
  SortedSet<Individual> posExamples=sr.getIndividuals(nc,20);
  SortedSet<String> posExStr=Helper.getStringSet(posExamples);
  System.out.print(""String_Node_Str"");
  AutomaticNegativeExampleFinderSPARQL2 finder=new AutomaticNegativeExampleFinderSPARQL2(ks.getEndpoint());
  SortedSet<String> negExStr=finder.getNegativeExamples(nc.getName(),posExStr);
  negExStr=SetManipulation.fuzzyShrink(negExStr,20);
  SortedSet<Individual> negExamples=Helper.getIndividualSet(negExStr);
  SortedSetTuple<Individual> examples=new SortedSetTuple<Individual>(posExamples,negExamples);
  System.out.println(""String_Node_Str"" + negExStr.size() + ""String_Node_Str"");
  ComponentManager cm=ComponentManager.getInstance();
  SparqlKnowledgeSource ks2=cm.knowledgeSource(SparqlKnowledgeSource.class);
  ks2.setInstances(Datastructures.individualSetToStringSet(examples.getCompleteSet()));
  ks2.setUrl(ks.getEndpoint().getURL());
  ks2.setDefaultGraphURIs(new TreeSet<String>(ks.getEndpoint().getDefaultGraphURIs()));
  ks2.setUseLits(false);
  ks2.setUseCacheDatabase(true);
  ks2.setRecursionDepth(2);
  ks2.setCloseAfterRecursion(true);
  System.out.println(""String_Node_Str"");
  ks2.init();
  System.out.println(""String_Node_Str"");
  AbstractReasonerComponent rc=cm.reasoner(FastInstanceChecker.class,ks2);
  rc.init();
  ClassLearningProblem lp=cm.learningProblem(ClassLearningProblem.class,rc);
  lp.setClassToDescribe(nc);
  lp.setEquivalence(true);
  lp.setHeuristic(HeuristicType.FMEASURE);
  lp.setUseApproximations(false);
  lp.setMaxExecutionTimeInSeconds(10);
  lp.init();
  CELOE la=null;
  try {
    la=cm.learningAlgorithm(CELOE.class,lp,rc);
  }
 catch (  LearningProblemUnsupportedException e) {
    e.printStackTrace();
  }
  la.setMaxExecutionTimeInSeconds(10);
  la.setNoisePercentage(25);
  la.init();
  System.out.print(""String_Node_Str"");
  la.start();
  System.out.println(""String_Node_Str"");
  List<? extends EvaluatedDescription> learnedDescriptions=la.getCurrentlyBestEvaluatedDescriptions(threshold);
  List<EvaluatedAxiom> evaluatedAxioms=new LinkedList<EvaluatedAxiom>();
  for (  EvaluatedDescription learnedDescription : learnedDescriptions) {
    Axiom axiom;
    if (equivalence) {
      axiom=new EquivalentClassesAxiom(nc,learnedDescription.getDescription());
    }
 else {
      axiom=new SubClassAxiom(nc,learnedDescription.getDescription());
    }
    Score score=lp.computeScore(learnedDescription.getDescription());
    evaluatedAxioms.add(new EvaluatedAxiom(axiom,score));
  }
  algorithmRuns.add(new AlgorithmRun(CELOE.class,evaluatedAxioms,ConfigHelper.getConfigOptionValuesString(la)));
  cm.freeAllComponents();
  return evaluatedAxioms;
}","private List<EvaluatedAxiom> applyCELOE(SparqlEndpointKS ks,NamedClass nc,boolean equivalence) throws ComponentInitException {
  SPARQLReasoner sr=new SPARQLReasoner(ks);
  SortedSet<Individual> posExamples=sr.getIndividuals(nc,20);
  SortedSet<String> posExStr=Helper.getStringSet(posExamples);
  System.out.print(""String_Node_Str"");
  AutomaticNegativeExampleFinderSPARQL2 finder=new AutomaticNegativeExampleFinderSPARQL2(ks.getEndpoint());
  SortedSet<String> negExStr=finder.getNegativeExamples(nc.getName(),posExStr);
  negExStr=SetManipulation.fuzzyShrink(negExStr,20);
  SortedSet<Individual> negExamples=Helper.getIndividualSet(negExStr);
  SortedSetTuple<Individual> examples=new SortedSetTuple<Individual>(posExamples,negExamples);
  System.out.println(""String_Node_Str"" + negExStr.size() + ""String_Node_Str"");
  SparqlKnowledgeSource ks2=new SparqlKnowledgeSource();
  ks2.setInstances(Datastructures.individualSetToStringSet(examples.getCompleteSet()));
  ks2.setUrl(ks.getEndpoint().getURL());
  ks2.setDefaultGraphURIs(new TreeSet<String>(ks.getEndpoint().getDefaultGraphURIs()));
  ks2.setUseLits(false);
  ks2.setUseCacheDatabase(true);
  ks2.setRecursionDepth(2);
  ks2.setCloseAfterRecursion(true);
  System.out.println(""String_Node_Str"");
  ks2.init();
  System.out.println(""String_Node_Str"");
  AbstractReasonerComponent rc=new FastInstanceChecker(ks2);
  rc.init();
  ClassLearningProblem lp=new ClassLearningProblem(rc);
  lp.setClassToDescribe(nc);
  lp.setEquivalence(true);
  lp.setHeuristic(HeuristicType.FMEASURE);
  lp.setUseApproximations(false);
  lp.setMaxExecutionTimeInSeconds(10);
  lp.init();
  CELOE la=new CELOE(lp,rc);
  la.setMaxExecutionTimeInSeconds(10);
  la.setNoisePercentage(25);
  la.init();
  System.out.print(""String_Node_Str"");
  la.start();
  System.out.println(""String_Node_Str"");
  List<? extends EvaluatedDescription> learnedDescriptions=la.getCurrentlyBestEvaluatedDescriptions(threshold);
  List<EvaluatedAxiom> evaluatedAxioms=new LinkedList<EvaluatedAxiom>();
  for (  EvaluatedDescription learnedDescription : learnedDescriptions) {
    Axiom axiom;
    if (equivalence) {
      axiom=new EquivalentClassesAxiom(nc,learnedDescription.getDescription());
    }
 else {
      axiom=new SubClassAxiom(nc,learnedDescription.getDescription());
    }
    Score score=lp.computeScore(learnedDescription.getDescription());
    evaluatedAxioms.add(new EvaluatedAxiom(axiom,score));
  }
  algorithmRuns.add(new AlgorithmRun(CELOE.class,evaluatedAxioms,ConfigHelper.getConfigOptionValuesString(la)));
  return evaluatedAxioms;
}"
9614,"public CommonPrefixMap(){
  put(""String_Node_Str"",""String_Node_Str"");
  put(""String_Node_Str"",""String_Node_Str"");
}","public CommonPrefixMap(){
  put(""String_Node_Str"",""String_Node_Str"");
  put(""String_Node_Str"",""String_Node_Str"");
  put(""String_Node_Str"",""String_Node_Str"");
  put(""String_Node_Str"",""String_Node_Str"");
  put(""String_Node_Str"",""String_Node_Str"");
}"
9615,"private String prettyPrint(EvaluatedAxiom axiom){
  double acc=axiom.getScore().getAccuracy() * 100;
  String accs=df.format(acc);
  if (acc < 10d) {
    accs=""String_Node_Str"" + accs;
  }
  if (acc < 100d) {
    accs=""String_Node_Str"" + accs;
  }
  String str=accs + ""String_Node_Str"" + axiom.getAxiom().toManchesterSyntaxString(null,prefixes);
  return str;
}","private String prettyPrint(EvaluatedAxiom axiom){
  double acc=axiom.getScore().getAccuracy() * 100;
  String accs=df.format(acc);
  if (accs.length() == 3) {
    accs=""String_Node_Str"" + accs;
  }
  if (accs.length() == 4) {
    accs=""String_Node_Str"" + accs;
  }
  String str=accs + ""String_Node_Str"" + axiom.getAxiom().toManchesterSyntaxString(null,prefixes);
  return str;
}"
9616,"private List<EvaluatedAxiom> applyCELOE(SparqlEndpointKS ks,NamedClass nc,boolean equivalence) throws ComponentInitException {
  SPARQLReasoner sr=new SPARQLReasoner(ks);
  SortedSet<Individual> posExamples=sr.getIndividuals(nc,20);
  SortedSet<String> posExStr=Helper.getStringSet(posExamples);
  System.out.print(""String_Node_Str"");
  AutomaticNegativeExampleFinderSPARQL2 finder=new AutomaticNegativeExampleFinderSPARQL2(ks.getEndpoint());
  SortedSet<String> negExStr=finder.getNegativeExamples(nc.getName(),posExStr);
  negExStr=SetManipulation.fuzzyShrink(negExStr,20);
  SortedSet<Individual> negExamples=Helper.getIndividualSet(negExStr);
  SortedSetTuple<Individual> examples=new SortedSetTuple<Individual>(posExamples,negExamples);
  System.out.println(""String_Node_Str"" + negExStr.size() + ""String_Node_Str"");
  SparqlKnowledgeSource ks2=new SparqlKnowledgeSource();
  ks2.setInstances(Datastructures.individualSetToStringSet(examples.getCompleteSet()));
  ks2.setUrl(ks.getEndpoint().getURL());
  ks2.setDefaultGraphURIs(new TreeSet<String>(ks.getEndpoint().getDefaultGraphURIs()));
  ks2.setUseLits(false);
  ks2.setUseCacheDatabase(true);
  ks2.setRecursionDepth(2);
  ks2.setCloseAfterRecursion(true);
  System.out.println(""String_Node_Str"");
  ks2.init();
  System.out.println(""String_Node_Str"");
  AbstractReasonerComponent rc=new FastInstanceChecker(ks2);
  rc.init();
  ClassLearningProblem lp=new ClassLearningProblem(rc);
  lp.setClassToDescribe(nc);
  lp.setEquivalence(true);
  lp.setHeuristic(HeuristicType.FMEASURE);
  lp.setUseApproximations(false);
  lp.setMaxExecutionTimeInSeconds(10);
  lp.init();
  CELOE la=new CELOE(lp,rc);
  la.setMaxExecutionTimeInSeconds(10);
  la.setNoisePercentage(25);
  la.init();
  System.out.print(""String_Node_Str"" + (equivalence ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  la.start();
  System.out.println(""String_Node_Str"");
  List<? extends EvaluatedDescription> learnedDescriptions=la.getCurrentlyBestEvaluatedDescriptions(threshold);
  List<EvaluatedAxiom> learnedAxioms=new LinkedList<EvaluatedAxiom>();
  for (  EvaluatedDescription learnedDescription : learnedDescriptions) {
    Axiom axiom;
    if (equivalence) {
      axiom=new EquivalentClassesAxiom(nc,learnedDescription.getDescription());
    }
 else {
      axiom=new SubClassAxiom(nc,learnedDescription.getDescription());
    }
    Score score=lp.computeScore(learnedDescription.getDescription());
    learnedAxioms.add(new EvaluatedAxiom(axiom,score));
  }
  System.out.println(prettyPrint(learnedAxioms));
  algorithmRuns.add(new AlgorithmRun(CELOE.class,learnedAxioms,ConfigHelper.getConfigOptionValuesString(la)));
  return learnedAxioms;
}","private List<EvaluatedAxiom> applyCELOE(SparqlEndpointKS ks,NamedClass nc,boolean equivalence,boolean reuseKnowledgeSource) throws ComponentInitException {
  SPARQLReasoner sr=new SPARQLReasoner(ks);
  SortedSet<Individual> posExamples=sr.getIndividuals(nc,20);
  SortedSet<String> posExStr=Helper.getStringSet(posExamples);
  long startTime=System.currentTimeMillis();
  System.out.print(""String_Node_Str"");
  AutomaticNegativeExampleFinderSPARQL2 finder=new AutomaticNegativeExampleFinderSPARQL2(ks.getEndpoint());
  SortedSet<String> negExStr=finder.getNegativeExamples(nc.getName(),posExStr);
  negExStr=SetManipulation.fuzzyShrink(negExStr,20);
  SortedSet<Individual> negExamples=Helper.getIndividualSet(negExStr);
  SortedSetTuple<Individual> examples=new SortedSetTuple<Individual>(posExamples,negExamples);
  long runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + negExStr.size() + ""String_Node_Str""+ runTime+ ""String_Node_Str"");
  SparqlKnowledgeSource ks2;
  AbstractReasonerComponent rc;
  if (reuseKnowledgeSource) {
    ks2=ksCached;
    rc=rcCached;
    System.out.println(""String_Node_Str"");
  }
 else {
    ks2=new SparqlKnowledgeSource();
    ks2.setInstances(Datastructures.individualSetToStringSet(examples.getCompleteSet()));
    ks2.setUrl(ks.getEndpoint().getURL());
    ks2.setDefaultGraphURIs(new TreeSet<String>(ks.getEndpoint().getDefaultGraphURIs()));
    ks2.setUseLits(false);
    ks2.setUseCacheDatabase(true);
    ks2.setRecursionDepth(2);
    ks2.setCloseAfterRecursion(true);
    startTime=System.currentTimeMillis();
    System.out.print(""String_Node_Str"");
    ks2.init();
    runTime=System.currentTimeMillis() - startTime;
    System.out.println(""String_Node_Str"" + runTime + ""String_Node_Str"");
    rc=new FastInstanceChecker(ks2);
    rc.init();
    ksCached=ks2;
    rcCached=rc;
  }
  ClassLearningProblem lp=new ClassLearningProblem(rc);
  lp.setClassToDescribe(nc);
  lp.setEquivalence(equivalence);
  lp.setHeuristic(HeuristicType.FMEASURE);
  lp.setUseApproximations(false);
  lp.setMaxExecutionTimeInSeconds(10);
  lp.init();
  CELOE la=new CELOE(lp,rc);
  la.setMaxExecutionTimeInSeconds(10);
  la.setNoisePercentage(25);
  la.init();
  startTime=System.currentTimeMillis();
  System.out.print(""String_Node_Str"" + (equivalence ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  la.start();
  runTime=System.currentTimeMillis() - startTime;
  System.out.println(""String_Node_Str"" + runTime + ""String_Node_Str"");
  List<? extends EvaluatedDescription> learnedDescriptions=la.getCurrentlyBestEvaluatedDescriptions(threshold);
  List<EvaluatedAxiom> learnedAxioms=new LinkedList<EvaluatedAxiom>();
  for (  EvaluatedDescription learnedDescription : learnedDescriptions) {
    Axiom axiom;
    if (equivalence) {
      axiom=new EquivalentClassesAxiom(nc,learnedDescription.getDescription());
    }
 else {
      axiom=new SubClassAxiom(nc,learnedDescription.getDescription());
    }
    Score score=lp.computeScore(learnedDescription.getDescription());
    learnedAxioms.add(new EvaluatedAxiom(axiom,score));
  }
  System.out.println(prettyPrint(learnedAxioms));
  algorithmRuns.add(new AlgorithmRun(CELOE.class,learnedAxioms,ConfigHelper.getConfigOptionValuesString(la)));
  return learnedAxioms;
}"
9617,"@SuppressWarnings(""String_Node_Str"") private void runClassLearningAlgorithms(SparqlEndpointKS ks,NamedClass nc) throws ComponentInitException {
  for (  Class<? extends LearningAlgorithm> algorithmClass : classAlgorithms) {
    if (algorithmClass == CELOE.class) {
      applyCELOE(ks,nc,false);
      applyCELOE(ks,nc,true);
    }
 else {
      applyLearningAlgorithm((Class<AxiomLearningAlgorithm>)algorithmClass,ks,nc);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private void runClassLearningAlgorithms(SparqlEndpointKS ks,NamedClass nc) throws ComponentInitException {
  for (  Class<? extends LearningAlgorithm> algorithmClass : classAlgorithms) {
    if (algorithmClass == CELOE.class) {
      applyCELOE(ks,nc,false,false);
      applyCELOE(ks,nc,true,true);
    }
 else {
      applyLearningAlgorithm((Class<AxiomLearningAlgorithm>)algorithmClass,ks,nc);
    }
  }
}"
9618,"@Override public void init() throws ComponentInitException {
  if (getReasoner().getReasonerType() == ReasonerType.DIG) {
    throw new ComponentInitException(""String_Node_Str"" + getName());
  }
  if (!logLevel.equals(CommonConfigOptions.logLevelDefault))   logger.setLevel(Level.toLevel(logLevel,Level.toLevel(CommonConfigOptions.logLevelDefault)));
  if (searchTreeFile == null)   searchTreeFile=new File(defaultSearchTreeFile);
  if (writeSearchTree)   Files.clearFile(searchTreeFile);
  if (heuristic == null) {
    if (heuristicStr == ""String_Node_Str"")     heuristic=new LexicographicHeuristic();
 else     if (heuristicStr == ""String_Node_Str"") {
      if (learningProblem instanceof PosOnlyLP) {
        throw new RuntimeException(""String_Node_Str"");
      }
      heuristic=new FlexibleHeuristic(((PosNegLP)getLearningProblem()).getNegativeExamples().size(),((PosNegLP)getLearningProblem()).getPercentPerLengthUnit());
    }
 else {
      if (getLearningProblem() instanceof PosOnlyLP) {
        throw new RuntimeException(""String_Node_Str"");
      }
 else {
        heuristic=new MultiHeuristic(((PosNegLP)getLearningProblem()).getPositiveExamples().size(),((PosNegLP)getLearningProblem()).getNegativeExamples().size(),negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
      }
    }
  }
  if (learningProblem instanceof PosNegLPStandard) {
    if (((PosNegLPStandard)learningProblem).isUseApproximations()) {
      System.err.println(""String_Node_Str"");
    }
    if (!((PosNegLPStandard)learningProblem).getAccuracyMethod().equals(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
    }
  }
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  if (allowedRoles != null) {
    Helper.checkRoles(reasoner,allowedRoles);
    usedRoles=allowedRoles;
  }
 else   if (ignoredRoles != null) {
    Helper.checkRoles(reasoner,ignoredRoles);
    usedRoles=Helper.difference(reasoner.getObjectProperties(),ignoredRoles);
  }
 else {
    usedRoles=reasoner.getObjectProperties();
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  if (improveSubsumptionHierarchy)   classHierarchy.thinOutSubsumptionHierarchy();
  if (operator == null) {
    operator=new RhoDRDown(reasoner,classHierarchy,applyAllFilter,applyExistsFilter,useAllConstructor,useExistsConstructor,useHasValueConstructor,valueFrequencyThreshold,useCardinalityRestrictions,useNegation,useBooleanDatatypes,useDoubleDatatypes,startClass,cardinalityLimit,useStringDatatypes,instanceBasedDisjoints);
  }
  algorithm=new ROLearner2(learningProblem,reasoner,operator,heuristic,startClass,noisePercentage / (double)100,writeSearchTree,replaceSearchTree,searchTreeFile,useTooWeakList,useOverlyGeneralList,useShortConceptConstruction,usePropernessChecks,maxPosOnlyExpansion,maxExecutionTimeInSeconds,minExecutionTimeInSeconds,guaranteeXgoodDescriptions,maxClassDescriptionTests,forceRefinementLengthIncrease,terminateOnNoiseReached,negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
}","@Override public void init() throws ComponentInitException {
  if (getReasoner().getReasonerType() == ReasonerType.DIG) {
    throw new ComponentInitException(""String_Node_Str"" + getName());
  }
  if (!logLevel.equals(CommonConfigOptions.logLevelDefault))   logger.setLevel(Level.toLevel(logLevel,Level.toLevel(CommonConfigOptions.logLevelDefault)));
  if (searchTreeFile == null)   searchTreeFile=new File(defaultSearchTreeFile);
  if (writeSearchTree)   Files.clearFile(searchTreeFile);
  if (heuristic == null) {
    if (heuristicStr == ""String_Node_Str"")     heuristic=new LexicographicHeuristic();
 else     if (heuristicStr == ""String_Node_Str"") {
      if (learningProblem instanceof PosOnlyLP) {
        throw new RuntimeException(""String_Node_Str"");
      }
      heuristic=new FlexibleHeuristic(((PosNegLP)getLearningProblem()).getNegativeExamples().size(),((PosNegLP)getLearningProblem()).getPercentPerLengthUnit());
    }
 else {
      if (getLearningProblem() instanceof PosOnlyLP) {
        throw new RuntimeException(""String_Node_Str"");
      }
 else {
        heuristic=new MultiHeuristic(((PosNegLP)getLearningProblem()).getPositiveExamples().size(),((PosNegLP)getLearningProblem()).getNegativeExamples().size(),negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
      }
    }
  }
  if (learningProblem instanceof PosNegLPStandard) {
    if (((PosNegLPStandard)learningProblem).isUseApproximations()) {
      System.err.println(""String_Node_Str"");
    }
    if (!((PosNegLPStandard)learningProblem).getAccuracyMethod().equals(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
    }
  }
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  if (allowedRoles != null) {
    Helper.checkRoles(reasoner,allowedRoles);
    usedRoles=allowedRoles;
  }
 else   if (ignoredRoles != null) {
    Helper.checkRoles(reasoner,ignoredRoles);
    usedRoles=Helper.difference(reasoner.getObjectProperties(),ignoredRoles);
  }
 else {
    usedRoles=reasoner.getObjectProperties();
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  if (improveSubsumptionHierarchy)   classHierarchy.thinOutSubsumptionHierarchy();
  if (operator == null) {
    operator=new RhoDRDown(reasoner,classHierarchy,applyAllFilter,applyExistsFilter,useAllConstructor,useExistsConstructor,useHasValueConstructor,valueFrequencyThreshold,useCardinalityRestrictions,useNegation,useBooleanDatatypes,useDoubleDatatypes,startClass,cardinalityLimit,useStringDatatypes,instanceBasedDisjoints);
  }
 else {
    operator.setSubHierarchy(classHierarchy);
  }
  algorithm=new ROLearner2(learningProblem,reasoner,operator,heuristic,startClass,noisePercentage / (double)100,writeSearchTree,replaceSearchTree,searchTreeFile,useTooWeakList,useOverlyGeneralList,useShortConceptConstruction,usePropernessChecks,maxPosOnlyExpansion,maxExecutionTimeInSeconds,minExecutionTimeInSeconds,guaranteeXgoodDescriptions,maxClassDescriptionTests,forceRefinementLengthIncrease,terminateOnNoiseReached,negativeWeight,startNodeBonus,expansionPenaltyFactor,negationPenalty);
}"
9619,"@Override public void init() throws ComponentInitException {
  Set<NamedClass> usedConcepts;
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  classHierarchy.thinOutSubsumptionHierarchy();
  heuristic=new OEHeuristicRuntime();
  minimizer=new DescriptionMinimizer(reasoner);
  startClass=Thing.instance;
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setStartClass(startClass);
    ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
  }
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  if (writeSearchTree) {
    File f=new File(searchTreeFile);
    Files.clearFile(f);
  }
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(maxNrOfResults);
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=noisePercentage / 100d;
  filterFollowsFromKB=filterDescriptionsFollowingFromKB && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (reuseExistingDescription && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}","@Override public void init() throws ComponentInitException {
  Set<NamedClass> usedConcepts;
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  classHierarchy.thinOutSubsumptionHierarchy();
  if (heuristic == null) {
    heuristic=new OEHeuristicRuntime();
  }
  minimizer=new DescriptionMinimizer(reasoner);
  startClass=Thing.instance;
  if (operator == null) {
    operator=new RhoDRDown();
    ((RhoDRDown)operator).setStartClass(startClass);
    ((RhoDRDown)operator).setSubHierarchy(classHierarchy);
  }
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  if (writeSearchTree) {
    File f=new File(searchTreeFile);
    Files.clearFile(f);
  }
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(maxNrOfResults);
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=noisePercentage / 100d;
  filterFollowsFromKB=filterDescriptionsFollowingFromKB && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (reuseExistingDescription && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}"
9620,"public final SortedSet<RDFNodeTuple> getTupelForResource(String uri){
  checkURIforValidity(uri);
  try {
    if (mode == NORMAL) {
      return retrieveTupel(uri);
    }
 else     if (mode == CLASSES_FOR_INSTANCES) {
      return retrieveClassesForInstances(uri);
    }
 else     if (mode == CLASS_INFORMATION) {
      return retrieveTuplesForClassesOnly(uri);
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + e.toString());
    return new TreeSet<RDFNodeTuple>();
  }
}","public final SortedSet<RDFNodeTuple> getTupelForResource(String uri){
  checkURIforValidity(uri);
  try {
    if (mode == NORMAL) {
      return retrieveTupel(uri);
    }
 else     if (mode == CLASSES_FOR_INSTANCES) {
      return retrieveClassesForInstances(uri);
    }
 else     if (mode == CLASS_INFORMATION) {
      return retrieveTuplesForClassesOnly(uri);
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + e.toString());
    e.printStackTrace();
    return new TreeSet<RDFNodeTuple>();
  }
}"
9621,"private boolean jj_3_2(){
  if (jj_3R_6())   return true;
  if (jj_scan_token(28))   return true;
  return false;
}","private boolean jj_3_2(){
  if (jj_3R_6())   return true;
  if (jj_scan_token(16))   return true;
  return false;
}"
9622,"private boolean jj_3_1(){
  if (jj_3R_5())   return true;
  if (jj_scan_token(28))   return true;
  return false;
}","private boolean jj_3_1(){
  if (jj_3R_5())   return true;
  if (jj_scan_token(16))   return true;
  return false;
}"
9623,"final public ConfFileOption2 ConfOption() throws ParseException {
  boolean containsSubOption=false;
  String value=""String_Node_Str"", value1=""String_Node_Str"", value2=""String_Node_Str"", tmp=""String_Node_Str"", tmp2=""String_Node_Str"";
  Set<String> values=new HashSet<String>();
  List<StringTuple> tuples=new LinkedList<StringTuple>();
  ConfFileOption2 option=new ConfFileOption2();
  boolean inQuotes=false;
  String beanName;
  String propertyName=""String_Node_Str"";
  String propertyValue;
  Class<?> propertyType;
  Object val=null;
  beanName=Id();
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case COMMAND_END:
    jj_consume_token(COMMAND_END);
  propertyName=Id();
containsSubOption=true;
break;
default :
jj_la1[1]=jj_gen;
;
}
jj_consume_token(25);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case ID:
propertyValue=Id();
val=propertyValue;
propertyType=String.class;
break;
case STRING:
propertyValue=String();
val=propertyValue;
inQuotes=true;
propertyType=String.class;
break;
case NUMBER:
val=Integer();
propertyValue=val.toString();
propertyType=Integer.class;
break;
case DOUBLE:
val=Double();
propertyValue=val.toString();
propertyType=Double.class;
break;
default :
jj_la1[6]=jj_gen;
if (jj_2_4(2147483647)) {
jj_consume_token(26);
jj_consume_token(27);
val=new HashSet();
propertyType=Set.class;
propertyValue=""String_Node_Str"";
}
 else if (jj_2_5(4)) {
jj_consume_token(26);
label_2: while (true) {
if (jj_2_1(2)) {
;
}
 else {
break label_2;
}
tmp=String();
values.add(tmp);
jj_consume_token(28);
}
tmp=String();
values.add(tmp);
jj_consume_token(27);
propertyType=Set.class;
propertyValue=""String_Node_Str"";
}
 else {
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case 26:
jj_consume_token(26);
label_3: while (true) {
if (jj_2_2(4)) {
;
}
 else {
break label_3;
}
tmp=Id();
values.add(tmp);
jj_consume_token(28);
}
tmp=Id();
values.add(tmp);
jj_consume_token(27);
val=values;
propertyType=Set.class;
propertyValue=""String_Node_Str"";
break;
default :
jj_la1[7]=jj_gen;
if (jj_2_6(2147483647)) {
jj_consume_token(29);
jj_consume_token(30);
val=new LinkedList();
propertyType=List.class;
propertyValue=""String_Node_Str"";
}
 else {
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case 29:
jj_consume_token(29);
label_4: while (true) {
if (jj_2_3(6)) {
;
}
 else {
break label_4;
}
jj_consume_token(31);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case STRING:
tmp=String();
break;
case ID:
tmp=Id();
break;
default :
jj_la1[2]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
jj_consume_token(28);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case STRING:
tmp2=String();
break;
case ID:
tmp2=Id();
break;
default :
jj_la1[3]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
jj_consume_token(32);
tuples.add(new StringTuple(tmp,tmp2));
jj_consume_token(28);
}
jj_consume_token(31);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case STRING:
tmp=String();
break;
case ID:
tmp=Id();
break;
default :
jj_la1[4]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
jj_consume_token(28);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case STRING:
tmp2=String();
break;
case ID:
tmp2=Id();
break;
default :
jj_la1[5]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
jj_consume_token(32);
tuples.add(new StringTuple(tmp,tmp2));
jj_consume_token(30);
val=values;
propertyType=List.class;
break;
default :
jj_la1[8]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
}
}
}
}
if (containsSubOption) {
option.setInQuotes(inQuotes);
option.setBeanName(beanName);
option.setPropertyName(propertyName);
option.setPropertyType(propertyType);
option.setValueObject(val);
}
 else {
}
{
if (true) return option;
}
throw new Error(""String_Node_Str"");
}","final public ConfFileOption2 ConfOption() throws ParseException {
  boolean containsSubOption=false;
  String value=""String_Node_Str"", value1=""String_Node_Str"", value2=""String_Node_Str"", tmp=""String_Node_Str"", tmp2=""String_Node_Str"";
  Set<String> values=new HashSet<String>();
  List<StringTuple> tuples=new LinkedList<StringTuple>();
  ConfFileOption2 option=new ConfFileOption2();
  boolean inQuotes=false;
  String beanName;
  String propertyName=""String_Node_Str"";
  String propertyValue;
  Class<?> propertyType;
  Object val=null;
  beanName=Id();
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case COMMAND_END:
    jj_consume_token(COMMAND_END);
  propertyName=Id();
containsSubOption=true;
break;
default :
jj_la1[1]=jj_gen;
;
}
jj_consume_token(13);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case ID:
propertyValue=Id();
if (propertyValue.equals(""String_Node_Str"") || propertyValue.equals(""String_Node_Str"")) {
val=Boolean.valueOf(propertyValue);
propertyType=Boolean.class;
}
 else {
val=propertyValue;
propertyType=String.class;
}
break;
case STRING:
propertyValue=String();
val=propertyValue;
inQuotes=true;
propertyType=String.class;
break;
case NUMBER:
val=Integer();
propertyValue=val.toString();
propertyType=Integer.class;
break;
case DOUBLE:
val=Double();
propertyValue=val.toString();
propertyType=Double.class;
break;
default :
jj_la1[6]=jj_gen;
if (jj_2_4(2147483647)) {
jj_consume_token(14);
jj_consume_token(15);
val=new HashSet();
propertyType=Set.class;
propertyValue=""String_Node_Str"";
}
 else if (jj_2_5(4)) {
jj_consume_token(14);
label_2: while (true) {
if (jj_2_1(2)) {
;
}
 else {
break label_2;
}
tmp=String();
values.add(tmp);
jj_consume_token(16);
}
tmp=String();
values.add(tmp);
jj_consume_token(15);
propertyType=Set.class;
propertyValue=""String_Node_Str"";
val=values;
inQuotes=true;
}
 else {
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case 14:
jj_consume_token(14);
label_3: while (true) {
if (jj_2_2(4)) {
;
}
 else {
break label_3;
}
tmp=Id();
values.add(tmp);
jj_consume_token(16);
}
tmp=Id();
values.add(tmp);
jj_consume_token(15);
val=values;
propertyType=Set.class;
propertyValue=""String_Node_Str"";
break;
default :
jj_la1[7]=jj_gen;
if (jj_2_6(2147483647)) {
jj_consume_token(17);
jj_consume_token(18);
val=new LinkedList();
propertyType=List.class;
propertyValue=""String_Node_Str"";
}
 else {
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case 17:
jj_consume_token(17);
label_4: while (true) {
if (jj_2_3(6)) {
;
}
 else {
break label_4;
}
jj_consume_token(19);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case STRING:
tmp=String();
break;
case ID:
tmp=Id();
break;
default :
jj_la1[2]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
jj_consume_token(16);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case STRING:
tmp2=String();
break;
case ID:
tmp2=Id();
break;
default :
jj_la1[3]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
jj_consume_token(20);
tuples.add(new StringTuple(tmp,tmp2));
jj_consume_token(16);
}
jj_consume_token(19);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case STRING:
tmp=String();
break;
case ID:
tmp=Id();
break;
default :
jj_la1[4]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
jj_consume_token(16);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case STRING:
tmp2=String();
break;
case ID:
tmp2=Id();
break;
default :
jj_la1[5]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
jj_consume_token(20);
tuples.add(new StringTuple(tmp,tmp2));
jj_consume_token(18);
val=values;
propertyType=List.class;
break;
default :
jj_la1[8]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
}
}
}
}
if (containsSubOption) {
option.setInQuotes(inQuotes);
option.setBeanName(beanName);
option.setPropertyName(propertyName);
option.setPropertyType(propertyType);
option.setValueObject(val);
}
 else {
}
{
if (true) return option;
}
throw new Error(""String_Node_Str"");
}"
9624,"private boolean jj_3_6(){
  if (jj_scan_token(29))   return true;
  if (jj_scan_token(30))   return true;
  return false;
}","private boolean jj_3_6(){
  if (jj_scan_token(17))   return true;
  if (jj_scan_token(18))   return true;
  return false;
}"
9625,"private boolean jj_3_5(){
  if (jj_scan_token(26))   return true;
  Token xsp;
  while (true) {
    xsp=jj_scanpos;
    if (jj_3_1()) {
      jj_scanpos=xsp;
      break;
    }
  }
  if (jj_3R_5())   return true;
  if (jj_scan_token(27))   return true;
  return false;
}","private boolean jj_3_5(){
  if (jj_scan_token(14))   return true;
  Token xsp;
  while (true) {
    xsp=jj_scanpos;
    if (jj_3_1()) {
      jj_scanpos=xsp;
      break;
    }
  }
  if (jj_3R_5())   return true;
  if (jj_scan_token(15))   return true;
  return false;
}"
9626,"private boolean jj_3_4(){
  if (jj_scan_token(26))   return true;
  if (jj_scan_token(27))   return true;
  return false;
}","private boolean jj_3_4(){
  if (jj_scan_token(14))   return true;
  if (jj_scan_token(15))   return true;
  return false;
}"
9627,"private boolean jj_3_3(){
  if (jj_scan_token(31))   return true;
  Token xsp;
  xsp=jj_scanpos;
  if (jj_3R_7()) {
    jj_scanpos=xsp;
    if (jj_3R_8())     return true;
  }
  if (jj_scan_token(28))   return true;
  xsp=jj_scanpos;
  if (jj_3R_9()) {
    jj_scanpos=xsp;
    if (jj_3R_10())     return true;
  }
  if (jj_scan_token(32))   return true;
  if (jj_scan_token(28))   return true;
  return false;
}","private boolean jj_3_3(){
  if (jj_scan_token(19))   return true;
  Token xsp;
  xsp=jj_scanpos;
  if (jj_3R_7()) {
    jj_scanpos=xsp;
    if (jj_3R_8())     return true;
  }
  if (jj_scan_token(16))   return true;
  xsp=jj_scanpos;
  if (jj_3R_9()) {
    jj_scanpos=xsp;
    if (jj_3R_10())     return true;
  }
  if (jj_scan_token(20))   return true;
  if (jj_scan_token(16))   return true;
  return false;
}"
9628,"private boolean jj_3_7(){
  if (jj_scan_token(ID))   return true;
  if (jj_scan_token(33))   return true;
  return false;
}","private boolean jj_3_7(){
  if (jj_scan_token(ID))   return true;
  if (jj_scan_token(21))   return true;
  return false;
}"
9629,"final public String ComplexId() throws ParseException {
  Token t1, t2;
  if (jj_2_7(2)) {
    t1=jj_consume_token(ID);
    jj_consume_token(33);
    t2=jj_consume_token(ID);
{
      if (true)       return t1.image + ""String_Node_Str"" + t2.image;
    }
  }
 else {
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case ID:
      t1=jj_consume_token(ID);
{
      if (true)       return t1.image;
    }
  break;
default :
jj_la1[10]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
}
throw new Error(""String_Node_Str"");
}","final public String ComplexId() throws ParseException {
  Token t1, t2;
  if (jj_2_7(2)) {
    t1=jj_consume_token(ID);
    jj_consume_token(21);
    t2=jj_consume_token(ID);
{
      if (true)       return t1.image + ""String_Node_Str"" + t2.image;
    }
  }
 else {
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case ID:
      t1=jj_consume_token(ID);
{
      if (true)       return t1.image;
    }
  break;
default :
jj_la1[10]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
}
throw new Error(""String_Node_Str"");
}"
9630,"/** 
 * Generate ParseException. 
 */
public ParseException generateParseException(){
  jj_expentries.clear();
  boolean[] la1tokens=new boolean[34];
  if (jj_kind >= 0) {
    la1tokens[jj_kind]=true;
    jj_kind=-1;
  }
  for (int i=0; i < 11; i++) {
    if (jj_la1[i] == jj_gen) {
      for (int j=0; j < 32; j++) {
        if ((jj_la1_0[i] & (1 << j)) != 0) {
          la1tokens[j]=true;
        }
        if ((jj_la1_1[i] & (1 << j)) != 0) {
          la1tokens[32 + j]=true;
        }
      }
    }
  }
  for (int i=0; i < 34; i++) {
    if (la1tokens[i]) {
      jj_expentry=new int[1];
      jj_expentry[0]=i;
      jj_expentries.add(jj_expentry);
    }
  }
  jj_endpos=0;
  jj_rescan_token();
  jj_add_error_token(0,0);
  int[][] exptokseq=new int[jj_expentries.size()][];
  for (int i=0; i < jj_expentries.size(); i++) {
    exptokseq[i]=jj_expentries.get(i);
  }
  return new ParseException(token,exptokseq,tokenImage);
}","/** 
 * Generate ParseException. 
 */
public ParseException generateParseException(){
  jj_expentries.clear();
  boolean[] la1tokens=new boolean[22];
  if (jj_kind >= 0) {
    la1tokens[jj_kind]=true;
    jj_kind=-1;
  }
  for (int i=0; i < 11; i++) {
    if (jj_la1[i] == jj_gen) {
      for (int j=0; j < 32; j++) {
        if ((jj_la1_0[i] & (1 << j)) != 0) {
          la1tokens[j]=true;
        }
      }
    }
  }
  for (int i=0; i < 22; i++) {
    if (la1tokens[i]) {
      jj_expentry=new int[1];
      jj_expentry[0]=i;
      jj_expentries.add(jj_expentry);
    }
  }
  jj_endpos=0;
  jj_rescan_token();
  jj_add_error_token(0,0);
  int[][] exptokseq=new int[jj_expentries.size()][];
  for (int i=0; i < jj_expentries.size(); i++) {
    exptokseq[i]=jj_expentries.get(i);
  }
  return new ParseException(token,exptokseq,tokenImage);
}"
9631,"private static void jj_la1_init_0(){
  jj_la1_0=new int[]{0x1000,0x100,0x1001000,0x1001000,0x1001000,0x1001000,0x1007000,0x4000000,0x20000000,0x1001000,0x1000};
}","private static void jj_la1_init_0(){
  jj_la1_0=new int[]{0x200,0x100,0x1200,0x1200,0x1200,0x1200,0x1e00,0x4000,0x20000,0x1200,0x200};
}"
9632,"/** 
 * Initialise all components based on conf file.
 * @param file Conf file to read.
 * @throws ComponentInitException
 * @throws ParseException 
 * @throws FileNotFoundException 
 * @throws  
	 * @throws IOException 
 */
public Start(File file) throws ComponentInitException, ParseException, FileNotFoundException {
  String baseDir=file.getAbsoluteFile().getParent();
  String message=""String_Node_Str"";
  long cmStartTime=System.nanoTime();
  ComponentManager cm=ComponentManager.getInstance();
  long cmTime=System.nanoTime() - cmStartTime;
  message+=""String_Node_Str"" + Helper.prettyPrintNanoSeconds(cmTime) + ""String_Node_Str"";
  logger.info(message);
  ConfParser parser=ConfParser.parseFile(file);
  Monitor ksMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  sources=new HashSet<AbstractKnowledgeSource>();
  Map<URL,Class<? extends AbstractKnowledgeSource>> importedFiles=getImportedFiles(parser,baseDir);
  for (  Map.Entry<URL,Class<? extends AbstractKnowledgeSource>> entry : importedFiles.entrySet()) {
    AbstractKnowledgeSource ks=cm.knowledgeSource(entry.getValue());
    cm.applyConfigEntry(ks,""String_Node_Str"",entry.getKey());
    sources.add(ks);
    configureComponent(cm,ks,parser);
    initComponent(cm,ks);
  }
  ksMonitor.stop();
  Monitor rsMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  ConfFileOption reasonerOption=parser.getConfOptionsByName(""String_Node_Str"");
  Class<? extends AbstractReasonerComponent> rcClass;
  if (reasonerOption != null) {
    rcClass=confMapper.getReasonerComponentClass(reasonerOption.getStringValue());
    if (rcClass == null) {
      handleError(""String_Node_Str"" + reasonerOption.getStringValue() + ""String_Node_Str""+ reasonerOption+ ""String_Node_Str""+ confMapper.getReasoners()+ ""String_Node_Str"");
    }
  }
 else {
    rcClass=FastInstanceChecker.class;
  }
  rc=cm.reasoner(rcClass,sources);
  configureComponent(cm,rc,parser);
  initComponent(cm,rc);
  rsMonitor.stop();
  Monitor lpMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  ConfFileOption problemOption=parser.getConfOptionsByName(""String_Node_Str"");
  Class<? extends AbstractLearningProblem> lpClass;
  if (problemOption != null) {
    lpClass=confMapper.getLearningProblemClass(problemOption.getStringValue());
    if (lpClass == null) {
      handleError(""String_Node_Str"" + problemOption.getStringValue() + ""String_Node_Str""+ problemOption+ ""String_Node_Str""+ confMapper.getLearningProblems()+ ""String_Node_Str"");
    }
  }
 else {
    lpClass=PosNegLPStandard.class;
  }
  lp=cm.learningProblem(lpClass,rc);
  if (lpClass == PosNegLPStandard.class || lpClass == PosOnlyLP.class || lpClass == FuzzyPosNegLPStandard.class) {
    SortedSet<String> posExamples=parser.getPositiveExamples();
    cm.applyConfigEntry(lp,""String_Node_Str"",posExamples);
  }
  if (lpClass == PosNegLPStandard.class || lpClass == FuzzyPosNegLPStandard.class) {
    SortedSet<String> negExamples=parser.getNegativeExamples();
    cm.applyConfigEntry(lp,""String_Node_Str"",negExamples);
  }
  configureComponent(cm,lp,parser);
  initComponent(cm,lp);
  lpMonitor.stop();
  Monitor laMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  ConfFileOption algorithmOption=parser.getConfOptionsByName(""String_Node_Str"");
  Class<? extends AbstractCELA> laClass;
  if (algorithmOption != null) {
    laClass=confMapper.getLearningAlgorithmClass(algorithmOption.getStringValue());
    if (laClass == null) {
      handleError(""String_Node_Str"" + algorithmOption.getStringValue() + ""String_Node_Str""+ algorithmOption+ ""String_Node_Str""+ confMapper.getLearningAlgorithms()+ ""String_Node_Str"");
    }
  }
 else {
    laClass=OCEL.class;
  }
  try {
    la=cm.learningAlgorithm(laClass,lp,rc);
  }
 catch (  LearningProblemUnsupportedException e) {
    e.printStackTrace();
  }
  configureComponent(cm,la,parser);
  initComponent(cm,la);
  laMonitor.stop();
  performExports(parser,baseDir,sources,rc);
  processCLIOptions(cm,parser,rc,lp);
  if (logger.isInfoEnabled()) {
    System.out.println(""String_Node_Str"");
  }
}","/** 
 * Initialise all components based on conf file.
 * @param file Conf file to read.
 * @throws ComponentInitException
 * @throws ParseException 
 * @throws FileNotFoundException 
 * @throws  
	 * @throws IOException 
 */
public Start(File file) throws ComponentInitException, ParseException, FileNotFoundException {
  String baseDir=file.getAbsoluteFile().getParent();
  String message=""String_Node_Str"";
  long cmStartTime=System.nanoTime();
  ComponentManager cm=ComponentManager.getInstance();
  long cmTime=System.nanoTime() - cmStartTime;
  message+=""String_Node_Str"" + Helper.prettyPrintNanoSeconds(cmTime) + ""String_Node_Str"";
  logger.info(message);
  ConfParser parser=ConfParser.parseFile(file);
  Monitor ksMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  sources=new HashSet<AbstractKnowledgeSource>();
  Map<URL,Class<? extends AbstractKnowledgeSource>> importedFiles=getImportedFiles(parser,baseDir);
  for (  Map.Entry<URL,Class<? extends AbstractKnowledgeSource>> entry : importedFiles.entrySet()) {
    AbstractKnowledgeSource ks=cm.knowledgeSource(entry.getValue());
    cm.applyConfigEntry(ks,""String_Node_Str"",entry.getKey());
    if (ks instanceof OWLFile) {
      ((OWLFile)ks).setURL(entry.getKey());
    }
    sources.add(ks);
    configureComponent(cm,ks,parser);
    initComponent(cm,ks);
  }
  ksMonitor.stop();
  Monitor rsMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  ConfFileOption reasonerOption=parser.getConfOptionsByName(""String_Node_Str"");
  Class<? extends AbstractReasonerComponent> rcClass;
  if (reasonerOption != null) {
    rcClass=confMapper.getReasonerComponentClass(reasonerOption.getStringValue());
    if (rcClass == null) {
      handleError(""String_Node_Str"" + reasonerOption.getStringValue() + ""String_Node_Str""+ reasonerOption+ ""String_Node_Str""+ confMapper.getReasoners()+ ""String_Node_Str"");
    }
  }
 else {
    rcClass=FastInstanceChecker.class;
  }
  rc=cm.reasoner(rcClass,sources);
  configureComponent(cm,rc,parser);
  initComponent(cm,rc);
  rsMonitor.stop();
  Monitor lpMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  ConfFileOption problemOption=parser.getConfOptionsByName(""String_Node_Str"");
  Class<? extends AbstractLearningProblem> lpClass;
  if (problemOption != null) {
    lpClass=confMapper.getLearningProblemClass(problemOption.getStringValue());
    if (lpClass == null) {
      handleError(""String_Node_Str"" + problemOption.getStringValue() + ""String_Node_Str""+ problemOption+ ""String_Node_Str""+ confMapper.getLearningProblems()+ ""String_Node_Str"");
    }
  }
 else {
    lpClass=PosNegLPStandard.class;
  }
  lp=cm.learningProblem(lpClass,rc);
  if (lpClass == PosNegLPStandard.class || lpClass == PosOnlyLP.class || lpClass == FuzzyPosNegLPStandard.class) {
    SortedSet<String> posExamples=parser.getPositiveExamples();
    cm.applyConfigEntry(lp,""String_Node_Str"",posExamples);
  }
  if (lpClass == PosNegLPStandard.class || lpClass == FuzzyPosNegLPStandard.class) {
    SortedSet<String> negExamples=parser.getNegativeExamples();
    cm.applyConfigEntry(lp,""String_Node_Str"",negExamples);
  }
  configureComponent(cm,lp,parser);
  initComponent(cm,lp);
  lpMonitor.stop();
  Monitor laMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  ConfFileOption algorithmOption=parser.getConfOptionsByName(""String_Node_Str"");
  Class<? extends AbstractCELA> laClass;
  if (algorithmOption != null) {
    laClass=confMapper.getLearningAlgorithmClass(algorithmOption.getStringValue());
    if (laClass == null) {
      handleError(""String_Node_Str"" + algorithmOption.getStringValue() + ""String_Node_Str""+ algorithmOption+ ""String_Node_Str""+ confMapper.getLearningAlgorithms()+ ""String_Node_Str"");
    }
  }
 else {
    laClass=OCEL.class;
  }
  try {
    la=cm.learningAlgorithm(laClass,lp,rc);
  }
 catch (  LearningProblemUnsupportedException e) {
    e.printStackTrace();
  }
  configureComponent(cm,la,parser);
  initComponent(cm,la);
  laMonitor.stop();
  performExports(parser,baseDir,sources,rc);
  processCLIOptions(cm,parser,rc,lp);
  if (logger.isInfoEnabled()) {
    System.out.println(""String_Node_Str"");
  }
}"
9633,"public static void main(String[] args) throws Exception {
  DisjointClassesLearner l=new DisjointClassesLearner(new SparqlEndpointKS(SparqlEndpoint.getEndpointDBpedia()));
  l.setClassToDescribe(new NamedClass(""String_Node_Str""));
  l.init();
  l.start();
  for (  EvaluatedDescription e : l.getCurrentlyBestEvaluatedDescriptions(300)) {
    System.out.println(e);
  }
}","public static void main(String[] args) throws Exception {
  DisjointClassesLearner l=new DisjointClassesLearner(new SparqlEndpointKS(SparqlEndpoint.getEndpointDBpedia()));
  l.setClassToDescribe(new NamedClass(""String_Node_Str""));
  l.init();
  l.start();
  for (  EvaluatedAxiom e : l.getCurrentlyBestEvaluatedAxioms(50)) {
    System.out.println(e);
  }
}"
9634,"@Override public List<Axiom> getCurrentlyBestAxioms(int nrOfAxioms){
  List<Axiom> bestAxioms=new ArrayList<Axiom>();
  Iterator<EvaluatedAxiom> it=currentlyBestAxioms.iterator();
  while (bestAxioms.size() < nrOfAxioms && it.hasNext()) {
    bestAxioms.add(it.next().getAxiom());
  }
  return bestAxioms;
}","@Override public List<Axiom> getCurrentlyBestAxioms(int nrOfAxioms){
  List<Axiom> bestAxioms=new ArrayList<Axiom>();
  for (  EvaluatedAxiom evAx : getCurrentlyBestEvaluatedAxioms(nrOfAxioms)) {
    bestAxioms.add(evAx.getAxiom());
  }
  return bestAxioms;
}"
9635,"public String toKBSyntaxString(String baseURI,Map<String,String> prefixes){
  throw new Error(""String_Node_Str"");
}","public String toKBSyntaxString(String baseURI,Map<String,String> prefixes){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  Iterator<Description> it=descriptions.iterator();
  while (it.hasNext()) {
    sb.append(it.next().toKBSyntaxString());
    if (it.hasNext()) {
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
9636,"@Override public String toManchesterSyntaxString(String baseURI,Map<String,String> prefixes){
  return ""String_Node_Str"";
}","@Override public String toManchesterSyntaxString(String baseURI,Map<String,String> prefixes){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  Iterator<Description> it=descriptions.iterator();
  while (it.hasNext()) {
    sb.append(it.next().toManchesterSyntaxString(baseURI,prefixes));
    if (it.hasNext()) {
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
9637,"public String toString(String baseURI,Map<String,String> prefixes){
  return ""String_Node_Str"";
}","public String toString(String baseURI,Map<String,String> prefixes){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  Iterator<Description> it=descriptions.iterator();
  while (it.hasNext()) {
    sb.append(it.next().toString());
    if (it.hasNext()) {
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
9638,"private Model getModel(List<OWLAxiom> axioms){
  Model model=ModelFactory.createDefaultModel();
  try {
    Conversion.OWLAPIOntology2JenaModel(OWLManager.createOWLOntologyManager().createOntology(new HashSet<OWLAxiom>(axioms)),model);
  }
 catch (  OWLOntologyCreationException e) {
    e.printStackTrace();
  }
  return model;
}","private Model getModel(List<OWLAxiom> axioms){
  Model model=ModelFactory.createDefaultModel();
  try {
    OWLOntology ontology=OWLManager.createOWLOntologyManager().createOntology(new HashSet<OWLAxiom>(axioms));
    String s=new org.aksw.commons.owlapi.StringConverter(ontology).toStringAsTurtle();
    System.out.println(s);
    ByteArrayInputStream bs=new ByteArrayInputStream(s.getBytes());
    model.read(bs,""String_Node_Str"",""String_Node_Str"");
  }
 catch (  OWLOntologyCreationException e) {
    e.printStackTrace();
  }
  return model;
}"
9639,"public static void main(String[] args) throws IOException, ComponentInitException, IllegalArgumentException, SecurityException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, LearningProblemUnsupportedException {
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  Logger.getRootLogger().setLevel(Level.WARN);
  Logger.getLogger(""String_Node_Str"").setLevel(Level.WARN);
  Logger.getRootLogger().removeAllAppenders();
  Logger.getRootLogger().addAppender(consoleAppender);
  OptionParser parser=new OptionParser();
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(false);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(URL.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(URI.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(URI.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(File.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(String.class).defaultsTo(""String_Node_Str"");
  OptionSet options=null;
  try {
    options=parser.parse(args);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
    System.exit(0);
  }
  if (options.has(""String_Node_Str"")) {
    parser.printHelpOn(System.out);
    String addHelp=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    System.out.println();
    System.out.println(addHelp);
  }
 else {
    URL endpoint=(URL)options.valueOf(""String_Node_Str"");
    URI graph=(URI)options.valueOf(""String_Node_Str"");
    LinkedList<String> defaultGraphURIs=new LinkedList<String>();
    if (graph != null) {
      defaultGraphURIs.add(graph.toString());
    }
    SparqlEndpoint se=new SparqlEndpoint(endpoint,defaultGraphURIs,new LinkedList<String>());
    Entity resource=null;
    if (options.valueOf(""String_Node_Str"") != null) {
      resource=new SPARQLTasks(se).guessResourceType(((URI)options.valueOf(""String_Node_Str"")).toString());
      if (resource == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + options.valueOf(""String_Node_Str""));
      }
    }
    if (!options.hasArgument(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
    }
    boolean verbose=(Boolean)options.valueOf(""String_Node_Str"");
    Enrichment e=new Enrichment(se,resource,verbose);
    e.start();
    SparqlEndpointKS ks=new SparqlEndpointKS(se);
    File f=(File)options.valueOf(""String_Node_Str"");
    if (options.has(""String_Node_Str"")) {
      if (options.valueOf(""String_Node_Str"").equals(""String_Node_Str"")) {
        List<AlgorithmRun> runs=e.getAlgorithmRuns();
        List<OWLAxiom> axioms=new LinkedList<OWLAxiom>();
        for (        AlgorithmRun run : runs) {
          axioms.addAll(e.toRDF(run.getAxioms(),run.getAlgorithm(),run.getParameters(),ks));
        }
        Model model=e.getModel(axioms);
        if (options.has(""String_Node_Str"")) {
          model.write(new FileOutputStream(f));
        }
 else {
          System.out.println(""String_Node_Str"");
          model.write(System.out);
          System.out.println(""String_Node_Str"");
        }
      }
    }
  }
}","public static void main(String[] args) throws IOException, ComponentInitException, IllegalArgumentException, SecurityException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, LearningProblemUnsupportedException {
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  Logger.getRootLogger().setLevel(Level.WARN);
  Logger.getLogger(""String_Node_Str"").setLevel(Level.WARN);
  Logger.getRootLogger().removeAllAppenders();
  Logger.getRootLogger().addAppender(consoleAppender);
  OptionParser parser=new OptionParser();
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(false);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(URL.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(URI.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(URI.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(File.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withOptionalArg().ofType(String.class).defaultsTo(""String_Node_Str"");
  OptionSet options=null;
  try {
    options=parser.parse(args);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
    System.exit(0);
  }
  if (options.has(""String_Node_Str"")) {
    parser.printHelpOn(System.out);
    String addHelp=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    System.out.println();
    System.out.println(addHelp);
  }
 else {
    URL endpoint=(URL)options.valueOf(""String_Node_Str"");
    URI graph=(URI)options.valueOf(""String_Node_Str"");
    LinkedList<String> defaultGraphURIs=new LinkedList<String>();
    if (graph != null) {
      defaultGraphURIs.add(graph.toString());
    }
    SparqlEndpoint se=new SparqlEndpoint(endpoint,defaultGraphURIs,new LinkedList<String>());
    Entity resource=null;
    if (options.valueOf(""String_Node_Str"") != null) {
      resource=new SPARQLTasks(se).guessResourceType(((URI)options.valueOf(""String_Node_Str"")).toString());
      if (resource == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + options.valueOf(""String_Node_Str""));
      }
    }
    if (!options.hasArgument(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
    }
    boolean verbose=(Boolean)options.valueOf(""String_Node_Str"");
    Enrichment e=new Enrichment(se,resource,verbose);
    e.start();
    SparqlEndpointKS ks=new SparqlEndpointKS(se);
    File f=(File)options.valueOf(""String_Node_Str"");
    if (options.has(""String_Node_Str"")) {
      if (options.valueOf(""String_Node_Str"").equals(""String_Node_Str"")) {
        List<AlgorithmRun> runs=e.getAlgorithmRuns();
        List<OWLAxiom> axioms=new LinkedList<OWLAxiom>();
        for (        AlgorithmRun run : runs) {
          axioms.addAll(e.toRDF(run.getAxioms(),run.getAlgorithm(),run.getParameters(),ks));
        }
        Model model=e.getModel(axioms);
        for (        Statement st : model.listStatements().toList()) {
          System.out.println(""String_Node_Str"");
          if (st.getSubject().isResource()) {
            System.out.println(st.getSubject());
          }
          System.out.println(st.getPredicate());
          if (st.getObject().isResource()) {
          }
          System.out.println(st.getObject());
        }
        if (options.has(""String_Node_Str"")) {
          model.write(new FileOutputStream(f));
        }
 else {
          System.out.println(""String_Node_Str"");
          model.write(System.out);
          System.out.println(""String_Node_Str"");
        }
      }
    }
  }
}"
9640,"private List<OWLAxiom> toRDF(List<EvaluatedAxiom> evalAxioms,Class<? extends LearningAlgorithm> algorithm,Map<ConfigOption,String> parameters,SparqlEndpointKS ks,String defaultNamespace){
  if (defaultNamespace == null || defaultNamespace.isEmpty()) {
    defaultNamespace=DEFAULT_NS;
  }
  List<OWLAxiom> axioms=new ArrayList<OWLAxiom>();
  OWLDataFactory f=new OWLDataFactoryImpl();
  String suggestionSetID=defaultNamespace + generateId();
  OWLIndividual ind=f.getOWLNamedIndividual(IRI.create(suggestionSetID));
  OWLAxiom ax=f.getOWLClassAssertionAxiom(EnrichmentVocabulary.SuggestionSet,ind);
  axioms.add(ax);
  String algorithmRunID=defaultNamespace + generateId();
  OWLIndividual algorithmRunInd=f.getOWLNamedIndividual(IRI.create(algorithmRunID));
  ax=f.getOWLClassAssertionAxiom(EnrichmentVocabulary.AlgorithmRun,algorithmRunInd);
  axioms.add(ax);
  String algorithmName=algorithm.getAnnotation(ComponentAnn.class).name();
  String algorithmID=""String_Node_Str"" + algorithmName.replace(""String_Node_Str"",""String_Node_Str"");
  OWLIndividual algorithmInd=f.getOWLNamedIndividual(IRI.create(algorithmID));
  OWLAnnotation labelAnno=f.getOWLAnnotation(f.getOWLAnnotationProperty(OWLRDFVocabulary.RDFS_LABEL.getIRI()),f.getOWLLiteral(algorithmName));
  ax=f.getOWLAnnotationAssertionAxiom(algorithmInd.asOWLNamedIndividual().getIRI(),labelAnno);
  axioms.add(ax);
  ax=f.getOWLDataPropertyAssertionAxiom(EnrichmentVocabulary.version,algorithmInd,algorithm.getAnnotation(ComponentAnn.class).version());
  axioms.add(ax);
  ax=f.getOWLObjectPropertyAssertionAxiom(EnrichmentVocabulary.usedAlgorithm,algorithmRunInd,algorithmInd);
  axioms.add(ax);
  try {
    OWLNamedIndividual knowldegeBaseInd=f.getOWLNamedIndividual(IRI.create(ks.getEndpoint().getURL()));
    ax=f.getOWLClassAssertionAxiom(EnrichmentVocabulary.SPARQLEndpoint,knowldegeBaseInd);
    axioms.add(ax);
    ax=f.getOWLObjectPropertyAssertionAxiom(EnrichmentVocabulary.defaultGraph,knowldegeBaseInd,f.getOWLNamedIndividual(IRI.create(ks.getEndpoint().getDefaultGraphURIs().iterator().next())));
    axioms.add(ax);
    ax=f.getOWLObjectPropertyAssertionAxiom(EnrichmentVocabulary.hasInput,algorithmRunInd,knowldegeBaseInd);
    axioms.add(ax);
  }
 catch (  URISyntaxException e1) {
    e1.printStackTrace();
  }
  ax=f.getOWLObjectPropertyAssertionAxiom(EnrichmentVocabulary.creator,ind,algorithmRunInd);
  axioms.add(ax);
  Entry<OWLIndividual,List<OWLAxiom>> ind2Axioms;
  for (  EvaluatedAxiom evAx : evalAxioms) {
    ind2Axioms=evAx.toRDF(defaultNamespace).entrySet().iterator().next();
    ax=f.getOWLObjectPropertyAssertionAxiom(EnrichmentVocabulary.hasSuggestion,ind,ind2Axioms.getKey());
    axioms.add(ax);
    axioms.addAll(ind2Axioms.getValue());
  }
  return axioms;
}","private List<OWLAxiom> toRDF(List<EvaluatedAxiom> evalAxioms,Class<? extends LearningAlgorithm> algorithm,Map<ConfigOption,String> parameters,SparqlEndpointKS ks,String defaultNamespace){
  if (defaultNamespace == null || defaultNamespace.isEmpty()) {
    defaultNamespace=DEFAULT_NS;
  }
  List<OWLAxiom> axioms=new ArrayList<OWLAxiom>();
  OWLDataFactory f=new OWLDataFactoryImpl();
  String suggestionSetID=defaultNamespace + generateId();
  OWLIndividual ind=f.getOWLNamedIndividual(IRI.create(suggestionSetID));
  OWLAxiom ax=f.getOWLClassAssertionAxiom(EnrichmentVocabulary.SuggestionSet,ind);
  axioms.add(ax);
  String algorithmRunID=defaultNamespace + generateId();
  OWLIndividual algorithmRunInd=f.getOWLNamedIndividual(IRI.create(algorithmRunID));
  ax=f.getOWLClassAssertionAxiom(EnrichmentVocabulary.AlgorithmRun,algorithmRunInd);
  axioms.add(ax);
  String algorithmName=algorithm.getAnnotation(ComponentAnn.class).name();
  String algorithmID=""String_Node_Str"" + algorithmName.replace(""String_Node_Str"",""String_Node_Str"");
  OWLIndividual algorithmInd=f.getOWLNamedIndividual(IRI.create(algorithmID));
  OWLAnnotation labelAnno=f.getOWLAnnotation(f.getOWLAnnotationProperty(OWLRDFVocabulary.RDFS_LABEL.getIRI()),f.getOWLLiteral(algorithmName));
  ax=f.getOWLAnnotationAssertionAxiom(algorithmInd.asOWLNamedIndividual().getIRI(),labelAnno);
  axioms.add(ax);
  ax=f.getOWLDataPropertyAssertionAxiom(EnrichmentVocabulary.version,algorithmInd,algorithm.getAnnotation(ComponentAnn.class).version());
  axioms.add(ax);
  ax=f.getOWLObjectPropertyAssertionAxiom(EnrichmentVocabulary.usedAlgorithm,algorithmRunInd,algorithmInd);
  axioms.add(ax);
  OWLIndividual paramInd;
  for (  Entry<ConfigOption,String> entry : parameters.entrySet()) {
    paramInd=f.getOWLNamedIndividual(IRI.create(generateId()));
    ax=f.getOWLClassAssertionAxiom(EnrichmentVocabulary.Parameter,paramInd);
    axioms.add(ax);
    ax=f.getOWLDataPropertyAssertionAxiom(EnrichmentVocabulary.parameterName,paramInd,entry.getKey().name());
    axioms.add(ax);
    ax=f.getOWLDataPropertyAssertionAxiom(EnrichmentVocabulary.parameterValue,paramInd,entry.getValue());
    axioms.add(ax);
  }
  try {
    OWLNamedIndividual knowldegeBaseInd=f.getOWLNamedIndividual(IRI.create(ks.getEndpoint().getURL()));
    ax=f.getOWLClassAssertionAxiom(EnrichmentVocabulary.SPARQLEndpoint,knowldegeBaseInd);
    axioms.add(ax);
    ax=f.getOWLObjectPropertyAssertionAxiom(EnrichmentVocabulary.defaultGraph,knowldegeBaseInd,f.getOWLNamedIndividual(IRI.create(ks.getEndpoint().getDefaultGraphURIs().iterator().next())));
    axioms.add(ax);
    ax=f.getOWLObjectPropertyAssertionAxiom(EnrichmentVocabulary.hasInput,algorithmRunInd,knowldegeBaseInd);
    axioms.add(ax);
  }
 catch (  URISyntaxException e1) {
    e1.printStackTrace();
  }
  ax=f.getOWLObjectPropertyAssertionAxiom(EnrichmentVocabulary.creator,ind,algorithmRunInd);
  axioms.add(ax);
  Entry<OWLIndividual,List<OWLAxiom>> ind2Axioms;
  for (  EvaluatedAxiom evAx : evalAxioms) {
    ind2Axioms=evAx.toRDF(defaultNamespace).entrySet().iterator().next();
    ax=f.getOWLObjectPropertyAssertionAxiom(EnrichmentVocabulary.hasSuggestion,ind,ind2Axioms.getKey());
    axioms.add(ax);
    axioms.addAll(ind2Axioms.getValue());
  }
  return axioms;
}"
9641,"@Override public void start(){
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  fetchedRows=0;
  currentlyBestAxioms=new ArrayList<EvaluatedAxiom>();
  Description existingDomain=reasoner.getDomain(propertyToDescribe);
  logger.info(""String_Node_Str"" + existingDomain);
  Map<Individual,Set<NamedClass>> individual2Types=new HashMap<Individual,Set<NamedClass>>();
  Map<Individual,Set<NamedClass>> newIndividual2Types;
  boolean repeat=true;
  while (!terminationCriteriaSatisfied() && repeat) {
    newIndividual2Types=getSubjectsWithTypes(fetchedRows);
    individual2Types.putAll(newIndividual2Types);
    currentlyBestAxioms=buildBestAxioms(individual2Types);
    fetchedRows+=1000;
    repeat=!newIndividual2Types.isEmpty();
  }
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime));
}","@Override public void start(){
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  fetchedRows=0;
  currentlyBestAxioms=new ArrayList<EvaluatedAxiom>();
  Description existingDomain=reasoner.getDomain(propertyToDescribe);
  logger.info(""String_Node_Str"" + existingDomain);
  Map<Individual,SortedSet<NamedClass>> individual2Types=new HashMap<Individual,SortedSet<NamedClass>>();
  boolean repeat=true;
  int limit=1000;
  while (!terminationCriteriaSatisfied() && repeat) {
    int ret=addIndividualsWithTypes(individual2Types,limit,fetchedRows);
    currentlyBestAxioms=buildEvaluatedAxioms(individual2Types);
    fetchedRows+=1000;
    repeat=(ret == limit);
  }
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime));
}"
9642,"@Override public void start(){
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  fetchedRows=0;
  currentlyBestAxioms=new ArrayList<EvaluatedAxiom>();
  DataRange existingRange=reasoner.getRange(propertyToDescribe);
  logger.debug(""String_Node_Str"" + existingRange);
  Map<Individual,Set<Datatype>> individual2Types=new HashMap<Individual,Set<Datatype>>();
  Map<Individual,Set<Datatype>> newIndividual2Types;
  boolean repeat=true;
  while (!terminationCriteriaSatisfied() && repeat) {
    newIndividual2Types=getObjectsWithDatatypes(fetchedRows);
    individual2Types.putAll(newIndividual2Types);
    currentlyBestAxioms=buildBestAxioms(individual2Types);
    fetchedRows+=1000;
    repeat=!newIndividual2Types.isEmpty();
  }
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime));
}","@Override public void start(){
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  fetchedRows=0;
  currentlyBestAxioms=new ArrayList<EvaluatedAxiom>();
  DataRange existingRange=reasoner.getRange(propertyToDescribe);
  logger.debug(""String_Node_Str"" + existingRange);
  Map<Individual,SortedSet<Datatype>> individual2Datatypes=new HashMap<Individual,SortedSet<Datatype>>();
  boolean repeat=true;
  int limit=1000;
  while (!terminationCriteriaSatisfied() && repeat) {
    int ret=addIndividualsWithTypes(individual2Datatypes,limit,fetchedRows);
    currentlyBestAxioms=buildEvaluatedAxioms(individual2Datatypes);
    fetchedRows+=1000;
    repeat=(ret == limit);
  }
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime));
}"
9643,"@Override public void start(){
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  fetchedRows=0;
  currentlyBestAxioms=new ArrayList<EvaluatedAxiom>();
  Description existingDomain=reasoner.getDomain(propertyToDescribe);
  logger.info(""String_Node_Str"" + existingDomain);
  Map<Individual,Set<NamedClass>> individual2Types=new HashMap<Individual,Set<NamedClass>>();
  Map<Individual,Set<NamedClass>> newIndividual2Types;
  boolean repeat=true;
  while (!terminationCriteriaSatisfied() && repeat) {
    newIndividual2Types=getSubjectsWithTypes(fetchedRows);
    individual2Types.putAll(newIndividual2Types);
    currentlyBestAxioms=buildBestAxioms(individual2Types);
    fetchedRows+=1000;
    repeat=!newIndividual2Types.isEmpty();
  }
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime));
}","@Override public void start(){
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  fetchedRows=0;
  currentlyBestAxioms=new ArrayList<EvaluatedAxiom>();
  Description existingDomain=reasoner.getDomain(propertyToDescribe);
  logger.info(""String_Node_Str"" + existingDomain);
  Map<Individual,SortedSet<NamedClass>> individual2Types=new HashMap<Individual,SortedSet<NamedClass>>();
  boolean repeat=true;
  int limit=1000;
  while (!terminationCriteriaSatisfied() && repeat) {
    int ret=addIndividualsWithTypes(individual2Types,limit,fetchedRows);
    currentlyBestAxioms=buildEvaluatedAxioms(individual2Types);
    fetchedRows+=1000;
    repeat=(ret == limit);
  }
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime));
}"
9644,"@Override public void start(){
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  fetchedRows=0;
  currentlyBestAxioms=new ArrayList<EvaluatedAxiom>();
  Description existingRange=reasoner.getRange(propertyToDescribe);
  logger.debug(""String_Node_Str"" + existingRange);
  Map<Individual,Set<NamedClass>> individual2Types=new HashMap<Individual,Set<NamedClass>>();
  Map<Individual,Set<NamedClass>> newIndividual2Types;
  boolean repeat=true;
  while (!terminationCriteriaSatisfied() && repeat) {
    newIndividual2Types=getObjectsWithTypes(fetchedRows);
    individual2Types.putAll(newIndividual2Types);
    currentlyBestAxioms=buildBestAxioms(individual2Types);
    fetchedRows+=1000;
    repeat=!newIndividual2Types.isEmpty();
  }
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime));
}","@Override public void start(){
  logger.info(""String_Node_Str"");
  startTime=System.currentTimeMillis();
  fetchedRows=0;
  currentlyBestAxioms=new ArrayList<EvaluatedAxiom>();
  Description existingRange=reasoner.getRange(propertyToDescribe);
  logger.debug(""String_Node_Str"" + existingRange);
  Map<Individual,SortedSet<NamedClass>> individual2Types=new HashMap<Individual,SortedSet<NamedClass>>();
  boolean repeat=true;
  int limit=1000;
  while (!terminationCriteriaSatisfied() && repeat) {
    int ret=addIndividualsWithTypes(individual2Types,limit,fetchedRows);
    currentlyBestAxioms=buildEvaluatedAxioms(individual2Types);
    fetchedRows+=1000;
    repeat=(ret == limit);
  }
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime));
}"
9645,"private List<EvaluatedAxiom> buildBestAxioms(Map<Individual,Set<NamedClass>> individual2Types){
  List<EvaluatedAxiom> axioms=new ArrayList<EvaluatedAxiom>();
  Map<NamedClass,Integer> result=new HashMap<NamedClass,Integer>();
  for (  Entry<Individual,Set<NamedClass>> entry : individual2Types.entrySet()) {
    for (    NamedClass nc : entry.getValue()) {
      Integer cnt=result.get(nc);
      if (cnt == null) {
        cnt=Integer.valueOf(1);
      }
      result.put(nc,Integer.valueOf(cnt + 1));
    }
  }
  EvaluatedAxiom evalAxiom;
  for (  Entry<NamedClass,Integer> entry : sortByValues(result)) {
    evalAxiom=new EvaluatedAxiom(new DatatypePropertyDomainAxiom(propertyToDescribe,entry.getKey()),new AxiomScore(entry.getValue() / (double)individual2Types.keySet().size()));
    axioms.add(evalAxiom);
  }
  return axioms;
}","private List<EvaluatedAxiom> buildBestAxioms(Map<Individual,Set<NamedClass>> individual2Types){
  List<EvaluatedAxiom> axioms=new ArrayList<EvaluatedAxiom>();
  Map<NamedClass,Integer> result=new HashMap<NamedClass,Integer>();
  for (  Entry<Individual,Set<NamedClass>> entry : individual2Types.entrySet()) {
    for (    NamedClass nc : entry.getValue()) {
      Integer cnt=result.get(nc);
      if (cnt == null) {
        cnt=Integer.valueOf(1);
      }
 else {
        cnt=Integer.valueOf(cnt + 1);
      }
      result.put(nc,cnt);
    }
  }
  EvaluatedAxiom evalAxiom;
  for (  Entry<NamedClass,Integer> entry : sortByValues(result)) {
    evalAxiom=new EvaluatedAxiom(new DatatypePropertyDomainAxiom(propertyToDescribe,entry.getKey()),new AxiomScore(entry.getValue() / (double)individual2Types.keySet().size()));
    axioms.add(evalAxiom);
  }
  return axioms;
}"
9646,"private Map<Individual,Set<Datatype>> getObjectsWithDatatypes(int offset){
  Map<Individual,Set<Datatype>> individual2Datatypes=new HashMap<Individual,Set<Datatype>>();
  int limit=1000;
  String query=String.format(""String_Node_Str"",propertyToDescribe.getName(),limit,offset);
  ResultSet rs=executeQuery(query);
  QuerySolution qs;
  Individual ind;
  Set<Datatype> types;
  while (rs.hasNext()) {
    qs=rs.next();
    ind=new Individual(qs.getResource(""String_Node_Str"").getURI());
    types=individual2Datatypes.get(ind);
    if (types == null) {
      types=new HashSet<Datatype>();
      individual2Datatypes.put(ind,types);
    }
    types.add(getDatatypeForURI(qs.getResource(""String_Node_Str"").getURI()));
  }
  return individual2Datatypes;
}","private Map<Individual,Set<Datatype>> getObjectsWithDatatypes(int offset){
  Map<Individual,Set<Datatype>> individual2Datatypes=new HashMap<Individual,Set<Datatype>>();
  int limit=1000;
  String query=String.format(""String_Node_Str"",propertyToDescribe.getName(),limit,offset);
  ResultSet rs=executeQuery(query);
  QuerySolution qs;
  Individual ind;
  Set<Datatype> types;
  while (rs.hasNext()) {
    qs=rs.next();
    ind=new Individual(qs.getResource(""String_Node_Str"").getURI());
    types=individual2Datatypes.get(ind);
    if (types == null) {
      types=new HashSet<Datatype>();
      individual2Datatypes.put(ind,types);
    }
    types.add(new Datatype(qs.getResource(""String_Node_Str"").getURI()));
  }
  return individual2Datatypes;
}"
9647,"private List<EvaluatedAxiom> buildBestAxioms(Map<Individual,Set<Datatype>> individual2Types){
  List<EvaluatedAxiom> axioms=new ArrayList<EvaluatedAxiom>();
  Map<Datatype,Integer> result=new HashMap<Datatype,Integer>();
  for (  Entry<Individual,Set<Datatype>> entry : individual2Types.entrySet()) {
    for (    Datatype nc : entry.getValue()) {
      Integer cnt=result.get(nc);
      if (cnt == null) {
        cnt=Integer.valueOf(1);
      }
      result.put(nc,Integer.valueOf(cnt + 1));
    }
  }
  EvaluatedAxiom evalAxiom;
  for (  Entry<Datatype,Integer> entry : sortByValues(result)) {
    evalAxiom=new EvaluatedAxiom(new DatatypePropertyRangeAxiom(propertyToDescribe,entry.getKey()),new AxiomScore(entry.getValue() / (double)individual2Types.keySet().size()));
    axioms.add(evalAxiom);
  }
  return axioms;
}","private List<EvaluatedAxiom> buildBestAxioms(Map<Individual,Set<Datatype>> individual2Types){
  List<EvaluatedAxiom> axioms=new ArrayList<EvaluatedAxiom>();
  Map<Datatype,Integer> result=new HashMap<Datatype,Integer>();
  for (  Entry<Individual,Set<Datatype>> entry : individual2Types.entrySet()) {
    for (    Datatype nc : entry.getValue()) {
      Integer cnt=result.get(nc);
      if (cnt == null) {
        cnt=Integer.valueOf(1);
      }
 else {
        cnt=Integer.valueOf(cnt + 1);
      }
      result.put(nc,cnt);
    }
  }
  EvaluatedAxiom evalAxiom;
  for (  Entry<Datatype,Integer> entry : sortByValues(result)) {
    evalAxiom=new EvaluatedAxiom(new DatatypePropertyRangeAxiom(propertyToDescribe,entry.getKey()),new AxiomScore(entry.getValue() / (double)individual2Types.keySet().size()));
    axioms.add(evalAxiom);
  }
  return axioms;
}"
9648,"private List<EvaluatedAxiom> buildBestAxioms(Map<Individual,Set<NamedClass>> individual2Types){
  List<EvaluatedAxiom> axioms=new ArrayList<EvaluatedAxiom>();
  Map<NamedClass,Integer> result=new HashMap<NamedClass,Integer>();
  for (  Entry<Individual,Set<NamedClass>> entry : individual2Types.entrySet()) {
    for (    NamedClass nc : entry.getValue()) {
      Integer cnt=result.get(nc);
      if (cnt == null) {
        cnt=Integer.valueOf(1);
      }
      result.put(nc,Integer.valueOf(cnt + 1));
    }
  }
  EvaluatedAxiom evalAxiom;
  for (  Entry<NamedClass,Integer> entry : sortByValues(result)) {
    evalAxiom=new EvaluatedAxiom(new ObjectPropertyDomainAxiom(propertyToDescribe,entry.getKey()),new AxiomScore(entry.getValue() / (double)individual2Types.keySet().size()));
    axioms.add(evalAxiom);
  }
  return axioms;
}","private List<EvaluatedAxiom> buildBestAxioms(Map<Individual,Set<NamedClass>> individual2Types){
  List<EvaluatedAxiom> axioms=new ArrayList<EvaluatedAxiom>();
  Map<NamedClass,Integer> result=new HashMap<NamedClass,Integer>();
  for (  Entry<Individual,Set<NamedClass>> entry : individual2Types.entrySet()) {
    for (    NamedClass nc : entry.getValue()) {
      Integer cnt=result.get(nc);
      if (cnt == null) {
        cnt=Integer.valueOf(1);
      }
 else {
        cnt=Integer.valueOf(cnt + 1);
      }
      result.put(nc,cnt);
    }
  }
  EvaluatedAxiom evalAxiom;
  for (  Entry<NamedClass,Integer> entry : sortByValues(result)) {
    evalAxiom=new EvaluatedAxiom(new ObjectPropertyDomainAxiom(propertyToDescribe,entry.getKey()),new AxiomScore(entry.getValue() / (double)individual2Types.keySet().size()));
    axioms.add(evalAxiom);
  }
  return axioms;
}"
9649,"private List<EvaluatedAxiom> buildBestAxioms(Map<Individual,Set<NamedClass>> individual2Types){
  List<EvaluatedAxiom> axioms=new ArrayList<EvaluatedAxiom>();
  Map<NamedClass,Integer> result=new HashMap<NamedClass,Integer>();
  for (  Entry<Individual,Set<NamedClass>> entry : individual2Types.entrySet()) {
    for (    NamedClass nc : entry.getValue()) {
      Integer cnt=result.get(nc);
      if (cnt == null) {
        cnt=Integer.valueOf(1);
      }
      result.put(nc,Integer.valueOf(cnt + 1));
    }
  }
  EvaluatedAxiom evalAxiom;
  for (  Entry<NamedClass,Integer> entry : sortByValues(result)) {
    evalAxiom=new EvaluatedAxiom(new ObjectPropertyRangeAxiom(propertyToDescribe,entry.getKey()),new AxiomScore(entry.getValue() / (double)individual2Types.keySet().size()));
    axioms.add(evalAxiom);
  }
  return axioms;
}","private List<EvaluatedAxiom> buildBestAxioms(Map<Individual,Set<NamedClass>> individual2Types){
  List<EvaluatedAxiom> axioms=new ArrayList<EvaluatedAxiom>();
  Map<NamedClass,Integer> result=new HashMap<NamedClass,Integer>();
  for (  Entry<Individual,Set<NamedClass>> entry : individual2Types.entrySet()) {
    for (    NamedClass nc : entry.getValue()) {
      Integer cnt=result.get(nc);
      if (cnt == null) {
        cnt=Integer.valueOf(1);
      }
 else {
        cnt=Integer.valueOf(cnt + 1);
      }
      result.put(nc,cnt);
    }
  }
  EvaluatedAxiom evalAxiom;
  for (  Entry<NamedClass,Integer> entry : sortByValues(result)) {
    System.out.println(entry.getKey());
    System.out.println(entry.getValue());
    evalAxiom=new EvaluatedAxiom(new ObjectPropertyRangeAxiom(propertyToDescribe,entry.getKey()),new AxiomScore(entry.getValue() / (double)individual2Types.keySet().size()));
    axioms.add(evalAxiom);
  }
  return axioms;
}"
9650,"public List<EvaluatedDescriptionPosNeg> learn(Set<String> pos,Set<String> neg,OntModel model,int maxTime) throws IOException, ComponentInitException, LearningProblemUnsupportedException {
  ComponentManager cm=ComponentManager.getInstance();
  Monitor total=MonitorFactory.getTimeMonitor(""String_Node_Str"").start();
  Monitor totalPerEx=MonitorFactory.getTimeMonitor(""String_Node_Str"" + (pos.size() + neg.size())).start();
  try {
    Monitor owlapi=MonitorFactory.getTimeMonitor(""String_Node_Str"").start();
    model.createIndividual(""String_Node_Str"",model.createClass(OWL.Ontology.getURI()));
    ModelUtils.write(model,new File(""String_Node_Str""));
    PipedOutputStream out=new PipedOutputStream();
    model.write(out,Constants.RDFXML);
    RDFWriter writer=model.getWriter(""String_Node_Str"");
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    writer.write(model,baos,""String_Node_Str"");
    ByteArrayInputStream bs=new ByteArrayInputStream(baos.toString().getBytes());
    log.debug(""String_Node_Str"");
    OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
    OWLOntology retOnt=null;
    try {
      retOnt=manager.loadOntologyFromOntologyDocument(bs);
    }
 catch (    OWLOntologyCreationException e) {
      e.printStackTrace();
    }
    KnowledgeSource ks=new OWLAPIOntology(retOnt);
    ks.init();
    owlapi.stop();
    log.debug(""String_Node_Str"" + Helper.prettyPrintNanoSeconds((long)owlapi.getLastValue()));
    Monitor mon=MonitorFactory.getTimeMonitor(""String_Node_Str"").start();
    ReasonerComponent rc=cm.reasoner(reasoner,ks);
    rc.init();
    mon.stop();
    log.debug(""String_Node_Str"" + Helper.prettyPrintNanoSeconds((long)mon.getLastValue()));
    PosNegLPStandard lp=cm.learningProblem(PosNegLPStandard.class,rc);
    lp.setPositiveExamples(Helper.getIndividualSet(pos));
    lp.setNegativeExamples(Helper.getIndividualSet(neg));
    lp.init();
    ELLearningAlgorithm la=cm.learningAlgorithm(ELLearningAlgorithm.class,lp,rc);
    la.getConfigurator().setInstanceBasedDisjoints(false);
    la.init();
    log.debug(""String_Node_Str"");
    Monitor learn=MonitorFactory.getTimeMonitor(""String_Node_Str"").start();
    la.start();
    List<EvaluatedDescriptionPosNeg> eds=new ArrayList<EvaluatedDescriptionPosNeg>();
    int x=0;
    for (    EvaluatedDescription ed : la.getCurrentlyBestEvaluatedDescriptions()) {
      eds.add((EvaluatedDescriptionPosNeg)ed);
      if (x > 5) {
        break;
      }
      x++;
    }
    learn.stop();
    log.debug(""String_Node_Str"" + Helper.prettyPrintNanoSeconds((long)learn.getLastValue()));
    log.debug(eds.get(0).toString());
    return eds;
  }
  finally {
    cm.freeAllComponents();
    total.stop();
    totalPerEx.stop();
  }
}","public List<EvaluatedDescriptionPosNeg> learn(Set<String> pos,Set<String> neg,OntModel model,int maxTime) throws IOException, ComponentInitException, LearningProblemUnsupportedException {
  ComponentManager cm=ComponentManager.getInstance();
  Monitor total=MonitorFactory.getTimeMonitor(""String_Node_Str"").start();
  Monitor totalPerEx=MonitorFactory.getTimeMonitor(""String_Node_Str"" + (pos.size() + neg.size())).start();
  try {
    Monitor owlapi=MonitorFactory.getTimeMonitor(""String_Node_Str"").start();
    model.createIndividual(""String_Node_Str"",model.createClass(OWL.Ontology.getURI()));
    ModelUtils.write(model,new File(""String_Node_Str""));
    PipedOutputStream out=new PipedOutputStream();
    model.write(out,Constants.RDFXML);
    RDFWriter writer=model.getWriter(""String_Node_Str"");
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    writer.write(model,baos,""String_Node_Str"");
    ByteArrayInputStream bs=new ByteArrayInputStream(baos.toString().getBytes());
    log.debug(""String_Node_Str"");
    OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
    OWLOntology retOnt=null;
    try {
      retOnt=manager.loadOntologyFromOntologyDocument(bs);
    }
 catch (    OWLOntologyCreationException e) {
      e.printStackTrace();
    }
    KnowledgeSource ks=new OWLAPIOntology(retOnt);
    ks.init();
    owlapi.stop();
    log.debug(""String_Node_Str"" + Helper.prettyPrintNanoSeconds((long)owlapi.getLastValue()));
    Monitor mon=MonitorFactory.getTimeMonitor(""String_Node_Str"").start();
    ReasonerComponent rc=cm.reasoner(reasoner,ks);
    rc.init();
    mon.stop();
    log.debug(""String_Node_Str"" + Helper.prettyPrintNanoSeconds((long)mon.getLastValue()));
    PosNegLPStandard lp=cm.learningProblem(PosNegLPStandard.class,rc);
    lp.setPositiveExamples(Helper.getIndividualSet(pos));
    lp.setNegativeExamples(Helper.getIndividualSet(neg));
    lp.init();
    ELLearningAlgorithm la=cm.learningAlgorithm(ELLearningAlgorithm.class,lp,rc);
    la.getConfigurator().setInstanceBasedDisjoints(false);
    la.init();
    log.debug(""String_Node_Str"");
    Monitor learn=MonitorFactory.getTimeMonitor(""String_Node_Str"").start();
    la.start();
    List<EvaluatedDescriptionPosNeg> eds=new ArrayList<EvaluatedDescriptionPosNeg>();
    for (    EvaluatedDescription ed : ((TreeSet<EvaluatedDescriptionPosNeg>)la.getCurrentlyBestEvaluatedDescriptions()).descendingSet()) {
      eds.add((EvaluatedDescriptionPosNeg)ed);
      if (ed.getAccuracy() < 1.0) {
        break;
      }
    }
    learn.stop();
    log.debug(""String_Node_Str"" + Helper.prettyPrintNanoSeconds((long)learn.getLastValue()));
    log.debug(eds.get(0).toString());
    return eds;
  }
  finally {
    cm.freeAllComponents();
    total.stop();
    totalPerEx.stop();
  }
}"
9651,"private List<Query> getNBestQueryCandidatesForTemplates(Map<Template,Collection<? extends Query>> template2Queries){
  List<Query> queries=new ArrayList<Query>();
  for (  Entry<Template,Collection<? extends Query>> entry : template2Queries.entrySet()) {
    int max=Math.min(maxQueriesPerTemplate,entry.getValue().size());
    int i=0;
    for (    Query q : entry.getValue()) {
      queries.add(q);
      i++;
      if (i == max) {
        break;
      }
    }
  }
  return queries;
}","private List<Query> getNBestQueryCandidatesForTemplates(Map<Template,Collection<? extends Query>> template2Queries){
  List<Query> queries=new ArrayList<Query>();
  for (  Entry<Template,Collection<? extends Query>> entry : template2Queries.entrySet()) {
    int max=Math.min(maxTestedQueriesPerTemplate,entry.getValue().size());
    int i=0;
    for (    Query q : entry.getValue()) {
      queries.add(q);
      i++;
      if (i == max) {
        break;
      }
    }
  }
  return queries;
}"
9652,"@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  stringDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      try {
        if (source instanceof OWLAPIOntology) {
          ontology=((OWLAPIOntology)source).getOWLOntolgy();
        }
 else         if (source instanceof SparqlKnowledgeSource) {
          ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
          manager=ontology.getOWLOntologyManager();
        }
 else {
          ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url.toURI()));
        }
        owlAPIOntologies.add(ontology);
        Set<OWLOntology> imports=manager.getImportsClosure(ontology);
        allImports.addAll(imports);
        for (        OWLOntology ont : imports) {
          classes.addAll(ont.getClassesInSignature());
          owlObjectProperties.addAll(ont.getObjectPropertiesInSignature());
          owlDatatypeProperties.addAll(ont.getDataPropertiesInSignature());
          owlIndividuals.addAll(ont.getIndividualsInSignature());
        }
        OWLOntologyFormat format=manager.getOntologyFormat(ontology);
        if (format instanceof PrefixOWLOntologyFormat) {
          prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
          baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
          prefixes.remove(""String_Node_Str"");
        }
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
catch (      URISyntaxException e) {
        e.printStackTrace();
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyURI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyURI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<OWLOntology>(owlAPIOntologies));
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  ReasonerProgressMonitor progressMonitor=new NullReasonerProgressMonitor();
  FreshEntityPolicy freshEntityPolicy=FreshEntityPolicy.ALLOW;
  long timeOut=Integer.MAX_VALUE;
  IndividualNodeSetPolicy individualNodeSetPolicy=IndividualNodeSetPolicy.BY_NAME;
  OWLReasonerConfiguration conf=new SimpleConfiguration(progressMonitor,freshEntityPolicy,timeOut,individualNodeSetPolicy);
  if (configurator.getReasonerType().equals(""String_Node_Str"")) {
    try {
      reasoner=new FaCTPlusPlusReasonerFactory().createNonBufferingReasoner(ontology,conf);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
  }
 else   if (configurator.getReasonerType().equals(""String_Node_Str"")) {
    reasoner=new ReasonerFactory().createNonBufferingReasoner(ontology,conf);
  }
 else   if (configurator.getReasonerType().equals(""String_Node_Str"")) {
    reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology,conf);
    Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
    pelletLogger.setLevel(Level.WARN);
  }
 else {
    try {
      OWLlinkHTTPXMLReasonerFactory factory=new OWLlinkHTTPXMLReasonerFactory();
      URL url=getConfigurator().getOwlLinkURL();
      OWLlinkReasonerConfiguration config=new OWLlinkReasonerConfiguration(url);
      reasoner=factory.createNonBufferingReasoner(ontology,config);
      System.out.println(reasoner.getReasonerName());
    }
 catch (    Exception e) {
      throw new ComponentInitException(e);
    }
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS);
  }
 else {
    throw new ComponentInitException(""String_Node_Str"");
  }
  factory=manager.getOWLDataFactory();
  for (  OWLClass owlClass : classes)   atomicConcepts.add(new NamedClass(owlClass.toStringID()));
  for (  OWLObjectProperty owlProperty : owlObjectProperties)   atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
  for (  OWLDataProperty owlProperty : owlDatatypeProperties) {
    DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
    Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
    Iterator<OWLDataRange> it=ranges.iterator();
    if (it.hasNext()) {
      OWLDataRange range=it.next();
      if (range.isDatatype()) {
        URI uri=((OWLDatatype)range).getIRI().toURI();
        if (uri.equals(Datatype.BOOLEAN.getURI()))         booleanDatatypeProperties.add(dtp);
 else         if (uri.equals(Datatype.DOUBLE.getURI()))         doubleDatatypeProperties.add(dtp);
 else         if (uri.equals(Datatype.INT.getURI()))         intDatatypeProperties.add(dtp);
 else         if (uri.equals(Datatype.STRING.getURI()))         stringDatatypeProperties.add(dtp);
      }
    }
 else {
      stringDatatypeProperties.add(dtp);
    }
    datatypeProperties.add(dtp);
  }
  for (  OWLNamedIndividual owlIndividual : owlIndividuals) {
    individuals.add(new Individual(owlIndividual.toStringID()));
  }
}","@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  stringDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      try {
        if (source instanceof OWLAPIOntology) {
          ontology=((OWLAPIOntology)source).getOWLOntolgy();
          manager=ontology.getOWLOntologyManager();
        }
 else         if (source instanceof SparqlKnowledgeSource) {
          ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
          manager=ontology.getOWLOntologyManager();
        }
 else {
          ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url.toURI()));
        }
        owlAPIOntologies.add(ontology);
        Set<OWLOntology> imports=manager.getImportsClosure(ontology);
        allImports.addAll(imports);
        for (        OWLOntology ont : imports) {
          classes.addAll(ont.getClassesInSignature());
          owlObjectProperties.addAll(ont.getObjectPropertiesInSignature());
          owlDatatypeProperties.addAll(ont.getDataPropertiesInSignature());
          owlIndividuals.addAll(ont.getIndividualsInSignature());
        }
        OWLOntologyFormat format=manager.getOntologyFormat(ontology);
        if (format instanceof PrefixOWLOntologyFormat) {
          prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
          baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
          prefixes.remove(""String_Node_Str"");
        }
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
catch (      URISyntaxException e) {
        e.printStackTrace();
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyURI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyURI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  try {
    ontology=manager.createOntology(IRI.create(""String_Node_Str""),new HashSet<OWLOntology>(owlAPIOntologies));
  }
 catch (  OWLOntologyCreationException e1) {
    e1.printStackTrace();
  }
  ReasonerProgressMonitor progressMonitor=new NullReasonerProgressMonitor();
  FreshEntityPolicy freshEntityPolicy=FreshEntityPolicy.ALLOW;
  long timeOut=Integer.MAX_VALUE;
  IndividualNodeSetPolicy individualNodeSetPolicy=IndividualNodeSetPolicy.BY_NAME;
  OWLReasonerConfiguration conf=new SimpleConfiguration(progressMonitor,freshEntityPolicy,timeOut,individualNodeSetPolicy);
  if (configurator.getReasonerType().equals(""String_Node_Str"")) {
    try {
      reasoner=new FaCTPlusPlusReasonerFactory().createNonBufferingReasoner(ontology,conf);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
  }
 else   if (configurator.getReasonerType().equals(""String_Node_Str"")) {
    reasoner=new ReasonerFactory().createNonBufferingReasoner(ontology,conf);
  }
 else   if (configurator.getReasonerType().equals(""String_Node_Str"")) {
    reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology,conf);
    Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
    pelletLogger.setLevel(Level.WARN);
  }
 else {
    try {
      OWLlinkHTTPXMLReasonerFactory factory=new OWLlinkHTTPXMLReasonerFactory();
      URL url=getConfigurator().getOwlLinkURL();
      OWLlinkReasonerConfiguration config=new OWLlinkReasonerConfiguration(url);
      reasoner=factory.createNonBufferingReasoner(ontology,config);
      System.out.println(reasoner.getReasonerName());
    }
 catch (    Exception e) {
      throw new ComponentInitException(e);
    }
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY,InferenceType.CLASS_ASSERTIONS);
  }
 else {
    throw new ComponentInitException(""String_Node_Str"");
  }
  factory=manager.getOWLDataFactory();
  for (  OWLClass owlClass : classes)   atomicConcepts.add(new NamedClass(owlClass.toStringID()));
  for (  OWLObjectProperty owlProperty : owlObjectProperties)   atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
  for (  OWLDataProperty owlProperty : owlDatatypeProperties) {
    DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
    Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
    Iterator<OWLDataRange> it=ranges.iterator();
    if (it.hasNext()) {
      OWLDataRange range=it.next();
      if (range.isDatatype()) {
        URI uri=((OWLDatatype)range).getIRI().toURI();
        if (uri.equals(Datatype.BOOLEAN.getURI()))         booleanDatatypeProperties.add(dtp);
 else         if (uri.equals(Datatype.DOUBLE.getURI()))         doubleDatatypeProperties.add(dtp);
 else         if (uri.equals(Datatype.INT.getURI()))         intDatatypeProperties.add(dtp);
 else         if (uri.equals(Datatype.STRING.getURI()))         stringDatatypeProperties.add(dtp);
      }
    }
 else {
      stringDatatypeProperties.add(dtp);
    }
    datatypeProperties.add(dtp);
  }
  for (  OWLNamedIndividual owlIndividual : owlIndividuals) {
    individuals.add(new Individual(owlIndividual.toStringID()));
  }
}"
9653,"public List<String> convertFeatureString2Classes(String productdesc){
  List<String> classes=new ArrayList<String>();
  String[] features=productdesc.split(""String_Node_Str"");
  String cpu=features[0].trim();
  String ram=features[1].trim();
  ram=ram.substring(0,ram.indexOf(""String_Node_Str"") + 2);
  add(classes,ramMap,ram);
  try {
    String hd=features[2].trim();
    if (hd.contains(""String_Node_Str"")) {
      classes.add(prefix + ""String_Node_Str"");
    }
 else     if (hd.contains(""String_Node_Str"")) {
      classes.add(prefix + ""String_Node_Str"");
    }
 else {
      classes.add(prefix + ""String_Node_Str"");
    }
    hd=hd.substring(0,hd.indexOf(""String_Node_Str"") + 2);
    add(classes,hdMap,hd);
  }
 catch (  Exception e) {
    log.warn(""String_Node_Str"" + features[2].trim());
  }
  String disc=features[3].trim();
  add(classes,discMap,disc);
  int x=6;
  while (!features[x].contains(""String_Node_Str"")) {
    x++;
  }
  return classes;
}","public List<String> convertFeatureString2Classes(String productdesc){
  List<String> classes=new ArrayList<String>();
  String[] features=productdesc.split(""String_Node_Str"");
  String cpu=features[0].trim();
  String ram=features[1].trim();
  ram=ram.substring(0,ram.indexOf(""String_Node_Str"") + 2);
  add(classes,ramMap,ram);
  try {
    String hd=features[2].trim();
    if (hd.contains(""String_Node_Str"")) {
      classes.add(prefix + ""String_Node_Str"");
    }
 else     if (hd.contains(""String_Node_Str"")) {
      classes.add(prefix + ""String_Node_Str"");
    }
 else {
      classes.add(prefix + ""String_Node_Str"");
    }
    hd=hd.substring(0,hd.indexOf(""String_Node_Str"") + 2);
    add(classes,hdMap,hd);
  }
 catch (  Exception e) {
    log.warn(""String_Node_Str"" + features[2].trim());
  }
  String disc=features[3].trim();
  add(classes,discMap,disc);
  int x=6;
  while (!features[x].contains(""String_Node_Str"")) {
    x++;
  }
  String[] display=features[x++].split(""String_Node_Str"");
  classes.add(prefix + ""String_Node_Str"" + display[0].replace(""String_Node_Str"",""String_Node_Str""));
  return classes;
}"
9654,"public LearningResult learn(Set<String> pos,Set<String> neg,OntModel model,int maxTime) throws IOException, ComponentInitException, LearningProblemUnsupportedException {
  LearningResult lr=new LearningResult();
  PipedOutputStream out=new PipedOutputStream();
  model.write(out,Constants.RDFXML);
  RDFWriter writer=model.getWriter(""String_Node_Str"");
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  writer.write(model,baos,""String_Node_Str"");
  ByteArrayInputStream bs=new ByteArrayInputStream(baos.toString().getBytes());
  ComponentManager cm=ComponentManager.getInstance();
  logger.debug(""String_Node_Str"");
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  OWLOntology retOnt=null;
  try {
    retOnt=manager.loadOntologyFromOntologyDocument(bs);
  }
 catch (  OWLOntologyCreationException e) {
    e.printStackTrace();
  }
  KnowledgeSource ks=new OWLAPIOntology(retOnt);
  ks.init();
  logger.debug(""String_Node_Str"");
  ReasonerComponent rc=cm.reasoner(OWLAPIReasoner.class,ks);
  rc.init();
  PosNegLPStandard lp=cm.learningProblem(PosNegLPStandard.class,rc);
  lp.setPositiveExamples(Helper.getIndividualSet(pos));
  lp.setNegativeExamples(Helper.getIndividualSet(neg));
  lp.getConfigurator().setAccuracyMethod(""String_Node_Str"");
  lp.getConfigurator().setUseApproximations(false);
  lp.init();
  ELLearningAlgorithm la=cm.learningAlgorithm(ELLearningAlgorithm.class,lp,rc);
  la.init();
  logger.debug(""String_Node_Str"");
  la.start();
  EvaluatedDescriptionPosNeg ed=(EvaluatedDescriptionPosNeg)la.getCurrentlyBestEvaluatedDescription();
  cm.freeAllComponents();
  System.out.println(ed);
  return lr;
}","public LearningResult learn(Set<String> pos,Set<String> neg,OntModel model,int maxTime) throws IOException, ComponentInitException, LearningProblemUnsupportedException {
  model.createIndividual(""String_Node_Str"",model.createClass(OWL.Ontology.getURI()));
  ModelUtils.write(model,new File(""String_Node_Str""));
  LearningResult lr=new LearningResult();
  PipedOutputStream out=new PipedOutputStream();
  model.write(out,Constants.RDFXML);
  RDFWriter writer=model.getWriter(""String_Node_Str"");
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  writer.write(model,baos,""String_Node_Str"");
  ByteArrayInputStream bs=new ByteArrayInputStream(baos.toString().getBytes());
  ComponentManager cm=ComponentManager.getInstance();
  logger.debug(""String_Node_Str"");
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  OWLOntology retOnt=null;
  try {
    retOnt=manager.loadOntologyFromOntologyDocument(bs);
  }
 catch (  OWLOntologyCreationException e) {
    e.printStackTrace();
  }
  KnowledgeSource ks=new OWLAPIOntology(retOnt);
  ks.init();
  logger.debug(""String_Node_Str"");
  ReasonerComponent rc=cm.reasoner(OWLAPIReasoner.class,ks);
  rc.init();
  PosNegLPStandard lp=cm.learningProblem(PosNegLPStandard.class,rc);
  lp.setPositiveExamples(Helper.getIndividualSet(pos));
  lp.setNegativeExamples(Helper.getIndividualSet(neg));
  lp.getConfigurator().setAccuracyMethod(""String_Node_Str"");
  lp.getConfigurator().setUseApproximations(false);
  lp.init();
  ELLearningAlgorithm la=cm.learningAlgorithm(ELLearningAlgorithm.class,lp,rc);
  la.init();
  logger.debug(""String_Node_Str"");
  la.start();
  EvaluatedDescriptionPosNeg ed=(EvaluatedDescriptionPosNeg)la.getCurrentlyBestEvaluatedDescription();
  cm.freeAllComponents();
  System.out.println(ed);
  return lr;
}"
9655,"public DBpediaClassesSolrIndexCreator(){
  try {
    solr=getEmbeddedSolrServer();
  }
 catch (  CorruptIndexException e) {
    e.printStackTrace();
  }
catch (  LockObtainFailedException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
  initDocument();
}","public DBpediaClassesSolrIndexCreator(){
  try {
    solr=getEmbeddedSolrServer();
  }
 catch (  CorruptIndexException e) {
    e.printStackTrace();
  }
catch (  LockObtainFailedException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
  initDocument();
  docs=new HashSet<SolrInputDocument>();
}"
9656,"public String getQuestion(List<String> posExamples,List<String> negExamples) throws QTLException {
  this.posExamples=posExamples;
  this.negExamples=negExamples;
  posExampleTrees.addAll(getQueryTrees(posExamples));
  negExampleTrees.addAll(getQueryTrees(negExamples));
  if (negExamples.isEmpty()) {
    QueryTree<String> dummyNegTree=new QueryTreeImpl<String>(""String_Node_Str"");
    dummyNegTree.addChild(new QueryTreeImpl<String>(""String_Node_Str""),""String_Node_Str"");
    negExampleTrees.add(dummyNegTree);
  }
  lgg=lggGenerator.getLGG(posExampleTrees);
  if (queryTreeFilter != null) {
    lgg=queryTreeFilter.getFilteredQueryTree(lgg);
  }
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + lgg.getStringRepresentation());
  }
  if (coversNegativeQueryTree(lgg)) {
    throw new QTLException(""String_Node_Str"");
  }
  lggInstances=getResources(lgg);
  nbr.setLGGInstances(lggInstances);
  String question=nbr.getQuestion(lgg,negExampleTrees,getKnownResources());
  return question;
}","public String getQuestion(List<String> posExamples,List<String> negExamples) throws QTLException {
  this.posExamples=posExamples;
  this.negExamples=negExamples;
  posExampleTrees.clear();
  negExampleTrees.clear();
  posExampleTrees.addAll(getQueryTrees(posExamples));
  negExampleTrees.addAll(getQueryTrees(negExamples));
  if (negExamples.isEmpty()) {
    QueryTree<String> dummyNegTree=new QueryTreeImpl<String>(""String_Node_Str"");
    dummyNegTree.addChild(new QueryTreeImpl<String>(""String_Node_Str""),""String_Node_Str"");
    negExampleTrees.add(dummyNegTree);
  }
  lgg=lggGenerator.getLGG(posExampleTrees);
  if (queryTreeFilter != null) {
    lgg=queryTreeFilter.getFilteredQueryTree(lgg);
  }
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + lgg.getStringRepresentation());
  }
  if (coversNegativeQueryTree(lgg)) {
    throw new QTLException(""String_Node_Str"");
  }
  lggInstances=getResources(lgg);
  nbr.setLGGInstances(lggInstances);
  String question=nbr.getQuestion(lgg,negExampleTrees,getKnownResources());
  return question;
}"
9657,"public Example getSimilarExample(List<String> posExamples,List<String> negExamples) throws SPARQLQueryException {
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"" + posExamples);
  logger.info(""String_Node_Str"" + negExamples);
  if (negExamples.isEmpty()) {
  }
  try {
    Example example=exampleFinder.findSimilarExample(posExamples,negExamples);
    return example;
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.error(e);
    throw new SPARQLQueryException(exampleFinder.getCurrentQueryHTML());
  }
}","public Example getSimilarExample(List<String> posExamples,List<String> negExamples) throws SPARQLQueryException {
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"" + posExamples);
  logger.info(""String_Node_Str"" + negExamples);
  if (negExamples.isEmpty()) {
  }
  try {
    Example example=exampleFinder.findSimilarExample(posExamples,negExamples);
    examplesCache.put(example.getURI(),example);
    return example;
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.error(e);
    throw new SPARQLQueryException(exampleFinder.getCurrentQueryHTML());
  }
}"
9658,"private void put(String question,String query,String endpoint,List<Example> posExamples,List<Example> negExamples,Example lastSuggestedExample){
  System.out.println(posExamples);
  System.out.println(negExamples);
  try {
    StoredSPARQLQuery storedQuery=new StoredSPARQLQuery(question,query,HTMLUtils.encodeHTML(query),endpoint,posExamples,negExamples,lastSuggestedExample);
    question2QueryMap.put(question,storedQuery.toStoredSPARQLQuerySer());
    saveMap();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","private void put(String question,String query,String endpoint,List<Example> posExamples,List<Example> negExamples,Example lastSuggestedExample){
  try {
    StoredSPARQLQuery storedQuery=new StoredSPARQLQuery(question,query,HTMLUtils.encodeHTML(query),endpoint,posExamples,negExamples,lastSuggestedExample);
    question2QueryMap.put(question,storedQuery.toStoredSPARQLQuerySer());
    saveMap();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
9659,"@Override protected void initialize(){
  mainPanel=new LayoutContainer(new RowLayout(Orientation.VERTICAL));
  BorderLayoutData data=new BorderLayoutData(LayoutRegion.CENTER);
  data.setMargins(new Margins(5,5,5,0));
  queryField=new HTML();
  mainPanel.add(queryField,new RowData(1,-1));
  resultPanel=new SPARQLQueryResultPanel(true);
  mainPanel.add(resultPanel,new RowData(1,0.7));
  Button editButton=new Button(""String_Node_Str"");
  editButton.addSelectionListener(new SelectionListener<ButtonEvent>(){
    @Override public void componentSelected(    ButtonEvent ce){
      AppEvent event=new AppEvent(AppEvents.EditQuery);
      event.setData(""String_Node_Str"",storedQuery);
      Dispatcher.forwardEvent(event);
    }
  }
);
  mainPanel.add(editButton);
}","@Override protected void initialize(){
  mainPanel=new LayoutContainer(new RowLayout(Orientation.VERTICAL));
  BorderLayoutData data=new BorderLayoutData(LayoutRegion.CENTER);
  data.setMargins(new Margins(5,5,5,0));
  queryField=new HTML();
  mainPanel.add(queryField,new RowData(1,-1));
  resultPanel=new SPARQLQueryResultPanel(true,false);
  mainPanel.add(resultPanel,new RowData(1,0.7));
  Button editButton=new Button(""String_Node_Str"");
  editButton.addSelectionListener(new SelectionListener<ButtonEvent>(){
    @Override public void componentSelected(    ButtonEvent ce){
      AppEvent event=new AppEvent(AppEvents.EditQuery);
      event.setData(""String_Node_Str"",storedQuery);
      Dispatcher.forwardEvent(event);
    }
  }
);
  mainPanel.add(editButton);
}"
9660,"private void showSimilarExample(){
  if (!interactiveMode) {
    showInteractivePanel();
  }
  if (!examplesPanel.getPositiveExamplesURIs().isEmpty()) {
    interactivePanel.mask(""String_Node_Str"");
    SPARQLService.Util.getInstance().getSimilarExample(examplesPanel.getPositiveExamplesURIs(),examplesPanel.getNegativeExamplesUris(),new AsyncCallbackEx<Example>(){
      @Override public void onSuccess(      Example result){
        interactivePanel.unmask();
        interactivePanel.setExample(result);
      }
    }
);
  }
}","private void showSimilarExample(){
  if (!interactiveMode) {
    showInteractivePanel();
  }
  if (!examplesPanel.getPositiveExamplesURIs().isEmpty()) {
    interactivePanel.mask(""String_Node_Str"");
    SPARQLService.Util.getInstance().getSimilarExample(examplesPanel.getPositiveExamplesURIs(),examplesPanel.getNegativeExamplesUris(),new AsyncCallbackEx<Example>(){
      @Override public void onSuccess(      Example result){
        interactivePanel.unmask();
        interactivePanel.setExample(result);
        resultPanel.refresh(examplesPanel.getPositiveExamplesURIs(),examplesPanel.getNegativeExamplesUris());
      }
    }
);
  }
}"
9661,"private void onAddExample(Example example,final Example.Type type){
  if (type == Example.Type.POSITIVE) {
    examplesPanel.addPositiveExample(example);
  }
 else {
    examplesPanel.addNegativeExample(example);
  }
  if (examplesPanel.getPositiveExamplesURIs().size() >= 2) {
    SPARQLService.Util.getInstance().setExamples(examplesPanel.getPositiveExamplesURIs(),examplesPanel.getNegativeExamplesUris(),new AsyncCallbackEx<Void>(){
      @Override public void onSuccess(      Void result){
        if (type == Example.Type.POSITIVE) {
          resultPanel.refresh(examplesPanel.getPositiveExamplesURIs(),examplesPanel.getNegativeExamplesUris());
        }
      }
    }
);
  }
 else {
  }
}","private void onAddExample(Example example,final Example.Type type){
  if (type == Example.Type.POSITIVE) {
    examplesPanel.addPositiveExample(example);
  }
 else {
    examplesPanel.addNegativeExample(example);
  }
  if (examplesPanel.getPositiveExamplesURIs().size() >= 2) {
    SPARQLService.Util.getInstance().setExamples(examplesPanel.getPositiveExamplesURIs(),examplesPanel.getNegativeExamplesUris(),new AsyncCallback<Void>(){
      @Override public void onSuccess(      Void result){
        if (type == Example.Type.POSITIVE) {
          showSimilarExample();
        }
      }
      @Override public void onFailure(      Throwable caught){
        System.out.println(""String_Node_Str"");
      }
    }
);
  }
 else {
  }
}"
9662,"@Override public void onSuccess(Example result){
  interactivePanel.unmask();
  interactivePanel.setExample(result);
}","@Override public void onSuccess(Example result){
  interactivePanel.unmask();
  interactivePanel.setExample(result);
  resultPanel.refresh(examplesPanel.getPositiveExamplesURIs(),examplesPanel.getNegativeExamplesUris());
}"
9663,"private void updateQuery(){
  SPARQLService.Util.getInstance().getCurrentSPARQLQuery(new AsyncCallback<String>(){
    @Override public void onFailure(    Throwable caught){
    }
    @Override public void onSuccess(    String result){
      queryTab.removeAll();
      queryTab.addText(""String_Node_Str"" + result + ""String_Node_Str"");
      queryTab.layout();
      System.out.println(result);
      System.out.println(URL.decode(result));
      resultPanel.setQuery(result);
      resultPanel.refresh();
    }
  }
);
}","private void updateQuery(){
  SPARQLService.Util.getInstance().getCurrentSPARQLQuery(new AsyncCallback<String>(){
    @Override public void onFailure(    Throwable caught){
    }
    @Override public void onSuccess(    String result){
      queryTab.removeAll();
      queryTab.addText(""String_Node_Str"" + encodeHTML(result) + ""String_Node_Str"");
      queryTab.layout();
      resultPanel.setQuery(result);
      resultPanel.loadProperties();
      resultPanel.refresh();
    }
  }
);
}"
9664,"public void refresh(List<String> posExamples,List<String> negExamples){
  this.posExamples=posExamples;
  this.negExamples=negExamples;
  updateQuery();
}","public void refresh(List<String> posExamples,List<String> negExamples){
  this.posExamples=posExamples;
  this.negExamples=negExamples;
  resultPanel.setExamples(posExamples,negExamples);
  updateQuery();
}"
9665,"private void createResultGrid(){
  queryResultTab=new TabItem(""String_Node_Str"");
  queryResultTab.setLayout(new RowLayout(Orientation.VERTICAL));
  resultPanel=new SPARQLQueryResultPanel(false);
  queryResultTab.add(resultPanel,new RowData(1,1));
  mainPanel.add(queryResultTab);
}","private void createResultGrid(){
  queryResultTab=new TabItem(""String_Node_Str"");
  queryResultTab.setLayout(new RowLayout(Orientation.VERTICAL));
  resultPanel=new SPARQLQueryResultPanel(false,true);
  queryResultTab.add(resultPanel,new RowData(1,1));
  mainPanel.add(queryResultTab);
}"
9666,"private void createColumns(Map<String,String> properties){
  ArrayList<ColumnConfig> columns=new ArrayList<ColumnConfig>();
  ColumnConfig c=new ColumnConfig();
  c=new ColumnConfig();
  c.setId(""String_Node_Str"");
  c.setHeader(""String_Node_Str"");
  c.setSortable(true);
  columns.add(c);
  for (  Entry<String,String> entry : properties.entrySet()) {
    c=new ColumnConfig();
    c.setId(entry.getKey());
    c.setHeader(entry.getValue());
    c.setSortable(true);
    c.setHidden(true);
    c.setWidth(200);
    columns.add(c);
  }
  final ColumnModel cm=new ColumnModel(columns);
  cm.addListener(Events.HiddenChange,new Listener<ColumnModelEvent>(){
    public void handleEvent(    ColumnModelEvent e){
      if (grid.isViewReady()) {
        EventType type=e.getType();
        if (type == Events.HiddenChange) {
          updateProperties(cm);
        }
      }
    }
  }
);
  grid.reconfigure(store,cm);
}","private void createColumns(Map<String,String> properties){
  ArrayList<ColumnConfig> columns=new ArrayList<ColumnConfig>();
  ColumnConfig c=new ColumnConfig();
  c=new ColumnConfig();
  c.setId(LABEL_URI);
  c.setHeader(""String_Node_Str"");
  c.setSortable(true);
  columns.add(c);
  for (  Entry<String,String> entry : properties.entrySet()) {
    c=new ColumnConfig();
    c.setId(entry.getKey());
    c.setHeader(entry.getValue());
    c.setSortable(true);
    c.setHidden(true);
    c.setWidth(200);
    columns.add(c);
  }
  final ColumnModel cm=new ColumnModel(columns);
  cm.addListener(Events.HiddenChange,new Listener<ColumnModelEvent>(){
    public void handleEvent(    ColumnModelEvent e){
      if (grid.isViewReady()) {
        EventType type=e.getType();
        if (type == Events.HiddenChange) {
          updateProperties(cm);
        }
      }
    }
  }
);
  grid.reconfigure(store,cm);
}"
9667,"private void initUI(){
  setLayout(new FitLayout());
  setHeading(""String_Node_Str"");
  ToolBar topToolbar=new ToolBar();
  setTopComponent(topToolbar);
  propertiesButton=new SplitButton(""String_Node_Str"",new SelectionListener<ButtonEvent>(){
    @Override public void componentSelected(    ButtonEvent ce){
    }
  }
);
  Menu menu=new Menu();
  propertiesButton.setMenu(menu);
  topToolbar.add(propertiesButton);
  RpcProxy<PagingLoadResult<Example>> proxy=new RpcProxy<PagingLoadResult<Example>>(){
    @Override protected void load(    Object loadConfig,    AsyncCallback<PagingLoadResult<Example>> callback){
      SPARQLService.Util.getInstance().getSPARQLQueryResultWithProperties(query,visibleProperties,(PagingLoadConfig)loadConfig,callback);
    }
  }
;
  loader=new BasePagingLoader<PagingLoadResult<ModelData>>(proxy);
  final PagingToolBar toolbar=new PagingToolBar(10);
  toolbar.bind(loader);
  store=new ListStore<Example>(loader);
  ArrayList<ColumnConfig> columns=new ArrayList<ColumnConfig>();
  ColumnConfig c=new ColumnConfig();
  c=new ColumnConfig();
  c.setId(""String_Node_Str"");
  c.setHeader(""String_Node_Str"");
  c.setSortable(true);
  columns.add(c);
  ColumnModel cm=new ColumnModel(columns);
  grid=new Grid<Example>(store,cm);
  grid.setAutoExpandColumn(""String_Node_Str"");
  grid.setLoadMask(true);
  grid.getView().setEmptyText(""String_Node_Str"");
  add(grid);
  setBottomComponent(toolbar);
}","private void initUI(){
  setLayout(new FitLayout());
  setHeading(""String_Node_Str"");
  ToolBar topToolbar=new ToolBar();
  setTopComponent(topToolbar);
  propertiesButton=new SplitButton(""String_Node_Str"",new SelectionListener<ButtonEvent>(){
    @Override public void componentSelected(    ButtonEvent ce){
    }
  }
);
  Menu menu=new Menu();
  propertiesButton.setMenu(menu);
  topToolbar.add(propertiesButton);
  RpcProxy<PagingLoadResult<Example>> proxy=new RpcProxy<PagingLoadResult<Example>>(){
    @Override protected void load(    Object loadConfig,    AsyncCallback<PagingLoadResult<Example>> callback){
      SPARQLService.Util.getInstance().getSPARQLQueryResultWithProperties(query,visibleProperties,(PagingLoadConfig)loadConfig,callback);
    }
  }
;
  loader=new BasePagingLoader<PagingLoadResult<ModelData>>(proxy);
  final PagingToolBar toolbar=new PagingToolBar(10);
  toolbar.bind(loader);
  store=new ListStore<Example>(loader);
  ArrayList<ColumnConfig> columns=new ArrayList<ColumnConfig>();
  ColumnConfig c=new ColumnConfig();
  c=new ColumnConfig();
  c.setId(LABEL_URI);
  c.setHeader(""String_Node_Str"");
  c.setSortable(true);
  columns.add(c);
  visibleProperties.add(LABEL_URI);
  ColumnModel cm=new ColumnModel(columns);
  grid=new Grid<Example>(store,cm);
  grid.setAutoExpandColumn(LABEL_URI);
  grid.setLoadMask(true);
  grid.getView().setEmptyText(""String_Node_Str"");
  if (highlightPosNeg) {
    grid.getView().setViewConfig(new GridViewConfig(){
      @Override public String getRowStyle(      ModelData model,      int rowIndex,      ListStore<ModelData> ds){
        String uri=model.get(""String_Node_Str"");
        if (posExamples.contains(uri)) {
          return ""String_Node_Str"";
        }
 else         if (negExamples.contains(uri)) {
          return ""String_Node_Str"";
        }
 else         if (rowIndex % 2 == 0) {
          return ""String_Node_Str"";
        }
 else {
          return ""String_Node_Str"";
        }
      }
    }
);
  }
  add(grid);
  setBottomComponent(toolbar);
}"
9668,"public SPARQLQueryResultPanel(boolean showHeader){
  setHeaderVisible(showHeader);
  initUI();
}","public SPARQLQueryResultPanel(boolean showHeader,boolean highlightPosNeg){
  this.highlightPosNeg=highlightPosNeg;
  setHeaderVisible(showHeader);
  initUI();
}"
9669,"public int getIndexSize(){
  try {
    return searcher.maxDoc();
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
    e.printStackTrace();
  }
  return -1;
}","public int getIndexSize(){
  return searcher.maxDoc();
}"
9670,"@Override public void init() throws ComponentInitException {
  Set<NamedClass> usedConcepts;
  Set<NamedClass> allowedConcepts=CommonConfigMappings.getAtomicConceptSet(configurator.getAllowedConcepts());
  Set<NamedClass> ignoredConcepts=CommonConfigMappings.getAtomicConceptSet(configurator.getIgnoredConcepts());
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  classHierarchy.thinOutSubsumptionHierarchy();
  heuristic=new OEHeuristicRuntime(configurator);
  minimizer=new DescriptionMinimizer(reasoner);
  startClass=Thing.instance;
  singleSuggestionMode=configurator.getSingleSuggestionMode();
  operator=new RhoDRDown(reasoner,classHierarchy,startClass,configurator);
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  if (configurator.getWriteSearchTree()) {
    Files.clearFile(new File(configurator.getSearchTreeFile()));
  }
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(configurator.getMaxNrOfResults());
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=configurator.getNoisePercentage() / 100d;
  maxDepth=configurator.getMaxDepth();
  filterFollowsFromKB=configurator.getFilterDescriptionsFollowingFromKB() && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (configurator.getReuseExistingDescription() && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}","@Override public void init() throws ComponentInitException {
  Set<NamedClass> usedConcepts;
  Set<NamedClass> allowedConcepts=configurator.getAllowedConcepts() == null ? null : CommonConfigMappings.getAtomicConceptSet(configurator.getAllowedConcepts());
  Set<NamedClass> ignoredConcepts=configurator.getIgnoredConcepts() == null ? null : CommonConfigMappings.getAtomicConceptSet(configurator.getIgnoredConcepts());
  if (allowedConcepts != null) {
    Helper.checkConcepts(reasoner,allowedConcepts);
    usedConcepts=allowedConcepts;
  }
 else   if (ignoredConcepts != null) {
    usedConcepts=Helper.computeConceptsUsingIgnoreList(reasoner,ignoredConcepts);
  }
 else {
    usedConcepts=Helper.computeConcepts(reasoner);
  }
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().cloneAndRestrict(usedConcepts);
  classHierarchy.thinOutSubsumptionHierarchy();
  heuristic=new OEHeuristicRuntime(configurator);
  minimizer=new DescriptionMinimizer(reasoner);
  startClass=Thing.instance;
  singleSuggestionMode=configurator.getSingleSuggestionMode();
  operator=new RhoDRDown(reasoner,classHierarchy,startClass,configurator);
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  if (configurator.getWriteSearchTree()) {
    Files.clearFile(new File(configurator.getSearchTreeFile()));
  }
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(configurator.getMaxNrOfResults());
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=configurator.getNoisePercentage() / 100d;
  maxDepth=configurator.getMaxDepth();
  filterFollowsFromKB=configurator.getFilterDescriptionsFollowingFromKB() && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (configurator.getReuseExistingDescription() && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}"
9671,"private String computeQuestionBetterPerformance(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources) throws TimeOutException {
  startTime=System.currentTimeMillis();
  this.lgg=lgg;
  this.negTrees=negTrees;
  if (userAnsweredWithNo()) {
    noSequences.add(lastSequence);
  }
  negExamplesCount=negTrees.size();
  determiningNodeIds=getDeterminingNodeIds(lgg,negTrees);
  logger.info(""String_Node_Str"");
  postLGG=getFilteredTree(lgg);
  PostLGG<N> postGen=new PostLGG<N>((SPARQLEndpointEx)endpoint);
  postGen.simplifyTree(postLGG,negTrees);
  logger.info(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(postLGG,endpoint.getBaseURI(),endpoint.getPrefixes()));
  logger.info(""String_Node_Str"" + postLGG.toSPARQLQueryString());
  logger.info(""String_Node_Str"" + getAllResources(postLGG.toSPARQLQueryString()).size());
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=null;
  if (generalizeSortedByNegatives) {
    queue=getAllowedGeneralisationsSortedByMatrix(new GeneralisedQueryTree<N>(postLGG),negTrees);
  }
 else {
    queue=getAllowedGeneralisationsSorted(new GeneralisedQueryTree<N>(postLGG));
  }
  logger.debug(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  QueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  List<GeneralisedQueryTree<N>> gens;
  List<GeneralisedQueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<GeneralisedQueryTree<N>>();
    logger.debug(""String_Node_Str"");
    tree1=getGeneralisedQueryTreeNotContainingNoSequence(queue);
    tmp=tree1;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + tmp.getChanges());
    }
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    neededGeneralisations.add(tmp);
    logger.debug(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      if (generalizeSortedByNegatives) {
        gens=getAllowedGeneralisationsSortedByMatrix(tmp,negTrees);
      }
 else {
        gens=getAllowedGeneralisationsSorted(tmp);
      }
      if (gens.isEmpty()) {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"");
        }
        break;
      }
      tmp=getGeneralisedQueryTreeNotContainingNoSequence(gens);
      neededGeneralisations.add(tmp);
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.debug(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.debug(""String_Node_Str"");
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      if (index == -1) {
        tree2=tmp.getQueryTree();
      }
      tree2=neededGeneralisations.get(index--).getQueryTree();
    }
 else {
      tree2=tmp.getQueryTree();
    }
    String newResource=getNewResource2(fSparql(lgg,neededGeneralisations.get(index).getChanges()),knownResources);
    if (isTerminationCriteriaReached()) {
      throw new TimeOutException(maxExecutionTimeInSeconds);
    }
    fSparql(postLGG,tmp.getChanges());
    logger.debug(""String_Node_Str"" + newResource);
    if (!(newResource == null)) {
      logger.debug(""String_Node_Str"");
      newResource=findMostSpecificResourceTree2(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      logger.debug(""String_Node_Str"");
      return newResource;
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
  return null;
}","private String computeQuestionBetterPerformance(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources) throws TimeOutException {
  startTime=System.currentTimeMillis();
  this.lgg=lgg;
  this.negTrees=negTrees;
  if (userAnsweredWithNo()) {
    noSequences.add(lastSequence);
  }
  negExamplesCount=negTrees.size();
  determiningNodeIds=getDeterminingNodeIds(lgg,negTrees);
  logger.info(""String_Node_Str"");
  postLGG=getFilteredTree(lgg);
  PostLGG<N> postGen=new PostLGG<N>((SPARQLEndpointEx)endpoint);
  postGen.simplifyTree(postLGG,negTrees);
  logger.info(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(postLGG,endpoint.getBaseURI(),endpoint.getPrefixes()));
  logger.info(""String_Node_Str"" + postLGG.toSPARQLQueryString());
  logger.info(""String_Node_Str"" + getAllResources(postLGG.toSPARQLQueryString()).size());
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=null;
  if (generalizeSortedByNegatives) {
    queue=getAllowedGeneralisationsSortedByMatrix(new GeneralisedQueryTree<N>(postLGG),negTrees);
  }
 else {
    queue=getAllowedGeneralisationsSorted(new GeneralisedQueryTree<N>(postLGG));
  }
  logger.debug(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  GeneralisedQueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  List<GeneralisedQueryTree<N>> gens;
  List<GeneralisedQueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<GeneralisedQueryTree<N>>();
    logger.debug(""String_Node_Str"");
    tree1=getGeneralisedQueryTreeNotContainingNoSequence(queue);
    tmp=tree1;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + tmp.getChanges());
    }
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    neededGeneralisations.add(tmp);
    logger.debug(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      if (generalizeSortedByNegatives) {
        gens=getAllowedGeneralisationsSortedByMatrix(tmp,negTrees);
      }
 else {
        gens=getAllowedGeneralisationsSorted(tmp);
      }
      if (gens.isEmpty()) {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"");
        }
        break;
      }
      tmp=getGeneralisedQueryTreeNotContainingNoSequence(gens);
      neededGeneralisations.add(tmp);
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.debug(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.debug(""String_Node_Str"");
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      if (index == -1) {
        tree2=tmp;
      }
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp;
    }
    String newResource=getNewResource2(fSparql(lgg,tree2.getChanges()),knownResources);
    if (isTerminationCriteriaReached()) {
      throw new TimeOutException(maxExecutionTimeInSeconds);
    }
    fSparql(postLGG,tmp.getChanges());
    logger.debug(""String_Node_Str"" + newResource);
    if (!(newResource == null)) {
      logger.debug(""String_Node_Str"");
      newResource=findMostSpecificResourceTree2(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      logger.debug(""String_Node_Str"");
      return newResource;
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
  return null;
}"
9672,"private void buildSPARQLQueryString(QueryTree<N> tree,List<QueryTreeChange> changes,StringBuilder triples,List<String> filters){
  Object subject=null;
  if (tree.getUserObject().equals(""String_Node_Str"")) {
    subject=""String_Node_Str"" + tree.getId();
  }
 else {
    subject=""String_Node_Str"" + tree.getUserObject() + ""String_Node_Str"";
  }
  Object predicate;
  Object object;
  if (!tree.isLeaf()) {
    for (    QueryTree<N> child : tree.getChildren()) {
      predicate=tree.getEdge(child);
      object=child.getUserObject();
      boolean addFilter=false;
      boolean removed=false;
      String uri=null;
      QueryTreeChange c=getChange(changes,child.getId());
      if (c != null) {
        if (c.getType() == ChangeType.REPLACE_LABEL) {
          uri=(String)object;
          filters.add(""String_Node_Str"" + child.getId() + ""String_Node_Str""+ uri+ ""String_Node_Str"");
          child.setUserObject((N)""String_Node_Str"");
          object=""String_Node_Str"" + child.getId();
        }
 else {
          removed=true;
          triples.append(""String_Node_Str"").append(subject).append(""String_Node_Str"").append(predicate).append(""String_Node_Str"").append(""String_Node_Str"").append(child.getId()).append(""String_Node_Str"");
          filters.add(""String_Node_Str"" + child.getId() + ""String_Node_Str"");
          child.getParent().removeChild((QueryTreeImpl<N>)child);
        }
      }
      if (((String)object).startsWith(""String_Node_Str"")) {
        object=""String_Node_Str"" + object + ""String_Node_Str"";
      }
      boolean objectIsResource=!child.getUserObject().equals(""String_Node_Str"");
      if (!removed) {
        triples.append(subject).append(""String_Node_Str"").append(predicate).append(""String_Node_Str"").append(object).append(""String_Node_Str"");
      }
      if (!objectIsResource) {
        buildSPARQLQueryString(child,changes,triples,filters);
      }
    }
  }
}","private void buildSPARQLQueryString(QueryTree<N> tree,List<QueryTreeChange> changes,StringBuilder triples,List<String> filters){
  Object subject=null;
  if (tree.getUserObject().equals(""String_Node_Str"")) {
    subject=""String_Node_Str"" + tree.getId();
  }
 else {
    subject=""String_Node_Str"" + tree.getUserObject() + ""String_Node_Str"";
  }
  Object predicate;
  Object object;
  if (!tree.isLeaf()) {
    for (    QueryTree<N> child : tree.getChildren()) {
      predicate=tree.getEdge(child);
      object=child.getUserObject();
      boolean addFilter=false;
      boolean removed=false;
      String uri=null;
      QueryTreeChange c=getChange(changes,child.getId());
      if (c != null) {
        if (c.getType() == ChangeType.REPLACE_LABEL) {
          uri=(String)object;
          filters.add(""String_Node_Str"" + child.getId() + ""String_Node_Str""+ uri+ ""String_Node_Str"");
          child.setUserObject((N)""String_Node_Str"");
        }
 else {
          removed=true;
          triples.append(""String_Node_Str"").append(subject).append(""String_Node_Str"").append(predicate).append(""String_Node_Str"").append(""String_Node_Str"").append(child.getId()).append(""String_Node_Str"");
          filters.add(""String_Node_Str"" + child.getId() + ""String_Node_Str"");
          child.getParent().removeChild((QueryTreeImpl<N>)child);
        }
      }
      object=child.getUserObject();
      boolean objectIsResource=!object.equals(""String_Node_Str"");
      if (!objectIsResource) {
        object=""String_Node_Str"" + child.getId();
      }
 else       if (((String)object).startsWith(""String_Node_Str"")) {
        object=""String_Node_Str"" + object + ""String_Node_Str"";
      }
      if (!removed) {
        triples.append(subject).append(""String_Node_Str"").append(predicate).append(""String_Node_Str"").append(object).append(""String_Node_Str"");
      }
      if (!objectIsResource) {
        buildSPARQLQueryString(child,changes,triples,filters);
      }
    }
  }
}"
9673,"private String computeQuestionBetterPerformance(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources) throws TimeOutException {
  startTime=System.currentTimeMillis();
  this.lgg=lgg;
  this.negTrees=negTrees;
  if (userAnsweredWithNo()) {
    noSequences.add(lastSequence);
  }
  negExamplesCount=negTrees.size();
  determiningNodeIds=getDeterminingNodeIds(lgg,negTrees);
  logger.info(""String_Node_Str"");
  postLGG=getFilteredTree(lgg);
  PostLGG<N> postGen=new PostLGG<N>((SPARQLEndpointEx)endpoint);
  postGen.simplifyTree(postLGG,negTrees);
  logger.info(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(postLGG,endpoint.getBaseURI(),endpoint.getPrefixes()));
  logger.info(""String_Node_Str"" + postLGG.toSPARQLQueryString());
  logger.info(""String_Node_Str"" + getAllResources(postLGG.toSPARQLQueryString()).size());
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=null;
  if (generalizeSortedByNegatives) {
    queue=getAllowedGeneralisationsSortedByMatrix(new GeneralisedQueryTree<N>(postLGG),negTrees);
  }
 else {
    queue=getAllowedGeneralisationsSorted(new GeneralisedQueryTree<N>(postLGG));
  }
  logger.debug(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  GeneralisedQueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  List<GeneralisedQueryTree<N>> gens;
  List<GeneralisedQueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<GeneralisedQueryTree<N>>();
    logger.debug(""String_Node_Str"");
    tree1=getGeneralisedQueryTreeNotContainingNoSequence(queue);
    tmp=tree1;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + tmp.getChanges());
    }
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    neededGeneralisations.add(tmp);
    logger.debug(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      if (generalizeSortedByNegatives) {
        gens=getAllowedGeneralisationsSortedByMatrix(tmp,negTrees);
      }
 else {
        gens=getAllowedGeneralisationsSorted(tmp);
      }
      if (gens.isEmpty()) {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"");
        }
        break;
      }
      tmp=getGeneralisedQueryTreeNotContainingNoSequence(gens);
      neededGeneralisations.add(tmp);
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.debug(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.debug(""String_Node_Str"");
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      if (index == -1) {
        tree2=tmp;
      }
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp;
    }
    String newResource=getNewResource2(fSparql(lgg,tree2.getChanges()),knownResources);
    if (isTerminationCriteriaReached()) {
      throw new TimeOutException(maxExecutionTimeInSeconds);
    }
    fSparql(postLGG,tmp.getChanges());
    logger.debug(""String_Node_Str"" + newResource);
    if (!(newResource == null)) {
      logger.debug(""String_Node_Str"");
      newResource=findMostSpecificResourceTree2(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      logger.debug(""String_Node_Str"");
      return newResource;
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
  return null;
}","private String computeQuestionBetterPerformance(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources) throws TimeOutException {
  startTime=System.currentTimeMillis();
  this.lgg=lgg;
  this.negTrees=negTrees;
  if (userAnsweredWithNo()) {
    noSequences.add(lastSequence);
  }
  negExamplesCount=negTrees.size();
  determiningNodeIds=getDeterminingNodeIds(lgg,negTrees);
  logger.info(""String_Node_Str"");
  postLGG=getFilteredTree(lgg);
  PostLGG<N> postGen=new PostLGG<N>((SPARQLEndpointEx)endpoint);
  postGen.simplifyTree(postLGG,negTrees);
  logger.info(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(postLGG,endpoint.getBaseURI(),endpoint.getPrefixes()));
  logger.info(""String_Node_Str"" + postLGG.toSPARQLQueryString());
  logger.info(""String_Node_Str"" + getAllResources(postLGG.toSPARQLQueryString()).size());
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=null;
  if (generalizeSortedByNegatives) {
    queue=getAllowedGeneralisationsSortedByMatrix(new GeneralisedQueryTree<N>(postLGG),negTrees);
  }
 else {
    queue=getAllowedGeneralisationsSorted(new GeneralisedQueryTree<N>(postLGG));
  }
  logger.debug(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  GeneralisedQueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  List<GeneralisedQueryTree<N>> gens;
  List<GeneralisedQueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<GeneralisedQueryTree<N>>();
    logger.debug(""String_Node_Str"");
    tree1=getGeneralisedQueryTreeNotContainingNoSequence(queue);
    tmp=tree1;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + tmp.getChanges());
    }
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    neededGeneralisations.add(tmp);
    logger.debug(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      if (generalizeSortedByNegatives) {
        gens=getAllowedGeneralisationsSortedByMatrix(tmp,negTrees);
      }
 else {
        gens=getAllowedGeneralisationsSorted(tmp);
      }
      if (gens.isEmpty()) {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"");
        }
        break;
      }
      tmp=getGeneralisedQueryTreeNotContainingNoSequence(gens);
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.debug(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
 else {
        neededGeneralisations.add(tmp);
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      if (index == -1) {
        tree2=tmp;
      }
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp;
    }
    String newResource=getNewResource2(fSparql(lgg,tree2.getChanges()),knownResources);
    if (isTerminationCriteriaReached()) {
      throw new TimeOutException(maxExecutionTimeInSeconds);
    }
    fSparql(postLGG,tmp.getChanges());
    logger.debug(""String_Node_Str"" + newResource);
    if (!(newResource == null)) {
      logger.debug(""String_Node_Str"");
      newResource=findMostSpecificResourceTree2(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      logger.debug(""String_Node_Str"");
      return newResource;
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
  return null;
}"
9674,"private String fSparql(QueryTree<N> tree,List<QueryTreeChange> changes){
  QueryTree<N> copy=new QueryTreeImpl<N>(tree);
  StringBuilder query=new StringBuilder();
  StringBuilder triples=new StringBuilder();
  List<String> filters=new ArrayList<String>();
  query.append(""String_Node_Str"");
  buildSPARQLQueryString(copy,changes,triples,filters);
  query.append(triples.toString());
  if (filters.size() > 0) {
    query.append(""String_Node_Str"");
    for (int i=0; i < filters.size() - 1; i++) {
      query.append(""String_Node_Str"").append(filters.get(i)).append(""String_Node_Str"");
    }
    query.append(""String_Node_Str"").append(filters.get(filters.size() - 1)).append(""String_Node_Str"");
    query.append(""String_Node_Str"");
  }
  query.append(""String_Node_Str"");
  return query.toString();
}","private String fSparql(QueryTree<N> tree,List<QueryTreeChange> changes){
  logger.info(""String_Node_Str"" + changes);
  QueryTree<N> copy=new QueryTreeImpl<N>(tree);
  StringBuilder query=new StringBuilder();
  StringBuilder triples=new StringBuilder();
  List<String> filters=new ArrayList<String>();
  query.append(""String_Node_Str"");
  buildSPARQLQueryString(copy,changes,triples,filters);
  query.append(triples.toString());
  if (filters.size() > 0) {
    query.append(""String_Node_Str"");
    for (int i=0; i < filters.size() - 1; i++) {
      query.append(""String_Node_Str"").append(filters.get(i)).append(""String_Node_Str"");
    }
    query.append(""String_Node_Str"").append(filters.get(filters.size() - 1)).append(""String_Node_Str"");
    query.append(""String_Node_Str"");
  }
  query.append(""String_Node_Str"");
  return query.toString();
}"
9675,"private String computeQuestionOptimized(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources) throws TimeOutException {
  startTime=System.currentTimeMillis();
  this.lgg=lgg;
  this.negTrees=negTrees;
  determiningNodeIds=getDeterminingNodeIds(lgg,negTrees);
  logger.info(""String_Node_Str"");
  postLGG=getFilteredTree(lgg);
  PostLGG<N> postGen=new PostLGG<N>((SPARQLEndpointEx)endpoint);
  postGen.simplifyTree(postLGG,negTrees);
  logger.info(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(postLGG,endpoint.getBaseURI(),endpoint.getPrefixes()));
  logger.info(""String_Node_Str"" + postLGG.toSPARQLQueryString());
  logger.info(""String_Node_Str"" + getAllResources(postLGG.toSPARQLQueryString()).size());
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=null;
  if (generalizeSortedByNegatives) {
    queue=getAllowedGeneralisationsSortedByMatrix(new GeneralisedQueryTree<N>(postLGG),negTrees);
  }
 else {
    queue=getAllowedGeneralisationsSorted(new GeneralisedQueryTree<N>(postLGG));
  }
  logger.debug(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  QueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  List<GeneralisedQueryTree<N>> gens;
  List<QueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<QueryTree<N>>();
    logger.debug(""String_Node_Str"");
    tree1=queue.remove(0);
    tmp=tree1;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + tmp.getChanges());
    }
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    neededGeneralisations.add(tmp.getQueryTree());
    logger.debug(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      if (generalizeSortedByNegatives) {
        gens=getAllowedGeneralisationsSortedByMatrix(tmp,negTrees);
      }
 else {
        gens=getAllowedGeneralisationsSorted(tmp);
      }
      if (gens.isEmpty()) {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"");
        }
        break;
      }
      tmp=gens.remove(0);
      neededGeneralisations.add(tmp.getQueryTree());
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.debug(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.debug(""String_Node_Str"");
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp.getQueryTree();
    }
    String newResource=getNewResource(tree2,knownResources);
    if (isTerminationCriteriaReached()) {
      throw new TimeOutException(maxExecutionTimeInSeconds);
    }
    logger.debug(""String_Node_Str"" + newResource);
    if (!(newResource == null)) {
      logger.debug(""String_Node_Str"");
      newResource=findMostSpecificResourceTree(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      logger.debug(""String_Node_Str"");
      return newResource;
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
  return null;
}","private String computeQuestionOptimized(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources) throws TimeOutException {
  startTime=System.currentTimeMillis();
  this.lgg=lgg;
  this.negTrees=negTrees;
  determiningNodeIds=getDeterminingNodeIds(lgg,negTrees);
  logger.info(""String_Node_Str"");
  postLGG=getFilteredTree(lgg);
  PostLGG<N> postGen=new PostLGG<N>((SPARQLEndpointEx)endpoint);
  postGen.simplifyTree(postLGG,negTrees);
  logger.info(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(postLGG,endpoint.getBaseURI(),endpoint.getPrefixes()));
  logger.info(""String_Node_Str"" + postLGG.toSPARQLQueryString());
  logger.info(""String_Node_Str"" + getAllResources(postLGG.toSPARQLQueryString()).size());
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=null;
  if (generalizeSortedByNegatives) {
    queue=getAllowedGeneralisationsSortedByMatrix(new GeneralisedQueryTree<N>(postLGG),negTrees);
  }
 else {
    queue=getAllowedGeneralisationsSorted(new GeneralisedQueryTree<N>(postLGG));
  }
  logger.debug(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  QueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  List<GeneralisedQueryTree<N>> gens;
  List<QueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<QueryTree<N>>();
    logger.debug(""String_Node_Str"");
    tree1=queue.remove(0);
    tmp=tree1;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + tmp.getChanges());
    }
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    neededGeneralisations.add(tmp.getQueryTree());
    logger.debug(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      if (generalizeSortedByNegatives) {
        gens=getAllowedGeneralisationsSortedByMatrix(tmp,negTrees);
      }
 else {
        gens=getAllowedGeneralisationsSorted(tmp);
      }
      if (gens.isEmpty()) {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"");
        }
        break;
      }
      tmp=gens.remove(0);
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.debug(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.debug(""String_Node_Str"");
      }
 else {
        neededGeneralisations.add(tmp.getQueryTree());
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp.getQueryTree();
    }
    String newResource=getNewResource(tree2,knownResources);
    if (isTerminationCriteriaReached()) {
      throw new TimeOutException(maxExecutionTimeInSeconds);
    }
    logger.debug(""String_Node_Str"" + newResource);
    if (!(newResource == null)) {
      logger.debug(""String_Node_Str"");
      newResource=findMostSpecificResourceTree(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      logger.debug(""String_Node_Str"");
      return newResource;
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
  return null;
}"
9676,"private void buildSPARQLQueryString(QueryTree<N> tree,List<QueryTreeChange> changes,StringBuilder triples,List<String> filters){
  Object subject=null;
  if (tree.getUserObject().equals(""String_Node_Str"")) {
    subject=""String_Node_Str"" + tree.getId();
  }
 else {
    subject=""String_Node_Str"" + tree.getUserObject() + ""String_Node_Str"";
  }
  Object predicate;
  Object object;
  if (!tree.isLeaf()) {
    for (    QueryTree<N> child : tree.getChildren()) {
      predicate=tree.getEdge(child);
      object=child.getUserObject();
      boolean objectIsResource=!object.equals(""String_Node_Str"");
      boolean addFilter=false;
      boolean removed=false;
      String uri=null;
      if (!objectIsResource) {
        object=""String_Node_Str"" + child.getId();
      }
 else       if (((String)object).startsWith(""String_Node_Str"")) {
        QueryTreeChange c=getChange(changes,child.getId());
        if (c != null) {
          if (c.getType() == ChangeType.REPLACE_LABEL) {
            uri=(String)object;
            child.setUserObject((N)""String_Node_Str"");
            object=""String_Node_Str"" + child.getId();
            addFilter=true;
          }
 else {
            removed=true;
            triples.append(""String_Node_Str"").append(subject).append(""String_Node_Str"").append(predicate).append(""String_Node_Str"").append(""String_Node_Str"").append(child.getId()).append(""String_Node_Str"");
            filters.add(""String_Node_Str"" + child.getId() + ""String_Node_Str"");
            child.getParent().removeChild((QueryTreeImpl<N>)child);
          }
        }
 else {
          object=""String_Node_Str"" + object + ""String_Node_Str"";
        }
      }
      if (!removed) {
        triples.append(subject).append(""String_Node_Str"").append(predicate).append(""String_Node_Str"").append(object).append(""String_Node_Str"");
      }
      if (addFilter) {
        filters.add(""String_Node_Str"" + child.getId() + ""String_Node_Str""+ uri+ ""String_Node_Str"");
      }
      if (!objectIsResource) {
        buildSPARQLQueryString(child,changes,triples,filters);
      }
    }
  }
}","private void buildSPARQLQueryString(QueryTree<N> tree,List<QueryTreeChange> changes,StringBuilder triples,List<String> filters){
  Object subject=null;
  if (tree.getUserObject().equals(""String_Node_Str"")) {
    subject=""String_Node_Str"" + tree.getId();
  }
 else {
    subject=""String_Node_Str"" + tree.getUserObject() + ""String_Node_Str"";
  }
  Object predicate;
  Object object;
  if (!tree.isLeaf()) {
    for (    QueryTree<N> child : tree.getChildren()) {
      predicate=tree.getEdge(child);
      object=child.getUserObject();
      boolean addFilter=false;
      boolean removed=false;
      String uri=null;
      QueryTreeChange c=getChange(changes,child.getId());
      if (c != null) {
        if (c.getType() == ChangeType.REPLACE_LABEL) {
          uri=(String)object;
          filters.add(""String_Node_Str"" + child.getId() + ""String_Node_Str""+ uri+ ""String_Node_Str"");
          child.setUserObject((N)""String_Node_Str"");
          object=""String_Node_Str"" + child.getId();
        }
 else {
          removed=true;
          triples.append(""String_Node_Str"").append(subject).append(""String_Node_Str"").append(predicate).append(""String_Node_Str"").append(""String_Node_Str"").append(child.getId()).append(""String_Node_Str"");
          filters.add(""String_Node_Str"" + child.getId() + ""String_Node_Str"");
          child.getParent().removeChild((QueryTreeImpl<N>)child);
        }
      }
      if (((String)object).startsWith(""String_Node_Str"")) {
        object=""String_Node_Str"" + object + ""String_Node_Str"";
      }
      boolean objectIsResource=!child.getUserObject().equals(""String_Node_Str"");
      if (!removed) {
        triples.append(subject).append(""String_Node_Str"").append(predicate).append(""String_Node_Str"").append(object).append(""String_Node_Str"");
      }
      if (!objectIsResource) {
        buildSPARQLQueryString(child,changes,triples,filters);
      }
    }
  }
}"
9677,"public EvaluationWithNLQueriesScript(){
  try {
    server=new CommonsHttpSolrServer(SOLR_SERVER_URL);
    List<String> predicateFilters=new ArrayList<String>();
    predicateFilters.add(""String_Node_Str"");
    predicateFilters.add(""String_Node_Str"");
    exFinder=new ExampleFinder(new SPARQLEndpointEx(new SparqlEndpoint(new URL(""String_Node_Str""),Collections.singletonList(""String_Node_Str""),Collections.<String>emptyList()),null,null,predicateFilters),selectCache,constructCache);
    schemaIndex=new DBpediaSchemaIndex(SCHEMA_FILE_PATH);
    luceneSearch=new LuceneSearch(LUCENE_INDEX_DIRECTORY);
    luceneSearch.setHitsPerPage(TOP_K);
    wordNet=new WordnetQuery(WORDNET_DICTIONARY);
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
  readQueries();
}","public EvaluationWithNLQueriesScript(){
  try {
    server=new CommonsHttpSolrServer(SOLR_SERVER_URL);
    List<String> predicateFilters=new ArrayList<String>();
    predicateFilters.add(""String_Node_Str"");
    predicateFilters.add(""String_Node_Str"");
    String baseURI=""String_Node_Str"";
    Map<String,String> prefixes=new HashMap<String,String>();
    prefixes.put(""String_Node_Str"",""String_Node_Str"");
    prefixes.put(""String_Node_Str"",""String_Node_Str"");
    prefixes.put(""String_Node_Str"",""String_Node_Str"");
    prefixes.put(""String_Node_Str"",""String_Node_Str"");
    prefixes.put(""String_Node_Str"",""String_Node_Str"");
    prefixes.put(""String_Node_Str"",""String_Node_Str"");
    prefixes.put(""String_Node_Str"",""String_Node_Str"");
    prefixes.put(""String_Node_Str"",""String_Node_Str"");
    prefixes.put(""String_Node_Str"",""String_Node_Str"");
    prefixes.put(""String_Node_Str"",""String_Node_Str"");
    prefixes.put(""String_Node_Str"",""String_Node_Str"");
    exFinder=new ExampleFinder(new SPARQLEndpointEx(new URL(""String_Node_Str""),Collections.singletonList(""String_Node_Str""),Collections.<String>emptyList(),null,baseURI,prefixes,predicateFilters),selectCache,constructCache);
    luceneSearch=new LuceneSearch(LUCENE_INDEX_DIRECTORY);
    luceneSearch.setHitsPerPage(TOP_K);
    wordNet=new WordnetQuery(WORDNET_DICTIONARY);
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
  readQueries();
}"
9678,"public void evaluate(){
  String targetQuery;
  Set<String> answers;
  List<String> examples;
  Set<String> relatedResources;
  List<String> relevantWords;
  int i=1;
  for (  String question : question2Answers.keySet()) {
    question=""String_Node_Str"";
    logger.info(getNewQuestionString(i++,question));
    try {
      logger.info(""String_Node_Str"" + question + ""String_Node_Str"");
      targetQuery=question2query.get(question);
      logger.info(""String_Node_Str"" + targetQuery);
      answers=question2Answers.get(question);
      logger.info(""String_Node_Str"" + answers.size() + ""String_Node_Str""+ answers);
      relevantWords=getRelevantWords(question);
      exFinder.setStatementFilter(new QuestionBasedStatementFilter(new HashSet<String>(relevantWords)));
      if (USE_SYNONYMS) {
        relevantWords.addAll(getSynonyms(relevantWords));
        logger.info(""String_Node_Str"" + relevantWords);
      }
      question=""String_Node_Str"";
      for (      String word : relevantWords) {
        question+=""String_Node_Str"" + word;
      }
      question.trim();
      logger.info(""String_Node_Str"" + question);
      if (USE_WIKIPEDIA_SEARCH) {
        examples=getResourcesByWikipedia(question);
      }
 else {
        examples=getResourcesByNLQueryWithLucene(question);
      }
      List<String> posExamples=new ArrayList<String>();
      List<String> negExamples=new ArrayList<String>();
      for (      String ex : examples) {
        if (answers.contains(ex)) {
          if (posExamples.size() < NR_OF_POS_START_EXAMPLES_COUNT) {
            posExamples.add(ex);
          }
        }
 else {
          if (negExamples.size() < NR_OF_NEG_START_EXAMPLES_COUNT) {
            negExamples.add(ex);
          }
        }
      }
      if (posExamples.isEmpty()) {
        logger.warn(""String_Node_Str"" + TOP_K + ""String_Node_Str""+ ""String_Node_Str"");
        continue;
      }
      logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str""+ posExamples);
      logger.info(""String_Node_Str"" + negExamples.size() + ""String_Node_Str""+ negExamples);
      Set<String> learnedResources;
      do {
        logger.info(""String_Node_Str"");
        long startTime=System.currentTimeMillis();
        String example=exFinder.findSimilarExample(posExamples,negExamples).getURI();
        logger.info(""String_Node_Str"" + example + ""String_Node_Str""+ (System.currentTimeMillis() - startTime)+ ""String_Node_Str"");
        String learnedQuery=exFinder.getCurrentQuery();
        logger.info(""String_Node_Str"" + learnedQuery);
        learnedQuery=""String_Node_Str"" + learnedQuery.substring(7);
        learnedResources=getResourcesBySPARQLQuery(learnedQuery);
        logger.info(""String_Node_Str"" + learnedResources.size());
        if (answers.contains(example)) {
          posExamples.add(example);
        }
 else {
          negExamples.add(example);
        }
      }
 while (answers.equals(learnedResources));
      logger.info(""String_Node_Str"" + question + ""String_Node_Str"");
    }
 catch (    TimeOutException e) {
      e.printStackTrace();
    }
catch (    SPARQLQueryException e) {
      e.printStackTrace();
    }
catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
  }
}","public void evaluate(){
  String targetQuery;
  Set<String> answers;
  List<String> examples;
  Set<String> relatedResources;
  List<String> relevantWords;
  int i=1;
  for (  String question : question2Answers.keySet()) {
    question=""String_Node_Str"";
    logger.info(getNewQuestionString(i++,question));
    try {
      logger.info(""String_Node_Str"" + question + ""String_Node_Str"");
      targetQuery=question2query.get(question);
      logger.info(""String_Node_Str"" + targetQuery);
      answers=question2Answers.get(question);
      logger.info(""String_Node_Str"" + answers.size() + ""String_Node_Str""+ answers);
      relevantWords=getRelevantWords(question);
      QuestionBasedStatementFilter filter=new QuestionBasedStatementFilter(new HashSet<String>(relevantWords));
      filter.setThreshold(SIMILARITY_THRESHOLD);
      exFinder.setStatementFilter(filter);
      if (USE_SYNONYMS) {
        relevantWords.addAll(getSynonyms(relevantWords));
        logger.info(""String_Node_Str"" + relevantWords);
      }
      question=""String_Node_Str"";
      for (      String word : relevantWords) {
        question+=""String_Node_Str"" + word;
      }
      question.trim();
      logger.info(""String_Node_Str"" + question);
      if (USE_WIKIPEDIA_SEARCH) {
        examples=getResourcesByWikipedia(question);
      }
 else {
        examples=getResourcesByNLQueryWithLucene(question);
      }
      List<String> posExamples=new ArrayList<String>();
      List<String> negExamples=new ArrayList<String>();
      for (      String ex : examples) {
        if (answers.contains(ex)) {
          if (posExamples.size() < NR_OF_POS_START_EXAMPLES_COUNT) {
            posExamples.add(ex);
          }
        }
 else {
          if (negExamples.size() < NR_OF_NEG_START_EXAMPLES_COUNT) {
            negExamples.add(ex);
          }
        }
      }
      if (posExamples.size() < NR_OF_POS_START_EXAMPLES_COUNT) {
        logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str"");
        for (        String answer : answers) {
          posExamples.add(answer);
          if (posExamples.size() == NR_OF_POS_START_EXAMPLES_COUNT) {
            break;
          }
        }
      }
      if (posExamples.isEmpty()) {
        logger.warn(""String_Node_Str"" + TOP_K + ""String_Node_Str""+ ""String_Node_Str"");
        continue;
      }
      logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str""+ posExamples);
      logger.info(""String_Node_Str"" + negExamples.size() + ""String_Node_Str""+ negExamples);
      Set<String> learnedResources;
      do {
        logger.info(""String_Node_Str"");
        long startTime=System.currentTimeMillis();
        String example=exFinder.findSimilarExample(posExamples,negExamples).getURI();
        logger.info(""String_Node_Str"" + example + ""String_Node_Str""+ (System.currentTimeMillis() - startTime)+ ""String_Node_Str"");
        String learnedQuery=exFinder.getCurrentQuery();
        logger.info(""String_Node_Str"" + learnedQuery);
        learnedQuery=""String_Node_Str"" + learnedQuery.substring(7);
        learnedResources=getResourcesBySPARQLQuery(learnedQuery);
        logger.info(""String_Node_Str"" + learnedResources.size());
        if (answers.contains(example)) {
          posExamples.add(example);
        }
 else {
          negExamples.add(example);
        }
      }
 while (answers.equals(learnedResources));
      logger.info(""String_Node_Str"" + question + ""String_Node_Str"");
    }
 catch (    TimeOutException e) {
      e.printStackTrace();
    }
catch (    SPARQLQueryException e) {
      e.printStackTrace();
    }
catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
  }
}"
9679,"/** 
 * @param args
 */
public static void main(String[] args){
  String question=""String_Node_Str"";
  String uri=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + question + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + uri);
  QueryTreeFactory<String> treeFactory=new QueryTreeFactoryImpl();
  QuestionProcessor qProcessor=new QuestionProcessor();
  List<String> predicateFilters=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ModelGenerator modelGen=new ModelGenerator(SparqlEndpoint.getEndpointDBpediaLiveAKSW(),new HashSet<String>(predicateFilters),new ExtractionDBCache(""String_Node_Str""));
  List<String> relevantWords=qProcessor.getRelevantWords(question);
  System.out.println(""String_Node_Str"" + relevantWords);
  Model model=modelGen.createModel(uri,Strategy.CHUNKS,2);
  QueryTree<String> tree=treeFactory.getQueryTree(uri,model);
  System.out.println(""String_Node_Str"" + tree.getStringRepresentation());
  treeFactory.setStatementSelector(new QuestionBasedStatementSelector(new HashSet<String>(relevantWords)));
  treeFactory.setStatementFilter(new QuestionBasedStatementFilter(new HashSet<String>(relevantWords)));
  QueryTree<String> filteredTree=treeFactory.getQueryTree(uri,model);
  System.out.println(""String_Node_Str"" + filteredTree.getStringRepresentation());
}","/** 
 * @param args
 */
public static void main(String[] args){
  String question=""String_Node_Str"";
  String uri=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + question + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + uri);
  QueryTreeFactory<String> treeFactory=new QueryTreeFactoryImpl();
  QuestionProcessor qProcessor=new QuestionProcessor();
  List<String> predicateFilters=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ModelGenerator modelGen=new ModelGenerator(SparqlEndpoint.getEndpointDBpediaLiveAKSW(),new HashSet<String>(predicateFilters),new ExtractionDBCache(""String_Node_Str""));
  List<String> relevantWords=qProcessor.getRelevantWords(question);
  System.out.println(""String_Node_Str"" + relevantWords);
  Model model=modelGen.createModel(uri,Strategy.CHUNKS,2);
  QueryTree<String> tree=treeFactory.getQueryTree(uri,model);
  System.out.println(""String_Node_Str"" + tree.getStringRepresentation());
  treeFactory.setStatementFilter(new QuestionBasedStatementFilter(new HashSet<String>(relevantWords)));
  QueryTree<String> filteredTree=treeFactory.getQueryTree(uri,model);
  System.out.println(""String_Node_Str"" + filteredTree.getStringRepresentation());
}"
9680,"public Example findSimilarExample(List<String> posExamples,List<String> negExamples) throws SPARQLQueryException, TimeOutException {
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"" + posExamples);
  logger.info(""String_Node_Str"" + negExamples);
  this.posExamples=posExamples;
  this.negExamples=negExamples;
  List<QueryTree<String>> posExampleTrees=new ArrayList<QueryTree<String>>();
  List<QueryTree<String>> negExampleTrees=new ArrayList<QueryTree<String>>();
  Model model;
  QueryTree<String> queryTree;
  for (  String resource : posExamples) {
    model=modelCache.getModel(resource);
    queryTree=queryTreeCache.getQueryTree(resource,model);
    System.out.println(queryTree.getStringRepresentation());
    posExampleTrees.add(queryTree);
  }
  for (  String resource : negExamples) {
    model=modelCache.getModel(resource);
    queryTree=queryTreeCache.getQueryTree(resource,model);
    negExampleTrees.add(queryTree);
  }
  if (posExamples.size() == 1 && negExamples.isEmpty()) {
    logger.info(""String_Node_Str"");
    return findExampleByGeneralisation(posExampleTrees.get(0));
  }
 else   if (negExamples.isEmpty()) {
    logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str""+ negExamples.size()+ ""String_Node_Str"");
    return findExampleByLGG(posExampleTrees,negExampleTrees);
  }
 else {
    return findExampleByNBR(posExampleTrees,negExampleTrees);
  }
}","public Example findSimilarExample(List<String> posExamples,List<String> negExamples) throws SPARQLQueryException, TimeOutException {
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"" + posExamples);
  logger.info(""String_Node_Str"" + negExamples);
  this.posExamples=posExamples;
  this.negExamples=negExamples;
  List<QueryTree<String>> posExampleTrees=new ArrayList<QueryTree<String>>();
  List<QueryTree<String>> negExampleTrees=new ArrayList<QueryTree<String>>();
  Model model;
  QueryTree<String> queryTree;
  for (  String resource : posExamples) {
    model=modelCache.getModel(resource);
    queryTree=queryTreeCache.getQueryTree(resource,model);
    System.out.println(TreeHelper.getAbbreviatedTreeRepresentation(queryTree,endpoint.getBaseURI(),endpoint.getPrefixes()));
    posExampleTrees.add(queryTree);
  }
  for (  String resource : negExamples) {
    model=modelCache.getModel(resource);
    queryTree=queryTreeCache.getQueryTree(resource,model);
    negExampleTrees.add(queryTree);
  }
  if (posExamples.size() == 1 && negExamples.isEmpty()) {
    logger.info(""String_Node_Str"");
    return findExampleByGeneralisation(posExampleTrees.get(0));
  }
 else   if (negExamples.isEmpty()) {
    logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str""+ negExamples.size()+ ""String_Node_Str"");
    return findExampleByLGG(posExampleTrees,negExampleTrees);
  }
 else {
    return findExampleByNBR(posExampleTrees,negExampleTrees);
  }
}"
9681,"private void fillMap(Resource s,Model model,SortedMap<String,SortedSet<Statement>> resource2Statements){
  Iterator<Statement> it=model.listStatements(s,null,(RDFNode)null).filterKeep(keepFilter);
  Statement st;
  SortedSet<Statement> statements;
  while (it.hasNext()) {
    st=it.next();
    statements=resource2Statements.get(st.getSubject().toString());
    if (statements == null) {
      statements=new TreeSet<Statement>(comparator);
      resource2Statements.put(st.getSubject().toString(),statements);
    }
    statements.add(st);
    if (st.getObject().isURIResource()) {
      fillMap(st.getObject().asResource(),model,resource2Statements);
    }
  }
}","private void fillMap(Resource s,Model model,SortedMap<String,SortedSet<Statement>> resource2Statements){
  Iterator<Statement> it=model.listStatements(s,null,(RDFNode)null).filterKeep(keepFilter);
  Statement st;
  SortedSet<Statement> statements;
  while (it.hasNext()) {
    st=it.next();
    statements=resource2Statements.get(st.getSubject().toString());
    if (statements == null) {
      statements=new TreeSet<Statement>(comparator);
      resource2Statements.put(st.getSubject().toString(),statements);
    }
    statements.add(st);
    if (st.getObject().isURIResource() && !resource2Statements.containsKey(st.getObject().asResource().getURI())) {
      fillMap(st.getObject().asResource(),model,resource2Statements);
    }
  }
}"
9682,"public QuestionBasedStatementFilter(Set<String> questionWords){
  this.questionWords=questionWords;
  metric=new QGramsDistance();
}","public QuestionBasedStatementFilter(Set<String> questionWords){
  this.questionWords=questionWords;
  qGramMetric=new QGramsDistance();
  levensteinMetric=new Levenshtein();
  jaroWinklerMetric=new JaroWinkler();
}"
9683,"private boolean areSimiliar(String s1,String s2){
  float sim=metric.getSimilarity(s1,s2);
  return sim >= threshold;
}","private boolean areSimiliar(String s1,String s2){
  float qSim=qGramMetric.getSimilarity(s1,s2);
  float lSim=levensteinMetric.getSimilarity(s1,s2);
  float jSim=jaroWinklerMetric.getSimilarity(s1,s2);
  float sim=Math.max(Math.max(qSim,lSim),jSim);
  return sim >= threshold;
}"
9684,"private Example findExampleByNBR(List<QueryTree<String>> posExamplesTrees,List<QueryTree<String>> negExamplesTrees){
  LGGGenerator<String> lggGen=new LGGGeneratorImpl<String>();
  lgg=lggGen.getLGG(posExamplesTrees);
  logger.info(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(lgg,endpoint.getBaseURI(),endpoint.getPrefixes()));
  logger.info(""String_Node_Str"" + lgg.toSPARQLQueryString());
  logger.info(""String_Node_Str"" + getResources(lgg.toSPARQLQueryString()).size());
  logger.info(""String_Node_Str"");
  List<String> knownResources=new ArrayList<String>();
  knownResources.addAll(posExamples);
  knownResources.addAll(negExamples);
  Example example=null;
  try {
    String uri=nbrGen.getQuestion(lgg,negExamplesTrees,knownResources);
    example=getExample(uri);
  }
 catch (  TimeOutException e) {
    e.printStackTrace();
  }
  example=getExample(example.getURI());
  currentQuery=nbrGen.getQuery();
  return example;
}","private Example findExampleByNBR(List<QueryTree<String>> posExamplesTrees,List<QueryTree<String>> negExamplesTrees){
  LGGGenerator<String> lggGen=new LGGGeneratorImpl<String>();
  lgg=lggGen.getLGG(posExamplesTrees);
  logger.info(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(lgg,endpoint.getBaseURI(),endpoint.getPrefixes()));
  logger.info(""String_Node_Str"" + lgg.toSPARQLQueryString());
  logger.info(""String_Node_Str"" + getAllResources(lgg.toSPARQLQueryString()).size());
  logger.info(""String_Node_Str"");
  List<String> knownResources=new ArrayList<String>();
  knownResources.addAll(posExamples);
  knownResources.addAll(negExamples);
  Example example=null;
  try {
    String uri=nbrGen.getQuestion(lgg,negExamplesTrees,knownResources);
    example=getExample(uri);
  }
 catch (  TimeOutException e) {
    e.printStackTrace();
  }
  example=getExample(example.getURI());
  currentQuery=nbrGen.getQuery();
  return example;
}"
9685,"public void setStatementFilter(com.hp.hpl.jena.util.iterator.Filter<Statement> filter){
  queryTreeCache.setStatementFilter(filter);
}","public void setStatementFilter(com.hp.hpl.jena.util.iterator.Filter<Statement> filter){
  queryTreeCache.setStatementFilter(filter);
  nbrGen.setStatementFilter(filter);
}"
9686,"private void learnPosOnly(){
  resultQueries.clear();
  resultTrees.clear();
  if (posQueryTrees.size() == 2 || newPosExample != null) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"");
    }
    Monitor monitor=MonitorFactory.getTimeMonitor(""String_Node_Str"");
    monitor.start();
    if (posQueryTrees.size() == 2) {
      lgg=lggGenerator.getLGG(posQueryTrees);
    }
 else {
      lgg=lggGenerator.getLGG(lgg,newPosExample);
    }
    monitor.stop();
    newPosExample=null;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"");
      logger.debug(lgg.getStringRepresentation());
      logger.debug(""String_Node_Str"" + monitor.getTotal() + ""String_Node_Str"");
    }
  }
  resultQueries.add(lgg.toSPARQLQueryString(true));
  resultTrees.add(lgg);
}","private void learnPosOnly(){
  resultQueries.clear();
  resultTrees.clear();
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
  }
  Monitor monitor=MonitorFactory.getTimeMonitor(""String_Node_Str"");
  monitor.start();
  lgg=lggGenerator.getLGG(posQueryTrees);
  monitor.stop();
  newPosExample=null;
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
    logger.debug(lgg.getStringRepresentation());
    logger.debug(""String_Node_Str"" + monitor.getTotal() + ""String_Node_Str"");
  }
  resultQueries.add(lgg.toSPARQLQueryString(true));
  resultTrees.add(lgg);
}"
9687,"private void limitEqualEdgesToLeafs(QueryTree<N> tree,int maxEqualEdgeCount){
  Set<QueryTree<N>> parents=new HashSet<QueryTree<N>>();
  for (  QueryTree<N> leaf : tree.getLeafs()) {
    if (leaf.getUserObject().equals(""String_Node_Str"")) {
      parents.add(leaf.getParent());
    }
  }
  for (  QueryTree<N> parent : parents) {
    for (    Object edge : parent.getEdges()) {
      int cnt=0;
      boolean existsResourceChild=false;
      for (      QueryTree<N> child : parent.getChildren(edge)) {
        if (!child.getUserObject().equals(""String_Node_Str"")) {
          existsResourceChild=true;
          break;
        }
      }
      for (      QueryTree<N> child : parent.getChildren(edge)) {
        if (child.getUserObject().equals(""String_Node_Str"")) {
          if (child.isLeaf()) {
            cnt++;
            if (existsResourceChild || cnt > maxEqualEdgeCount) {
              parent.removeChild((QueryTreeImpl<N>)child);
            }
          }
        }
      }
    }
  }
}","private void limitEqualEdgesToLeafs(QueryTree<N> tree,int maxEqualEdgeCount){
  if (tree.getChildren().isEmpty()) {
    return;
  }
  Set<QueryTree<N>> parents=new HashSet<QueryTree<N>>();
  for (  QueryTree<N> leaf : tree.getLeafs()) {
    if (leaf.getUserObject().equals(""String_Node_Str"")) {
      parents.add(leaf.getParent());
    }
  }
  for (  QueryTree<N> parent : parents) {
    for (    Object edge : parent.getEdges()) {
      int cnt=0;
      boolean existsResourceChild=false;
      for (      QueryTree<N> child : parent.getChildren(edge)) {
        if (!child.getUserObject().equals(""String_Node_Str"")) {
          existsResourceChild=true;
          break;
        }
      }
      for (      QueryTree<N> child : parent.getChildren(edge)) {
        if (child.getUserObject().equals(""String_Node_Str"")) {
          if (child.isLeaf()) {
            cnt++;
            if (existsResourceChild || cnt > maxEqualEdgeCount) {
              parent.removeChild((QueryTreeImpl<N>)child);
            }
          }
        }
      }
    }
  }
}"
9688,"private SortedSet<String> getAllResources(String query){
  SortedSet<String> resources=new TreeSet<String>();
  String result=selectCache.executeSelectQuery(endpoint,getLimitedQuery(currentQuery,1000,true));
  testedQueries.add(currentQuery);
  ResultSetRewindable rs=SparqlQuery.convertJSONtoResultSet(result);
  String uri;
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    uri=qs.getResource(""String_Node_Str"").getURI();
    resources.add(uri);
  }
  return resources;
}","private SortedSet<String> getAllResources(String query){
  SortedSet<String> resources=new TreeSet<String>();
  query=getLimitedQuery(query,1000,true);
  System.err.println(query);
  String result=selectCache.executeSelectQuery(endpoint,query);
  testedQueries.add(query);
  ResultSetRewindable rs=SparqlQuery.convertJSONtoResultSet(result);
  String uri;
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    uri=qs.getResource(""String_Node_Str"").getURI();
    resources.add(uri);
  }
  return resources;
}"
9689,"private SortedSet<String> getResources(String query){
  SortedSet<String> resources=new TreeSet<String>();
  String result=selectCache.executeSelectQuery(endpoint,getLimitedQuery(currentQuery,(posExamples.size() + negExamples.size() + 1),true));
  testedQueries.add(currentQuery);
  ResultSetRewindable rs=SparqlQuery.convertJSONtoResultSet(result);
  String uri;
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    uri=qs.getResource(""String_Node_Str"").getURI();
    resources.add(uri);
  }
  return resources;
}","private SortedSet<String> getResources(String query){
  SortedSet<String> resources=new TreeSet<String>();
  String result=selectCache.executeSelectQuery(endpoint,getLimitedQuery(query,(posExamples.size() + negExamples.size() + 1),true));
  testedQueries.add(query);
  ResultSetRewindable rs=SparqlQuery.convertJSONtoResultSet(result);
  String uri;
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    uri=qs.getResource(""String_Node_Str"").getURI();
    resources.add(uri);
  }
  return resources;
}"
9690,"/** 
 * @param args
 * @throws SPARQLQueryException 
 * @throws TimeOutException 
 * @throws SolrServerException 
 * @throws ParserConfigurationException 
 * @throws IOException 
 * @throws SAXException 
 */
public static void main(String[] args) throws TimeOutException, SPARQLQueryException, SolrServerException, ParserConfigurationException, SAXException, IOException {
  Logger.getLogger(Generalisation.class).setLevel(Level.OFF);
  Logger.getLogger(LGGGeneratorImpl.class).setLevel(Level.OFF);
  Logger.getLogger(NBR.class).setLevel(Level.DEBUG);
  Logger.getRootLogger().removeAllAppenders();
  Layout layout=new PatternLayout(""String_Node_Str"");
  ConsoleAppender appender=new ConsoleAppender(layout);
  Logger.getRootLogger().addAppender(appender);
  FileAppender fileAppender=new FileAppender(layout,""String_Node_Str"",false);
  fileAppender.setThreshold(Level.DEBUG);
  Logger.getRootLogger().addAppender(fileAppender);
  FileAppender fileAppender2=new FileAppender(layout,""String_Node_Str"",false);
  fileAppender2.setThreshold(Level.INFO);
  Logger.getLogger(""String_Node_Str"").addAppender(fileAppender2);
  new EvaluationWithNLQueriesScript().evaluate();
}","/** 
 * @param args
 * @throws SPARQLQueryException 
 * @throws TimeOutException 
 * @throws SolrServerException 
 * @throws ParserConfigurationException 
 * @throws IOException 
 * @throws SAXException 
 */
public static void main(String[] args) throws TimeOutException, SPARQLQueryException, SolrServerException, ParserConfigurationException, SAXException, IOException {
  Logger.getLogger(Generalisation.class).setLevel(Level.OFF);
  Logger.getLogger(LGGGeneratorImpl.class).setLevel(Level.OFF);
  Logger.getLogger(NBR.class).setLevel(Level.DEBUG);
  Logger.getRootLogger().removeAllAppenders();
  Layout layout=new PatternLayout(""String_Node_Str"");
  ConsoleAppender appender=new ConsoleAppender(layout);
  Logger.getRootLogger().addAppender(appender);
  FileAppender fileAppender=new FileAppender(layout,""String_Node_Str"",false);
  fileAppender.setThreshold(Level.DEBUG);
  Logger.getRootLogger().addAppender(fileAppender);
  FileAppender fileAppender2=new FileAppender(layout,""String_Node_Str"",false);
  fileAppender2.setThreshold(Level.INFO);
  Logger.getLogger(""String_Node_Str"").removeAllAppenders();
  Logger.getLogger(""String_Node_Str"").addAppender(fileAppender2);
  new EvaluationWithNLQueriesScript().evaluate();
}"
9691,"public void evaluate(){
  String targetQuery;
  Set<String> answers;
  List<String> examples;
  Set<String> relatedResources;
  List<String> relevantWords;
  int i=1;
  int learnedQueries=0;
  for (  String question : question2Answers.keySet()) {
    logger.debug(getNewQuestionString(i++,question));
    miniLogger.info(""String_Node_Str"" + question);
    try {
      targetQuery=question2query.get(question);
      logger.debug(""String_Node_Str"" + targetQuery);
      miniLogger.info(""String_Node_Str"" + targetQuery);
      answers=getResourcesBySPARQLQuery(targetQuery,""String_Node_Str"");
      logger.debug(""String_Node_Str"" + answers.size() + ""String_Node_Str""+ answers);
      miniLogger.info(""String_Node_Str"" + answers.size() + ""String_Node_Str""+ answers);
      relevantWords=getRelevantWords(question);
      QuestionBasedStatementFilter filter=new QuestionBasedStatementFilter(new HashSet<String>(relevantWords));
      filter.setThreshold(SIMILARITY_THRESHOLD);
      exFinder.setStatementFilter(filter);
      if (USE_SYNONYMS) {
        relevantWords.addAll(getSynonyms(relevantWords));
        logger.debug(""String_Node_Str"" + relevantWords);
      }
      question=""String_Node_Str"";
      for (      String word : relevantWords) {
        question+=""String_Node_Str"" + word;
      }
      question.trim();
      logger.debug(""String_Node_Str"" + question);
      if (USE_WIKIPEDIA_SEARCH) {
        examples=getResourcesByWikipedia(question);
      }
 else {
        examples=getResourcesByNLQueryWithLucene(question);
      }
      List<String> posExamples=new ArrayList<String>();
      List<String> negExamples=new ArrayList<String>();
      for (      String ex : examples) {
        if (answers.contains(ex)) {
          if (posExamples.size() < NR_OF_POS_START_EXAMPLES_COUNT) {
            miniLogger.info(""String_Node_Str"" + ex + ""String_Node_Str"");
            posExamples.add(ex);
          }
        }
 else {
          if (negExamples.size() < NR_OF_NEG_START_EXAMPLES_COUNT) {
            miniLogger.info(""String_Node_Str"" + ex + ""String_Node_Str"");
            negExamples.add(ex);
          }
        }
      }
      miniLogger.info(""String_Node_Str"" + posExamples);
      if (posExamples.size() < NR_OF_POS_START_EXAMPLES_COUNT) {
        logger.debug(""String_Node_Str"" + posExamples.size() + ""String_Node_Str"");
        for (        String answer : answers) {
          posExamples.add(answer);
          if (posExamples.size() == NR_OF_POS_START_EXAMPLES_COUNT) {
            break;
          }
        }
      }
      if (posExamples.isEmpty()) {
        logger.warn(""String_Node_Str"" + TOP_K + ""String_Node_Str""+ ""String_Node_Str"");
        continue;
      }
      logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str""+ posExamples);
      logger.info(""String_Node_Str"" + negExamples.size() + ""String_Node_Str""+ negExamples);
      Set<String> learnedResources;
      String oldLearnedQuery=""String_Node_Str"";
      boolean learningFailed=false;
      do {
        logger.info(""String_Node_Str"");
        long startTime=System.currentTimeMillis();
        String example=exFinder.findSimilarExample(posExamples,negExamples).getURI();
        logger.debug(""String_Node_Str"" + example + ""String_Node_Str""+ (System.currentTimeMillis() - startTime)+ ""String_Node_Str"");
        miniLogger.info(""String_Node_Str"" + example + ""String_Node_Str"");
        String learnedQuery=exFinder.getCurrentQuery();
        if (oldLearnedQuery.equals(learnedQuery)) {
          learningFailed=true;
          logger.info(""String_Node_Str"");
          break;
        }
        oldLearnedQuery=learnedQuery;
        logger.debug(""String_Node_Str"" + learnedQuery);
        learnedQuery=""String_Node_Str"" + learnedQuery.substring(7);
        learnedResources=getResourcesBySPARQLQuery(learnedQuery,""String_Node_Str"");
        logger.debug(""String_Node_Str"" + learnedResources.size());
        if (answers.contains(example)) {
          posExamples.add(example);
          miniLogger.info(""String_Node_Str"");
        }
 else {
          negExamples.add(example);
          miniLogger.info(""String_Node_Str"");
        }
        miniLogger.info(""String_Node_Str"" + learnedQuery);
      }
 while (!answers.equals(learnedResources));
      if (!learningFailed) {
        logger.info(""String_Node_Str"" + question + ""String_Node_Str"");
        miniLogger.info(""String_Node_Str"");
        learnedQueries++;
      }
 else {
        miniLogger.info(""String_Node_Str"");
      }
    }
 catch (    TimeOutException e) {
      e.printStackTrace();
    }
catch (    SPARQLQueryException e) {
      e.printStackTrace();
    }
catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      miniLogger.info(""String_Node_Str"");
    }
  }
  logger.info(""String_Node_Str"" + learnedQueries + ""String_Node_Str""+ question2query.keySet().size()+ ""String_Node_Str"");
}","public void evaluate(){
  String targetQuery;
  Set<String> answers;
  List<String> examples;
  Set<String> relatedResources;
  List<String> relevantWords;
  int i=1;
  int learnedQueries=0;
  for (  String question : question2Answers.keySet()) {
    logger.debug(getNewQuestionString(i++,question));
    try {
      targetQuery=question2query.get(question);
      logger.debug(""String_Node_Str"" + targetQuery);
      answers=getResourcesBySPARQLQuery(targetQuery,""String_Node_Str"");
      logger.debug(""String_Node_Str"" + answers.size() + ""String_Node_Str""+ answers);
      printStartingPosition(i,question,targetQuery,answers);
      relevantWords=getRelevantWords(question);
      QuestionBasedStatementFilter filter=new QuestionBasedStatementFilter(new HashSet<String>(relevantWords));
      filter.setThreshold(SIMILARITY_THRESHOLD);
      exFinder.setStatementFilter(filter);
      if (USE_SYNONYMS) {
        relevantWords.addAll(getSynonyms(relevantWords));
        logger.debug(""String_Node_Str"" + relevantWords);
      }
      question=""String_Node_Str"";
      for (      String word : relevantWords) {
        question+=""String_Node_Str"" + word;
      }
      question.trim();
      logger.debug(""String_Node_Str"" + question);
      if (USE_WIKIPEDIA_SEARCH) {
        examples=getResourcesByWikipedia(question);
      }
 else {
        examples=getResourcesByNLQueryWithLucene(question);
      }
      miniLogger.info(""String_Node_Str"" + examples);
      List<String> posExamples=new ArrayList<String>();
      List<String> negExamples=new ArrayList<String>();
      for (      String ex : examples) {
        if (answers.contains(ex)) {
          if (posExamples.size() < NR_OF_POS_START_EXAMPLES_COUNT) {
            miniLogger.info(""String_Node_Str"" + ex + ""String_Node_Str"");
            posExamples.add(ex);
          }
        }
 else {
          if (negExamples.size() < NR_OF_NEG_START_EXAMPLES_COUNT) {
            negExamples.add(ex);
          }
        }
      }
      if (posExamples.size() < NR_OF_POS_START_EXAMPLES_COUNT) {
        logger.debug(""String_Node_Str"" + posExamples.size() + ""String_Node_Str"");
        miniLogger.info(""String_Node_Str"" + (NR_OF_POS_START_EXAMPLES_COUNT - posExamples.size()) + ""String_Node_Str"");
        for (        String answer : answers) {
          if (posExamples.add(answer)) {
            miniLogger.info(""String_Node_Str"" + answer + ""String_Node_Str"");
          }
          if (posExamples.size() == NR_OF_POS_START_EXAMPLES_COUNT) {
            break;
          }
        }
      }
      if (posExamples.isEmpty()) {
        logger.warn(""String_Node_Str"" + TOP_K + ""String_Node_Str""+ ""String_Node_Str"");
        continue;
      }
      logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str""+ posExamples);
      logger.info(""String_Node_Str"" + negExamples.size() + ""String_Node_Str""+ negExamples);
      miniLogger.info(""String_Node_Str"");
      if (LGGIsSolution(posExamples,answers)) {
        logger.info(""String_Node_Str"");
        miniLogger.info(""String_Node_Str"");
        continue;
      }
      Set<String> learnedResources;
      String oldLearnedQuery=""String_Node_Str"";
      boolean learningFailed=false;
      do {
        logger.info(""String_Node_Str"");
        long startTime=System.currentTimeMillis();
        String example=exFinder.findSimilarExample(posExamples,negExamples).getURI();
        logger.debug(""String_Node_Str"" + example + ""String_Node_Str""+ (System.currentTimeMillis() - startTime)+ ""String_Node_Str"");
        miniLogger.info(""String_Node_Str"" + example + ""String_Node_Str"");
        String learnedQuery=exFinder.getCurrentQuery();
        if (oldLearnedQuery.equals(learnedQuery)) {
          learningFailed=true;
          logger.info(""String_Node_Str"");
          break;
        }
        oldLearnedQuery=learnedQuery;
        logger.debug(""String_Node_Str"" + learnedQuery);
        learnedQuery=""String_Node_Str"" + learnedQuery.substring(7);
        learnedResources=getResourcesBySPARQLQuery(learnedQuery,""String_Node_Str"");
        logger.debug(""String_Node_Str"" + learnedResources.size());
        if (answers.contains(example)) {
          posExamples.add(example);
          miniLogger.info(""String_Node_Str"");
        }
 else {
          negExamples.add(example);
          miniLogger.info(""String_Node_Str"");
        }
        miniLogger.info(""String_Node_Str"" + learnedQuery);
      }
 while (!answers.equals(learnedResources));
      if (!learningFailed) {
        logger.info(""String_Node_Str"" + question + ""String_Node_Str"");
        miniLogger.info(""String_Node_Str"");
        learnedQueries++;
      }
 else {
        miniLogger.info(""String_Node_Str"");
      }
    }
 catch (    TimeOutException e) {
      e.printStackTrace();
    }
catch (    SPARQLQueryException e) {
      e.printStackTrace();
    }
catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      miniLogger.info(""String_Node_Str"");
    }
  }
  logger.info(""String_Node_Str"" + learnedQueries + ""String_Node_Str""+ question2query.keySet().size()+ ""String_Node_Str"");
}"
9692,"private Example findExampleByNBR(List<QueryTree<String>> posExamplesTrees,List<QueryTree<String>> negExamplesTrees){
  logger.info(""String_Node_Str"");
  LGGGenerator<String> lggGen=new LGGGeneratorImpl<String>();
  lgg=lggGen.getLGG(posExamplesTrees);
  logger.info(""String_Node_Str"" + lgg.getStringRepresentation());
  List<String> knownResources=new ArrayList<String>();
  knownResources.addAll(posExamples);
  knownResources.addAll(negExamples);
  Example example=null;
  try {
    example=findExampleByLGG(posExamplesTrees,negExamplesTrees);
  }
 catch (  SPARQLQueryException e1) {
    e1.printStackTrace();
  }
  if (example != null) {
    return example;
  }
  try {
    String uri=nbrGen.getQuestion(lgg,negExamplesTrees,knownResources);
    example=getExample(uri);
  }
 catch (  TimeOutException e) {
    e.printStackTrace();
  }
  example=getExample(example.getURI());
  currentQuery=nbrGen.getQuery();
  return example;
}","private Example findExampleByNBR(List<QueryTree<String>> posExamplesTrees,List<QueryTree<String>> negExamplesTrees){
  logger.info(""String_Node_Str"");
  LGGGenerator<String> lggGen=new LGGGeneratorImpl<String>();
  List<String> knownResources=new ArrayList<String>();
  knownResources.addAll(posExamples);
  knownResources.addAll(negExamples);
  Example example=null;
  try {
    String uri=nbrGen.getQuestion(lgg,negExamplesTrees,knownResources);
    example=getExample(uri);
  }
 catch (  TimeOutException e) {
    e.printStackTrace();
  }
  example=getExample(example.getURI());
  currentQuery=nbrGen.getQuery();
  return example;
}"
9693,"public Example findSimilarExample(List<String> posExamples,List<String> negExamples) throws SPARQLQueryException, TimeOutException {
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"" + posExamples);
  logger.info(""String_Node_Str"" + negExamples);
  this.posExamples=posExamples;
  this.negExamples=negExamples;
  List<QueryTree<String>> posExampleTrees=new ArrayList<QueryTree<String>>();
  List<QueryTree<String>> negExampleTrees=new ArrayList<QueryTree<String>>();
  Model model;
  QueryTree<String> queryTree;
  for (  String resource : posExamples) {
    model=modelCache.getModel(resource);
    queryTree=queryTreeCache.getQueryTree(resource,model);
    System.out.println(""String_Node_Str"" + resource + ""String_Node_Str""+ TreeHelper.getAbbreviatedTreeRepresentation(queryTree,endpoint.getBaseURI(),endpoint.getPrefixes()));
    posExampleTrees.add(queryTree);
  }
  for (  String resource : negExamples) {
    model=modelCache.getModel(resource);
    queryTree=queryTreeCache.getQueryTree(resource,model);
    negExampleTrees.add(queryTree);
  }
  if (posExamples.size() == 1 && negExamples.isEmpty()) {
    logger.info(""String_Node_Str"");
    return findExampleByGeneralisation(posExampleTrees.get(0));
  }
 else   if (negExamples.isEmpty()) {
    logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str""+ negExamples.size()+ ""String_Node_Str"");
    Example ex=findExampleByLGG(posExampleTrees,negExampleTrees);
    if (ex == null) {
      return findExampleByGeneralisation(currentQueryTree);
    }
 else {
      return ex;
    }
  }
 else {
    return findExampleByNBR(posExampleTrees,negExampleTrees);
  }
}","public Example findSimilarExample(List<String> posExamples,List<String> negExamples) throws SPARQLQueryException, TimeOutException {
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"" + posExamples);
  logger.info(""String_Node_Str"" + negExamples);
  this.posExamples=posExamples;
  this.negExamples=negExamples;
  List<QueryTree<String>> posExampleTrees=new ArrayList<QueryTree<String>>();
  List<QueryTree<String>> negExampleTrees=new ArrayList<QueryTree<String>>();
  Model model;
  QueryTree<String> queryTree;
  for (  String resource : posExamples) {
    model=modelCache.getModel(resource);
    queryTree=queryTreeCache.getQueryTree(resource,model);
    posExampleTrees.add(queryTree);
  }
  for (  String resource : negExamples) {
    model=modelCache.getModel(resource);
    queryTree=queryTreeCache.getQueryTree(resource,model);
    negExampleTrees.add(queryTree);
  }
  if (posExamples.size() == 1 && negExamples.isEmpty()) {
    logger.info(""String_Node_Str"");
    return findExampleByGeneralisation(posExampleTrees.get(0));
  }
 else   if (negExamples.isEmpty()) {
    logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str""+ negExamples.size()+ ""String_Node_Str"");
    Example ex=findExampleByLGG(posExampleTrees,negExampleTrees);
    if (ex == null) {
      return findExampleByGeneralisation(currentQueryTree);
    }
 else {
      return ex;
    }
  }
 else {
    return findExampleByNBR(posExampleTrees,negExampleTrees);
  }
}"
9694,"private Set<String> getResourcesBySPARQLQuery(String query){
  logger.info(""String_Node_Str"");
  long startTime=System.currentTimeMillis();
  Set<String> resources=new HashSet<String>();
  ResultSet rs=SparqlQuery.convertJSONtoResultSet(selectCache.executeSelectQuery(ENDPOINT,query));
  while (rs.hasNext()) {
    resources.add(rs.nextSolution().get(""String_Node_Str"").asResource().getURI());
  }
  logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
  return resources;
}","private Set<String> getResourcesBySPARQLQuery(String query,String varName){
  logger.info(""String_Node_Str"");
  long startTime=System.currentTimeMillis();
  Set<String> resources=new HashSet<String>();
  ResultSet rs=SparqlQuery.convertJSONtoResultSet(selectCache.executeSelectQuery(ENDPOINT,query));
  while (rs.hasNext()) {
    resources.add(rs.nextSolution().get(varName).asResource().getURI());
  }
  logger.info(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
  return resources;
}"
9695,"public void evaluate(){
  String targetQuery;
  Set<String> answers;
  List<String> examples;
  Set<String> relatedResources;
  List<String> relevantWords;
  int i=1;
  for (  String question : question2Answers.keySet()) {
    question=""String_Node_Str"";
    logger.info(getNewQuestionString(i++,question));
    try {
      logger.info(""String_Node_Str"" + question + ""String_Node_Str"");
      targetQuery=question2query.get(question);
      logger.info(""String_Node_Str"" + targetQuery);
      answers=question2Answers.get(question);
      logger.info(""String_Node_Str"" + answers.size() + ""String_Node_Str""+ answers);
      relevantWords=getRelevantWords(question);
      QuestionBasedStatementFilter filter=new QuestionBasedStatementFilter(new HashSet<String>(relevantWords));
      filter.setThreshold(SIMILARITY_THRESHOLD);
      exFinder.setStatementFilter(filter);
      if (USE_SYNONYMS) {
        relevantWords.addAll(getSynonyms(relevantWords));
        logger.info(""String_Node_Str"" + relevantWords);
      }
      question=""String_Node_Str"";
      for (      String word : relevantWords) {
        question+=""String_Node_Str"" + word;
      }
      question.trim();
      logger.info(""String_Node_Str"" + question);
      if (USE_WIKIPEDIA_SEARCH) {
        examples=getResourcesByWikipedia(question);
      }
 else {
        examples=getResourcesByNLQueryWithLucene(question);
      }
      List<String> posExamples=new ArrayList<String>();
      List<String> negExamples=new ArrayList<String>();
      for (      String ex : examples) {
        if (answers.contains(ex)) {
          if (posExamples.size() < NR_OF_POS_START_EXAMPLES_COUNT) {
            posExamples.add(ex);
          }
        }
 else {
          if (negExamples.size() < NR_OF_NEG_START_EXAMPLES_COUNT) {
            negExamples.add(ex);
          }
        }
      }
      if (posExamples.size() < NR_OF_POS_START_EXAMPLES_COUNT) {
        logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str"");
        for (        String answer : answers) {
          posExamples.add(answer);
          if (posExamples.size() == NR_OF_POS_START_EXAMPLES_COUNT) {
            break;
          }
        }
      }
      if (posExamples.isEmpty()) {
        logger.warn(""String_Node_Str"" + TOP_K + ""String_Node_Str""+ ""String_Node_Str"");
        continue;
      }
      logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str""+ posExamples);
      logger.info(""String_Node_Str"" + negExamples.size() + ""String_Node_Str""+ negExamples);
      Set<String> learnedResources;
      do {
        logger.info(""String_Node_Str"");
        long startTime=System.currentTimeMillis();
        String example=exFinder.findSimilarExample(posExamples,negExamples).getURI();
        logger.info(""String_Node_Str"" + example + ""String_Node_Str""+ (System.currentTimeMillis() - startTime)+ ""String_Node_Str"");
        String learnedQuery=exFinder.getCurrentQuery();
        logger.info(""String_Node_Str"" + learnedQuery);
        learnedQuery=""String_Node_Str"" + learnedQuery.substring(7);
        learnedResources=getResourcesBySPARQLQuery(learnedQuery);
        logger.info(""String_Node_Str"" + learnedResources.size());
        if (answers.contains(example)) {
          posExamples.add(example);
        }
 else {
          negExamples.add(example);
        }
      }
 while (answers.equals(learnedResources));
      logger.info(""String_Node_Str"" + question + ""String_Node_Str"");
    }
 catch (    TimeOutException e) {
      e.printStackTrace();
    }
catch (    SPARQLQueryException e) {
      e.printStackTrace();
    }
catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
  }
}","public void evaluate(){
  String targetQuery;
  Set<String> answers;
  List<String> examples;
  Set<String> relatedResources;
  List<String> relevantWords;
  int i=1;
  for (  String question : question2Answers.keySet()) {
    logger.info(getNewQuestionString(i++,question));
    try {
      targetQuery=question2query.get(question);
      logger.info(""String_Node_Str"" + targetQuery);
      answers=getResourcesBySPARQLQuery(targetQuery,""String_Node_Str"");
      logger.info(""String_Node_Str"" + answers.size() + ""String_Node_Str""+ answers);
      relevantWords=getRelevantWords(question);
      QuestionBasedStatementFilter filter=new QuestionBasedStatementFilter(new HashSet<String>(relevantWords));
      filter.setThreshold(SIMILARITY_THRESHOLD);
      exFinder.setStatementFilter(filter);
      if (USE_SYNONYMS) {
        relevantWords.addAll(getSynonyms(relevantWords));
        logger.info(""String_Node_Str"" + relevantWords);
      }
      question=""String_Node_Str"";
      for (      String word : relevantWords) {
        question+=""String_Node_Str"" + word;
      }
      question.trim();
      logger.info(""String_Node_Str"" + question);
      if (USE_WIKIPEDIA_SEARCH) {
        examples=getResourcesByWikipedia(question);
      }
 else {
        examples=getResourcesByNLQueryWithLucene(question);
      }
      List<String> posExamples=new ArrayList<String>();
      List<String> negExamples=new ArrayList<String>();
      for (      String ex : examples) {
        if (answers.contains(ex)) {
          if (posExamples.size() < NR_OF_POS_START_EXAMPLES_COUNT) {
            posExamples.add(ex);
          }
        }
 else {
          if (negExamples.size() < NR_OF_NEG_START_EXAMPLES_COUNT) {
            negExamples.add(ex);
          }
        }
      }
      if (posExamples.size() < NR_OF_POS_START_EXAMPLES_COUNT) {
        logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str"");
        for (        String answer : answers) {
          posExamples.add(answer);
          if (posExamples.size() == NR_OF_POS_START_EXAMPLES_COUNT) {
            break;
          }
        }
      }
      if (posExamples.isEmpty()) {
        logger.warn(""String_Node_Str"" + TOP_K + ""String_Node_Str""+ ""String_Node_Str"");
        continue;
      }
      logger.info(""String_Node_Str"" + posExamples.size() + ""String_Node_Str""+ posExamples);
      logger.info(""String_Node_Str"" + negExamples.size() + ""String_Node_Str""+ negExamples);
      Set<String> learnedResources;
      do {
        logger.info(""String_Node_Str"");
        long startTime=System.currentTimeMillis();
        String example=exFinder.findSimilarExample(posExamples,negExamples).getURI();
        logger.info(""String_Node_Str"" + example + ""String_Node_Str""+ (System.currentTimeMillis() - startTime)+ ""String_Node_Str"");
        String learnedQuery=exFinder.getCurrentQuery();
        logger.info(""String_Node_Str"" + learnedQuery);
        learnedQuery=""String_Node_Str"" + learnedQuery.substring(7);
        learnedResources=getResourcesBySPARQLQuery(learnedQuery,""String_Node_Str"");
        logger.info(""String_Node_Str"" + learnedResources.size());
        if (answers.contains(example)) {
          posExamples.add(example);
        }
 else {
          negExamples.add(example);
        }
      }
 while (!answers.equals(learnedResources));
      logger.info(""String_Node_Str"" + question + ""String_Node_Str"");
    }
 catch (    TimeOutException e) {
      e.printStackTrace();
    }
catch (    SPARQLQueryException e) {
      e.printStackTrace();
    }
catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
  }
}"
9696,"public void simplifyTree(QueryTree<N> tree,List<QueryTree<N>> negTrees){
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(tree,endpoint.getBaseURI(),endpoint.getPrefixes()));
    int i=1;
    for (    QueryTree<N> negTree : negTrees) {
      logger.debug(""String_Node_Str"" + i++ + ""String_Node_Str""+ negTrees.size()+ ""String_Node_Str""+ TreeHelper.getAbbreviatedTreeRepresentation(negTree,endpoint.getBaseURI(),endpoint.getPrefixes()));
    }
  }
  List<Object> path;
  boolean pathExists;
  for (  QueryTree<N> leaf : tree.getLeafs()) {
    pathExists=false;
    path=getPathFromRootToNode(leaf);
    if (leaf.getParent().getUserObject().equals(""String_Node_Str"")) {
      pathExists=true;
      for (      QueryTree<N> negTree : negTrees) {
        if (!pathExists(leaf,new ArrayList<Object>(path),negTree)) {
          pathExists=false;
          break;
        }
      }
    }
    if (pathExists) {
      leaf.getParent().removeChild((QueryTreeImpl<N>)leaf);
    }
  }
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(tree,endpoint.getBaseURI(),endpoint.getPrefixes()));
  }
}","public void simplifyTree(QueryTree<N> tree,List<QueryTree<N>> negTrees){
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(tree,endpoint.getBaseURI(),endpoint.getPrefixes()));
    int i=1;
    for (    QueryTree<N> negTree : negTrees) {
      logger.debug(""String_Node_Str"" + i++ + ""String_Node_Str""+ negTrees.size()+ ""String_Node_Str""+ TreeHelper.getAbbreviatedTreeRepresentation(negTree,endpoint.getBaseURI(),endpoint.getPrefixes()));
    }
  }
  List<Object> path;
  boolean pathExists;
  for (  QueryTree<N> leaf : tree.getLeafs()) {
    pathExists=false;
    path=getPathFromRootToNode(leaf);
    pathExists=true;
    for (    QueryTree<N> negTree : negTrees) {
      if (!pathExists(leaf,new ArrayList<Object>(path),negTree)) {
        pathExists=false;
        break;
      }
    }
    if (pathExists) {
      leaf.getParent().removeChild((QueryTreeImpl<N>)leaf);
    }
  }
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(tree,endpoint.getBaseURI(),endpoint.getPrefixes()));
  }
}"
9697,"/** 
 * Computes score of a given concept using the reasoner. Either retrieval or instance check are used. For the latter, this method treats <code>UseMultiInstanceChecks.TWO_CHECKS</code> as if it were  <code>UseMultiInstanceChecks.ONE_CHECKS</code> (it does not make much sense to implement TWO_CHECKS in this function, because we have to test all examples to create a score object anyway).
 * @see org.dllearner.learningproblems.PosNegLP.UseMultiInstanceChecks
 * @param concept The concept to test.
 * @return Corresponding Score object.
 */
@Override public ScorePosNeg computeScore(Description concept){
  if (useRetrievalForClassification) {
    SortedSet<Individual> posClassified=reasoner.getIndividuals(concept);
    SortedSet<Individual> posAsPos=Helper.intersection(positiveExamples,posClassified);
    SortedSet<Individual> negAsPos=Helper.intersection(negativeExamples,posClassified);
    SortedSet<Individual> posAsNeg=new TreeSet<Individual>();
    for (    Individual posExample : positiveExamples) {
      if (!posClassified.contains(posExample))       posAsNeg.add(posExample);
    }
    SortedSet<Individual> negAsNeg=new TreeSet<Individual>();
    for (    Individual negExample : negativeExamples) {
      if (!posClassified.contains(negExample))       negAsNeg.add(negExample);
    }
    return new ScoreTwoValued(concept.getLength(),percentPerLengthUnit,posAsPos,posAsNeg,negAsPos,negAsNeg);
  }
 else {
    SortedSet<Individual> posAsPos=new TreeSet<Individual>();
    SortedSet<Individual> posAsNeg=new TreeSet<Individual>();
    SortedSet<Individual> negAsPos=new TreeSet<Individual>();
    SortedSet<Individual> negAsNeg=new TreeSet<Individual>();
    if (useMultiInstanceChecks != UseMultiInstanceChecks.NEVER) {
      SortedSet<Individual> posClassified=reasoner.hasType(concept,allExamples);
      SortedSet<Individual> negClassified=Helper.difference(allExamples,posClassified);
      posAsPos=Helper.intersection(positiveExamples,posClassified);
      posAsNeg=Helper.intersection(positiveExamples,negClassified);
      negAsPos=Helper.intersection(negativeExamples,posClassified);
      negAsNeg=Helper.intersection(negativeExamples,negClassified);
      return new ScoreTwoValued(concept.getLength(),percentPerLengthUnit,posAsPos,posAsNeg,negAsPos,negAsNeg);
    }
 else {
      for (      Individual example : positiveExamples) {
        if (reasoner.hasType(concept,example)) {
          posAsPos.add(example);
        }
 else {
          posAsNeg.add(example);
        }
      }
      for (      Individual example : negativeExamples) {
        if (reasoner.hasType(concept,example))         negAsPos.add(example);
 else         negAsNeg.add(example);
      }
      return new ScoreTwoValued(concept.getLength(),percentPerLengthUnit,posAsPos,posAsNeg,negAsPos,negAsNeg);
    }
  }
}","/** 
 * Computes score of a given concept using the reasoner. Either retrieval or instance check are used. For the latter, this method treats <code>UseMultiInstanceChecks.TWO_CHECKS</code> as if it were  <code>UseMultiInstanceChecks.ONE_CHECKS</code> (it does not make much sense to implement TWO_CHECKS in this function, because we have to test all examples to create a score object anyway). NOTE: The options above are no longer supported, because of interface changes (the options are more or less only relevant in combination with DIG).
 * @see org.dllearner.learningproblems.PosNegLP.UseMultiInstanceChecks
 * @param concept The concept to test.
 * @return Corresponding Score object.
 */
@Override public ScorePosNeg computeScore(Description concept){
  if (useOldDIGOptions) {
    if (useRetrievalForClassification) {
      SortedSet<Individual> posClassified=reasoner.getIndividuals(concept);
      SortedSet<Individual> posAsPos=Helper.intersection(positiveExamples,posClassified);
      SortedSet<Individual> negAsPos=Helper.intersection(negativeExamples,posClassified);
      SortedSet<Individual> posAsNeg=new TreeSet<Individual>();
      for (      Individual posExample : positiveExamples) {
        if (!posClassified.contains(posExample))         posAsNeg.add(posExample);
      }
      SortedSet<Individual> negAsNeg=new TreeSet<Individual>();
      for (      Individual negExample : negativeExamples) {
        if (!posClassified.contains(negExample))         negAsNeg.add(negExample);
      }
      return new ScoreTwoValued(concept.getLength(),percentPerLengthUnit,posAsPos,posAsNeg,negAsPos,negAsNeg);
    }
 else {
      SortedSet<Individual> posAsPos=new TreeSet<Individual>();
      SortedSet<Individual> posAsNeg=new TreeSet<Individual>();
      SortedSet<Individual> negAsPos=new TreeSet<Individual>();
      SortedSet<Individual> negAsNeg=new TreeSet<Individual>();
      if (useMultiInstanceChecks != UseMultiInstanceChecks.NEVER) {
        SortedSet<Individual> posClassified=reasoner.hasType(concept,allExamples);
        SortedSet<Individual> negClassified=Helper.difference(allExamples,posClassified);
        posAsPos=Helper.intersection(positiveExamples,posClassified);
        posAsNeg=Helper.intersection(positiveExamples,negClassified);
        negAsPos=Helper.intersection(negativeExamples,posClassified);
        negAsNeg=Helper.intersection(negativeExamples,negClassified);
        return new ScoreTwoValued(concept.getLength(),percentPerLengthUnit,posAsPos,posAsNeg,negAsPos,negAsNeg);
      }
 else {
        for (        Individual example : positiveExamples) {
          if (reasoner.hasType(concept,example)) {
            posAsPos.add(example);
          }
 else {
            posAsNeg.add(example);
          }
        }
        for (        Individual example : negativeExamples) {
          if (reasoner.hasType(concept,example))           negAsPos.add(example);
 else           negAsNeg.add(example);
        }
        return new ScoreTwoValued(concept.getLength(),percentPerLengthUnit,posAsPos,posAsNeg,negAsPos,negAsNeg);
      }
    }
  }
 else {
    SortedSet<Individual> posAsPos=new TreeSet<Individual>();
    SortedSet<Individual> posAsNeg=new TreeSet<Individual>();
    SortedSet<Individual> negAsPos=new TreeSet<Individual>();
    SortedSet<Individual> negAsNeg=new TreeSet<Individual>();
    for (    Individual example : positiveExamples) {
      if (reasoner.hasType(concept,example)) {
        posAsPos.add(example);
      }
 else {
        posAsNeg.add(example);
      }
    }
    for (    Individual example : negativeExamples) {
      if (reasoner.hasType(concept,example))       negAsPos.add(example);
 else       negAsNeg.add(example);
    }
    double accuracy=getAccuracyOrTooWeakExact(concept,1);
    return new ScoreTwoValued(concept.getLength(),percentPerLengthUnit,posAsPos,posAsNeg,negAsPos,negAsNeg,accuracy);
  }
}"
9698,"private void computeScore(){
  accuracy=posAsPos.size() + negAsNeg.size();
  accuracy=accuracy / (double)nrOfExamples;
  score=accuracy - 1 - percentPerLengthUnit * conceptLength;
}","@Deprecated private void computeScore(){
  accuracy=posAsPos.size() + negAsNeg.size();
  accuracy=accuracy / (double)nrOfExamples;
  score=accuracy - 1 - percentPerLengthUnit * conceptLength;
}"
9699,"public ScoreTwoValued(int conceptLength,double percentPerLengthUnit,Set<Individual> posAsPos,Set<Individual> posAsNeg,Set<Individual> negAsPos,Set<Individual> negAsNeg){
  this.conceptLength=conceptLength;
  this.percentPerLengthUnit=percentPerLengthUnit;
  this.posAsPos=posAsPos;
  this.posAsNeg=posAsNeg;
  this.negAsPos=negAsPos;
  this.negAsNeg=negAsNeg;
  nrOfExamples=posAsPos.size() + posAsNeg.size() + negAsPos.size()+ negAsNeg.size();
  computeScore();
}","public ScoreTwoValued(int conceptLength,double percentPerLengthUnit,Set<Individual> posAsPos,Set<Individual> posAsNeg,Set<Individual> negAsPos,Set<Individual> negAsNeg,double accuracy){
  this.conceptLength=conceptLength;
  this.percentPerLengthUnit=percentPerLengthUnit;
  this.posAsPos=posAsPos;
  this.posAsNeg=posAsNeg;
  this.negAsPos=negAsPos;
  this.negAsNeg=negAsNeg;
  nrOfExamples=posAsPos.size() + posAsNeg.size() + negAsPos.size()+ negAsNeg.size();
  this.accuracy=accuracy;
  score=accuracy - 1 - percentPerLengthUnit * conceptLength;
}"
9700,"@Test public void posNegLPLearningTests() throws ComponentInitException {
  KB kb=new KB();
  String ns=""String_Node_Str"";
  NamedClass[] nc=new NamedClass[5];
  for (int i=0; i < 5; i++) {
    nc[i]=new NamedClass(ns + ""String_Node_Str"" + i);
  }
  Individual[] ind=new Individual[100];
  for (int i=0; i < 100; i++) {
    ind[i]=new Individual(ns + ""String_Node_Str"" + i);
  }
  for (int i=0; i < 100; i++) {
    kb.addAxiom(new ClassAssertionAxiom(Thing.instance,ind[i]));
  }
  for (int i=0; i < 20; i++) {
    kb.addAxiom(new ClassAssertionAxiom(nc[0],ind[i]));
  }
  for (int i=10; i < 30; i++) {
    kb.addAxiom(new ClassAssertionAxiom(nc[1],ind[i]));
  }
  for (int i=10; i < 50; i++) {
    kb.addAxiom(new ClassAssertionAxiom(nc[2],ind[i]));
  }
  for (int i=8; i < 13; i++) {
    kb.addAxiom(new ClassAssertionAxiom(nc[3],ind[i]));
  }
  ComponentManager cm=ComponentManager.getInstance();
  KnowledgeSource ks=new KBFile(kb);
  ReasonerComponent reasoner=cm.reasoner(OWLAPIReasoner.class,ks);
  PosNegLPStandard problem=cm.learningProblem(PosNegLPStandard.class,reasoner);
  ks.init();
  reasoner.init();
  Individual[] pos1=new Individual[]{ind[1],ind[2]};
  Individual[] neg1=new Individual[]{ind[3],ind[4]};
  HeuristicTests.configurePosNegStandardLP(problem,pos1,neg1,""String_Node_Str"",false);
}","@Test public void posNegLPLearningTests() throws ComponentInitException {
  KB kb=new KB();
  String ns=""String_Node_Str"";
  NamedClass[] nc=new NamedClass[5];
  for (int i=0; i < 5; i++) {
    nc[i]=new NamedClass(ns + ""String_Node_Str"" + i);
  }
  Individual[] ind=new Individual[100];
  for (int i=0; i < 100; i++) {
    ind[i]=new Individual(ns + ""String_Node_Str"" + i);
  }
  for (int i=0; i < 100; i++) {
    kb.addAxiom(new ClassAssertionAxiom(Thing.instance,ind[i]));
  }
  kb.addAxiom(new ClassAssertionAxiom(nc[0],ind[0]));
  kb.addAxiom(new ClassAssertionAxiom(nc[0],ind[1]));
  kb.addAxiom(new ClassAssertionAxiom(nc[0],ind[5]));
  kb.addAxiom(new ClassAssertionAxiom(nc[1],ind[0]));
  kb.addAxiom(new ClassAssertionAxiom(nc[1],ind[1]));
  kb.addAxiom(new ClassAssertionAxiom(nc[1],ind[2]));
  kb.addAxiom(new ClassAssertionAxiom(nc[1],ind[5]));
  ComponentManager cm=ComponentManager.getInstance();
  KnowledgeSource ks=new KBFile(kb);
  ReasonerComponent reasoner=cm.reasoner(OWLAPIReasoner.class,ks);
  PosNegLPStandard problem=cm.learningProblem(PosNegLPStandard.class,reasoner);
  ks.init();
  reasoner.init();
  Individual[] pos1=new Individual[]{ind[0],ind[1],ind[2],ind[3],ind[4]};
  Individual[] neg1=new Individual[]{ind[5],ind[6],ind[7],ind[8],ind[9]};
  HeuristicTests.configurePosNegStandardLP(problem,pos1,neg1,""String_Node_Str"",false);
  assertEqualsPosNegLPStandard(problem,nc[0],0.5);
  assertEqualsPosNegLPStandard(problem,nc[1],2 / 3d);
  HeuristicTests.configurePosNegStandardLP(problem,pos1,neg1,""String_Node_Str"",true);
  assertEqualsPosNegLPStandard(problem,nc[0],0.5);
  assertEqualsPosNegLPStandard(problem,nc[1],2 / 3d);
}"
9701,"private String getNewResource(QueryTree<N> tree,List<String> knownResources){
  int i=0;
  int chunkSize=10;
  SortedSet<String> foundResources=getResources(tree,chunkSize,chunkSize * i);
  foundResources.removeAll(knownResources);
  QueryTree<N> newTree;
  while (!foundResources.isEmpty()) {
    for (    String resource : foundResources) {
      newTree=getQueryTree(resource);
      if (!newTree.isSubsumedBy(lgg)) {
        return resource;
      }
    }
    i++;
    foundResources=getResources(tree,chunkSize,chunkSize * i);
    foundResources.removeAll(knownResources);
  }
  logger.debug(""String_Node_Str"");
  return null;
}","private String getNewResource(QueryTree<N> tree,List<String> knownResources){
  int i=0;
  int chunkSize=40;
  SortedSet<String> foundResources;
  QueryTree<N> newTree;
  int foundSize;
  do {
    foundResources=getResources(tree,chunkSize,chunkSize * i);
    foundSize=foundResources.size();
    foundResources.removeAll(knownResources);
    for (    String resource : foundResources) {
      newTree=getQueryTree(resource);
      if (!newTree.isSubsumedBy(lgg)) {
        return resource;
      }
    }
    i++;
  }
 while (foundSize == chunkSize);
  logger.debug(""String_Node_Str"");
  return null;
}"
9702,"private void limitEqualEdgesToLeafs(QueryTree<N> tree,int maxEqualEdgeCount){
  Set<QueryTree<N>> parents=new HashSet<QueryTree<N>>();
  for (  QueryTree<N> leaf : tree.getLeafs()) {
    if (leaf.getUserObject().equals(""String_Node_Str"")) {
      parents.add(leaf.getParent());
    }
  }
  for (  QueryTree<N> parent : parents) {
    for (    Object edge : parent.getEdges()) {
      int cnt=0;
      for (      QueryTree<N> child : parent.getChildren(edge)) {
        if (child.getUserObject().equals(""String_Node_Str"")) {
          if (child.isLeaf()) {
            cnt++;
            if (cnt > maxEqualEdgeCount) {
              parent.removeChild((QueryTreeImpl<N>)child);
            }
          }
        }
      }
    }
  }
}","private void limitEqualEdgesToLeafs(QueryTree<N> tree,int maxEqualEdgeCount){
  Set<QueryTree<N>> parents=new HashSet<QueryTree<N>>();
  for (  QueryTree<N> leaf : tree.getLeafs()) {
    if (leaf.getUserObject().equals(""String_Node_Str"")) {
      parents.add(leaf.getParent());
    }
  }
  for (  QueryTree<N> parent : parents) {
    for (    Object edge : parent.getEdges()) {
      int cnt=0;
      boolean existsResourceChild=false;
      for (      QueryTree<N> child : parent.getChildren(edge)) {
        if (!child.getUserObject().equals(""String_Node_Str"")) {
          existsResourceChild=true;
          break;
        }
      }
      for (      QueryTree<N> child : parent.getChildren(edge)) {
        if (child.getUserObject().equals(""String_Node_Str"")) {
          if (child.isLeaf()) {
            cnt++;
            if (existsResourceChild || cnt > maxEqualEdgeCount) {
              parent.removeChild((QueryTreeImpl<N>)child);
            }
          }
        }
      }
    }
  }
}"
9703,"public void simplifyTree(QueryTree<N> tree,List<QueryTree<N>> negTrees){
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(tree,endpoint.getBaseURI(),endpoint.getPrefixes()));
  }
  List<Object> path;
  boolean pathExists;
  for (  QueryTree<N> leaf : tree.getLeafs()) {
    pathExists=false;
    path=getPathFromRootToNode(leaf);
    if (leaf.getParent().getUserObject().equals(""String_Node_Str"")) {
      pathExists=true;
      for (      QueryTree<N> negTree : negTrees) {
        if (!pathExists(leaf,new ArrayList<Object>(path),negTree)) {
          pathExists=false;
          break;
        }
      }
    }
    if (pathExists) {
      leaf.getParent().removeChild((QueryTreeImpl<N>)leaf);
    }
  }
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(tree,endpoint.getBaseURI(),endpoint.getPrefixes()));
  }
}","public void simplifyTree(QueryTree<N> tree,List<QueryTree<N>> negTrees){
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(tree,endpoint.getBaseURI(),endpoint.getPrefixes()));
    int i=1;
    for (    QueryTree<N> negTree : negTrees) {
      logger.debug(""String_Node_Str"" + i++ + ""String_Node_Str""+ negTrees.size()+ ""String_Node_Str""+ TreeHelper.getAbbreviatedTreeRepresentation(negTree,endpoint.getBaseURI(),endpoint.getPrefixes()));
    }
  }
  List<Object> path;
  boolean pathExists;
  for (  QueryTree<N> leaf : tree.getLeafs()) {
    pathExists=false;
    path=getPathFromRootToNode(leaf);
    if (leaf.getParent().getUserObject().equals(""String_Node_Str"")) {
      pathExists=true;
      for (      QueryTree<N> negTree : negTrees) {
        if (!pathExists(leaf,new ArrayList<Object>(path),negTree)) {
          pathExists=false;
          break;
        }
      }
    }
    if (pathExists) {
      leaf.getParent().removeChild((QueryTreeImpl<N>)leaf);
    }
  }
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + TreeHelper.getAbbreviatedTreeRepresentation(tree,endpoint.getBaseURI(),endpoint.getPrefixes()));
  }
}"
9704,"private boolean pathExists(QueryTree<N> leaf,List<Object> path,QueryTree<N> tree){
  List<QueryTree<N>> negLeaves;
  Object lastEdge=path.remove(path.size() - 1);
  for (  QueryTree<N> node : getNodesByPath(tree,path)) {
    negLeaves=node.getChildren(lastEdge);
    if (negLeaves.isEmpty()) {
      break;
    }
 else {
      if (leaf.getUserObject().equals(""String_Node_Str"")) {
        return true;
      }
      for (      QueryTree<N> negLeaf : negLeaves) {
        if (negLeaf.getUserObject().equals(leaf.getUserObject())) {
          return true;
        }
      }
    }
  }
  return false;
}","private boolean pathExists(QueryTree<N> leaf,List<Object> path,QueryTree<N> tree){
  List<QueryTree<N>> negLeaves;
  Object lastEdge=path.remove(path.size() - 1);
  for (  QueryTree<N> node : getNodesByPath(tree,path)) {
    negLeaves=node.getChildren(lastEdge);
    boolean exists=false;
    if (negLeaves.isEmpty()) {
      return false;
    }
 else {
      if (leaf.getUserObject().equals(""String_Node_Str"")) {
        return true;
      }
      for (      QueryTree<N> negLeaf : negLeaves) {
        if (negLeaf.getUserObject().equals(leaf.getUserObject())) {
          exists=true;
          break;
        }
      }
    }
    if (!exists) {
      return false;
    }
  }
  return true;
}"
9705,"private String getNewResource(QueryTree<N> tree,List<String> knownResources){
  int i=0;
  int chunkSize=10;
  SortedSet<String> foundResources=getResources(tree,10,chunkSize * i);
  foundResources.removeAll(knownResources);
  QueryTree<N> newTree;
  while (!foundResources.isEmpty()) {
    for (    String resource : foundResources) {
      newTree=getQueryTree(resource);
      if (!newTree.isSubsumedBy(lgg)) {
        return resource;
      }
    }
    i++;
    foundResources=getResources(tree,10,chunkSize * i);
  }
  logger.debug(""String_Node_Str"");
  return null;
}","private String getNewResource(QueryTree<N> tree,List<String> knownResources){
  int i=0;
  int chunkSize=10;
  SortedSet<String> foundResources=getResources(tree,10,chunkSize * i);
  foundResources.removeAll(knownResources);
  QueryTree<N> newTree;
  while (!foundResources.isEmpty()) {
    for (    String resource : foundResources) {
      newTree=getQueryTree(resource);
      if (!newTree.isSubsumedBy(lgg)) {
        return resource;
      }
    }
    i++;
    foundResources=getResources(tree,10,chunkSize * i);
    foundResources.removeAll(knownResources);
  }
  logger.debug(""String_Node_Str"");
  return null;
}"
9706,"private void buildSPARQLQueryString(QueryTree<N> tree,StringBuilder sb,boolean filtered,int cnt){
  Object subject=null;
  if (tree.getUserObject().equals(""String_Node_Str"")) {
    subject=""String_Node_Str"" + cnt++;
  }
 else {
    subject=""String_Node_Str"" + tree.getUserObject() + ""String_Node_Str"";
  }
  Object predicate;
  Object object;
  if (!tree.isLeaf()) {
    for (    QueryTree<N> child : tree.getChildren()) {
      predicate=tree.getEdge(child);
      if (filtered) {
        if (Filter.getAllFilterProperties().contains(predicate.toString())) {
          continue;
        }
      }
      object=child.getUserObject();
      boolean objectIsResource=!object.equals(""String_Node_Str"");
      if (!objectIsResource) {
        object=""String_Node_Str"" + cnt;
      }
 else       if (((String)object).startsWith(""String_Node_Str"")) {
        object=""String_Node_Str"" + object + ""String_Node_Str"";
      }
      sb.append(subject).append(""String_Node_Str"").append(predicate).append(""String_Node_Str"").append(object).append(""String_Node_Str"");
      if (!objectIsResource) {
        buildSPARQLQueryString(child,sb,filtered,cnt);
      }
    }
  }
}","private void buildSPARQLQueryString(QueryTree<N> tree,StringBuilder sb,boolean filtered,int cnt){
  Object subject=null;
  if (tree.getUserObject().equals(""String_Node_Str"")) {
    subject=""String_Node_Str"" + cnt++;
  }
 else {
    subject=""String_Node_Str"" + tree.getUserObject() + ""String_Node_Str"";
  }
  Object predicate;
  Object object;
  if (!tree.isLeaf()) {
    for (    QueryTree<N> child : tree.getChildren()) {
      if (child.isLiteralNode()) {
        continue;
      }
      predicate=tree.getEdge(child);
      if (((String)predicate).startsWith(""String_Node_Str"")) {
        continue;
      }
      if (filtered) {
        if (Filter.getAllFilterProperties().contains(predicate.toString())) {
          continue;
        }
      }
      object=child.getUserObject();
      boolean objectIsResource=!object.equals(""String_Node_Str"");
      if (!objectIsResource) {
        object=""String_Node_Str"" + cnt;
      }
 else       if (((String)object).startsWith(""String_Node_Str"")) {
        object=""String_Node_Str"" + object + ""String_Node_Str"";
      }
      sb.append(subject).append(""String_Node_Str"").append(predicate).append(""String_Node_Str"").append(object).append(""String_Node_Str"");
      if (!objectIsResource) {
        buildSPARQLQueryString(child,sb,filtered,cnt);
      }
    }
  }
}"
9707,"private SortedSet<String> getResources(QueryTree<N> tree){
  SortedSet<String> resources=new TreeSet<String>();
  query=tree.toSPARQLQueryString();
  query=getDistinctQuery(query);
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + query);
  }
  String result=cache.executeSelectQuery(endpoint,getLimitedQuery(query));
  ResultSetRewindable rs=SparqlQuery.convertJSONtoResultSet(result);
  String uri;
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    uri=qs.getResource(""String_Node_Str"").getURI();
    resources.add(uri);
  }
  return resources;
}","private SortedSet<String> getResources(QueryTree<N> tree){
  SortedSet<String> resources=new TreeSet<String>();
  query=tree.toSPARQLQueryString();
  query=getLimitedQuery(query);
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + query);
  }
  String result=cache.executeSelectQuery(endpoint,query);
  ResultSetRewindable rs=SparqlQuery.convertJSONtoResultSet(result);
  String uri;
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    uri=qs.getResource(""String_Node_Str"").getURI();
    resources.add(uri);
  }
  return resources;
}"
9708,"private String getLimitedQuery(String query){
  return query + ""String_Node_Str"" + (limit + 1);
}","private String getLimitedQuery(String query){
  query=""String_Node_Str"" + query.substring(7);
  return query + ""String_Node_Str"" + (limit + 1);
}"
9709,"public Example getQuestionOptimised(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources){
  lgg=getFilteredTree(lgg);
  negTrees=getFilteredTrees(negTrees);
  PostLGG<N> postLgg=new PostLGG<N>();
  postLgg.simplifyTree(lgg,negTrees);
  logger.info(lgg.getStringRepresentation());
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=getAllowedGeneralisations(new GeneralisedQueryTree<N>(lgg));
  GeneralisedQueryTree<N> tree1;
  QueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  QueryTree<N> queryTree;
  List<GeneralisedQueryTree<N>> gens;
  List<QueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<QueryTree<N>>();
    tree1=queue.remove(0);
    tmp=tree1;
    if (logger.isInfoEnabled()) {
      logger.info(""String_Node_Str"" + tmp.getChanges());
    }
    queryTree=tmp.getQueryTree();
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    if (!coversNegTree) {
      if (logger.isInfoEnabled()) {
        logger.info(""String_Node_Str"");
      }
    }
    while (!coversNegTree) {
      gens=getAllowedGeneralisationsSorted(tmp);
      if (gens.isEmpty()) {
        if (logger.isInfoEnabled()) {
          logger.info(""String_Node_Str"");
        }
        break;
      }
      tmp=gens.remove(0);
      neededGeneralisations.add(tmp.getQueryTree());
      if (logger.isInfoEnabled()) {
        logger.info(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp.getQueryTree();
    }
    SortedSet<String> foundResources=getResources(tree2);
    foundResources.removeAll(knownResources);
    Example example;
    if (!foundResources.isEmpty()) {
      int i=findMostSpecificResourceTree(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      foundResources=getResources(neededGeneralisations.get(i));
      return new Example(foundResources.first(),null,null,null);
    }
 else {
      if (logger.isInfoEnabled()) {
        logger.info(""String_Node_Str"");
      }
    }
  }
  return null;
}","public Example getQuestionOptimised(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources){
  lgg=getFilteredTree(lgg);
  logger.info(lgg.getStringRepresentation());
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=getAllowedGeneralisations(new GeneralisedQueryTree<N>(lgg));
  logger.info(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  QueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  QueryTree<N> queryTree;
  List<GeneralisedQueryTree<N>> gens;
  List<QueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<QueryTree<N>>();
    tree1=queue.remove(0);
    tmp=tree1;
    if (logger.isInfoEnabled()) {
      logger.info(""String_Node_Str"" + tmp.getChanges());
    }
    queryTree=tmp.getQueryTree();
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    logger.info(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      gens=getAllowedGeneralisationsSorted(tmp);
      if (gens.isEmpty()) {
        if (logger.isInfoEnabled()) {
          logger.info(""String_Node_Str"");
        }
        break;
      }
      tmp=gens.remove(0);
      neededGeneralisations.add(tmp.getQueryTree());
      if (logger.isInfoEnabled()) {
        logger.info(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.info(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.info(""String_Node_Str"");
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp.getQueryTree();
    }
    SortedSet<String> foundResources=getResources(tree2);
    foundResources.removeAll(knownResources);
    Example example;
    if (!foundResources.isEmpty()) {
      logger.info(""String_Node_Str"");
      int i=findMostSpecificResourceTree(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      foundResources=getResources(neededGeneralisations.get(i));
      logger.info(""String_Node_Str"");
      return new Example(foundResources.first(),null,null,null);
    }
 else {
      if (logger.isInfoEnabled()) {
        logger.info(""String_Node_Str"");
      }
    }
  }
  return null;
}"
9710,"@Test public void optimisedTest(){
  try {
    SimpleLayout layout=new SimpleLayout();
    ConsoleAppender consoleAppender=new ConsoleAppender(layout);
    FileAppender fileAppender=new FileAppender(layout,""String_Node_Str"",false);
    Logger logger=Logger.getRootLogger();
    logger.removeAllAppenders();
    logger.addAppender(consoleAppender);
    logger.addAppender(fileAppender);
    logger.setLevel(Level.OFF);
    Logger.getLogger(NBR.class).setLevel(Level.INFO);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  HttpQuery.urlLimit=0;
  try {
    ExtractionDBCache cache=new ExtractionDBCache(CACHE_DIR);
    SparqlEndpoint endpoint=new SparqlEndpoint(new URL(""String_Node_Str""),Collections.singletonList(""String_Node_Str""),Collections.<String>emptyList());
    Set<String> predicateFilters=new HashSet<String>();
    predicateFilters.add(""String_Node_Str"");
    predicateFilters.add(""String_Node_Str"");
    ModelGenerator modelGen=new ModelGenerator(endpoint,predicateFilters,cache);
    QueryTreeFactory<String> treeFactory=new QueryTreeFactoryImpl();
    LGGGenerator<String> lggGen=new LGGGeneratorImpl<String>();
    NBR<String> nbrGen=new NBR<String>(endpoint,cache);
    String targetQuery=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    ResultSet rs=SparqlQuery.convertJSONtoResultSet(cache.executeSelectQuery(endpoint,targetQuery));
    SortedSet<String> targetResources=new TreeSet<String>();
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      if (qs.get(""String_Node_Str"").isURIResource()) {
        targetResources.add(qs.get(""String_Node_Str"").asResource().getURI());
      }
    }
    List<QueryTree<String>> posTrees=new ArrayList<QueryTree<String>>();
    List<QueryTree<String>> negTrees=new ArrayList<QueryTree<String>>();
    List<String> knownResources=new ArrayList<String>();
    String uri=""String_Node_Str"";
    knownResources.add(uri);
    Model model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    QueryTree<String> tree=treeFactory.getQueryTree(uri,model);
    tree=getFilteredTree(tree);
    posTrees.add(tree);
    uri=""String_Node_Str"";
    knownResources.add(uri);
    model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    tree=treeFactory.getQueryTree(uri,model);
    tree=getFilteredTree(tree);
    posTrees.add(tree);
    uri=""String_Node_Str"";
    knownResources.add(uri);
    model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    tree=treeFactory.getQueryTree(uri,model);
    tree=getFilteredTree(tree);
    negTrees.add(tree);
    QueryTree<String> lgg=lggGen.getLGG(posTrees);
    Example example=nbrGen.getQuestionOptimised(lgg,negTrees,knownResources);
    String learnedQuery=nbrGen.getQuery();
    while (!isEquivalentQuery(targetResources,learnedQuery,endpoint,cache)) {
      uri=example.getURI();
      knownResources.add(uri);
      model=modelGen.createModel(uri,Strategy.CHUNKS,2);
      tree=treeFactory.getQueryTree(uri,model);
      if (targetResources.contains(uri)) {
        System.out.println(""String_Node_Str"" + uri);
        posTrees.add(tree);
        lgg=lggGen.getLGG(posTrees);
      }
 else {
        System.out.println(""String_Node_Str"" + uri);
        negTrees.add(tree);
      }
      example=nbrGen.getQuestion(lgg,negTrees,knownResources);
      learnedQuery=nbrGen.getQuery();
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
}","@Test public void optimisedTest(){
  try {
    SimpleLayout layout=new SimpleLayout();
    ConsoleAppender consoleAppender=new ConsoleAppender(layout);
    FileAppender fileAppender=new FileAppender(layout,""String_Node_Str"",false);
    Logger logger=Logger.getRootLogger();
    logger.removeAllAppenders();
    logger.addAppender(fileAppender);
    logger.setLevel(Level.OFF);
    Logger.getLogger(NBR.class).setLevel(Level.INFO);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  HttpQuery.urlLimit=0;
  try {
    ExtractionDBCache cache=new ExtractionDBCache(CACHE_DIR);
    SparqlEndpoint endpoint=new SparqlEndpoint(new URL(""String_Node_Str""),Collections.singletonList(""String_Node_Str""),Collections.<String>emptyList());
    Set<String> predicateFilters=new HashSet<String>();
    predicateFilters.add(""String_Node_Str"");
    predicateFilters.add(""String_Node_Str"");
    ModelGenerator modelGen=new ModelGenerator(endpoint,predicateFilters,cache);
    QueryTreeFactory<String> treeFactory=new QueryTreeFactoryImpl();
    LGGGenerator<String> lggGen=new LGGGeneratorImpl<String>();
    NBR<String> nbrGen=new NBR<String>(endpoint,cache);
    String targetQuery=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    ResultSet rs=SparqlQuery.convertJSONtoResultSet(cache.executeSelectQuery(endpoint,targetQuery));
    SortedSet<String> targetResources=new TreeSet<String>();
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      if (qs.get(""String_Node_Str"").isURIResource()) {
        targetResources.add(qs.get(""String_Node_Str"").asResource().getURI());
      }
    }
    List<QueryTree<String>> posTrees=new ArrayList<QueryTree<String>>();
    List<QueryTree<String>> negTrees=new ArrayList<QueryTree<String>>();
    List<String> knownResources=new ArrayList<String>();
    String uri=""String_Node_Str"";
    knownResources.add(uri);
    Model model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    QueryTree<String> tree=treeFactory.getQueryTree(uri,model);
    tree=getFilteredTree(tree);
    posTrees.add(tree);
    uri=""String_Node_Str"";
    knownResources.add(uri);
    model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    tree=treeFactory.getQueryTree(uri,model);
    tree=getFilteredTree(tree);
    posTrees.add(tree);
    uri=""String_Node_Str"";
    knownResources.add(uri);
    model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    tree=treeFactory.getQueryTree(uri,model);
    tree=getFilteredTree(tree);
    negTrees.add(tree);
    QueryTree<String> lgg=lggGen.getLGG(posTrees);
    Example example=nbrGen.getQuestionOptimised(lgg,negTrees,knownResources);
    String learnedQuery=nbrGen.getQuery();
    while (!isEquivalentQuery(targetResources,learnedQuery,endpoint,cache)) {
      uri=example.getURI();
      knownResources.add(uri);
      model=modelGen.createModel(uri,Strategy.CHUNKS,2);
      tree=treeFactory.getQueryTree(uri,model);
      if (targetResources.contains(uri)) {
        System.out.println(""String_Node_Str"" + uri);
        posTrees.add(tree);
        lgg=lggGen.getLGG(posTrees);
      }
 else {
        System.out.println(""String_Node_Str"" + uri);
        negTrees.add(tree);
      }
      example=nbrGen.getQuestionOptimised(lgg,negTrees,knownResources);
      learnedQuery=nbrGen.getQuery();
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
}"
9711,"@Test public void test1(){
  try {
    SimpleLayout layout=new SimpleLayout();
    ConsoleAppender consoleAppender=new ConsoleAppender(layout);
    FileAppender fileAppender=new FileAppender(layout,""String_Node_Str"",false);
    Logger logger=Logger.getRootLogger();
    logger.removeAllAppenders();
    logger.addAppender(consoleAppender);
    logger.addAppender(fileAppender);
    logger.setLevel(Level.OFF);
    Logger.getLogger(NBR.class).setLevel(Level.INFO);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  HttpQuery.urlLimit=0;
  try {
    ExtractionDBCache cache=new ExtractionDBCache(CACHE_DIR);
    SparqlEndpoint endpoint=new SparqlEndpoint(new URL(""String_Node_Str""),Collections.singletonList(""String_Node_Str""),Collections.<String>emptyList());
    Set<String> predicateFilters=new HashSet<String>();
    predicateFilters.add(""String_Node_Str"");
    predicateFilters.add(""String_Node_Str"");
    ModelGenerator modelGen=new ModelGenerator(endpoint,predicateFilters,cache);
    QueryTreeFactory<String> treeFactory=new QueryTreeFactoryImpl();
    LGGGenerator<String> lggGen=new LGGGeneratorImpl<String>();
    NBR<String> nbrGen=new NBR<String>(endpoint,cache);
    String targetQuery=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    ResultSet rs=SparqlQuery.convertJSONtoResultSet(cache.executeSelectQuery(endpoint,targetQuery));
    SortedSet<String> targetResources=new TreeSet<String>();
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      if (qs.get(""String_Node_Str"").isURIResource()) {
        targetResources.add(qs.get(""String_Node_Str"").asResource().getURI());
      }
    }
    List<QueryTree<String>> posTrees=new ArrayList<QueryTree<String>>();
    List<QueryTree<String>> negTrees=new ArrayList<QueryTree<String>>();
    List<String> knownResources=new ArrayList<String>();
    String uri=""String_Node_Str"";
    knownResources.add(uri);
    Model model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    QueryTree<String> tree=treeFactory.getQueryTree(uri,model);
    posTrees.add(tree);
    uri=""String_Node_Str"";
    knownResources.add(uri);
    model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    tree=treeFactory.getQueryTree(uri,model);
    negTrees.add(tree);
    QueryTree<String> lgg=lggGen.getLGG(posTrees);
    Example example=nbrGen.getQuestion(lgg,negTrees,knownResources);
    String learnedQuery=nbrGen.getQuery();
    while (!isEquivalentQuery(targetResources,learnedQuery,endpoint,cache)) {
      uri=example.getURI();
      knownResources.add(uri);
      model=modelGen.createModel(uri,Strategy.CHUNKS,2);
      tree=treeFactory.getQueryTree(uri,model);
      if (targetResources.contains(uri)) {
        System.out.println(""String_Node_Str"" + uri);
        posTrees.add(tree);
        lgg=lggGen.getLGG(posTrees);
      }
 else {
        System.out.println(""String_Node_Str"" + uri);
        negTrees.add(tree);
      }
      example=nbrGen.getQuestion(lgg,negTrees,knownResources);
      learnedQuery=nbrGen.getQuery();
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
}","@Test public void test1(){
  try {
    SimpleLayout layout=new SimpleLayout();
    ConsoleAppender consoleAppender=new ConsoleAppender(layout);
    FileAppender fileAppender=new FileAppender(layout,""String_Node_Str"",false);
    Logger logger=Logger.getRootLogger();
    logger.removeAllAppenders();
    logger.addAppender(consoleAppender);
    logger.addAppender(fileAppender);
    logger.setLevel(Level.OFF);
    Logger.getLogger(NBR.class).setLevel(Level.INFO);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  HttpQuery.urlLimit=0;
  try {
    ExtractionDBCache cache=new ExtractionDBCache(CACHE_DIR);
    SparqlEndpoint endpoint=new SparqlEndpoint(new URL(""String_Node_Str""),Collections.singletonList(""String_Node_Str""),Collections.<String>emptyList());
    Set<String> predicateFilters=new HashSet<String>();
    predicateFilters.add(""String_Node_Str"");
    predicateFilters.add(""String_Node_Str"");
    ModelGenerator modelGen=new ModelGenerator(endpoint,predicateFilters,cache);
    QueryTreeFactory<String> treeFactory=new QueryTreeFactoryImpl();
    LGGGenerator<String> lggGen=new LGGGeneratorImpl<String>();
    NBR<String> nbrGen=new NBR<String>(endpoint,cache);
    String targetQuery=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    ResultSet rs=SparqlQuery.convertJSONtoResultSet(cache.executeSelectQuery(endpoint,targetQuery));
    SortedSet<String> targetResources=new TreeSet<String>();
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      if (qs.get(""String_Node_Str"").isURIResource()) {
        targetResources.add(qs.get(""String_Node_Str"").asResource().getURI());
      }
    }
    List<QueryTree<String>> posTrees=new ArrayList<QueryTree<String>>();
    List<QueryTree<String>> negTrees=new ArrayList<QueryTree<String>>();
    List<String> knownResources=new ArrayList<String>();
    String uri=""String_Node_Str"";
    knownResources.add(uri);
    Model model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    QueryTree<String> tree=treeFactory.getQueryTree(uri,model);
    posTrees.add(tree);
    uri=""String_Node_Str"";
    knownResources.add(uri);
    model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    tree=treeFactory.getQueryTree(uri,model);
    posTrees.add(tree);
    uri=""String_Node_Str"";
    knownResources.add(uri);
    model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    tree=treeFactory.getQueryTree(uri,model);
    negTrees.add(tree);
    QueryTree<String> lgg=lggGen.getLGG(posTrees);
    Example example=nbrGen.getQuestion(lgg,negTrees,knownResources);
    String learnedQuery=nbrGen.getQuery();
    while (!isEquivalentQuery(targetResources,learnedQuery,endpoint,cache)) {
      uri=example.getURI();
      knownResources.add(uri);
      model=modelGen.createModel(uri,Strategy.CHUNKS,2);
      tree=treeFactory.getQueryTree(uri,model);
      if (targetResources.contains(uri)) {
        System.out.println(""String_Node_Str"" + uri);
        posTrees.add(tree);
        lgg=lggGen.getLGG(posTrees);
      }
 else {
        System.out.println(""String_Node_Str"" + uri);
        negTrees.add(tree);
      }
      example=nbrGen.getQuestion(lgg,negTrees,knownResources);
      learnedQuery=nbrGen.getQuery();
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
}"
9712,"private QueryTree<N> createFilteredTree(QueryTree<N> tree){
  QueryTree<N> filteredTree=new QueryTreeImpl<N>(tree.getUserObject());
  filteredTree.setId(nodeId);
  QueryTree<N> subTree;
  Object predicate;
  for (  QueryTree<N> child : tree.getChildren()) {
    if (child.isLiteralNode()) {
      continue;
    }
    predicate=tree.getEdge(child);
    if (((String)predicate).startsWith(""String_Node_Str"")) {
      continue;
    }
    this.nodeId++;
    subTree=createFilteredTree(child);
    subTree.setLiteralNode(child.isLiteralNode());
    subTree.setResourceNode(child.isResourceNode());
    filteredTree.addChild((QueryTreeImpl<N>)subTree,tree.getEdge(child));
  }
  return filteredTree;
}","private QueryTree<N> createFilteredTree(QueryTree<N> tree){
  QueryTree<N> filteredTree=new QueryTreeImpl<N>(tree.getUserObject());
  filteredTree.setId(nodeId);
  QueryTree<N> subTree;
  Object predicate;
  for (  QueryTree<N> child : tree.getChildren()) {
    predicate=tree.getEdge(child);
    if (((String)predicate).startsWith(""String_Node_Str"")) {
      continue;
    }
    this.nodeId++;
    subTree=createFilteredTree(child);
    subTree.setLiteralNode(child.isLiteralNode());
    subTree.setResourceNode(child.isResourceNode());
    filteredTree.addChild((QueryTreeImpl<N>)subTree,tree.getEdge(child));
  }
  return filteredTree;
}"
9713,"private List<GeneralisedQueryTree<N>> getAllowedGeneralisationsSortedByMatrix(GeneralisedQueryTree<N> tree){
  List<QueryTreeChange> changes=new ArrayList<QueryTreeChange>();
  System.err.println(tree.getQueryTree().getStringRepresentation());
  QueryTreeChange lastChange=tree.getLastChange();
  for (  QueryTree<N> node : getPossibleNodes2Change(tree.getQueryTree())) {
    if (lastChange.getType() == ChangeType.REMOVE_NODE) {
      if (node.getUserObject().equals(""String_Node_Str"") && node.getId() < lastChange.getNodeId()) {
        changes.add(new QueryTreeChange(node.getId(),ChangeType.REMOVE_NODE));
      }
    }
 else {
      if (node.getUserObject().equals(""String_Node_Str"")) {
        changes.add(new QueryTreeChange(node.getId(),ChangeType.REMOVE_NODE));
      }
 else {
        changes.add(new QueryTreeChange(node.getId(),ChangeType.REPLACE_LABEL));
      }
    }
  }
  System.out.println();
  List<GeneralisedQueryTree<N>> gens=getAllowedGeneralisations(tree);
  Collections.sort(gens,comparator);
  return gens;
}","private List<QueryTreeChange> getAllowedGeneralisationsSortedByMatrix(GeneralisedQueryTree<N> tree){
  List<QueryTreeChange> changes=new ArrayList<QueryTreeChange>();
  QueryTreeChange lastChange=tree.getLastChange();
  for (  QueryTree<N> node : getPossibleNodes2Change(tree.getQueryTree())) {
    if (lastChange.getType() == ChangeType.REMOVE_NODE) {
      if (node.getUserObject().equals(""String_Node_Str"") && node.getId() < lastChange.getNodeId()) {
        changes.add(new QueryTreeChange(node.getId(),ChangeType.REMOVE_NODE));
      }
    }
 else {
      if (node.getUserObject().equals(""String_Node_Str"")) {
        changes.add(new QueryTreeChange(node.getId(),ChangeType.REMOVE_NODE));
      }
 else       if (lastChange.getNodeId() < node.getId()) {
        changes.add(new QueryTreeChange(node.getId(),ChangeType.REPLACE_LABEL));
      }
    }
  }
  return changes;
}"
9714,"public Example getQuestionOptimised(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources){
  this.lgg=lgg;
  logger.info(""String_Node_Str"");
  postLGG=getFilteredTree(lgg);
  PostLGG<N> postGen=new PostLGG<N>();
  postGen.simplifyTree(postLGG,negTrees);
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=getAllowedGeneralisations(new GeneralisedQueryTree<N>(postLGG));
  logger.debug(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  QueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  QueryTree<N> queryTree;
  List<GeneralisedQueryTree<N>> gens;
  List<QueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<QueryTree<N>>();
    logger.debug(""String_Node_Str"");
    tree1=queue.remove(0);
    tmp=tree1;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + tmp.getChanges());
    }
    queryTree=tmp.getQueryTree();
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    logger.debug(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      gens=getAllowedGeneralisationsSorted(tmp);
      if (gens.isEmpty()) {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"");
        }
        break;
      }
      tmp=gens.remove(0);
      neededGeneralisations.add(tmp.getQueryTree());
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.debug(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.debug(""String_Node_Str"");
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp.getQueryTree();
    }
    String newResource=getNewResource(tree2,knownResources);
    if (!(newResource == null)) {
      logger.debug(""String_Node_Str"");
      newResource=findMostSpecificResourceTree(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      logger.debug(""String_Node_Str"");
      return new Example(newResource,null,null,null);
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
  return null;
}","public Example getQuestionOptimised(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources){
  this.lgg=lgg;
  logger.info(""String_Node_Str"");
  postLGG=getFilteredTree(lgg);
  PostLGG<N> postGen=new PostLGG<N>();
  postGen.simplifyTree(postLGG,negTrees);
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=getAllowedGeneralisations(new GeneralisedQueryTree<N>(postLGG));
  logger.debug(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  QueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  QueryTree<N> queryTree;
  List<GeneralisedQueryTree<N>> gens;
  List<QueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<QueryTree<N>>();
    logger.debug(""String_Node_Str"");
    tree1=queue.remove(0);
    tmp=tree1;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + tmp.getChanges());
    }
    queryTree=tmp.getQueryTree();
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    logger.debug(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      gens=getAllowedGeneralisationsSorted(tmp);
      if (gens.isEmpty()) {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"");
        }
        break;
      }
      tmp=gens.remove(0);
      neededGeneralisations.add(tmp.getQueryTree());
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.debug(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.debug(""String_Node_Str"");
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp.getQueryTree();
    }
    String newResource=getNewResource(tree2,knownResources);
    logger.debug(""String_Node_Str"" + newResource);
    if (!(newResource == null)) {
      logger.debug(""String_Node_Str"");
      newResource=findMostSpecificResourceTree(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      logger.debug(""String_Node_Str"");
      return new Example(newResource,null,null,null);
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
  return null;
}"
9715,"@Test public void optimisedTest(){
  try {
    SimpleLayout layout=new SimpleLayout();
    ConsoleAppender consoleAppender=new ConsoleAppender(layout);
    consoleAppender.setThreshold(Level.INFO);
    FileAppender fileAppender=new FileAppender(layout,""String_Node_Str"",false);
    fileAppender.setThreshold(Level.DEBUG);
    Logger logger=Logger.getRootLogger();
    logger.removeAllAppenders();
    logger.addAppender(consoleAppender);
    logger.addAppender(fileAppender);
    Logger.getLogger(ModelGenerator.class).setLevel(Level.OFF);
    Logger.getLogger(SPARQLQueryGeneratorCachedImpl.class).setLevel(Level.OFF);
    Logger.getLogger(LGGGeneratorImpl.class).setLevel(Level.OFF);
    Logger.getLogger(NBRGeneratorImpl.class).setLevel(Level.OFF);
    Logger.getLogger(Generalisation.class).setLevel(Level.OFF);
    Logger.getLogger(QueryTreeImpl.class).setLevel(Level.OFF);
    Logger.getLogger(NBR.class).setLevel(Level.INFO);
    Logger.getLogger(NBR.class).setLevel(Level.DEBUG);
    Logger.getLogger(PostLGG.class).setLevel(Level.DEBUG);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  HttpQuery.urlLimit=0;
  try {
    ExtractionDBCache cache=new ExtractionDBCache(CACHE_DIR);
    List<String> predicateFilters=new ArrayList<String>();
    SparqlEndpoint endpoint=new SPARQLEndpointEx(new URL(""String_Node_Str""),Collections.singletonList(""String_Node_Str""),Collections.<String>emptyList(),null,null,predicateFilters);
    predicateFilters.add(""String_Node_Str"");
    predicateFilters.add(""String_Node_Str"");
    ModelGenerator modelGen=new ModelGenerator(endpoint,new HashSet<String>(predicateFilters),cache);
    QueryTreeFactory<String> treeFactory=new QueryTreeFactoryImpl();
    LGGGenerator<String> lggGen=new LGGGeneratorImpl<String>();
    NBR<String> nbrGen=new NBR<String>(endpoint,cache);
    String targetQuery=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    ResultSet rs=SparqlQuery.convertJSONtoResultSet(cache.executeSelectQuery(endpoint,targetQuery));
    SortedSet<String> targetResources=new TreeSet<String>();
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      if (qs.get(""String_Node_Str"").isURIResource()) {
        targetResources.add(qs.get(""String_Node_Str"").asResource().getURI());
      }
    }
    List<String> posExamples=new ArrayList<String>();
    List<QueryTree<String>> posTrees=new ArrayList<QueryTree<String>>();
    List<QueryTree<String>> negTrees=new ArrayList<QueryTree<String>>();
    List<String> knownResources=new ArrayList<String>();
    String uri=""String_Node_Str"";
    posExamples.add(uri);
    knownResources.add(uri);
    Model model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    QueryTree<String> tree=treeFactory.getQueryTree(uri,model);
    tree=getFilteredTree(tree);
    posTrees.add(tree);
    uri=""String_Node_Str"";
    posExamples.add(uri);
    knownResources.add(uri);
    model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    tree=treeFactory.getQueryTree(uri,model);
    tree=getFilteredTree(tree);
    posTrees.add(tree);
    uri=""String_Node_Str"";
    knownResources.add(uri);
    model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    tree=treeFactory.getQueryTree(uri,model);
    tree=getFilteredTree(tree);
    negTrees.add(tree);
    logger.info(""String_Node_Str"" + posExamples);
    QueryTree<String> lgg=lggGen.getLGG(posTrees);
    Example example=nbrGen.getQuestionOptimised(lgg,negTrees,knownResources);
    String learnedQuery=nbrGen.getQuery();
    while (!isEquivalentQuery(targetResources,learnedQuery,endpoint,cache)) {
      logger.info(""String_Node_Str"" + getResultCount(lgg.toSPARQLQueryString(),endpoint,cache));
      logger.info(""String_Node_Str"" + getResultCount(nbrGen.getPostLGG().toSPARQLQueryString(),endpoint,cache));
      uri=example.getURI();
      knownResources.add(uri);
      model=modelGen.createModel(uri,Strategy.CHUNKS,2);
      tree=treeFactory.getQueryTree(uri,model);
      tree=getFilteredTree(tree);
      if (targetResources.contains(uri)) {
        logger.info(""String_Node_Str"" + uri);
        posExamples.add(uri);
        posTrees.add(tree);
        lgg=lggGen.getLGG(posTrees);
      }
 else {
        logger.info(""String_Node_Str"" + uri);
        negTrees.add(tree);
      }
      logger.info(""String_Node_Str"" + posExamples);
      example=nbrGen.getQuestionOptimised(lgg,negTrees,knownResources);
      learnedQuery=nbrGen.getQuery();
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
}","@Test public void optimisedTest(){
  try {
    SimpleLayout layout=new SimpleLayout();
    ConsoleAppender consoleAppender=new ConsoleAppender(layout);
    consoleAppender.setThreshold(Level.INFO);
    FileAppender fileAppender=new FileAppender(layout,""String_Node_Str"",false);
    fileAppender.setThreshold(Level.DEBUG);
    Logger logger=Logger.getRootLogger();
    logger.removeAllAppenders();
    logger.addAppender(consoleAppender);
    logger.addAppender(fileAppender);
    Logger.getLogger(ModelGenerator.class).setLevel(Level.OFF);
    Logger.getLogger(SPARQLQueryGeneratorCachedImpl.class).setLevel(Level.OFF);
    Logger.getLogger(LGGGeneratorImpl.class).setLevel(Level.OFF);
    Logger.getLogger(NBRGeneratorImpl.class).setLevel(Level.OFF);
    Logger.getLogger(Generalisation.class).setLevel(Level.OFF);
    Logger.getLogger(QueryTreeImpl.class).setLevel(Level.OFF);
    Logger.getLogger(NBR.class).setLevel(Level.DEBUG);
    Logger.getLogger(PostLGG.class).setLevel(Level.DEBUG);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  HttpQuery.urlLimit=0;
  try {
    ExtractionDBCache cache=new ExtractionDBCache(CACHE_DIR);
    List<String> predicateFilters=new ArrayList<String>();
    SparqlEndpoint endpoint=new SPARQLEndpointEx(new URL(""String_Node_Str""),Collections.singletonList(""String_Node_Str""),Collections.<String>emptyList(),null,null,predicateFilters);
    predicateFilters.add(""String_Node_Str"");
    predicateFilters.add(""String_Node_Str"");
    ModelGenerator modelGen=new ModelGenerator(endpoint,new HashSet<String>(predicateFilters),cache);
    QueryTreeFactory<String> treeFactory=new QueryTreeFactoryImpl();
    LGGGenerator<String> lggGen=new LGGGeneratorImpl<String>();
    NBR<String> nbrGen=new NBR<String>(endpoint,cache);
    String targetQuery=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    ResultSet rs=SparqlQuery.convertJSONtoResultSet(cache.executeSelectQuery(endpoint,targetQuery));
    SortedSet<String> targetResources=new TreeSet<String>();
    QuerySolution qs;
    while (rs.hasNext()) {
      qs=rs.next();
      if (qs.get(""String_Node_Str"").isURIResource()) {
        targetResources.add(qs.get(""String_Node_Str"").asResource().getURI());
      }
    }
    List<String> posExamples=new ArrayList<String>();
    List<QueryTree<String>> posTrees=new ArrayList<QueryTree<String>>();
    List<QueryTree<String>> negTrees=new ArrayList<QueryTree<String>>();
    List<String> knownResources=new ArrayList<String>();
    String uri=""String_Node_Str"";
    posExamples.add(uri);
    knownResources.add(uri);
    Model model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    QueryTree<String> tree=treeFactory.getQueryTree(uri,model);
    tree=getFilteredTree(tree);
    posTrees.add(tree);
    uri=""String_Node_Str"";
    posExamples.add(uri);
    knownResources.add(uri);
    model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    tree=treeFactory.getQueryTree(uri,model);
    tree=getFilteredTree(tree);
    posTrees.add(tree);
    uri=""String_Node_Str"";
    knownResources.add(uri);
    model=modelGen.createModel(uri,Strategy.CHUNKS,2);
    tree=treeFactory.getQueryTree(uri,model);
    tree=getFilteredTree(tree);
    negTrees.add(tree);
    logger.info(""String_Node_Str"" + posExamples);
    QueryTree<String> lgg=lggGen.getLGG(posTrees);
    Example example=nbrGen.getQuestionOptimised(lgg,negTrees,knownResources);
    String learnedQuery=nbrGen.getQuery();
    while (!isEquivalentQuery(targetResources,learnedQuery,endpoint,cache)) {
      logger.info(""String_Node_Str"" + getResultCount(lgg.toSPARQLQueryString(),endpoint,cache));
      logger.info(""String_Node_Str"" + getResultCount(nbrGen.getPostLGG().toSPARQLQueryString(),endpoint,cache));
      uri=example.getURI();
      knownResources.add(uri);
      model=modelGen.createModel(uri,Strategy.CHUNKS,2);
      tree=treeFactory.getQueryTree(uri,model);
      tree=getFilteredTree(tree);
      if (targetResources.contains(uri)) {
        logger.info(""String_Node_Str"" + uri);
        posExamples.add(uri);
        posTrees.add(tree);
        lgg=lggGen.getLGG(posTrees);
      }
 else {
        logger.info(""String_Node_Str"" + uri);
        negTrees.add(tree);
      }
      logger.info(""String_Node_Str"" + posExamples);
      example=nbrGen.getQuestionOptimised(lgg,negTrees,knownResources);
      learnedQuery=nbrGen.getQuery();
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
}"
9716,"private int getResultCount(String query,SparqlEndpoint endpoint,ExtractionDBCache cache){
  com.hp.hpl.jena.query.ResultSet rs=SparqlQuery.convertJSONtoResultSet(cache.executeSelectQuery(endpoint,query));
  SortedSet<String> resources=new TreeSet<String>();
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    if (qs.get(""String_Node_Str"").isURIResource()) {
      resources.add(qs.get(""String_Node_Str"").asResource().getURI());
    }
  }
  return resources.size();
}","private int getResultCount(String query,SparqlEndpoint endpoint,ExtractionDBCache cache){
  com.hp.hpl.jena.query.ResultSet rs=SparqlQuery.convertJSONtoResultSet(cache.executeSelectQuery(endpoint,getDistinctQuery(query)));
  SortedSet<String> resources=new TreeSet<String>();
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    if (qs.get(""String_Node_Str"").isURIResource()) {
      resources.add(qs.get(""String_Node_Str"").asResource().getURI());
    }
  }
  return resources.size();
}"
9717,"private SortedSet<String> getResources(QueryTree<N> tree){
  SortedSet<String> resources=new TreeSet<String>();
  query=tree.toSPARQLQueryString();
  query=getLimitedQuery(query);
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + query);
  }
  String result=cache.executeSelectQuery(endpoint,query);
  ResultSetRewindable rs=SparqlQuery.convertJSONtoResultSet(result);
  String uri;
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    uri=qs.getResource(""String_Node_Str"").getURI();
    resources.add(uri);
  }
  return resources;
}","private SortedSet<String> getResources(QueryTree<N> tree){
  SortedSet<String> resources=new TreeSet<String>();
  query=tree.toSPARQLQueryString();
  query=getDistinctQuery(query);
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + getLimitedQuery(query));
  }
  String result=cache.executeSelectQuery(endpoint,getLimitedQuery(query));
  ResultSetRewindable rs=SparqlQuery.convertJSONtoResultSet(result);
  String uri;
  QuerySolution qs;
  while (rs.hasNext()) {
    qs=rs.next();
    uri=qs.getResource(""String_Node_Str"").getURI();
    resources.add(uri);
  }
  return resources;
}"
9718,"private String getLimitedQuery(String query){
  query=""String_Node_Str"" + query.substring(7);
  return query + ""String_Node_Str"" + (limit + 1);
}","private String getLimitedQuery(String query){
  return query + ""String_Node_Str"" + (limit + 1);
}"
9719,"public Example getQuestionOptimised(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources){
  lgg=getFilteredTree(lgg);
  logger.info(lgg.getStringRepresentation());
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=getAllowedGeneralisations(new GeneralisedQueryTree<N>(lgg));
  logger.info(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  QueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  QueryTree<N> queryTree;
  List<GeneralisedQueryTree<N>> gens;
  List<QueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<QueryTree<N>>();
    tree1=queue.remove(0);
    tmp=tree1;
    if (logger.isInfoEnabled()) {
      logger.info(""String_Node_Str"" + tmp.getChanges());
    }
    queryTree=tmp.getQueryTree();
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    logger.info(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      gens=getAllowedGeneralisationsSorted(tmp);
      if (gens.isEmpty()) {
        if (logger.isInfoEnabled()) {
          logger.info(""String_Node_Str"");
        }
        break;
      }
      tmp=gens.remove(0);
      neededGeneralisations.add(tmp.getQueryTree());
      if (logger.isInfoEnabled()) {
        logger.info(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.info(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.info(""String_Node_Str"");
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp.getQueryTree();
    }
    SortedSet<String> foundResources=getResources(tree2);
    foundResources.removeAll(knownResources);
    Example example;
    if (!foundResources.isEmpty()) {
      logger.info(""String_Node_Str"");
      int i=findMostSpecificResourceTree(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      foundResources=getResources(neededGeneralisations.get(i));
      logger.info(""String_Node_Str"");
      return new Example(foundResources.first(),null,null,null);
    }
 else {
      if (logger.isInfoEnabled()) {
        logger.info(""String_Node_Str"");
      }
    }
  }
  return null;
}","public Example getQuestionOptimised(QueryTree<N> lgg,List<QueryTree<N>> negTrees,List<String> knownResources){
  lgg=getFilteredTree(lgg);
  logger.info(lgg.getStringRepresentation());
  limit=knownResources.size();
  List<GeneralisedQueryTree<N>> queue=getAllowedGeneralisations(new GeneralisedQueryTree<N>(lgg));
  logger.info(getQueueLogInfo(queue));
  GeneralisedQueryTree<N> tree1;
  QueryTree<N> tree2;
  GeneralisedQueryTree<N> tmp;
  QueryTree<N> queryTree;
  List<GeneralisedQueryTree<N>> gens;
  List<QueryTree<N>> neededGeneralisations;
  while (!queue.isEmpty()) {
    neededGeneralisations=new ArrayList<QueryTree<N>>();
    tree1=queue.remove(0);
    tmp=tree1;
    if (logger.isInfoEnabled()) {
      logger.info(""String_Node_Str"" + tmp.getChanges());
    }
    queryTree=tmp.getQueryTree();
    boolean coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
    logger.info(""String_Node_Str"" + coversNegTree);
    while (!coversNegTree) {
      gens=getAllowedGeneralisationsSorted(tmp);
      if (gens.isEmpty()) {
        if (logger.isInfoEnabled()) {
          logger.info(""String_Node_Str"");
        }
        break;
      }
      tmp=gens.remove(0);
      neededGeneralisations.add(tmp.getQueryTree());
      if (logger.isInfoEnabled()) {
        logger.info(""String_Node_Str"" + tmp.getChanges());
      }
      queue.addAll(0,gens);
      logger.info(getQueueLogInfo(queue));
      coversNegTree=coversNegativeTree(tmp.getQueryTree(),negTrees);
      if (coversNegTree) {
        logger.info(""String_Node_Str"");
      }
    }
    int index=neededGeneralisations.size() - 1;
    if (coversNegTree) {
      tree2=neededGeneralisations.get(index--);
    }
 else {
      tree2=tmp.getQueryTree();
    }
    SortedSet<String> foundResources=getResources(tree2);
    foundResources.removeAll(knownResources);
    Example example;
    if (!foundResources.isEmpty()) {
      logger.info(""String_Node_Str"");
      int i=findMostSpecificResourceTree(neededGeneralisations,knownResources,0,neededGeneralisations.size() - 1);
      foundResources=getResources(neededGeneralisations.get(i));
      foundResources.removeAll(knownResources);
      logger.info(""String_Node_Str"");
      return new Example(foundResources.first(),null,null,null);
    }
 else {
      if (logger.isInfoEnabled()) {
        logger.info(""String_Node_Str"");
      }
    }
  }
  return null;
}"
9720,"private void fillTree(QueryTreeImpl<String> tree,SortedMap<String,SortedSet<Statement>> resource2Statements){
  if (resource2Statements.containsKey(tree.getUserObject())) {
    QueryTreeImpl<String> subTree;
    for (    Statement st : resource2Statements.get(tree.getUserObject())) {
      if (Filter.getAllFilterProperties().contains(st.getPredicate().toString())) {
        continue;
      }
      if (st.getObject().isLiteral()) {
        Literal lit=st.getLiteral();
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"").append(lit.getLexicalForm()).append(""String_Node_Str"");
        if (lit.getDatatypeURI() != null) {
          sb.append(""String_Node_Str"").append(lit.getDatatypeURI()).append(""String_Node_Str"");
        }
        if (!lit.getLanguage().isEmpty()) {
          sb.append(""String_Node_Str"").append(lit.getLanguage());
        }
        tree.addChild(new QueryTreeImpl<String>(sb.toString()),st.getPredicate().toString());
      }
 else {
        if (!tree.getUserObjectPathToRoot().contains(st.getObject().toString())) {
          subTree=new QueryTreeImpl<String>(st.getObject().toString());
          tree.addChild(subTree,st.getPredicate().toString());
          fillTree(subTree,resource2Statements);
        }
      }
    }
  }
}","private void fillTree(QueryTreeImpl<String> tree,SortedMap<String,SortedSet<Statement>> resource2Statements){
  if (resource2Statements.containsKey(tree.getUserObject())) {
    QueryTreeImpl<String> subTree;
    for (    Statement st : resource2Statements.get(tree.getUserObject())) {
      if (Filter.getAllFilterProperties().contains(st.getPredicate().toString())) {
        continue;
      }
      if (st.getObject().isLiteral()) {
        Literal lit=st.getLiteral();
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"").append(lit.getLexicalForm()).append(""String_Node_Str"");
        if (lit.getDatatypeURI() != null) {
          sb.append(""String_Node_Str"").append(lit.getDatatypeURI()).append(""String_Node_Str"");
        }
        if (!lit.getLanguage().isEmpty()) {
          sb.append(""String_Node_Str"").append(lit.getLanguage());
        }
        tree.addChild(new QueryTreeImpl<String>(sb.toString()),st.getPredicate().toString());
      }
 else {
        if (tree.getUserObjectPathToRoot().size() < 3 && !tree.getUserObjectPathToRoot().contains(st.getObject().toString())) {
          subTree=new QueryTreeImpl<String>(st.getObject().toString());
          tree.addChild(subTree,st.getPredicate().toString());
          fillTree(subTree,resource2Statements);
        }
      }
    }
  }
}"
9721,"public SPARQLQueryGeneratorImpl(String endpointURL){
  this.endpointURL=endpointURL;
  modelGen=new ModelGenerator(endpointURL);
}","public SPARQLQueryGeneratorImpl(NBRStrategy nbrStrategy){
  this.nbrStrategy=nbrStrategy;
}"
9722,"private void learnPosNeg(){
  logger.info(""String_Node_Str"");
  Monitor lggMonitor=MonitorFactory.getTimeMonitor(""String_Node_Str"");
  lggMonitor.start();
  LGGGenerator<String> lggGenerator=new LGGGeneratorImpl<String>();
  QueryTree<String> lgg=lggGenerator.getLGG(posQueryTrees);
  lggMonitor.stop();
  logger.info(""String_Node_Str"");
  logger.info(lgg.getStringRepresentation());
  logger.info(""String_Node_Str"" + lggMonitor.getTotal() + ""String_Node_Str"");
  Monitor nbrMonitor=MonitorFactory.getTimeMonitor(""String_Node_Str"");
  nbrMonitor.start();
  NBRGenerator<String> nbrGenerator=new NBRGeneratorImpl<String>();
  int i=1;
  for (  QueryTree<String> nbr : nbrGenerator.getNBRs(lgg,negQueryTrees)) {
    logger.info(""String_Node_Str"" + i++);
    logger.info(nbr.getStringRepresentation());
    resultQueries.add(nbr.toSPARQLQueryString(true));
    resultTrees.add(nbr);
  }
  nbrMonitor.stop();
  logger.info(""String_Node_Str"" + nbrMonitor.getTotal() + ""String_Node_Str"");
}","private void learnPosNeg(){
  logger.info(""String_Node_Str"");
  Monitor lggMonitor=MonitorFactory.getTimeMonitor(""String_Node_Str"");
  lggMonitor.start();
  LGGGenerator<String> lggGenerator=new LGGGeneratorImpl<String>();
  lgg=lggGenerator.getLGG(posQueryTrees);
  lggMonitor.stop();
  logger.info(""String_Node_Str"");
  logger.info(lgg.getStringRepresentation());
  logger.info(""String_Node_Str"" + lggMonitor.getTotal() + ""String_Node_Str"");
  Monitor nbrMonitor=MonitorFactory.getTimeMonitor(""String_Node_Str"");
  nbrMonitor.start();
  NBRGenerator<String> nbrGenerator=new NBRGeneratorImpl<String>(nbrStrategy);
  int i=1;
  for (  QueryTree<String> nbr : nbrGenerator.getNBRs(lgg,negQueryTrees)) {
    logger.info(""String_Node_Str"" + i++);
    logger.info(nbr.getStringRepresentation());
    resultQueries.add(nbr.toSPARQLQueryString(true));
    resultTrees.add(nbr);
  }
  nbrMonitor.stop();
  logger.info(""String_Node_Str"" + nbrMonitor.getTotal() + ""String_Node_Str"");
}"
9723,"private void writeTriples2DB(String key,String value){
  try {
    PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
    ps.setBytes(1,md5(key));
    java.sql.ResultSet rs=ps.executeQuery();
    if (rs.next()) {
      int id=rs.getInt(""String_Node_Str"");
      ps=conn.prepareStatement(""String_Node_Str"");
      ps.setClob(1,new StringReader(value));
      ps.setTimestamp(2,new java.sql.Timestamp(new java.util.Date().getTime()));
      ps.setInt(3,id);
      ps.executeUpdate();
    }
 else {
      ps=conn.prepareStatement(""String_Node_Str"");
      ps.setBytes(1,md5(key));
      ps.setClob(2,new StringReader(value));
      ps.setTimestamp(3,new java.sql.Timestamp(new java.util.Date().getTime()));
      ps.addBatch();
    }
  }
 catch (  SQLException e) {
    logger.error(""String_Node_Str"" + key + ""String_Node_Str"",e);
  }
}","private void writeTriples2DB(String key,String value){
  try {
    PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
    ps.setBytes(1,md5(key));
    java.sql.ResultSet rs=ps.executeQuery();
    if (rs.next()) {
      int id=rs.getInt(""String_Node_Str"");
      ps=conn.prepareStatement(""String_Node_Str"");
      ps.setClob(1,new StringReader(value));
      ps.setTimestamp(2,new java.sql.Timestamp(new java.util.Date().getTime()));
      ps.setInt(3,id);
      ps.executeUpdate();
    }
 else {
      ps=conn.prepareStatement(""String_Node_Str"");
      ps.setBytes(1,md5(key));
      ps.setClob(2,new StringReader(value));
      ps.setTimestamp(3,new java.sql.Timestamp(new java.util.Date().getTime()));
      ps.executeUpdate();
    }
  }
 catch (  SQLException e) {
    logger.error(""String_Node_Str"" + key + ""String_Node_Str"",e);
  }
}"
9724,"private int getResourceID(String resource){
  int id=-1;
  try {
    PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
    ps.setBytes(1,md5(resource));
    java.sql.ResultSet rs=ps.executeQuery();
    if (rs.next()) {
      id=rs.getInt(""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    logger.error(""String_Node_Str"" + resource + ""String_Node_Str"",e);
    e.printStackTrace();
  }
  return -1;
}","private int getResourceID(String resource){
  int id=-1;
  try {
    PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
    ps.setBytes(1,md5(resource));
    java.sql.ResultSet rs=ps.executeQuery();
    if (rs.next()) {
      id=rs.getInt(""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    logger.error(""String_Node_Str"" + resource + ""String_Node_Str"",e);
    e.printStackTrace();
  }
  return id;
}"
9725,"public void fillCache(int limit){
  monitor.reset();
  monitor.start();
  logger.info(""String_Node_Str"");
  Model model;
  com.hp.hpl.jena.rdf.model.Statement st;
  String objectURI;
  String modelStr;
  int i=0;
  logger.info(""String_Node_Str"" + i * CHUNK_SIZE + ""String_Node_Str"" + i * CHUNK_SIZE + CHUNK_SIZE);
  List<String> resources=getResources(CHUNK_SIZE,i * CHUNK_SIZE);
  logger.info(""String_Node_Str"" + resources);
  while (!resources.isEmpty()) {
    for (    String resource : resources) {
      logger.info(""String_Node_Str"" + resource);
      queryMonitor.start();
      model=createModel(resource);
      queryMonitor.stop();
      logger.info(""String_Node_Str"" + model.size() + ""String_Node_Str""+ queryMonitor.getLastValue() / 1000 + ""String_Node_Str"");
      modelStr=convertModel2String(model);
      logger.info(""String_Node_Str"");
      dbMonitor.start();
      writeTriples2DB(resource,modelStr);
      int id=getResourceID(resource);
      if (id != -1) {
        for (StmtIterator iter=model.listStatements(); iter.hasNext(); ) {
          st=iter.next();
          if (st.getObject().isURIResource()) {
            objectURI=st.getObject().asResource().getURI();
            if (objectURI.startsWith(""String_Node_Str"")) {
              logger.info(""String_Node_Str"" + resource + ""String_Node_Str""+ objectURI);
              logger.info(""String_Node_Str"" + resource + ""String_Node_Str""+ id);
              writeKey2KeyIntoDB(id,objectURI);
            }
          }
        }
      }
 else {
        logger.info(""String_Node_Str"" + resource);
      }
      dbMonitor.stop();
    }
    i++;
    if (limit != -1 && i * CHUNK_SIZE >= limit) {
      break;
    }
    logger.info(""String_Node_Str"" + i * CHUNK_SIZE + ""String_Node_Str"" + i * CHUNK_SIZE + CHUNK_SIZE);
    resources=getResources(CHUNK_SIZE,i * CHUNK_SIZE);
    logger.info(""String_Node_Str"" + resources);
  }
  monitor.stop();
  logger.info(""String_Node_Str"" + queryMonitor.getTotal() / 1000 + ""String_Node_Str"");
  logger.info(""String_Node_Str"" + dbMonitor.getTotal() / 1000 + ""String_Node_Str"");
  logger.info(""String_Node_Str"" + monitor.getTotal() / 1000 + ""String_Node_Str"");
  try {
    conn.close();
  }
 catch (  SQLException e) {
    e.printStackTrace();
  }
}","public void fillCache(int limit){
  monitor.reset();
  monitor.start();
  logger.info(""String_Node_Str"");
  Model model;
  com.hp.hpl.jena.rdf.model.Statement st;
  String objectURI;
  String modelStr;
  int i=0;
  logger.info(""String_Node_Str"" + i * CHUNK_SIZE + ""String_Node_Str"" + i * CHUNK_SIZE + CHUNK_SIZE);
  List<String> resources=getResources(CHUNK_SIZE,i * CHUNK_SIZE);
  logger.info(""String_Node_Str"" + resources);
  while (!resources.isEmpty()) {
    for (    String resource : resources) {
      logger.info(""String_Node_Str"" + resource);
      queryMonitor.start();
      model=createModel(resource);
      queryMonitor.stop();
      logger.info(""String_Node_Str"" + model.size() + ""String_Node_Str""+ queryMonitor.getLastValue() / 1000 + ""String_Node_Str"");
      modelStr=convertModel2String(model);
      logger.info(""String_Node_Str"");
      dbMonitor.start();
      writeTriples2DB(resource,modelStr);
      int id=getResourceID(resource);
      writeKey2KeyIntoDB(id,id);
      if (id != -1) {
        for (StmtIterator iter=model.listStatements(); iter.hasNext(); ) {
          st=iter.next();
          if (st.getObject().isURIResource()) {
            objectURI=st.getObject().asResource().getURI();
            if (objectURI.startsWith(""String_Node_Str"")) {
              logger.info(""String_Node_Str"" + resource + ""String_Node_Str""+ objectURI);
              logger.info(""String_Node_Str"" + resource + ""String_Node_Str""+ id);
              writeKey2KeyIntoDB(id,objectURI);
            }
          }
        }
      }
 else {
        logger.info(""String_Node_Str"" + resource);
      }
      dbMonitor.stop();
    }
    i++;
    if (limit != -1 && i * CHUNK_SIZE >= limit) {
      break;
    }
    logger.info(""String_Node_Str"" + i * CHUNK_SIZE + ""String_Node_Str"" + i * CHUNK_SIZE + CHUNK_SIZE);
    resources=getResources(CHUNK_SIZE,i * CHUNK_SIZE);
    logger.info(""String_Node_Str"" + resources);
  }
  monitor.stop();
  logger.info(""String_Node_Str"" + queryMonitor.getTotal() / 1000 + ""String_Node_Str"");
  logger.info(""String_Node_Str"" + dbMonitor.getTotal() / 1000 + ""String_Node_Str"");
  logger.info(""String_Node_Str"" + monitor.getTotal() / 1000 + ""String_Node_Str"");
  try {
    conn.close();
  }
 catch (  SQLException e) {
    e.printStackTrace();
  }
}"
9726,"private Model getModelIncrementallyRec(String resource,int depth){
  logger.debug(""String_Node_Str"" + resource);
  Query query=makeConstructQuery(resource);
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"" + query.toString());
  queryMonitor.start();
  QueryExecution qexec=QueryExecutionFactory.sparqlService(endpoint.getURL().toString(),query,endpoint.getDefaultGraphURIs(),endpoint.getNamedGraphURIs());
  Model model=qexec.execConstruct();
  logger.debug(""String_Node_Str"" + model.size() + ""String_Node_Str"");
  Statement st=null;
  for (Iterator<Statement> i=model.listStatements(); i.hasNext(); st=i.next()) {
    logger.debug(st);
  }
  if (depth < recursionDepth) {
    Model tmp=ModelFactory.createDefaultModel();
    for (Iterator<Statement> i=model.listStatements(); i.hasNext(); ) {
      st=i.next();
      if (st.getObject().isURIResource()) {
        tmp.add(getModelIncrementallyRec(st.getObject().toString(),depth++));
      }
    }
    model.add(tmp);
  }
  return model;
}","private Model getModelIncrementallyRec(String resource,int depth){
  logger.debug(""String_Node_Str"" + resource);
  Query query=makeConstructQuery(resource,predicateFilters);
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"" + query.toString());
  queryMonitor.start();
  QueryExecution qexec=QueryExecutionFactory.sparqlService(endpoint.getURL().toString(),query,endpoint.getDefaultGraphURIs(),endpoint.getNamedGraphURIs());
  Model model=qexec.execConstruct();
  logger.debug(""String_Node_Str"" + model.size() + ""String_Node_Str"");
  Statement st=null;
  for (Iterator<Statement> i=model.listStatements(); i.hasNext(); st=i.next()) {
    logger.debug(st);
  }
  if (depth < recursionDepth) {
    Model tmp=ModelFactory.createDefaultModel();
    for (Iterator<Statement> i=model.listStatements(); i.hasNext(); ) {
      st=i.next();
      if (st.getObject().isURIResource()) {
        tmp.add(getModelIncrementallyRec(st.getObject().toString(),depth + 1));
      }
    }
    model.add(tmp);
  }
  return model;
}"
9727,"/** 
 * A SPARQL CONSTRUCT query is created, to get a RDF graph for the given example with a specific recursion depth.
 * @param example The example resource for which a CONSTRUCT query is created.
 * @return The JENA ARQ Query object.
 */
private Query makeConstructQueryOptional(String resource,int limit,int offset){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(resource).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  for (int i=1; i < recursionDepth; i++) {
    sb.append(""String_Node_Str"").append(i - 1).append(""String_Node_Str"").append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(""String_Node_Str"").append(i).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(resource).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  for (int i=1; i < recursionDepth; i++) {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(i - 1).append(""String_Node_Str"").append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(""String_Node_Str"").append(i).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (int i=1; i < recursionDepth; i++) {
    sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (int i=0; i < recursionDepth; i++) {
    sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(""String_Node_Str"").append(i).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(limit).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(offset);
  Query query=QueryFactory.create(sb.toString());
  return query;
}","/** 
 * A SPARQL CONSTRUCT query is created, to get a RDF graph for the given example with a specific recursion depth.
 * @param example The example resource for which a CONSTRUCT query is created.
 * @return The JENA ARQ Query object.
 */
private Query makeConstructQueryOptional(String resource,int limit,int offset,Set<String> predicateFilter){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(resource).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  for (int i=1; i < recursionDepth; i++) {
    sb.append(""String_Node_Str"").append(i - 1).append(""String_Node_Str"").append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(""String_Node_Str"").append(i).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(resource).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  for (int i=1; i < recursionDepth; i++) {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(i - 1).append(""String_Node_Str"").append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(""String_Node_Str"").append(i).append(""String_Node_Str"");
  }
  for (int i=1; i < recursionDepth; i++) {
    sb.append(""String_Node_Str"");
  }
  for (int i=0; i < recursionDepth; i++) {
    for (    String predicate : predicateFilter) {
      sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(predicate).append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(limit).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(offset);
  Query query=QueryFactory.create(sb.toString());
  return query;
}"
9728,"public Model createModel(String resource,Strategy strategy,int recursionDepth){
  this.recursionDepth=recursionDepth;
  if (strategy == Strategy.INCREMENTALLY) {
    return getModelIncrementallyRec(resource,0);
  }
 else   if (strategy == Strategy.CHUNKS) {
    return getModel(resource);
  }
 else   if (strategy == null) {
    return getModelOptional(resource);
  }
  return ModelFactory.createDefaultModel();
}","public Model createModel(String resource,Strategy strategy,int recursionDepth){
  this.recursionDepth=recursionDepth;
  if (strategy == Strategy.INCREMENTALLY) {
    return getModelIncrementallyRec(resource,0);
  }
 else   if (strategy == Strategy.CHUNKS) {
    return getModelChunked(resource);
  }
  return ModelFactory.createDefaultModel();
}"
9729,"/** 
 * A SPARQL CONSTRUCT query is created, to get a RDF graph for the given example.
 * @param example The example resource for which a CONSTRUCT query is created.
 * @return The JENA ARQ Query object.
 */
private Query makeConstructQuery(String example){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(example).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(example).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  Query query=QueryFactory.create(sb.toString());
  return query;
}","/** 
 * A SPARQL CONSTRUCT query is created, to get a RDF graph for the given example.
 * @param example The example resource for which a CONSTRUCT query is created.
 * @return The JENA ARQ Query object.
 */
private Query makeConstructQuery(String example,Set<String> predicateFilters){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(example).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(example).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  for (  String predicate : predicateFilters) {
    sb.append(""String_Node_Str"").append(predicate).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  Query query=QueryFactory.create(sb.toString());
  return query;
}"
9730,"public Model executeConstructQuery(SparqlEndpoint endpoint,String query) throws SQLException, UnsupportedEncodingException {
  byte[] md5=md5(query);
  PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
  ps.setBytes(1,md5);
  ResultSet rs=ps.executeQuery();
  boolean readFromCache=rs.next() && (rs.getTimestamp(""String_Node_Str"").getTime() - System.currentTimeMillis() < freshnessSeconds);
  if (readFromCache) {
    Clob clob=rs.getClob(""String_Node_Str"");
    Model readModel=ModelFactory.createDefaultModel();
    readModel.read(clob.getAsciiStream(),null,""String_Node_Str"");
    return readModel;
  }
 else {
    QueryEngineHTTP queryExecution=new QueryEngineHTTP(endpoint.getURL().toString(),query);
    for (    String dgu : endpoint.getDefaultGraphURIs()) {
      queryExecution.addDefaultGraph(dgu);
    }
    for (    String ngu : endpoint.getNamedGraphURIs()) {
      queryExecution.addNamedGraph(ngu);
    }
    Model m2=queryExecution.execConstruct();
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    m2.write(baos,""String_Node_Str"");
    String modelStr=baos.toString(""String_Node_Str"");
    PreparedStatement ps2=conn.prepareStatement(""String_Node_Str"");
    ps2.setBytes(1,md5);
    ps2.setString(2,query);
    ps2.setClob(3,new StringReader(modelStr));
    ps2.setTimestamp(4,new java.sql.Timestamp(new java.util.Date().getTime()));
    ps2.executeUpdate();
    return m2;
  }
}","public Model executeConstructQuery(SparqlEndpoint endpoint,String query) throws SQLException, UnsupportedEncodingException {
  byte[] md5=md5(query);
  PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
  ps.setBytes(1,md5);
  ResultSet rs=ps.executeQuery();
  boolean entryExists=rs.next();
  boolean readFromCache=entryExists && (System.currentTimeMillis() - rs.getTimestamp(""String_Node_Str"").getTime() < freshnessInMilliseconds);
  if (readFromCache) {
    Clob clob=rs.getClob(""String_Node_Str"");
    Model readModel=ModelFactory.createDefaultModel();
    readModel.read(clob.getAsciiStream(),null,""String_Node_Str"");
    return readModel;
  }
 else {
    QueryEngineHTTP queryExecution=new QueryEngineHTTP(endpoint.getURL().toString(),query);
    for (    String dgu : endpoint.getDefaultGraphURIs()) {
      queryExecution.addDefaultGraph(dgu);
    }
    for (    String ngu : endpoint.getNamedGraphURIs()) {
      queryExecution.addNamedGraph(ngu);
    }
    Model m2=queryExecution.execConstruct();
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    m2.write(baos,""String_Node_Str"");
    String modelStr=baos.toString(""String_Node_Str"");
    PreparedStatement ps2;
    if (entryExists) {
      ps2=conn.prepareStatement(""String_Node_Str"");
      ps2.setClob(1,new StringReader(modelStr));
      ps2.setTimestamp(2,new java.sql.Timestamp(new java.util.Date().getTime()));
      ps2.setBytes(3,md5);
    }
 else {
      ps2=conn.prepareStatement(""String_Node_Str"");
      ps2.setBytes(1,md5);
      ps2.setString(2,query);
      ps2.setClob(3,new StringReader(modelStr));
      ps2.setTimestamp(4,new java.sql.Timestamp(new java.util.Date().getTime()));
    }
    ps2.executeUpdate();
    return m2;
  }
}"
9731,"public String executeSelectQuery(SparqlEndpoint endpoint,String query){
  try {
    byte[] md5=md5(query);
    PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
    ps.setBytes(1,md5);
    ResultSet rs=ps.executeQuery();
    boolean readFromCache=rs.next() && (rs.getTimestamp(""String_Node_Str"").getTime() - System.currentTimeMillis() < freshnessSeconds);
    if (readFromCache) {
      Clob clob=rs.getClob(""String_Node_Str"");
      return clob.getSubString(1,(int)clob.length());
    }
 else {
      QueryEngineHTTP queryExecution=new QueryEngineHTTP(endpoint.getURL().toString(),query);
      for (      String dgu : endpoint.getDefaultGraphURIs()) {
        queryExecution.addDefaultGraph(dgu);
      }
      for (      String ngu : endpoint.getNamedGraphURIs()) {
        queryExecution.addNamedGraph(ngu);
      }
      com.hp.hpl.jena.query.ResultSet tmp=queryExecution.execSelect();
      ResultSetRewindable rs2=ResultSetFactory.makeRewindable(tmp);
      String json=SparqlQuery.convertResultSetToJSON(rs2);
      PreparedStatement ps2=conn.prepareStatement(""String_Node_Str"");
      ps2.setBytes(1,md5);
      ps2.setString(2,query);
      ps2.setClob(3,new StringReader(json));
      ps2.setTimestamp(4,new java.sql.Timestamp(new java.util.Date().getTime()));
      ps2.executeUpdate();
      return json;
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
    return null;
  }
}","public String executeSelectQuery(SparqlEndpoint endpoint,String query){
  try {
    byte[] md5=md5(query);
    PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
    ps.setBytes(1,md5);
    ResultSet rs=ps.executeQuery();
    boolean entryExists=rs.next();
    boolean readFromCache=entryExists && (System.currentTimeMillis() - rs.getTimestamp(""String_Node_Str"").getTime() < freshnessInMilliseconds);
    if (readFromCache) {
      Clob clob=rs.getClob(""String_Node_Str"");
      return clob.getSubString(1,(int)clob.length());
    }
 else {
      QueryEngineHTTP queryExecution=new QueryEngineHTTP(endpoint.getURL().toString(),query);
      for (      String dgu : endpoint.getDefaultGraphURIs()) {
        queryExecution.addDefaultGraph(dgu);
      }
      for (      String ngu : endpoint.getNamedGraphURIs()) {
        queryExecution.addNamedGraph(ngu);
      }
      com.hp.hpl.jena.query.ResultSet tmp=queryExecution.execSelect();
      ResultSetRewindable rs2=ResultSetFactory.makeRewindable(tmp);
      String json=SparqlQuery.convertResultSetToJSON(rs2);
      PreparedStatement ps2;
      if (entryExists) {
        ps2=conn.prepareStatement(""String_Node_Str"");
        ps2.setClob(1,new StringReader(json));
        ps2.setTimestamp(2,new java.sql.Timestamp(new java.util.Date().getTime()));
        ps2.setBytes(3,md5);
      }
 else {
        ps2=conn.prepareStatement(""String_Node_Str"");
        ps2.setBytes(1,md5);
        ps2.setString(2,query);
        ps2.setClob(3,new StringReader(json));
        ps2.setTimestamp(4,new java.sql.Timestamp(new java.util.Date().getTime()));
      }
      ps2.executeUpdate();
      return json;
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
    return null;
  }
}"
9732,"public static void main(String[] args) throws ClassNotFoundException, SQLException, NoSuchAlgorithmException, UnsupportedEncodingException {
  SparqlEndpoint endpoint=SparqlEndpoint.getEndpointLOCALDBpedia();
  String resource=""String_Node_Str"";
  String query=""String_Node_Str"" + resource + ""String_Node_Str""+ resource+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + query);
  ExtractionDBCache h2=new ExtractionDBCache(""String_Node_Str"");
  long startTime=System.nanoTime();
  Model m=h2.executeConstructQuery(endpoint,query);
  for (int i=0; i < 1000; i++) {
    h2.executeConstructQuery(endpoint,query);
  }
  long runTime=System.nanoTime() - startTime;
  System.out.println(""String_Node_Str"" + Helper.prettyPrintNanoSeconds(runTime));
  System.out.println(ExtractionDBCache.toNTriple(m));
}","public static void main(String[] args) throws ClassNotFoundException, SQLException, NoSuchAlgorithmException, UnsupportedEncodingException {
  SparqlEndpoint endpoint=SparqlEndpoint.getEndpointDBpediaLiveAKSW();
  String resource=""String_Node_Str"";
  String query=""String_Node_Str"" + resource + ""String_Node_Str""+ resource+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + query);
  ExtractionDBCache h2=new ExtractionDBCache(""String_Node_Str"");
  long startTime=System.nanoTime();
  Model m=h2.executeConstructQuery(endpoint,query);
  long runTime=System.nanoTime() - startTime;
  System.out.println(""String_Node_Str"" + Helper.prettyPrintNanoSeconds(runTime));
  System.out.println(ExtractionDBCache.toNTriple(m));
}"
9733,"public CrossValidation(File file,int folds,boolean leaveOneOut,LearningAlgorithm la){
  DecimalFormat df=new DecimalFormat();
  ComponentManager cm=ComponentManager.getInstance();
  Start start=null;
  try {
    start=new Start(file);
  }
 catch (  ComponentInitException e) {
    e.printStackTrace();
  }
catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  ParseException e) {
    e.printStackTrace();
  }
  LearningProblem lp=start.getLearningProblem();
  List<Set<Individual>> trainingSetsPos=new LinkedList<Set<Individual>>();
  List<Set<Individual>> trainingSetsNeg=new LinkedList<Set<Individual>>();
  List<Set<Individual>> testSetsPos=new LinkedList<Set<Individual>>();
  List<Set<Individual>> testSetsNeg=new LinkedList<Set<Individual>>();
  if (lp instanceof PosNegLP) {
    Set<Individual> posExamples=((PosNegLP)lp).getPositiveExamples();
    List<Individual> posExamplesList=new LinkedList<Individual>(posExamples);
    Collections.shuffle(posExamplesList,new Random(1));
    Set<Individual> negExamples=((PosNegLP)lp).getNegativeExamples();
    List<Individual> negExamplesList=new LinkedList<Individual>(negExamples);
    Collections.shuffle(negExamplesList,new Random(2));
    if (!leaveOneOut && (posExamples.size() < folds && negExamples.size() < folds)) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      System.exit(0);
    }
    if (leaveOneOut) {
      int nrOfExamples=posExamples.size() + negExamples.size();
      for (int i=0; i < nrOfExamples; i++) {
      }
      System.out.println(""String_Node_Str"");
      System.exit(1);
    }
 else {
      int[] splitsPos=calculateSplits(posExamples.size(),folds);
      int[] splitsNeg=calculateSplits(negExamples.size(),folds);
      for (int i=0; i < folds; i++) {
        Set<Individual> testPos=getTestingSet(posExamplesList,splitsPos,i);
        Set<Individual> testNeg=getTestingSet(negExamplesList,splitsNeg,i);
        testSetsPos.add(i,testPos);
        testSetsNeg.add(i,testNeg);
        trainingSetsPos.add(i,getTrainingSet(posExamples,testPos));
        trainingSetsNeg.add(i,getTrainingSet(negExamples,testNeg));
      }
    }
  }
 else   if (lp instanceof PosOnlyLP) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
 else {
    System.out.println(""String_Node_Str"" + lp + ""String_Node_Str"");
    System.exit(0);
  }
  for (int currFold=0; currFold < folds; currFold++) {
    try {
      start=new Start(file);
    }
 catch (    ComponentInitException e) {
      e.printStackTrace();
    }
catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    ParseException e) {
      e.printStackTrace();
    }
    lp=start.getLearningProblem();
    Set<String> pos=Datastructures.individualSetToStringSet(trainingSetsPos.get(currFold));
    Set<String> neg=Datastructures.individualSetToStringSet(trainingSetsNeg.get(currFold));
    cm.applyConfigEntry(lp,""String_Node_Str"",pos);
    cm.applyConfigEntry(lp,""String_Node_Str"",neg);
    la=start.getLearningAlgorithm();
    try {
      lp.init();
      la.init();
    }
 catch (    ComponentInitException e) {
      e.printStackTrace();
    }
    long algorithmStartTime=System.nanoTime();
    la.start();
    long algorithmDuration=System.nanoTime() - algorithmStartTime;
    runtime.addNumber(algorithmDuration / (double)1000000000);
    Description concept=la.getCurrentlyBestDescription();
    ReasonerComponent rs=start.getReasonerComponent();
    Set<Individual> tmp=rs.hasType(concept,testSetsPos.get(currFold));
    Set<Individual> tmp2=Helper.difference(testSetsPos.get(currFold),tmp);
    Set<Individual> tmp3=rs.hasType(concept,testSetsNeg.get(currFold));
    System.out.println(""String_Node_Str"" + tmp2);
    System.out.println(""String_Node_Str"" + tmp3);
    int trainingCorrectPosClassified=getCorrectPosClassified(rs,concept,trainingSetsPos.get(currFold));
    int trainingCorrectNegClassified=getCorrectNegClassified(rs,concept,trainingSetsNeg.get(currFold));
    int trainingCorrectExamples=trainingCorrectPosClassified + trainingCorrectNegClassified;
    double trainingAccuracy=100 * ((double)trainingCorrectExamples / (trainingSetsPos.get(currFold).size() + trainingSetsNeg.get(currFold).size()));
    accuracyTraining.addNumber(trainingAccuracy);
    int correctPosClassified=getCorrectPosClassified(rs,concept,testSetsPos.get(currFold));
    int correctNegClassified=getCorrectNegClassified(rs,concept,testSetsNeg.get(currFold));
    int correctExamples=correctPosClassified + correctNegClassified;
    double currAccuracy=100 * ((double)correctExamples / (testSetsPos.get(currFold).size() + testSetsNeg.get(currFold).size()));
    accuracy.addNumber(currAccuracy);
    length.addNumber(concept.getLength());
    System.out.println(""String_Node_Str"" + currFold + ""String_Node_Str""+ file+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + pos.size() + ""String_Node_Str""+ neg.size()+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + correctPosClassified + ""String_Node_Str""+ testSetsPos.get(currFold).size()+ ""String_Node_Str""+ correctNegClassified+ ""String_Node_Str""+ testSetsNeg.get(currFold).size()+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + concept);
    System.out.println(""String_Node_Str"" + df.format(currAccuracy) + ""String_Node_Str""+ df.format(trainingAccuracy)+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + df.format(concept.getLength()));
    System.out.println(""String_Node_Str"" + df.format(algorithmDuration / (double)1000000000) + ""String_Node_Str"");
    rs.releaseKB();
    cm.freeAllComponents();
  }
  System.out.println();
  System.out.println(""String_Node_Str"" + folds + ""String_Node_Str""+ file+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + statOutput(df,runtime,""String_Node_Str""));
  System.out.println(""String_Node_Str"" + statOutput(df,length,""String_Node_Str""));
  System.out.println(""String_Node_Str"" + statOutput(df,accuracy,""String_Node_Str""));
  System.out.println(""String_Node_Str"" + statOutput(df,accuracyTraining,""String_Node_Str""));
}","public CrossValidation(File file,int folds,boolean leaveOneOut,LearningAlgorithm la){
  DecimalFormat df=new DecimalFormat();
  ComponentManager cm=ComponentManager.getInstance();
  Start start=null;
  try {
    start=new Start(file);
  }
 catch (  ComponentInitException e) {
    e.printStackTrace();
  }
catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  org.dllearner.confparser.ParseException e) {
    e.printStackTrace();
  }
  LearningProblem lp=start.getLearningProblem();
  List<Set<Individual>> trainingSetsPos=new LinkedList<Set<Individual>>();
  List<Set<Individual>> trainingSetsNeg=new LinkedList<Set<Individual>>();
  List<Set<Individual>> testSetsPos=new LinkedList<Set<Individual>>();
  List<Set<Individual>> testSetsNeg=new LinkedList<Set<Individual>>();
  if (lp instanceof PosNegLP) {
    Set<Individual> posExamples=((PosNegLP)lp).getPositiveExamples();
    List<Individual> posExamplesList=new LinkedList<Individual>(posExamples);
    Collections.shuffle(posExamplesList,new Random(1));
    Set<Individual> negExamples=((PosNegLP)lp).getNegativeExamples();
    List<Individual> negExamplesList=new LinkedList<Individual>(negExamples);
    Collections.shuffle(negExamplesList,new Random(2));
    if (!leaveOneOut && (posExamples.size() < folds && negExamples.size() < folds)) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      System.exit(0);
    }
    if (leaveOneOut) {
      int nrOfExamples=posExamples.size() + negExamples.size();
      for (int i=0; i < nrOfExamples; i++) {
      }
      System.out.println(""String_Node_Str"");
      System.exit(1);
    }
 else {
      int[] splitsPos=calculateSplits(posExamples.size(),folds);
      int[] splitsNeg=calculateSplits(negExamples.size(),folds);
      for (int i=0; i < folds; i++) {
        Set<Individual> testPos=getTestingSet(posExamplesList,splitsPos,i);
        Set<Individual> testNeg=getTestingSet(negExamplesList,splitsNeg,i);
        testSetsPos.add(i,testPos);
        testSetsNeg.add(i,testNeg);
        trainingSetsPos.add(i,getTrainingSet(posExamples,testPos));
        trainingSetsNeg.add(i,getTrainingSet(negExamples,testNeg));
      }
    }
  }
 else   if (lp instanceof PosOnlyLP) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
 else {
    System.out.println(""String_Node_Str"" + lp + ""String_Node_Str"");
    System.exit(0);
  }
  for (int currFold=0; currFold < folds; currFold++) {
    try {
      start=new Start(file);
    }
 catch (    ComponentInitException e) {
      e.printStackTrace();
    }
catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    org.dllearner.confparser.ParseException e) {
      e.printStackTrace();
    }
    lp=start.getLearningProblem();
    Set<String> pos=Datastructures.individualSetToStringSet(trainingSetsPos.get(currFold));
    Set<String> neg=Datastructures.individualSetToStringSet(trainingSetsNeg.get(currFold));
    cm.applyConfigEntry(lp,""String_Node_Str"",pos);
    cm.applyConfigEntry(lp,""String_Node_Str"",neg);
    la=start.getLearningAlgorithm();
    try {
      lp.init();
      la.init();
    }
 catch (    ComponentInitException e) {
      e.printStackTrace();
    }
    long algorithmStartTime=System.nanoTime();
    la.start();
    long algorithmDuration=System.nanoTime() - algorithmStartTime;
    runtime.addNumber(algorithmDuration / (double)1000000000);
    Description concept=la.getCurrentlyBestDescription();
    ReasonerComponent rs=start.getReasonerComponent();
    Set<Individual> tmp=rs.hasType(concept,testSetsPos.get(currFold));
    Set<Individual> tmp2=Helper.difference(testSetsPos.get(currFold),tmp);
    Set<Individual> tmp3=rs.hasType(concept,testSetsNeg.get(currFold));
    System.out.println(""String_Node_Str"" + tmp2);
    System.out.println(""String_Node_Str"" + tmp3);
    int trainingCorrectPosClassified=getCorrectPosClassified(rs,concept,trainingSetsPos.get(currFold));
    int trainingCorrectNegClassified=getCorrectNegClassified(rs,concept,trainingSetsNeg.get(currFold));
    int trainingCorrectExamples=trainingCorrectPosClassified + trainingCorrectNegClassified;
    double trainingAccuracy=100 * ((double)trainingCorrectExamples / (trainingSetsPos.get(currFold).size() + trainingSetsNeg.get(currFold).size()));
    accuracyTraining.addNumber(trainingAccuracy);
    int correctPosClassified=getCorrectPosClassified(rs,concept,testSetsPos.get(currFold));
    int correctNegClassified=getCorrectNegClassified(rs,concept,testSetsNeg.get(currFold));
    int correctExamples=correctPosClassified + correctNegClassified;
    double currAccuracy=100 * ((double)correctExamples / (testSetsPos.get(currFold).size() + testSetsNeg.get(currFold).size()));
    accuracy.addNumber(currAccuracy);
    length.addNumber(concept.getLength());
    System.out.println(""String_Node_Str"" + currFold + ""String_Node_Str""+ file+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + pos.size() + ""String_Node_Str""+ neg.size()+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + correctPosClassified + ""String_Node_Str""+ testSetsPos.get(currFold).size()+ ""String_Node_Str""+ correctNegClassified+ ""String_Node_Str""+ testSetsNeg.get(currFold).size()+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + concept);
    System.out.println(""String_Node_Str"" + df.format(currAccuracy) + ""String_Node_Str""+ df.format(trainingAccuracy)+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + df.format(concept.getLength()));
    System.out.println(""String_Node_Str"" + df.format(algorithmDuration / (double)1000000000) + ""String_Node_Str"");
    rs.releaseKB();
    cm.freeAllComponents();
  }
  System.out.println();
  System.out.println(""String_Node_Str"" + folds + ""String_Node_Str""+ file+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + statOutput(df,runtime,""String_Node_Str""));
  System.out.println(""String_Node_Str"" + statOutput(df,length,""String_Node_Str""));
  System.out.println(""String_Node_Str"" + statOutput(df,accuracy,""String_Node_Str""));
  System.out.println(""String_Node_Str"" + statOutput(df,accuracyTraining,""String_Node_Str""));
}"
9734,"public NestedCrossValidation(File confFile,int outerFolds,int innerFolds,String parameter,int startValue,int endValue,boolean verbose) throws FileNotFoundException, ComponentInitException, ParseException {
  DecimalFormat df=new DecimalFormat();
  ComponentManager cm=ComponentManager.getInstance();
  Start start=new Start(confFile);
  LearningProblem lp=start.getLearningProblem();
  if (!(lp instanceof PosNegLP)) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  LinkedList<Individual> posExamples=new LinkedList<Individual>(((PosNegLP)lp).getPositiveExamples());
  Collections.shuffle(posExamples,new Random(1));
  LinkedList<Individual> negExamples=new LinkedList<Individual>(((PosNegLP)lp).getNegativeExamples());
  Collections.shuffle(negExamples,new Random(2));
  ReasonerComponent rc=start.getReasonerComponent();
  String baseURI=rc.getBaseURI();
  List<TrainTestList> posLists=getFolds(posExamples,outerFolds);
  List<TrainTestList> negLists=getFolds(negExamples,outerFolds);
  Stat accOverall=new Stat();
  Stat fOverall=new Stat();
  Stat recallOverall=new Stat();
  Stat precisionOverall=new Stat();
  for (int currOuterFold=0; currOuterFold < outerFolds; currOuterFold++) {
    System.out.println(""String_Node_Str"" + currOuterFold);
    TrainTestList posList=posLists.get(currOuterFold);
    TrainTestList negList=negLists.get(currOuterFold);
    Map<Integer,Stat> paraStats=new HashMap<Integer,Stat>();
    for (int currParaValue=startValue; currParaValue <= endValue; currParaValue++) {
      System.out.println(""String_Node_Str"" + currParaValue + ""String_Node_Str"");
      List<Individual> trainPosList=posList.getTrainList();
      List<TrainTestList> innerPosLists=getFolds(trainPosList,innerFolds);
      List<Individual> trainNegList=negList.getTrainList();
      List<TrainTestList> innerNegLists=getFolds(trainNegList,innerFolds);
      Stat paraCriterionStat=new Stat();
      for (int currInnerFold=0; currInnerFold < innerFolds; currInnerFold++) {
        System.out.println(""String_Node_Str"" + currInnerFold + ""String_Node_Str"");
        Set<Individual> posEx=new TreeSet<Individual>(innerPosLists.get(currInnerFold).getTrainList());
        Set<Individual> negEx=new TreeSet<Individual>(innerNegLists.get(currInnerFold).getTrainList());
        start=new Start(confFile);
        LearningProblem lpIn=start.getLearningProblem();
        cm.applyConfigEntry(lpIn,""String_Node_Str"",Datastructures.individualSetToStringSet(posEx));
        cm.applyConfigEntry(lpIn,""String_Node_Str"",Datastructures.individualSetToStringSet(negEx));
        LearningAlgorithm laIn=start.getLearningAlgorithm();
        cm.applyConfigEntry(laIn,parameter,(double)currParaValue);
        lpIn.init();
        laIn.init();
        laIn.start();
        Description concept=laIn.getCurrentlyBestDescription();
        TreeSet<Individual> posTest=new TreeSet<Individual>(innerPosLists.get(currInnerFold).getTestList());
        TreeSet<Individual> negTest=new TreeSet<Individual>(innerNegLists.get(currInnerFold).getTestList());
        ReasonerComponent rs=start.getReasonerComponent();
        Set<Individual> posCorrect=rs.hasType(concept,posTest);
        Set<Individual> posError=Helper.difference(posTest,posCorrect);
        Set<Individual> negError=rs.hasType(concept,negTest);
        Set<Individual> negCorrect=Helper.difference(negTest,negError);
        double accuracy=100 * ((double)(posCorrect.size() + negCorrect.size()) / (posTest.size() + negTest.size()));
        double precision=100 * (double)posCorrect.size() / (posCorrect.size() + negError.size());
        double recall=100 * (double)posCorrect.size() / (posCorrect.size() + posError.size());
        double fmeasure=2 * (precision * recall) / (precision + recall);
        paraCriterionStat.addNumber(accuracy);
        System.out.println(""String_Node_Str"" + concept.toManchesterSyntaxString(baseURI,null));
        System.out.println(""String_Node_Str"" + df.format(accuracy) + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + df.format(precision) + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + df.format(recall) + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + df.format(fmeasure) + ""String_Node_Str"");
        if (verbose) {
          System.out.println(""String_Node_Str"" + formatIndividualSet(posError,baseURI));
          System.out.println(""String_Node_Str"" + formatIndividualSet(negError,baseURI));
        }
        rs.releaseKB();
        cm.freeAllComponents();
      }
      paraStats.put(currParaValue,paraCriterionStat);
    }
    System.out.println(""String_Node_Str"");
    int bestPara=startValue;
    double bestValue=Double.NEGATIVE_INFINITY;
    for (    Entry<Integer,Stat> entry : paraStats.entrySet()) {
      int para=entry.getKey();
      Stat stat=entry.getValue();
      System.out.println(""String_Node_Str"" + para + ""String_Node_Str""+ stat.prettyPrint(""String_Node_Str""));
      if (stat.getMean() > bestValue) {
        bestPara=para;
        bestValue=stat.getMean();
      }
    }
    System.out.println(""String_Node_Str"" + bestPara + ""String_Node_Str""+ df.format(bestValue)+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    start=new Start(confFile);
    LearningProblem lpOut=start.getLearningProblem();
    cm.applyConfigEntry(lpOut,""String_Node_Str"",Datastructures.individualListToStringSet(posLists.get(currOuterFold).getTrainList()));
    cm.applyConfigEntry(lpOut,""String_Node_Str"",Datastructures.individualListToStringSet(negLists.get(currOuterFold).getTrainList()));
    LearningAlgorithm laOut=start.getLearningAlgorithm();
    cm.applyConfigEntry(laOut,parameter,(double)bestPara);
    lpOut.init();
    laOut.init();
    laOut.start();
    Description concept=laOut.getCurrentlyBestDescription();
    TreeSet<Individual> posTest=new TreeSet<Individual>(posLists.get(currOuterFold).getTestList());
    TreeSet<Individual> negTest=new TreeSet<Individual>(negLists.get(currOuterFold).getTestList());
    ReasonerComponent rs=start.getReasonerComponent();
    Set<Individual> posCorrect=rs.hasType(concept,posTest);
    Set<Individual> posError=Helper.difference(posTest,posCorrect);
    Set<Individual> negError=rs.hasType(concept,negTest);
    Set<Individual> negCorrect=Helper.difference(negTest,negError);
    double accuracy=100 * ((double)(posCorrect.size() + negCorrect.size()) / (posTest.size() + negTest.size()));
    double precision=100 * (double)posCorrect.size() / (posCorrect.size() + negError.size());
    double recall=100 * (double)posCorrect.size() / (posCorrect.size() + posError.size());
    double fmeasure=2 * (precision * recall) / (precision + recall);
    System.out.println(""String_Node_Str"" + concept.toManchesterSyntaxString(baseURI,null));
    System.out.println(""String_Node_Str"" + df.format(accuracy) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + df.format(precision) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + df.format(recall) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + df.format(fmeasure) + ""String_Node_Str"");
    if (verbose) {
      System.out.println(""String_Node_Str"" + formatIndividualSet(posError,baseURI));
      System.out.println(""String_Node_Str"" + formatIndividualSet(negError,baseURI));
    }
    accOverall.addNumber(accuracy);
    fOverall.addNumber(fmeasure);
    recallOverall.addNumber(recall);
    precisionOverall.addNumber(precision);
    rs.releaseKB();
    cm.freeAllComponents();
  }
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + accOverall.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + fOverall.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + precisionOverall.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + recallOverall.prettyPrint(""String_Node_Str""));
}","public NestedCrossValidation(File confFile,int outerFolds,int innerFolds,String parameter,int startValue,int endValue,boolean verbose) throws FileNotFoundException, ComponentInitException, ParseException, org.dllearner.confparser.ParseException {
  DecimalFormat df=new DecimalFormat();
  ComponentManager cm=ComponentManager.getInstance();
  Start start=new Start(confFile);
  LearningProblem lp=start.getLearningProblem();
  if (!(lp instanceof PosNegLP)) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  LinkedList<Individual> posExamples=new LinkedList<Individual>(((PosNegLP)lp).getPositiveExamples());
  Collections.shuffle(posExamples,new Random(1));
  LinkedList<Individual> negExamples=new LinkedList<Individual>(((PosNegLP)lp).getNegativeExamples());
  Collections.shuffle(negExamples,new Random(2));
  ReasonerComponent rc=start.getReasonerComponent();
  String baseURI=rc.getBaseURI();
  List<TrainTestList> posLists=getFolds(posExamples,outerFolds);
  List<TrainTestList> negLists=getFolds(negExamples,outerFolds);
  Stat accOverall=new Stat();
  Stat fOverall=new Stat();
  Stat recallOverall=new Stat();
  Stat precisionOverall=new Stat();
  for (int currOuterFold=0; currOuterFold < outerFolds; currOuterFold++) {
    System.out.println(""String_Node_Str"" + currOuterFold);
    TrainTestList posList=posLists.get(currOuterFold);
    TrainTestList negList=negLists.get(currOuterFold);
    Map<Integer,Stat> paraStats=new HashMap<Integer,Stat>();
    for (int currParaValue=startValue; currParaValue <= endValue; currParaValue++) {
      System.out.println(""String_Node_Str"" + currParaValue + ""String_Node_Str"");
      List<Individual> trainPosList=posList.getTrainList();
      List<TrainTestList> innerPosLists=getFolds(trainPosList,innerFolds);
      List<Individual> trainNegList=negList.getTrainList();
      List<TrainTestList> innerNegLists=getFolds(trainNegList,innerFolds);
      Stat paraCriterionStat=new Stat();
      for (int currInnerFold=0; currInnerFold < innerFolds; currInnerFold++) {
        System.out.println(""String_Node_Str"" + currInnerFold + ""String_Node_Str"");
        Set<Individual> posEx=new TreeSet<Individual>(innerPosLists.get(currInnerFold).getTrainList());
        Set<Individual> negEx=new TreeSet<Individual>(innerNegLists.get(currInnerFold).getTrainList());
        start=new Start(confFile);
        LearningProblem lpIn=start.getLearningProblem();
        cm.applyConfigEntry(lpIn,""String_Node_Str"",Datastructures.individualSetToStringSet(posEx));
        cm.applyConfigEntry(lpIn,""String_Node_Str"",Datastructures.individualSetToStringSet(negEx));
        LearningAlgorithm laIn=start.getLearningAlgorithm();
        cm.applyConfigEntry(laIn,parameter,(double)currParaValue);
        lpIn.init();
        laIn.init();
        laIn.start();
        Description concept=laIn.getCurrentlyBestDescription();
        TreeSet<Individual> posTest=new TreeSet<Individual>(innerPosLists.get(currInnerFold).getTestList());
        TreeSet<Individual> negTest=new TreeSet<Individual>(innerNegLists.get(currInnerFold).getTestList());
        ReasonerComponent rs=start.getReasonerComponent();
        Set<Individual> posCorrect=rs.hasType(concept,posTest);
        Set<Individual> posError=Helper.difference(posTest,posCorrect);
        Set<Individual> negError=rs.hasType(concept,negTest);
        Set<Individual> negCorrect=Helper.difference(negTest,negError);
        double accuracy=100 * ((double)(posCorrect.size() + negCorrect.size()) / (posTest.size() + negTest.size()));
        double precision=100 * (double)posCorrect.size() / (posCorrect.size() + negError.size());
        double recall=100 * (double)posCorrect.size() / (posCorrect.size() + posError.size());
        double fmeasure=2 * (precision * recall) / (precision + recall);
        paraCriterionStat.addNumber(accuracy);
        System.out.println(""String_Node_Str"" + concept.toManchesterSyntaxString(baseURI,null));
        System.out.println(""String_Node_Str"" + df.format(accuracy) + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + df.format(precision) + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + df.format(recall) + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + df.format(fmeasure) + ""String_Node_Str"");
        if (verbose) {
          System.out.println(""String_Node_Str"" + formatIndividualSet(posError,baseURI));
          System.out.println(""String_Node_Str"" + formatIndividualSet(negError,baseURI));
        }
        rs.releaseKB();
        cm.freeAllComponents();
      }
      paraStats.put(currParaValue,paraCriterionStat);
    }
    System.out.println(""String_Node_Str"");
    int bestPara=startValue;
    double bestValue=Double.NEGATIVE_INFINITY;
    for (    Entry<Integer,Stat> entry : paraStats.entrySet()) {
      int para=entry.getKey();
      Stat stat=entry.getValue();
      System.out.println(""String_Node_Str"" + para + ""String_Node_Str""+ stat.prettyPrint(""String_Node_Str""));
      if (stat.getMean() > bestValue) {
        bestPara=para;
        bestValue=stat.getMean();
      }
    }
    System.out.println(""String_Node_Str"" + bestPara + ""String_Node_Str""+ df.format(bestValue)+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    start=new Start(confFile);
    LearningProblem lpOut=start.getLearningProblem();
    cm.applyConfigEntry(lpOut,""String_Node_Str"",Datastructures.individualListToStringSet(posLists.get(currOuterFold).getTrainList()));
    cm.applyConfigEntry(lpOut,""String_Node_Str"",Datastructures.individualListToStringSet(negLists.get(currOuterFold).getTrainList()));
    LearningAlgorithm laOut=start.getLearningAlgorithm();
    cm.applyConfigEntry(laOut,parameter,(double)bestPara);
    lpOut.init();
    laOut.init();
    laOut.start();
    Description concept=laOut.getCurrentlyBestDescription();
    TreeSet<Individual> posTest=new TreeSet<Individual>(posLists.get(currOuterFold).getTestList());
    TreeSet<Individual> negTest=new TreeSet<Individual>(negLists.get(currOuterFold).getTestList());
    ReasonerComponent rs=start.getReasonerComponent();
    Set<Individual> posCorrect=rs.hasType(concept,posTest);
    Set<Individual> posError=Helper.difference(posTest,posCorrect);
    Set<Individual> negError=rs.hasType(concept,negTest);
    Set<Individual> negCorrect=Helper.difference(negTest,negError);
    double accuracy=100 * ((double)(posCorrect.size() + negCorrect.size()) / (posTest.size() + negTest.size()));
    double precision=100 * (double)posCorrect.size() / (posCorrect.size() + negError.size());
    double recall=100 * (double)posCorrect.size() / (posCorrect.size() + posError.size());
    double fmeasure=2 * (precision * recall) / (precision + recall);
    System.out.println(""String_Node_Str"" + concept.toManchesterSyntaxString(baseURI,null));
    System.out.println(""String_Node_Str"" + df.format(accuracy) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + df.format(precision) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + df.format(recall) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + df.format(fmeasure) + ""String_Node_Str"");
    if (verbose) {
      System.out.println(""String_Node_Str"" + formatIndividualSet(posError,baseURI));
      System.out.println(""String_Node_Str"" + formatIndividualSet(negError,baseURI));
    }
    accOverall.addNumber(accuracy);
    fOverall.addNumber(fmeasure);
    recallOverall.addNumber(recall);
    precisionOverall.addNumber(precision);
    rs.releaseKB();
    cm.freeAllComponents();
  }
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + accOverall.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + fOverall.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + precisionOverall.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + recallOverall.prettyPrint(""String_Node_Str""));
}"
9735,"/** 
 * Entry method, which uses JOptSimple to parse parameters.
 * @param args Command line arguments (see class documentation).
 * @throws IOException
 * @throws ParseException 
 * @throws ComponentInitException 
 */
public static void main(String[] args) throws IOException, ComponentInitException, ParseException {
  OptionParser parser=new OptionParser();
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(File.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(Integer.class).describedAs(""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(Integer.class).describedAs(""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg();
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg();
  OptionSet options=null;
  try {
    options=parser.parse(args);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
    System.exit(0);
  }
  if (options.has(""String_Node_Str"")) {
    parser.printHelpOn(System.out);
  }
 else   if (options.has(""String_Node_Str"") && options.has(""String_Node_Str"") && options.has(""String_Node_Str"")&& options.has(""String_Node_Str"")&& options.has(""String_Node_Str"")) {
    File confFile=(File)options.valueOf(""String_Node_Str"");
    int outerFolds=(Integer)options.valueOf(""String_Node_Str"");
    int innerFolds=(Integer)options.valueOf(""String_Node_Str"");
    String parameter=(String)options.valueOf(""String_Node_Str"");
    String range=(String)options.valueOf(""String_Node_Str"");
    String[] rangeSplit=range.split(""String_Node_Str"");
    int rangeStart=new Integer(rangeSplit[0]);
    int rangeEnd=new Integer(rangeSplit[1]);
    boolean verbose=options.has(""String_Node_Str"");
    SimpleLayout layout=new SimpleLayout();
    ConsoleAppender consoleAppender=new ConsoleAppender(layout);
    Logger logger=Logger.getRootLogger();
    logger.removeAllAppenders();
    logger.addAppender(consoleAppender);
    logger.setLevel(Level.WARN);
    java.util.logging.Logger.getLogger(""String_Node_Str"").setLevel(java.util.logging.Level.WARNING);
    System.out.println(""String_Node_Str"");
    new NestedCrossValidation(confFile,outerFolds,innerFolds,parameter,rangeStart,rangeEnd,verbose);
  }
 else {
    parser.printHelpOn(System.out);
    System.out.println(""String_Node_Str"");
  }
}","/** 
 * Entry method, which uses JOptSimple to parse parameters.
 * @param args Command line arguments (see class documentation).
 * @throws IOException
 * @throws ParseException 
 * @throws ComponentInitException 
 * @throws org.dllearner.confparser.ParseException 
 */
public static void main(String[] args) throws IOException, ComponentInitException, ParseException, org.dllearner.confparser.ParseException {
  OptionParser parser=new OptionParser();
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(File.class);
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(Integer.class).describedAs(""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(Integer.class).describedAs(""String_Node_Str"");
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg();
  parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").withRequiredArg();
  OptionSet options=null;
  try {
    options=parser.parse(args);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
    System.exit(0);
  }
  if (options.has(""String_Node_Str"")) {
    parser.printHelpOn(System.out);
  }
 else   if (options.has(""String_Node_Str"") && options.has(""String_Node_Str"") && options.has(""String_Node_Str"")&& options.has(""String_Node_Str"")&& options.has(""String_Node_Str"")) {
    File confFile=(File)options.valueOf(""String_Node_Str"");
    int outerFolds=(Integer)options.valueOf(""String_Node_Str"");
    int innerFolds=(Integer)options.valueOf(""String_Node_Str"");
    String parameter=(String)options.valueOf(""String_Node_Str"");
    String range=(String)options.valueOf(""String_Node_Str"");
    String[] rangeSplit=range.split(""String_Node_Str"");
    int rangeStart=new Integer(rangeSplit[0]);
    int rangeEnd=new Integer(rangeSplit[1]);
    boolean verbose=options.has(""String_Node_Str"");
    SimpleLayout layout=new SimpleLayout();
    ConsoleAppender consoleAppender=new ConsoleAppender(layout);
    Logger logger=Logger.getRootLogger();
    logger.removeAllAppenders();
    logger.addAppender(consoleAppender);
    logger.setLevel(Level.WARN);
    java.util.logging.Logger.getLogger(""String_Node_Str"").setLevel(java.util.logging.Level.WARNING);
    System.out.println(""String_Node_Str"");
    new NestedCrossValidation(confFile,outerFolds,innerFolds,parameter,rangeStart,rangeEnd,verbose);
  }
 else {
    parser.printHelpOn(System.out);
    System.out.println(""String_Node_Str"");
  }
}"
9736,"public static void main(String args[]) throws ComponentInitException, FileNotFoundException, ParseException {
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  logger.removeAllAppenders();
  logger.addAppender(consoleAppender);
  logger.setLevel(Level.DEBUG);
  String filenameTrain=args[0];
  String filenameTest=args[1];
  Start start=new Start(new File(filenameTrain));
  start.start(false);
  Description solution=start.getLearningAlgorithm().getCurrentlyBestDescription();
  logger.setLevel(Level.WARN);
  Start startTest=new Start(new File(filenameTest));
  ReasonerComponent rs=startTest.getReasonerComponent();
  LearningProblem lp=startTest.getLearningProblem();
  Set<Individual> result=rs.getIndividuals(solution);
  System.out.println(""String_Node_Str"" + result);
  ScorePosNeg score=(ScorePosNeg)lp.computeScore(solution);
  System.out.println(score);
}","public static void main(String args[]) throws ComponentInitException, FileNotFoundException, ParseException, org.dllearner.confparser.ParseException {
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  logger.removeAllAppenders();
  logger.addAppender(consoleAppender);
  logger.setLevel(Level.DEBUG);
  String filenameTrain=args[0];
  String filenameTest=args[1];
  Start start=new Start(new File(filenameTrain));
  start.start(false);
  Description solution=start.getLearningAlgorithm().getCurrentlyBestDescription();
  logger.setLevel(Level.WARN);
  Start startTest=new Start(new File(filenameTest));
  ReasonerComponent rs=startTest.getReasonerComponent();
  LearningProblem lp=startTest.getLearningProblem();
  Set<Individual> result=rs.getIndividuals(solution);
  System.out.println(""String_Node_Str"" + result);
  ScorePosNeg score=(ScorePosNeg)lp.computeScore(solution);
  System.out.println(score);
}"
9737,"/** 
 * Writes documentation for all components available in this <code>ComponentManager</code> instance. It goes through all components (sorted by their type) and all the configuration options of the components. Explanations, default values, allowed values for the options are collected and the obtained string is written in a file. 
 * @param file The documentation file.
 */
public void writeConfigDocumentation(File file){
  String doc=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  for (  Class<? extends Component> component : knowledgeSources) {
    if (component != SparqlKnowledgeSource.class) {
      continue;
    }
    doc+=getComponentConfigString(component,KnowledgeSource.class);
  }
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  for (  Class<? extends Component> component : reasonerComponents) {
    doc+=getComponentConfigString(component,ReasonerComponent.class);
  }
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  for (  Class<? extends Component> component : learningProblems) {
    doc+=getComponentConfigString(component,LearningProblem.class);
  }
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  for (  Class<? extends Component> component : learningAlgorithms) {
    doc+=getComponentConfigString(component,LearningAlgorithm.class);
  }
  Files.createFile(file,doc);
}","/** 
 * Writes documentation for all components available in this <code>ComponentManager</code> instance. It goes through all components (sorted by their type) and all the configuration options of the components. Explanations, default values, allowed values for the options are collected and the obtained string is written in a file. 
 * @param file The documentation file.
 */
public void writeConfigDocumentation(File file){
  String doc=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  for (  Class<? extends Component> component : cm.getKnowledgeSources()) {
    if (component != SparqlKnowledgeSource.class) {
      continue;
    }
    doc+=getComponentConfigString(component,KnowledgeSource.class);
  }
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  for (  Class<? extends Component> component : cm.getReasonerComponents()) {
    doc+=getComponentConfigString(component,ReasonerComponent.class);
  }
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  for (  Class<? extends Component> component : cm.getLearningProblems()) {
    doc+=getComponentConfigString(component,LearningProblem.class);
  }
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  doc+=""String_Node_Str"";
  for (  Class<? extends Component> component : cm.getLearningAlgorithms()) {
    doc+=getComponentConfigString(component,LearningAlgorithm.class);
  }
  Files.createFile(file,doc);
}"
9738,"private String getComponentConfigString(Class<? extends Component> component,Class<? extends Component> componentType){
  String componentDescription=""String_Node_Str"" + invokeStaticMethod(component,""String_Node_Str"") + ""String_Node_Str""+ component.getName()+ ""String_Node_Str"";
  String str=componentDescription + ""String_Node_Str"";
  String cli=confMapper.getComponentTypeString(componentType);
  String usage=confMapper.getComponentString(component);
  for (int i=0; i < componentDescription.length(); i++) {
    str+=""String_Node_Str"";
  }
  str+=""String_Node_Str"";
  if (componentType.equals(KnowledgeSource.class)) {
    str+=""String_Node_Str"" + cli + ""String_Node_Str""+ usage.toUpperCase()+ ""String_Node_Str"";
  }
 else {
    str+=""String_Node_Str"" + cli + ""String_Node_Str""+ usage+ ""String_Node_Str"";
  }
  for (  ConfigOption<?> option : componentOptions.get(component)) {
    String val=(option.getDefaultValue() == null) ? ""String_Node_Str"" : option.getDefaultValue() + ""String_Node_Str"";
    str+=option.toString() + ""String_Node_Str"" + usage+ ""String_Node_Str""+ option.getName()+ ""String_Node_Str""+ val+ ""String_Node_Str"";
  }
  return str + ""String_Node_Str"";
}","private String getComponentConfigString(Class<? extends Component> component,Class<? extends Component> componentType){
  String componentDescription=""String_Node_Str"" + cm.getComponentName(component);
  String str=componentDescription + ""String_Node_Str"";
  String cli=confMapper.getComponentTypeString(componentType);
  String usage=confMapper.getComponentString(component);
  for (int i=0; i < componentDescription.length(); i++) {
    str+=""String_Node_Str"";
  }
  str+=""String_Node_Str"";
  if (componentType.equals(KnowledgeSource.class)) {
    str+=""String_Node_Str"" + cli + ""String_Node_Str""+ usage.toUpperCase()+ ""String_Node_Str"";
  }
 else {
    str+=""String_Node_Str"" + cli + ""String_Node_Str""+ usage+ ""String_Node_Str"";
  }
  for (  ConfigOption<?> option : ComponentManager.getConfigOptions(component)) {
    String val=(option.getDefaultValue() == null) ? ""String_Node_Str"" : option.getDefaultValue() + ""String_Node_Str"";
    str+=option.toString() + ""String_Node_Str"" + usage+ ""String_Node_Str""+ option.getName()+ ""String_Node_Str""+ val+ ""String_Node_Str"";
  }
  return str + ""String_Node_Str"";
}"
9739,"/** 
 * Initialise all components based on conf file.
 * @param file Conf file to read.
 * @throws ComponentInitException
 * @throws ParseException 
 * @throws FileNotFoundException 
 * @throws IOException 
 */
public Start(File file) throws ComponentInitException, ParseException, FileNotFoundException {
  String baseDir=file.getAbsoluteFile().getParent();
  String message=""String_Node_Str"";
  long cmStartTime=System.nanoTime();
  ComponentManager cm=ComponentManager.getInstance();
  long cmTime=System.nanoTime() - cmStartTime;
  message+=""String_Node_Str"" + Helper.prettyPrintNanoSeconds(cmTime) + ""String_Node_Str"";
  logger.info(message);
  ConfParser parser=ConfParser.parseFile(file);
  Monitor ksMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  sources=new HashSet<KnowledgeSource>();
  Map<URL,Class<? extends KnowledgeSource>> importedFiles=getImportedFiles(parser,baseDir);
  for (  Map.Entry<URL,Class<? extends KnowledgeSource>> entry : importedFiles.entrySet()) {
    KnowledgeSource ks=cm.knowledgeSource(entry.getValue());
    cm.applyConfigEntry(ks,""String_Node_Str"",entry.getKey());
    sources.add(ks);
    configureComponent(cm,ks,parser);
    initComponent(cm,ks);
  }
  ksMonitor.stop();
  Monitor rsMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  ConfFileOption reasonerOption=parser.getConfOptionsByName(""String_Node_Str"");
  Class<? extends ReasonerComponent> rcClass;
  if (reasonerOption != null) {
    rcClass=confMapper.getReasonerComponentClass(reasonerOption.getStringValue());
    if (rcClass == null) {
      handleError(""String_Node_Str"" + reasonerOption.getStringValue() + ""String_Node_Str""+ reasonerOption+ ""String_Node_Str""+ confMapper.getReasoners()+ ""String_Node_Str"");
    }
  }
 else {
    rcClass=FastInstanceChecker.class;
  }
  rc=cm.reasoner(rcClass,sources);
  configureComponent(cm,rc,parser);
  initComponent(cm,rc);
  rsMonitor.stop();
  Monitor lpMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  ConfFileOption problemOption=parser.getConfOptionsByName(""String_Node_Str"");
  Class<? extends LearningProblem> lpClass;
  if (problemOption != null) {
    lpClass=confMapper.getLearningProblemClass(problemOption.getStringValue());
    if (lpClass == null) {
      handleError(""String_Node_Str"" + problemOption.getStringValue() + ""String_Node_Str""+ problemOption+ ""String_Node_Str""+ confMapper.getLearningProblems()+ ""String_Node_Str"");
    }
  }
 else {
    lpClass=PosNegLPStandard.class;
  }
  lp=cm.learningProblem(lpClass,rc);
  if (lpClass == PosNegLPStandard.class || lpClass == PosOnlyLP.class) {
    SortedSet<String> posExamples=parser.getPositiveExamples();
    cm.applyConfigEntry(lp,""String_Node_Str"",posExamples);
  }
  if (lpClass == PosNegLPStandard.class) {
    SortedSet<String> negExamples=parser.getNegativeExamples();
    cm.applyConfigEntry(lp,""String_Node_Str"",negExamples);
  }
  configureComponent(cm,lp,parser);
  initComponent(cm,lp);
  lpMonitor.stop();
  Monitor laMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  ConfFileOption algorithmOption=parser.getConfOptionsByName(""String_Node_Str"");
  Class<? extends LearningAlgorithm> laClass;
  if (algorithmOption != null) {
    laClass=confMapper.getLearningAlgorithmClass(algorithmOption.getStringValue());
    if (laClass == null) {
      handleError(""String_Node_Str"" + algorithmOption.getStringValue() + ""String_Node_Str""+ algorithmOption+ ""String_Node_Str""+ confMapper.getLearningAlgorithms()+ ""String_Node_Str"");
    }
  }
 else {
    laClass=ROLComponent2.class;
  }
  try {
    la=cm.learningAlgorithm(laClass,lp,rc);
  }
 catch (  LearningProblemUnsupportedException e) {
    e.printStackTrace();
  }
  configureComponent(cm,la,parser);
  initComponent(cm,la);
  laMonitor.stop();
  performExports(parser,baseDir,sources,rc);
  processCLIOptions(cm,parser,rc,lp);
  if (logger.isInfoEnabled()) {
    System.out.println(""String_Node_Str"");
  }
}","/** 
 * Initialise all components based on conf file.
 * @param file Conf file to read.
 * @throws ComponentInitException
 * @throws ParseException 
 * @throws FileNotFoundException 
 * @throws  
	 * @throws IOException 
 */
public Start(File file) throws ComponentInitException, ParseException, FileNotFoundException {
  String baseDir=file.getAbsoluteFile().getParent();
  String message=""String_Node_Str"";
  long cmStartTime=System.nanoTime();
  ComponentManager cm=ComponentManager.getInstance();
  long cmTime=System.nanoTime() - cmStartTime;
  message+=""String_Node_Str"" + Helper.prettyPrintNanoSeconds(cmTime) + ""String_Node_Str"";
  logger.info(message);
  ConfParser parser=ConfParser.parseFile(file);
  Monitor ksMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  sources=new HashSet<KnowledgeSource>();
  Map<URL,Class<? extends KnowledgeSource>> importedFiles=getImportedFiles(parser,baseDir);
  for (  Map.Entry<URL,Class<? extends KnowledgeSource>> entry : importedFiles.entrySet()) {
    KnowledgeSource ks=cm.knowledgeSource(entry.getValue());
    cm.applyConfigEntry(ks,""String_Node_Str"",entry.getKey());
    sources.add(ks);
    configureComponent(cm,ks,parser);
    initComponent(cm,ks);
  }
  ksMonitor.stop();
  Monitor rsMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  ConfFileOption reasonerOption=parser.getConfOptionsByName(""String_Node_Str"");
  Class<? extends ReasonerComponent> rcClass;
  if (reasonerOption != null) {
    rcClass=confMapper.getReasonerComponentClass(reasonerOption.getStringValue());
    if (rcClass == null) {
      handleError(""String_Node_Str"" + reasonerOption.getStringValue() + ""String_Node_Str""+ reasonerOption+ ""String_Node_Str""+ confMapper.getReasoners()+ ""String_Node_Str"");
    }
  }
 else {
    rcClass=FastInstanceChecker.class;
  }
  rc=cm.reasoner(rcClass,sources);
  configureComponent(cm,rc,parser);
  initComponent(cm,rc);
  rsMonitor.stop();
  Monitor lpMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  ConfFileOption problemOption=parser.getConfOptionsByName(""String_Node_Str"");
  Class<? extends LearningProblem> lpClass;
  if (problemOption != null) {
    lpClass=confMapper.getLearningProblemClass(problemOption.getStringValue());
    if (lpClass == null) {
      handleError(""String_Node_Str"" + problemOption.getStringValue() + ""String_Node_Str""+ problemOption+ ""String_Node_Str""+ confMapper.getLearningProblems()+ ""String_Node_Str"");
    }
  }
 else {
    lpClass=PosNegLPStandard.class;
  }
  lp=cm.learningProblem(lpClass,rc);
  if (lpClass == PosNegLPStandard.class || lpClass == PosOnlyLP.class) {
    SortedSet<String> posExamples=parser.getPositiveExamples();
    cm.applyConfigEntry(lp,""String_Node_Str"",posExamples);
  }
  if (lpClass == PosNegLPStandard.class) {
    SortedSet<String> negExamples=parser.getNegativeExamples();
    cm.applyConfigEntry(lp,""String_Node_Str"",negExamples);
  }
  configureComponent(cm,lp,parser);
  initComponent(cm,lp);
  lpMonitor.stop();
  Monitor laMonitor=JamonMonitorLogger.getTimeMonitor(Start.class,""String_Node_Str"").start();
  ConfFileOption algorithmOption=parser.getConfOptionsByName(""String_Node_Str"");
  Class<? extends LearningAlgorithm> laClass;
  if (algorithmOption != null) {
    laClass=confMapper.getLearningAlgorithmClass(algorithmOption.getStringValue());
    if (laClass == null) {
      handleError(""String_Node_Str"" + algorithmOption.getStringValue() + ""String_Node_Str""+ algorithmOption+ ""String_Node_Str""+ confMapper.getLearningAlgorithms()+ ""String_Node_Str"");
    }
  }
 else {
    laClass=ROLComponent2.class;
  }
  try {
    la=cm.learningAlgorithm(laClass,lp,rc);
  }
 catch (  LearningProblemUnsupportedException e) {
    e.printStackTrace();
  }
  configureComponent(cm,la,parser);
  initComponent(cm,la);
  laMonitor.stop();
  performExports(parser,baseDir,sources,rc);
  processCLIOptions(cm,parser,rc,lp);
  if (logger.isInfoEnabled()) {
    System.out.println(""String_Node_Str"");
  }
}"
9740,"private static void processQueryMode(LearningProblem lp,ReasonerComponent rs){
  logger.info(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  String queryStr=""String_Node_Str"";
  do {
    logger.info(""String_Node_Str"");
    BufferedReader input=new BufferedReader(new InputStreamReader(System.in));
    try {
      queryStr=input.readLine();
      logger.debug(queryStr);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    if (!(queryStr.equalsIgnoreCase(""String_Node_Str"") || queryStr.equalsIgnoreCase(""String_Node_Str""))) {
      Description concept=null;
      boolean parsedCorrectly=true;
      try {
        concept=KBParser.parseConcept(queryStr);
      }
 catch (      ParseException e1) {
        e1.printStackTrace();
        System.err.println(""String_Node_Str"");
        parsedCorrectly=false;
      }
catch (      TokenMgrError e) {
        e.printStackTrace();
        System.err.println(""String_Node_Str"");
        parsedCorrectly=false;
      }
      if (parsedCorrectly) {
        SortedSet<NamedClass> occurringConcepts=new TreeSet<NamedClass>(new ConceptComparator());
        occurringConcepts.addAll(Helper.getAtomicConcepts(concept));
        SortedSet<ObjectProperty> occurringRoles=new TreeSet<ObjectProperty>(new RoleComparator());
        occurringRoles.addAll(Helper.getAtomicRoles(concept));
        for (        NamedClass ac : rs.getNamedClasses())         occurringConcepts.remove(ac);
        for (        ObjectProperty ar : rs.getObjectProperties())         occurringRoles.remove(ar);
        boolean nonExistingConstructs=false;
        if (occurringConcepts.size() != 0 || occurringRoles.size() != 0) {
          logger.debug(""String_Node_Str"");
          if (occurringConcepts.size() > 0)           logger.debug(""String_Node_Str"" + occurringConcepts);
          if (occurringRoles.size() > 0)           logger.debug(""String_Node_Str"" + occurringRoles);
          nonExistingConstructs=true;
        }
        if (!nonExistingConstructs) {
          if (!queryStr.startsWith(""String_Node_Str"") && (queryStr.contains(""String_Node_Str"") || queryStr.contains(""String_Node_Str""))) {
            logger.info(""String_Node_Str"");
          }
          logger.info(""String_Node_Str"" + concept.toKBSyntaxString() + ""String_Node_Str"");
          Set<Individual> result=null;
          result=rs.getIndividuals(concept);
          logger.info(""String_Node_Str"" + result.size() + ""String_Node_Str""+ result);
          ScorePosNeg score=(ScorePosNeg)lp.computeScore(concept);
          logger.info(score);
        }
      }
    }
  }
 while (!(queryStr.equalsIgnoreCase(""String_Node_Str"") || queryStr.equalsIgnoreCase(""String_Node_Str"")));
}","private static void processQueryMode(LearningProblem lp,ReasonerComponent rs){
  logger.info(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  String queryStr=""String_Node_Str"";
  do {
    logger.info(""String_Node_Str"");
    BufferedReader input=new BufferedReader(new InputStreamReader(System.in));
    try {
      queryStr=input.readLine();
      logger.debug(queryStr);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    if (!(queryStr.equalsIgnoreCase(""String_Node_Str"") || queryStr.equalsIgnoreCase(""String_Node_Str""))) {
      Description concept=null;
      boolean parsedCorrectly=true;
      try {
        concept=KBParser.parseConcept(queryStr);
      }
 catch (      TokenMgrError e) {
        e.printStackTrace();
        System.err.println(""String_Node_Str"");
        parsedCorrectly=false;
      }
catch (      org.dllearner.parser.ParseException e) {
        e.printStackTrace();
        System.err.println(""String_Node_Str"");
        parsedCorrectly=false;
      }
      if (parsedCorrectly) {
        SortedSet<NamedClass> occurringConcepts=new TreeSet<NamedClass>(new ConceptComparator());
        occurringConcepts.addAll(Helper.getAtomicConcepts(concept));
        SortedSet<ObjectProperty> occurringRoles=new TreeSet<ObjectProperty>(new RoleComparator());
        occurringRoles.addAll(Helper.getAtomicRoles(concept));
        for (        NamedClass ac : rs.getNamedClasses())         occurringConcepts.remove(ac);
        for (        ObjectProperty ar : rs.getObjectProperties())         occurringRoles.remove(ar);
        boolean nonExistingConstructs=false;
        if (occurringConcepts.size() != 0 || occurringRoles.size() != 0) {
          logger.debug(""String_Node_Str"");
          if (occurringConcepts.size() > 0)           logger.debug(""String_Node_Str"" + occurringConcepts);
          if (occurringRoles.size() > 0)           logger.debug(""String_Node_Str"" + occurringRoles);
          nonExistingConstructs=true;
        }
        if (!nonExistingConstructs) {
          if (!queryStr.startsWith(""String_Node_Str"") && (queryStr.contains(""String_Node_Str"") || queryStr.contains(""String_Node_Str""))) {
            logger.info(""String_Node_Str"");
          }
          logger.info(""String_Node_Str"" + concept.toKBSyntaxString() + ""String_Node_Str"");
          Set<Individual> result=null;
          result=rs.getIndividuals(concept);
          logger.info(""String_Node_Str"" + result.size() + ""String_Node_Str""+ result);
          ScorePosNeg score=(ScorePosNeg)lp.computeScore(concept);
          logger.info(score);
        }
      }
    }
  }
 while (!(queryStr.equalsIgnoreCase(""String_Node_Str"") || queryStr.equalsIgnoreCase(""String_Node_Str"")));
}"
9741,"private void compute(QueryTree<N> posExampleTree,Set<QueryTree<N>> negExampleTrees,Set<QueryTree<N>> nbrs){
  QueryTree<N> nbr=new QueryTreeImpl<N>(posExampleTree);
  for (  QueryTree<N> n : nbrs) {
    for (    QueryTree<N> leaf1 : nbr.getLeafs()) {
      for (      QueryTree<N> leaf2 : n.getLeafs()) {
        if (leaf1.getUserObject().equals(leaf2.getUserObject())) {
          leaf1.getParent().removeChild((QueryTreeImpl<N>)leaf1);
        }
      }
    }
  }
  if (!subsumesTrees(nbr,negExampleTrees)) {
    Set<QueryTree<N>> tested=new HashSet<QueryTree<N>>();
    Object edge;
    QueryTree<N> parent;
    while (!(tested.size() == nbr.getLeafs().size())) {
      for (      QueryTree<N> leaf : nbr.getLeafs()) {
        parent=leaf.getParent();
        edge=parent.getEdge(leaf);
        parent.removeChild((QueryTreeImpl<N>)leaf);
        boolean isSubsumedBy=false;
        for (        QueryTree<N> negTree : negExampleTrees) {
          isSubsumedBy=negTree.isSubsumedBy(nbr);
          if (isSubsumedBy) {
            break;
          }
        }
        if (isSubsumedBy) {
          tested.add(leaf);
          parent.addChild((QueryTreeImpl<N>)leaf,edge);
        }
      }
    }
    nbrs.add(nbr);
    compute(posExampleTree,negExampleTrees,nbrs);
  }
}","private void compute(QueryTree<N> posExampleTree,Set<QueryTree<N>> negExampleTrees,Set<QueryTree<N>> nbrs){
  QueryTree<N> nbr=new QueryTreeImpl<N>(posExampleTree);
  if (subsumesTrees(posExampleTree,negExampleTrees)) {
    return;
  }
  for (  QueryTree<N> n : nbrs) {
    removeTree(nbr,n);
  }
  if (!subsumesTrees(nbr,negExampleTrees)) {
    Set<QueryTree<N>> tested=new HashSet<QueryTree<N>>();
    Object edge;
    QueryTree<N> parent;
    while (!(tested.size() == nbr.getLeafs().size())) {
      for (      QueryTree<N> leaf : nbr.getLeafs()) {
        parent=leaf.getParent();
        edge=parent.getEdge(leaf);
        parent.removeChild((QueryTreeImpl<N>)leaf);
        boolean isSubsumedBy=false;
        for (        QueryTree<N> negTree : negExampleTrees) {
          isSubsumedBy=negTree.isSubsumedBy(nbr);
          if (isSubsumedBy) {
            break;
          }
        }
        if (isSubsumedBy) {
          tested.add(leaf);
          parent.addChild((QueryTreeImpl<N>)leaf,edge);
        }
      }
    }
    nbrs.add(nbr);
    compute(posExampleTree,negExampleTrees,nbrs);
  }
}"
9742,"@Override public QueryTree<N> computeNBR(QueryTree<N> posExampleTree,Set<QueryTree<N>> negExampleTrees){
  QueryTree<N> nbr=new QueryTreeImpl<N>(posExampleTree);
  Set<QueryTree<N>> tested=new HashSet<QueryTree<N>>();
  Object edge;
  QueryTree<N> parent;
  while (!(tested.size() == nbr.getLeafs().size())) {
    for (    QueryTree<N> leaf : nbr.getLeafs()) {
      parent=leaf.getParent();
      edge=parent.getEdge(leaf);
      parent.removeChild((QueryTreeImpl<N>)leaf);
      boolean isSubsumedBy=false;
      for (      QueryTree<N> negTree : negExampleTrees) {
        isSubsumedBy=negTree.isSubsumedBy(nbr);
        if (isSubsumedBy) {
          break;
        }
      }
      if (isSubsumedBy) {
        tested.add(leaf);
        parent.addChild((QueryTreeImpl<N>)leaf,edge);
      }
    }
  }
  System.out.println(nbr.getLeafs());
  return nbr;
}","@Override public QueryTree<N> computeNBR(QueryTree<N> posExampleTree,Set<QueryTree<N>> negExampleTrees){
  QueryTree<N> nbr=new QueryTreeImpl<N>(posExampleTree);
  if (subsumesTrees(posExampleTree,negExampleTrees)) {
    return nbr;
  }
  Set<QueryTree<N>> tested=new HashSet<QueryTree<N>>();
  Object edge;
  QueryTree<N> parent;
  while (!(tested.size() == nbr.getLeafs().size())) {
    for (    QueryTree<N> leaf : nbr.getLeafs()) {
      parent=leaf.getParent();
      edge=parent.getEdge(leaf);
      parent.removeChild((QueryTreeImpl<N>)leaf);
      boolean isSubsumedBy=false;
      for (      QueryTree<N> negTree : negExampleTrees) {
        isSubsumedBy=negTree.isSubsumedBy(nbr);
        if (isSubsumedBy) {
          break;
        }
      }
      if (isSubsumedBy) {
        tested.add(leaf);
        parent.addChild((QueryTreeImpl<N>)leaf,edge);
      }
    }
  }
  return nbr;
}"
9743,"@Test public void testLGGWithTrees(){
  QueryTreeFactory<String> factory=new QueryTreeFactoryImpl();
  Set<QueryTree<String>> posExampleTrees=DBpediaExample.getPosExampleTrees();
  int cnt=1;
  for (  QueryTree<String> tree : posExampleTrees) {
    System.out.println(""String_Node_Str"" + cnt);
    tree.dump(new PrintWriter(System.out));
    System.out.println(""String_Node_Str"");
    cnt++;
  }
  LGGGenerator<String> lggGenerator=new LGGGeneratorImpl<String>();
  QueryTree<String> lgg=lggGenerator.getLGG(posExampleTrees);
  System.out.println(""String_Node_Str"");
  lgg.dump(new PrintWriter(System.out));
  QueryTreeImpl<String> tree=factory.getQueryTree(""String_Node_Str"");
  QueryTreeImpl<String> subTree1=new QueryTreeImpl<String>(""String_Node_Str"");
  subTree1.addChild(new QueryTreeImpl<String>(""String_Node_Str""),""String_Node_Str"");
  subTree1.addChild(new QueryTreeImpl<String>(""String_Node_Str""),""String_Node_Str"");
  subTree1.addChild(new QueryTreeImpl<String>(""String_Node_Str""),""String_Node_Str"");
  tree.addChild(subTree1,""String_Node_Str"");
  tree.addChild(new QueryTreeImpl<String>(""String_Node_Str""),RDFS.label.toString());
  QueryTreeImpl<String> subTree2=new QueryTreeImpl<String>(""String_Node_Str"");
  subTree2.addChild(new QueryTreeImpl<String>(OWL.Thing.toString()),RDFS.subClassOf.toString());
  tree.addChild(subTree2,RDF.type.toString());
  QueryTreeImpl<String> subTree3=new QueryTreeImpl<String>(""String_Node_Str"");
  QueryTreeImpl<String> subSubTree=new QueryTreeImpl<String>(""String_Node_Str"");
  subSubTree.addChild(new QueryTreeImpl<String>(OWL.Thing.toString()),RDFS.subClassOf.toString());
  subTree3.addChild(subSubTree,RDFS.subClassOf.toString());
  tree.addChild(subTree3,RDF.type.toString());
  Assert.assertTrue(lgg.isSameTreeAs(tree));
}","@Test public void testLGGWithTrees(){
  QueryTreeFactory<String> factory=new QueryTreeFactoryImpl();
  Set<QueryTree<String>> posExampleTrees=DBpediaExample.getPosExampleTrees();
  int cnt=1;
  for (  QueryTree<String> tree : posExampleTrees) {
    System.out.println(""String_Node_Str"" + cnt);
    tree.dump();
    System.out.println(""String_Node_Str"");
    cnt++;
  }
  LGGGenerator<String> lggGenerator=new LGGGeneratorImpl<String>();
  QueryTree<String> lgg=lggGenerator.getLGG(posExampleTrees);
  System.out.println(""String_Node_Str"");
  lgg.dump();
  QueryTreeImpl<String> tree=factory.getQueryTree(""String_Node_Str"");
  QueryTreeImpl<String> subTree1=new QueryTreeImpl<String>(""String_Node_Str"");
  subTree1.addChild(new QueryTreeImpl<String>(""String_Node_Str""),""String_Node_Str"");
  subTree1.addChild(new QueryTreeImpl<String>(""String_Node_Str""),""String_Node_Str"");
  subTree1.addChild(new QueryTreeImpl<String>(""String_Node_Str""),""String_Node_Str"");
  tree.addChild(subTree1,""String_Node_Str"");
  tree.addChild(new QueryTreeImpl<String>(""String_Node_Str""),RDFS.label.toString());
  QueryTreeImpl<String> subTree2=new QueryTreeImpl<String>(""String_Node_Str"");
  subTree2.addChild(new QueryTreeImpl<String>(OWL.Thing.toString()),RDFS.subClassOf.toString());
  tree.addChild(subTree2,RDF.type.toString());
  QueryTreeImpl<String> subTree3=new QueryTreeImpl<String>(""String_Node_Str"");
  QueryTreeImpl<String> subSubTree=new QueryTreeImpl<String>(""String_Node_Str"");
  subSubTree.addChild(new QueryTreeImpl<String>(OWL.Thing.toString()),RDFS.subClassOf.toString());
  subTree3.addChild(subSubTree,RDFS.subClassOf.toString());
  tree.addChild(subTree3,RDF.type.toString());
  Assert.assertTrue(lgg.isSameTreeAs(tree));
}"
9744,"@Test public void computeAllNBRsBruteForce(){
  Set<QueryTree<String>> posExampleTrees=DBpediaExample.getPosExampleTrees();
  Set<QueryTree<String>> negExampleTrees=DBpediaExample.getNegExampleTrees();
  LGGGenerator<String> lggGenerator=new LGGGeneratorImpl<String>();
  NBRGenerator<String> nbrGenerator=new NBRGeneratorImpl<String>(new BruteForceNBRStrategy<String>());
  int cnt=1;
  for (  QueryTree<String> tree : posExampleTrees) {
    System.out.println(""String_Node_Str"" + cnt);
    tree.dump(new PrintWriter(System.out));
    System.out.println(""String_Node_Str"");
    cnt++;
  }
  QueryTree<String> lgg=lggGenerator.getLGG(posExampleTrees);
  System.out.println(""String_Node_Str"");
  lgg.dump(new PrintWriter(System.out));
  System.out.println(""String_Node_Str"");
  cnt=1;
  for (  QueryTree<String> tree : negExampleTrees) {
    System.out.println(""String_Node_Str"" + cnt);
    tree.dump(new PrintWriter(System.out));
    System.out.println(""String_Node_Str"");
    cnt++;
  }
  Set<QueryTree<String>> nbrs=nbrGenerator.getNBRs(lgg,negExampleTrees);
  cnt=1;
  for (  QueryTree<String> tree : nbrs) {
    System.out.println(""String_Node_Str"" + cnt);
    tree.dump(new PrintWriter(System.out));
    System.out.println(""String_Node_Str"");
    cnt++;
  }
}","@Test public void computeAllNBRsBruteForce(){
  Set<QueryTree<String>> posExampleTrees=DBpediaExample.getPosExampleTrees();
  Set<QueryTree<String>> negExampleTrees=DBpediaExample.getNegExampleTrees();
  LGGGenerator<String> lggGenerator=new LGGGeneratorImpl<String>();
  NBRGenerator<String> nbrGenerator=new NBRGeneratorImpl<String>(new BruteForceNBRStrategy<String>());
  int cnt=1;
  for (  QueryTree<String> tree : posExampleTrees) {
    System.out.println(""String_Node_Str"" + cnt);
    tree.dump();
    System.out.println(""String_Node_Str"");
    cnt++;
  }
  QueryTree<String> lgg=lggGenerator.getLGG(posExampleTrees);
  System.out.println(""String_Node_Str"");
  lgg.dump();
  System.out.println(""String_Node_Str"");
  cnt=1;
  for (  QueryTree<String> tree : negExampleTrees) {
    System.out.println(""String_Node_Str"" + cnt);
    tree.dump();
    System.out.println(""String_Node_Str"");
    cnt++;
  }
  Set<QueryTree<String>> nbrs=nbrGenerator.getNBRs(lgg,negExampleTrees);
  cnt=1;
  for (  QueryTree<String> tree : nbrs) {
    System.out.println(""String_Node_Str"" + cnt);
    tree.dump();
    System.out.println(""String_Node_Str"");
    cnt++;
  }
}"
9745,"@Test public void computeSingleNBRBruteForce(){
  Set<QueryTree<String>> posExampleTrees=DBpediaExample.getPosExampleTrees();
  Set<QueryTree<String>> negExampleTrees=DBpediaExample.getNegExampleTrees();
  LGGGenerator<String> lggGenerator=new LGGGeneratorImpl<String>();
  NBRGenerator<String> nbrGenerator=new NBRGeneratorImpl<String>(new BruteForceNBRStrategy<String>());
  int cnt=1;
  for (  QueryTree<String> tree : posExampleTrees) {
    System.out.println(""String_Node_Str"" + cnt);
    tree.dump(new PrintWriter(System.out));
    System.out.println(""String_Node_Str"");
    cnt++;
  }
  QueryTree<String> lgg=lggGenerator.getLGG(posExampleTrees);
  System.out.println(""String_Node_Str"");
  lgg.dump(new PrintWriter(System.out));
  System.out.println(""String_Node_Str"");
  cnt=1;
  for (  QueryTree<String> tree : negExampleTrees) {
    System.out.println(""String_Node_Str"" + cnt);
    tree.dump(new PrintWriter(System.out));
    System.out.println(""String_Node_Str"");
    cnt++;
  }
  System.out.println(""String_Node_Str"");
  QueryTree<String> nbr=nbrGenerator.getNBR(lgg,negExampleTrees);
  nbr.dump(new PrintWriter(System.out));
}","@Test public void computeSingleNBRBruteForce(){
  Set<QueryTree<String>> posExampleTrees=DBpediaExample.getPosExampleTrees();
  Set<QueryTree<String>> negExampleTrees=DBpediaExample.getNegExampleTrees();
  LGGGenerator<String> lggGenerator=new LGGGeneratorImpl<String>();
  NBRGenerator<String> nbrGenerator=new NBRGeneratorImpl<String>(new BruteForceNBRStrategy<String>());
  int cnt=1;
  for (  QueryTree<String> tree : posExampleTrees) {
    System.out.println(""String_Node_Str"" + cnt);
    tree.dump();
    System.out.println(""String_Node_Str"");
    cnt++;
  }
  QueryTree<String> lgg=lggGenerator.getLGG(posExampleTrees);
  System.out.println(""String_Node_Str"");
  lgg.dump();
  System.out.println(""String_Node_Str"");
  cnt=1;
  for (  QueryTree<String> tree : negExampleTrees) {
    System.out.println(""String_Node_Str"" + cnt);
    tree.dump();
    System.out.println(""String_Node_Str"");
    cnt++;
  }
  QueryTree<String> nbr=nbrGenerator.getNBR(lgg,negExampleTrees);
  System.out.println(""String_Node_Str"");
  nbr.dump();
}"
9746,"private static SortedSet<PropertyContext> getForallContexts(Description description,PropertyContext currentContext){
  if (description instanceof Restriction) {
    Property op=(Property)((Restriction)description).getRestrictedPropertyExpression();
    if (op instanceof ObjectProperty) {
      currentContext.add((ObjectProperty)op);
      if (description instanceof ObjectAllRestriction) {
        TreeSet<PropertyContext> contexts=new TreeSet<PropertyContext>();
        contexts.add(currentContext);
        contexts.addAll(getForallContexts(description.getChild(0),currentContext));
        return contexts;
      }
 else {
        return getForallContexts(description.getChild(0),currentContext);
      }
    }
 else {
      return new TreeSet<PropertyContext>();
    }
  }
 else {
    TreeSet<PropertyContext> contexts=new TreeSet<PropertyContext>();
    for (    Description child : description.getChildren()) {
      contexts.addAll(getForallContexts(child,currentContext));
    }
    return contexts;
  }
}","private static SortedSet<PropertyContext> getForallContexts(Description description,PropertyContext currentContext){
  if (description instanceof Restriction) {
    Property op=(Property)((Restriction)description).getRestrictedPropertyExpression();
    if (op instanceof ObjectProperty) {
      PropertyContext currentContextCopy=(PropertyContext)currentContext.clone();
      if (description instanceof ObjectAllRestriction) {
        currentContextCopy.add((ObjectProperty)op);
        TreeSet<PropertyContext> contexts=new TreeSet<PropertyContext>();
        contexts.add(currentContextCopy);
        contexts.addAll(getForallContexts(description.getChild(0),currentContextCopy));
        return contexts;
      }
 else       if (description.getChildren().size() > 0) {
        currentContextCopy.add((ObjectProperty)op);
        return getForallContexts(description.getChild(0),currentContextCopy);
      }
 else {
        return new TreeSet<PropertyContext>();
      }
    }
 else {
      return new TreeSet<PropertyContext>();
    }
  }
 else {
    TreeSet<PropertyContext> contexts=new TreeSet<PropertyContext>();
    for (    Description child : description.getChildren()) {
      contexts.addAll(getForallContexts(child,currentContext));
    }
    return contexts;
  }
}"
9747,"public void visit(DisjointClassesAxiom axiom){
  Set<Description> descriptions=axiom.getDescriptions();
  Set<OWLClassExpression> owlAPIDescriptions=new HashSet<OWLClassExpression>();
  for (  Description description : descriptions)   owlAPIDescriptions.add(getOWLClassExpression(description));
  OWLAxiom axiomOWLAPI=factory.getOWLDisjointClassesAxiom(owlAPIDescriptions);
  addAxiom(axiomOWLAPI);
}","@Override public void visit(StringDatatypePropertyAssertion axiom){
  throw new UnsupportedOperationException(""String_Node_Str"");
}"
9748,"public Set<OWLClass> getInconsistentOWLClasses(){
  return reasoner.getUnsatisfiableClasses().getEntities();
}","public Set<OWLClass> getInconsistentOWLClasses(){
  return reasoner.getUnsatisfiableClasses().getEntitiesMinusBottom();
}"
9749,"@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  factory=manager.getOWLDataFactory();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  loadedOntologies=new HashSet<OWLOntology>();
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      if (source instanceof OWLAPIOntology) {
        ontology=((OWLAPIOntology)source).getOWLOntolgy();
      }
 else       if (source instanceof SparqlKnowledgeSource) {
        ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
        manager=ontology.getOWLOntologyManager();
      }
 else {
        try {
          ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url.toURI()));
        }
 catch (        OWLOntologyCreationException e) {
          e.printStackTrace();
        }
catch (        URISyntaxException e) {
          e.printStackTrace();
        }
      }
      owlAPIOntologies.add(ontology);
      Set<OWLOntology> imports=manager.getImportsClosure(ontology);
      allImports.addAll(imports);
      loadedOntologies.addAll(imports);
      classes.addAll(ontology.getClassesInSignature(true));
      owlObjectProperties.addAll(ontology.getObjectPropertiesInSignature(true));
      owlDatatypeProperties.addAll(ontology.getDataPropertiesInSignature(true));
      owlIndividuals.addAll(ontology.getIndividualsInSignature(true));
      OWLOntologyFormat format=manager.getOntologyFormat(ontology);
      if (format instanceof PrefixOWLOntologyFormat) {
        prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
        baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
        prefixes.remove(""String_Node_Str"");
      }
      for (      OWLClass owlClass : classes)       atomicConcepts.add(new NamedClass(owlClass.toStringID()));
      for (      OWLObjectProperty owlProperty : owlObjectProperties)       atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
      for (      OWLDataProperty owlProperty : owlDatatypeProperties) {
        DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
        Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
        for (        OWLDataRange range : ranges) {
          if (range.isDatatype()) {
            if (range.asOWLDatatype().isBoolean())             booleanDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isDouble())             doubleDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isInteger())             intDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isString())             stringDatatypeProperties.add(dtp);
          }
        }
        datatypeProperties.add(dtp);
      }
      for (      OWLNamedIndividual owlIndividual : owlIndividuals) {
        individuals.add(new Individual(owlIndividual.toStringID()));
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyIRI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyIRI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  PelletOptions.USE_CLASSIFICATION_MONITOR=PelletOptions.MonitorType.NONE;
  Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
  pelletLogger.setLevel(Level.WARN);
  reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology);
  classifier=PelletIncremantalReasonerFactory.getInstance().createReasoner(reasoner);
}","@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  factory=manager.getOWLDataFactory();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  loadedOntologies=new HashSet<OWLOntology>();
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      if (source instanceof OWLAPIOntology) {
        ontology=((OWLAPIOntology)source).getOWLOntolgy();
        manager=ontology.getOWLOntologyManager();
      }
 else       if (source instanceof SparqlKnowledgeSource) {
        ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
        manager=ontology.getOWLOntologyManager();
      }
 else {
        try {
          ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url.toURI()));
        }
 catch (        OWLOntologyCreationException e) {
          e.printStackTrace();
        }
catch (        URISyntaxException e) {
          e.printStackTrace();
        }
      }
      owlAPIOntologies.add(ontology);
      Set<OWLOntology> imports=manager.getImportsClosure(ontology);
      allImports.addAll(imports);
      loadedOntologies.addAll(imports);
      classes.addAll(ontology.getClassesInSignature(true));
      owlObjectProperties.addAll(ontology.getObjectPropertiesInSignature(true));
      owlDatatypeProperties.addAll(ontology.getDataPropertiesInSignature(true));
      owlIndividuals.addAll(ontology.getIndividualsInSignature(true));
      OWLOntologyFormat format=manager.getOntologyFormat(ontology);
      if (format instanceof PrefixOWLOntologyFormat) {
        prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
        baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
        prefixes.remove(""String_Node_Str"");
      }
      for (      OWLClass owlClass : classes)       atomicConcepts.add(new NamedClass(owlClass.toStringID()));
      for (      OWLObjectProperty owlProperty : owlObjectProperties)       atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
      for (      OWLDataProperty owlProperty : owlDatatypeProperties) {
        DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
        Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
        for (        OWLDataRange range : ranges) {
          if (range.isDatatype()) {
            if (range.asOWLDatatype().isBoolean())             booleanDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isDouble())             doubleDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isInteger())             intDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isString())             stringDatatypeProperties.add(dtp);
          }
        }
        datatypeProperties.add(dtp);
      }
      for (      OWLNamedIndividual owlIndividual : owlIndividuals) {
        individuals.add(new Individual(owlIndividual.toStringID()));
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyIRI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyIRI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  PelletOptions.USE_CLASSIFICATION_MONITOR=PelletOptions.MonitorType.NONE;
  Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
  pelletLogger.setLevel(Level.WARN);
  reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology);
  classifier=PelletIncremantalReasonerFactory.getInstance().createReasoner(reasoner);
}"
9750,"public void loadOntologies() throws URISyntaxException, OWLOntologyCreationException {
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  loadedOntologies=new HashSet<OWLOntology>();
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      if (source instanceof OWLAPIOntology) {
        ontology=((OWLAPIOntology)source).getOWLOntolgy();
      }
 else       if (source instanceof SparqlKnowledgeSource) {
        ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
      }
 else {
        ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url));
      }
      owlAPIOntologies.add(ontology);
      Set<OWLOntology> imports=manager.getImportsClosure(ontology);
      allImports.addAll(imports);
      loadedOntologies.addAll(imports);
      classes.addAll(ontology.getClassesInSignature(true));
      owlObjectProperties.addAll(ontology.getObjectPropertiesInSignature(true));
      owlDatatypeProperties.addAll(ontology.getDataPropertiesInSignature(true));
      owlIndividuals.addAll(ontology.getIndividualsInSignature(true));
      OWLOntologyFormat format=manager.getOntologyFormat(ontology);
      if (format instanceof PrefixOWLOntologyFormat) {
        prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
        baseURI=prefixes.get(""String_Node_Str"");
        prefixes.remove(""String_Node_Str"");
      }
      for (      OWLClass owlClass : classes)       atomicConcepts.add(new NamedClass(owlClass.toStringID()));
      for (      OWLObjectProperty owlProperty : owlObjectProperties)       atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
      for (      OWLDataProperty owlProperty : owlDatatypeProperties) {
        DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
        Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
        Iterator<OWLDataRange> it=ranges.iterator();
        if (it.hasNext()) {
          OWLDataRange range=it.next();
          if (range.isDatatype()) {
            URI uri=((OWLDatatype)range).getIRI().toURI();
            if (uri.equals(Datatype.BOOLEAN.getURI()))             booleanDatatypeProperties.add(dtp);
 else             if (uri.equals(Datatype.DOUBLE.getURI()))             doubleDatatypeProperties.add(dtp);
 else             if (uri.equals(Datatype.INT.getURI()))             intDatatypeProperties.add(dtp);
 else             if (uri.equals(Datatype.STRING.getURI()))             stringDatatypeProperties.add(dtp);
          }
        }
        datatypeProperties.add(dtp);
      }
      for (      OWLNamedIndividual owlIndividual : owlIndividuals) {
        individuals.add(new Individual(owlIndividual.toStringID()));
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyIRI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyIRI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
}","public void loadOntologies() throws URISyntaxException, OWLOntologyCreationException {
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  loadedOntologies=new HashSet<OWLOntology>();
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      if (source instanceof OWLAPIOntology) {
        ontology=((OWLAPIOntology)source).getOWLOntolgy();
        manager=ontology.getOWLOntologyManager();
      }
 else       if (source instanceof SparqlKnowledgeSource) {
        ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
        manager=ontology.getOWLOntologyManager();
      }
 else {
        ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url));
      }
      owlAPIOntologies.add(ontology);
      Set<OWLOntology> imports=manager.getImportsClosure(ontology);
      allImports.addAll(imports);
      loadedOntologies.addAll(imports);
      classes.addAll(ontology.getClassesInSignature(true));
      owlObjectProperties.addAll(ontology.getObjectPropertiesInSignature(true));
      owlDatatypeProperties.addAll(ontology.getDataPropertiesInSignature(true));
      owlIndividuals.addAll(ontology.getIndividualsInSignature(true));
      OWLOntologyFormat format=manager.getOntologyFormat(ontology);
      if (format instanceof PrefixOWLOntologyFormat) {
        prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
        baseURI=prefixes.get(""String_Node_Str"");
        prefixes.remove(""String_Node_Str"");
      }
      for (      OWLClass owlClass : classes)       atomicConcepts.add(new NamedClass(owlClass.toStringID()));
      for (      OWLObjectProperty owlProperty : owlObjectProperties)       atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
      for (      OWLDataProperty owlProperty : owlDatatypeProperties) {
        DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
        Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
        Iterator<OWLDataRange> it=ranges.iterator();
        if (it.hasNext()) {
          OWLDataRange range=it.next();
          if (range.isDatatype()) {
            URI uri=((OWLDatatype)range).getIRI().toURI();
            if (uri.equals(Datatype.BOOLEAN.getURI()))             booleanDatatypeProperties.add(dtp);
 else             if (uri.equals(Datatype.DOUBLE.getURI()))             doubleDatatypeProperties.add(dtp);
 else             if (uri.equals(Datatype.INT.getURI()))             intDatatypeProperties.add(dtp);
 else             if (uri.equals(Datatype.STRING.getURI()))             stringDatatypeProperties.add(dtp);
          }
        }
        datatypeProperties.add(dtp);
      }
      for (      OWLNamedIndividual owlIndividual : owlIndividuals) {
        individuals.add(new Individual(owlIndividual.toStringID()));
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyIRI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyIRI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
}"
9751,"@Override public Set<NamedClass> getInconsistentClassesImpl(){
  Set<NamedClass> concepts=new HashSet<NamedClass>();
  for (  OWLClass concept : reasoner.getUnsatisfiableClasses().getEntities()) {
    concepts.add(new NamedClass(concept.toStringID()));
  }
  return concepts;
}","@Override public Set<NamedClass> getInconsistentClassesImpl(){
  Set<NamedClass> concepts=new HashSet<NamedClass>();
  for (  OWLClass concept : reasoner.getUnsatisfiableClasses().getEntitiesMinusBottom()) {
    concepts.add(new NamedClass(concept.toStringID()));
  }
  return concepts;
}"
9752,"private SortedSet<Description> getNegClassCandidatesRecursive(Description index,Description lowerClass){
  SortedSet<Description> candidates=new TreeSet<Description>(conceptComparator);
  for (  Description candidate : subHierarchy.getSuperClasses(lowerClass)) {
    if (!isDisjoint(new Negation(candidate),index)) {
      boolean meaningful;
      if (instanceBasedDisjoints) {
        SortedSet<Individual> tmp=rs.getIndividuals(lowerClass);
        tmp.removeAll(rs.getIndividuals(new Negation(candidate)));
        meaningful=tmp.size() != 0;
      }
 else {
        meaningful=!isDisjoint(candidate,index);
      }
      if (meaningful) {
        candidates.add(new Negation(candidate));
      }
 else {
        candidates.addAll(getClassCandidatesRecursive(index,candidate));
      }
    }
  }
  return candidates;
}","private SortedSet<Description> getNegClassCandidatesRecursive(Description index,Description lowerClass){
  SortedSet<Description> candidates=new TreeSet<Description>(conceptComparator);
  for (  Description candidate : subHierarchy.getSuperClasses(lowerClass)) {
    if (!(candidate instanceof Thing)) {
      if (!isDisjoint(new Negation(candidate),index)) {
        boolean meaningful;
        if (instanceBasedDisjoints) {
          SortedSet<Individual> tmp=rs.getIndividuals(index);
          tmp.removeAll(rs.getIndividuals(new Negation(candidate)));
          meaningful=tmp.size() != 0;
        }
 else {
          meaningful=!isDisjoint(candidate,index);
        }
        if (meaningful) {
          candidates.add(new Negation(candidate));
        }
 else {
          candidates.addAll(getNegClassCandidatesRecursive(index,candidate));
        }
      }
    }
  }
  return candidates;
}"
9753,"private SortedSet<Description> getClassCandidatesRecursive(Description index,Description upperClass){
  SortedSet<Description> candidates=new TreeSet<Description>();
  for (  Description candidate : subHierarchy.getSubClasses(upperClass)) {
    if (!isDisjoint(candidate,index)) {
      boolean meaningful;
      if (instanceBasedDisjoints) {
        SortedSet<Individual> tmp=rs.getIndividuals(upperClass);
        tmp.removeAll(rs.getIndividuals(candidate));
        meaningful=tmp.size() != 0;
      }
 else {
        meaningful=!isDisjoint(new Negation(candidate),index);
      }
      if (meaningful) {
        candidates.add(candidate);
      }
 else {
        candidates.addAll(getClassCandidatesRecursive(index,candidate));
      }
    }
  }
  return candidates;
}","private SortedSet<Description> getClassCandidatesRecursive(Description index,Description upperClass){
  SortedSet<Description> candidates=new TreeSet<Description>();
  for (  Description candidate : subHierarchy.getSubClasses(upperClass)) {
    if (!isDisjoint(candidate,index)) {
      boolean meaningful;
      if (instanceBasedDisjoints) {
        SortedSet<Individual> tmp=rs.getIndividuals(index);
        tmp.removeAll(rs.getIndividuals(candidate));
        meaningful=tmp.size() != 0;
      }
 else {
        meaningful=!isDisjoint(new Negation(candidate),index);
      }
      if (meaningful) {
        candidates.add(candidate);
      }
 else {
        candidates.addAll(getClassCandidatesRecursive(index,candidate));
      }
    }
  }
  return candidates;
}"
9754,"private void computeM(NamedClass nc){
  long mComputationTimeStartNs=System.nanoTime();
  mA.put(nc,new TreeMap<Integer,SortedSet<Description>>());
  for (int i=1; i <= mMaxLength; i++) {
    mA.get(nc).put(i,new TreeSet<Description>(conceptComparator));
  }
  SortedSet<Description> m1=getClassCandidates(nc);
  mA.get(nc).put(1,m1);
  SortedSet<Description> m2=getNegClassCandidates(nc);
  mA.get(nc).put(2,m2);
  computeMg(nc);
  if (useBooleanDatatypes) {
    Set<DatatypeProperty> booleanDPs=mgbd.get(nc);
    for (    DatatypeProperty dp : booleanDPs) {
      m2.add(new BooleanValueRestriction(dp,true));
      m2.add(new BooleanValueRestriction(dp,false));
    }
  }
  mA.get(nc).put(2,m2);
  SortedSet<Description> m3=new TreeSet<Description>(conceptComparator);
  if (useExistsConstructor) {
    for (    ObjectProperty r : mgr.get(nc)) {
      m3.add(new ObjectSomeRestriction(r,new Thing()));
    }
  }
  if (useAllConstructor) {
    for (    ObjectProperty r : mgr.get(nc)) {
      m3.add(new ObjectAllRestriction(r,new Thing()));
    }
  }
  if (useDoubleDatatypes) {
    Set<DatatypeProperty> doubleDPs=mgdd.get(nc);
    for (    DatatypeProperty dp : doubleDPs) {
      if (splits.get(dp).size() > 0) {
        DoubleMaxValue max=new DoubleMaxValue(splits.get(dp).get(splits.get(dp).size() - 1));
        DoubleMinValue min=new DoubleMinValue(splits.get(dp).get(0));
        m3.add(new DatatypeSomeRestriction(dp,max));
        m3.add(new DatatypeSomeRestriction(dp,min));
      }
    }
  }
  if (useDataHasValueConstructor) {
    Set<DatatypeProperty> stringDPs=mgsd.get(nc);
    for (    DatatypeProperty dp : stringDPs) {
      Set<Constant> freqValues=frequentDataValues.get(dp);
      for (      Constant c : freqValues) {
        m3.add(new StringValueRestriction(dp,c.getLiteral()));
      }
    }
  }
  mA.get(nc).put(3,m3);
  SortedSet<Description> m4=new TreeSet<Description>(conceptComparator);
  if (useCardinalityRestrictions) {
    for (    ObjectProperty r : mgr.get(nc)) {
      int maxFillers=maxNrOfFillers.get(r);
      if (maxFillers > 0)       m4.add(new ObjectMaxCardinalityRestriction(maxFillers - 1,r,new Thing()));
    }
  }
  mA.get(nc).put(4,m4);
  mComputationTimeNs+=System.nanoTime() - mComputationTimeStartNs;
}","private void computeM(NamedClass nc){
  long mComputationTimeStartNs=System.nanoTime();
  mA.put(nc,new TreeMap<Integer,SortedSet<Description>>());
  for (int i=1; i <= mMaxLength; i++) {
    mA.get(nc).put(i,new TreeSet<Description>(conceptComparator));
  }
  SortedSet<Description> m1=getClassCandidates(nc);
  mA.get(nc).put(1,m1);
  SortedSet<Description> m2=new TreeSet<Description>();
  if (useNegation) {
    m2=getNegClassCandidates(nc);
    mA.get(nc).put(2,m2);
  }
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + nc + ""String_Node_Str""+ m1);
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + nc + ""String_Node_Str""+ m2);
  computeMg(nc);
  if (useBooleanDatatypes) {
    Set<DatatypeProperty> booleanDPs=mgbd.get(nc);
    for (    DatatypeProperty dp : booleanDPs) {
      m2.add(new BooleanValueRestriction(dp,true));
      m2.add(new BooleanValueRestriction(dp,false));
    }
  }
  mA.get(nc).put(2,m2);
  SortedSet<Description> m3=new TreeSet<Description>(conceptComparator);
  if (useExistsConstructor) {
    for (    ObjectProperty r : mgr.get(nc)) {
      m3.add(new ObjectSomeRestriction(r,new Thing()));
    }
  }
  if (useAllConstructor) {
    for (    ObjectProperty r : mgr.get(nc)) {
      m3.add(new ObjectAllRestriction(r,new Thing()));
    }
  }
  if (useDoubleDatatypes) {
    Set<DatatypeProperty> doubleDPs=mgdd.get(nc);
    for (    DatatypeProperty dp : doubleDPs) {
      if (splits.get(dp).size() > 0) {
        DoubleMaxValue max=new DoubleMaxValue(splits.get(dp).get(splits.get(dp).size() - 1));
        DoubleMinValue min=new DoubleMinValue(splits.get(dp).get(0));
        m3.add(new DatatypeSomeRestriction(dp,max));
        m3.add(new DatatypeSomeRestriction(dp,min));
      }
    }
  }
  if (useDataHasValueConstructor) {
    Set<DatatypeProperty> stringDPs=mgsd.get(nc);
    for (    DatatypeProperty dp : stringDPs) {
      Set<Constant> freqValues=frequentDataValues.get(dp);
      for (      Constant c : freqValues) {
        m3.add(new StringValueRestriction(dp,c.getLiteral()));
      }
    }
  }
  mA.get(nc).put(3,m3);
  SortedSet<Description> m4=new TreeSet<Description>(conceptComparator);
  if (useCardinalityRestrictions) {
    for (    ObjectProperty r : mgr.get(nc)) {
      int maxFillers=maxNrOfFillers.get(r);
      if (maxFillers > 0)       m4.add(new ObjectMaxCardinalityRestriction(maxFillers - 1,r,new Thing()));
    }
  }
  mA.get(nc).put(4,m4);
  mComputationTimeNs+=System.nanoTime() - mComputationTimeStartNs;
}"
9755,"private Set<OWLDisjointClassesAxiom> retrieveDisjointClassAxioms(){
  logger.info(""String_Node_Str"");
  queryMonitor.start();
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(""String_Node_Str"").append(OWL.disjointWith).append(""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(RESULT_LIMIT);
  Query query=QueryFactory.create(sb.toString());
  QueryExecution sparqlQueryExec=QueryExecutionFactory.sparqlService(endpointURI,query,DEFAULT_GRAPH_URI);
  ResultSet sparqlResults=sparqlQueryExec.execSelect();
  Set<OWLDisjointClassesAxiom> axioms=new HashSet<OWLDisjointClassesAxiom>();
  QuerySolution solution;
  RDFNode rdfNodeSubject;
  RDFNode rdfNodeObject;
  OWLClass disjointClass1;
  OWLClass disjointClass2;
  while (sparqlResults.hasNext()) {
    solution=sparqlResults.nextSolution();
    rdfNodeSubject=solution.getResource(""String_Node_Str"");
    rdfNodeObject=solution.getResource(""String_Node_Str"");
    if (rdfNodeSubject.isAnon() || rdfNodeObject.isAnon()) {
      continue;
    }
    disjointClass1=factory.getOWLClass(IRI.create(rdfNodeSubject.toString()));
    disjointClass2=factory.getOWLClass(IRI.create(rdfNodeObject.toString()));
    axioms.add(factory.getOWLDisjointClassesAxiom(disjointClass1,disjointClass2));
  }
  queryMonitor.stop();
  logger.info(""String_Node_Str"" + axioms.size() + ""String_Node_Str""+ queryMonitor.getLastValue()+ ""String_Node_Str"");
  return axioms;
}","private Set<OWLDisjointClassesAxiom> retrieveDisjointClassAxioms(){
  logger.info(""String_Node_Str"");
  queryMonitor.start();
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(""String_Node_Str"").append(OWL.disjointWith).append(""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(RESULT_LIMIT);
  System.out.println(sb);
  Query query=QueryFactory.create(sb.toString());
  QueryExecution sparqlQueryExec=QueryExecutionFactory.sparqlService(endpointURI,query,DEFAULT_GRAPH_URI);
  ResultSet sparqlResults=sparqlQueryExec.execSelect();
  Set<OWLDisjointClassesAxiom> axioms=new HashSet<OWLDisjointClassesAxiom>();
  QuerySolution solution;
  RDFNode rdfNodeSubject;
  RDFNode rdfNodeObject;
  OWLClass disjointClass1;
  OWLClass disjointClass2;
  while (sparqlResults.hasNext()) {
    solution=sparqlResults.nextSolution();
    rdfNodeSubject=solution.getResource(""String_Node_Str"");
    rdfNodeObject=solution.getResource(""String_Node_Str"");
    if (rdfNodeSubject.isAnon() || rdfNodeObject.isAnon()) {
      continue;
    }
    disjointClass1=factory.getOWLClass(IRI.create(rdfNodeSubject.toString()));
    disjointClass2=factory.getOWLClass(IRI.create(rdfNodeObject.toString()));
    axioms.add(factory.getOWLDisjointClassesAxiom(disjointClass1,disjointClass2));
  }
  queryMonitor.stop();
  logger.info(""String_Node_Str"" + axioms.size() + ""String_Node_Str""+ queryMonitor.getLastValue()+ ""String_Node_Str"");
  return axioms;
}"
9756,"/** 
 * Retrieve axioms for a given individual. Axiom types: SameAs, DifferentFrom, ClassAssertion, ObjectPropertyAssertion, DataPropertyAssertion
 * @param ind
 * @return
 */
private Set<OWLAxiom> retrieveAxiomsForIndividual(OWLNamedIndividual ind){
  logger.info(""String_Node_Str"" + ind);
  Set<OWLAxiom> axioms=new HashSet<OWLAxiom>();
  queryMonitor.start();
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(ind.toStringID()).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(RESULT_LIMIT);
  Query query=QueryFactory.create(sb.toString());
  QueryExecution queryExec=QueryExecutionFactory.sparqlService(endpointURI,query,DEFAULT_GRAPH_URI);
  ResultSet results=queryExec.execSelect();
  QuerySolution solution;
  RDFNode rdfNodePredicate;
  RDFNode rdfNodeObject;
  while (results.hasNext()) {
    solution=results.nextSolution();
    rdfNodePredicate=solution.getResource(""String_Node_Str"");
    rdfNodeObject=solution.get(""String_Node_Str"");
    if (rdfNodeObject.isAnon()) {
      continue;
    }
    if (rdfNodePredicate.equals(RDF.type)) {
      axioms.add(factory.getOWLClassAssertionAxiom(factory.getOWLClass(IRI.create(rdfNodeObject.toString())),ind));
    }
 else     if (rdfNodePredicate.equals(OWL.sameAs)) {
      axioms.add(factory.getOWLSameIndividualAxiom(ind,factory.getOWLNamedIndividual(IRI.create(rdfNodePredicate.toString()))));
    }
 else     if (rdfNodePredicate.equals(OWL.differentFrom)) {
      axioms.add(factory.getOWLDifferentIndividualsAxiom(ind,factory.getOWLNamedIndividual(IRI.create(rdfNodePredicate.toString()))));
    }
 else     if (rdfNodeObject.isLiteral()) {
      if (rdfNodeObject.equals(RDFS.comment)) {
      }
 else       if (rdfNodeObject.equals(RDFS.label)) {
      }
 else {
        axioms.add(factory.getOWLDataPropertyAssertionAxiom(factory.getOWLDataProperty(IRI.create(rdfNodePredicate.toString())),ind,rdfNodeObject.toString()));
      }
    }
 else     if (rdfNodeObject.isResource()) {
      axioms.add(factory.getOWLObjectPropertyAssertionAxiom(factory.getOWLObjectProperty(IRI.create(rdfNodePredicate.toString())),ind,factory.getOWLNamedIndividual(IRI.create(rdfNodeObject.toString()))));
    }
  }
  if (axioms.isEmpty()) {
    axioms.addAll(getAxiomsFromLinkedDataSource(ind.getIRI()));
  }
  queryMonitor.stop();
  logger.info(""String_Node_Str"" + axioms.size() + ""String_Node_Str""+ queryMonitor.getLastValue()+ ""String_Node_Str"");
  return axioms;
}","/** 
 * Retrieve axioms for a given individual. Axiom types: SameAs, DifferentFrom, ClassAssertion, ObjectPropertyAssertion, DataPropertyAssertion
 * @param ind
 * @return
 */
private Set<OWLAxiom> retrieveAxiomsForIndividual(OWLNamedIndividual ind){
  logger.info(""String_Node_Str"" + ind);
  Set<OWLAxiom> axioms=new HashSet<OWLAxiom>();
  queryMonitor.start();
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(ind.toStringID()).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(RESULT_LIMIT);
  Query query=QueryFactory.create(sb.toString());
  QueryExecution queryExec=QueryExecutionFactory.sparqlService(endpointURI,query,DEFAULT_GRAPH_URI);
  ResultSet results=queryExec.execSelect();
  QuerySolution solution;
  RDFNode rdfNodePredicate;
  RDFNode rdfNodeObject;
  while (results.hasNext()) {
    solution=results.nextSolution();
    rdfNodePredicate=solution.getResource(""String_Node_Str"");
    rdfNodeObject=solution.get(""String_Node_Str"");
    if (rdfNodeObject.isAnon()) {
      continue;
    }
    if (rdfNodePredicate.equals(RDF.type)) {
      axioms.add(factory.getOWLClassAssertionAxiom(factory.getOWLClass(IRI.create(rdfNodeObject.toString())),ind));
    }
 else     if (rdfNodePredicate.equals(OWL.sameAs)) {
      axioms.add(factory.getOWLSameIndividualAxiom(ind,factory.getOWLNamedIndividual(IRI.create(rdfNodeObject.toString()))));
    }
 else     if (rdfNodePredicate.equals(OWL.differentFrom)) {
      axioms.add(factory.getOWLDifferentIndividualsAxiom(ind,factory.getOWLNamedIndividual(IRI.create(rdfNodeObject.toString()))));
    }
 else     if (rdfNodeObject.isLiteral()) {
      if (rdfNodeObject.equals(RDFS.comment)) {
      }
 else       if (rdfNodeObject.equals(RDFS.label)) {
      }
 else {
        axioms.add(factory.getOWLDataPropertyAssertionAxiom(factory.getOWLDataProperty(IRI.create(rdfNodePredicate.toString())),ind,rdfNodeObject.toString()));
      }
    }
 else     if (rdfNodeObject.isResource()) {
      axioms.add(factory.getOWLObjectPropertyAssertionAxiom(factory.getOWLObjectProperty(IRI.create(rdfNodePredicate.toString())),ind,factory.getOWLNamedIndividual(IRI.create(rdfNodeObject.toString()))));
    }
  }
  if (axioms.isEmpty()) {
    axioms.addAll(getAxiomsFromLinkedDataSource(ind.getIRI()));
  }
  queryMonitor.stop();
  logger.info(""String_Node_Str"" + axioms.size() + ""String_Node_Str""+ queryMonitor.getLastValue()+ ""String_Node_Str"");
  return axioms;
}"
9757,"/** 
 * This method checks incrementally the consistency of the knowledgebase.
 * @param endpointURI
 */
private void checkForInconsistency(String endpointURI){
  this.endpointURI=endpointURI;
  logger.info(""String_Node_Str"" + endpointURI);
  PelletOptions.USE_COMPLETION_QUEUE=true;
  PelletOptions.USE_INCREMENTAL_CONSISTENCY=true;
  PelletOptions.USE_SMART_RESTORE=false;
  OWLReasoner reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology);
  overallMonitor.reset();
  reasonerMonitor.reset();
  queryMonitor.reset();
  overallMonitor.start();
  Set<OWLClass> visitedClasses=new HashSet<OWLClass>();
  Set<OWLObjectProperty> visitedObjectProperties=new HashSet<OWLObjectProperty>();
  Set<OWLNamedIndividual> visitedIndividuals=new HashSet<OWLNamedIndividual>();
  Set<OWLClass> classesToVisit=new HashSet<OWLClass>();
  Set<OWLClass> tmp=new HashSet<OWLClass>();
  Set<OWLDisjointClassesAxiom> disjointAxioms=retrieveDisjointClassAxioms();
  manager.addAxioms(ontology,disjointAxioms);
  for (  OWLDisjointClassesAxiom ax : disjointAxioms) {
    for (    OWLClassExpression cl : ax.getClassExpressions()) {
      if (!cl.isAnonymous()) {
        classesToVisit.add(cl.asOWLClass());
      }
    }
  }
  boolean isConsistent=true;
  Set<OWLAxiom> axioms;
  logger.info(""String_Node_Str"" + classesToVisit.size() + ""String_Node_Str"");
  for (int i=1; i <= RECURSION_DEPTH; i++) {
    logger.info(""String_Node_Str"" + i);
    for (    OWLClass cl : classesToVisit) {
      axioms=retrieveAxiomsForClass(cl);
      manager.addAxioms(ontology,axioms);
      if (!axioms.isEmpty()) {
        logger.info(""String_Node_Str"");
        reasonerMonitor.start();
        isConsistent=reasoner.isConsistent();
        reasonerMonitor.stop();
      }
      for (      OWLAxiom ax : axioms) {
        tmp.addAll(ax.getClassesInSignature());
      }
      if (!isConsistent && BREAK_AFTER_ERROR_FOUND) {
        logger.info(""String_Node_Str"");
        break;
      }
    }
    logger.info(""String_Node_Str"" + ontology.getIndividualsInSignature().size() + ""String_Node_Str"");
    for (    OWLNamedIndividual ind : ontology.getIndividualsInSignature()) {
      if (!visitedIndividuals.contains(ind)) {
        manager.addAxioms(ontology,retrieveAxiomsForIndividual(ind));
        visitedIndividuals.add(ind);
      }
    }
    logger.info(""String_Node_Str"" + ontology.getObjectPropertiesInSignature().size() + ""String_Node_Str"");
    for (    OWLObjectProperty prop : ontology.getObjectPropertiesInSignature()) {
      if (!visitedObjectProperties.contains(prop)) {
        manager.addAxioms(ontology,retrieveAxiomsForObjectProperty(prop));
        visitedObjectProperties.add(prop);
      }
    }
    if (!isConsistent && BREAK_AFTER_ERROR_FOUND) {
      break;
    }
    visitedClasses.addAll(classesToVisit);
    tmp.removeAll(visitedClasses);
    classesToVisit.clear();
    classesToVisit.addAll(tmp);
    tmp.clear();
  }
  overallMonitor.stop();
  showStats();
  if (!reasoner.isConsistent()) {
    ExplanationGenerator expGen=new PelletExplanationGenerator(ontology);
    logger.info(expGen.getExplanation(factory.getOWLSubClassOfAxiom(factory.getOWLThing(),factory.getOWLNothing())));
  }
}","/** 
 * This method checks incrementally the consistency of the knowledgebase.
 * @param endpointURI
 */
private void checkForInconsistency(String endpointURI){
  this.endpointURI=endpointURI;
  logger.info(""String_Node_Str"" + endpointURI);
  PelletOptions.USE_COMPLETION_QUEUE=true;
  PelletOptions.USE_INCREMENTAL_CONSISTENCY=true;
  PelletOptions.USE_SMART_RESTORE=false;
  OWLReasoner reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology);
  overallMonitor.reset();
  reasonerMonitor.reset();
  queryMonitor.reset();
  overallMonitor.start();
  Set<OWLClass> visitedClasses=new HashSet<OWLClass>();
  Set<OWLObjectProperty> visitedObjectProperties=new HashSet<OWLObjectProperty>();
  Set<OWLNamedIndividual> visitedIndividuals=new HashSet<OWLNamedIndividual>();
  Set<OWLClass> classesToVisit=new HashSet<OWLClass>();
  Set<OWLClass> tmp=new HashSet<OWLClass>();
  Set<OWLDisjointClassesAxiom> disjointAxioms=retrieveDisjointClassAxioms();
  manager.addAxioms(ontology,disjointAxioms);
  for (  OWLDisjointClassesAxiom ax : disjointAxioms) {
    for (    OWLClassExpression cl : ax.getClassExpressions()) {
      if (!cl.isAnonymous()) {
        classesToVisit.add(cl.asOWLClass());
      }
    }
  }
  boolean isConsistent=true;
  Set<OWLAxiom> axioms;
  logger.info(""String_Node_Str"" + classesToVisit.size() + ""String_Node_Str"");
  for (int i=1; i <= RECURSION_DEPTH; i++) {
    logger.info(""String_Node_Str"" + i);
    for (    OWLClass cl : classesToVisit) {
      axioms=retrieveAxiomsForClass(cl);
      manager.addAxioms(ontology,axioms);
      if (!axioms.isEmpty()) {
        logger.info(""String_Node_Str"");
        reasonerMonitor.start();
        isConsistent=reasoner.isConsistent();
        reasonerMonitor.stop();
      }
      for (      OWLAxiom ax : axioms) {
        tmp.addAll(ax.getClassesInSignature());
      }
      if (!isConsistent && BREAK_AFTER_ERROR_FOUND) {
        logger.info(""String_Node_Str"");
        break;
      }
    }
    logger.info(""String_Node_Str"" + ontology.getIndividualsInSignature().size() + ""String_Node_Str"");
    int cnt=0;
    for (    OWLNamedIndividual ind : ontology.getIndividualsInSignature()) {
      if (!visitedIndividuals.contains(ind)) {
        manager.addAxioms(ontology,retrieveAxiomsForIndividual(ind));
        visitedIndividuals.add(ind);
        logger.info(""String_Node_Str"");
        reasonerMonitor.start();
        isConsistent=reasoner.isConsistent();
        reasonerMonitor.stop();
      }
      if (!isConsistent && BREAK_AFTER_ERROR_FOUND) {
        logger.info(""String_Node_Str"");
        break;
      }
      cnt++;
      if (cnt == 100) {
        break;
      }
    }
    cnt=0;
    logger.info(""String_Node_Str"" + ontology.getObjectPropertiesInSignature().size() + ""String_Node_Str"");
    for (    OWLObjectProperty prop : ontology.getObjectPropertiesInSignature()) {
      if (!visitedObjectProperties.contains(prop)) {
        manager.addAxioms(ontology,retrieveAxiomsForObjectProperty(prop));
        visitedObjectProperties.add(prop);
        logger.info(""String_Node_Str"");
        reasonerMonitor.start();
        isConsistent=reasoner.isConsistent();
        reasonerMonitor.stop();
      }
      if (!isConsistent && BREAK_AFTER_ERROR_FOUND) {
        logger.info(""String_Node_Str"");
        break;
      }
      cnt++;
      if (cnt == 100) {
        break;
      }
    }
    if (!isConsistent && BREAK_AFTER_ERROR_FOUND) {
      break;
    }
    visitedClasses.addAll(classesToVisit);
    tmp.removeAll(visitedClasses);
    classesToVisit.clear();
    classesToVisit.addAll(tmp);
    tmp.clear();
  }
  overallMonitor.stop();
  showStats();
  if (!reasoner.isConsistent()) {
    ExplanationGenerator expGen=new PelletExplanationGenerator(ontology);
    logger.info(expGen.getExplanation(factory.getOWLSubClassOfAxiom(factory.getOWLThing(),factory.getOWLNothing())));
  }
}"
9758,"/** 
 * The method computes a new class hierarchy, which is a copy of this one, but only the specified classes are allowed to occur. For instance, if we have subclass relationships between 1sYearStudent, Student, and Person, but Student is not allowed, then there a is a subclass relationship between 1stYearStudent and Person. Currently, owl:Thing and owl:Nothing are always allowed for technical reasons.
 * @param allowedClasses The classes, which are allowed to occur in the newclass hierarchy.
 * @return A copy of this hierarchy, which is restricted to a certain setof classes.
 */
public ClassHierarchy cloneAndRestrict(Set<NamedClass> allowedClasses){
  Set<Description> allowed=new TreeSet<Description>(conceptComparator);
  allowed.addAll(allowedClasses);
  allowed.add(Thing.instance);
  allowed.add(Nothing.instance);
  TreeMap<Description,SortedSet<Description>> subsumptionHierarchyUpNew=new TreeMap<Description,SortedSet<Description>>(conceptComparator);
  TreeMap<Description,SortedSet<Description>> subsumptionHierarchyDownNew=new TreeMap<Description,SortedSet<Description>>(conceptComparator);
  for (  Entry<Description,SortedSet<Description>> entry : subsumptionHierarchyUp.entrySet()) {
    Description key=entry.getKey();
    if (allowed.contains(key)) {
      TreeSet<Description> superClasses=new TreeSet<Description>(entry.getValue());
      TreeSet<Description> newSuperClasses=new TreeSet<Description>(conceptComparator);
      while (!superClasses.isEmpty()) {
        Description d=superClasses.pollFirst();
        if (allowed.contains(d)) {
          newSuperClasses.add(d);
        }
 else {
          Set<Description> tmp=subsumptionHierarchyUp.get(d);
          superClasses.addAll(tmp);
        }
      }
      subsumptionHierarchyUpNew.put(key,newSuperClasses);
    }
  }
  for (  Entry<Description,SortedSet<Description>> entry : subsumptionHierarchyDown.entrySet()) {
    Description key=entry.getKey();
    if (allowed.contains(key)) {
      TreeSet<Description> subClasses=new TreeSet<Description>(entry.getValue());
      TreeSet<Description> newSubClasses=new TreeSet<Description>(entry.getValue());
      while (!subClasses.isEmpty()) {
        Description d=subClasses.pollFirst();
        if (allowed.contains(d)) {
          newSubClasses.add(d);
        }
 else {
          subClasses.addAll(subsumptionHierarchyDown.get(d));
        }
      }
      subsumptionHierarchyDownNew.put(key,newSubClasses);
    }
  }
  return new ClassHierarchy(subsumptionHierarchyUpNew,subsumptionHierarchyDownNew);
}","/** 
 * The method computes a new class hierarchy, which is a copy of this one, but only the specified classes are allowed to occur. For instance, if we have subclass relationships between 1sYearStudent, Student, and Person, but Student is not allowed, then there a is a subclass relationship between 1stYearStudent and Person. Currently, owl:Thing and owl:Nothing are always allowed for technical reasons.
 * @param allowedClasses The classes, which are allowed to occur in the newclass hierarchy.
 * @return A copy of this hierarchy, which is restricted to a certain setof classes.
 */
public ClassHierarchy cloneAndRestrict(Set<NamedClass> allowedClasses){
  Set<Description> allowed=new TreeSet<Description>(conceptComparator);
  allowed.addAll(allowedClasses);
  allowed.add(Thing.instance);
  allowed.add(Nothing.instance);
  TreeMap<Description,SortedSet<Description>> subsumptionHierarchyUpNew=new TreeMap<Description,SortedSet<Description>>(conceptComparator);
  TreeMap<Description,SortedSet<Description>> subsumptionHierarchyDownNew=new TreeMap<Description,SortedSet<Description>>(conceptComparator);
  for (  Entry<Description,SortedSet<Description>> entry : subsumptionHierarchyUp.entrySet()) {
    Description key=entry.getKey();
    if (allowed.contains(key)) {
      TreeSet<Description> superClasses=new TreeSet<Description>(entry.getValue());
      TreeSet<Description> newSuperClasses=new TreeSet<Description>(conceptComparator);
      while (!superClasses.isEmpty()) {
        Description d=superClasses.pollFirst();
        if (allowed.contains(d)) {
          newSuperClasses.add(d);
        }
 else {
          Set<Description> tmp=subsumptionHierarchyUp.get(d);
          superClasses.addAll(tmp);
        }
      }
      subsumptionHierarchyUpNew.put(key,newSuperClasses);
    }
  }
  for (  Entry<Description,SortedSet<Description>> entry : subsumptionHierarchyDown.entrySet()) {
    Description key=entry.getKey();
    if (allowed.contains(key)) {
      TreeSet<Description> subClasses=new TreeSet<Description>(entry.getValue());
      TreeSet<Description> newSubClasses=new TreeSet<Description>(conceptComparator);
      while (!subClasses.isEmpty()) {
        Description d=subClasses.pollFirst();
        if (allowed.contains(d)) {
          newSubClasses.add(d);
        }
 else {
          subClasses.addAll(subsumptionHierarchyDown.get(d));
        }
      }
      subsumptionHierarchyDownNew.put(key,newSubClasses);
    }
  }
  return new ClassHierarchy(subsumptionHierarchyUpNew,subsumptionHierarchyDownNew);
}"
9759,"private boolean addNode(Description description,OENode parentNode){
  boolean nonRedundant=descriptions.add(description);
  if (!nonRedundant) {
    return false;
  }
  if (!isDescriptionAllowed(description,parentNode)) {
    return false;
  }
  double accuracy=learningProblem.getAccuracyOrTooWeak(description,noise);
  if (accuracy > 1.0 || (accuracy < 0.0 && accuracy != -1)) {
    logger.warn(""String_Node_Str"" + accuracy + ""String_Node_Str""+ description+ ""String_Node_Str"");
    System.exit(0);
  }
  expressionTests++;
  if (accuracy == -1) {
    return false;
  }
  OENode node=new OENode(parentNode,description,accuracy);
  if (parentNode == null) {
    startNode=node;
  }
 else {
    parentNode.addChild(node);
  }
  nodes.add(node);
  if (singleSuggestionMode) {
    if (accuracy > bestAccuracy) {
      bestAccuracy=accuracy;
      bestDescription=description;
      logger.info(""String_Node_Str"" + dfPercent.format(bestAccuracy) + ""String_Node_Str""+ descriptionToString(bestDescription));
    }
    return true;
  }
  boolean isCandidate=!bestEvaluatedDescriptions.isFull();
  if (!isCandidate) {
    EvaluatedDescription worst=bestEvaluatedDescriptions.getWorst();
    double accThreshold=worst.getAccuracy();
    isCandidate=(accuracy > accThreshold || (accuracy >= accThreshold && description.getLength() < worst.getDescriptionLength()));
  }
  if (isCandidate) {
    Description niceDescription=rewriteNode(node);
    ConceptTransformation.transformToOrderedForm(niceDescription,descriptionComparator);
    boolean shorterDescriptionExists=false;
    for (    EvaluatedDescription ed : bestEvaluatedDescriptions.getSet()) {
      if (Math.abs(ed.getAccuracy() - accuracy) <= 0.00001 && ConceptTransformation.isSubdescription(niceDescription,ed.getDescription())) {
        shorterDescriptionExists=true;
        break;
      }
    }
    if (!shorterDescriptionExists) {
      if (!filterFollowsFromKB || !((ClassLearningProblem)learningProblem).followsFromKB(niceDescription)) {
        bestEvaluatedDescriptions.add(niceDescription,accuracy,learningProblem);
      }
    }
  }
  return true;
}","private boolean addNode(Description description,OENode parentNode){
  boolean nonRedundant=descriptions.add(description);
  if (!nonRedundant) {
    return false;
  }
  if (!isDescriptionAllowed(description,parentNode)) {
    return false;
  }
  double accuracy=learningProblem.getAccuracyOrTooWeak(description,noise);
  if (accuracy > 1.0 || (accuracy < 0.0 && accuracy != -1)) {
    logger.warn(""String_Node_Str"" + accuracy + ""String_Node_Str""+ description+ ""String_Node_Str"");
    System.exit(0);
  }
  expressionTests++;
  if (accuracy == -1) {
    return false;
  }
  OENode node=new OENode(parentNode,description,accuracy);
  if (parentNode == null) {
    startNode=node;
  }
 else {
    parentNode.addChild(node);
  }
  nodes.add(node);
  if (singleSuggestionMode) {
    if (accuracy > bestAccuracy) {
      bestAccuracy=accuracy;
      bestDescription=description;
      logger.info(""String_Node_Str"" + dfPercent.format(bestAccuracy) + ""String_Node_Str""+ descriptionToString(bestDescription));
    }
    return true;
  }
  boolean isCandidate=!bestEvaluatedDescriptions.isFull();
  if (!isCandidate) {
    EvaluatedDescription worst=bestEvaluatedDescriptions.getWorst();
    double accThreshold=worst.getAccuracy();
    isCandidate=(accuracy > accThreshold || (accuracy >= accThreshold && description.getLength() < worst.getDescriptionLength()));
  }
  if (isCandidate) {
    Description niceDescription=rewriteNode(node);
    ConceptTransformation.transformToOrderedForm(niceDescription,descriptionComparator);
    boolean shorterDescriptionExists=false;
    if (forceMutualDifference) {
      for (      EvaluatedDescription ed : bestEvaluatedDescriptions.getSet()) {
        if (Math.abs(ed.getAccuracy() - accuracy) <= 0.00001 && ConceptTransformation.isSubdescription(niceDescription,ed.getDescription())) {
          shorterDescriptionExists=true;
          break;
        }
      }
    }
    if (!shorterDescriptionExists) {
      if (!filterFollowsFromKB || !((ClassLearningProblem)learningProblem).followsFromKB(niceDescription)) {
        bestEvaluatedDescriptions.add(niceDescription,accuracy,learningProblem);
      }
    }
  }
  return true;
}"
9760,"@Override public void init() throws ComponentInitException {
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().clone();
  classHierarchy.thinOutSubsumptionHierarchy();
  minimizer=new DescriptionMinimizer(reasoner);
  startClass=Thing.instance;
  singleSuggestionMode=configurator.getSingleSuggestionMode();
  operator=new RhoDRDown(reasoner,classHierarchy,startClass,configurator);
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(configurator.getMaxNrOfResults());
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=configurator.getNoisePercentage() / 100d;
  maxDepth=configurator.getMaxDepth();
  filterFollowsFromKB=configurator.getFilterDescriptionsFollowingFromKB() && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (configurator.getReuseExistingDescription() && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}","@Override public void init() throws ComponentInitException {
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().clone();
  classHierarchy.thinOutSubsumptionHierarchy();
  minimizer=new DescriptionMinimizer(reasoner);
  startClass=Thing.instance;
  singleSuggestionMode=configurator.getSingleSuggestionMode();
  operator=new RhoDRDown(reasoner,classHierarchy,startClass,configurator);
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  if (configurator.getWriteSearchTree()) {
    Files.clearFile(new File(configurator.getSearchTreeFile()));
  }
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(configurator.getMaxNrOfResults());
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=configurator.getNoisePercentage() / 100d;
  maxDepth=configurator.getMaxDepth();
  filterFollowsFromKB=configurator.getFilterDescriptionsFollowingFromKB() && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (configurator.getReuseExistingDescription() && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}"
9761,"@Override public void start(){
  stop=false;
  isRunning=true;
  reset();
  nanoStartTime=System.nanoTime();
  double highestAccuracy=0.0;
  OENode nextNode;
  addNode(startClass,null);
  int loop=0;
  while (!terminationCriteriaSatisfied()) {
    if (!singleSuggestionMode && bestEvaluatedDescriptions.getBestAccuracy() > highestAccuracy) {
      highestAccuracy=bestEvaluatedDescriptions.getBestAccuracy();
      logger.info(""String_Node_Str"" + dfPercent.format(highestAccuracy) + ""String_Node_Str""+ descriptionToString(bestEvaluatedDescriptions.getBest().getDescription()));
    }
    nextNode=getNextNodeToExpand();
    int horizExp=nextNode.getHorizontalExpansion();
    Monitor mon=MonitorFactory.start(""String_Node_Str"");
    TreeSet<Description> refinements=refineNode(nextNode);
    mon.stop();
    while (refinements.size() != 0) {
      Description refinement=refinements.pollFirst();
      int length=refinement.getLength();
      if (length > horizExp && refinement.getDepth() <= maxDepth) {
        Monitor mon2=MonitorFactory.start(""String_Node_Str"");
        addNode(refinement,nextNode);
        mon2.stop();
        if (terminationCriteriaSatisfied()) {
          break;
        }
      }
    }
    updateMinMaxHorizExp(nextNode);
    loop++;
  }
  if (stop) {
    logger.info(""String_Node_Str"" + expressionTests + ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
  }
 else {
    logger.info(""String_Node_Str"" + expressionTests + ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
  }
  if (singleSuggestionMode) {
    bestEvaluatedDescriptions.add(bestDescription,bestAccuracy,learningProblem);
  }
  logger.info(""String_Node_Str"" + getSolutionString());
  isRunning=false;
}","@Override public void start(){
  stop=false;
  isRunning=true;
  reset();
  nanoStartTime=System.nanoTime();
  double highestAccuracy=0.0;
  OENode nextNode;
  addNode(startClass,null);
  int loop=0;
  while (!terminationCriteriaSatisfied()) {
    if (!singleSuggestionMode && bestEvaluatedDescriptions.getBestAccuracy() > highestAccuracy) {
      highestAccuracy=bestEvaluatedDescriptions.getBestAccuracy();
      logger.info(""String_Node_Str"" + dfPercent.format(highestAccuracy) + ""String_Node_Str""+ descriptionToString(bestEvaluatedDescriptions.getBest().getDescription()));
    }
    nextNode=getNextNodeToExpand();
    int horizExp=nextNode.getHorizontalExpansion();
    Monitor mon=MonitorFactory.start(""String_Node_Str"");
    TreeSet<Description> refinements=refineNode(nextNode);
    mon.stop();
    while (refinements.size() != 0) {
      Description refinement=refinements.pollFirst();
      int length=refinement.getLength();
      if (length > horizExp && refinement.getDepth() <= maxDepth) {
        Monitor mon2=MonitorFactory.start(""String_Node_Str"");
        addNode(refinement,nextNode);
        mon2.stop();
        if (terminationCriteriaSatisfied()) {
          break;
        }
      }
    }
    updateMinMaxHorizExp(nextNode);
    if (configurator.getWriteSearchTree()) {
      String treeString=""String_Node_Str"" + bestEvaluatedDescriptions.getBest() + ""String_Node_Str"";
      if (refinements.size() > 1) {
        treeString+=""String_Node_Str"";
        for (        Description n : refinements) {
          treeString+=""String_Node_Str"" + n + ""String_Node_Str"";
        }
      }
      treeString+=startNode.toTreeString(baseURI);
      treeString+=""String_Node_Str"";
      if (configurator.getReplaceSearchTree())       Files.createFile(new File(configurator.getSearchTreeFile()),treeString);
 else       Files.appendFile(new File(configurator.getSearchTreeFile()),treeString);
    }
    loop++;
  }
  if (stop) {
    logger.info(""String_Node_Str"" + expressionTests + ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
  }
 else {
    logger.info(""String_Node_Str"" + expressionTests + ""String_Node_Str""+ nodes.size()+ ""String_Node_Str"");
  }
  if (singleSuggestionMode) {
    bestEvaluatedDescriptions.add(bestDescription,bestAccuracy,learningProblem);
  }
  logger.info(""String_Node_Str"" + getSolutionString());
  isRunning=false;
}"
9762,"public static Collection<ConfigOption<?>> createConfigOptions(){
  Collection<ConfigOption<?>> options=new LinkedList<ConfigOption<?>>();
  options.add(CommonConfigOptions.useAllConstructor());
  options.add(CommonConfigOptions.useExistsConstructor());
  options.add(CommonConfigOptions.useHasValueConstructor());
  options.add(CommonConfigOptions.useDataHasValueConstructor());
  options.add(CommonConfigOptions.valueFreqencyThreshold());
  options.add(CommonConfigOptions.useCardinalityRestrictions());
  options.add(CommonConfigOptions.cardinalityLimit());
  options.add(CommonConfigOptions.useNegation(false));
  options.add(CommonConfigOptions.useBooleanDatatypes());
  options.add(CommonConfigOptions.useDoubleDatatypes());
  options.add(CommonConfigOptions.maxExecutionTimeInSeconds(10));
  options.add(CommonConfigOptions.getNoisePercentage());
  options.add(CommonConfigOptions.getMaxDepth(7));
  options.add(CommonConfigOptions.maxNrOfResults(10));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  options.add(CommonConfigOptions.getInstanceBasedDisjoints());
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  return options;
}","public static Collection<ConfigOption<?>> createConfigOptions(){
  Collection<ConfigOption<?>> options=new LinkedList<ConfigOption<?>>();
  options.add(CommonConfigOptions.useAllConstructor());
  options.add(CommonConfigOptions.useExistsConstructor());
  options.add(CommonConfigOptions.useHasValueConstructor());
  options.add(CommonConfigOptions.useDataHasValueConstructor());
  options.add(CommonConfigOptions.valueFreqencyThreshold());
  options.add(CommonConfigOptions.useCardinalityRestrictions());
  options.add(CommonConfigOptions.cardinalityLimit());
  options.add(CommonConfigOptions.useNegation(false));
  options.add(CommonConfigOptions.useBooleanDatatypes());
  options.add(CommonConfigOptions.useDoubleDatatypes());
  options.add(CommonConfigOptions.maxExecutionTimeInSeconds(10));
  options.add(CommonConfigOptions.getNoisePercentage());
  options.add(CommonConfigOptions.getMaxDepth(7));
  options.add(CommonConfigOptions.maxNrOfResults(10));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  options.add(CommonConfigOptions.getInstanceBasedDisjoints());
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  options.add(new StringConfigOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  return options;
}"
9763,"public static ReasonerComponent getTestOntology(TestOntology ont){
  String kbString=""String_Node_Str"";
  String owlFile=""String_Node_Str"";
  if (ont.equals(TestOntology.EMPTY)) {
  }
 else   if (ont.equals(TestOntology.SIMPLE)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE_NO_DR)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE_NO_DISJOINT)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE_NO_DR_DISJOINT)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE2)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE3)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.R1SUBR2)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.DATA1)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.FIVE_ROLES)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.RHO1)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.FATHER)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.FATHER_OE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.CARCINOGENESIS)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.EPC_OE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.KRK_ZERO_ONE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.DBPEDIA_OWL)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.TRAINS_OWL)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SWORE)) {
    owlFile=""String_Node_Str"";
  }
  try {
    ComponentManager cm=ComponentManager.getInstance();
    KnowledgeSource source;
    if (!kbString.isEmpty() || ont.equals(TestOntology.EMPTY)) {
      KB kb=KBParser.parseKBFile(kbString);
      source=new KBFile(kb);
    }
 else {
      source=cm.knowledgeSource(OWLFile.class);
      try {
        cm.applyConfigEntry(source,""String_Node_Str"",new File(owlFile).toURI().toURL());
      }
 catch (      MalformedURLException e) {
        e.printStackTrace();
      }
    }
    ReasonerComponent rc=cm.reasoner(OWLAPIReasoner.class,source);
    source.init();
    rc.init();
    return rc;
  }
 catch (  ParseException e) {
    e.printStackTrace();
  }
catch (  ComponentInitException e) {
    e.printStackTrace();
  }
  throw new Error(""String_Node_Str"");
}","public static ReasonerComponent getTestOntology(TestOntology ont){
  String kbString=""String_Node_Str"";
  String owlFile=""String_Node_Str"";
  if (ont.equals(TestOntology.EMPTY)) {
  }
 else   if (ont.equals(TestOntology.SIMPLE)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE_NO_DR)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE_NO_DISJOINT)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE_NO_DR_DISJOINT)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE2)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE3)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.R1SUBR2)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.DATA1)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.FIVE_ROLES)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.RHO1)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.FATHER)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.FATHER_OE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.CARCINOGENESIS)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.EPC_OE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.KRK_ZERO_ONE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.DBPEDIA_OWL)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.TRAINS_OWL)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SWORE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.MDM)) {
    owlFile=""String_Node_Str"";
  }
  try {
    ComponentManager cm=ComponentManager.getInstance();
    KnowledgeSource source;
    if (!kbString.isEmpty() || ont.equals(TestOntology.EMPTY)) {
      KB kb=KBParser.parseKBFile(kbString);
      source=new KBFile(kb);
    }
 else {
      source=cm.knowledgeSource(OWLFile.class);
      try {
        cm.applyConfigEntry(source,""String_Node_Str"",new File(owlFile).toURI().toURL());
      }
 catch (      MalformedURLException e) {
        e.printStackTrace();
      }
    }
    ReasonerComponent rc=cm.reasoner(OWLAPIReasoner.class,source);
    source.init();
    rc.init();
    return rc;
  }
 catch (  ParseException e) {
    e.printStackTrace();
  }
catch (  ComponentInitException e) {
    e.printStackTrace();
  }
  throw new Error(""String_Node_Str"");
}"
9764,"@Override public SortedSet<Individual> getIndividualsImpl(Description concept){
  OWLClassExpression d=OWLAPIDescriptionConvertVisitor.getOWLClassExpression(concept);
  Set<OWLNamedIndividual> individuals=reasoner.getInstances(d,false).getFlattened();
  SortedSet<Individual> inds=new TreeSet<Individual>();
  for (  OWLNamedIndividual ind : individuals)   inds.add(new Individual(ind.toStringID()));
  return inds;
}","@Override public SortedSet<Individual> getIndividualsImpl(Description concept){
  OWLClassExpression d=OWLAPIDescriptionConvertVisitor.getOWLClassExpression(concept);
  Set<OWLNamedIndividual> individuals=reasoner.getInstances(d,false).getFlattened();
  SortedSet<Individual> inds=new TreeSet<Individual>();
  for (  OWLNamedIndividual ind : individuals)   if (ind != null)   inds.add(new Individual(ind.toStringID()));
  return inds;
}"
9765,"public SuggestionsTable(OWLEditorKit editorKit){
  super(new SuggestionsTableModel());
  progressRenderer=new ProgressBarTableCellRenderer();
  progressRenderer.setBackground(getBackground());
  getColumn(0).setCellRenderer(progressRenderer);
  owlRenderer=new OWLCellRenderer(editorKit,false,false);
  owlRenderer.setHighlightKeywords(true);
  owlRenderer.setHighlightUnsatisfiableClasses(false);
  owlRenderer.setHighlightUnsatisfiableProperties(false);
  owlRenderer.setWrap(false);
  getColumn(2).setCellRenderer(owlRenderer);
  setColumnSizes();
}","public SuggestionsTable(OWLEditorKit editorKit){
  super(new SuggestionsTableModel());
  progressRenderer=new ProgressBarTableCellRenderer();
  progressRenderer.setBackground(getBackground());
  getColumn(0).setCellRenderer(progressRenderer);
  owlRenderer=new OWLCellRenderer(editorKit,false,false);
  owlRenderer.setHighlightKeywords(true);
  owlRenderer.setHighlightUnsatisfiableClasses(false);
  owlRenderer.setHighlightUnsatisfiableProperties(false);
  owlRenderer.setWrap(false);
  getColumn(2).setCellRenderer(owlRenderer);
  setColumnSizes();
  Comparator<Integer> comparator=new Comparator<Integer>(){
    @Override public int compare(    Integer o1,    Integer o2){
      return o1.compareTo(o2);
    }
  }
;
  getColumnExt(0).setComparator(comparator);
}"
9766,"@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  stringDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      try {
        if (source instanceof OWLAPIOntology) {
          ontology=((OWLAPIOntology)source).getOWLOntolgy();
        }
 else         if (source instanceof SparqlKnowledgeSource) {
          ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
        }
 else {
          ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url.toURI()));
        }
        owlAPIOntologies.add(ontology);
        Set<OWLOntology> imports=manager.getImportsClosure(ontology);
        allImports.addAll(imports);
        for (        OWLOntology ont : imports) {
          classes.addAll(ont.getClassesInSignature());
          owlObjectProperties.addAll(ont.getObjectPropertiesInSignature());
          owlDatatypeProperties.addAll(ont.getDataPropertiesInSignature());
          owlIndividuals.addAll(ont.getIndividualsInSignature());
        }
        OWLOntologyFormat format=manager.getOntologyFormat(ontology);
        if (format instanceof PrefixOWLOntologyFormat) {
          prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
          baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
          prefixes.remove(""String_Node_Str"");
        }
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
catch (      URISyntaxException e) {
        e.printStackTrace();
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyURI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyURI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  ReasonerProgressMonitor progressMonitor=new NullReasonerProgressMonitor();
  FreshEntityPolicy freshEntityPolicy=FreshEntityPolicy.ALLOW;
  long timeOut=Integer.MAX_VALUE;
  IndividualNodeSetPolicy individualNodeSetPolicy=IndividualNodeSetPolicy.BY_NAME;
  OWLReasonerConfiguration conf=new SimpleConfiguration(progressMonitor,freshEntityPolicy,timeOut,individualNodeSetPolicy);
  if (configurator.getReasonerType().equals(""String_Node_Str"")) {
    try {
      reasoner=new FaCTPlusPlusReasonerFactory().createNonBufferingReasoner(ontology,conf);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
  }
 else {
    reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology,conf);
    Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
    pelletLogger.setLevel(Level.WARN);
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.prepareReasoner();
  }
 else {
    throw new ComponentInitException(""String_Node_Str"");
  }
  factory=manager.getOWLDataFactory();
  for (  OWLClass owlClass : classes)   atomicConcepts.add(new NamedClass(owlClass.toStringID()));
  for (  OWLObjectProperty owlProperty : owlObjectProperties)   atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
  for (  OWLDataProperty owlProperty : owlDatatypeProperties) {
    DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
    Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
    Iterator<OWLDataRange> it=ranges.iterator();
    if (it.hasNext()) {
      OWLDataRange range=it.next();
      if (range.isDatatype()) {
        URI uri=((OWLDatatype)range).getIRI().toURI();
        if (uri.equals(Datatype.BOOLEAN.getURI()))         booleanDatatypeProperties.add(dtp);
 else         if (uri.equals(Datatype.DOUBLE.getURI()))         doubleDatatypeProperties.add(dtp);
 else         if (uri.equals(Datatype.INT.getURI()))         intDatatypeProperties.add(dtp);
 else         if (uri.equals(Datatype.STRING.getURI()))         stringDatatypeProperties.add(dtp);
      }
    }
 else {
      stringDatatypeProperties.add(dtp);
    }
    datatypeProperties.add(dtp);
  }
  for (  OWLNamedIndividual owlIndividual : owlIndividuals) {
    individuals.add(new Individual(owlIndividual.toStringID()));
  }
}","@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  stringDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      try {
        if (source instanceof OWLAPIOntology) {
          ontology=((OWLAPIOntology)source).getOWLOntolgy();
        }
 else         if (source instanceof SparqlKnowledgeSource) {
          ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
          manager=ontology.getOWLOntologyManager();
        }
 else {
          ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url.toURI()));
        }
        owlAPIOntologies.add(ontology);
        Set<OWLOntology> imports=manager.getImportsClosure(ontology);
        allImports.addAll(imports);
        for (        OWLOntology ont : imports) {
          classes.addAll(ont.getClassesInSignature());
          owlObjectProperties.addAll(ont.getObjectPropertiesInSignature());
          owlDatatypeProperties.addAll(ont.getDataPropertiesInSignature());
          owlIndividuals.addAll(ont.getIndividualsInSignature());
        }
        OWLOntologyFormat format=manager.getOntologyFormat(ontology);
        if (format instanceof PrefixOWLOntologyFormat) {
          prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
          baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
          prefixes.remove(""String_Node_Str"");
        }
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
catch (      URISyntaxException e) {
        e.printStackTrace();
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyURI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyURI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  ReasonerProgressMonitor progressMonitor=new NullReasonerProgressMonitor();
  FreshEntityPolicy freshEntityPolicy=FreshEntityPolicy.ALLOW;
  long timeOut=Integer.MAX_VALUE;
  IndividualNodeSetPolicy individualNodeSetPolicy=IndividualNodeSetPolicy.BY_NAME;
  OWLReasonerConfiguration conf=new SimpleConfiguration(progressMonitor,freshEntityPolicy,timeOut,individualNodeSetPolicy);
  if (configurator.getReasonerType().equals(""String_Node_Str"")) {
    try {
      reasoner=new FaCTPlusPlusReasonerFactory().createNonBufferingReasoner(ontology,conf);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
  }
 else {
    reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology,conf);
    Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
    pelletLogger.setLevel(Level.WARN);
  }
  boolean inconsistentOntology=!reasoner.isConsistent();
  if (!inconsistentOntology) {
    reasoner.prepareReasoner();
  }
 else {
    throw new ComponentInitException(""String_Node_Str"");
  }
  factory=manager.getOWLDataFactory();
  for (  OWLClass owlClass : classes)   atomicConcepts.add(new NamedClass(owlClass.toStringID()));
  for (  OWLObjectProperty owlProperty : owlObjectProperties)   atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
  for (  OWLDataProperty owlProperty : owlDatatypeProperties) {
    DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
    Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
    Iterator<OWLDataRange> it=ranges.iterator();
    if (it.hasNext()) {
      OWLDataRange range=it.next();
      if (range.isDatatype()) {
        URI uri=((OWLDatatype)range).getIRI().toURI();
        if (uri.equals(Datatype.BOOLEAN.getURI()))         booleanDatatypeProperties.add(dtp);
 else         if (uri.equals(Datatype.DOUBLE.getURI()))         doubleDatatypeProperties.add(dtp);
 else         if (uri.equals(Datatype.INT.getURI()))         intDatatypeProperties.add(dtp);
 else         if (uri.equals(Datatype.STRING.getURI()))         stringDatatypeProperties.add(dtp);
      }
    }
 else {
      stringDatatypeProperties.add(dtp);
    }
    datatypeProperties.add(dtp);
  }
  for (  OWLNamedIndividual owlIndividual : owlIndividuals) {
    individuals.add(new Individual(owlIndividual.toStringID()));
  }
}"
9767,"@Override public Description getRangeImpl(ObjectProperty objectProperty){
  OWLObjectProperty prop=OWLAPIConverter.getOWLAPIObjectProperty(objectProperty);
  NodeSet<OWLClass> set=reasoner.getObjectPropertyRanges(prop,true);
  if (set.isEmpty())   return new Thing();
  OWLClass oc=set.iterator().next().getRepresentativeElement();
  return new NamedClass(oc.toStringID());
}","@Override public Description getRangeImpl(ObjectProperty objectProperty){
  OWLObjectProperty prop=OWLAPIConverter.getOWLAPIObjectProperty(objectProperty);
  NodeSet<OWLClass> set=reasoner.getObjectPropertyRanges(prop,true);
  if (set.isEmpty())   return new Thing();
  OWLClass oc=set.iterator().next().getRepresentativeElement();
  if (oc.isOWLThing()) {
    return Thing.instance;
  }
  return new NamedClass(oc.toStringID());
}"
9768,"@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  factory=manager.getOWLDataFactory();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  loadedOntologies=new HashSet<OWLOntology>();
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      if (source instanceof OWLAPIOntology) {
        ontology=((OWLAPIOntology)source).getOWLOntolgy();
      }
 else       if (source instanceof SparqlKnowledgeSource) {
        ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
      }
 else {
        try {
          ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url.toURI()));
        }
 catch (        OWLOntologyCreationException e) {
          e.printStackTrace();
        }
catch (        URISyntaxException e) {
          e.printStackTrace();
        }
      }
      owlAPIOntologies.add(ontology);
      Set<OWLOntology> imports=manager.getImportsClosure(ontology);
      allImports.addAll(imports);
      loadedOntologies.addAll(imports);
      classes.addAll(ontology.getClassesInSignature(true));
      owlObjectProperties.addAll(ontology.getObjectPropertiesInSignature(true));
      owlDatatypeProperties.addAll(ontology.getDataPropertiesInSignature(true));
      owlIndividuals.addAll(ontology.getIndividualsInSignature(true));
      OWLOntologyFormat format=manager.getOntologyFormat(ontology);
      if (format instanceof PrefixOWLOntologyFormat) {
        prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
        baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
        prefixes.remove(""String_Node_Str"");
      }
      for (      OWLClass owlClass : classes)       atomicConcepts.add(new NamedClass(owlClass.toStringID()));
      for (      OWLObjectProperty owlProperty : owlObjectProperties)       atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
      for (      OWLDataProperty owlProperty : owlDatatypeProperties) {
        DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
        Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
        for (        OWLDataRange range : ranges) {
          if (range.isDatatype()) {
            if (range.asOWLDatatype().isBoolean())             booleanDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isDouble())             doubleDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isInteger())             intDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isString())             stringDatatypeProperties.add(dtp);
          }
        }
        datatypeProperties.add(dtp);
      }
      for (      OWLNamedIndividual owlIndividual : owlIndividuals) {
        individuals.add(new Individual(owlIndividual.toStringID()));
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyIRI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyIRI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  PelletOptions.USE_CLASSIFICATION_MONITOR=PelletOptions.MonitorType.NONE;
  Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
  pelletLogger.setLevel(Level.WARN);
  reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology);
  classifier=PelletIncremantalReasonerFactory.getInstance().createReasoner(reasoner);
}","@Override public void init() throws ComponentInitException {
  atomicConcepts=new TreeSet<NamedClass>(conceptComparator);
  atomicRoles=new TreeSet<ObjectProperty>(roleComparator);
  datatypeProperties=new TreeSet<DatatypeProperty>();
  booleanDatatypeProperties=new TreeSet<DatatypeProperty>();
  doubleDatatypeProperties=new TreeSet<DatatypeProperty>();
  intDatatypeProperties=new TreeSet<DatatypeProperty>();
  individuals=new TreeSet<Individual>();
  manager=OWLManager.createOWLOntologyManager();
  factory=manager.getOWLDataFactory();
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getIRI().compareTo(o2.getIRI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLNamedIndividual> owlIndividuals=new TreeSet<OWLNamedIndividual>(namedObjectComparator);
  loadedOntologies=new HashSet<OWLOntology>();
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      if (source instanceof OWLAPIOntology) {
        ontology=((OWLAPIOntology)source).getOWLOntolgy();
      }
 else       if (source instanceof SparqlKnowledgeSource) {
        ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
        manager=ontology.getOWLOntologyManager();
      }
 else {
        try {
          ontology=manager.loadOntologyFromOntologyDocument(IRI.create(url.toURI()));
        }
 catch (        OWLOntologyCreationException e) {
          e.printStackTrace();
        }
catch (        URISyntaxException e) {
          e.printStackTrace();
        }
      }
      owlAPIOntologies.add(ontology);
      Set<OWLOntology> imports=manager.getImportsClosure(ontology);
      allImports.addAll(imports);
      loadedOntologies.addAll(imports);
      classes.addAll(ontology.getClassesInSignature(true));
      owlObjectProperties.addAll(ontology.getObjectPropertiesInSignature(true));
      owlDatatypeProperties.addAll(ontology.getDataPropertiesInSignature(true));
      owlIndividuals.addAll(ontology.getIndividualsInSignature(true));
      OWLOntologyFormat format=manager.getOntologyFormat(ontology);
      if (format instanceof PrefixOWLOntologyFormat) {
        prefixes.putAll(((PrefixOWLOntologyFormat)format).getPrefixName2PrefixMap());
        baseURI=((PrefixOWLOntologyFormat)format).getDefaultPrefix();
        prefixes.remove(""String_Node_Str"");
      }
      for (      OWLClass owlClass : classes)       atomicConcepts.add(new NamedClass(owlClass.toStringID()));
      for (      OWLObjectProperty owlProperty : owlObjectProperties)       atomicRoles.add(new ObjectProperty(owlProperty.toStringID()));
      for (      OWLDataProperty owlProperty : owlDatatypeProperties) {
        DatatypeProperty dtp=new DatatypeProperty(owlProperty.toStringID());
        Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
        for (        OWLDataRange range : ranges) {
          if (range.isDatatype()) {
            if (range.asOWLDatatype().isBoolean())             booleanDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isDouble())             doubleDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isInteger())             intDatatypeProperties.add(dtp);
 else             if (range.asOWLDatatype().isString())             stringDatatypeProperties.add(dtp);
          }
        }
        datatypeProperties.add(dtp);
      }
      for (      OWLNamedIndividual owlIndividual : owlIndividuals) {
        individuals.add(new Individual(owlIndividual.toStringID()));
      }
    }
 else {
      KB kb=source.toKB();
      IRI ontologyIRI=IRI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyIRI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  PelletOptions.USE_CLASSIFICATION_MONITOR=PelletOptions.MonitorType.NONE;
  Logger pelletLogger=Logger.getLogger(""String_Node_Str"");
  pelletLogger.setLevel(Level.WARN);
  reasoner=PelletReasonerFactory.getInstance().createNonBufferingReasoner(ontology);
  classifier=PelletIncremantalReasonerFactory.getInstance().createReasoner(reasoner);
}"
9769,"@Override public Description getRangeImpl(ObjectProperty objectProperty){
  OWLObjectProperty prop=OWLAPIConverter.getOWLAPIObjectProperty(objectProperty);
  NodeSet<OWLClass> set=reasoner.getObjectPropertyRanges(prop,true);
  if (set.isEmpty())   return new Thing();
  OWLClass oc=set.iterator().next().getRepresentativeElement();
  return new NamedClass(oc.toStringID());
}","@Override public Description getRangeImpl(ObjectProperty objectProperty){
  OWLObjectProperty prop=OWLAPIConverter.getOWLAPIObjectProperty(objectProperty);
  NodeSet<OWLClass> set=reasoner.getObjectPropertyRanges(prop,true);
  if (set.isEmpty())   return new Thing();
  OWLClass oc=set.iterator().next().getRepresentativeElement();
  return getDescriptionFromReturnedDomain(set);
}"
9770,"private SortedSet<Description> getNegClassCandidatesRecursive(Description index,Description lowerClass){
  SortedSet<Description> candidates=new TreeSet<Description>();
  for (  Description candidate : subHierarchy.getSuperClasses(lowerClass)) {
    if (!isDisjoint(new Negation(candidate),index)) {
      boolean meaningful;
      if (instanceBasedDisjoints) {
        SortedSet<Individual> tmp=rs.getIndividuals(lowerClass);
        tmp.removeAll(rs.getIndividuals(new Negation(candidate)));
        meaningful=tmp.size() != 0;
      }
 else {
        meaningful=!isDisjoint(candidate,index);
      }
      if (meaningful) {
        candidates.add(new Negation(candidate));
      }
 else {
        candidates.addAll(getClassCandidatesRecursive(index,candidate));
      }
    }
  }
  return candidates;
}","private SortedSet<Description> getNegClassCandidatesRecursive(Description index,Description lowerClass){
  SortedSet<Description> candidates=new TreeSet<Description>(conceptComparator);
  for (  Description candidate : subHierarchy.getSuperClasses(lowerClass)) {
    if (!isDisjoint(new Negation(candidate),index)) {
      boolean meaningful;
      if (instanceBasedDisjoints) {
        SortedSet<Individual> tmp=rs.getIndividuals(lowerClass);
        tmp.removeAll(rs.getIndividuals(new Negation(candidate)));
        meaningful=tmp.size() != 0;
      }
 else {
        meaningful=!isDisjoint(candidate,index);
      }
      if (meaningful) {
        candidates.add(new Negation(candidate));
      }
 else {
        candidates.addAll(getClassCandidatesRecursive(index,candidate));
      }
    }
  }
  return candidates;
}"
9771,"public static void main(String[] args) throws ComponentInitException, MalformedURLException {
  Map<String,Integer> ontologyRelClassCountMap=new HashMap<String,Integer>();
  Set<String> inconsistentOntologies=new HashSet<String>();
  Hashtable<String,Integer> incohaerentOntologies=new Hashtable<String,Integer>();
  File file=new File(args[0]);
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  PelletReasoner reasoner;
  OWLOntology ontology;
  Set<OWLOntology> ontologies=new HashSet<OWLOntology>();
  StringBuffer sb=new StringBuffer();
  StringBuffer sb2=new StringBuffer();
  String url=null;
  try {
    BufferedReader in=new BufferedReader(new FileReader(file));
    sb2.append(""String_Node_Str"");
    int count=1;
    while ((url=in.readLine()) != null) {
      try {
        System.out.println(count++ + ""String_Node_Str"" + url);
        ontology=manager.loadOntology(IRI.create(url));
        ontologies.add(ontology);
        ontologies.addAll(manager.getImportsClosure(ontology));
        reasoner=new PelletReasonerFactory().createReasoner(ontology);
        sb.append(url + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + ontology.getLogicalAxiomCount() + ""String_Node_Str"");
        sb2.append(ontology.getLogicalAxiomCount() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + ontology.getClassesInSignature(true).size() + ""String_Node_Str"");
        sb2.append(ontology.getClassesInSignature(true).size() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + ontology.getObjectPropertiesInSignature(true).size() + ""String_Node_Str"");
        sb2.append(ontology.getObjectPropertiesInSignature(true).size() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + ontology.getDataPropertiesInSignature(true).size() + ""String_Node_Str"");
        sb2.append(ontology.getDataPropertiesInSignature(true).size() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + ontology.getIndividualsInSignature(true).size() + ""String_Node_Str"");
        sb2.append(url + ""String_Node_Str"");
        if (reasoner.isConsistent()) {
          long startTime=System.currentTimeMillis();
          reasoner.prepareReasoner();
          sb.append(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
          int unsatCount=reasoner.getUnsatisfiableClasses().getEntitiesMinusBottom().size();
          sb.append(""String_Node_Str"" + unsatCount + ""String_Node_Str"");
          if (unsatCount > 0) {
            incohaerentOntologies.put(url,Integer.valueOf(unsatCount));
          }
          int classCount=0;
          StringBuffer tmp=new StringBuffer();
          if (ontology.getIndividualsInSignature(true).size() > 0) {
            for (            OWLClass cl : ontology.getClassesInSignature(true)) {
              Set<OWLNamedIndividual> inds=reasoner.getInstances(cl,false).getFlattened();
              if (inds.size() >= minInstanceCount) {
                classCount++;
                tmp.append(""String_Node_Str"" + cl.getIRI() + ""String_Node_Str"");
                if (displayInstances) {
                  int indCount=0;
                  for (                  OWLIndividual ind : inds) {
                    tmp.append(""String_Node_Str"" + ind.toString() + ""String_Node_Str"");
                    indCount++;
                    if (indCount >= maxInstances) {
                      tmp.append(""String_Node_Str"" + inds.size() + ""String_Node_Str"");
                      break;
                    }
                  }
                }
              }
            }
          }
          sb.append(""String_Node_Str"" + minInstanceCount + ""String_Node_Str""+ classCount+ ""String_Node_Str"");
          if (displayClasses) {
            sb.append(tmp);
          }
          ontologyRelClassCountMap.put(url,classCount);
        }
 else {
          inconsistentOntologies.add(url);
          sb.append(""String_Node_Str"");
        }
        sb.append(""String_Node_Str"");
        sb2.append(""String_Node_Str"");
        reasoner.dispose();
        manager.removeOntology(ontology);
        ontologies.clear();
        System.out.println(inconsistentOntologies.size() + ""String_Node_Str"");
        int cnt=1;
        for (        String uri : inconsistentOntologies) {
          System.out.println(uri);
        }
        System.out.println();
        System.out.println(incohaerentOntologies.size() + ""String_Node_Str"");
        cnt=1;
        for (        Entry<String,Integer> ent : incohaerentOntologies.entrySet()) {
          System.out.println(cnt++ + ""String_Node_Str"" + ent.getKey()+ ""String_Node_Str""+ ent.getValue()+ ""String_Node_Str"");
        }
        System.out.println();
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  System.out.println(sb.toString());
  System.out.println(sb2.toString());
  for (  Entry<String,Integer> ent : ontologyRelClassCountMap.entrySet()) {
    System.out.println(ent.getValue() + ""String_Node_Str"" + ent.getKey());
  }
  System.out.println(""String_Node_Str"");
  for (  String uri : inconsistentOntologies) {
    System.out.println(uri);
  }
  System.out.println(""String_Node_Str"");
  for (  Entry<String,Integer> ent : incohaerentOntologies.entrySet()) {
    System.out.println(ent.getKey() + ""String_Node_Str"" + ent.getValue()+ ""String_Node_Str"");
  }
}","public static void main(String[] args) throws ComponentInitException, MalformedURLException {
  Map<String,Integer> ontologyRelClassCountMap=new HashMap<String,Integer>();
  Set<String> inconsistentOntologies=new HashSet<String>();
  Hashtable<String,Integer> incohaerentOntologies=new Hashtable<String,Integer>();
  File file=new File(args[0]);
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  PelletReasoner reasoner;
  OWLOntology ontology;
  Set<OWLOntology> ontologies=new HashSet<OWLOntology>();
  StringBuffer sb=new StringBuffer();
  StringBuffer sb2=new StringBuffer();
  String url=null;
  try {
    BufferedReader in=new BufferedReader(new FileReader(file));
    sb2.append(""String_Node_Str"");
    int count=1;
    while ((url=in.readLine()) != null) {
      try {
        System.out.println(count++ + ""String_Node_Str"" + url);
        ontology=manager.loadOntology(IRI.create(url));
        ontologies.add(ontology);
        ontologies.addAll(manager.getImportsClosure(ontology));
        reasoner=new PelletReasonerFactory().createReasoner(ontology);
        sb.append(url + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + ontology.getLogicalAxiomCount() + ""String_Node_Str"");
        sb2.append(ontology.getLogicalAxiomCount() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + ontology.getClassesInSignature(true).size() + ""String_Node_Str"");
        sb2.append(ontology.getClassesInSignature(true).size() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + ontology.getObjectPropertiesInSignature(true).size() + ""String_Node_Str"");
        sb2.append(ontology.getObjectPropertiesInSignature(true).size() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + ontology.getDataPropertiesInSignature(true).size() + ""String_Node_Str"");
        sb2.append(ontology.getDataPropertiesInSignature(true).size() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + ontology.getIndividualsInSignature(true).size() + ""String_Node_Str"");
        sb2.append(url + ""String_Node_Str"");
        if (reasoner.isConsistent()) {
          long startTime=System.currentTimeMillis();
          reasoner.prepareReasoner();
          sb.append(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
          int unsatCount=reasoner.getUnsatisfiableClasses().getEntitiesMinusBottom().size();
          sb.append(""String_Node_Str"" + unsatCount + ""String_Node_Str"");
          if (unsatCount > 0) {
            incohaerentOntologies.put(url,Integer.valueOf(unsatCount));
          }
          int classCount=0;
          StringBuffer tmp=new StringBuffer();
          if (ontology.getIndividualsInSignature(true).size() > 0) {
            for (            OWLClass cl : ontology.getClassesInSignature(true)) {
              Set<OWLNamedIndividual> inds=reasoner.getInstances(cl,false).getFlattened();
              if (inds.size() >= minInstanceCount) {
                classCount++;
                tmp.append(""String_Node_Str"" + cl.getIRI() + ""String_Node_Str"");
                if (displayInstances) {
                  int indCount=0;
                  for (                  OWLIndividual ind : inds) {
                    tmp.append(""String_Node_Str"" + ind.toString() + ""String_Node_Str"");
                    indCount++;
                    if (indCount >= maxInstances) {
                      tmp.append(""String_Node_Str"" + inds.size() + ""String_Node_Str"");
                      break;
                    }
                  }
                }
              }
            }
          }
          sb.append(""String_Node_Str"" + minInstanceCount + ""String_Node_Str""+ classCount+ ""String_Node_Str"");
          if (displayClasses) {
            sb.append(tmp);
          }
          ontologyRelClassCountMap.put(url,classCount);
        }
 else {
          inconsistentOntologies.add(url);
          sb.append(""String_Node_Str"");
        }
        sb.append(""String_Node_Str"");
        sb2.append(""String_Node_Str"");
        reasoner.dispose();
        manager.removeOntology(ontology);
        ontologies.clear();
        System.out.println(inconsistentOntologies.size() + ""String_Node_Str"");
        int cnt=1;
        for (        String uri : inconsistentOntologies) {
          System.out.println(cnt++ + ""String_Node_Str"" + uri);
        }
        System.out.println();
        System.out.println(incohaerentOntologies.size() + ""String_Node_Str"");
        cnt=1;
        for (        Entry<String,Integer> ent : incohaerentOntologies.entrySet()) {
          System.out.println(cnt++ + ""String_Node_Str"" + ent.getKey()+ ""String_Node_Str""+ ent.getValue()+ ""String_Node_Str"");
        }
        System.out.println();
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  System.out.println(sb.toString());
  System.out.println(sb2.toString());
  for (  Entry<String,Integer> ent : ontologyRelClassCountMap.entrySet()) {
    System.out.println(ent.getValue() + ""String_Node_Str"" + ent.getKey());
  }
  System.out.println(""String_Node_Str"");
  for (  String uri : inconsistentOntologies) {
    System.out.println(uri);
  }
  System.out.println(""String_Node_Str"");
  for (  Entry<String,Integer> ent : incohaerentOntologies.entrySet()) {
    System.out.println(ent.getKey() + ""String_Node_Str"" + ent.getValue()+ ""String_Node_Str"");
  }
}"
9772,"/** 
 * Used for testing the Sparql Query converter.
 * @param args
 */
public static void main(String[] args){
  try {
    SortedSet<String> s=new TreeSet<String>();
    HashMap<String,String> result=new HashMap<String,String>();
    HashMap<String,String> subclassMap=new HashMap<String,String>();
    subclassMap.put(""String_Node_Str"",""String_Node_Str"");
    String conj=""String_Node_Str"";
    s.add(""String_Node_Str"");
    s.add(""String_Node_Str"");
    s.add(""String_Node_Str"" + conj);
    s.add(""String_Node_Str"");
    s.add(""String_Node_Str"");
    s.add(""String_Node_Str"");
    s.add(conj);
    s.add(""String_Node_Str"");
    s.add(""String_Node_Str"");
    s.add(""String_Node_Str"");
    s.clear();
    String prefix=""String_Node_Str"";
    String test=""String_Node_Str"";
    ObjectProperty stp=new ObjectProperty(prefix + ""String_Node_Str"");
    DatatypeProperty dtp=new DatatypeProperty(prefix + ""String_Node_Str"");
    StringValueRestriction svr=new StringValueRestriction(dtp,""String_Node_Str"");
    Intersection inner=new Intersection(new NamedClass(prefix + ""String_Node_Str""),svr);
    Intersection middle=new Intersection(new ObjectSomeRestriction(stp,new NamedClass(prefix + ""String_Node_Str"")),new ObjectSomeRestriction(stp,inner));
    Intersection outer=new Intersection(new NamedClass(prefix + ""String_Node_Str""),middle);
    System.out.println(outer.toKBSyntaxString(null,null));
    System.out.println(test);
    Map<String,Set<String>> testMap=new HashMap<String,Set<String>>();
    testMap.put(prefix + ""String_Node_Str"",new HashSet<String>(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str""})));
    SparqlQueryDescriptionConvertVisitor testVisitor=new SparqlQueryDescriptionConvertVisitor();
    testVisitor.setSubclassMap(testMap);
    String q=testVisitor.getSparqlQuery(outer.toKBSyntaxString());
    System.out.println(q);
    if (true) {
      System.exit(0);
    }
    String query=""String_Node_Str"";
    SparqlQueryDescriptionConvertVisitor visit=new SparqlQueryDescriptionConvertVisitor();
    visit.setLabels(false);
    visit.setDistinct(false);
    for (    String kbsyntax : s) {
      query=visit.getSparqlQuery(kbsyntax);
      result.put(kbsyntax,query);
    }
    System.out.println(""String_Node_Str"");
    for (    String string : result.keySet()) {
      System.out.println(""String_Node_Str"" + string);
      System.out.println(""String_Node_Str"" + result.get(string));
      System.out.println(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  ParseException e) {
    e.printStackTrace();
  }
}","/** 
 * Used for testing the Sparql Query converter.
 * @param args
 */
public static void main(String[] args){
  SparqlQueryConverter.test();
  try {
    SortedSet<String> s=new TreeSet<String>();
    HashMap<String,String> result=new HashMap<String,String>();
    HashMap<String,String> subclassMap=new HashMap<String,String>();
    subclassMap.put(""String_Node_Str"",""String_Node_Str"");
    String conj=""String_Node_Str"";
    s.add(""String_Node_Str"");
    s.add(""String_Node_Str"");
    s.add(""String_Node_Str"" + conj);
    s.add(""String_Node_Str"");
    s.add(""String_Node_Str"");
    s.add(""String_Node_Str"");
    s.add(conj);
    s.add(""String_Node_Str"");
    s.add(""String_Node_Str"");
    s.add(""String_Node_Str"");
    s.clear();
    String prefix=""String_Node_Str"";
    String test=""String_Node_Str"";
    ObjectProperty stp=new ObjectProperty(prefix + ""String_Node_Str"");
    DatatypeProperty dtp=new DatatypeProperty(prefix + ""String_Node_Str"");
    StringValueRestriction svr=new StringValueRestriction(dtp,""String_Node_Str"");
    Intersection inner=new Intersection(new NamedClass(prefix + ""String_Node_Str""),svr);
    Intersection middle=new Intersection(new ObjectSomeRestriction(stp,new NamedClass(prefix + ""String_Node_Str"")),new ObjectSomeRestriction(stp,inner));
    Intersection outer=new Intersection(new NamedClass(prefix + ""String_Node_Str""),middle);
    System.out.println(outer.toKBSyntaxString(null,null));
    System.out.println(test);
    Map<String,Set<String>> testMap=new HashMap<String,Set<String>>();
    testMap.put(prefix + ""String_Node_Str"",new HashSet<String>(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str""})));
    SparqlQueryDescriptionConvertVisitor testVisitor=new SparqlQueryDescriptionConvertVisitor();
    testVisitor.setSubclassMap(testMap);
    String q=testVisitor.getSparqlQuery(outer.toKBSyntaxString());
    System.out.println(q);
    if (true) {
      System.exit(0);
    }
    String query=""String_Node_Str"";
    SparqlQueryDescriptionConvertVisitor visit=new SparqlQueryDescriptionConvertVisitor();
    visit.setLabels(false);
    visit.setDistinct(false);
    for (    String kbsyntax : s) {
      query=visit.getSparqlQuery(kbsyntax);
      result.put(kbsyntax,query);
    }
    System.out.println(""String_Node_Str"");
    for (    String string : result.keySet()) {
      System.out.println(""String_Node_Str"" + string);
      System.out.println(""String_Node_Str"" + result.get(string));
      System.out.println(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  ParseException e) {
    e.printStackTrace();
  }
}"
9773,"private void computeM(NamedClass nc){
  long mComputationTimeStartNs=System.nanoTime();
  mA.put(nc,new TreeMap<Integer,SortedSet<Description>>());
  for (int i=1; i <= mMaxLength; i++) {
    mA.get(nc).put(i,new TreeSet<Description>(conceptComparator));
  }
  SortedSet<Description> m1=subHierarchy.getSubClasses(nc);
  mA.get(nc).put(1,m1);
  SortedSet<Description> m2=new TreeSet<Description>(conceptComparator);
  if (useNegation) {
    SortedSet<Description> m2tmp=subHierarchy.getSuperClasses(new Nothing());
    for (    Description c : m2tmp) {
      if (!(c instanceof Thing)) {
        NamedClass a=(NamedClass)c;
        if (!isNotADisjoint(a,nc) && isNotAMeaningful(a,nc))         m2.add(new Negation(a));
      }
    }
  }
  computeMg(nc);
  if (useBooleanDatatypes) {
    Set<DatatypeProperty> booleanDPs=mgbd.get(nc);
    for (    DatatypeProperty dp : booleanDPs) {
      m2.add(new BooleanValueRestriction(dp,true));
      m2.add(new BooleanValueRestriction(dp,false));
    }
  }
  mA.get(nc).put(2,m2);
  SortedSet<Description> m3=new TreeSet<Description>(conceptComparator);
  if (useExistsConstructor) {
    for (    ObjectProperty r : mgr.get(nc)) {
      m3.add(new ObjectSomeRestriction(r,new Thing()));
    }
  }
  if (useAllConstructor) {
    for (    ObjectProperty r : mgr.get(nc)) {
      m3.add(new ObjectAllRestriction(r,new Thing()));
    }
  }
  if (useDoubleDatatypes) {
    Set<DatatypeProperty> doubleDPs=mgdd.get(nc);
    for (    DatatypeProperty dp : doubleDPs) {
      if (splits.get(dp).size() > 0) {
        DoubleMaxValue max=new DoubleMaxValue(splits.get(dp).get(splits.get(dp).size() - 1));
        DoubleMinValue min=new DoubleMinValue(splits.get(dp).get(0));
        m3.add(new DatatypeSomeRestriction(dp,max));
        m3.add(new DatatypeSomeRestriction(dp,min));
      }
    }
  }
  if (useDataHasValueConstructor) {
    Set<DatatypeProperty> stringDPs=mgsd.get(nc);
    for (    DatatypeProperty dp : stringDPs) {
      Set<Constant> freqValues=frequentDataValues.get(dp);
      for (      Constant c : freqValues) {
        m3.add(new StringValueRestriction(dp,c.getLiteral()));
      }
    }
  }
  mA.get(nc).put(3,m3);
  SortedSet<Description> m4=new TreeSet<Description>(conceptComparator);
  if (useCardinalityRestrictions) {
    for (    ObjectProperty r : mgr.get(nc)) {
      int maxFillers=maxNrOfFillers.get(r);
      if (maxFillers > 0)       m4.add(new ObjectMaxCardinalityRestriction(maxFillers - 1,r,new Thing()));
    }
  }
  mA.get(nc).put(4,m4);
  mComputationTimeNs+=System.nanoTime() - mComputationTimeStartNs;
}","private void computeM(NamedClass nc){
  long mComputationTimeStartNs=System.nanoTime();
  mA.put(nc,new TreeMap<Integer,SortedSet<Description>>());
  for (int i=1; i <= mMaxLength; i++) {
    mA.get(nc).put(i,new TreeSet<Description>(conceptComparator));
  }
  SortedSet<Description> m1=getClassCandidates(nc);
  mA.get(nc).put(1,m1);
  SortedSet<Description> m2=getNegClassCandidates(nc);
  mA.get(nc).put(2,m2);
  computeMg(nc);
  if (useBooleanDatatypes) {
    Set<DatatypeProperty> booleanDPs=mgbd.get(nc);
    for (    DatatypeProperty dp : booleanDPs) {
      m2.add(new BooleanValueRestriction(dp,true));
      m2.add(new BooleanValueRestriction(dp,false));
    }
  }
  mA.get(nc).put(2,m2);
  SortedSet<Description> m3=new TreeSet<Description>(conceptComparator);
  if (useExistsConstructor) {
    for (    ObjectProperty r : mgr.get(nc)) {
      m3.add(new ObjectSomeRestriction(r,new Thing()));
    }
  }
  if (useAllConstructor) {
    for (    ObjectProperty r : mgr.get(nc)) {
      m3.add(new ObjectAllRestriction(r,new Thing()));
    }
  }
  if (useDoubleDatatypes) {
    Set<DatatypeProperty> doubleDPs=mgdd.get(nc);
    for (    DatatypeProperty dp : doubleDPs) {
      if (splits.get(dp).size() > 0) {
        DoubleMaxValue max=new DoubleMaxValue(splits.get(dp).get(splits.get(dp).size() - 1));
        DoubleMinValue min=new DoubleMinValue(splits.get(dp).get(0));
        m3.add(new DatatypeSomeRestriction(dp,max));
        m3.add(new DatatypeSomeRestriction(dp,min));
      }
    }
  }
  if (useDataHasValueConstructor) {
    Set<DatatypeProperty> stringDPs=mgsd.get(nc);
    for (    DatatypeProperty dp : stringDPs) {
      Set<Constant> freqValues=frequentDataValues.get(dp);
      for (      Constant c : freqValues) {
        m3.add(new StringValueRestriction(dp,c.getLiteral()));
      }
    }
  }
  mA.get(nc).put(3,m3);
  SortedSet<Description> m4=new TreeSet<Description>(conceptComparator);
  if (useCardinalityRestrictions) {
    for (    ObjectProperty r : mgr.get(nc)) {
      int maxFillers=maxNrOfFillers.get(r);
      if (maxFillers > 0)       m4.add(new ObjectMaxCardinalityRestriction(maxFillers - 1,r,new Thing()));
    }
  }
  mA.get(nc).put(4,m4);
  mComputationTimeNs+=System.nanoTime() - mComputationTimeStartNs;
}"
9774,"public void removeSelection(OWLAxiom ax){
  selectedAxioms.remove(ax);
  fireImpactListChanged();
}","public void removeSelection(OWLAxiom ax){
  if (selectedAxioms.remove(ax)) {
    fireImpactListChanged();
  }
}"
9775,"public LaconicExplanationGenerator(OWLOntologyManager manager,OWLReasonerFactory reasonerFactory,Set<OWLOntology> ontologies){
  this.manager=manager;
  try {
    ontology=manager.createOntology(URI.create(new StringBuilder().append(""String_Node_Str"").append(System.nanoTime()).toString()),ontologies,true);
  }
 catch (  OWLOntologyCreationException e) {
    e.printStackTrace();
  }
catch (  OWLOntologyChangeException e) {
    e.printStackTrace();
  }
  oPlus=new OPlus(manager.getOWLDataFactory());
  pelletExplanation=new PelletExplanationGenerator(manager,ontologies);
  lastRegularExplanations=new HashSet<Explanation>();
}","public LaconicExplanationGenerator(OWLOntologyManager manager){
  this.manager=manager;
  oPlus=new OPlus(manager.getOWLDataFactory());
  lastRegularExplanations=new HashSet<Explanation>();
}"
9776,"@Override public void setValueAt(Object value,int rowIndex,int columnIndex){
  if (columnIndex == 4) {
    OWLAxiom ax=getOWLAxiomAtRow(rowIndex);
    if (impMan.isSelected(ax)) {
      impMan.removeSelection(ax);
      if (!ont.containsAxiom(ax)) {
        List<OWLOntologyChange> changes=new ArrayList<OWLOntologyChange>();
        for (        OWLAxiom source : expMan.getSourceAxioms(ax)) {
          impMan.removeSelection(source);
          changes.add(new RemoveAxiom(ont,source));
          for (          OWLAxiom remain : expMan.getRemainingAxioms(source,ax)) {
            changes.add(new AddAxiom(ont,remain));
          }
        }
        repMan.removeFromRepairPlan(changes);
      }
 else {
        repMan.removeFromRepairPlan(new RemoveAxiom(ont,ax));
      }
    }
 else {
      if (!OREManager.getInstance().isSourceOWLAxiom(ax)) {
        RemainingAxiomsDialog dialog=new RemainingAxiomsDialog(ax,ont);
        int ret=dialog.showDialog();
        if (ret == RemainingAxiomsDialog.OK_RETURN_CODE) {
          impMan.addSelection(ax);
          List<OWLOntologyChange> changes=dialog.getChanges();
          for (          OWLAxiom source : expMan.getLaconicSourceAxioms(ax)) {
            if (repMan.isScheduled2Add(source)) {
              changes.add(new RemoveAxiom(ont,source));
            }
          }
          repMan.addToRepairPlan(changes);
        }
      }
 else {
        impMan.addSelection(ax);
        repMan.addToRepairPlan(new RemoveAxiom(ont,ax));
      }
    }
  }
  super.setValueAt(value,rowIndex,columnIndex);
}","@Override public void setValueAt(Object value,int rowIndex,int columnIndex){
  if (columnIndex == 4) {
    OWLAxiom ax=getOWLAxiomAtRow(rowIndex);
    if (impMan.isSelected(ax)) {
      impMan.removeSelection(ax);
      if (!ont.containsAxiom(ax)) {
        List<OWLOntologyChange> changes=new ArrayList<OWLOntologyChange>();
        for (        OWLAxiom source : expMan.getSourceAxioms(ax)) {
          impMan.removeSelection(source);
          changes.add(new RemoveAxiom(ont,source));
          for (          OWLAxiom remain : expMan.getRemainingAxioms(source,ax)) {
            changes.add(new AddAxiom(ont,remain));
          }
        }
        repMan.removeFromRepairPlan(changes);
      }
 else {
        repMan.removeFromRepairPlan(new RemoveAxiom(ont,ax));
      }
    }
 else {
      if (!OREManager.getInstance().isSourceOWLAxiom(ax)) {
        RemainingAxiomsDialog dialog=new RemainingAxiomsDialog(ax,ont);
        int ret=dialog.showDialog();
        if (ret == RemainingAxiomsDialog.OK_RETURN_CODE) {
          impMan.addSelection(ax);
          List<OWLOntologyChange> changes=dialog.getChanges();
          for (          OWLAxiom source : expMan.getSourceAxioms(ax)) {
            if (repMan.isScheduled2Add(source)) {
              changes.add(new RemoveAxiom(ont,source));
            }
          }
          repMan.addToRepairPlan(changes);
        }
      }
 else {
        impMan.addSelection(ax);
        repMan.addToRepairPlan(new RemoveAxiom(ont,ax));
      }
    }
  }
  super.setValueAt(value,rowIndex,columnIndex);
}"
9777,"public RepairTable(){
  super(new RepairTableModel());
  setBackground(Color.WHITE);
  setShowHorizontalLines(true);
  setGridColor(Color.LIGHT_GRAY);
  setTableHeader(null);
  getColumn(0).setMaxWidth(30);
  getColumn(1).setCellRenderer(new TextAreaRenderer());
  getColumn(2).setMaxWidth(40);
  getColumn(2).setCellRenderer(new TableCellRenderer(){
    @Override public Component getTableCellRendererComponent(    JTable arg0,    Object arg1,    boolean arg2,    boolean arg3,    int arg4,    int arg5){
      return new JLabel(deleteIcon);
    }
  }
);
  addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      handleKeyPressed(e);
    }
  }
);
  addMouseMotionListener(new MouseAdapter(){
    final RepairTable table;
{
      table=RepairTable.this;
    }
    public void mouseMoved(    MouseEvent e){
      int row=rowAtPoint(e.getPoint());
      int column=columnAtPoint(e.getPoint());
      if (column == 2 && row <= table.getRowCount() && row >= 0) {
        setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
      }
 else {
        setCursor(null);
      }
    }
  }
);
  addMouseListener(new MouseAdapter(){
    final RepairTable table;
{
      table=RepairTable.this;
    }
    public void mouseClicked(    MouseEvent e){
      int row=rowAtPoint(e.getPoint());
      int column=columnAtPoint(e.getPoint());
      if (row >= 0 && row <= table.getRowCount() && column == 2) {
        OWLOntologyChange change=((RepairTableModel)getModel()).getChangeAt(row);
        if (ImpactManager.getInstance(OREManager.getInstance()).isSelected(change.getAxiom())) {
          ImpactManager.getInstance(OREManager.getInstance()).removeSelection(change.getAxiom());
        }
        RepairManager.getInstance(OREManager.getInstance()).removeFromRepairPlan(change);
        setCursor(null);
      }
    }
  }
);
}","public RepairTable(){
  super(new RepairTableModel());
  setBackground(Color.WHITE);
  setShowHorizontalLines(true);
  setGridColor(Color.LIGHT_GRAY);
  setTableHeader(null);
  getColumn(0).setMaxWidth(30);
  getColumn(1).setCellRenderer(new TextAreaRenderer());
  getColumn(2).setMaxWidth(40);
  getColumn(2).setCellRenderer(new TableCellRenderer(){
    @Override public Component getTableCellRendererComponent(    JTable arg0,    Object arg1,    boolean arg2,    boolean arg3,    int arg4,    int arg5){
      return new JLabel(deleteIcon);
    }
  }
);
  addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      handleKeyPressed(e);
    }
  }
);
  addMouseMotionListener(new MouseAdapter(){
    final RepairTable table;
{
      table=RepairTable.this;
    }
    public void mouseMoved(    MouseEvent e){
      int row=rowAtPoint(e.getPoint());
      int column=columnAtPoint(e.getPoint());
      if (column == 2 && row <= table.getRowCount() && row >= 0) {
        setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
      }
 else {
        setCursor(null);
      }
    }
  }
);
  addMouseListener(new MouseAdapter(){
    final RepairTable table;
{
      table=RepairTable.this;
    }
    public void mouseClicked(    MouseEvent e){
      int row=rowAtPoint(e.getPoint());
      int column=columnAtPoint(e.getPoint());
      if (row >= 0 && row <= table.getRowCount() && column == 2) {
        OWLOntologyChange change=((RepairTableModel)getModel()).getChangeAt(row);
        handleRemoveChange(change);
        setCursor(null);
      }
    }
  }
);
}"
9778,"private void handleKeyPressed(KeyEvent e){
  int selRow=getSelectedRow();
  OWLOntologyChange change=((RepairTableModel)getModel()).getChangeAt(selRow);
  if (e.getKeyCode() == KeyEvent.VK_DELETE) {
    RepairManager.getInstance(OREManager.getInstance()).removeFromRepairPlan(change);
    if (ImpactManager.getInstance(OREManager.getInstance()).isSelected(change.getAxiom())) {
      ImpactManager.getInstance(OREManager.getInstance()).removeSelection(change.getAxiom());
    }
  }
  getSelectionModel().clearSelection();
}","private void handleKeyPressed(KeyEvent e){
  int selRow=getSelectedRow();
  OWLOntologyChange change=((RepairTableModel)getModel()).getChangeAt(selRow);
  if (e.getKeyCode() == KeyEvent.VK_DELETE) {
    handleRemoveChange(change);
  }
  getSelectionModel().clearSelection();
}"
9779,"public void mouseClicked(MouseEvent e){
  int row=rowAtPoint(e.getPoint());
  int column=columnAtPoint(e.getPoint());
  if (row >= 0 && row <= table.getRowCount() && column == 2) {
    OWLOntologyChange change=((RepairTableModel)getModel()).getChangeAt(row);
    if (ImpactManager.getInstance(OREManager.getInstance()).isSelected(change.getAxiom())) {
      ImpactManager.getInstance(OREManager.getInstance()).removeSelection(change.getAxiom());
    }
    RepairManager.getInstance(OREManager.getInstance()).removeFromRepairPlan(change);
    setCursor(null);
  }
}","public void mouseClicked(MouseEvent e){
  int row=rowAtPoint(e.getPoint());
  int column=columnAtPoint(e.getPoint());
  if (row >= 0 && row <= table.getRowCount() && column == 2) {
    OWLOntologyChange change=((RepairTableModel)getModel()).getChangeAt(row);
    handleRemoveChange(change);
    setCursor(null);
  }
}"
9780,"/** 
 * Initializes the panel. 
 */
public void init(){
  prefixes=OREManager.getInstance().getPrefixes();
  baseURI=OREManager.getInstance().getBaseURI();
  newIcon=new ImageIcon(""String_Node_Str"");
  setLayout(new GridLayout());
  setBackground(Color.WHITE);
  setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
  UIManager.put(""String_Node_Str"",Color.GRAY);
  UIManager.put(""String_Node_Str"",Color.GRAY);
  container=new JXTaskPaneContainer();
  container.setBackground(Color.WHITE);
  indPane=new JXTaskPane();
  indPane.setTitle(""String_Node_Str"");
  indPane.add(new JLabel(ind.toManchesterSyntaxString(baseURI,prefixes)));
  classPane=new JXTaskPane();
  classPane.setTitle(""String_Node_Str"");
  oldClasses=OREManager.getInstance().getReasoner().getTypes(ind);
  for (  NamedClass nc : oldClasses) {
    classPane.add(new JLabel(nc.toManchesterSyntaxString(baseURI,prefixes)));
  }
  propertyPane=new JXTaskPane();
  propertyPane.setTitle(""String_Node_Str"");
  oldProperties=modifier.getObjectProperties(ind);
  oldPropMap=new HashMap<String,Set<String>>();
  for (  ObjectPropertyAssertion ob : oldProperties) {
    String role=ob.getRole().toString(baseURI,prefixes);
    String ind=ob.getIndividual2().toManchesterSyntaxString(baseURI,prefixes);
    if (oldPropMap.containsKey(role)) {
      Set<String> oldSet=oldPropMap.get(role);
      oldSet.add(ind);
      oldPropMap.put(role,oldSet);
    }
 else {
      Set<String> newSet=new HashSet<String>();
      newSet.add(ind);
      oldPropMap.put(role,newSet);
    }
  }
  for (  String key : oldPropMap.keySet()) {
    JXTaskPane actionPane=new JXTaskPane();
    actionPane.setTitle(key);
    actionPane.setSpecial(true);
    Set<String> value=(Set<String>)oldPropMap.get(key);
    for (    String i : value) {
      actionPane.add(new JLabel(i));
    }
    propertyPane.add(actionPane);
  }
  container.add(indPane);
  container.add(classPane);
  container.add(propertyPane);
  add(container);
}","/** 
 * Initializes the panel. 
 */
public void init(){
  prefixes=OREManager.getInstance().getPrefixes();
  baseURI=OREManager.getInstance().getBaseURI();
  setLayout(new GridLayout());
  setBackground(Color.WHITE);
  setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
  UIManager.put(""String_Node_Str"",Color.GRAY);
  UIManager.put(""String_Node_Str"",Color.GRAY);
  container=new JXTaskPaneContainer();
  container.setBackground(Color.WHITE);
  indPane=new JXTaskPane();
  indPane.setTitle(""String_Node_Str"");
  indPane.add(new JLabel(ind.toManchesterSyntaxString(baseURI,prefixes)));
  classPane=new JXTaskPane();
  classPane.setTitle(""String_Node_Str"");
  oldClasses=OREManager.getInstance().getReasoner().getTypes(ind);
  for (  NamedClass nc : oldClasses) {
    classPane.add(new JLabel(nc.toManchesterSyntaxString(baseURI,prefixes)));
  }
  propertyPane=new JXTaskPane();
  propertyPane.setTitle(""String_Node_Str"");
  oldProperties=modifier.getObjectProperties(ind);
  oldPropMap=new HashMap<String,Set<String>>();
  for (  ObjectPropertyAssertion ob : oldProperties) {
    String role=ob.getRole().toString(baseURI,prefixes);
    String ind=ob.getIndividual2().toManchesterSyntaxString(baseURI,prefixes);
    if (oldPropMap.containsKey(role)) {
      Set<String> oldSet=oldPropMap.get(role);
      oldSet.add(ind);
      oldPropMap.put(role,oldSet);
    }
 else {
      Set<String> newSet=new HashSet<String>();
      newSet.add(ind);
      oldPropMap.put(role,newSet);
    }
  }
  for (  String key : oldPropMap.keySet()) {
    JXTaskPane actionPane=new JXTaskPane();
    actionPane.setTitle(key);
    actionPane.setSpecial(true);
    Set<String> value=(Set<String>)oldPropMap.get(key);
    for (    String i : value) {
      actionPane.add(new JLabel(i));
    }
    propertyPane.add(actionPane);
  }
  container.add(indPane);
  container.add(classPane);
  container.add(propertyPane);
  add(container);
}"
9781,"private TreeSet<DatatypeProperty> getFirstDatatypeProperties(Set<Set<OWLDataProperty>> setOfSets){
  TreeSet<DatatypeProperty> roles=new TreeSet<DatatypeProperty>(roleComparator);
  for (  Set<OWLDataProperty> innerSet : setOfSets) {
    OWLDataProperty property=innerSet.iterator().next();
    roles.add(new DatatypeProperty(property.getURI().toString()));
  }
  return roles;
}","private TreeSet<DatatypeProperty> getFirstDatatypeProperties(Set<Set<OWLDataProperty>> setOfSets){
  TreeSet<DatatypeProperty> roles=new TreeSet<DatatypeProperty>(roleComparator);
  for (  Set<OWLDataProperty> innerSet : setOfSets) {
    OWLDataProperty property=innerSet.iterator().next();
    roles.add(new DatatypeProperty(property.getURI().toString()));
  }
  roles.remove(new DatatypeProperty(""String_Node_Str""));
  roles.remove(new DatatypeProperty(""String_Node_Str""));
  return roles;
}"
9782,"private TreeSet<ObjectProperty> getFirstObjectProperties(Set<Set<OWLObjectProperty>> setOfSets){
  TreeSet<ObjectProperty> roles=new TreeSet<ObjectProperty>(roleComparator);
  for (  Set<OWLObjectProperty> innerSet : setOfSets) {
    OWLObjectProperty property=innerSet.iterator().next();
    roles.add(new ObjectProperty(property.getURI().toString()));
  }
  return roles;
}","private TreeSet<ObjectProperty> getFirstObjectProperties(Set<Set<OWLObjectProperty>> setOfSets){
  TreeSet<ObjectProperty> roles=new TreeSet<ObjectProperty>(roleComparator);
  for (  Set<OWLObjectProperty> innerSet : setOfSets) {
    OWLObjectProperty property=innerSet.iterator().next();
    roles.add(new ObjectProperty(property.getURI().toString()));
  }
  roles.remove(new ObjectProperty(""String_Node_Str""));
  roles.remove(new ObjectProperty(""String_Node_Str""));
  return roles;
}"
9783,"public static void main(String[] args) throws ComponentInitException, MalformedURLException {
  Map<String,Integer> ontologyRelClassCountMap=new HashMap<String,Integer>();
  File file=new File(args[0]);
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  Reasoner reasoner=new Reasoner(manager);
  OWLOntology ontology;
  Set<OWLOntology> ontologies=new HashSet<OWLOntology>();
  StringBuffer sb=new StringBuffer();
  StringBuffer sb2=new StringBuffer();
  String url=null;
  try {
    BufferedReader in=new BufferedReader(new FileReader(file));
    sb2.append(""String_Node_Str"");
    while ((url=in.readLine()) != null) {
      try {
        System.out.println(url);
        ontology=manager.loadOntology(URI.create(url));
        ontologies.add(ontology);
        ontologies.addAll(manager.getImportsClosure(ontology));
        reasoner.loadOntologies(ontologies);
        sb.append(url + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + ontology.getLogicalAxiomCount() + ""String_Node_Str"");
        sb2.append(ontology.getLogicalAxiomCount() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + reasoner.getClasses().size() + ""String_Node_Str"");
        sb2.append(ontology.getReferencedClasses().size() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + reasoner.getObjectProperties().size() + ""String_Node_Str"");
        sb2.append(ontology.getReferencedObjectProperties().size() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + reasoner.getDataProperties().size() + ""String_Node_Str"");
        sb2.append(ontology.getReferencedDataProperties().size() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + reasoner.getIndividuals().size() + ""String_Node_Str"");
        sb2.append(url + ""String_Node_Str"");
        reasoner.setOntology(ontology);
        if (reasoner.isConsistent()) {
          long startTime=System.currentTimeMillis();
          reasoner.classify();
          sb.append(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
          sb.append(""String_Node_Str"" + reasoner.getInconsistentClasses().size() + ""String_Node_Str"");
          int classCount=0;
          StringBuffer tmp=new StringBuffer();
          if (reasoner.getIndividuals().size() > 0) {
            for (            OWLClass cl : reasoner.getClasses()) {
              Set<OWLIndividual> inds=reasoner.getIndividuals(cl,false);
              if (inds.size() >= minInstanceCount) {
                classCount++;
                tmp.append(""String_Node_Str"" + cl.getURI() + ""String_Node_Str"");
                if (displayInstances) {
                  for (                  OWLIndividual ind : inds) {
                    tmp.append(""String_Node_Str"" + ind.toString() + ""String_Node_Str"");
                  }
                }
              }
            }
          }
          sb.append(""String_Node_Str"" + minInstanceCount + ""String_Node_Str""+ classCount+ ""String_Node_Str"");
          if (displayClasses) {
            sb.append(tmp);
          }
          ontologyRelClassCountMap.put(url,classCount);
        }
 else {
          sb.append(""String_Node_Str"");
        }
        sb.append(""String_Node_Str"");
        sb2.append(""String_Node_Str"");
        reasoner.unloadOntologies(ontologies);
        manager.removeOntology(URI.create(url));
        ontologies.clear();
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  System.out.println(sb.toString());
  for (  Entry<String,Integer> ent : ontologyRelClassCountMap.entrySet()) {
    System.out.println(ent.getValue() + ""String_Node_Str"" + ent.getKey());
  }
}","public static void main(String[] args) throws ComponentInitException, MalformedURLException {
  Map<String,Integer> ontologyRelClassCountMap=new HashMap<String,Integer>();
  File file=new File(args[0]);
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  Reasoner reasoner=new Reasoner(manager);
  OWLOntology ontology;
  Set<OWLOntology> ontologies=new HashSet<OWLOntology>();
  StringBuffer sb=new StringBuffer();
  StringBuffer sb2=new StringBuffer();
  String url=null;
  try {
    BufferedReader in=new BufferedReader(new FileReader(file));
    sb2.append(""String_Node_Str"");
    while ((url=in.readLine()) != null) {
      try {
        System.out.println(url);
        ontology=manager.loadOntology(URI.create(url));
        ontologies.add(ontology);
        ontologies.addAll(manager.getImportsClosure(ontology));
        reasoner.loadOntologies(ontologies);
        sb.append(url + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + ontology.getLogicalAxiomCount() + ""String_Node_Str"");
        sb2.append(ontology.getLogicalAxiomCount() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + reasoner.getClasses().size() + ""String_Node_Str"");
        sb2.append(ontology.getReferencedClasses().size() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + reasoner.getObjectProperties().size() + ""String_Node_Str"");
        sb2.append(ontology.getReferencedObjectProperties().size() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + reasoner.getDataProperties().size() + ""String_Node_Str"");
        sb2.append(ontology.getReferencedDataProperties().size() + ""String_Node_Str"");
        sb.append(""String_Node_Str"" + reasoner.getIndividuals().size() + ""String_Node_Str"");
        sb2.append(url + ""String_Node_Str"");
        reasoner.setOntology(ontology);
        if (reasoner.isConsistent()) {
          long startTime=System.currentTimeMillis();
          reasoner.classify();
          sb.append(""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str"");
          sb.append(""String_Node_Str"" + reasoner.getInconsistentClasses().size() + ""String_Node_Str"");
          int classCount=0;
          StringBuffer tmp=new StringBuffer();
          if (reasoner.getIndividuals().size() > 0) {
            for (            OWLClass cl : reasoner.getClasses()) {
              Set<OWLIndividual> inds=reasoner.getIndividuals(cl,false);
              if (inds.size() >= minInstanceCount) {
                classCount++;
                tmp.append(""String_Node_Str"" + cl.getURI() + ""String_Node_Str"");
                if (displayInstances) {
                  int indCount=0;
                  for (                  OWLIndividual ind : inds) {
                    tmp.append(""String_Node_Str"" + ind.toString() + ""String_Node_Str"");
                    indCount++;
                    if (indCount >= maxInstances) {
                      tmp.append(""String_Node_Str"" + inds.size() + ""String_Node_Str"");
                      break;
                    }
                  }
                }
              }
            }
          }
          sb.append(""String_Node_Str"" + minInstanceCount + ""String_Node_Str""+ classCount+ ""String_Node_Str"");
          if (displayClasses) {
            sb.append(tmp);
          }
          ontologyRelClassCountMap.put(url,classCount);
        }
 else {
          sb.append(""String_Node_Str"");
        }
        sb.append(""String_Node_Str"");
        sb2.append(""String_Node_Str"");
        reasoner.unloadOntologies(ontologies);
        manager.removeOntology(URI.create(url));
        ontologies.clear();
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  System.out.println(sb.toString());
  for (  Entry<String,Integer> ent : ontologyRelClassCountMap.entrySet()) {
    System.out.println(ent.getValue() + ""String_Node_Str"" + ent.getKey());
  }
}"
9784,"@Test public void rhoDownTestPellet(){
  Logger.getRootLogger().setLevel(Level.TRACE);
  ReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.FATHER);
  RhoDRDown rho=new RhoDRDown(rs);
  NamedClass nc=new NamedClass(""String_Node_Str"");
  Set<Description> refinements=rho.refine(nc,5);
  for (  Description refinement : refinements) {
    System.out.println(refinement);
  }
  assertTrue(refinements.size() == 8);
}","@Test public void rhoDownTestPellet(){
  Logger.getRootLogger().setLevel(Level.TRACE);
  ReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.FATHER);
  RhoDRDown rho=new RhoDRDown(rs);
  NamedClass nc=new NamedClass(""String_Node_Str"");
  Set<Description> refinements=rho.refine(nc,5);
  for (  Description refinement : refinements) {
    System.out.println(refinement);
  }
  System.out.println(rs.getObjectPropertyHierarchy());
  assertTrue(refinements.size() == 8);
}"
9785,"public ObjectPropertyHierarchy(Set<ObjectProperty> atomicRoles,TreeMap<ObjectProperty,SortedSet<ObjectProperty>> roleHierarchyUp,TreeMap<ObjectProperty,SortedSet<ObjectProperty>> roleHierarchyDown){
  this.roleHierarchyUp=roleHierarchyUp;
  this.roleHierarchyDown=roleHierarchyDown;
  for (  ObjectProperty role : atomicRoles) {
    if (getMoreGeneralRoles(role).size() == 0)     mostGeneralRoles.add(role);
    if (getMoreSpecialRoles(role).size() == 0)     mostSpecialRoles.add(role);
  }
}","public ObjectPropertyHierarchy(Set<ObjectProperty> atomicRoles,TreeMap<ObjectProperty,SortedSet<ObjectProperty>> roleHierarchyUp,TreeMap<ObjectProperty,SortedSet<ObjectProperty>> roleHierarchyDown){
  this.roleHierarchyUp=roleHierarchyUp;
  this.roleHierarchyDown=roleHierarchyDown;
  for (  ObjectProperty role : atomicRoles) {
    SortedSet<ObjectProperty> moreGen=getMoreGeneralRoles(role);
    SortedSet<ObjectProperty> moreSpec=getMoreSpecialRoles(role);
    if (moreGen.size() == 0 || (moreGen.size() == 1 && moreGen.first().equals(topRole)))     mostGeneralRoles.add(role);
    if (moreSpec.size() == 0 || (moreSpec.size() == 1 && moreSpec.first().equals(botRole)))     mostSpecialRoles.add(role);
  }
}"
9786,"@Test public void rhoDownTestPellet(){
  Logger.getRootLogger().setLevel(Level.TRACE);
  ReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.FATHER);
  RhoDRDown rho=new RhoDRDown(rs);
  NamedClass nc=new NamedClass(""String_Node_Str"");
  Set<Description> refinements=rho.refine(nc,5);
  for (  Description refinement : refinements) {
    System.out.println(refinement);
  }
  System.out.println(rs);
  assertTrue(refinements.size() == 8);
}","@Test public void rhoDownTestPellet(){
  Logger.getRootLogger().setLevel(Level.TRACE);
  ReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.FATHER);
  RhoDRDown rho=new RhoDRDown(rs);
  NamedClass nc=new NamedClass(""String_Node_Str"");
  Set<Description> refinements=rho.refine(nc,5);
  for (  Description refinement : refinements) {
    System.out.println(refinement);
  }
  assertTrue(refinements.size() == 8);
}"
9787,"/** 
 * main method.
 * @param args possible is to use URI as parameter
 */
public static void main(String[] args){
  try {
    UIManager.put(""String_Node_Str"",""String_Node_Str"");
    UIManager.put(""String_Node_Str"",""String_Node_Str"");
    UIManager.setLookAndFeel(new PlasticLookAndFeel());
    UIDefaults def=UIManager.getLookAndFeelDefaults();
    Vector<?> vec=new Vector<Object>(def.keySet());
    Collections.sort(vec,new Comparator<Object>(){
      public int compare(      Object arg0,      Object arg1){
        return arg0.toString().compareTo(arg1.toString());
      }
    }
);
    for (    Object obj : vec) {
      if (obj.toString().endsWith(""String_Node_Str"")) {
        FontUIResource fur=(FontUIResource)UIManager.get(obj);
        Font f=new Font(""String_Node_Str"",Font.PLAIN,fur.getSize());
        UIManager.put(obj,new FontUIResource(f));
      }
    }
  }
 catch (  UnsupportedLookAndFeelException e) {
    e.printStackTrace();
  }
  Locale.setDefault(Locale.ENGLISH);
  final Wizard wizard=new Wizard();
  wizard.getDialog().setTitle(""String_Node_Str"");
  Dimension dim=java.awt.Toolkit.getDefaultToolkit().getScreenSize();
  wizard.getDialog().setSize(dim);
  WizardPanelDescriptor descriptor1=new IntroductionPanelDescriptor();
  wizard.registerWizardPanel(IntroductionPanelDescriptor.IDENTIFIER,descriptor1);
  WizardPanelDescriptor descriptor2=new KnowledgeSourcePanelDescriptor();
  wizard.registerWizardPanel(KnowledgeSourcePanelDescriptor.IDENTIFIER,descriptor2);
  WizardPanelDescriptor descriptor5=new ClassChoosePanelDescriptor();
  wizard.registerWizardPanel(ClassChoosePanelDescriptor.IDENTIFIER,descriptor5);
  wizard.registerWizardPanel(UnsatisfiableExplanationPanelDescriptor.IDENTIFIER,new UnsatisfiableExplanationPanelDescriptor());
  WizardPanelDescriptor descriptor9=new AutoLearnPanelDescriptor();
  wizard.registerWizardPanel(AutoLearnPanelDescriptor.IDENTIFIER,descriptor9);
  WizardPanelDescriptor descriptor6=new ManualLearnPanelDescriptor();
  wizard.registerWizardPanel(ManualLearnPanelDescriptor.IDENTIFIER,descriptor6);
  WizardPanelDescriptor descriptor7=new RepairPanelDescriptor();
  wizard.registerWizardPanel(RepairPanelDescriptor.IDENTIFIER,descriptor7);
  WizardPanelDescriptor descriptor8=new SavePanelDescriptor();
  wizard.registerWizardPanel(SavePanelDescriptor.IDENTIFIER,descriptor8);
  if (!(args.length == 1)) {
    wizard.setCurrentPanel(IntroductionPanelDescriptor.IDENTIFIER);
  }
 else {
    wizard.setCurrentPanel(KnowledgeSourcePanelDescriptor.IDENTIFIER);
    wizard.setLeftPanel(1);
    ((KnowledgeSourcePanelDescriptor)wizard.getModel().getPanelHashMap().get(KnowledgeSourcePanelDescriptor.IDENTIFIER)).loadOntology(new File(args[0]).toURI());
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      wizard.showModalDialog();
    }
  }
);
}","/** 
 * main method.
 * @param args possible is to use URI as parameter
 */
public static void main(String[] args){
  RecentManager.getInstance().load();
  try {
    UIManager.put(""String_Node_Str"",""String_Node_Str"");
    UIManager.put(""String_Node_Str"",""String_Node_Str"");
    UIManager.setLookAndFeel(new PlasticLookAndFeel());
    UIDefaults def=UIManager.getLookAndFeelDefaults();
    Vector<?> vec=new Vector<Object>(def.keySet());
    Collections.sort(vec,new Comparator<Object>(){
      public int compare(      Object arg0,      Object arg1){
        return arg0.toString().compareTo(arg1.toString());
      }
    }
);
    for (    Object obj : vec) {
      if (obj.toString().endsWith(""String_Node_Str"")) {
        FontUIResource fur=(FontUIResource)UIManager.get(obj);
        Font f=new Font(""String_Node_Str"",Font.PLAIN,fur.getSize());
        UIManager.put(obj,new FontUIResource(f));
      }
    }
  }
 catch (  UnsupportedLookAndFeelException e) {
    e.printStackTrace();
  }
  Locale.setDefault(Locale.ENGLISH);
  final Wizard wizard=new Wizard();
  wizard.getDialog().setTitle(""String_Node_Str"");
  Dimension dim=java.awt.Toolkit.getDefaultToolkit().getScreenSize();
  wizard.getDialog().setSize(dim);
  WizardPanelDescriptor descriptor1=new IntroductionPanelDescriptor();
  wizard.registerWizardPanel(IntroductionPanelDescriptor.IDENTIFIER,descriptor1);
  WizardPanelDescriptor descriptor2=new KnowledgeSourcePanelDescriptor();
  wizard.registerWizardPanel(KnowledgeSourcePanelDescriptor.IDENTIFIER,descriptor2);
  WizardPanelDescriptor descriptor5=new ClassChoosePanelDescriptor();
  wizard.registerWizardPanel(ClassChoosePanelDescriptor.IDENTIFIER,descriptor5);
  wizard.registerWizardPanel(UnsatisfiableExplanationPanelDescriptor.IDENTIFIER,new UnsatisfiableExplanationPanelDescriptor());
  WizardPanelDescriptor descriptor9=new AutoLearnPanelDescriptor();
  wizard.registerWizardPanel(AutoLearnPanelDescriptor.IDENTIFIER,descriptor9);
  WizardPanelDescriptor descriptor6=new ManualLearnPanelDescriptor();
  wizard.registerWizardPanel(ManualLearnPanelDescriptor.IDENTIFIER,descriptor6);
  WizardPanelDescriptor descriptor7=new RepairPanelDescriptor();
  wizard.registerWizardPanel(RepairPanelDescriptor.IDENTIFIER,descriptor7);
  WizardPanelDescriptor descriptor8=new SavePanelDescriptor();
  wizard.registerWizardPanel(SavePanelDescriptor.IDENTIFIER,descriptor8);
  if (!(args.length == 1)) {
    wizard.setCurrentPanel(IntroductionPanelDescriptor.IDENTIFIER);
  }
 else {
    wizard.setCurrentPanel(KnowledgeSourcePanelDescriptor.IDENTIFIER);
    wizard.setLeftPanel(1);
    ((KnowledgeSourcePanelDescriptor)wizard.getModel().getPanelHashMap().get(KnowledgeSourcePanelDescriptor.IDENTIFIER)).loadOntology(new File(args[0]).toURI());
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      wizard.showModalDialog();
    }
  }
);
}"
9788,"public RecentManager(){
  uriList=new ArrayList<URI>();
  file=new File(""String_Node_Str"");
}","public RecentManager(){
  uriList=new ArrayList<URI>();
}"
9789,"public void addResults(List<EvaluatedDescriptionClass> resultList){
  this.resultList.clear();
  this.selectionList.clear();
  this.resultList.addAll(resultList);
  for (int i=0; i < resultList.size(); i++) {
    selectionList.add(i,Boolean.FALSE);
  }
  fireTableRowsUpdated(0,this.resultList.size());
}","public void addResults(List<EvaluatedDescriptionClass> resultList){
  this.resultList.clear();
  this.selectionList.clear();
  this.resultList.addAll(resultList);
  for (int i=0; i < resultList.size(); i++) {
    selectionList.add(i,Boolean.FALSE);
  }
  fireTableDataChanged();
}"
9790,"/** 
 * Closes the dialog and sets the return code to the integer parameter.
 * @param code The return code.
 */
public void close(int code){
  returnCode=code;
  System.out.println(""String_Node_Str"");
  wizardDialog.dispose();
  System.exit(0);
}","/** 
 * Closes the dialog and sets the return code to the integer parameter.
 * @param code The return code.
 */
public void close(int code){
  RecentManager.getInstance().save();
  returnCode=code;
  System.out.println(""String_Node_Str"");
  wizardDialog.dispose();
  System.exit(0);
}"
9791,"/** 
 * This method initializes the components for the wizard dialog: it creates a JFrame as a CardLayout panel surrounded by a small amount of space on each side, as well as three buttons at the bottom.
 */
private void initComponents(){
  wizardModel.addPropertyChangeListener(this);
  wizardController=new WizardController(this);
  wizardDialog.getContentPane().setLayout(new BorderLayout());
  wizardDialog.addWindowListener(this);
  JPanel buttonPanel=new JPanel();
  JSeparator separator=new JSeparator();
  Box buttonBox=new Box(BoxLayout.X_AXIS);
  statusBar=new StatusBar2();
  cardPanel=new JPanel();
  cardPanel.setBorder(new EmptyBorder(new Insets(5,10,5,10)));
  cardLayout=new CardLayout();
  cardPanel.setLayout(cardLayout);
  backButton=new JButton();
  nextButton=new JButton();
  cancelButton=new JButton();
  backButton.setActionCommand(BACK_BUTTON_ACTION_COMMAND);
  nextButton.setActionCommand(NEXT_BUTTON_ACTION_COMMAND);
  cancelButton.setActionCommand(CANCEL_BUTTON_ACTION_COMMAND);
  backButton.addActionListener(wizardController);
  nextButton.addActionListener(wizardController);
  cancelButton.addActionListener(wizardController);
  buttonPanel.setLayout(new BorderLayout());
  buttonPanel.add(separator,BorderLayout.NORTH);
  buttonBox.setBorder(new EmptyBorder(new Insets(5,10,5,10)));
  buttonBox.add(backButton);
  buttonBox.add(Box.createHorizontalStrut(10));
  buttonBox.add(nextButton);
  buttonBox.add(Box.createHorizontalStrut(30));
  buttonBox.add(cancelButton);
  buttonPanel.add(buttonBox,java.awt.BorderLayout.EAST);
  buttonPanel.add(statusBar,BorderLayout.WEST);
  Color color=UIManager.getColor(""String_Node_Str"");
  informationsField=new JTextPane();
  informationsField.setBackground(new Color(color.getRed(),color.getGreen(),color.getBlue()));
  informationsField.setOpaque(true);
  informationsField.setEditable(false);
  wizardDialog.getContentPane().add(buttonPanel,java.awt.BorderLayout.SOUTH);
  JPanel infoMainHolder=new JPanel();
  infoMainHolder.setLayout(new BorderLayout());
  infoMainHolder.add(informationsField,BorderLayout.SOUTH);
  infoMainHolder.add(cardPanel,BorderLayout.CENTER);
  wizardDialog.getContentPane().add(infoMainHolder,java.awt.BorderLayout.CENTER);
  leftPanel=new LeftPanel(0);
  wizardDialog.getContentPane().add(leftPanel,BorderLayout.WEST);
  TaskManager.getInstance().setDialog(wizardDialog);
  TaskManager.getInstance().setStatusBar(statusBar);
  RecentManager.getInstance().deserialize();
}","/** 
 * This method initializes the components for the wizard dialog: it creates a JFrame as a CardLayout panel surrounded by a small amount of space on each side, as well as three buttons at the bottom.
 */
private void initComponents(){
  wizardModel.addPropertyChangeListener(this);
  wizardController=new WizardController(this);
  wizardDialog.getContentPane().setLayout(new BorderLayout());
  wizardDialog.addWindowListener(this);
  JPanel buttonPanel=new JPanel();
  JSeparator separator=new JSeparator();
  Box buttonBox=new Box(BoxLayout.X_AXIS);
  statusBar=new StatusBar2();
  cardPanel=new JPanel();
  cardPanel.setBorder(new EmptyBorder(new Insets(5,10,5,10)));
  cardLayout=new CardLayout();
  cardPanel.setLayout(cardLayout);
  backButton=new JButton();
  nextButton=new JButton();
  cancelButton=new JButton();
  backButton.setActionCommand(BACK_BUTTON_ACTION_COMMAND);
  nextButton.setActionCommand(NEXT_BUTTON_ACTION_COMMAND);
  cancelButton.setActionCommand(CANCEL_BUTTON_ACTION_COMMAND);
  backButton.addActionListener(wizardController);
  nextButton.addActionListener(wizardController);
  cancelButton.addActionListener(wizardController);
  buttonPanel.setLayout(new BorderLayout());
  buttonPanel.add(separator,BorderLayout.NORTH);
  buttonBox.setBorder(new EmptyBorder(new Insets(5,10,5,10)));
  buttonBox.add(backButton);
  buttonBox.add(Box.createHorizontalStrut(10));
  buttonBox.add(nextButton);
  buttonBox.add(Box.createHorizontalStrut(30));
  buttonBox.add(cancelButton);
  buttonPanel.add(buttonBox,java.awt.BorderLayout.EAST);
  buttonPanel.add(statusBar,BorderLayout.WEST);
  Color color=UIManager.getColor(""String_Node_Str"");
  informationsField=new JTextPane();
  informationsField.setBackground(new Color(color.getRed(),color.getGreen(),color.getBlue()));
  informationsField.setOpaque(true);
  informationsField.setEditable(false);
  wizardDialog.getContentPane().add(buttonPanel,java.awt.BorderLayout.SOUTH);
  JPanel infoMainHolder=new JPanel();
  infoMainHolder.setLayout(new BorderLayout());
  infoMainHolder.add(informationsField,BorderLayout.SOUTH);
  infoMainHolder.add(cardPanel,BorderLayout.CENTER);
  wizardDialog.getContentPane().add(infoMainHolder,java.awt.BorderLayout.CENTER);
  leftPanel=new LeftPanel(0);
  wizardDialog.getContentPane().add(leftPanel,BorderLayout.WEST);
  TaskManager.getInstance().setDialog(wizardDialog);
  TaskManager.getInstance().setStatusBar(statusBar);
}"
9792,"@Override public void run(){
  fillClassesList(1);
  TaskManager.getInstance().setTaskFinished();
}","@Override public void run(){
  fillClassesList(3);
  TaskManager.getInstance().setTaskFinished();
}"
9793,"@Override public void done(){
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      fillClassesList(1);
      TaskManager.getInstance().setTaskFinished();
    }
  }
);
}","@Override public void done(){
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      fillClassesList(3);
      TaskManager.getInstance().setTaskFinished();
    }
  }
);
}"
9794,"@Override public Void doInBackground(){
  getWizard().setNextFinishButtonEnabled(false);
  try {
    oreMan.initPelletReasoner();
    RecentManager.getInstance().addURI(currentURI);
    RecentManager.getInstance().serialize();
    if (oreMan.consistentOntology()) {
      oreMan.getReasoner().classify();
      oreMan.getReasoner().realise();
    }
  }
 catch (  URISyntaxException e) {
    cancel(true);
    getWizard().getDialog().setCursor(null);
    JOptionPane.showMessageDialog(getWizard().getDialog(),""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return null;
  }
catch (  OWLOntologyCreationException e) {
    cancel(true);
    getWizard().getDialog().setCursor(null);
    if (e.getClass().equals(UnparsableOntologyException.class)) {
      JOptionPane.showMessageDialog(getWizard().getDialog(),""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
 else {
      JOptionPane.showMessageDialog(getWizard().getDialog(),""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
  }
  return null;
}","@Override public Void doInBackground(){
  getWizard().setNextFinishButtonEnabled(false);
  try {
    oreMan.initPelletReasoner();
    RecentManager.getInstance().add(currentURI);
    if (oreMan.consistentOntology()) {
      oreMan.getReasoner().classify();
      oreMan.getReasoner().realise();
    }
  }
 catch (  URISyntaxException e) {
    cancel(true);
    getWizard().getDialog().setCursor(null);
    TaskManager.getInstance().setTaskFinished();
    JOptionPane.showMessageDialog(getWizard().getDialog(),""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return null;
  }
catch (  OWLOntologyCreationException e) {
    cancel(true);
    getWizard().getDialog().setCursor(null);
    TaskManager.getInstance().setTaskFinished();
    if (e.getClass().equals(UnparsableOntologyException.class)) {
      JOptionPane.showMessageDialog(getWizard().getDialog(),""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
 else {
      JOptionPane.showMessageDialog(getWizard().getDialog(),""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
  }
  return null;
}"
9795,"public void setSelectedClass(int rowIndex){
  classesTable.setSelectedClass(rowIndex);
}","public void setSelectedClass(int rowIndex){
  classesTable.setSelectedClass(rowIndex);
  String renderedClassName=OREManager.getInstance().getManchesterSyntaxRendering(classesTable.getSelectedClass(rowIndex));
  superPanel.setTitle(SUPERCLASS_PANEL_TITLE + renderedClassName);
  equivalentPanel.setTitle(EQUIVALENTCLASS_PANEL_TITLE + renderedClassName);
}"
9796,"private JComponent createSuperPanel(){
  GridBagConstraints c=new GridBagConstraints();
  superPanel=new JPanel();
  superPanel.setLayout(new GridBagLayout());
  c.weightx=1.0;
  c.weighty=1.0;
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=0;
  superClassResultsTable=new SelectableClassExpressionsTable();
  superClassResultsTable.setName(""String_Node_Str"");
  superPanel.add(new JScrollPane(superClassResultsTable),c);
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridx=1;
  c.gridy=0;
  superClassCoveragePanel=new GraphicalCoveragePanel(""String_Node_Str"");
  superPanel.add(new JScrollPane(superClassCoveragePanel),c);
  superPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  c.gridx=0;
  c.gridy=1;
  superInconsistencyLabel=new JLabel(""String_Node_Str"");
  superPanel.add(superInconsistencyLabel,c);
  return superPanel;
}","private JComponent createSuperPanel(){
  GridBagConstraints c=new GridBagConstraints();
  superPanel=new JXTitledPanel(SUPERCLASS_PANEL_TITLE);
  superPanel.getContentContainer().setLayout(new GridBagLayout());
  c.weightx=1.0;
  c.weighty=1.0;
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=0;
  superClassResultsTable=new SelectableClassExpressionsTable();
  superClassResultsTable.setName(""String_Node_Str"");
  superPanel.getContentContainer().add(new JScrollPane(superClassResultsTable),c);
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridx=1;
  c.gridy=0;
  superClassCoveragePanel=new GraphicalCoveragePanel(""String_Node_Str"");
  superPanel.getContentContainer().add(new JScrollPane(superClassCoveragePanel),c);
  c.gridx=0;
  c.gridy=1;
  superInconsistencyLabel=new JLabel(""String_Node_Str"");
  superPanel.getContentContainer().add(superInconsistencyLabel,c);
  return superPanel;
}"
9797,"private JComponent createClassesPanel(){
  classesTable=new MarkableClassesTable();
  classesTable.setBorder(null);
  JScrollPane classesScroll=new JScrollPane(classesTable);
  classesScroll.setBorder(new MatteBorder(null));
  return classesScroll;
}","private JComponent createClassesPanel(){
  JXTitledPanel classesPanel=new JXTitledPanel(""String_Node_Str"");
  classesPanel.getContentContainer().setLayout(new BorderLayout());
  classesTable=new MarkableClassesTable();
  classesTable.setBorder(null);
  JScrollPane classesScroll=new JScrollPane(classesTable);
  classesScroll.setBorder(new MatteBorder(null));
  classesPanel.getContentContainer().add(classesScroll);
  return classesPanel;
}"
9798,"private JComponent createEquivalentPanel(){
  GridBagConstraints c=new GridBagConstraints();
  equivalentPanel=new JPanel();
  equivalentPanel.setLayout(new GridBagLayout());
  c.weightx=1.0;
  c.weighty=1.0;
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=0;
  equivalentClassResultsTable=new SelectableClassExpressionsTable();
  equivalentClassResultsTable.setName(""String_Node_Str"");
  equivalentPanel.add(new JScrollPane(equivalentClassResultsTable),c);
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridx=1;
  c.gridy=0;
  equivalentClassCoveragePanel=new GraphicalCoveragePanel(""String_Node_Str"");
  equivalentPanel.add(new JScrollPane(equivalentClassCoveragePanel),c);
  equivalentPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  c.gridx=0;
  c.gridy=1;
  equivalentInconsistencyLabel=new JLabel(""String_Node_Str"");
  equivalentPanel.add(equivalentInconsistencyLabel,c);
  return equivalentPanel;
}","private JComponent createEquivalentPanel(){
  GridBagConstraints c=new GridBagConstraints();
  equivalentPanel=new JXTitledPanel(EQUIVALENTCLASS_PANEL_TITLE);
  equivalentPanel.getContentContainer().setLayout(new GridBagLayout());
  c.weightx=1.0;
  c.weighty=1.0;
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=0;
  equivalentClassResultsTable=new SelectableClassExpressionsTable();
  equivalentClassResultsTable.setName(""String_Node_Str"");
  equivalentPanel.getContentContainer().add(new JScrollPane(equivalentClassResultsTable),c);
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridx=1;
  c.gridy=0;
  equivalentClassCoveragePanel=new GraphicalCoveragePanel(""String_Node_Str"");
  equivalentPanel.getContentContainer().add(new JScrollPane(equivalentClassCoveragePanel),c);
  c.gridx=0;
  c.gridy=1;
  equivalentInconsistencyLabel=new JLabel(""String_Node_Str"");
  equivalentPanel.getContentContainer().add(equivalentInconsistencyLabel,c);
  return equivalentPanel;
}"
9799,"@Override public String toManchesterSyntaxString(String baseURI,Map<String,String> prefixes){
  return literal;
}","@Override public String toManchesterSyntaxString(String baseURI,Map<String,String> prefixes){
  if (datatype.equals(Datatype.INT) || datatype.equals(Datatype.DOUBLE)) {
    if (Double.valueOf(literal) >= 0) {
      return ""String_Node_Str"" + literal;
    }
 else {
      return ""String_Node_Str"" + literal;
    }
  }
 else   if (datatype.equals(Datatype.STRING)) {
    return ""String_Node_Str"" + literal + ""String_Node_Str"";
  }
 else {
    return ""String_Node_Str"" + literal + ""String_Node_Str""+ datatype.toManchesterSyntaxString(baseURI,prefixes);
  }
}"
9800,"@Override public String toManchesterSyntaxString(String baseURI,Map<String,String> prefixes){
  if (hasLang)   return literal + ""String_Node_Str"" + lang;
 else   return literal;
}","@Override public String toManchesterSyntaxString(String baseURI,Map<String,String> prefixes){
  if (hasLang)   return ""String_Node_Str"" + literal + ""String_Node_Str""+ lang;
 else   return ""String_Node_Str"" + literal + ""String_Node_Str"";
}"
9801,"public void updateRecentList(ActionListener aL){
  recentLinkBox.removeAll();
  openFromRecentLinks.clear();
  LinkLabel link;
  for (  final URI uri : RecentManager.getInstance().getURIs()) {
    link=new LinkLabel(uri.toString());
    link.setName(""String_Node_Str"");
    openFromRecentLinks.add(link);
    recentLinkBox.add(link);
    link.addLinkListener(aL);
  }
}","public void updateRecentList(ActionListener aL){
  if (recentLinkBox == null) {
    recentLinkBox=new Box(BoxLayout.Y_AXIS);
    recentLinkBox.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createTitledBorder(BorderFactory.createMatteBorder(1,1,1,1,Color.GRAY),""String_Node_Str"",0,0,getFont().deriveFont(Font.BOLD),Color.GRAY),BorderFactory.createEmptyBorder(20,20,20,20)));
    box.add(recentLinkBox);
  }
  recentLinkBox.removeAll();
  openFromRecentLinks.clear();
  LinkLabel link;
  for (  final URI uri : RecentManager.getInstance().getURIs()) {
    link=new LinkLabel(uri.toString());
    link.setName(""String_Node_Str"");
    openFromRecentLinks.add(link);
    recentLinkBox.add(link);
    link.addLinkListener(aL);
  }
}"
9802,"@Override public Description getCurrentlyBestDescription(){
  return getCurrentlyBestEvaluatedDescription().getDescription();
}","@Override public Description getCurrentlyBestDescription(){
  EvaluatedDescription ed=getCurrentlyBestEvaluatedDescription();
  return ed == null ? null : ed.getDescription();
}"
9803,"@Override public void buildWidgetPanel(){
  add(getLabel());
  value=config.getConfigOptionValue(component,configOption);
  if (((URLConfigOption)configOption).refersToOWLClass()) {
    comboBox=new JComboBox();
    ReasonerComponent reasoner=config.getReasoner();
    String baseURI=reasoner.getBaseURI();
    Map<String,String> prefixes=reasoner.getPrefixes();
    classes=new LinkedList<NamedClass>(reasoner.getNamedClasses());
    for (    NamedClass clazz : classes) {
      comboBox.addItem(clazz.toManchesterSyntaxString(baseURI,prefixes));
    }
    comboBox.addActionListener(this);
    NamedClass valueNc=new NamedClass(value.toString());
    comboBox.setSelectedItem(valueNc.toManchesterSyntaxString(baseURI,prefixes));
    add(comboBox);
  }
 else {
    stringField=new JTextField(35);
    if (value != null) {
      stringField.setText(value.toString());
    }
    stringField.setToolTipText(configOption.getAllowedValuesDescription());
    setButton=new JButton(""String_Node_Str"");
    setButton.addActionListener(this);
    add(stringField);
    add(setButton);
    if (((URLConfigOption)configOption).refersToFile()) {
      chooseLocalButton=new JButton(""String_Node_Str"");
      chooseLocalButton.addActionListener(this);
      add(new JLabel(""String_Node_Str""));
      add(chooseLocalButton);
    }
  }
}","@Override public void buildWidgetPanel(){
  add(getLabel());
  value=config.getConfigOptionValue(component,configOption);
  if (((URLConfigOption)configOption).refersToOWLClass()) {
    comboBox=new JComboBox();
    ReasonerComponent reasoner=config.getReasoner();
    String baseURI=reasoner.getBaseURI();
    Map<String,String> prefixes=reasoner.getPrefixes();
    classes=new LinkedList<NamedClass>(reasoner.getNamedClasses());
    for (    NamedClass clazz : classes) {
      comboBox.addItem(clazz.toManchesterSyntaxString(baseURI,prefixes));
    }
    comboBox.addActionListener(this);
    if (value == null) {
      comboBox.setSelectedIndex(0);
    }
 else {
      NamedClass valueNc=new NamedClass(value.toString());
      comboBox.setSelectedItem(valueNc.toManchesterSyntaxString(baseURI,prefixes));
    }
    add(comboBox);
  }
 else {
    stringField=new JTextField(35);
    if (value != null) {
      stringField.setText(value.toString());
    }
    stringField.setToolTipText(configOption.getAllowedValuesDescription());
    setButton=new JButton(""String_Node_Str"");
    setButton.addActionListener(this);
    add(stringField);
    add(setButton);
    if (((URLConfigOption)configOption).refersToFile()) {
      chooseLocalButton=new JButton(""String_Node_Str"");
      chooseLocalButton.addActionListener(this);
      add(new JLabel(""String_Node_Str""));
      add(chooseLocalButton);
    }
  }
}"
9804,"private void saveUserInputToFile(){
  OWLOntology activeOnt=getOWLModelManager().getActiveOntology();
  URI uri=getOWLModelManager().getOntologyPhysicalURI(activeOnt);
  String outputFile=uri.toString().substring(0,uri.toString().lastIndexOf('.') + 1) + ""String_Node_Str"";
  OutputStream fos=null;
  File file=new File(outputFile);
  try {
    fos=new FileOutputStream(file);
    ObjectOutputStream o=new ObjectOutputStream(fos);
    o.flush();
    o.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      fos.close();
    }
 catch (    Exception e) {
    }
  }
}","/** 
 * Saves the user evaluation map object to disk. The file format is 'FILENAME'.inp .
 */
private void saveUserInputToFile(){
  OWLOntology activeOnt=getOWLModelManager().getActiveOntology();
  URI uri=getOWLModelManager().getOntologyPhysicalURI(activeOnt);
  String outputFile=uri.toString().substring(0,uri.toString().lastIndexOf('.') + 1) + ""String_Node_Str"";
  OutputStream fos=null;
  File file=new File(URI.create(outputFile));
  try {
    fos=new FileOutputStream(file);
    ObjectOutputStream o=new ObjectOutputStream(fos);
    o.writeObject(userInputMap);
    o.flush();
    o.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      fos.close();
    }
 catch (    Exception e) {
    }
  }
}"
9805,"/** 
 * Create the user interface.
 */
private void createUI(){
  setLayout(new BorderLayout());
  currentClassLabel=new JLabel();
  add(currentClassLabel,BorderLayout.NORTH);
  JPanel tableHolderPanel=new JPanel(new BorderLayout());
  evaluationTable=new EvaluationTable(getOWLEditorKit());
  evaluationTable.getSelectionModel().addListSelectionListener(this);
  JScrollPane sp=new JScrollPane(evaluationTable);
  sp.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
  tableHolderPanel.add(sp);
  inconsistencyLabel=new JLabel(INCONSISTENCY_WARNING);
  inconsistencyLabel.setForeground(getBackground());
  tableHolderPanel.add(inconsistencyLabel,BorderLayout.SOUTH);
  add(tableHolderPanel);
  JPanel coverageHolderPanel=new JPanel(new BorderLayout());
  coveragePanel=new GraphicalCoveragePanel(getOWLEditorKit());
  coverageHolderPanel.add(coveragePanel);
  nextSaveButton=new JButton();
  nextSaveButton.setActionCommand(""String_Node_Str"");
  nextSaveButton.setToolTipText(""String_Node_Str"");
  nextSaveButton.setAction(new AbstractAction(""String_Node_Str""){
    /** 
 */
    private static final long serialVersionUID=6982520538511324236L;
    @Override public void actionPerformed(    ActionEvent e){
      showNextEvaluatedDescriptions();
    }
  }
);
  JPanel buttonHolderPanel=new JPanel();
  progressBar=new JProgressBar();
  progressBar.setValue(0);
  progressBar.setStringPainted(true);
  buttonHolderPanel.add(progressBar);
  buttonHolderPanel.add(nextSaveButton);
  coverageHolderPanel.add(buttonHolderPanel,BorderLayout.SOUTH);
  add(coverageHolderPanel,BorderLayout.SOUTH);
}","/** 
 * Create the user interface.
 */
private void createUI(){
  setLayout(new BorderLayout());
  currentClassLabel=new JLabel();
  add(currentClassLabel,BorderLayout.NORTH);
  JPanel tableHolderPanel=new JPanel(new BorderLayout());
  evaluationTable=new EvaluationTable(getOWLEditorKit());
  evaluationTable.getSelectionModel().addListSelectionListener(this);
  JScrollPane sp=new JScrollPane(evaluationTable);
  sp.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
  tableHolderPanel.add(sp);
  inconsistencyLabel=new JLabel(INCONSISTENCY_WARNING);
  inconsistencyLabel.setForeground(getBackground());
  tableHolderPanel.add(inconsistencyLabel,BorderLayout.SOUTH);
  add(tableHolderPanel);
  JPanel coverageHolderPanel=new JPanel(new BorderLayout());
  coveragePanel=new GraphicalCoveragePanel(getOWLEditorKit());
  coverageHolderPanel.add(coveragePanel);
  nextSaveButton=new JButton();
  nextSaveButton.setActionCommand(""String_Node_Str"");
  nextSaveButton.setToolTipText(""String_Node_Str"");
  nextSaveButton.setAction(new AbstractAction(""String_Node_Str""){
    /** 
 */
    private static final long serialVersionUID=6982520538511324236L;
    @Override public void actionPerformed(    ActionEvent e){
      traceInput(classes.get(currentClassIndex));
      showNextEvaluatedDescriptions();
    }
  }
);
  JPanel buttonHolderPanel=new JPanel();
  progressBar=new JProgressBar();
  progressBar.setValue(0);
  progressBar.setStringPainted(true);
  buttonHolderPanel.add(progressBar);
  buttonHolderPanel.add(nextSaveButton);
  coverageHolderPanel.add(buttonHolderPanel,BorderLayout.SOUTH);
  add(coverageHolderPanel,BorderLayout.SOUTH);
}"
9806,"@Override public void actionPerformed(ActionEvent arg0){
  saveUserInputToFile();
}","@Override public void actionPerformed(ActionEvent arg0){
  traceInput(classes.get(currentClassIndex - 1));
  saveUserInputToFile();
}"
9807,"/** 
 * Show the descriptions for next class to evaluate.
 */
private void showNextEvaluatedDescriptions(){
  showInconsistencyWarning(false);
  NamedClass currentClass=classes.get(currentClassIndex++);
  evaluationTable.setAllColumnsEnabled(OWLAPIDescriptionConvertVisitor.getOWLDescription(currentClass).asOWLClass().getEquivalentClasses(getOWLModelManager().getActiveOntology()).size() > 0);
  String renderedClass=getOWLModelManager().getRendering(OWLAPIDescriptionConvertVisitor.getOWLDescription(currentClass));
  currentClassLabel.setText(CURRENT_CLASS_MESSAGE + ""String_Node_Str"" + renderedClass+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + currentClass.toString());
  coveragePanel.setConcept(currentClass);
  progressBar.setValue(currentClassIndex);
  progressBar.setString(""String_Node_Str"" + currentClassIndex + ""String_Node_Str""+ classes.size());
  lastSelectedRowIndex=-1;
  OWLDescription desc=OWLAPIDescriptionConvertVisitor.getOWLDescription(currentClass);
  OWLEntity curEntity=desc.asOWLClass();
  getOWLEditorKit().getWorkspace().getOWLSelectionModel().setSelectedEntity(curEntity);
  evaluationTable.setDescriptions(getMergedDescriptions(currentClass));
  if (currentClassIndex == classes.size()) {
    nextSaveButton.setAction(new AbstractAction(""String_Node_Str""){
      /** 
 */
      private static final long serialVersionUID=8298689809521088714L;
      @Override public void actionPerformed(      ActionEvent arg0){
        saveUserInputToFile();
      }
    }
);
    nextSaveButton.setToolTipText(""String_Node_Str"");
  }
}","/** 
 * Show the descriptions for next class to evaluate.
 */
private void showNextEvaluatedDescriptions(){
  showInconsistencyWarning(false);
  NamedClass newClass=classes.get(currentClassIndex++);
  evaluationTable.setAllColumnsEnabled(OWLAPIDescriptionConvertVisitor.getOWLDescription(newClass).asOWLClass().getEquivalentClasses(getOWLModelManager().getActiveOntology()).size() > 0);
  String renderedClass=getOWLModelManager().getRendering(OWLAPIDescriptionConvertVisitor.getOWLDescription(newClass));
  currentClassLabel.setText(CURRENT_CLASS_MESSAGE + ""String_Node_Str"" + renderedClass+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + newClass.toString());
  coveragePanel.setConcept(newClass);
  progressBar.setValue(currentClassIndex);
  progressBar.setString(""String_Node_Str"" + currentClassIndex + ""String_Node_Str""+ classes.size());
  lastSelectedRowIndex=-1;
  OWLDescription desc=OWLAPIDescriptionConvertVisitor.getOWLDescription(newClass);
  OWLEntity curEntity=desc.asOWLClass();
  getOWLEditorKit().getWorkspace().getOWLSelectionModel().setSelectedEntity(curEntity);
  evaluationTable.setDescriptions(getMergedDescriptions(newClass));
  if (currentClassIndex == classes.size()) {
    nextSaveButton.setAction(new AbstractAction(""String_Node_Str""){
      /** 
 */
      private static final long serialVersionUID=8298689809521088714L;
      @Override public void actionPerformed(      ActionEvent arg0){
        traceInput(classes.get(currentClassIndex - 1));
        saveUserInputToFile();
      }
    }
);
    nextSaveButton.setToolTipText(""String_Node_Str"");
  }
}"
9808,"/** 
 * Load the computed DL-Learner results from a file, which name corresponds to the loaded owl-file.
 */
@SuppressWarnings(""String_Node_Str"") private void parseEvaluationFile(){
  OWLOntology activeOnt=getOWLModelManager().getActiveOntology();
  URI uri=getOWLModelManager().getOntologyPhysicalURI(activeOnt);
  String resultFile=uri.toString().substring(0,uri.toString().lastIndexOf('.') + 1) + ""String_Node_Str"";
  InputStream fis=null;
  try {
    fis=new FileInputStream(new File(URI.create(resultFile)));
    ObjectInputStream o=new ObjectInputStream(fis);
    owlEquivalenceStandardMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    owlEquivalenceFMeasureMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    owlEquivalencePredaccMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    owlEquivalenceJaccardMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    owlEquivalenceGenFMeasureMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    for (int i=1; i <= 5; i++) {
      o.readObject();
    }
    fastEquivalenceStandardMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    fastEquivalenceFMeasureMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    fastEquivalencePredaccMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    fastEquivalenceJaccardMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    fastEquivalenceGenFMeasureMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    for (int i=1; i <= 5; i++) {
      o.readObject();
    }
    defaultEquivalenceMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
  classes.addAll(new TreeSet<NamedClass>(owlEquivalenceStandardMap.keySet()));
  progressBar.setMaximum(classes.size());
}","/** 
 * Load the computed DL-Learner results from a file, which name corresponds to the loaded owl-file.
 */
@SuppressWarnings(""String_Node_Str"") private void parseEvaluationFile(){
  OWLOntology activeOnt=getOWLModelManager().getActiveOntology();
  URI uri=getOWLModelManager().getOntologyPhysicalURI(activeOnt);
  String resultFile=uri.toString().substring(0,uri.toString().lastIndexOf('.') + 1) + ""String_Node_Str"";
  InputStream fis=null;
  try {
    fis=new FileInputStream(new File(URI.create(resultFile)));
    ObjectInputStream o=new ObjectInputStream(fis);
    owlEquivalenceStandardMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    owlEquivalenceFMeasureMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    owlEquivalencePredaccMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    owlEquivalenceJaccardMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    owlEquivalenceGenFMeasureMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    fastEquivalenceStandardMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    fastEquivalenceFMeasureMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    fastEquivalencePredaccMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    fastEquivalenceJaccardMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    fastEquivalenceGenFMeasureMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    defaultEquivalenceMap=(HashMap<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
  classes.addAll(new TreeSet<NamedClass>(owlEquivalenceStandardMap.keySet()));
  progressBar.setMaximum(classes.size());
}"
9809,"private void setRenderers(OWLEditorKit editorKit){
  OWLCellRenderer renderer=new OWLCellRenderer(editorKit,true,false);
  renderer.setHighlightKeywords(true);
  renderer.setWrap(true);
  getColumn(0).setCellRenderer(renderer);
  for (int i=1; i < getColumnCount(); i++) {
    getColumn(i).setCellRenderer(new RadioButtonRenderer());
    getColumn(i).setCellEditor(new RadioButtonEditor());
    getColumn(i).setHeaderRenderer(new VerticalHeaderRenderer());
  }
}","private void setRenderers(OWLEditorKit editorKit){
  OWLCellRenderer renderer=new OWLCellRenderer(editorKit,false,false);
  renderer.setHighlightKeywords(true);
  renderer.setWrap(false);
  getColumn(0).setCellRenderer(renderer);
  for (int i=1; i < getColumnCount(); i++) {
    getColumn(i).setCellRenderer(new RadioButtonRenderer());
    getColumn(i).setCellEditor(new RadioButtonEditor());
    getColumn(i).setHeaderRenderer(new VerticalHeaderRenderer());
  }
}"
9810,"private String getSolutionString(){
  int current=1;
  String str=""String_Node_Str"";
  for (  EvaluatedDescription ed : bestEvaluatedDescriptions.getSet().descendingSet()) {
    if (learningProblem instanceof PosNegLPStandard) {
      str+=current + ""String_Node_Str"" + descriptionToString(ed.getDescription())+ ""String_Node_Str""+ dfPercent.format(((PosNegLPStandard)learningProblem).getPredAccuracyOrTooWeakExact(ed.getDescription(),1))+ ""String_Node_Str""+ dfPercent.format(((PosNegLPStandard)learningProblem).getFMeasureOrTooWeakExact(ed.getDescription(),1))+ ""String_Node_Str"";
    }
 else {
      str+=current + ""String_Node_Str"" + descriptionToString(ed.getDescription())+ ""String_Node_Str""+ dfPercent.format(ed.getAccuracy())+ ""String_Node_Str"";
      System.out.println(ed);
    }
    current++;
  }
  return str;
}","private String getSolutionString(){
  int current=1;
  String str=""String_Node_Str"";
  for (  EvaluatedDescription ed : bestEvaluatedDescriptions.getSet().descendingSet()) {
    if (learningProblem instanceof PosNegLPStandard) {
      str+=current + ""String_Node_Str"" + descriptionToString(ed.getDescription())+ ""String_Node_Str""+ dfPercent.format(((PosNegLPStandard)learningProblem).getPredAccuracyOrTooWeakExact(ed.getDescription(),1))+ ""String_Node_Str""+ dfPercent.format(((PosNegLPStandard)learningProblem).getFMeasureOrTooWeakExact(ed.getDescription(),1))+ ""String_Node_Str"";
    }
 else {
      str+=current + ""String_Node_Str"" + descriptionToString(ed.getDescription())+ ""String_Node_Str""+ dfPercent.format(ed.getAccuracy())+ ""String_Node_Str"";
    }
    current++;
  }
  return str;
}"
9811,"private boolean addNode(Description description,OENode parentNode){
  System.out.println(description);
  boolean nonRedundant=descriptions.add(description);
  if (!nonRedundant) {
    return false;
  }
  if (!isDescriptionAllowed(description,parentNode)) {
    return false;
  }
  double accuracy=learningProblem.getAccuracyOrTooWeak(description,noise);
  if (accuracy > 1 || (accuracy < 0 || accuracy != -1)) {
    logger.warn(""String_Node_Str"" + accuracy + ""String_Node_Str""+ description+ ""String_Node_Str"");
    System.exit(0);
  }
  expressionTests++;
  if (accuracy == -1) {
    return false;
  }
  OENode node=new OENode(parentNode,description,accuracy);
  if (parentNode == null) {
    startNode=node;
  }
 else {
    parentNode.addChild(node);
  }
  nodes.add(node);
  if (singleSuggestionMode) {
    if (accuracy > bestAccuracy) {
      bestAccuracy=accuracy;
      bestDescription=description;
      logger.info(""String_Node_Str"" + dfPercent.format(bestAccuracy) + ""String_Node_Str""+ descriptionToString(bestDescription));
    }
    return true;
  }
  boolean isCandidate=!bestEvaluatedDescriptions.isFull();
  if (!isCandidate) {
    EvaluatedDescription worst=bestEvaluatedDescriptions.getWorst();
    double accThreshold=worst.getAccuracy();
    isCandidate=(accuracy > accThreshold || (accuracy >= accThreshold && description.getLength() < worst.getDescriptionLength()));
  }
  if (isCandidate) {
    Description niceDescription=rewriteNode(node);
    ConceptTransformation.transformToOrderedForm(niceDescription,descriptionComparator);
    boolean shorterDescriptionExists=false;
    for (    EvaluatedDescription ed : bestEvaluatedDescriptions.getSet()) {
      if (Math.abs(ed.getAccuracy() - accuracy) <= 0.00001 && ConceptTransformation.isSubdescription(niceDescription,ed.getDescription())) {
        shorterDescriptionExists=true;
        break;
      }
    }
    if (!shorterDescriptionExists) {
      if (!filterFollowsFromKB || !((ClassLearningProblem)learningProblem).followsFromKB(niceDescription)) {
        bestEvaluatedDescriptions.add(niceDescription,accuracy,learningProblem);
      }
    }
  }
  return true;
}","private boolean addNode(Description description,OENode parentNode){
  boolean nonRedundant=descriptions.add(description);
  if (!nonRedundant) {
    return false;
  }
  if (!isDescriptionAllowed(description,parentNode)) {
    return false;
  }
  double accuracy=learningProblem.getAccuracyOrTooWeak(description,noise);
  if (accuracy > 1.0 || (accuracy < 0.0 && accuracy != -1)) {
    logger.warn(""String_Node_Str"" + accuracy + ""String_Node_Str""+ description+ ""String_Node_Str"");
    System.exit(0);
  }
  expressionTests++;
  if (accuracy == -1) {
    return false;
  }
  OENode node=new OENode(parentNode,description,accuracy);
  if (parentNode == null) {
    startNode=node;
  }
 else {
    parentNode.addChild(node);
  }
  nodes.add(node);
  if (singleSuggestionMode) {
    if (accuracy > bestAccuracy) {
      bestAccuracy=accuracy;
      bestDescription=description;
      logger.info(""String_Node_Str"" + dfPercent.format(bestAccuracy) + ""String_Node_Str""+ descriptionToString(bestDescription));
    }
    return true;
  }
  boolean isCandidate=!bestEvaluatedDescriptions.isFull();
  if (!isCandidate) {
    EvaluatedDescription worst=bestEvaluatedDescriptions.getWorst();
    double accThreshold=worst.getAccuracy();
    isCandidate=(accuracy > accThreshold || (accuracy >= accThreshold && description.getLength() < worst.getDescriptionLength()));
  }
  if (isCandidate) {
    Description niceDescription=rewriteNode(node);
    ConceptTransformation.transformToOrderedForm(niceDescription,descriptionComparator);
    boolean shorterDescriptionExists=false;
    for (    EvaluatedDescription ed : bestEvaluatedDescriptions.getSet()) {
      if (Math.abs(ed.getAccuracy() - accuracy) <= 0.00001 && ConceptTransformation.isSubdescription(niceDescription,ed.getDescription())) {
        shorterDescriptionExists=true;
        break;
      }
    }
    if (!shorterDescriptionExists) {
      if (!filterFollowsFromKB || !((ClassLearningProblem)learningProblem).followsFromKB(niceDescription)) {
        bestEvaluatedDescriptions.add(niceDescription,accuracy,learningProblem);
      }
    }
  }
  return true;
}"
9812,"public static Collection<ConfigOption<?>> createConfigOptions(){
  Collection<ConfigOption<?>> options=new LinkedList<ConfigOption<?>>();
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  options.add(new StringConfigOption(""String_Node_Str"",""String_Node_Str"",defaultSearchTreeFile));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  StringConfigOption heuristicOption=new StringConfigOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  heuristicOption.setAllowedValues(new String[]{""String_Node_Str"",""String_Node_Str""});
  options.add(heuristicOption);
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  DoubleConfigOption horizExp=new DoubleConfigOption(""String_Node_Str"",""String_Node_Str"",0.6);
  horizExp.setLowerLimit(0.0);
  horizExp.setUpperLimit(1.0);
  options.add(horizExp);
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(CommonConfigOptions.allowedConcepts());
  options.add(CommonConfigOptions.ignoredConcepts());
  options.add(CommonConfigOptions.allowedRoles());
  options.add(CommonConfigOptions.ignoredRoles());
  options.add(CommonConfigOptions.useAllConstructor());
  options.add(CommonConfigOptions.useExistsConstructor());
  options.add(CommonConfigOptions.useHasValueConstructor());
  options.add(CommonConfigOptions.useDataHasValueConstructor());
  options.add(CommonConfigOptions.valueFreqencyThreshold());
  options.add(CommonConfigOptions.useCardinalityRestrictions());
  options.add(CommonConfigOptions.cardinalityLimit());
  options.add(CommonConfigOptions.useNegation());
  options.add(CommonConfigOptions.useBooleanDatatypes());
  options.add(CommonConfigOptions.useDoubleDatatypes());
  options.add(CommonConfigOptions.useStringDatatypes());
  options.add(CommonConfigOptions.maxExecutionTimeInSeconds());
  options.add(CommonConfigOptions.minExecutionTimeInSeconds());
  options.add(CommonConfigOptions.guaranteeXgoodDescriptions());
  options.add(CommonConfigOptions.maxClassDescriptionTests());
  options.add(CommonConfigOptions.getLogLevel());
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",usePropernessChecksDefault));
  options.add(CommonConfigOptions.getNoisePercentage());
  options.add(CommonConfigOptions.getTerminateOnNoiseReached());
  options.add(new StringConfigOption(""String_Node_Str"",""String_Node_Str""));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str""));
  options.add(new DoubleConfigOption(""String_Node_Str"",""String_Node_Str"",1.0));
  options.add(new DoubleConfigOption(""String_Node_Str"",""String_Node_Str"",0.0));
  options.add(new IntegerConfigOption(""String_Node_Str"",""String_Node_Str"",0));
  options.add(CommonConfigOptions.getExpansionPenaltyFactor(0.02));
  options.add(CommonConfigOptions.getInstanceBasedDisjoints());
  return options;
}","public static Collection<ConfigOption<?>> createConfigOptions(){
  Collection<ConfigOption<?>> options=new LinkedList<ConfigOption<?>>();
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  options.add(new StringConfigOption(""String_Node_Str"",""String_Node_Str"",defaultSearchTreeFile));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  StringConfigOption heuristicOption=new StringConfigOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  heuristicOption.setAllowedValues(new String[]{""String_Node_Str"",""String_Node_Str""});
  options.add(heuristicOption);
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  DoubleConfigOption horizExp=new DoubleConfigOption(""String_Node_Str"",""String_Node_Str"",0.6);
  horizExp.setLowerLimit(0.0);
  horizExp.setUpperLimit(1.0);
  options.add(horizExp);
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(CommonConfigOptions.allowedConcepts());
  options.add(CommonConfigOptions.ignoredConcepts());
  options.add(CommonConfigOptions.useAllConstructor());
  options.add(CommonConfigOptions.useExistsConstructor());
  options.add(CommonConfigOptions.useHasValueConstructor());
  options.add(CommonConfigOptions.useDataHasValueConstructor());
  options.add(CommonConfigOptions.valueFreqencyThreshold());
  options.add(CommonConfigOptions.useCardinalityRestrictions());
  options.add(CommonConfigOptions.cardinalityLimit());
  options.add(CommonConfigOptions.useNegation());
  options.add(CommonConfigOptions.useBooleanDatatypes());
  options.add(CommonConfigOptions.useDoubleDatatypes());
  options.add(CommonConfigOptions.useStringDatatypes());
  options.add(CommonConfigOptions.maxExecutionTimeInSeconds());
  options.add(CommonConfigOptions.minExecutionTimeInSeconds());
  options.add(CommonConfigOptions.guaranteeXgoodDescriptions());
  options.add(CommonConfigOptions.maxClassDescriptionTests());
  options.add(CommonConfigOptions.getLogLevel());
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",usePropernessChecksDefault));
  options.add(CommonConfigOptions.getNoisePercentage());
  options.add(CommonConfigOptions.getTerminateOnNoiseReached());
  options.add(new StringConfigOption(""String_Node_Str"",""String_Node_Str""));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str""));
  options.add(new DoubleConfigOption(""String_Node_Str"",""String_Node_Str"",1.0));
  options.add(new DoubleConfigOption(""String_Node_Str"",""String_Node_Str"",0.0));
  options.add(new IntegerConfigOption(""String_Node_Str"",""String_Node_Str"",0));
  options.add(CommonConfigOptions.getExpansionPenaltyFactor(0.02));
  options.add(CommonConfigOptions.getInstanceBasedDisjoints());
  return options;
}"
9813,"/** 
 * Build a String from nanoSeconds.
 * @param nanoSeconds is type of Long and represent a time interval in ns
 * @return a string like this: 3h 10min 46s 753ms
 */
private String makeTime(Long nanoSeconds){
  if (nanoSeconds == null)   return null;
  Long hours=0L, minutes=0L, seconds=0L, millis=0L, mikros=0L, nanos=0L;
  String timeStr=""String_Node_Str"";
  nanos=nanoSeconds % 1000;
  nanoSeconds/=1000;
  mikros=nanoSeconds % 1000;
  nanoSeconds/=1000;
  millis=nanoSeconds % 1000;
  nanoSeconds/=1000;
  seconds=nanoSeconds % 60;
  nanoSeconds/=60;
  minutes=nanoSeconds % 60;
  nanoSeconds/=60;
  hours=nanoSeconds;
  if (hours > 0)   timeStr+=hours + ""String_Node_Str"";
  if (minutes > 0)   timeStr+=minutes + ""String_Node_Str"";
  if (seconds > 0)   timeStr+=seconds + ""String_Node_Str"";
  if (millis > 0)   timeStr+=millis + ""String_Node_Str"";
  if (false)   timeStr+=mikros + ""String_Node_Str"";
  if (false)   timeStr+=nanos + ""String_Node_Str"";
  return timeStr;
}","/** 
 * Build a String from nanoSeconds.
 * @param nanoSeconds is type of Long and represent a time interval in ns
 * @return a string like this: 3h 10min 46s 753ms
 */
private String makeTime(Long nanoSeconds){
  if (nanoSeconds == null)   return null;
  Long hours=0L, minutes=0L, seconds=0L, millis=0L;
  String timeStr=""String_Node_Str"";
  nanoSeconds/=1000;
  nanoSeconds/=1000;
  millis=nanoSeconds % 1000;
  nanoSeconds/=1000;
  seconds=nanoSeconds % 60;
  nanoSeconds/=60;
  minutes=nanoSeconds % 60;
  nanoSeconds/=60;
  hours=nanoSeconds;
  if (hours > 0)   timeStr+=hours + ""String_Node_Str"";
  if (minutes > 0)   timeStr+=minutes + ""String_Node_Str"";
  if (seconds > 0)   timeStr+=seconds + ""String_Node_Str"";
  if (millis > 0)   timeStr+=millis + ""String_Node_Str"";
  return timeStr;
}"
9814,"@Override public void buildWidgetPanel(){
  add(getLabel());
  value=config.getConfigOptionValue(component,configOption);
  if (((URLConfigOption)configOption).refersToOWLClass()) {
    comboBox=new JComboBox();
    ReasonerComponent reasoner=config.getReasoner();
    String baseURI=reasoner.getBaseURI();
    Map<String,String> prefixes=reasoner.getPrefixes();
    classes=new LinkedList<NamedClass>(reasoner.getNamedClasses());
    for (    NamedClass clazz : classes) {
      comboBox.addItem(clazz.toManchesterSyntaxString(baseURI,prefixes));
    }
    comboBox.addActionListener(this);
    comboBox.setSelectedIndex(0);
    add(comboBox);
  }
 else {
    stringField=new JTextField(35);
    if (value != null) {
      stringField.setText(value.toString());
    }
    stringField.setToolTipText(configOption.getAllowedValuesDescription());
    setButton=new JButton(""String_Node_Str"");
    setButton.addActionListener(this);
    add(stringField);
    add(setButton);
    if (((URLConfigOption)configOption).refersToFile()) {
      chooseLocalButton=new JButton(""String_Node_Str"");
      chooseLocalButton.addActionListener(this);
      add(new JLabel(""String_Node_Str""));
      add(chooseLocalButton);
    }
  }
}","@Override public void buildWidgetPanel(){
  add(getLabel());
  value=config.getConfigOptionValue(component,configOption);
  if (((URLConfigOption)configOption).refersToOWLClass()) {
    comboBox=new JComboBox();
    ReasonerComponent reasoner=config.getReasoner();
    String baseURI=reasoner.getBaseURI();
    Map<String,String> prefixes=reasoner.getPrefixes();
    classes=new LinkedList<NamedClass>(reasoner.getNamedClasses());
    for (    NamedClass clazz : classes) {
      comboBox.addItem(clazz.toManchesterSyntaxString(baseURI,prefixes));
    }
    comboBox.addActionListener(this);
    NamedClass valueNc=new NamedClass(value.toString());
    comboBox.setSelectedItem(valueNc.toManchesterSyntaxString(baseURI,prefixes));
    add(comboBox);
  }
 else {
    stringField=new JTextField(35);
    if (value != null) {
      stringField.setText(value.toString());
    }
    stringField.setToolTipText(configOption.getAllowedValuesDescription());
    setButton=new JButton(""String_Node_Str"");
    setButton.addActionListener(this);
    add(stringField);
    add(setButton);
    if (((URLConfigOption)configOption).refersToFile()) {
      chooseLocalButton=new JButton(""String_Node_Str"");
      chooseLocalButton.addActionListener(this);
      add(new JLabel(""String_Node_Str""));
      add(chooseLocalButton);
    }
  }
}"
9815,"@Override public void init() throws ComponentInitException {
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().clone();
  classHierarchy.thinOutSubsumptionHierarchy();
  minimizer=new DescriptionMinimizer(reasoner);
  startClass=Thing.instance;
  singleSuggestionMode=configurator.getSingleSuggestionMode();
  operator=new RhoDRDown(reasoner,classHierarchy,startClass,configurator);
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(configurator.getMaxNrOfResults());
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=configurator.getNoisePercentage() / 100d;
  maxDepth=configurator.getMaxDepth();
  filterFollowsFromKB=configurator.getFilterDescriptionsFollowingFromKB() && isClassLearningProblem;
  System.out.println(""String_Node_Str"" + filterFollowsFromKB);
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (configurator.getReuseExistingDescription() && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        do {
          Description candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            startClassCandidates.addAll(upwardOperator.refine(candidate,candidate.getLength()));
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}","@Override public void init() throws ComponentInitException {
  ClassHierarchy classHierarchy=reasoner.getClassHierarchy().clone();
  classHierarchy.thinOutSubsumptionHierarchy();
  minimizer=new DescriptionMinimizer(reasoner);
  startClass=Thing.instance;
  singleSuggestionMode=configurator.getSingleSuggestionMode();
  operator=new RhoDRDown(reasoner,classHierarchy,startClass,configurator);
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  bestEvaluatedDescriptions=new EvaluatedDescriptionSet(configurator.getMaxNrOfResults());
  isClassLearningProblem=(learningProblem instanceof ClassLearningProblem);
  noise=configurator.getNoisePercentage() / 100d;
  maxDepth=configurator.getMaxDepth();
  filterFollowsFromKB=configurator.getFilterDescriptionsFollowingFromKB() && isClassLearningProblem;
  if (isClassLearningProblem) {
    ClassLearningProblem problem=(ClassLearningProblem)learningProblem;
    classToDescribe=problem.getClassToDescribe();
    isEquivalenceProblem=problem.isEquivalenceProblem();
    examples=reasoner.getIndividuals(classToDescribe);
    if (isEquivalenceProblem) {
      Set<Description> existingDefinitions=reasoner.getAssertedDefinitions(classToDescribe);
      if (configurator.getReuseExistingDescription() && (existingDefinitions.size() > 0)) {
        Description existingDefinition=null;
        int highestLength=0;
        for (        Description exDef : existingDefinitions) {
          if (exDef.getLength() > highestLength) {
            existingDefinition=exDef;
            highestLength=exDef.getLength();
          }
        }
        LinkedList<Description> startClassCandidates=new LinkedList<Description>();
        startClassCandidates.add(existingDefinition);
        ((RhoDRDown)operator).setDropDisjuncts(true);
        RefinementOperator upwardOperator=new OperatorInverter(operator);
        boolean startClassFound=false;
        Description candidate;
        do {
          candidate=startClassCandidates.pollFirst();
          if (((ClassLearningProblem)learningProblem).getRecall(candidate) < 1.0) {
            Set<Description> refinements=upwardOperator.refine(candidate,candidate.getLength());
            LinkedList<Description> refinementList=new LinkedList<Description>(refinements);
            startClassCandidates.addAll(refinementList);
          }
 else {
            startClassFound=true;
          }
        }
 while (!startClassFound);
        startClass=candidate;
        if (startClass.equals(existingDefinition)) {
          logger.info(""String_Node_Str"" + startClass.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
        }
 else {
          logger.info(""String_Node_Str"" + existingDefinition.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ startClass.toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
        }
        ((RhoDRDown)operator).setDropDisjuncts(false);
      }
 else {
        Set<Description> superClasses=reasoner.getClassHierarchy().getSuperClasses(classToDescribe);
        if (superClasses.size() > 1) {
          startClass=new Intersection(new LinkedList<Description>(superClasses));
        }
 else         if (superClasses.size() == 1) {
          startClass=(Description)superClasses.toArray()[0];
        }
 else {
          startClass=Thing.instance;
          logger.warn(classToDescribe + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (learningProblem instanceof PosOnlyLP) {
    examples=((PosOnlyLP)learningProblem).getPositiveExamples();
  }
 else   if (learningProblem instanceof PosNegLP) {
    examples=Helper.union(((PosNegLP)learningProblem).getPositiveExamples(),((PosNegLP)learningProblem).getNegativeExamples());
  }
}"
9816,"/** 
 * Returns asserted class definitions of given class
 * @param nc the class
 * @return the asserted class definitions
 */
@Override public Set<Description> getAssertedDefinitionsImpl(NamedClass nc){
  OWLClass owlClass=OWLAPIDescriptionConvertVisitor.getOWLDescription(nc).asOWLClass();
  Set<OWLDescription> owlAPIDefinitions=owlClass.getEquivalentClasses(new HashSet<OWLOntology>(owlAPIOntologies));
  Set<Description> definitions=new HashSet<Description>();
  return definitions;
}","/** 
 * Returns asserted class definitions of given class
 * @param nc the class
 * @return the asserted class definitions
 */
@Override protected Set<Description> getAssertedDefinitionsImpl(NamedClass nc){
  OWLClass owlClass=OWLAPIDescriptionConvertVisitor.getOWLDescription(nc).asOWLClass();
  Set<OWLDescription> owlAPIDescriptions=owlClass.getEquivalentClasses(new HashSet<OWLOntology>(owlAPIOntologies));
  Set<Description> definitions=new HashSet<Description>();
  for (  OWLDescription owlAPIDescription : owlAPIDescriptions) {
    definitions.add(DLLearnerDescriptionConvertVisitor.getDLLearnerDescription(owlAPIDescription));
  }
  return definitions;
}"
9817,"public static ReasonerComponent getTestOntology(TestOntology ont){
  String kbString=""String_Node_Str"";
  String owlFile=""String_Node_Str"";
  if (ont.equals(TestOntology.EMPTY)) {
  }
 else   if (ont.equals(TestOntology.SIMPLE)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE_NO_DR)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE_NO_DISJOINT)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE_NO_DR_DISJOINT)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE2)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE3)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.R1SUBR2)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.DATA1)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.FIVE_ROLES)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.RHO1)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.FATHER_OE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.CARCINOGENESIS)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.EPC_OE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.KRK_ZERO_ONE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.DBPEDIA_OWL)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.TRAINS_OWL)) {
    owlFile=""String_Node_Str"";
  }
  try {
    ComponentManager cm=ComponentManager.getInstance();
    KnowledgeSource source;
    if (!kbString.isEmpty() || ont.equals(TestOntology.EMPTY)) {
      KB kb=KBParser.parseKBFile(kbString);
      source=new KBFile(kb);
    }
 else {
      source=cm.knowledgeSource(OWLFile.class);
      try {
        cm.applyConfigEntry(source,""String_Node_Str"",new File(owlFile).toURI().toURL());
      }
 catch (      MalformedURLException e) {
        e.printStackTrace();
      }
    }
    ReasonerComponent rc=cm.reasoner(OWLAPIReasoner.class,source);
    source.init();
    rc.init();
    return rc;
  }
 catch (  ParseException e) {
    e.printStackTrace();
  }
catch (  ComponentInitException e) {
    e.printStackTrace();
  }
  throw new Error(""String_Node_Str"");
}","public static ReasonerComponent getTestOntology(TestOntology ont){
  String kbString=""String_Node_Str"";
  String owlFile=""String_Node_Str"";
  if (ont.equals(TestOntology.EMPTY)) {
  }
 else   if (ont.equals(TestOntology.SIMPLE)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE_NO_DR)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE_NO_DISJOINT)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE_NO_DR_DISJOINT)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE2)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SIMPLE3)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.R1SUBR2)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.DATA1)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.FIVE_ROLES)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.RHO1)) {
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
    kbString+=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.FATHER_OE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.CARCINOGENESIS)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.EPC_OE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.KRK_ZERO_ONE)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.DBPEDIA_OWL)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.TRAINS_OWL)) {
    owlFile=""String_Node_Str"";
  }
 else   if (ont.equals(TestOntology.SWORE)) {
    owlFile=""String_Node_Str"";
  }
  try {
    ComponentManager cm=ComponentManager.getInstance();
    KnowledgeSource source;
    if (!kbString.isEmpty() || ont.equals(TestOntology.EMPTY)) {
      KB kb=KBParser.parseKBFile(kbString);
      source=new KBFile(kb);
    }
 else {
      source=cm.knowledgeSource(OWLFile.class);
      try {
        cm.applyConfigEntry(source,""String_Node_Str"",new File(owlFile).toURI().toURL());
      }
 catch (      MalformedURLException e) {
        e.printStackTrace();
      }
    }
    ReasonerComponent rc=cm.reasoner(OWLAPIReasoner.class,source);
    source.init();
    rc.init();
    return rc;
  }
 catch (  ParseException e) {
    e.printStackTrace();
  }
catch (  ComponentInitException e) {
    e.printStackTrace();
  }
  throw new Error(""String_Node_Str"");
}"
9818,"/** 
 * Constructor for the Option Panel. 
 */
public OptionPanel(){
  setLayout(new BorderLayout());
  optionHandler=new OptionPanelHandler(this);
  labelPanel=new JPanel();
  labelPanel.setLayout(new GridLayout(0,1));
  sliderPanel=new JPanel();
  sliderPanel.setLayout(new GridLayout(0,1));
  profilePanel=new JPanel();
  profilePanel.setLayout(new GridLayout(0,1));
  radioBoxPanel=new JPanel();
  radioBoxPanel.setLayout(new GridLayout(1,3));
  checkBoxPanel=new JPanel();
  checkBoxPanel.setLayout(new GridLayout(1,6));
  minAccuracyLabel=new JLabel(""String_Node_Str"");
  maxExecutionTimeLabel=new JLabel(""String_Node_Str"");
  nrOfConceptsLabel=new JLabel(""String_Node_Str"");
  minAccuracy=new JSlider(0,50,5);
  minAccuracy.setPaintTicks(true);
  minAccuracy.setMajorTickSpacing(10);
  minAccuracy.setMinorTickSpacing(1);
  minAccuracy.setPaintLabels(true);
  maxExecutionTime=new JSlider(0,40,8);
  maxExecutionTime.setPaintTicks(true);
  maxExecutionTime.setMajorTickSpacing(10);
  maxExecutionTime.setMinorTickSpacing(1);
  maxExecutionTime.setPaintLabels(true);
  nrOfConcepts=new JSlider(2,20,10);
  nrOfConcepts.setPaintTicks(true);
  nrOfConcepts.setMajorTickSpacing(2);
  nrOfConcepts.setMinorTickSpacing(1);
  nrOfConcepts.setPaintLabels(true);
  owlRadioButton=new JRadioButton(""String_Node_Str"",true);
  elProfileButton=new JRadioButton(""String_Node_Str"",false);
  owlRadioButton.setEnabled(true);
  owlRadioButton.addItemListener(optionHandler);
  elProfileButton.addItemListener(optionHandler);
  allBox=new JCheckBox(""String_Node_Str"",true);
  allBox.addItemListener(optionHandler);
  someBox=new JCheckBox(""String_Node_Str"",true);
  someBox.addItemListener(optionHandler);
  notBox=new JCheckBox(""String_Node_Str"",true);
  notBox.addItemListener(optionHandler);
  valueBox=new JCheckBox(""String_Node_Str"",true);
  valueBox.addItemListener(optionHandler);
  moreBox=new JCheckBox(""String_Node_Str"",true);
  moreBox.addItemListener(optionHandler);
  countMoreBox=new JComboBox();
  countMoreBox.addItem(1);
  countMoreBox.addItem(2);
  countMoreBox.addItem(3);
  countMoreBox.addItem(4);
  countMoreBox.addItem(5);
  countMoreBox.addItem(6);
  countMoreBox.addItem(7);
  countMoreBox.addItem(8);
  countMoreBox.addItem(9);
  countMoreBox.addItem(10);
  countMoreBox.setSelectedItem(5);
  countMoreBox.setEditable(false);
  checkBoxPanel.add(allBox);
  checkBoxPanel.add(someBox);
  checkBoxPanel.add(notBox);
  checkBoxPanel.add(valueBox);
  checkBoxPanel.add(moreBox);
  checkBoxPanel.add(countMoreBox);
  radioBoxPanel.add(owlRadioButton);
  radioBoxPanel.add(elProfileButton);
  profilePanel.add(radioBoxPanel);
  profilePanel.add(checkBoxPanel);
  labelPanel.add(minAccuracyLabel);
  labelPanel.add(maxExecutionTimeLabel);
  labelPanel.add(nrOfConceptsLabel);
  sliderPanel.add(minAccuracy);
  sliderPanel.add(maxExecutionTime);
  sliderPanel.add(nrOfConcepts);
  add(BorderLayout.SOUTH,profilePanel);
  add(BorderLayout.WEST,labelPanel);
  add(BorderLayout.CENTER,sliderPanel);
}","/** 
 * Constructor for the Option Panel. 
 */
public OptionPanel(){
  setLayout(new BorderLayout());
  optionHandler=new OptionPanelHandler(this);
  labelPanel=new JPanel();
  labelPanel.setLayout(new GridLayout(0,1));
  sliderPanel=new JPanel();
  sliderPanel.setLayout(new GridLayout(0,1));
  profilePanel=new JPanel();
  profilePanel.setLayout(new GridLayout(0,1));
  radioBoxPanel=new JPanel();
  radioBoxPanel.setLayout(new GridLayout(1,3));
  checkBoxPanel=new JPanel();
  checkBoxPanel.setLayout(new GridBagLayout());
  minAccuracyLabel=new JLabel(""String_Node_Str"");
  maxExecutionTimeLabel=new JLabel(""String_Node_Str"");
  nrOfConceptsLabel=new JLabel(""String_Node_Str"");
  minAccuracy=new JSlider(0,50,5);
  minAccuracy.setPaintTicks(true);
  minAccuracy.setMajorTickSpacing(10);
  minAccuracy.setMinorTickSpacing(1);
  minAccuracy.setPaintLabels(true);
  maxExecutionTime=new JSlider(0,40,8);
  maxExecutionTime.setPaintTicks(true);
  maxExecutionTime.setMajorTickSpacing(10);
  maxExecutionTime.setMinorTickSpacing(1);
  maxExecutionTime.setPaintLabels(true);
  nrOfConcepts=new JSlider(2,20,10);
  nrOfConcepts.setPaintTicks(true);
  nrOfConcepts.setMajorTickSpacing(2);
  nrOfConcepts.setMinorTickSpacing(1);
  nrOfConcepts.setPaintLabels(true);
  owlRadioButton=new JRadioButton(""String_Node_Str"",true);
  elProfileButton=new JRadioButton(""String_Node_Str"",false);
  owlRadioButton.setEnabled(true);
  owlRadioButton.addItemListener(optionHandler);
  elProfileButton.addItemListener(optionHandler);
  allBox=new JCheckBox(""String_Node_Str"",true);
  allBox.addItemListener(optionHandler);
  someBox=new JCheckBox(""String_Node_Str"",true);
  someBox.addItemListener(optionHandler);
  notBox=new JCheckBox(""String_Node_Str"",true);
  notBox.addItemListener(optionHandler);
  valueBox=new JCheckBox(""String_Node_Str"",true);
  valueBox.addItemListener(optionHandler);
  moreBox=new JCheckBox(""String_Node_Str"",true);
  moreBox.addItemListener(optionHandler);
  countMoreBox=new JComboBox();
  countMoreBox.addItem(1);
  countMoreBox.addItem(2);
  countMoreBox.addItem(3);
  countMoreBox.addItem(4);
  countMoreBox.addItem(5);
  countMoreBox.addItem(6);
  countMoreBox.addItem(7);
  countMoreBox.addItem(8);
  countMoreBox.addItem(9);
  countMoreBox.addItem(10);
  countMoreBox.setSelectedItem(5);
  countMoreBox.setEditable(false);
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1.0;
  c.weighty=0.0;
  c.gridx=0;
  c.gridy=0;
  c.gridwidth=1;
  checkBoxPanel.add(allBox,c);
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1.0;
  c.weighty=0.0;
  c.gridx=2;
  c.gridy=0;
  c.gridwidth=1;
  checkBoxPanel.add(someBox,c);
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1.0;
  c.weighty=0.0;
  c.gridx=4;
  c.gridy=0;
  c.gridwidth=1;
  checkBoxPanel.add(notBox,c);
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1.0;
  c.weighty=0.0;
  c.gridx=6;
  c.gridy=0;
  c.gridwidth=1;
  checkBoxPanel.add(valueBox,c);
  c.fill=GridBagConstraints.BOTH;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridx=8;
  c.gridy=0;
  c.gridwidth=1;
  checkBoxPanel.add(moreBox,c);
  c.fill=GridBagConstraints.BOTH;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridx=9;
  c.gridy=0;
  c.gridwidth=1;
  checkBoxPanel.add(countMoreBox,c);
  radioBoxPanel.add(owlRadioButton);
  radioBoxPanel.add(elProfileButton);
  profilePanel.add(radioBoxPanel);
  profilePanel.add(checkBoxPanel);
  labelPanel.add(minAccuracyLabel);
  labelPanel.add(maxExecutionTimeLabel);
  labelPanel.add(nrOfConceptsLabel);
  sliderPanel.add(minAccuracy);
  sliderPanel.add(maxExecutionTime);
  sliderPanel.add(nrOfConcepts);
  add(BorderLayout.SOUTH,profilePanel);
  add(BorderLayout.WEST,labelPanel);
  add(BorderLayout.CENTER,sliderPanel);
}"
9819,"@SuppressWarnings(""String_Node_Str"") @Override protected List<? extends EvaluatedDescription> doInBackground() throws Exception {
  setProgress(0);
  la=model.getLearningAlgorithm();
  view.setStatusBarVisible(true);
  view.getStatusBar().setMaximumValue(view.getPosAndNegSelectPanel().getOptionPanel().getMaxExecutionTime());
  timer=new Timer();
  timer.schedule(new TimerTask(){
    int progress=0;
    @Override public void run(){
      progress+=1;
      setProgress(progress);
      if (la != null) {
        publish(la.getCurrentlyBestEvaluatedDescriptions(view.getPosAndNegSelectPanel().getOptionPanel().getNrOfConcepts()));
        CELOE celoe=(CELOE)model.getLearningAlgorithm();
        view.getHintPanel().setForeground(Color.RED);
        String moreInformationsMessage=""String_Node_Str"" + celoe.getMinimumHorizontalExpansion() + ""String_Node_Str""+ celoe.getMaximumHorizontalExpansion()+ ""String_Node_Str"";
        view.setHintMessage(moreInformationsMessage);
      }
    }
  }
,1000,1000);
  dlLearner=new Thread(new Runnable(){
    @Override public void run(){
      try {
        model.run();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
);
  dlLearner.start();
  try {
    dlLearner.join();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  List<? extends EvaluatedDescription> result=la.getCurrentlyBestEvaluatedDescriptions(view.getPosAndNegSelectPanel().getOptionPanel().getNrOfConcepts());
  return result;
}","@SuppressWarnings(""String_Node_Str"") @Override protected List<? extends EvaluatedDescription> doInBackground() throws Exception {
  setProgress(0);
  la=model.getLearningAlgorithm();
  view.setStatusBarVisible(true);
  view.getStatusBar().setMaximumValue(view.getPosAndNegSelectPanel().getOptionPanel().getMaxExecutionTime());
  timer=new Timer();
  isFinished=false;
  timer.schedule(new TimerTask(){
    int progress=0;
    @Override public void run(){
      progress+=1;
      setProgress(progress);
      if (progress == view.getPosAndNegSelectPanel().getOptionPanel().getMaxExecutionTime() - 1) {
        isFinished=true;
      }
      if (la != null) {
        publish(la.getCurrentlyBestEvaluatedDescriptions(view.getPosAndNegSelectPanel().getOptionPanel().getNrOfConcepts()));
        CELOE celoe=(CELOE)model.getLearningAlgorithm();
        view.getHintPanel().setForeground(Color.RED);
        String moreInformationsMessage=""String_Node_Str"" + celoe.getMinimumHorizontalExpansion() + ""String_Node_Str""+ celoe.getMaximumHorizontalExpansion()+ ""String_Node_Str"";
        view.setHintMessage(moreInformationsMessage);
      }
    }
  }
,1000,1000);
  dlLearner=new Thread(new Runnable(){
    @Override public void run(){
      try {
        model.run();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
);
  dlLearner.start();
  try {
    dlLearner.join();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  List<? extends EvaluatedDescription> result=la.getCurrentlyBestEvaluatedDescriptions(view.getPosAndNegSelectPanel().getOptionPanel().getNrOfConcepts());
  return result;
}"
9820,"public void run(){
  model.setSuggestList(result);
  dm.clear();
  int i=0;
  for (  EvaluatedDescription eval : result) {
    Set<String> ont=model.getOntologyURIString();
    for (    String ontology : ont) {
      if (eval.getDescription().toString().contains(ontology)) {
        if (((EvaluatedDescriptionClass)eval).isConsistent()) {
          dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          i++;
          break;
        }
 else {
          dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          view.setIsInconsistent(true);
          i++;
          break;
        }
      }
    }
  }
  view.getSuggestClassPanel().setSuggestList(dm);
  view.getLearnerView().repaint();
}","public void run(){
  model.setSuggestList(result);
  dm.clear();
  int i=0;
  for (  EvaluatedDescription eval : result) {
    Set<String> ont=model.getOntologyURIString();
    for (    String ontology : ont) {
      if (eval.getDescription().toString().contains(ontology)) {
        if (((EvaluatedDescriptionClass)eval).isConsistent()) {
          dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          i++;
          break;
        }
 else {
          dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          if (isFinished) {
            view.setIsInconsistent(true);
          }
          i++;
          break;
        }
      }
    }
  }
  view.getSuggestClassPanel().setSuggestList(dm);
  view.getLearnerView().repaint();
}"
9821,"private void updateList(final List<? extends EvaluatedDescription> result){
  Runnable doUpdateList=new Runnable(){
    public void run(){
      model.setSuggestList(result);
      dm.clear();
      int i=0;
      for (      EvaluatedDescription eval : result) {
        Set<String> ont=model.getOntologyURIString();
        for (        String ontology : ont) {
          if (eval.getDescription().toString().contains(ontology)) {
            if (((EvaluatedDescriptionClass)eval).isConsistent()) {
              dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              i++;
              break;
            }
 else {
              dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              view.setIsInconsistent(true);
              i++;
              break;
            }
          }
        }
      }
      view.getSuggestClassPanel().setSuggestList(dm);
      view.getLearnerView().repaint();
    }
  }
;
  SwingUtilities.invokeLater(doUpdateList);
}","private void updateList(final List<? extends EvaluatedDescription> result){
  Runnable doUpdateList=new Runnable(){
    public void run(){
      model.setSuggestList(result);
      dm.clear();
      int i=0;
      for (      EvaluatedDescription eval : result) {
        Set<String> ont=model.getOntologyURIString();
        for (        String ontology : ont) {
          if (eval.getDescription().toString().contains(ontology)) {
            if (((EvaluatedDescriptionClass)eval).isConsistent()) {
              dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              i++;
              break;
            }
 else {
              dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              if (isFinished) {
                view.setIsInconsistent(true);
              }
              i++;
              break;
            }
          }
        }
      }
      view.getSuggestClassPanel().setSuggestList(dm);
      view.getLearnerView().repaint();
    }
  }
;
  SwingUtilities.invokeLater(doUpdateList);
}"
9822,"@Override public void actionPerformed(ActionEvent e){
  traceInput();
  if (e.getActionCommand().equals(""String_Node_Str"")) {
    NamedClass nc=classesTable.getSelectedClass(currentClassIndex);
    if (!showingMultiTables) {
    }
    if (showingMultiTables && showingEquivalentSuggestions) {
      if (defaultSuperMap.get(nc) != null) {
        showSuperSuggestions(nc);
        showSingleTable();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
        showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
        showSingleTable();
      }
    }
 else     if (!showingMultiTables && showingEquivalentSuggestions) {
      if (owlEquivalenceStandardMap.get(nc) != null) {
        showMultiTables();
      }
 else       if (defaultSuperMap.get(nc) != null) {
        showSuperSuggestions(nc);
        showSingleTable();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
        showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
        showSingleTable();
      }
    }
 else     if (!showingMultiTables && !showingEquivalentSuggestions) {
      if (owlSuperStandardMap.get(nc) != null) {
        showMultiTables();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        NamedClass newNc=classesTable.getSelectedClass(currentClassIndex);
        graphPanel.setConcept(newNc);
        if (defaultEquivalenceMap.get(newNc) != null) {
          showEquivalentSuggestions(newNc);
        }
 else {
          showSuperSuggestions(newNc);
        }
        showSingleTable();
      }
    }
 else {
      currentClassIndex++;
      classesTable.setSelectedClass(currentClassIndex);
      NamedClass newCl=classesTable.getSelectedClass(currentClassIndex);
      graphPanel.setConcept(newCl);
      if (defaultEquivalenceMap.containsKey(newCl)) {
        showEquivalentSuggestions(newCl);
      }
 else {
        showSuperSuggestions(newCl);
      }
      showSingleTable();
    }
    setFinished();
    resetTablePanels();
  }
 else   if (e.getActionCommand().equals(""String_Node_Str"")) {
    closeDialog();
    saveInput();
  }
}","@Override public void actionPerformed(ActionEvent e){
  traceInput();
  if (e.getActionCommand().equals(""String_Node_Str"")) {
    NamedClass nc=classesTable.getSelectedClass(currentClassIndex);
    if (!showingMultiTables) {
    }
    if (showingMultiTables && showingEquivalentSuggestions) {
      if (defaultSuperMap.get(nc) != null) {
        showSuperSuggestions(nc);
        showSingleTable();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
        showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
        showSingleTable();
      }
    }
 else     if (!showingMultiTables && showingEquivalentSuggestions) {
      if (owlEquivalenceStandardMap.get(nc) != null) {
        showMultiTables();
      }
 else       if (defaultSuperMap.get(nc) != null) {
        showSuperSuggestions(nc);
        showSingleTable();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
        if (defaultEquivalenceMap.get(classesTable.getSelectedClass(currentClassIndex)) != null) {
          showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
        }
 else {
          showSuperSuggestions(classesTable.getSelectedClass(currentClassIndex));
        }
        showSingleTable();
      }
    }
 else     if (!showingMultiTables && !showingEquivalentSuggestions) {
      if (owlSuperStandardMap.get(nc) != null) {
        showMultiTables();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        NamedClass newNc=classesTable.getSelectedClass(currentClassIndex);
        graphPanel.setConcept(newNc);
        if (defaultEquivalenceMap.get(newNc) != null) {
          showEquivalentSuggestions(newNc);
        }
 else {
          showSuperSuggestions(newNc);
        }
        showSingleTable();
      }
    }
 else {
      currentClassIndex++;
      classesTable.setSelectedClass(currentClassIndex);
      NamedClass newCl=classesTable.getSelectedClass(currentClassIndex);
      graphPanel.setConcept(newCl);
      if (defaultEquivalenceMap.containsKey(newCl)) {
        showEquivalentSuggestions(newCl);
      }
 else {
        showSuperSuggestions(newCl);
      }
      showSingleTable();
    }
    setFinished();
    resetTablePanels();
  }
 else   if (e.getActionCommand().equals(""String_Node_Str"")) {
    closeDialog();
    saveInput();
  }
}"
9823,"private void saveResults(){
  OutputStream fos=null;
  File old=new File(ontologyURI);
  int index=old.getName().lastIndexOf('.');
  String fileName=""String_Node_Str"";
  if (index > 0 && index <= old.getName().length() - 2) {
    fileName=old.getName().substring(0,index) + ""String_Node_Str"";
  }
  File file=new File(fileName);
  try {
    fos=new FileOutputStream(file);
    ObjectOutputStream o=new ObjectOutputStream(fos);
    o.writeObject(owlEquivalenceStandardMap);
    o.writeObject(owlEquivalenceFMeasureMap);
    o.writeObject(owlEquivalencePredaccMap);
    o.writeObject(owlEquivalenceJaccardMap);
    o.writeObject(owlEquivalenceGenFMeasureMap);
    o.writeObject(owlSuperStandardMap);
    o.writeObject(owlSuperFMeasureMap);
    o.writeObject(owlSuperPredaccMap);
    o.writeObject(owlSuperJaccardMap);
    o.writeObject(owlSuperGenFMeasureMap);
    o.writeObject(fastEquivalenceStandardMap);
    o.writeObject(fastEquivalenceFMeasureMap);
    o.writeObject(fastEquivalencePredaccMap);
    o.writeObject(fastEquivalenceJaccardMap);
    o.writeObject(fastEquivalenceGenFMeasureMap);
    o.writeObject(fastSuperStandardMap);
    o.writeObject(fastSuperFMeasureMap);
    o.writeObject(fastSuperPredaccMap);
    o.writeObject(fastSuperJaccardMap);
    o.writeObject(fastSuperGenFMeasureMap);
    o.writeObject(defaultEquivalenceMap);
    o.writeObject(defaultSuperMap);
    o.writeObject(baseURI);
    o.writeObject(prefixes);
    o.writeObject(assertedEquivalentClasses);
    o.writeObject(assertedSuperClasses);
    o.flush();
  }
 catch (  IOException e) {
    System.err.println(e);
  }
 finally {
    try {
      fos.close();
    }
 catch (    Exception e) {
    }
  }
}","private void saveResults(){
  OutputStream fos=null;
  File old=new File(ontologyURI);
  int index=old.toURI().toString().lastIndexOf('.');
  String fileName=""String_Node_Str"";
  if (index > 0) {
    fileName=old.toURI().toString().substring(0,index) + ""String_Node_Str"";
  }
  File file=new File(fileName);
  try {
    fos=new FileOutputStream(file);
    ObjectOutputStream o=new ObjectOutputStream(fos);
    o.writeObject(owlEquivalenceStandardMap);
    o.writeObject(owlEquivalenceFMeasureMap);
    o.writeObject(owlEquivalencePredaccMap);
    o.writeObject(owlEquivalenceJaccardMap);
    o.writeObject(owlEquivalenceGenFMeasureMap);
    o.writeObject(owlSuperStandardMap);
    o.writeObject(owlSuperFMeasureMap);
    o.writeObject(owlSuperPredaccMap);
    o.writeObject(owlSuperJaccardMap);
    o.writeObject(owlSuperGenFMeasureMap);
    o.writeObject(fastEquivalenceStandardMap);
    o.writeObject(fastEquivalenceFMeasureMap);
    o.writeObject(fastEquivalencePredaccMap);
    o.writeObject(fastEquivalenceJaccardMap);
    o.writeObject(fastEquivalenceGenFMeasureMap);
    o.writeObject(fastSuperStandardMap);
    o.writeObject(fastSuperFMeasureMap);
    o.writeObject(fastSuperPredaccMap);
    o.writeObject(fastSuperJaccardMap);
    o.writeObject(fastSuperGenFMeasureMap);
    o.writeObject(defaultEquivalenceMap);
    o.writeObject(defaultSuperMap);
    o.writeObject(baseURI);
    o.writeObject(prefixes);
    o.writeObject(assertedEquivalentClasses);
    o.writeObject(assertedSuperClasses);
    o.flush();
  }
 catch (  IOException e) {
    System.err.println(e);
  }
 finally {
    try {
      fos.close();
    }
 catch (    Exception e) {
    }
  }
}"
9824,"@Override public void actionPerformed(ActionEvent e){
  traceInput();
  if (e.getActionCommand().equals(""String_Node_Str"")) {
    NamedClass nc=classesTable.getSelectedClass(currentClassIndex);
    if (!showingMultiTables) {
    }
    if (showingMultiTables && showingEquivalentSuggestions) {
      if (defaultSuperMap.get(nc) != null) {
        showSuperSuggestions(nc);
        showSingleTable();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
        showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
        showSingleTable();
      }
    }
 else     if (!showingMultiTables && showingEquivalentSuggestions) {
      if (owlEquivalenceStandardMap.get(nc) != null) {
        showMultiTables();
      }
 else       if (defaultSuperMap.get(nc) != null) {
        showSuperSuggestions(nc);
        showSingleTable();
        if (currentClassIndex + 1 >= defaultEquivalenceMap.keySet().size()) {
          nextFinishButton.setText(""String_Node_Str"");
          nextFinishButton.setActionCommand(""String_Node_Str"");
        }
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
        showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
        showSingleTable();
      }
    }
 else     if (!showingMultiTables && !showingEquivalentSuggestions) {
      if (owlSuperStandardMap.get(nc) != null) {
        showMultiTables();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        NamedClass newNc=classesTable.getSelectedClass(currentClassIndex);
        graphPanel.setConcept(newNc);
        if (defaultEquivalenceMap.get(newNc) != null) {
          showEquivalentSuggestions(newNc);
        }
 else {
          showSuperSuggestions(newNc);
        }
        showSingleTable();
      }
    }
 else {
      currentClassIndex++;
      classesTable.setSelectedClass(currentClassIndex);
      graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
      showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
      showSingleTable();
    }
    setFinished();
    resetSingleTablePanel();
  }
 else   if (e.getActionCommand().equals(""String_Node_Str"")) {
    closeDialog();
    saveInput();
  }
}","@Override public void actionPerformed(ActionEvent e){
  traceInput();
  if (e.getActionCommand().equals(""String_Node_Str"")) {
    NamedClass nc=classesTable.getSelectedClass(currentClassIndex);
    if (!showingMultiTables) {
    }
    if (showingMultiTables && showingEquivalentSuggestions) {
      if (defaultSuperMap.get(nc) != null) {
        showSuperSuggestions(nc);
        showSingleTable();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
        showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
        showSingleTable();
      }
    }
 else     if (!showingMultiTables && showingEquivalentSuggestions) {
      if (owlEquivalenceStandardMap.get(nc) != null) {
        showMultiTables();
      }
 else       if (defaultSuperMap.get(nc) != null) {
        showSuperSuggestions(nc);
        showSingleTable();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
        showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
        showSingleTable();
      }
    }
 else     if (!showingMultiTables && !showingEquivalentSuggestions) {
      if (owlSuperStandardMap.get(nc) != null) {
        showMultiTables();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        NamedClass newNc=classesTable.getSelectedClass(currentClassIndex);
        graphPanel.setConcept(newNc);
        if (defaultEquivalenceMap.get(newNc) != null) {
          showEquivalentSuggestions(newNc);
        }
 else {
          showSuperSuggestions(newNc);
        }
        showSingleTable();
      }
    }
 else {
      currentClassIndex++;
      classesTable.setSelectedClass(currentClassIndex);
      NamedClass newCl=classesTable.getSelectedClass(currentClassIndex);
      graphPanel.setConcept(newCl);
      if (defaultEquivalenceMap.containsKey(newCl)) {
        showEquivalentSuggestions(newCl);
      }
 else {
        showSuperSuggestions(newCl);
      }
      showSingleTable();
    }
    setFinished();
    resetSingleTablePanel();
  }
 else   if (e.getActionCommand().equals(""String_Node_Str"")) {
    closeDialog();
    saveInput();
  }
}"
9825,"/** 
 * @param args
 * @throws MalformedURLException 
 * @throws LearningProblemUnsupportedException 
 * @throws ComponentInitException 
 * @throws URISyntaxException 
 */
public static void main(String[] args) throws MalformedURLException, ComponentInitException, LearningProblemUnsupportedException, URISyntaxException {
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  URL fileURL=null;
  if (args[0].startsWith(""String_Node_Str"")) {
    fileURL=new URL(args[0]);
  }
 else {
    fileURL=new File(new URL(args[0]).toURI()).toURI().toURL();
  }
  long startTime=System.currentTimeMillis();
  new EvaluationComputingScript(fileURL);
  System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - startTime) / 1000 + ""String_Node_Str"");
}","/** 
 * @param args
 * @throws MalformedURLException 
 * @throws LearningProblemUnsupportedException 
 * @throws ComponentInitException 
 * @throws URISyntaxException 
 */
public static void main(String[] args) throws MalformedURLException, ComponentInitException, LearningProblemUnsupportedException, URISyntaxException {
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  URL fileURL=new URL(args[0]);
  long startTime=System.currentTimeMillis();
  new EvaluationComputingScript(fileURL);
  System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - startTime) / 1000 + ""String_Node_Str"");
}"
9826,"/** 
 * @param args
 * @throws ComponentInitException
 * @throws MalformedURLException
 * @throws LearningProblemUnsupportedException
 * @throws UnsupportedLookAndFeelException
 * @throws IllegalAccessException
 * @throws InstantiationException
 * @throws ClassNotFoundException
 * @throws URISyntaxException 
 */
public static void main(String[] args) throws ComponentInitException, MalformedURLException, LearningProblemUnsupportedException, ClassNotFoundException, InstantiationException, IllegalAccessException, UnsupportedLookAndFeelException, URISyntaxException {
  UIManager.setLookAndFeel(new PlasticLookAndFeel());
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  final File input=new File(args[0]);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      try {
        new EvaluationGUI(input);
      }
 catch (      MalformedURLException e) {
        e.printStackTrace();
      }
catch (      ComponentInitException e) {
        e.printStackTrace();
      }
catch (      LearningProblemUnsupportedException e) {
        e.printStackTrace();
      }
    }
  }
);
}","/** 
 * @param args
 * @throws ComponentInitException
 * @throws MalformedURLException
 * @throws LearningProblemUnsupportedException
 * @throws UnsupportedLookAndFeelException
 * @throws IllegalAccessException
 * @throws InstantiationException
 * @throws ClassNotFoundException
 * @throws URISyntaxException 
 */
public static void main(String[] args) throws ComponentInitException, LearningProblemUnsupportedException, ClassNotFoundException, InstantiationException, IllegalAccessException, UnsupportedLookAndFeelException, URISyntaxException {
  UIManager.setLookAndFeel(new PlasticLookAndFeel());
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  final File input=new File(args[0]);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      try {
        new EvaluationGUI(input);
      }
 catch (      MalformedURLException e) {
        e.printStackTrace();
      }
catch (      ComponentInitException e) {
        e.printStackTrace();
      }
catch (      LearningProblemUnsupportedException e) {
        e.printStackTrace();
      }
    }
  }
);
}"
9827,"/** 
 * @param args
 * @throws URISyntaxException
 * @throws MalformedURLException
 */
public static void main(String[] args) throws MalformedURLException, URISyntaxException {
  Locale.setDefault(Locale.ENGLISH);
  File directory=new File(new URL(args[0]).toURI());
  new StatsGenerator(directory);
}","/** 
 * @param args
 * @throws URISyntaxException
 * @throws MalformedURLException
 */
public static void main(String[] args) throws MalformedURLException, URISyntaxException {
  Locale.setDefault(Locale.ENGLISH);
  Logger.getRootLogger().setLevel(Level.DEBUG);
  File directory=new File(new URL(args[0]).toURI());
  new StatsGenerator(directory);
}"
9828,"/** 
 * Loads the computed suggestion files.
 * @param resultFile The file where the suggestions are serialized.
 */
private void loadSuggestions(File resultFile){
  InputStream fis=null;
  try {
    fis=new FileInputStream(resultFile);
    ObjectInputStream o=new ObjectInputStream(fis);
    for (int i=0; i < 20; i++) {
      o.readObject();
    }
    equivalentSuggestions=(Map<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    superSuggestions=(Map<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
  }
 catch (  IOException e) {
    System.err.println(e);
  }
catch (  ClassNotFoundException e) {
    System.err.println(e);
  }
 finally {
    try {
      fis.close();
    }
 catch (    Exception e) {
    }
  }
  suggestionListsCount=equivalentSuggestions.size() + superSuggestions.size();
}","/** 
 * Loads the computed suggestion files.
 * @param resultFile The file where the suggestions are serialized.
 */
private void loadSuggestions(File resultFile){
  InputStream fis=null;
  try {
    fis=new FileInputStream(resultFile);
    ObjectInputStream o=new ObjectInputStream(fis);
    for (int i=0; i < 20; i++) {
      o.readObject();
    }
    equivalentSuggestions=(Map<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
    superSuggestions=(Map<NamedClass,List<EvaluatedDescriptionClass>>)o.readObject();
  }
 catch (  IOException e) {
    System.err.println(e);
  }
catch (  ClassNotFoundException e) {
    System.err.println(e);
  }
 finally {
    try {
      fis.close();
    }
 catch (    Exception e) {
    }
  }
  suggestionListsCount=equivalentSuggestions.keySet().size() + superSuggestions.keySet().size();
}"
9829,"private void addStatsTableRow(){
  double accept=acceptedGlobalStat.getMean() / suggestionListsCount * 100;
  double reject=rejectedGlobalStat.getMean() / suggestionListsCount * 100;
  double fail=failedGlobalStat.getMean() / suggestionListsCount * 100;
  Stat positionStat=new Stat(positionStats);
  double avgPosition=positionStat.getMean();
  if (Double.isNaN(avgPosition)) {
    avgPosition=-1;
  }
  double stdDeviationPosition=positionStat.getStandardDeviation();
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  double additionalInstanceCountEq=new Stat(moreInstancesCountStats).getMean();
  double additionalInstanceCountSC=new Stat(moreInstancesCountStatsSC).getMean();
  double additionalInstanceCount=new Stat(new Stat(moreInstancesCountStats),new Stat(moreInstancesCountStatsSC)).getMean();
  Stat avgSelectedAccuracyEq=new Stat(accSelectedStats);
  Stat avgSelectedAccuracySC=new Stat(accSelectedStatsSC);
  Stat avgSelectedAccuracy=new Stat(avgSelectedAccuracyEq,avgSelectedAccuracySC);
  double avgAccuracy=avgSelectedAccuracy.getMean();
  latexStats.append(logicalAxiomCount + ""String_Node_Str"" + suggestionListsCount+ ""String_Node_Str""+ df.format(accept)+ ""String_Node_Str""+ df.format(reject)+ ""String_Node_Str""+ df.format(fail)+ ""String_Node_Str""+ df.format(avgPosition)+ ""String_Node_Str""+ df.format(stdDeviationPosition)+ ""String_Node_Str""+ df.format(avgAccuracy * 100)+ ""String_Node_Str""+ df.format(additionalInstanceCountEq)+ ""String_Node_Str""+ df.format(additionalInstanceCount)+ ""String_Node_Str"");
}","private void addStatsTableRow(){
  double accept=acceptedGlobalStat.getMean() / suggestionListsCount * 100;
  double reject=rejectedGlobalStat.getMean() / suggestionListsCount * 100;
  double fail=failedGlobalStat.getMean() / suggestionListsCount * 100;
  Stat positionStat=new Stat(positionStats);
  double avgPosition=positionStat.getMean();
  if (Double.isNaN(avgPosition)) {
    avgPosition=-1;
  }
  double stdDeviationPosition=positionStat.getStandardDeviation();
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  double additionalInstanceCountEq=new Stat(moreInstancesCountStats).getMean();
  double additionalInstanceCountSC=new Stat(moreInstancesCountStatsSC).getMean();
  double additionalInstanceCount=new Stat(new Stat(moreInstancesCountStats),new Stat(moreInstancesCountStatsSC)).getMean();
  Stat avgSelectedAccuracyEq=new Stat(accSelectedStats);
  Stat avgSelectedAccuracySC=new Stat(accSelectedStatsSC);
  Stat avgSelectedAccuracy=new Stat(avgSelectedAccuracyEq,avgSelectedAccuracySC);
  double avgAccuracy=avgSelectedAccuracy.getMean();
  latexStats.append(logicalAxiomCount + ""String_Node_Str"" + suggestionListsCount+ ""String_Node_Str""+ df.format(accept)+ ""String_Node_Str""+ df.format(reject)+ ""String_Node_Str""+ df.format(fail)+ ""String_Node_Str""+ df.format(avgPosition)+ ""String_Node_Str""+ df.format(stdDeviationPosition)+ ""String_Node_Str""+ df.format(avgAccuracy * 100)+ ""String_Node_Str""+ df.format(additionalInstanceCountEq)+ ""String_Node_Str""+ df.format(additionalInstanceCount)+ ""String_Node_Str"");
  for (int i=0; i < mat.length; i++) {
    for (int j=0; j < mat[i].length; j++) {
      System.out.print(mat[i][j]);
    }
    System.out.println();
  }
  System.out.println(new FleissKappa().computeKappa(mat));
}"
9830,"public StatsGenerator(File directory){
  beginOntologyMetricsTable();
  beginStatsTable();
  for (  File suggestionFile : directory.listFiles(new ResultFileFilter())) {
    clearStats();
    loadSuggestions(suggestionFile);
    loadOntology(suggestionFile);
    for (    File inputFile : directory.listFiles(new NameFilter(suggestionFile))) {
      loadUserInput(inputFile);
      makeSingleStat();
    }
    addOntologyMetricsTableRow();
    addStatsTableRow();
  }
  endTables();
  printLatexCode();
}","public StatsGenerator(File directory){
  beginOntologyMetricsTable();
  beginStatsTable();
  for (  File suggestionFile : directory.listFiles(new ResultFileFilter())) {
    loadSuggestions(suggestionFile);
    loadOntology(suggestionFile);
    resetStats();
    for (    File inputFile : directory.listFiles(new NameFilter(suggestionFile))) {
      loadUserInput(inputFile);
      makeSingleStat();
    }
    addOntologyMetricsTableRow();
    addStatsTableRow();
  }
  endTables();
  printLatexCode();
}"
9831,"private void makeSingleStat(){
  int candidatesAboveThresholdCount=0;
  int missesCount=0;
  int foundDescriptionCount=0;
  int noSensibleDescriptionCount=0;
  int inconsistencyDetected=0;
  int moreInstancesCount=0;
  int nonPerfectCount=0;
  Stat moreInstancesCountStat=new Stat();
  Stat accStat=new Stat();
  Stat accSelectedStat=new Stat();
  Stat accAboveThresholdStat=new Stat();
  Stat positionStat=new Stat();
  int candidatesAboveThresholdCountSC=0;
  int missesCountSC=0;
  int foundDescriptionCountSC=0;
  int noSensibleDescriptionCountSC=0;
  int inconsistencyDetectedSC=0;
  int moreInstancesCountSC=0;
  int nonPerfectCountSC=0;
  Stat moreInstancesCountStatSC=new Stat();
  Stat accStatSC=new Stat();
  Stat accSelectedStatSC=new Stat();
  Stat accAboveThresholdStatSC=new Stat();
  Stat positionStatSC=new Stat();
  for (  Entry<NamedClass,String> e : equivalentInput.entrySet()) {
    NamedClass currentClass=e.getKey();
    String input=e.getValue();
    if (input.equals(""String_Node_Str"")) {
      missesCount++;
    }
 else     if (input.equals(""String_Node_Str"")) {
      noSensibleDescriptionCount++;
    }
 else {
      int selectedIndex=Integer.parseInt(input);
      EvaluatedDescriptionClass selectedExpression=equivalentSuggestions.get(currentClass).get(selectedIndex);
      double bestAcc=equivalentSuggestions.get(currentClass).get(0).getAccuracy();
      int selectedNr=selectedIndex + 1;
      boolean isConsistent=selectedExpression.isConsistent();
      Set<Individual> addInst=selectedExpression.getAdditionalInstances();
      int additionalInstances=addInst.size();
      accSelectedStat.addNumber(selectedExpression.getAccuracy());
      positionStat.addNumber(selectedNr);
      foundDescriptionCount++;
      if (!isConsistent) {
        inconsistencyDetected++;
      }
      if (additionalInstances > 0) {
        moreInstancesCount++;
        moreInstancesCountStat.addNumber(additionalInstances);
      }
      if (bestAcc < 0.9999) {
        nonPerfectCount++;
      }
    }
  }
  acceptedStat.addNumber(foundDescriptionCount);
  rejectedStat.addNumber(noSensibleDescriptionCount);
  failedStat.addNumber(missesCount);
  moreInstancesCountStats.add(moreInstancesCountStat);
  accStats.add(accStat);
  accSelectedStats.add(accSelectedStat);
  accAboveThresholdStats.add(accSelectedStat);
  positionStats.add(positionStat);
  for (  Entry<NamedClass,String> e : superInput.entrySet()) {
    NamedClass currentClass=e.getKey();
    if (e.getValue().equals(""String_Node_Str"")) {
      missesCountSC++;
    }
 else     if (e.getValue().equals(""String_Node_Str"")) {
      noSensibleDescriptionCountSC++;
    }
 else {
      int selectedIndex=Integer.parseInt(e.getValue());
      EvaluatedDescriptionClass selectedExpression=superSuggestions.get(currentClass).get(selectedIndex);
      double bestAcc=superSuggestions.get(currentClass).get(0).getAccuracy();
      int selectedNr=selectedIndex + 1;
      boolean isConsistent=selectedExpression.isConsistent();
      Set<Individual> addInst=selectedExpression.getAdditionalInstances();
      int additionalInstances=addInst.size();
      accSelectedStatSC.addNumber(selectedExpression.getAccuracy());
      positionStatSC.addNumber(selectedNr);
      foundDescriptionCountSC++;
      if (!isConsistent) {
        inconsistencyDetectedSC++;
      }
      if (additionalInstances > 0) {
        moreInstancesCountSC++;
        moreInstancesCountStatSC.addNumber(additionalInstances);
      }
      if (bestAcc < 0.9999) {
        nonPerfectCountSC++;
      }
    }
  }
  acceptedStatSC.addNumber(foundDescriptionCountSC);
  rejectedStatSC.addNumber(noSensibleDescriptionCountSC);
  failedStatSC.addNumber(missesCountSC);
  moreInstancesCountStatsSC.add(moreInstancesCountStatSC);
  accStatsSC.add(accStatSC);
  accSelectedStatsSC.add(accSelectedStatSC);
  accAboveThresholdStatsSC.add(accSelectedStatSC);
  positionStatsSC.add(positionStatSC);
  acceptedGlobalStat.addNumber(foundDescriptionCount + foundDescriptionCountSC);
  rejectedGlobalStat.addNumber(noSensibleDescriptionCountSC + noSensibleDescriptionCount);
  failedGlobalStat.addNumber(missesCountSC + missesCount);
  System.out.println(""String_Node_Str"" + ont.getURI());
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + candidatesAboveThresholdCount);
  System.out.println(""String_Node_Str"" + foundDescriptionCount);
  System.out.println(""String_Node_Str"" + missesCount);
  System.out.println(""String_Node_Str"" + noSensibleDescriptionCount);
  System.out.println(""String_Node_Str"" + inconsistencyDetected);
  System.out.println(""String_Node_Str"" + moreInstancesCountStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accSelectedStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accAboveThresholdStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + nonPerfectCount);
  System.out.println(""String_Node_Str"" + positionStat.prettyPrint(""String_Node_Str""));
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + candidatesAboveThresholdCountSC);
  System.out.println(""String_Node_Str"" + foundDescriptionCountSC);
  System.out.println(""String_Node_Str"" + missesCountSC);
  System.out.println(""String_Node_Str"" + noSensibleDescriptionCountSC);
  System.out.println(""String_Node_Str"" + inconsistencyDetectedSC);
  System.out.println(""String_Node_Str"" + moreInstancesCountStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accSelectedStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accAboveThresholdStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + nonPerfectCountSC);
  System.out.println(""String_Node_Str"" + positionStatSC.prettyPrint(""String_Node_Str""));
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (candidatesAboveThresholdCount + candidatesAboveThresholdCountSC));
  System.out.println(""String_Node_Str"" + (foundDescriptionCount + foundDescriptionCountSC));
  System.out.println(""String_Node_Str"" + (missesCount + missesCountSC));
  System.out.println(""String_Node_Str"" + (noSensibleDescriptionCount + noSensibleDescriptionCountSC));
  System.out.println(""String_Node_Str"" + (inconsistencyDetected + inconsistencyDetectedSC));
  System.out.println(""String_Node_Str"" + new Stat(moreInstancesCountStat,moreInstancesCountStatSC).prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + new Stat(accStat,accStatSC).prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + new Stat(accSelectedStat,accSelectedStatSC).prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + new Stat(accAboveThresholdStat,accAboveThresholdStatSC).prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + (nonPerfectCount + nonPerfectCountSC));
  System.out.println(""String_Node_Str"" + new Stat(positionStat,positionStatSC).prettyPrint(""String_Node_Str""));
  System.out.println();
}","private void makeSingleStat(){
  int candidatesAboveThresholdCount=0;
  int missesCount=0;
  int foundDescriptionCount=0;
  int noSensibleDescriptionCount=0;
  int inconsistencyDetected=0;
  int moreInstancesCount=0;
  int nonPerfectCount=0;
  Stat moreInstancesCountStat=new Stat();
  Stat accStat=new Stat();
  Stat accSelectedStat=new Stat();
  Stat accAboveThresholdStat=new Stat();
  Stat positionStat=new Stat();
  int candidatesAboveThresholdCountSC=0;
  int missesCountSC=0;
  int foundDescriptionCountSC=0;
  int noSensibleDescriptionCountSC=0;
  int inconsistencyDetectedSC=0;
  int moreInstancesCountSC=0;
  int nonPerfectCountSC=0;
  Stat moreInstancesCountStatSC=new Stat();
  Stat accStatSC=new Stat();
  Stat accSelectedStatSC=new Stat();
  Stat accAboveThresholdStatSC=new Stat();
  Stat positionStatSC=new Stat();
  for (  Entry<NamedClass,String> e : equivalentInput.entrySet()) {
    NamedClass currentClass=e.getKey();
    String input=e.getValue();
    if (input.equals(""String_Node_Str"")) {
      input=""String_Node_Str"";
    }
    if (input.equals(""String_Node_Str"")) {
      missesCount++;
      mat[equivalentLists.indexOf(currentClass)][2]++;
    }
 else     if (input.equals(""String_Node_Str"")) {
      noSensibleDescriptionCount++;
      mat[equivalentLists.indexOf(currentClass)][1]++;
    }
 else {
      mat[equivalentLists.indexOf(currentClass)][0]++;
      int selectedIndex=Integer.parseInt(input);
      EvaluatedDescriptionClass selectedExpression=equivalentSuggestions.get(currentClass).get(selectedIndex);
      double bestAcc=equivalentSuggestions.get(currentClass).get(0).getAccuracy();
      int selectedNr=selectedIndex + 1;
      boolean isConsistent=selectedExpression.isConsistent();
      Set<Individual> addInst=selectedExpression.getAdditionalInstances();
      int additionalInstances=addInst.size();
      accSelectedStat.addNumber(selectedExpression.getAccuracy());
      positionStat.addNumber(selectedNr);
      foundDescriptionCount++;
      if (!isConsistent) {
        inconsistencyDetected++;
      }
      if (additionalInstances > 0) {
        moreInstancesCount++;
        moreInstancesCountStat.addNumber(additionalInstances);
      }
      if (bestAcc < 0.9999) {
        nonPerfectCount++;
      }
    }
  }
  acceptedStat.addNumber(foundDescriptionCount);
  rejectedStat.addNumber(noSensibleDescriptionCount);
  failedStat.addNumber(missesCount);
  moreInstancesCountStats.add(moreInstancesCountStat);
  accStats.add(accStat);
  accSelectedStats.add(accSelectedStat);
  accAboveThresholdStats.add(accSelectedStat);
  positionStats.add(positionStat);
  for (  Entry<NamedClass,String> e : superInput.entrySet()) {
    NamedClass currentClass=e.getKey();
    if (e.getValue().equals(""String_Node_Str"")) {
      missesCountSC++;
      mat[superLists.indexOf(currentClass) + equivalentLists.size()][2]++;
    }
 else     if (e.getValue().equals(""String_Node_Str"")) {
      noSensibleDescriptionCountSC++;
      mat[superLists.indexOf(currentClass) + equivalentLists.size()][1]++;
    }
 else {
      mat[superLists.indexOf(currentClass) + equivalentLists.size()][0]++;
      int selectedIndex=Integer.parseInt(e.getValue());
      EvaluatedDescriptionClass selectedExpression=superSuggestions.get(currentClass).get(selectedIndex);
      double bestAcc=superSuggestions.get(currentClass).get(0).getAccuracy();
      int selectedNr=selectedIndex + 1;
      boolean isConsistent=selectedExpression.isConsistent();
      Set<Individual> addInst=selectedExpression.getAdditionalInstances();
      int additionalInstances=addInst.size();
      accSelectedStatSC.addNumber(selectedExpression.getAccuracy());
      positionStatSC.addNumber(selectedNr);
      foundDescriptionCountSC++;
      if (!isConsistent) {
        inconsistencyDetectedSC++;
      }
      if (additionalInstances > 0) {
        moreInstancesCountSC++;
        moreInstancesCountStatSC.addNumber(additionalInstances);
      }
      if (bestAcc < 0.9999) {
        nonPerfectCountSC++;
      }
    }
  }
  acceptedStatSC.addNumber(foundDescriptionCountSC);
  rejectedStatSC.addNumber(noSensibleDescriptionCountSC);
  failedStatSC.addNumber(missesCountSC);
  moreInstancesCountStatsSC.add(moreInstancesCountStatSC);
  accStatsSC.add(accStatSC);
  accSelectedStatsSC.add(accSelectedStatSC);
  accAboveThresholdStatsSC.add(accSelectedStatSC);
  positionStatsSC.add(positionStatSC);
  acceptedGlobalStat.addNumber(foundDescriptionCount + foundDescriptionCountSC);
  rejectedGlobalStat.addNumber(noSensibleDescriptionCountSC + noSensibleDescriptionCount);
  failedGlobalStat.addNumber(missesCountSC + missesCount);
  System.out.println(""String_Node_Str"" + ont.getURI());
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + candidatesAboveThresholdCount);
  System.out.println(""String_Node_Str"" + foundDescriptionCount);
  System.out.println(""String_Node_Str"" + missesCount);
  System.out.println(""String_Node_Str"" + noSensibleDescriptionCount);
  System.out.println(""String_Node_Str"" + inconsistencyDetected);
  System.out.println(""String_Node_Str"" + moreInstancesCountStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accSelectedStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accAboveThresholdStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + nonPerfectCount);
  System.out.println(""String_Node_Str"" + positionStat.prettyPrint(""String_Node_Str""));
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + candidatesAboveThresholdCountSC);
  System.out.println(""String_Node_Str"" + foundDescriptionCountSC);
  System.out.println(""String_Node_Str"" + missesCountSC);
  System.out.println(""String_Node_Str"" + noSensibleDescriptionCountSC);
  System.out.println(""String_Node_Str"" + inconsistencyDetectedSC);
  System.out.println(""String_Node_Str"" + moreInstancesCountStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accSelectedStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accAboveThresholdStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + nonPerfectCountSC);
  System.out.println(""String_Node_Str"" + positionStatSC.prettyPrint(""String_Node_Str""));
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (candidatesAboveThresholdCount + candidatesAboveThresholdCountSC));
  System.out.println(""String_Node_Str"" + (foundDescriptionCount + foundDescriptionCountSC));
  System.out.println(""String_Node_Str"" + (missesCount + missesCountSC));
  System.out.println(""String_Node_Str"" + (noSensibleDescriptionCount + noSensibleDescriptionCountSC));
  System.out.println(""String_Node_Str"" + (inconsistencyDetected + inconsistencyDetectedSC));
  System.out.println(""String_Node_Str"" + new Stat(moreInstancesCountStat,moreInstancesCountStatSC).prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + new Stat(accStat,accStatSC).prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + new Stat(accSelectedStat,accSelectedStatSC).prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + new Stat(accAboveThresholdStat,accAboveThresholdStatSC).prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + (nonPerfectCount + nonPerfectCountSC));
  System.out.println(""String_Node_Str"" + new Stat(positionStat,positionStatSC).prettyPrint(""String_Node_Str""));
  System.out.println();
}"
9832,"public EvaluationGUI(File input) throws ComponentInitException, MalformedURLException, LearningProblemUnsupportedException {
  super();
  inputFile=input;
  loadResults(input);
  setTitle(input.getName());
  createUI();
  createCoverageWindow();
  classesTable.setSelectedClass(currentClassIndex);
  graphPanel.initManchesterSyntax(baseURI,prefixes);
  graphPanel2.initManchesterSyntax(baseURI,prefixes);
  graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
  graphPanel2.setConcept(classesTable.getSelectedClass(currentClassIndex));
  if (classesTable.getSelectedClass(currentClassIndex) != null) {
    showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
  }
 else {
    showSuperSuggestions(classesTable.getSelectedClass(currentClassIndex));
  }
  cardLayout.last(cardPanel);
  pack();
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setExtendedState(JFrame.MAXIMIZED_BOTH);
  setVisible(true);
}","public EvaluationGUI(File input) throws ComponentInitException, MalformedURLException, LearningProblemUnsupportedException {
  super();
  inputFile=input;
  loadResults(input);
  setTitle(input.getName());
  createUI();
  createCoverageWindow();
  classesTable.setSelectedClass(currentClassIndex);
  graphPanel.initManchesterSyntax(baseURI,prefixes);
  graphPanel2.initManchesterSyntax(baseURI,prefixes);
  graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
  graphPanel2.setConcept(classesTable.getSelectedClass(currentClassIndex));
  if (defaultEquivalenceMap.get(classesTable.getSelectedClass(currentClassIndex)) != null) {
    showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
  }
 else {
    showSuperSuggestions(classesTable.getSelectedClass(currentClassIndex));
  }
  cardLayout.last(cardPanel);
  pack();
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setExtendedState(JFrame.MAXIMIZED_BOTH);
  setVisible(true);
}"
9833,"public RatingTablePanel(){
  setLayout(new BorderLayout());
  setBorder(BorderFactory.createLineBorder(Color.BLACK));
  table=new ResultTable();
  add(table,BorderLayout.CENTER);
  rating=new RatingPanel();
  add(rating,BorderLayout.EAST);
}","public RatingTablePanel(){
  setLayout(new BorderLayout());
  setBorder(BorderFactory.createLineBorder(Color.BLACK));
  table=new ResultTable();
  table.getColumn(1).setCellRenderer(new MultiLineTableCellRenderer());
  table.setRowHeightEnabled(true);
  add(table,BorderLayout.CENTER);
  rating=new RatingPanel();
  add(rating,BorderLayout.EAST);
}"
9834,"@Override public void actionPerformed(ActionEvent e){
  traceInput();
  if (e.getActionCommand().equals(""String_Node_Str"")) {
    NamedClass nc=classesTable.getSelectedClass(currentClassIndex);
    if (!showingMultiTables) {
    }
    if (showingMultiTables && showingEquivalentSuggestions) {
      if (defaultSuperMap.get(nc) != null) {
        showSuperSuggestions(nc);
        showSingleTable();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
        showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
        showSingleTable();
      }
    }
 else     if (!showingMultiTables && showingEquivalentSuggestions) {
      if (owlEquivalenceStandardMap.get(nc) != null) {
        showMultiTables();
      }
 else       if (defaultSuperMap.get(nc) != null) {
        showSuperSuggestions(nc);
        showSingleTable();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
        if (defaultEquivalenceMap.get(classesTable.getSelectedClass(currentClassIndex)) != null) {
          showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
        }
 else {
          showSuperSuggestions(classesTable.getSelectedClass(currentClassIndex));
        }
        showSingleTable();
      }
    }
 else     if (!showingMultiTables && !showingEquivalentSuggestions) {
      if (owlSuperStandardMap.get(nc) != null) {
        showMultiTables();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        NamedClass newNc=classesTable.getSelectedClass(currentClassIndex);
        graphPanel.setConcept(newNc);
        if (defaultEquivalenceMap.get(newNc) != null) {
          showEquivalentSuggestions(newNc);
        }
 else {
          showSuperSuggestions(newNc);
        }
        showSingleTable();
      }
    }
 else {
      currentClassIndex++;
      classesTable.setSelectedClass(currentClassIndex);
      NamedClass newCl=classesTable.getSelectedClass(currentClassIndex);
      graphPanel.setConcept(newCl);
      if (defaultEquivalenceMap.containsKey(newCl)) {
        showEquivalentSuggestions(newCl);
      }
 else {
        showSuperSuggestions(newCl);
      }
      showSingleTable();
    }
    setFinished();
    resetTablePanels();
  }
 else   if (e.getActionCommand().equals(""String_Node_Str"")) {
    closeDialog();
    saveInput();
  }
}","@Override public void actionPerformed(ActionEvent e){
  traceInput();
  if (e.getActionCommand().equals(""String_Node_Str"")) {
    defaultTab.clearSelection();
    NamedClass nc=classesTable.getSelectedClass(currentClassIndex);
    if (!showingMultiTables) {
    }
    if (showingMultiTables && showingEquivalentSuggestions) {
      if (defaultSuperMap.get(nc) != null) {
        showSuperSuggestions(nc);
        showSingleTable();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
        if (defaultEquivalenceMap.get(classesTable.getSelectedClass(currentClassIndex)) != null) {
          showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
        }
 else {
          showSuperSuggestions(classesTable.getSelectedClass(currentClassIndex));
        }
        showSingleTable();
      }
    }
 else     if (!showingMultiTables && showingEquivalentSuggestions) {
      if (owlEquivalenceStandardMap.get(nc) != null) {
        showMultiTables();
      }
 else       if (defaultSuperMap.get(nc) != null) {
        showSuperSuggestions(nc);
        showSingleTable();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
        if (defaultEquivalenceMap.get(classesTable.getSelectedClass(currentClassIndex)) != null) {
          showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
        }
 else {
          showSuperSuggestions(classesTable.getSelectedClass(currentClassIndex));
        }
        showSingleTable();
      }
    }
 else     if (!showingMultiTables && !showingEquivalentSuggestions) {
      if (owlSuperStandardMap.get(nc) != null) {
        showMultiTables();
      }
 else {
        currentClassIndex++;
        classesTable.setSelectedClass(currentClassIndex);
        NamedClass newNc=classesTable.getSelectedClass(currentClassIndex);
        graphPanel.setConcept(newNc);
        if (defaultEquivalenceMap.get(newNc) != null) {
          showEquivalentSuggestions(newNc);
        }
 else {
          showSuperSuggestions(newNc);
        }
        showSingleTable();
      }
    }
 else {
      currentClassIndex++;
      classesTable.setSelectedClass(currentClassIndex);
      NamedClass newCl=classesTable.getSelectedClass(currentClassIndex);
      graphPanel.setConcept(newCl);
      if (defaultEquivalenceMap.containsKey(newCl)) {
        showEquivalentSuggestions(newCl);
      }
 else {
        showSuperSuggestions(newCl);
      }
      showSingleTable();
    }
    setFinished();
    resetTablePanels();
  }
 else   if (e.getActionCommand().equals(""String_Node_Str"")) {
    closeDialog();
    saveInput();
  }
}"
9835,"private void showSingleTable(){
  defaultTab.clearSelection();
  graphPanel.clear();
  cardLayout.last(cardPanel);
  showingMultiTables=false;
}","private void showSingleTable(){
  graphPanel.clear();
  cardLayout.last(cardPanel);
  showingMultiTables=false;
}"
9836,"private JPanel createSingleTablePanel(){
  JPanel panel=new JPanel(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.BOTH;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.weightx=1.0;
  c.weighty=0.0;
  JPanel tableHolderPanel=new JPanel(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.fill=GridBagConstraints.HORIZONTAL;
  gbc.weightx=1.0;
  defaultTab=new SelectableClassExpressionsTable();
  defaultTab.getSelectionModel().addListSelectionListener(this);
  tableHolderPanel.add(new JScrollPane(defaultTab),gbc);
  graphPanel=new GraphicalCoveragePanel(""String_Node_Str"");
  gbc.weightx=0.0;
  tableHolderPanel.add(graphPanel,gbc);
  panel.add(tableHolderPanel,c);
  inconsistencyLabel=new JLabel();
  panel.add(inconsistencyLabel,c);
  inconsistencyLabel.setText(INCONSISTENCYWARNING);
  inconsistencyLabel.setForeground(SystemColor.control);
  c.weightx=1.0;
  c.weighty=0.0;
  c.ipady=10;
  c.fill=GridBagConstraints.HORIZONTAL;
  noSuggestionCheckBox=new JCheckBox();
  noSuggestionCheckBox.setAction(new AbstractAction(""String_Node_Str""){
    /** 
 */
    private static final long serialVersionUID=5923669465504160583L;
    @Override public void actionPerformed(    ActionEvent e){
      defaultTab.clearSelection();
      defaultTab.removeSelection();
      graphPanel.clear();
      showInconsistencyWarning(false);
    }
  }
);
  panel.add(noSuggestionCheckBox,c);
  alternateSuggestionCheckBox=new JCheckBox();
  alternateSuggestionCheckBox.setAction(new AbstractAction(""String_Node_Str""){
    /** 
 */
    private static final long serialVersionUID=-8642827827310795390L;
    @Override public void actionPerformed(    ActionEvent e){
      defaultTab.clearSelection();
      defaultTab.removeSelection();
      graphPanel.clear();
      showInconsistencyWarning(false);
    }
  }
);
  panel.add(alternateSuggestionCheckBox,c);
  bg=new ButtonGroup();
  bg.add(alternateSuggestionCheckBox);
  bg.add(noSuggestionCheckBox);
  noSuggestionCheckBox.setSelected(true);
  return panel;
}","private JPanel createSingleTablePanel(){
  JPanel panel=new JPanel(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.BOTH;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.weightx=1.0;
  c.weighty=0.0;
  JPanel tableHolderPanel=new JPanel(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.fill=GridBagConstraints.HORIZONTAL;
  gbc.weightx=1.0;
  defaultTab=new SelectableClassExpressionsTable();
  defaultTab.getColumn(1).setCellRenderer(new MultiLineTableCellRenderer());
  defaultTab.getSelectionModel().addListSelectionListener(this);
  defaultTab.setRowHeightEnabled(true);
  tableHolderPanel.add(new JScrollPane(defaultTab),gbc);
  graphPanel=new GraphicalCoveragePanel(""String_Node_Str"");
  gbc.weightx=0.0;
  tableHolderPanel.add(graphPanel,gbc);
  panel.add(tableHolderPanel,c);
  inconsistencyLabel=new JLabel();
  panel.add(inconsistencyLabel,c);
  inconsistencyLabel.setText(INCONSISTENCYWARNING);
  inconsistencyLabel.setForeground(SystemColor.control);
  c.weightx=1.0;
  c.weighty=0.0;
  c.ipady=10;
  c.fill=GridBagConstraints.HORIZONTAL;
  noSuggestionCheckBox=new JCheckBox();
  noSuggestionCheckBox.setAction(new AbstractAction(""String_Node_Str""){
    /** 
 */
    private static final long serialVersionUID=5923669465504160583L;
    @Override public void actionPerformed(    ActionEvent e){
      defaultTab.clearSelection();
      defaultTab.removeSelection();
      graphPanel.clear();
      showInconsistencyWarning(false);
    }
  }
);
  panel.add(noSuggestionCheckBox,c);
  alternateSuggestionCheckBox=new JCheckBox();
  alternateSuggestionCheckBox.setAction(new AbstractAction(""String_Node_Str""){
    /** 
 */
    private static final long serialVersionUID=-8642827827310795390L;
    @Override public void actionPerformed(    ActionEvent e){
      defaultTab.clearSelection();
      defaultTab.removeSelection();
      graphPanel.clear();
      showInconsistencyWarning(false);
    }
  }
);
  panel.add(alternateSuggestionCheckBox,c);
  bg=new ButtonGroup();
  bg.add(alternateSuggestionCheckBox);
  bg.add(noSuggestionCheckBox);
  noSuggestionCheckBox.setSelected(true);
  return panel;
}"
9837,"@Override public void activeOntologyChanged(){
  ontology=OREManager.getInstance().getReasoner().getOWLAPIOntologies();
  reasoner=OREManager.getInstance().getReasoner().getReasoner();
  gen=new CachedExplanationGenerator(ontology,reasoner);
  orderingMap.clear();
  usageChecker=new AxiomUsageChecker(ontology);
}","@Override public void activeOntologyChanged(){
  reasoner=OREManager.getInstance().getReasoner().getReasoner();
  ontology=OREManager.getInstance().getReasoner().getOWLAPIOntologies();
  gen=new CachedExplanationGenerator(reasoner.getLoadedOntologies());
  orderingMap.clear();
  usageChecker=new AxiomUsageChecker(ontology);
}"
9838,"private ExplanationManager(OREManager oreMan){
  OREManager.getInstance().addListener(this);
  this.reasoner=oreMan.getReasoner().getReasoner();
  this.manager=reasoner.getManager();
  this.ontology=reasoner.getLoadedOntologies().iterator().next();
  dataFactory=manager.getOWLDataFactory();
  explanationOrderer=new DefaultExplanationOrderer();
  orderingMap=new HashMap<Explanation,List<Map<OWLAxiom,Integer>>>();
  rootFinder=new RootFinder();
  usageChecker=new AxiomUsageChecker(ontology);
  listeners=new ArrayList<ExplanationManagerListener>();
  gen=new CachedExplanationGenerator(ontology,reasoner);
}","private ExplanationManager(OREManager oreMan){
  OREManager.getInstance().addListener(this);
  this.reasoner=oreMan.getReasoner().getReasoner();
  this.manager=reasoner.getManager();
  this.ontology=oreMan.getReasoner().getOWLAPIOntologies();
  System.out.println(ontology);
  dataFactory=manager.getOWLDataFactory();
  explanationOrderer=new DefaultExplanationOrderer();
  orderingMap=new HashMap<Explanation,List<Map<OWLAxiom,Integer>>>();
  rootFinder=new RootFinder();
  usageChecker=new AxiomUsageChecker(ontology);
  listeners=new ArrayList<ExplanationManagerListener>();
  gen=new CachedExplanationGenerator(reasoner.getLoadedOntologies());
}"
9839,"private Set<Explanation> computeLaconicExplanations(OWLAxiom entailment,int limit) throws ExplanationException {
  Set<Explanation> explanations=laconicExplanationCache.get(entailment);
  Integer lastRequestedSize=lastRequestedLaconicSize.get(entailment);
  if (lastRequestedSize == null) {
    lastRequestedSize=Integer.valueOf(0);
  }
  if (explanations == null || lastRequestedSize.intValue() != -1 && lastRequestedSize.intValue() < limit) {
    OWLOntology module=axiom2Module.get(entailment);
    if (module == null) {
      module=OntologyUtils.getOntologyFromAxioms(ModularityUtils.extractModule(Collections.singleton(ontology),entailment.getSignature(),ModuleType.TOP_OF_BOT));
    }
    axiom2Module.put(entailment,module);
    laconicExpGen=new LaconicExplanationGenerator(manager,new PelletReasonerFactory(),Collections.singleton(module));
    laconicExpGen.setProgressMonitor(TaskManager.getInstance().getStatusBar());
    if (limit == -1) {
      explanations=laconicExpGen.getExplanations(entailment);
    }
 else {
      explanations=laconicExpGen.getExplanations(entailment,limit);
    }
    laconicExplanationCache.put(entailment,laconicExpGen.retrieveAxioms(explanations));
    preciseExplanationCache.put(entailment,explanations);
    lastRequestedLaconicSize.put(entailment,Integer.valueOf(limit));
  }
  return explanations;
}","private Set<Explanation> computeLaconicExplanations(OWLAxiom entailment,int limit) throws ExplanationException {
  Set<Explanation> explanations=laconicExplanationCache.get(entailment);
  Integer lastRequestedSize=lastRequestedLaconicSize.get(entailment);
  if (lastRequestedSize == null) {
    lastRequestedSize=Integer.valueOf(0);
  }
  if (explanations == null || lastRequestedSize.intValue() != -1 && lastRequestedSize.intValue() < limit) {
    OWLOntology module=axiom2Module.get(entailment);
    if (module == null) {
      module=OntologyUtils.getOntologyFromAxioms(ModularityUtils.extractModule(ontologies,entailment.getSignature(),ModuleType.TOP_OF_BOT));
    }
    axiom2Module.put(entailment,module);
    laconicExpGen=new LaconicExplanationGenerator(manager,new PelletReasonerFactory(),Collections.singleton(module));
    laconicExpGen.setProgressMonitor(TaskManager.getInstance().getStatusBar());
    if (limit == -1) {
      explanations=laconicExpGen.getExplanations(entailment);
    }
 else {
      explanations=laconicExpGen.getExplanations(entailment,limit);
    }
    laconicExplanationCache.put(entailment,laconicExpGen.retrieveAxioms(explanations));
    preciseExplanationCache.put(entailment,explanations);
    lastRequestedLaconicSize.put(entailment,Integer.valueOf(limit));
  }
  return explanations;
}"
9840,"private Set<Explanation> computeRegularExplanations(OWLAxiom entailment,int limit) throws ExplanationException {
  Set<Explanation> explanations=regularExplanationCache.get(entailment);
  Integer lastRequestedSize=lastRequestedRegularSize.get(entailment);
  if (lastRequestedSize == null) {
    lastRequestedSize=Integer.valueOf(0);
  }
  if (explanations == null || lastRequestedSize.intValue() != -1 && lastRequestedSize.intValue() < limit) {
    OWLOntology module=axiom2Module.get(entailment);
    if (module == null) {
      module=OntologyUtils.getOntologyFromAxioms(ModularityUtils.extractModule(Collections.singleton(ontology),entailment.getSignature(),ModuleType.TOP_OF_BOT));
    }
    axiom2Module.put(entailment,module);
    regularExpGen=new PelletExplanationGenerator(manager,Collections.singleton(module));
    regularExpGen.setProgressMonitor(TaskManager.getInstance().getStatusBar());
    if (limit == -1) {
      explanations=regularExpGen.getExplanations(entailment);
    }
 else {
      explanations=regularExpGen.getExplanations(entailment,limit);
    }
    regularExplanationCache.put(entailment,explanations);
    lastRequestedRegularSize.put(entailment,Integer.valueOf(limit));
  }
  return explanations;
}","private Set<Explanation> computeRegularExplanations(OWLAxiom entailment,int limit) throws ExplanationException {
  Set<Explanation> explanations=regularExplanationCache.get(entailment);
  Integer lastRequestedSize=lastRequestedRegularSize.get(entailment);
  if (lastRequestedSize == null) {
    lastRequestedSize=Integer.valueOf(0);
  }
  if (explanations == null || lastRequestedSize.intValue() != -1 && lastRequestedSize.intValue() < limit) {
    OWLOntology module=axiom2Module.get(entailment);
    if (module == null) {
      module=OntologyUtils.getOntologyFromAxioms(ModularityUtils.extractModule(ontologies,entailment.getSignature(),ModuleType.TOP_OF_BOT));
    }
    axiom2Module.put(entailment,module);
    regularExpGen=new PelletExplanationGenerator(manager,Collections.singleton(module));
    regularExpGen.setProgressMonitor(TaskManager.getInstance().getStatusBar());
    if (limit == -1) {
      explanations=regularExpGen.getExplanations(entailment);
    }
 else {
      explanations=regularExpGen.getExplanations(entailment,limit);
    }
    regularExplanationCache.put(entailment,explanations);
    lastRequestedRegularSize.put(entailment,Integer.valueOf(limit));
  }
  return explanations;
}"
9841,"public CachedExplanationGenerator(OWLOntology ontology,Reasoner reasoner){
  this.ontology=ontology;
  this.manager=OWLManager.createOWLOntologyManager();
  axiom2Module=new HashMap<OWLAxiom,OWLOntology>();
  regularExplanationCache=new HashMap<OWLAxiom,Set<Explanation>>();
  laconicExplanationCache=new HashMap<OWLAxiom,Set<Explanation>>();
  preciseExplanationCache=new HashMap<OWLAxiom,Set<Explanation>>();
  lastRequestedRegularSize=new HashMap<OWLAxiom,Integer>();
  lastRequestedLaconicSize=new HashMap<OWLAxiom,Integer>();
  RepairManager.getInstance(OREManager.getInstance()).addListener(this);
}","public CachedExplanationGenerator(Set<OWLOntology> ontologies){
  this.ontologies=ontologies;
  this.manager=OWLManager.createOWLOntologyManager();
  axiom2Module=new HashMap<OWLAxiom,OWLOntology>();
  regularExplanationCache=new HashMap<OWLAxiom,Set<Explanation>>();
  laconicExplanationCache=new HashMap<OWLAxiom,Set<Explanation>>();
  preciseExplanationCache=new HashMap<OWLAxiom,Set<Explanation>>();
  lastRequestedRegularSize=new HashMap<OWLAxiom,Integer>();
  lastRequestedLaconicSize=new HashMap<OWLAxiom,Integer>();
  RepairManager.getInstance(OREManager.getInstance()).addListener(this);
}"
9842,"private void setNextButtonEnabled2ConsistentOntology(){
  if (reasoner.isConsistent()) {
    getWizard().setNextFinishButtonEnabled(true);
  }
 else {
    getWizard().setNextFinishButtonEnabled(false);
  }
}","private void setNextButtonEnabled2ConsistentOntology(){
  reasoner.refresh();
  if (reasoner.isConsistent()) {
    getWizard().setNextFinishButtonEnabled(true);
  }
 else {
    getWizard().setNextFinishButtonEnabled(false);
  }
}"
9843,"public static Collection<ConfigOption<?>> createConfigOptions(){
  Collection<ConfigOption<?>> options=new LinkedList<ConfigOption<?>>();
  options.add(CommonConfigOptions.useAllConstructor());
  options.add(CommonConfigOptions.useExistsConstructor());
  options.add(CommonConfigOptions.useHasValueConstructor());
  options.add(CommonConfigOptions.valueFreqencyThreshold());
  options.add(CommonConfigOptions.useCardinalityRestrictions());
  options.add(CommonConfigOptions.cardinalityLimit());
  options.add(CommonConfigOptions.useNegation(false));
  options.add(CommonConfigOptions.useBooleanDatatypes());
  options.add(CommonConfigOptions.useDoubleDatatypes());
  options.add(CommonConfigOptions.maxExecutionTimeInSeconds(10));
  options.add(CommonConfigOptions.getNoisePercentage());
  options.add(CommonConfigOptions.getMaxDepth(7));
  options.add(CommonConfigOptions.maxNrOfResults(10));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  options.add(CommonConfigOptions.getInstanceBasedDisjoints());
  return options;
}","public static Collection<ConfigOption<?>> createConfigOptions(){
  Collection<ConfigOption<?>> options=new LinkedList<ConfigOption<?>>();
  options.add(CommonConfigOptions.useAllConstructor());
  options.add(CommonConfigOptions.useExistsConstructor());
  options.add(CommonConfigOptions.useHasValueConstructor());
  options.add(CommonConfigOptions.useDataHasValueConstructor());
  options.add(CommonConfigOptions.valueFreqencyThreshold());
  options.add(CommonConfigOptions.useCardinalityRestrictions());
  options.add(CommonConfigOptions.cardinalityLimit());
  options.add(CommonConfigOptions.useNegation(false));
  options.add(CommonConfigOptions.useBooleanDatatypes());
  options.add(CommonConfigOptions.useDoubleDatatypes());
  options.add(CommonConfigOptions.maxExecutionTimeInSeconds(10));
  options.add(CommonConfigOptions.getNoisePercentage());
  options.add(CommonConfigOptions.getMaxDepth(7));
  options.add(CommonConfigOptions.maxNrOfResults(10));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  options.add(CommonConfigOptions.getInstanceBasedDisjoints());
  return options;
}"
9844,"public static Collection<ConfigOption<?>> createConfigOptions(){
  Collection<ConfigOption<?>> options=new LinkedList<ConfigOption<?>>();
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  options.add(new StringConfigOption(""String_Node_Str"",""String_Node_Str"",defaultSearchTreeFile));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  StringConfigOption heuristicOption=new StringConfigOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  heuristicOption.setAllowedValues(new String[]{""String_Node_Str"",""String_Node_Str""});
  options.add(heuristicOption);
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  DoubleConfigOption horizExp=new DoubleConfigOption(""String_Node_Str"",""String_Node_Str"",0.6);
  horizExp.setLowerLimit(0.0);
  horizExp.setUpperLimit(1.0);
  options.add(horizExp);
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(CommonConfigOptions.allowedConcepts());
  options.add(CommonConfigOptions.ignoredConcepts());
  options.add(CommonConfigOptions.allowedRoles());
  options.add(CommonConfigOptions.ignoredRoles());
  options.add(CommonConfigOptions.useAllConstructor());
  options.add(CommonConfigOptions.useExistsConstructor());
  options.add(CommonConfigOptions.useHasValueConstructor());
  options.add(CommonConfigOptions.valueFreqencyThreshold());
  options.add(CommonConfigOptions.useCardinalityRestrictions());
  options.add(CommonConfigOptions.cardinalityLimit());
  options.add(CommonConfigOptions.useNegation());
  options.add(CommonConfigOptions.useBooleanDatatypes());
  options.add(CommonConfigOptions.useDoubleDatatypes());
  options.add(CommonConfigOptions.useStringDatatypes());
  options.add(CommonConfigOptions.maxExecutionTimeInSeconds());
  options.add(CommonConfigOptions.minExecutionTimeInSeconds());
  options.add(CommonConfigOptions.guaranteeXgoodDescriptions());
  options.add(CommonConfigOptions.maxClassDescriptionTests());
  options.add(CommonConfigOptions.getLogLevel());
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",usePropernessChecksDefault));
  options.add(CommonConfigOptions.getNoisePercentage());
  options.add(CommonConfigOptions.getTerminateOnNoiseReached());
  options.add(new StringConfigOption(""String_Node_Str"",""String_Node_Str""));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str""));
  options.add(new DoubleConfigOption(""String_Node_Str"",""String_Node_Str"",1.0));
  options.add(new DoubleConfigOption(""String_Node_Str"",""String_Node_Str"",0.0));
  options.add(new IntegerConfigOption(""String_Node_Str"",""String_Node_Str"",0));
  options.add(CommonConfigOptions.getExpansionPenaltyFactor(0.02));
  options.add(CommonConfigOptions.getInstanceBasedDisjoints());
  return options;
}","public static Collection<ConfigOption<?>> createConfigOptions(){
  Collection<ConfigOption<?>> options=new LinkedList<ConfigOption<?>>();
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  options.add(new StringConfigOption(""String_Node_Str"",""String_Node_Str"",defaultSearchTreeFile));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",false));
  StringConfigOption heuristicOption=new StringConfigOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  heuristicOption.setAllowedValues(new String[]{""String_Node_Str"",""String_Node_Str""});
  options.add(heuristicOption);
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  DoubleConfigOption horizExp=new DoubleConfigOption(""String_Node_Str"",""String_Node_Str"",0.6);
  horizExp.setLowerLimit(0.0);
  horizExp.setUpperLimit(1.0);
  options.add(horizExp);
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",true));
  options.add(CommonConfigOptions.allowedConcepts());
  options.add(CommonConfigOptions.ignoredConcepts());
  options.add(CommonConfigOptions.allowedRoles());
  options.add(CommonConfigOptions.ignoredRoles());
  options.add(CommonConfigOptions.useAllConstructor());
  options.add(CommonConfigOptions.useExistsConstructor());
  options.add(CommonConfigOptions.useHasValueConstructor());
  options.add(CommonConfigOptions.useDataHasValueConstructor());
  options.add(CommonConfigOptions.valueFreqencyThreshold());
  options.add(CommonConfigOptions.useCardinalityRestrictions());
  options.add(CommonConfigOptions.cardinalityLimit());
  options.add(CommonConfigOptions.useNegation());
  options.add(CommonConfigOptions.useBooleanDatatypes());
  options.add(CommonConfigOptions.useDoubleDatatypes());
  options.add(CommonConfigOptions.useStringDatatypes());
  options.add(CommonConfigOptions.maxExecutionTimeInSeconds());
  options.add(CommonConfigOptions.minExecutionTimeInSeconds());
  options.add(CommonConfigOptions.guaranteeXgoodDescriptions());
  options.add(CommonConfigOptions.maxClassDescriptionTests());
  options.add(CommonConfigOptions.getLogLevel());
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str"",usePropernessChecksDefault));
  options.add(CommonConfigOptions.getNoisePercentage());
  options.add(CommonConfigOptions.getTerminateOnNoiseReached());
  options.add(new StringConfigOption(""String_Node_Str"",""String_Node_Str""));
  options.add(new BooleanConfigOption(""String_Node_Str"",""String_Node_Str""));
  options.add(new DoubleConfigOption(""String_Node_Str"",""String_Node_Str"",1.0));
  options.add(new DoubleConfigOption(""String_Node_Str"",""String_Node_Str"",0.0));
  options.add(new IntegerConfigOption(""String_Node_Str"",""String_Node_Str"",0));
  options.add(CommonConfigOptions.getExpansionPenaltyFactor(0.02));
  options.add(CommonConfigOptions.getInstanceBasedDisjoints());
  return options;
}"
9845,"public int compareTo(TypedConstant o){
  int datatypeComparision=datatype.getURI().compareTo(datatype.getURI());
  if (datatypeComparision == 0) {
    return literal.compareTo(o.literal);
  }
 else   return datatypeComparision;
}","@Override public int compareTo(Constant o){
  if (o instanceof UntypedConstant) {
    return 1;
  }
  String str=literal + datatype;
  String str2=o.literal + ((TypedConstant)o).datatype;
  return str.compareTo(str2);
}"
9846,"public RhoDRDown(ReasonerComponent reasoningService,ClassHierarchy subHierarchy,ROLComponent2Configurator configurator,boolean applyAllFilter,boolean applyExistsFilter,boolean useAllConstructor,boolean useExistsConstructor,boolean useHasValueConstructor,int valueFrequencyThreshold,boolean useCardinalityRestrictions,boolean useNegation,boolean useBooleanDatatypes,boolean useDoubleDatatypes,NamedClass startClass){
  this.rs=reasoningService;
  this.subHierarchy=subHierarchy;
  this.applyAllFilter=applyAllFilter;
  this.applyExistsFilter=applyExistsFilter;
  this.useAllConstructor=useAllConstructor;
  this.useExistsConstructor=useExistsConstructor;
  this.useHasValueConstructor=useHasValueConstructor;
  this.frequencyThreshold=valueFrequencyThreshold;
  this.useCardinalityRestrictions=useCardinalityRestrictions;
  cardinalityLimit=configurator.getCardinalityLimit();
  this.useNegation=useNegation;
  this.useBooleanDatatypes=useBooleanDatatypes;
  this.useDoubleDatatypes=useDoubleDatatypes;
  useStringDatatypes=configurator.getUseStringDatatypes();
  instanceBasedDisjoints=configurator.getInstanceBasedDisjoints();
  if (startClass != null) {
    this.startClass=startClass;
  }
  init();
}","public RhoDRDown(ReasonerComponent reasoningService,ClassHierarchy subHierarchy,ROLComponent2Configurator configurator,boolean applyAllFilter,boolean applyExistsFilter,boolean useAllConstructor,boolean useExistsConstructor,boolean useHasValueConstructor,int valueFrequencyThreshold,boolean useCardinalityRestrictions,boolean useNegation,boolean useBooleanDatatypes,boolean useDoubleDatatypes,NamedClass startClass){
  this.rs=reasoningService;
  this.subHierarchy=subHierarchy;
  this.applyAllFilter=applyAllFilter;
  this.applyExistsFilter=applyExistsFilter;
  this.useAllConstructor=useAllConstructor;
  this.useExistsConstructor=useExistsConstructor;
  this.useHasValueConstructor=useHasValueConstructor;
  this.frequencyThreshold=valueFrequencyThreshold;
  this.useCardinalityRestrictions=useCardinalityRestrictions;
  cardinalityLimit=configurator.getCardinalityLimit();
  this.useDataHasValueConstructor=configurator.getUseDataHasValueConstructor();
  this.useNegation=useNegation;
  this.useBooleanDatatypes=useBooleanDatatypes;
  this.useDoubleDatatypes=useDoubleDatatypes;
  useStringDatatypes=configurator.getUseStringDatatypes();
  instanceBasedDisjoints=configurator.getInstanceBasedDisjoints();
  if (startClass != null) {
    this.startClass=startClass;
  }
  init();
}"
9847,"public int compare(Description concept1,Description concept2){
  if (concept1 instanceof Nothing) {
    if (concept2 instanceof Nothing)     return 0;
 else     return -1;
  }
 else   if (concept1 instanceof NamedClass) {
    if (concept2 instanceof Nothing)     return 1;
 else     if (concept2 instanceof NamedClass)     return ((NamedClass)concept1).getName().compareTo(((NamedClass)concept2).getName());
 else     return -1;
  }
 else   if (concept1 instanceof BooleanValueRestriction) {
    if (concept2 instanceof Nothing || concept2 instanceof NamedClass) {
      return 1;
    }
 else     if (concept2 instanceof BooleanValueRestriction) {
      int cmp=rc.compare(((BooleanValueRestriction)concept1).getRestrictedPropertyExpresssion(),((BooleanValueRestriction)concept2).getRestrictedPropertyExpresssion());
      if (cmp == 0) {
        boolean val1=((BooleanValueRestriction)concept1).getBooleanValue();
        boolean val2=((BooleanValueRestriction)concept2).getBooleanValue();
        if (val1) {
          if (val2)           return 0;
 else           return 1;
        }
 else {
          if (val2)           return -1;
 else           return 0;
        }
      }
 else       return cmp;
    }
 else     return -1;
  }
 else   if (concept1 instanceof DatatypeSomeRestriction) {
    if (concept2 instanceof Nothing || concept2 instanceof NamedClass || concept2 instanceof BooleanValueRestriction) {
      return 1;
    }
 else     if (concept2 instanceof DatatypeSomeRestriction) {
      DatatypeSomeRestriction dsr=(DatatypeSomeRestriction)concept1;
      DatatypeProperty dp=(DatatypeProperty)dsr.getRestrictedPropertyExpression();
      DatatypeSomeRestriction dsr2=(DatatypeSomeRestriction)concept2;
      DatatypeProperty dp2=(DatatypeProperty)dsr2.getRestrictedPropertyExpression();
      int cmp=rc.compare(dp,dp2);
      if (cmp == 0) {
        SimpleDoubleDataRange dr=(SimpleDoubleDataRange)dsr.getDataRange();
        SimpleDoubleDataRange dr2=(SimpleDoubleDataRange)dsr2.getDataRange();
        if ((dr instanceof DoubleMaxValue && dr2 instanceof DoubleMaxValue) || (dr instanceof DoubleMinValue && dr2 instanceof DoubleMinValue)) {
          double val1=dr.getValue();
          double val2=dr2.getValue();
          if (val1 > val2)           return 1;
 else           if (val1 == val2)           return 0;
 else           return -1;
        }
 else         if (dr instanceof DoubleMaxValue)         return 1;
 else         return -1;
      }
 else       return cmp;
    }
 else     return -1;
  }
 else   if (concept1 instanceof ObjectValueRestriction) {
    if (concept2 instanceof Nothing || concept2 instanceof NamedClass || concept2 instanceof BooleanValueRestriction|| concept2 instanceof DatatypeSomeRestriction) {
      return 1;
    }
 else     if (concept2 instanceof ObjectValueRestriction) {
      int roleCompare=rc.compare(((ObjectValueRestriction)concept1).getRestrictedPropertyExpression(),((ObjectValueRestriction)concept2).getRestrictedPropertyExpression());
      if (roleCompare == 0) {
        Individual value1=((ObjectValueRestriction)concept1).getIndividual();
        Individual value2=((ObjectValueRestriction)concept2).getIndividual();
        return value1.compareTo(value2);
      }
 else {
        return roleCompare;
      }
    }
 else     return -1;
  }
 else   if (concept1 instanceof Thing) {
    if (concept2 instanceof Nothing || concept2 instanceof NamedClass || concept2 instanceof BooleanValueRestriction|| concept2 instanceof DatatypeSomeRestriction|| concept2 instanceof ObjectValueRestriction)     return 1;
 else     if (concept2 instanceof Thing)     return 0;
 else     return -1;
  }
 else   if (concept1 instanceof Negation) {
    if (concept2.getChildren().size() < 1)     return 1;
 else     if (concept2 instanceof Negation)     return compare(concept1.getChild(0),concept2.getChild(0));
 else     return -1;
  }
 else   if (concept1 instanceof ObjectSomeRestriction) {
    if (concept2.getChildren().size() < 1 || concept2 instanceof Negation)     return 1;
 else     if (concept2 instanceof ObjectSomeRestriction) {
      int roleCompare=rc.compare(((ObjectQuantorRestriction)concept1).getRole(),((ObjectQuantorRestriction)concept2).getRole());
      if (roleCompare == 0)       return compare(concept1.getChild(0),concept2.getChild(0));
 else       return roleCompare;
    }
 else     return -1;
  }
 else   if (concept1 instanceof ObjectAllRestriction) {
    if (concept2.getChildren().size() < 1 || concept2 instanceof Negation || concept2 instanceof ObjectSomeRestriction)     return 1;
 else     if (concept2 instanceof ObjectAllRestriction) {
      int roleCompare=rc.compare(((ObjectQuantorRestriction)concept1).getRole(),((ObjectQuantorRestriction)concept2).getRole());
      if (roleCompare == 0)       return compare(concept1.getChild(0),concept2.getChild(0));
 else       return roleCompare;
    }
 else     return -1;
  }
 else   if (concept1 instanceof ObjectMinCardinalityRestriction) {
    if (concept2.getChildren().size() < 1 || concept2 instanceof Negation || concept2 instanceof ObjectQuantorRestriction)     return 1;
 else     if (concept2 instanceof ObjectMinCardinalityRestriction) {
      int roleCompare=rc.compare(((ObjectCardinalityRestriction)concept1).getRole(),((ObjectCardinalityRestriction)concept2).getRole());
      if (roleCompare == 0) {
        Integer number1=((ObjectCardinalityRestriction)concept1).getNumber();
        Integer number2=((ObjectCardinalityRestriction)concept2).getNumber();
        int numberCompare=number1.compareTo(number2);
        if (numberCompare == 0)         return compare(concept1.getChild(0),concept2.getChild(0));
 else         return numberCompare;
      }
 else       return roleCompare;
    }
 else     return -1;
  }
 else   if (concept1 instanceof ObjectMaxCardinalityRestriction) {
    if (concept2.getChildren().size() < 1 || concept2 instanceof Negation || concept2 instanceof ObjectQuantorRestriction || concept2 instanceof ObjectMinCardinalityRestriction)     return 1;
 else     if (concept2 instanceof ObjectMaxCardinalityRestriction) {
      int roleCompare=rc.compare(((ObjectCardinalityRestriction)concept1).getRole(),((ObjectCardinalityRestriction)concept2).getRole());
      if (roleCompare == 0) {
        Integer number1=((ObjectCardinalityRestriction)concept1).getNumber();
        Integer number2=((ObjectCardinalityRestriction)concept2).getNumber();
        int numberCompare=number1.compareTo(number2);
        if (numberCompare == 0)         return compare(concept1.getChild(0),concept2.getChild(0));
 else         return numberCompare;
      }
 else       return roleCompare;
    }
 else     return -1;
  }
 else   if (concept1 instanceof Intersection) {
    if (concept2.getChildren().size() < 2)     return 1;
 else     if (concept2 instanceof Intersection) {
      int nrOfChildrenConcept1=concept1.getChildren().size();
      int nrOfChildrenConcept2=concept2.getChildren().size();
      if (nrOfChildrenConcept1 > nrOfChildrenConcept2)       return 1;
 else       if (nrOfChildrenConcept1 == nrOfChildrenConcept2) {
        for (int i=0; i < nrOfChildrenConcept1; i++) {
          int compareValue=compare(concept1.getChild(i),concept2.getChild(i));
          if (compareValue > 0)           return 1;
 else           if (compareValue < 0)           return -1;
        }
        return 0;
      }
 else       return -1;
    }
 else     return -1;
  }
 else   if (concept1 instanceof Union) {
    if (concept2.getChildren().size() < 2 || concept2 instanceof Intersection)     return 1;
 else     if (concept2 instanceof Union) {
      int nrOfChildrenConcept1=concept1.getChildren().size();
      int nrOfChildrenConcept2=concept2.getChildren().size();
      if (nrOfChildrenConcept1 > nrOfChildrenConcept2)       return 1;
 else       if (nrOfChildrenConcept1 == nrOfChildrenConcept2) {
        for (int i=0; i < nrOfChildrenConcept1; i++) {
          int compareValue=compare(concept1.getChild(i),concept2.getChild(i));
          if (compareValue > 0)           return 1;
 else           if (compareValue < 0)           return -1;
        }
        return 0;
      }
 else       return -1;
    }
 else     return -1;
  }
 else   throw new RuntimeException(concept1.toString());
}","public int compare(Description concept1,Description concept2){
  if (concept1 instanceof Nothing) {
    if (concept2 instanceof Nothing)     return 0;
 else     return -1;
  }
 else   if (concept1 instanceof NamedClass) {
    if (concept2 instanceof Nothing)     return 1;
 else     if (concept2 instanceof NamedClass)     return ((NamedClass)concept1).getName().compareTo(((NamedClass)concept2).getName());
 else     return -1;
  }
 else   if (concept1 instanceof BooleanValueRestriction) {
    if (concept2 instanceof Nothing || concept2 instanceof NamedClass) {
      return 1;
    }
 else     if (concept2 instanceof BooleanValueRestriction) {
      int cmp=rc.compare(((BooleanValueRestriction)concept1).getRestrictedPropertyExpresssion(),((BooleanValueRestriction)concept2).getRestrictedPropertyExpresssion());
      if (cmp == 0) {
        boolean val1=((BooleanValueRestriction)concept1).getBooleanValue();
        boolean val2=((BooleanValueRestriction)concept2).getBooleanValue();
        if (val1) {
          if (val2)           return 0;
 else           return 1;
        }
 else {
          if (val2)           return -1;
 else           return 0;
        }
      }
 else       return cmp;
    }
 else     return -1;
  }
 else   if (concept1 instanceof DatatypeSomeRestriction) {
    if (concept2 instanceof Nothing || concept2 instanceof NamedClass || concept2 instanceof BooleanValueRestriction) {
      return 1;
    }
 else     if (concept2 instanceof DatatypeSomeRestriction) {
      DatatypeSomeRestriction dsr=(DatatypeSomeRestriction)concept1;
      DatatypeProperty dp=(DatatypeProperty)dsr.getRestrictedPropertyExpression();
      DatatypeSomeRestriction dsr2=(DatatypeSomeRestriction)concept2;
      DatatypeProperty dp2=(DatatypeProperty)dsr2.getRestrictedPropertyExpression();
      int cmp=rc.compare(dp,dp2);
      if (cmp == 0) {
        SimpleDoubleDataRange dr=(SimpleDoubleDataRange)dsr.getDataRange();
        SimpleDoubleDataRange dr2=(SimpleDoubleDataRange)dsr2.getDataRange();
        if ((dr instanceof DoubleMaxValue && dr2 instanceof DoubleMaxValue) || (dr instanceof DoubleMinValue && dr2 instanceof DoubleMinValue)) {
          double val1=dr.getValue();
          double val2=dr2.getValue();
          if (val1 > val2)           return 1;
 else           if (val1 == val2)           return 0;
 else           return -1;
        }
 else         if (dr instanceof DoubleMaxValue)         return 1;
 else         return -1;
      }
 else       return cmp;
    }
 else     return -1;
  }
 else   if (concept1 instanceof ObjectValueRestriction) {
    if (concept2 instanceof Nothing || concept2 instanceof NamedClass || concept2 instanceof BooleanValueRestriction|| concept2 instanceof DatatypeSomeRestriction) {
      return 1;
    }
 else     if (concept2 instanceof ObjectValueRestriction) {
      int roleCompare=rc.compare(((ObjectValueRestriction)concept1).getRestrictedPropertyExpression(),((ObjectValueRestriction)concept2).getRestrictedPropertyExpression());
      if (roleCompare == 0) {
        Individual value1=((ObjectValueRestriction)concept1).getIndividual();
        Individual value2=((ObjectValueRestriction)concept2).getIndividual();
        return value1.compareTo(value2);
      }
 else {
        return roleCompare;
      }
    }
 else     return -1;
  }
 else   if (concept1 instanceof DatatypeValueRestriction) {
    if (concept2 instanceof Nothing || concept2 instanceof NamedClass || concept2 instanceof BooleanValueRestriction|| concept2 instanceof DatatypeSomeRestriction|| concept2 instanceof ObjectValueRestriction) {
      return 1;
    }
 else     if (concept2 instanceof DatatypeValueRestriction) {
      int roleCompare=rc.compare(((DatatypeValueRestriction)concept1).getRestrictedPropertyExpression(),((DatatypeValueRestriction)concept2).getRestrictedPropertyExpression());
      if (roleCompare == 0) {
        Constant value1=((DatatypeValueRestriction)concept1).getValue();
        Constant value2=((DatatypeValueRestriction)concept2).getValue();
        return value1.compareTo(value2);
      }
 else {
        return roleCompare;
      }
    }
 else     return -1;
  }
 else   if (concept1 instanceof Thing) {
    if (concept2 instanceof Nothing || concept2 instanceof NamedClass || concept2 instanceof BooleanValueRestriction|| concept2 instanceof DatatypeSomeRestriction|| concept2 instanceof ObjectValueRestriction|| concept2 instanceof DatatypeValueRestriction)     return 1;
 else     if (concept2 instanceof Thing)     return 0;
 else     return -1;
  }
 else   if (concept1 instanceof Negation) {
    if (concept2.getChildren().size() < 1)     return 1;
 else     if (concept2 instanceof Negation)     return compare(concept1.getChild(0),concept2.getChild(0));
 else     return -1;
  }
 else   if (concept1 instanceof ObjectSomeRestriction) {
    if (concept2.getChildren().size() < 1 || concept2 instanceof Negation)     return 1;
 else     if (concept2 instanceof ObjectSomeRestriction) {
      int roleCompare=rc.compare(((ObjectQuantorRestriction)concept1).getRole(),((ObjectQuantorRestriction)concept2).getRole());
      if (roleCompare == 0)       return compare(concept1.getChild(0),concept2.getChild(0));
 else       return roleCompare;
    }
 else     return -1;
  }
 else   if (concept1 instanceof ObjectAllRestriction) {
    if (concept2.getChildren().size() < 1 || concept2 instanceof Negation || concept2 instanceof ObjectSomeRestriction)     return 1;
 else     if (concept2 instanceof ObjectAllRestriction) {
      int roleCompare=rc.compare(((ObjectQuantorRestriction)concept1).getRole(),((ObjectQuantorRestriction)concept2).getRole());
      if (roleCompare == 0)       return compare(concept1.getChild(0),concept2.getChild(0));
 else       return roleCompare;
    }
 else     return -1;
  }
 else   if (concept1 instanceof ObjectMinCardinalityRestriction) {
    if (concept2.getChildren().size() < 1 || concept2 instanceof Negation || concept2 instanceof ObjectQuantorRestriction)     return 1;
 else     if (concept2 instanceof ObjectMinCardinalityRestriction) {
      int roleCompare=rc.compare(((ObjectCardinalityRestriction)concept1).getRole(),((ObjectCardinalityRestriction)concept2).getRole());
      if (roleCompare == 0) {
        Integer number1=((ObjectCardinalityRestriction)concept1).getNumber();
        Integer number2=((ObjectCardinalityRestriction)concept2).getNumber();
        int numberCompare=number1.compareTo(number2);
        if (numberCompare == 0)         return compare(concept1.getChild(0),concept2.getChild(0));
 else         return numberCompare;
      }
 else       return roleCompare;
    }
 else     return -1;
  }
 else   if (concept1 instanceof ObjectMaxCardinalityRestriction) {
    if (concept2.getChildren().size() < 1 || concept2 instanceof Negation || concept2 instanceof ObjectQuantorRestriction || concept2 instanceof ObjectMinCardinalityRestriction)     return 1;
 else     if (concept2 instanceof ObjectMaxCardinalityRestriction) {
      int roleCompare=rc.compare(((ObjectCardinalityRestriction)concept1).getRole(),((ObjectCardinalityRestriction)concept2).getRole());
      if (roleCompare == 0) {
        Integer number1=((ObjectCardinalityRestriction)concept1).getNumber();
        Integer number2=((ObjectCardinalityRestriction)concept2).getNumber();
        int numberCompare=number1.compareTo(number2);
        if (numberCompare == 0)         return compare(concept1.getChild(0),concept2.getChild(0));
 else         return numberCompare;
      }
 else       return roleCompare;
    }
 else     return -1;
  }
 else   if (concept1 instanceof Intersection) {
    if (concept2.getChildren().size() < 2)     return 1;
 else     if (concept2 instanceof Intersection) {
      int nrOfChildrenConcept1=concept1.getChildren().size();
      int nrOfChildrenConcept2=concept2.getChildren().size();
      if (nrOfChildrenConcept1 > nrOfChildrenConcept2)       return 1;
 else       if (nrOfChildrenConcept1 == nrOfChildrenConcept2) {
        for (int i=0; i < nrOfChildrenConcept1; i++) {
          int compareValue=compare(concept1.getChild(i),concept2.getChild(i));
          if (compareValue > 0)           return 1;
 else           if (compareValue < 0)           return -1;
        }
        return 0;
      }
 else       return -1;
    }
 else     return -1;
  }
 else   if (concept1 instanceof Union) {
    if (concept2.getChildren().size() < 2 || concept2 instanceof Intersection)     return 1;
 else     if (concept2 instanceof Union) {
      int nrOfChildrenConcept1=concept1.getChildren().size();
      int nrOfChildrenConcept2=concept2.getChildren().size();
      if (nrOfChildrenConcept1 > nrOfChildrenConcept2)       return 1;
 else       if (nrOfChildrenConcept1 == nrOfChildrenConcept2) {
        for (int i=0; i < nrOfChildrenConcept1; i++) {
          int compareValue=compare(concept1.getChild(i),concept2.getChild(i));
          if (compareValue > 0)           return 1;
 else           if (compareValue < 0)           return -1;
        }
        return 0;
      }
 else       return -1;
    }
 else     return -1;
  }
 else   throw new RuntimeException(concept1.toString());
}"
9848,"public double getAccuracyOrTooWeakExact(Description description,double noise){
  nanoStartTime=System.nanoTime();
  if (heuristic.equals(HeuristicType.JACCARD)) {
    TreeSet<Individual> coveredInstancesSet=new TreeSet<Individual>();
    for (    Individual ind : classInstances) {
      if (reasoner.hasType(description,ind)) {
        coveredInstancesSet.add(ind);
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    if (coveredInstancesSet.size() / (double)classInstances.size() <= 1 - noise) {
      return -1;
    }
    TreeSet<Individual> additionalInstancesSet=new TreeSet<Individual>();
    for (    Individual ind : superClassInstances) {
      if (reasoner.hasType(description,ind)) {
        additionalInstancesSet.add(ind);
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    Set<Individual> union=Helper.union(classInstancesSet,additionalInstancesSet);
    return (1 - (union.size() - coveredInstancesSet.size()) / (double)union.size());
  }
 else   if (heuristic.equals(HeuristicType.OWN) || heuristic.equals(HeuristicType.FMEASURE) || heuristic.equals(HeuristicType.PRED_ACC)) {
    int additionalInstances=0;
    for (    Individual ind : superClassInstances) {
      if (reasoner.hasType(description,ind)) {
        additionalInstances++;
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    int coveredInstances=0;
    for (    Individual ind : classInstances) {
      if (reasoner.hasType(description,ind)) {
        coveredInstances++;
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    double recall=coveredInstances / (double)classInstances.size();
    double precision=(additionalInstances + coveredInstances == 0) ? 0 : coveredInstances / (double)(coveredInstances + additionalInstances);
    if (heuristic.equals(HeuristicType.OWN)) {
      if ((coverageFactor * recall + 1) / (double)(coverageFactor + 1) < (1 - noise)) {
        return -1;
      }
 else {
        return getAccuracy(recall,precision);
      }
    }
 else     if (heuristic.equals(HeuristicType.FMEASURE)) {
      if (((1 + Math.sqrt(coverageFactor)) * recall) / (Math.sqrt(coverageFactor) + 1) < 1 - noise) {
        return -1;
      }
 else {
        return getFMeasure(recall,precision);
      }
    }
 else     if (heuristic.equals(HeuristicType.PRED_ACC)) {
      if ((coverageFactor * coveredInstances + superClassInstances.size()) / (double)(coverageFactor * classInstances.size() + superClassInstances.size()) < 1 - noise) {
        return -1;
      }
 else {
        return (coverageFactor * coveredInstances + superClassInstances.size() - additionalInstances) / (double)(coverageFactor * classInstances.size() + superClassInstances.size());
      }
    }
  }
 else   if (heuristic.equals(HeuristicType.GEN_FMEASURE)) {
    TreeSet<Individual> icPos=new TreeSet<Individual>();
    TreeSet<Individual> icNeg=new TreeSet<Individual>();
    Description descriptionNeg=new Negation(description);
    for (    Individual ind : classAndSuperClassInstances) {
      if (reasoner.hasType(description,ind)) {
        icPos.add(ind);
      }
 else       if (reasoner.hasType(descriptionNeg,ind)) {
        icNeg.add(ind);
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    Set<Individual> tmp1Pos=Helper.intersection(icPos,classInstancesSet);
    Set<Individual> tmp1Neg=Helper.intersection(icNeg,negatedClassInstances);
    int tmp1Size=tmp1Pos.size() + tmp1Neg.size();
    int icSize=icPos.size() + icNeg.size();
    double prec=(icSize == 0) ? 0 : tmp1Size / (double)icSize;
    double rec=tmp1Size / (double)(classInstances.size() + negatedClassInstances.size());
    if (rec <= 0.01) {
      return -1;
    }
    return getFMeasure(rec,prec);
  }
  throw new Error(""String_Node_Str"");
}","public double getAccuracyOrTooWeakExact(Description description,double noise){
  nanoStartTime=System.nanoTime();
  if (heuristic.equals(HeuristicType.JACCARD)) {
    TreeSet<Individual> coveredInstancesSet=new TreeSet<Individual>();
    for (    Individual ind : classInstances) {
      if (reasoner.hasType(description,ind)) {
        coveredInstancesSet.add(ind);
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    if (coveredInstancesSet.size() / (double)classInstances.size() <= 1 - noise) {
      return -1;
    }
    TreeSet<Individual> additionalInstancesSet=new TreeSet<Individual>();
    for (    Individual ind : superClassInstances) {
      if (reasoner.hasType(description,ind)) {
        additionalInstancesSet.add(ind);
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    Set<Individual> union=Helper.union(classInstancesSet,additionalInstancesSet);
    return (1 - (union.size() - coveredInstancesSet.size()) / (double)union.size());
  }
 else   if (heuristic.equals(HeuristicType.OWN) || heuristic.equals(HeuristicType.FMEASURE) || heuristic.equals(HeuristicType.PRED_ACC)) {
    int additionalInstances=0;
    for (    Individual ind : superClassInstances) {
      if (reasoner.hasType(description,ind)) {
        additionalInstances++;
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    int coveredInstances=0;
    for (    Individual ind : classInstances) {
      if (reasoner.hasType(description,ind)) {
        coveredInstances++;
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    double recall=coveredInstances / (double)classInstances.size();
    double precision=(additionalInstances + coveredInstances == 0) ? 0 : coveredInstances / (double)(coveredInstances + additionalInstances);
    if (heuristic.equals(HeuristicType.OWN)) {
      if ((coverageFactor * recall + 1) / (double)(coverageFactor + 1) < (1 - noise)) {
        return -1;
      }
 else {
        return getAccuracy(recall,precision);
      }
    }
 else     if (heuristic.equals(HeuristicType.FMEASURE)) {
      if (((1 + Math.sqrt(coverageFactor)) * recall) / (Math.sqrt(coverageFactor) + 1) < 1 - noise) {
        return -1;
      }
 else {
        return getFMeasure(recall,precision);
      }
    }
 else     if (heuristic.equals(HeuristicType.PRED_ACC)) {
      if ((coverageFactor * coveredInstances + superClassInstances.size()) / (double)(coverageFactor * classInstances.size() + superClassInstances.size()) < 1 - noise) {
        return -1;
      }
 else {
        return (coverageFactor * coveredInstances + superClassInstances.size() - additionalInstances) / (double)(coverageFactor * classInstances.size() + superClassInstances.size());
      }
    }
  }
 else   if (heuristic.equals(HeuristicType.GEN_FMEASURE)) {
    TreeSet<Individual> icPos=new TreeSet<Individual>();
    TreeSet<Individual> icNeg=new TreeSet<Individual>();
    Description descriptionNeg=new Negation(description);
    for (    Individual ind : classAndSuperClassInstances) {
      if (reasoner.hasType(description,ind)) {
        icPos.add(ind);
      }
 else       if (reasoner.hasType(descriptionNeg,ind)) {
        icNeg.add(ind);
      }
      if (terminationTimeExpired()) {
        return 0;
      }
    }
    Set<Individual> tmp1Pos=Helper.intersection(icPos,classInstancesSet);
    Set<Individual> tmp1Neg=Helper.intersection(icNeg,negatedClassInstances);
    int tmp1Size=tmp1Pos.size() + tmp1Neg.size();
    int icSize=icPos.size() + icNeg.size();
    double prec=(icSize == 0) ? 0 : tmp1Size / (double)icSize;
    double rec=tmp1Size / (double)(classInstances.size() + negatedClassInstances.size());
    if (rec <= 0.0000001) {
      return -1;
    }
    return getFMeasure(rec,prec);
  }
  throw new Error(""String_Node_Str"");
}"
9849,"public EvaluationGUI(File input) throws ComponentInitException, MalformedURLException, LearningProblemUnsupportedException {
  super();
  loadResults(input);
  setTitle(input.getName());
  createUI();
  createCoverageWindow();
  classesTable.setSelectedClass(currentClassIndex);
  graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
  graphPanel2.setConcept(classesTable.getSelectedClass(currentClassIndex));
  showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
  cardLayout.first(cardPanel);
  pack();
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setExtendedState(JFrame.MAXIMIZED_BOTH);
  setVisible(true);
}","public EvaluationGUI(File input) throws ComponentInitException, MalformedURLException, LearningProblemUnsupportedException {
  super();
  loadResults(input);
  setTitle(input.getName());
  createUI();
  createCoverageWindow();
  classesTable.setSelectedClass(currentClassIndex);
  graphPanel.setConcept(classesTable.getSelectedClass(currentClassIndex));
  graphPanel2.setConcept(classesTable.getSelectedClass(currentClassIndex));
  showEquivalentSuggestions(classesTable.getSelectedClass(currentClassIndex));
  cardLayout.last(cardPanel);
  pack();
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setExtendedState(JFrame.MAXIMIZED_BOTH);
  setVisible(true);
}"
9850,"private void showMultiTables(){
  cardLayout.last(cardPanel);
  showingMultiTables=true;
}","private void showMultiTables(){
  cardLayout.first(cardPanel);
  showingMultiTables=true;
}"
9851,"private void showSingleTable(){
  defaultTab.clearSelection();
  graphPanel.clear();
  cardLayout.first(cardPanel);
  showingMultiTables=false;
}","private void showSingleTable(){
  defaultTab.clearSelection();
  graphPanel.clear();
  cardLayout.last(cardPanel);
  showingMultiTables=false;
}"
9852,"private JPanel createMainPanel(){
  JPanel messageTablesPanel=new JPanel();
  messageTablesPanel.setLayout(new BorderLayout());
  messageLabel=new JLabel();
  messageLabel.addMouseMotionListener(this);
  messageTablesPanel.add(messageLabel,BorderLayout.NORTH);
  cardPanel=new JPanel();
  cardPanel.setBorder(new EmptyBorder(new Insets(5,10,5,10)));
  cardLayout=new CardLayout();
  cardPanel.add(createSingleTablePanel(),SINGLETABLEVIEW);
  cardPanel.add(createMultiTablesPanel(),MULTITABLEVIEW);
  cardPanel.setLayout(cardLayout);
  messageTablesPanel.add(cardPanel,BorderLayout.CENTER);
  return messageTablesPanel;
}","private JPanel createMainPanel(){
  JPanel messageTablesPanel=new JPanel();
  messageTablesPanel.setLayout(new BorderLayout());
  messageLabel=new JLabel();
  messageLabel.addMouseMotionListener(this);
  messageTablesPanel.add(messageLabel,BorderLayout.NORTH);
  cardPanel=new JPanel();
  cardPanel.setBorder(new EmptyBorder(new Insets(5,10,5,10)));
  cardLayout=new CardLayout();
  cardPanel.add(createMultiTablesPanel(),MULTITABLEVIEW);
  cardPanel.add(createSingleTablePanel(),SINGLETABLEVIEW);
  cardPanel.setLayout(cardLayout);
  messageTablesPanel.add(cardPanel,BorderLayout.CENTER);
  return messageTablesPanel;
}"
9853,"private JPanel createMultiTablesPanel(){
  JPanel tablesHolderPanel=new JPanel();
  tablesHolderPanel.setLayout(new GridLayout(5,2,5,5));
  tab1=new ResultTable();
  tab1.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab1));
  tab2=new ResultTable();
  tab2.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab2));
  tab3=new ResultTable();
  tab3.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab3));
  tab4=new ResultTable();
  tab4.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab4));
  tab5=new ResultTable();
  tab5.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab5));
  tab6=new ResultTable();
  tab6.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab6));
  tab7=new ResultTable();
  tab7.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab7));
  tab8=new ResultTable();
  tab8.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab8));
  tab9=new ResultTable();
  tab9.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab9));
  tab10=new ResultTable();
  tab10.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab10));
  return tablesHolderPanel;
}","private JPanel createMultiTablesPanel(){
  JPanel tablesHolderPanel=new JPanel();
  tablesHolderPanel.setLayout(new GridLayout(5,2,5,5));
  tablesHolderPanel.addMouseMotionListener(this);
  tab1=new ResultTable();
  tab1.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab1));
  tab2=new ResultTable();
  tab2.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab2));
  tab3=new ResultTable();
  tab3.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab3));
  tab4=new ResultTable();
  tab4.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab4));
  tab5=new ResultTable();
  tab5.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab5));
  tab6=new ResultTable();
  tab6.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab6));
  tab7=new ResultTable();
  tab7.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab7));
  tab8=new ResultTable();
  tab8.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab8));
  tab9=new ResultTable();
  tab9.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab9));
  tab10=new ResultTable();
  tab10.addMouseMotionListener(this);
  tablesHolderPanel.add(createSelectablePanel(tab10));
  return tablesHolderPanel;
}"
9854,"@Override public void mouseMoved(MouseEvent e){
  ResultTable result=((ResultTable)e.getSource());
  int column=result.columnAtPoint(e.getPoint());
  int row=result.rowAtPoint(e.getPoint());
  EvaluatedDescriptionClass ec=result.getValueAtRow(row);
  if (column == 0) {
    graphPanel2.clear();
    graphPanel2.setNewClassDescription(ec);
    showCoveragePanel(true);
  }
 else {
    showCoveragePanel(false);
  }
}","@Override public void mouseMoved(MouseEvent e){
  if (e.getSource() instanceof ResultTable) {
    ResultTable result=((ResultTable)e.getSource());
    int column=result.columnAtPoint(e.getPoint());
    int row=result.rowAtPoint(e.getPoint());
    if (column == 0 && row >= 0 && row <= 9) {
      EvaluatedDescriptionClass ec=result.getValueAtRow(row);
      graphPanel2.clear();
      graphPanel2.setNewClassDescription(ec);
      showCoveragePanel(true);
    }
 else {
      showCoveragePanel(false);
    }
  }
 else {
    showCoveragePanel(false);
  }
}"
9855,"/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  labels=""String_Node_Str"";
  individualSize=0;
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel(model,this);
  learnerPanel=new JPanel();
  hintPanel=new JPanel(new FlowLayout());
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JTextPane();
  wikiPane.setContentType(""String_Node_Str"");
  wikiPane.setBackground(learnerScroll.getBackground());
  wikiPane.setText(WIKI_STRING);
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  URL helpIconUrl=this.getClass().getResource(""String_Node_Str"");
  helpIcon=new ImageIcon(helpIconUrl);
  helpButton=new JButton(helpIcon);
  helpButton.setPreferredSize(new Dimension(20,20));
  helpButton.setName(""String_Node_Str"");
  helpButton.addActionListener(action);
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  stat=new StatusBar();
  hint=new JTextPane();
  hint.setBackground(learnerScroll.getBackground());
  hint.setContentType(""String_Node_Str"");
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.addHyperlinkListener(hyperHandler);
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(260,30));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  sugPanelHandler=new SuggestClassPanelHandler(this,model,action);
  sugPanel.addSuggestPanelMouseListener(sugPanelHandler);
  sugPanel.getSuggestList().addListSelectionListener(sugPanelHandler);
  hyperHandler=new HyperLinkHandler();
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}","/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  labels=""String_Node_Str"";
  individualSize=0;
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel(model,this);
  learnerPanel=new JPanel();
  hintPanel=new JPanel(new FlowLayout());
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JTextPane();
  wikiPane.setContentType(""String_Node_Str"");
  wikiPane.setBackground(learnerScroll.getBackground());
  wikiPane.setEditable(false);
  wikiPane.setText(WIKI_STRING);
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  URL helpIconUrl=this.getClass().getResource(""String_Node_Str"");
  helpIcon=new ImageIcon(helpIconUrl);
  helpButton=new JButton(helpIcon);
  helpButton.setPreferredSize(new Dimension(20,20));
  helpButton.setName(""String_Node_Str"");
  helpButton.addActionListener(action);
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  stat=new StatusBar();
  hint=new JTextPane();
  hint.setBackground(learnerScroll.getBackground());
  hint.setContentType(""String_Node_Str"");
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.addHyperlinkListener(hyperHandler);
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(260,30));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  sugPanelHandler=new SuggestClassPanelHandler(this,model,action);
  sugPanel.addSuggestPanelMouseListener(sugPanelHandler);
  sugPanel.getSuggestList().addListSelectionListener(sugPanelHandler);
  hyperHandler=new HyperLinkHandler();
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}"
9856,"public HyperLinkHandler(){
  try {
    launcher=new BrowserLauncher();
  }
 catch (  BrowserLaunchingInitializingException e) {
    e.printStackTrace();
  }
catch (  UnsupportedOperatingSystemException e) {
    e.printStackTrace();
  }
}","/** 
 * This is the constructor that instantiate the BrowserLauncher.
 */
public HyperLinkHandler(){
  try {
    launcher=new BrowserLauncher();
  }
 catch (  BrowserLaunchingInitializingException e) {
    e.printStackTrace();
  }
catch (  UnsupportedOperatingSystemException e) {
    e.printStackTrace();
  }
}"
9857,"@Override public void mouseMoved(MouseEvent m){
  if (m.getX() >= panel.getX1() + panel.getShiftCovered() && m.getX() <= panel.getX2() + panel.getShiftCovered() && m.getY() >= panel.getY1() && m.getY() <= panel.getY2() || m.getX() >= panel.getX1() + panel.getShiftNewConcept() && m.getX() <= panel.getX2() + panel.getShiftNewConcept() && m.getY() >= panel.getY1() && m.getY() <= panel.getY2() || m.getX() >= panel.getX1() + panel.getShiftNewConceptX() && m.getX() <= panel.getX2() + panel.getShiftNewConceptX() && m.getY() >= panel.getY1() + panel.getShiftNewConcept() && m.getY() <= panel.getY2() + panel.getShiftNewConcept() || m.getX() >= panel.getX1() - panel.getShiftOldConcept() && m.getX() <= panel.getX2() - panel.getShiftOldConcept() && m.getY() >= panel.getY1() && m.getY() <= panel.getY2()) {
    panel.getGraphicalCoveragePanel().setToolTipText(""String_Node_Str"");
  }
  Vector<IndividualPoint> v=panel.getIndividualVector();
  FastInstanceChecker reasoner=model.getReasoner();
  for (int i=0; i < v.size(); i++) {
    if (v.get(i).getXAxis() >= m.getX() - 5 && v.get(i).getXAxis() <= m.getX() + 5 && v.get(i).getYAxis() >= m.getY() - 5 && v.get(i).getYAxis() <= m.getY() + 5) {
      String individualInformation=""String_Node_Str"" + v.get(i).getIndividualName().toString();
      Set<NamedClass> types=reasoner.getTypes(v.get(i).getDLLearnerIndividual());
      individualInformation+=""String_Node_Str"";
      for (      NamedClass dlLearnerClass : types) {
        individualInformation+=dlLearnerClass.toManchesterSyntaxString(v.get(i).getBaseUri(),null) + ""String_Node_Str"";
      }
      Map<ObjectProperty,Set<Individual>> objectProperties=reasoner.getObjectPropertyRelationships(v.get(i).getDLLearnerIndividual());
      Set<ObjectProperty> key=objectProperties.keySet();
      individualInformation+=""String_Node_Str"";
      for (      ObjectProperty objectProperty : key) {
        Set<Individual> indiSet=objectProperties.get(objectProperty);
        individualInformation=individualInformation + objectProperty.toManchesterSyntaxString(v.get(i).getBaseUri(),null) + ""String_Node_Str"";
        for (        Individual indi : indiSet) {
          individualInformation+=indi.toManchesterSyntaxString(v.get(i).getBaseUri(),null);
          if (indiSet.size() > 1) {
            individualInformation+=""String_Node_Str"";
          }
        }
        individualInformation+=""String_Node_Str"";
      }
      individualInformation+=""String_Node_Str"";
      panel.getGraphicalCoveragePanel().setToolTipText(individualInformation);
    }
  }
}","@Override public void mouseMoved(MouseEvent m){
  if (m.getX() >= panel.getX1() + panel.getShiftCovered() && m.getX() <= panel.getX2() + panel.getShiftCovered() && m.getY() >= panel.getY1() && m.getY() <= panel.getY2() || m.getX() >= panel.getX1() + panel.getShiftNewConcept() && m.getX() <= panel.getX2() + panel.getShiftNewConcept() && m.getY() >= panel.getY1() && m.getY() <= panel.getY2() || m.getX() >= panel.getX1() + panel.getShiftNewConceptX() && m.getX() <= panel.getX2() + panel.getShiftNewConceptX() && m.getY() >= panel.getY1() + panel.getShiftNewConcept() && m.getY() <= panel.getY2() + panel.getShiftNewConcept() || m.getX() >= panel.getX1() - panel.getShiftOldConcept() && m.getX() <= panel.getX2() - panel.getShiftOldConcept() && m.getY() >= panel.getY1() && m.getY() <= panel.getY2()) {
    panel.getGraphicalCoveragePanel().setToolTipText(""String_Node_Str"");
  }
  Vector<IndividualPoint> v=panel.getIndividualVector();
  FastInstanceChecker reasoner=model.getReasoner();
  for (int i=0; i < v.size(); i++) {
    if (v.get(i).getXAxis() >= m.getX() - 5 && v.get(i).getXAxis() <= m.getX() + 5 && v.get(i).getYAxis() >= m.getY() - 5 && v.get(i).getYAxis() <= m.getY() + 5) {
      String individualInformation=""String_Node_Str"" + v.get(i).getIndividualName().toString();
      if (v.get(i).getDLLearnerIndividual() != null) {
        Set<NamedClass> types=reasoner.getTypes(v.get(i).getDLLearnerIndividual());
        individualInformation+=""String_Node_Str"";
        for (        NamedClass dlLearnerClass : types) {
          individualInformation+=dlLearnerClass.toManchesterSyntaxString(v.get(i).getBaseUri(),null) + ""String_Node_Str"";
        }
        Map<ObjectProperty,Set<Individual>> objectProperties=reasoner.getObjectPropertyRelationships(v.get(i).getDLLearnerIndividual());
        Set<ObjectProperty> key=objectProperties.keySet();
        individualInformation+=""String_Node_Str"";
        for (        ObjectProperty objectProperty : key) {
          Set<Individual> indiSet=objectProperties.get(objectProperty);
          individualInformation=individualInformation + objectProperty.toManchesterSyntaxString(v.get(i).getBaseUri(),null) + ""String_Node_Str"";
          for (          Individual indi : indiSet) {
            individualInformation+=indi.toManchesterSyntaxString(v.get(i).getBaseUri(),null);
            if (indiSet.size() > 1) {
              individualInformation+=""String_Node_Str"";
            }
          }
          individualInformation+=""String_Node_Str"";
        }
      }
      individualInformation+=""String_Node_Str"";
      panel.getGraphicalCoveragePanel().setToolTipText(individualInformation);
    }
  }
}"
9858,"/** 
 * When a Button is pressed this method select the right.
 * @param z ActionEvent
 */
public void actionPerformed(ActionEvent z){
  if (z.getActionCommand().equals(EQUIVALENT_CLASS_LEARNING_STRING) || z.getActionCommand().equals(SUPER_CLASS_LEARNING_STRING)) {
    model.setKnowledgeSource();
    view.getSuggestClassPanel().getSuggestModel().clear();
    view.getSuggestClassPanel().repaint();
    model.setLearningProblem();
    model.setLearningAlgorithm();
    view.getRunButton().setEnabled(false);
    view.getHintPanel().setForeground(Color.RED);
    CELOE celoe=(CELOE)model.getLearningAlgorithm();
    String moreInformationsMessage=""String_Node_Str"" + celoe.getMinimumHorizontalExpansion() + ""String_Node_Str""+ celoe.getMaximumHorizontalExpansion()+ ""String_Node_Str"";
    view.setHelpButtonVisible(true);
    view.setHintMessage(moreInformationsMessage);
    retriever=new SuggestionRetriever();
    retriever.addPropertyChangeListener(view.getStatusBar());
    retriever.execute();
  }
  if (z.getActionCommand().equals(ADD_BUTTON_STRING)) {
    if (evaluatedDescription != null) {
      model.changeDLLearnerDescriptionsToOWLDescriptions(evaluatedDescription.getDescription());
    }
 else {
      model.changeDLLearnerDescriptionsToOWLDescriptions((Description)view.getSuggestClassPanel().getSuggestList().getSelectedValue());
    }
    String message=""String_Node_Str"";
    view.setHintMessage(message);
    view.setHelpButtonVisible(false);
  }
  if (z.toString().contains(ADVANCED_BUTTON_STRING)) {
    if (!toggled) {
      toggled=true;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
 else {
      toggled=false;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
  }
  if (z.toString().contains(HELP_BUTTON_STRING)) {
    String helpText=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    help=new JTextPane();
    help.setEditable(false);
    help.setContentType(""String_Node_Str"");
    help.setForeground(Color.black);
    help.addHyperlinkListener(hyperHandler);
    help.setBackground(view.getLearnerView().getBackground());
    help.setText(helpText);
    JOptionPane.showMessageDialog(null,help,""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
  }
}","/** 
 * When a Button is pressed this method select the right.
 * @param z ActionEvent
 */
public void actionPerformed(ActionEvent z){
  if (z.getActionCommand().equals(EQUIVALENT_CLASS_LEARNING_STRING) || z.getActionCommand().equals(SUPER_CLASS_LEARNING_STRING)) {
    model.setKnowledgeSource();
    view.getSuggestClassPanel().getSuggestModel().clear();
    view.getSuggestClassPanel().repaint();
    model.setLearningProblem();
    model.setLearningAlgorithm();
    view.getRunButton().setEnabled(false);
    view.getHintPanel().setForeground(Color.RED);
    CELOE celoe=(CELOE)model.getLearningAlgorithm();
    String moreInformationsMessage=""String_Node_Str"" + celoe.getMinimumHorizontalExpansion() + ""String_Node_Str""+ celoe.getMaximumHorizontalExpansion()+ ""String_Node_Str"";
    view.setHelpButtonVisible(true);
    view.setHintMessage(moreInformationsMessage);
    retriever=new SuggestionRetriever();
    retriever.addPropertyChangeListener(view.getStatusBar());
    retriever.execute();
  }
  if (z.getActionCommand().equals(ADD_BUTTON_STRING)) {
    if (evaluatedDescription != null) {
      model.changeDLLearnerDescriptionsToOWLDescriptions(evaluatedDescription.getDescription());
    }
 else {
      model.changeDLLearnerDescriptionsToOWLDescriptions((Description)view.getSuggestClassPanel().getSuggestList().getSelectedValue());
    }
    String message=""String_Node_Str"";
    view.setHintMessage(message);
    view.setHelpButtonVisible(false);
  }
  if (z.toString().contains(ADVANCED_BUTTON_STRING)) {
    if (!toggled) {
      toggled=true;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
 else {
      toggled=false;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
  }
  if (z.toString().contains(HELP_BUTTON_STRING)) {
    Set<String> uris=model.getOntologyURIString();
    String currentClass=""String_Node_Str"";
    for (    String uri : uris) {
      if (model.getCurrentConcept().toString().contains(uri)) {
        currentClass=model.getCurrentConcept().toManchesterSyntaxString(uri,null);
      }
    }
    String helpText=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + currentClass + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ view.getPosAndNegSelectPanel().getOptionPanel().getMaxExecutionTime()+ ""String_Node_Str""+ ""String_Node_Str"";
    help=new JTextPane();
    help.setEditable(false);
    help.setContentType(""String_Node_Str"");
    help.setForeground(Color.black);
    help.addHyperlinkListener(hyperHandler);
    help.setBackground(view.getLearnerView().getBackground());
    help.setText(helpText);
    JOptionPane.showMessageDialog(null,help,""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
  }
}"
9859,"/** 
 * Checks the URI if a ""#"" is in it.
 */
private void checkURI(){
  ontologieURI=new HashSet<String>();
  Set<OWLOntology> ont=editor.getModelManager().getActiveOntologies();
  Set<Individual> indi=reasoner.getIndividuals();
  for (  OWLOntology onto : ont) {
    String ontURI=onto.getURI().toString();
    for (    Individual ind : indi) {
      if (ind.toString().contains(ontURI)) {
        if (ind.toString().contains(""String_Node_Str"")) {
          ontologieURI.add(onto.getURI().toString() + ""String_Node_Str"");
          break;
        }
 else {
          ontologieURI.add(onto.getURI().toString());
          break;
        }
      }
    }
  }
  model.setOntologyURIString(ontologieURI);
}","/** 
 * Puts every base uri in a HashSet.
 */
private void checkURI(){
  ontologieURI=new HashSet<String>();
  Set<Individual> indi=reasoner.getIndividuals();
  for (  Individual ind : indi) {
    int ontURI=ind.toString().lastIndexOf(""String_Node_Str"");
    int ontURI2=ind.toString().lastIndexOf(""String_Node_Str"");
    String uriNeu=""String_Node_Str"";
    String uriAlt=""String_Node_Str"";
    if (ontURI2 != -1) {
      uriNeu=ind.toString().substring(0,ontURI2 + 1);
      if (uriNeu != uriAlt) {
        ontologieURI.add(uriNeu);
        uriAlt=uriNeu;
        uriNeu=""String_Node_Str"";
        String uriTest=indi.toString().replace(uriAlt,""String_Node_Str"");
        if (!uriTest.contains(""String_Node_Str"") && !uriTest.contains(""String_Node_Str"")) {
          break;
        }
      }
    }
 else {
      uriNeu=ind.toString().substring(0,ontURI + 1);
      if (uriNeu != uriAlt) {
        ontologieURI.add(uriNeu);
        uriAlt=uriNeu;
        uriNeu=""String_Node_Str"";
        String uriTest=indi.toString().replace(uriAlt,""String_Node_Str"");
        if (!uriTest.contains(""String_Node_Str"") && !uriTest.contains(""String_Node_Str"")) {
          break;
        }
      }
    }
  }
  model.setOntologyURIString(ontologieURI);
}"
9860,"/** 
 * When a Button is pressed this method select the right.
 * @param z ActionEvent
 */
public void actionPerformed(ActionEvent z){
  if (z.getActionCommand().equals(""String_Node_Str"") || z.getActionCommand().equals(""String_Node_Str"")) {
    model.setKnowledgeSource();
    view.getSuggestClassPanel().getSuggestModel().clear();
    view.getSuggestClassPanel().repaint();
    model.setLearningProblem();
    model.setLearningAlgorithm();
    view.getRunButton().setEnabled(false);
    view.getHintPanel().setForeground(Color.RED);
    CELOE celoe=(CELOE)model.getLearningAlgorithm();
    String moreInformationsMessage=""String_Node_Str"" + celoe.getMinimumHorizontalExpansion() + ""String_Node_Str""+ celoe.getMaximumHorizontalExpansion()+ ""String_Node_Str"";
    view.setHelpButtonVisible(true);
    view.setHintMessage(moreInformationsMessage);
    retriever=new SuggestionRetriever();
    retriever.addPropertyChangeListener(view.getStatusBar());
    retriever.execute();
  }
  if (z.getActionCommand().equals(""String_Node_Str"")) {
    if (evaluatedDescription != null) {
      model.changeDLLearnerDescriptionsToOWLDescriptions(evaluatedDescription.getDescription());
    }
 else {
      model.changeDLLearnerDescriptionsToOWLDescriptions((Description)view.getSuggestClassPanel().getSuggestList().getSelectedValue());
    }
    String message=""String_Node_Str"";
    view.setHintMessage(message);
    view.setHelpButtonVisible(false);
  }
  if (z.toString().contains(ADVANCED_BUTTON_STRING)) {
    if (!toggled) {
      toggled=true;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
 else {
      toggled=false;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
  }
  if (z.toString().contains(HELP_BUTTON_STRING)) {
    String helpText=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    help=new JTextArea();
    help.setEditable(false);
    help.setForeground(Color.black);
    help.setText(helpText);
    JOptionPane.showMessageDialog(null,help,""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
  }
}","/** 
 * When a Button is pressed this method select the right.
 * @param z ActionEvent
 */
public void actionPerformed(ActionEvent z){
  if (z.getActionCommand().equals(EQUIVALENT_CLASS_LEARNING_STRING) || z.getActionCommand().equals(SUPER_CLASS_LEARNING_STRING)) {
    model.setKnowledgeSource();
    view.getSuggestClassPanel().getSuggestModel().clear();
    view.getSuggestClassPanel().repaint();
    model.setLearningProblem();
    model.setLearningAlgorithm();
    view.getRunButton().setEnabled(false);
    view.getHintPanel().setForeground(Color.RED);
    CELOE celoe=(CELOE)model.getLearningAlgorithm();
    String moreInformationsMessage=""String_Node_Str"" + celoe.getMinimumHorizontalExpansion() + ""String_Node_Str""+ celoe.getMaximumHorizontalExpansion()+ ""String_Node_Str"";
    view.setHelpButtonVisible(true);
    view.setHintMessage(moreInformationsMessage);
    retriever=new SuggestionRetriever();
    retriever.addPropertyChangeListener(view.getStatusBar());
    retriever.execute();
  }
  if (z.getActionCommand().equals(ADD_BUTTON_STRING)) {
    if (evaluatedDescription != null) {
      model.changeDLLearnerDescriptionsToOWLDescriptions(evaluatedDescription.getDescription());
    }
 else {
      model.changeDLLearnerDescriptionsToOWLDescriptions((Description)view.getSuggestClassPanel().getSuggestList().getSelectedValue());
    }
    String message=""String_Node_Str"";
    view.setHintMessage(message);
    view.setHelpButtonVisible(false);
  }
  if (z.toString().contains(ADVANCED_BUTTON_STRING)) {
    if (!toggled) {
      toggled=true;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
 else {
      toggled=false;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
  }
  if (z.toString().contains(HELP_BUTTON_STRING)) {
    String helpText=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    help=new JTextArea();
    help.setEditable(false);
    help.setForeground(Color.black);
    help.setText(helpText);
    JOptionPane.showMessageDialog(null,help,""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
  }
}"
9861,"/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  labels=""String_Node_Str"";
  individualSize=0;
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel(model,this);
  learnerPanel=new JPanel();
  hintPanel=new JPanel(new FlowLayout());
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  URL helpIconUrl=this.getClass().getResource(""String_Node_Str"");
  helpIcon=new ImageIcon(helpIconUrl);
  helpButton=new JButton(helpIcon);
  helpButton.setPreferredSize(new Dimension(20,20));
  helpButton.setName(""String_Node_Str"");
  helpButton.addActionListener(action);
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  stat=new StatusBar();
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.setPreferredSize(new Dimension(485,30));
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(260,30));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  sugPanelHandler=new SuggestClassPanelHandler(this,model);
  sugPanel.addSuggestPanelMouseListener(sugPanelHandler);
  sugPanel.getSuggestList().addListSelectionListener(sugPanelHandler);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}","/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  labels=""String_Node_Str"";
  individualSize=0;
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel(model,this);
  learnerPanel=new JPanel();
  hintPanel=new JPanel(new FlowLayout());
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  URL helpIconUrl=this.getClass().getResource(""String_Node_Str"");
  helpIcon=new ImageIcon(helpIconUrl);
  helpButton=new JButton(helpIcon);
  helpButton.setPreferredSize(new Dimension(20,20));
  helpButton.setName(""String_Node_Str"");
  helpButton.addActionListener(action);
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  stat=new StatusBar();
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.setPreferredSize(new Dimension(485,30));
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(260,30));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  sugPanelHandler=new SuggestClassPanelHandler(this,model,action);
  sugPanel.addSuggestPanelMouseListener(sugPanelHandler);
  sugPanel.getSuggestList().addListSelectionListener(sugPanelHandler);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}"
9862,"/** 
 * This is the constructor for the SuggestClassPanelHandler.
 * @param v DLLearnerView
 * @param m DLLearnerModel
 */
public SuggestClassPanelHandler(DLLearnerView v,DLLearnerModel m){
  this.view=v;
  this.model=m;
}","/** 
 * This is the constructor for the SuggestClassPanelHandler.
 * @param v DLLearnerView
 * @param m DLLearnerModel
 */
public SuggestClassPanelHandler(DLLearnerView v,DLLearnerModel m,ActionHandler a){
  this.view=v;
  this.model=m;
  this.action=a;
}"
9863,"@Override public void mouseClicked(MouseEvent e){
  if (view.getSuggestClassPanel().getSuggestList().getSelectedValue() != null) {
    SuggestListItem item=(SuggestListItem)view.getSuggestClassPanel().getSuggestList().getSelectedValue();
    String desc=item.getValue();
    if (model.getEvaluatedDescriptionList() != null) {
      List<? extends EvaluatedDescription> evalList=model.getEvaluatedDescriptionList();
      Set<String> onto=model.getOntologyURIString();
      for (      EvaluatedDescription eDescription : evalList) {
        for (        String ont : onto) {
          if (desc.equals(eDescription.getDescription().toManchesterSyntaxString(ont,null))) {
            evaluatedDescription=eDescription;
            break;
          }
        }
      }
    }
    view.getMoreDetailForSuggestedConceptsPanel().renderDetailPanel(evaluatedDescription);
    view.setGraphicalPanel();
  }
}","@Override public void mouseClicked(MouseEvent e){
  if (view.getSuggestClassPanel().getSuggestList().getSelectedValue() != null) {
    SuggestListItem item=(SuggestListItem)view.getSuggestClassPanel().getSuggestList().getSelectedValue();
    String desc=item.getValue();
    if (model.getEvaluatedDescriptionList() != null) {
      List<? extends EvaluatedDescription> evalList=model.getEvaluatedDescriptionList();
      Set<String> onto=model.getOntologyURIString();
      for (      EvaluatedDescription eDescription : evalList) {
        for (        String ont : onto) {
          if (desc.equals(eDescription.getDescription().toManchesterSyntaxString(ont,null))) {
            evaluatedDescription=eDescription;
            action.setEvaluatedClassExpression(eDescription);
            break;
          }
        }
      }
    }
    view.getMoreDetailForSuggestedConceptsPanel().renderDetailPanel(evaluatedDescription);
    view.setGraphicalPanel();
  }
}"
9864,"/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  labels=""String_Node_Str"";
  individualSize=0;
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel(model,this);
  learnerPanel=new JPanel();
  hintPanel=new JPanel(new FlowLayout());
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JTextPane();
  wikiPane.setContentType(""String_Node_Str"");
  wikiPane.setBackground(learnerScroll.getBackground());
  wikiPane.setEditable(false);
  wikiPane.setText(WIKI_STRING);
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  URL helpIconUrl=this.getClass().getResource(""String_Node_Str"");
  helpIcon=new ImageIcon(helpIconUrl);
  helpButton=new JButton(helpIcon);
  helpButton.setPreferredSize(new Dimension(20,20));
  helpButton.setName(""String_Node_Str"");
  helpButton.addActionListener(action);
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  stat=new StatusBar();
  hint=new JTextPane();
  hint.setBackground(learnerScroll.getBackground());
  hint.setContentType(""String_Node_Str"");
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.addHyperlinkListener(hyperHandler);
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(260,30));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  sugPanelHandler=new SuggestClassPanelHandler(this,model,action);
  sugPanel.addSuggestPanelMouseListener(sugPanelHandler);
  sugPanel.getSuggestList().addListSelectionListener(sugPanelHandler);
  hyperHandler=new HyperLinkHandler();
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}","/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  labels=""String_Node_Str"";
  individualSize=0;
  hyperHandler=new HyperLinkHandler();
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel(model,this);
  learnerPanel=new JPanel();
  hintPanel=new JPanel(new FlowLayout());
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JTextPane();
  wikiPane.setContentType(""String_Node_Str"");
  wikiPane.setBackground(learnerScroll.getBackground());
  wikiPane.setEditable(false);
  wikiPane.setText(WIKI_STRING);
  wikiPane.addHyperlinkListener(hyperHandler);
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  URL helpIconUrl=this.getClass().getResource(""String_Node_Str"");
  helpIcon=new ImageIcon(helpIconUrl);
  helpButton=new JButton(helpIcon);
  helpButton.setPreferredSize(new Dimension(20,20));
  helpButton.setName(""String_Node_Str"");
  helpButton.addActionListener(action);
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  stat=new StatusBar();
  hint=new JTextPane();
  hint.setBackground(learnerScroll.getBackground());
  hint.setContentType(""String_Node_Str"");
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(260,30));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  sugPanelHandler=new SuggestClassPanelHandler(this,model,action);
  sugPanel.addSuggestPanelMouseListener(sugPanelHandler);
  sugPanel.getSuggestList().addListSelectionListener(sugPanelHandler);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}"
9865,"@Override public void activeOntologyChanged(){
  ontology=OREManager.getInstance().getReasoner().getOWLAPIOntologies();
  reasoner=OREManager.getInstance().getReasoner().getReasoner();
  gen=new CachedExplanationGenerator(ontology,reasoner);
  orderingMap.clear();
}","@Override public void activeOntologyChanged(){
  ontology=OREManager.getInstance().getReasoner().getOWLAPIOntologies();
  reasoner=OREManager.getInstance().getReasoner().getReasoner();
  gen=new CachedExplanationGenerator(ontology,reasoner);
  orderingMap.clear();
  usageChecker=new AxiomUsageChecker(ontology);
}"
9866,"public LearningManager(){
  listeners=new ArrayList<LearningManagerListener>();
}","public LearningManager(){
  listeners=new ArrayList<LearningManagerListener>();
  newDescriptions=new ArrayList<EvaluatedDescriptionClass>();
}"
9867,"public void setNewDescriptions(List<EvaluatedDescriptionClass> newDescriptions){
  this.newDescriptions=newDescriptions;
  currentDescriptionIndex=0;
  fireNewDescriptionsAdded(newDescriptions);
  setNextDescription();
}","public void setNewDescriptions(List<List<EvaluatedDescriptionClass>> descriptions){
  newDescriptions.clear();
  newDescriptions.addAll(descriptions.get(0));
  newDescriptions.addAll(descriptions.get(1));
  equivalentDescriptions=descriptions.get(0);
  superDescriptions=descriptions.get(1);
  currentDescriptionIndex=0;
  fireNewDescriptionsAdded(newDescriptions);
  setNextDescription();
}"
9868,"public boolean consistentOntology() throws InconsistentOntologyException {
  return reasoner.isConsistent();
}","public boolean consistentOntology() throws InconsistentOntologyException {
  return consistentOntology;
}"
9869,"public void initPelletReasoner() throws URISyntaxException, OWLOntologyCreationException {
  reasoner=cm.reasoner(PelletReasoner.class,ks);
  try {
    reasoner.init();
  }
 catch (  ComponentInitException e) {
    e.printStackTrace();
  }
  reasoner.loadOntologies();
  reasoner.addProgressMonitor(TaskManager.getInstance().getStatusBar());
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  modifier=new OntologyModifier(reasoner);
  fireActiveOntologyChanged();
}","public void initPelletReasoner() throws URISyntaxException, OWLOntologyCreationException {
  reasoner=cm.reasoner(PelletReasoner.class,ks);
  try {
    reasoner.init();
  }
 catch (  ComponentInitException e) {
    e.printStackTrace();
  }
  reasoner.loadOntologies();
  reasoner.addProgressMonitor(TaskManager.getInstance().getStatusBar());
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  modifier=new OntologyModifier(reasoner);
  fireActiveOntologyChanged();
  consistentOntology=reasoner.isConsistent();
}"
9870,"public ImpactTable(){
  setModel(new ImpactTableModel());
  setBackground(Color.WHITE);
  setShowHorizontalLines(true);
  setGridColor(Color.LIGHT_GRAY);
  setTableHeader(null);
  setRowHeightEnabled(true);
  getColumnModel().getColumn(1).setCellRenderer(new MultiLineTableCellRenderer());
  setRowHeight(getRowHeight() + 5);
  getColumn(0).setMaxWidth(50);
  getColumn(2).setMaxWidth(60);
  addMouseMotionListener(new MouseAdapter(){
    final ImpactTable table;
{
      table=ImpactTable.this;
    }
    public void mouseMoved(    MouseEvent e){
      int row=rowAtPoint(e.getPoint());
      int column=columnAtPoint(e.getPoint());
      if (column == 2 && row <= table.getRowCount() && row >= 0 && ((ImpactTableModel)getModel()).isLostEntailment(row)) {
        setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
      }
 else {
        setCursor(null);
      }
    }
  }
);
  addMouseListener(new MouseAdapter(){
    final ImpactTable table;
{
      table=ImpactTable.this;
    }
    public void mouseClicked(    MouseEvent e){
      int row=rowAtPoint(e.getPoint());
      int column=columnAtPoint(e.getPoint());
      if (row >= 0 && row <= table.getRowCount() && column == 2 && ((ImpactTableModel)getModel()).isLostEntailment(row)) {
        ((ImpactTableModel)table.getModel()).addToRepairPlan(rowAtPoint(e.getPoint()));
        setCursor(null);
      }
    }
    public void mousePressed(    MouseEvent e){
      int row=rowAtPoint(e.getPoint());
      if (row >= 0 && row < getRowCount() && e.isPopupTrigger()) {
        showPopupMenu(e);
      }
    }
    public void mouseReleased(    MouseEvent e){
      int row=rowAtPoint(e.getPoint());
      if (row >= 0 && row < getRowCount() && e.isPopupTrigger()) {
        showPopupMenu(e);
      }
    }
  }
);
}","public ImpactTable(){
  setModel(new ImpactTableModel());
  setBackground(Color.WHITE);
  setShowHorizontalLines(true);
  setGridColor(Color.LIGHT_GRAY);
  setTableHeader(null);
  setRowHeightEnabled(true);
  getColumnModel().getColumn(1).setCellRenderer(new MultiLineTableCellRenderer());
  setRowHeight(getRowHeight() + 5);
  getColumn(0).setMaxWidth(60);
  getColumn(2).setMaxWidth(60);
  addMouseMotionListener(new MouseAdapter(){
    final ImpactTable table;
{
      table=ImpactTable.this;
    }
    public void mouseMoved(    MouseEvent e){
      int row=rowAtPoint(e.getPoint());
      int column=columnAtPoint(e.getPoint());
      if (column == 2 && row <= table.getRowCount() && row >= 0 && ((ImpactTableModel)getModel()).isLostEntailment(row)) {
        setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
      }
 else {
        setCursor(null);
      }
    }
  }
);
  addMouseListener(new MouseAdapter(){
    final ImpactTable table;
{
      table=ImpactTable.this;
    }
    public void mouseClicked(    MouseEvent e){
      int row=rowAtPoint(e.getPoint());
      int column=columnAtPoint(e.getPoint());
      if (row >= 0 && row <= table.getRowCount() && column == 2 && ((ImpactTableModel)getModel()).isLostEntailment(row)) {
        ((ImpactTableModel)table.getModel()).addToRepairPlan(rowAtPoint(e.getPoint()));
        setCursor(null);
      }
    }
    public void mousePressed(    MouseEvent e){
      int row=rowAtPoint(e.getPoint());
      if (row >= 0 && row < getRowCount() && e.isPopupTrigger()) {
        showPopupMenu(e);
      }
    }
    public void mouseReleased(    MouseEvent e){
      int row=rowAtPoint(e.getPoint());
      if (row >= 0 && row < getRowCount() && e.isPopupTrigger()) {
        showPopupMenu(e);
      }
    }
  }
);
}"
9871,"public void addURI(URI uri){
  if (!uriList.contains(uri)) {
    uriList.add(uri);
  }
}","public void addURI(URI uri){
  if (uri != null && !uriList.contains(uri)) {
    uriList.add(uri);
  }
}"
9872,"@SuppressWarnings(""String_Node_Str"") public static void main(String[] args) throws MalformedURLException {
  String exampleClass=""String_Node_Str"";
  String exampleClassKBString=""String_Node_Str"" + exampleClass + ""String_Node_Str"";
  ComponentManager cm=ComponentManager.getInstance();
  SparqlEndpoint endPoint=SparqlEndpoint.getEndpointDBpedia();
  String queryString=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  SPARQLTasks task=new SPARQLTasks(endPoint);
  System.out.println(task.queryAsSet(queryString,""String_Node_Str""));
  AutomaticPositiveExampleFinderSPARQL pos=new AutomaticPositiveExampleFinderSPARQL(task);
  pos.makePositiveExamplesFromConcept(exampleClassKBString);
  SortedSet<String> allPosExamples=pos.getPosExamples();
  SortedSet<String> posExamples=SetManipulation.stableShrink(allPosExamples,20);
  System.out.println(posExamples.size());
  System.out.println(posExamples);
  SortedSet<String> instances=new TreeSet<String>(posExamples);
  try {
    SparqlKnowledgeSource ks=cm.knowledgeSource(SparqlKnowledgeSource.class);
    cm.applyConfigEntry(ks,""String_Node_Str"",""String_Node_Str"");
    ks.getConfigurator().setInstances(instances);
    ks.getConfigurator().setPredefinedFilter(""String_Node_Str"");
    ks.init();
    ReasonerComponent reasoner=cm.reasoner(FastInstanceChecker.class,ks);
    reasoner.init();
    ClassLearningProblem lp=cm.learningProblem(ClassLearningProblem.class,reasoner);
    lp.getConfigurator().setClassToDescribe(new URL(exampleClass));
    lp.init();
    LearningAlgorithm la=cm.learningAlgorithm(CELOE.class,lp,reasoner);
    la.init();
    la.start();
  }
 catch (  ComponentInitException e) {
    e.printStackTrace();
  }
catch (  LearningProblemUnsupportedException e) {
    e.printStackTrace();
  }
}","@SuppressWarnings(""String_Node_Str"") public static void main(String[] args) throws MalformedURLException {
  String exampleClass=""String_Node_Str"";
  String exampleClassKBString=""String_Node_Str"" + exampleClass + ""String_Node_Str"";
  ComponentManager cm=ComponentManager.getInstance();
  SparqlEndpoint endPoint=SparqlEndpoint.getEndpointDBpedia();
  String queryString=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  SPARQLTasks task=new SPARQLTasks(endPoint);
  System.out.println(task.queryAsSet(queryString,""String_Node_Str""));
  AutomaticPositiveExampleFinderSPARQL pos=new AutomaticPositiveExampleFinderSPARQL(task);
  pos.makePositiveExamplesFromConcept(exampleClassKBString);
  SortedSet<String> allPosExamples=pos.getPosExamples();
  SortedSet<String> posExamples=SetManipulation.stableShrink(allPosExamples,20);
  System.out.println(posExamples.size());
  System.out.println(posExamples);
  SortedSet<String> instances=new TreeSet<String>(posExamples);
  try {
    SparqlKnowledgeSource ks=cm.knowledgeSource(SparqlKnowledgeSource.class);
    cm.applyConfigEntry(ks,""String_Node_Str"",""String_Node_Str"");
    ks.getConfigurator().setInstances(instances);
    ks.init();
    ReasonerComponent reasoner=cm.reasoner(FastInstanceChecker.class,ks);
    reasoner.init();
    ClassLearningProblem lp=cm.learningProblem(ClassLearningProblem.class,reasoner);
    lp.getConfigurator().setClassToDescribe(new URL(exampleClass));
    lp.init();
    LearningAlgorithm la=cm.learningAlgorithm(CELOE.class,lp,reasoner);
    la.init();
    la.start();
  }
 catch (  ComponentInitException e) {
    e.printStackTrace();
  }
catch (  LearningProblemUnsupportedException e) {
    e.printStackTrace();
  }
}"
9873,"public static void miniEconomyTest(){
  String file=""String_Node_Str"";
  try {
    OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
    ManchesterSyntaxExplanationRenderer renderer=new ManchesterSyntaxExplanationRenderer();
    PrintWriter pw=new PrintWriter(System.out);
    renderer.startRendering(pw);
    OWLOntology ontology=manager.loadOntologyFromPhysicalURI(URI.create(file));
    Set<OWLOntology> ontologies=new HashSet<OWLOntology>();
    ontologies.add(ontology);
    PelletReasonerFactory resonerFact=new PelletReasonerFactory();
    OWLDataFactory dataFactory=manager.getOWLDataFactory();
    Reasoner reasoner=resonerFact.createReasoner(manager);
    reasoner.loadOntologies(ontologies);
    SwingProgressMonitor monitor=new SwingProgressMonitor();
    reasoner.getKB().getTaxonomyBuilder().setProgressMonitor(monitor);
    reasoner.classify();
    System.out.println(reasoner.getInconsistentClasses());
    LaconicExplanationGenerator expGen=new LaconicExplanationGenerator(manager,resonerFact,ontologies);
    Set<OWLClass> unsatClasses=reasoner.getInconsistentClasses();
    OWLSubClassAxiom unsatAxiom;
    unsatAxiom=dataFactory.getOWLSubClassAxiom(dataFactory.getOWLClass(URI.create(""String_Node_Str"")),dataFactory.getOWLNothing());
    Set<Explanation> preciseJusts=expGen.getExplanations(unsatAxiom);
    renderer.endRendering();
  }
 catch (  OWLOntologyCreationException e) {
    e.printStackTrace();
  }
catch (  OWLException e) {
    e.printStackTrace();
  }
catch (  UnsupportedOperationException e) {
    e.printStackTrace();
  }
}","public static void miniEconomyTest(){
  String file=""String_Node_Str"";
  try {
    OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
    OWLOntology ontology=manager.loadOntologyFromPhysicalURI(URI.create(file));
    PelletReasonerFactory resonerFact=new PelletReasonerFactory();
    OWLDataFactory dataFactory=manager.getOWLDataFactory();
    Reasoner reasoner=resonerFact.createReasoner(manager);
    reasoner.loadOntology(ontology);
    reasoner.classify();
    System.out.println(reasoner.getInconsistentClasses());
    LaconicExplanationGenerator expGen=new LaconicExplanationGenerator(manager,resonerFact,Collections.singleton(ontology));
    Set<OWLClass> unsatClasses=reasoner.getInconsistentClasses();
    OWLSubClassAxiom unsatAxiom;
    for (    OWLClass unsat : unsatClasses) {
      unsatAxiom=dataFactory.getOWLSubClassAxiom(unsat,dataFactory.getOWLNothing());
      Set<Explanation> explanations=expGen.getExplanations(unsatAxiom);
      System.out.println(explanations);
    }
  }
 catch (  OWLOntologyCreationException e) {
    e.printStackTrace();
  }
catch (  OWLException e) {
    e.printStackTrace();
  }
catch (  UnsupportedOperationException e) {
    e.printStackTrace();
  }
}"
9874,"public static void test(){
  String file=""String_Node_Str"";
  try {
    OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
    ManchesterSyntaxExplanationRenderer renderer=new ManchesterSyntaxExplanationRenderer();
    PrintWriter pw=new PrintWriter(System.out);
    renderer.startRendering(pw);
    OWLDataFactory dataFactory=manager.getOWLDataFactory();
    PelletReasonerFactory resonerFact=new PelletReasonerFactory();
    OWLOntology ontology=manager.loadOntologyFromPhysicalURI(URI.create(file));
    Reasoner reasoner=resonerFact.createReasoner(manager);
    reasoner.loadOntologies(Collections.singleton(ontology));
    System.out.println(reasoner.getInconsistentClasses());
    PelletExplanation exp=new PelletExplanation(manager,Collections.singleton(ontology));
    System.out.println(exp.getUnsatisfiableExplanations(dataFactory.getOWLClass(URI.create(""String_Node_Str""))));
    renderer.endRendering();
  }
 catch (  OWLOntologyCreationException e) {
    e.printStackTrace();
  }
catch (  OWLException e) {
    e.printStackTrace();
  }
}","public static void test(){
  String file=""String_Node_Str"";
  try {
    OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
    ManchesterSyntaxExplanationRenderer renderer=new ManchesterSyntaxExplanationRenderer();
    PrintWriter pw=new PrintWriter(System.out);
    renderer.startRendering(pw);
    OWLDataFactory dataFactory=manager.getOWLDataFactory();
    PelletReasonerFactory resonerFact=new PelletReasonerFactory();
    OWLOntology ontology=manager.loadOntologyFromPhysicalURI(URI.create(file));
    Reasoner reasoner=resonerFact.createReasoner(manager);
    reasoner.loadOntologies(Collections.singleton(ontology));
    System.out.println(reasoner.getInconsistentClasses());
    PelletExplanation exp=new PelletExplanation(manager,Collections.singleton(ontology));
    System.out.println(exp.getUnsatisfiableExplanations(dataFactory.getOWLClass(URI.create(""String_Node_Str""))));
    renderer.endRendering();
  }
 catch (  OWLOntologyCreationException e) {
    e.printStackTrace();
  }
}"
9875,"public static void main(String[] args){
  test();
  miniTest();
  miniEconomyTest();
  universityTest();
}","public static void main(String[] args){
  miniEconomyTest();
}"
9876,"@Override public Void doInBackground(){
  ComponentManager cm=ComponentManager.getInstance();
  URL endpointURL=null;
  try {
    endpointURL=new URL(comboBox.getSelectedItem().toString());
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
  List<String> defaultGraphURIS=new ArrayList<String>(1);
  defaultGraphURIS.add(defaultGraphField.getText());
  SparqlEndpoint endpoint=new SparqlEndpoint(endpointURL,defaultGraphURIS,Collections.<String>emptyList());
  task=new SPARQLTasks(endpoint);
  String classKBString;
  if (asLabelButton.isSelected()) {
    classKBString=""String_Node_Str"" + getClassFromLabel() + ""String_Node_Str"";
  }
 else {
    classKBString=""String_Node_Str"" + classField.getText() + ""String_Node_Str"";
  }
  AutomaticPositiveExampleFinderSPARQL pos=new AutomaticPositiveExampleFinderSPARQL(task);
  pos.makePositiveExamplesFromConcept(classKBString);
  SortedSet<String> allPosExamples=pos.getPosExamples();
  SortedSet<String> posExamples=SetManipulation.stableShrink(allPosExamples,20);
  SortedSet<String> instances=new TreeSet<String>(posExamples);
  ks=cm.knowledgeSource(SparqlKnowledgeSource.class);
  ks.getConfigurator().setUrl(SparqlEndpoint.getEndpointDBpedia().getURL());
  ks.getConfigurator().setInstances(instances);
  ks.getConfigurator().setPredefinedFilter(""String_Node_Str"");
  ks.getConfigurator().setBreakSuperClassRetrievalAfter(optionsPanel.getBreakSuperClassRetrievalAfterValue());
  ks.getConfigurator().setRecursionDepth(optionsPanel.getRecursionDepthValue());
  ks.getConfigurator().setUseCache(optionsPanel.isUseCache());
  ks.getConfigurator().setGetAllSuperClasses(optionsPanel.isGetAllSuperClasses());
  ks.getConfigurator().setDissolveBlankNodes(optionsPanel.isDissolveBlankNodes());
  ks.getConfigurator().setUseImprovedSparqlTupelAquisitor(optionsPanel.isUseImprovedSparqlTupelAquisitor());
  ks.getConfigurator().setUseLits(optionsPanel.isUseLiterals());
  ks.getConfigurator().setGetPropertyInformation(optionsPanel.isGetPropertyInformation());
  ks.getConfigurator().setCloseAfterRecursion(optionsPanel.isCloseAfterRecursion());
  ks.addProgressMonitor(mon);
  ks.init();
  return null;
}","@Override public Void doInBackground(){
  if (urlIsConnectable()) {
    message.setText(""String_Node_Str"");
  }
 else {
    message.setText(""String_Node_Str"");
    cancel(true);
  }
  ComponentManager cm=ComponentManager.getInstance();
  URL endpointURL=null;
  try {
    endpointURL=new URL(comboBox.getSelectedItem().toString());
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
  List<String> defaultGraphURIS=new ArrayList<String>(1);
  defaultGraphURIS.add(defaultGraphField.getText());
  SparqlEndpoint endpoint=new SparqlEndpoint(endpointURL,defaultGraphURIS,Collections.<String>emptyList());
  task=new SPARQLTasks(endpoint);
  String concept;
  if (asLabelButton.isSelected()) {
    concept=getClassFromLabel();
  }
 else {
    concept=classField.getText();
  }
  SortedSet<String> allPosExamples=getPosExamples(concept);
  SortedSet<String> posExamples=SetManipulation.stableShrink(allPosExamples,20);
  System.out.println(posExamples);
  SortedSet<String> instances=new TreeSet<String>(posExamples);
  ks=cm.knowledgeSource(SparqlKnowledgeSource.class);
  ks.getConfigurator().setUrl(endpoint.getURL());
  ks.getConfigurator().setInstances(instances);
  ks.getConfigurator().setBreakSuperClassRetrievalAfter(optionsPanel.getBreakSuperClassRetrievalAfterValue());
  ks.getConfigurator().setRecursionDepth(optionsPanel.getRecursionDepthValue());
  ks.getConfigurator().setUseCache(optionsPanel.isUseCache());
  ks.getConfigurator().setGetAllSuperClasses(optionsPanel.isGetAllSuperClasses());
  ks.getConfigurator().setDissolveBlankNodes(optionsPanel.isDissolveBlankNodes());
  ks.getConfigurator().setUseImprovedSparqlTupelAquisitor(optionsPanel.isUseImprovedSparqlTupelAquisitor());
  ks.getConfigurator().setUseLits(optionsPanel.isUseLiterals());
  ks.getConfigurator().setGetPropertyInformation(optionsPanel.isGetPropertyInformation());
  ks.getConfigurator().setCloseAfterRecursion(optionsPanel.isCloseAfterRecursion());
  ks.addProgressMonitor(mon);
  ks.getConfigurator().setSaveExtractedFragment(true);
  ks.init();
  return null;
}"
9877,"public OntologyExtractingTask(ProgressMonitor mon){
  this.mon=mon;
}","public OntologyExtractingTask(JDialog dialog,ProgressMonitor mon){
  this.mon=mon;
  this.dialog=dialog;
}"
9878,"@Override public void done(){
  if (!isCancelled() && ks != null) {
    okButton.setEnabled(true);
    message.setText(""String_Node_Str"");
  }
}","@Override public void done(){
  dialog.setCursor(null);
  if (!isCancelled() && ks != null) {
    okButton.setEnabled(true);
    message.setText(""String_Node_Str"");
  }
}"
9879,"private void extract(){
  if (urlIsConnectable()) {
    message.setText(""String_Node_Str"");
    mon=new ProgressMonitor(this,""String_Node_Str"",""String_Node_Str"",0,100);
    extractTask=new OntologyExtractingTask(mon);
    extractTask.addPropertyChangeListener(this);
    extractTask.execute();
  }
 else {
    message.setText(""String_Node_Str"");
  }
}","private void extract(){
  message.setText(""String_Node_Str"");
  setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
  mon=new ProgressMonitor(this,""String_Node_Str"",""String_Node_Str"",0,100);
  extractTask=new OntologyExtractingTask(this,mon);
  extractTask.addPropertyChangeListener(this);
  extractTask.execute();
}"
9880,"public List<URI> getURIs(){
  uriList.clear();
  deserialize();
  return uriList;
}","public List<URI> getURIs(){
  return uriList;
}"
9881,"@SuppressWarnings(""String_Node_Str"") private void deserialize(){
  try {
    FileInputStream fileStream=new FileInputStream(file);
    ObjectInputStream inputStream=new ObjectInputStream(new BufferedInputStream(fileStream));
    try {
      List<URI> list=(List<URI>)inputStream.readObject();
      if (list != null) {
        uriList.addAll(list);
      }
    }
  finally {
      inputStream.close();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
}","@SuppressWarnings(""String_Node_Str"") public void deserialize(){
  try {
    FileInputStream fileStream=new FileInputStream(file);
    ObjectInputStream inputStream=new ObjectInputStream(new BufferedInputStream(fileStream));
    try {
      List<URI> list=(List<URI>)inputStream.readObject();
      if (list != null) {
        uriList.addAll(list);
      }
    }
  finally {
      inputStream.close();
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"");
  }
catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
}"
9882,"public Set<Explanation> getExplanations(OWLAxiom entailment,int limit) throws ExplanationException {
  Set<Explanation> explanations;
  try {
    explanations=computePreciseJusts(entailment,limit);
  }
 catch (  OWLException e) {
    throw new ExplanationException(e);
  }
  return explanations;
}","public Set<Explanation> getExplanations(OWLAxiom entailment,int limit) throws ExplanationException {
  if (log.isLoggable(Level.CONFIG))   log.config(""String_Node_Str"" + (limit == Integer.MAX_VALUE ? ""String_Node_Str"" : limit) + ""String_Node_Str""+ entailment);
  Set<Explanation> explanations;
  try {
    explanations=computePreciseJusts(entailment,limit);
  }
 catch (  OWLException e) {
    throw new ExplanationException(e);
  }
  return explanations;
}"
9883,"/** 
 * Computes the precise explanations
 * @param entailment
 * @param limit
 * @return
 * @throws OWLException
 */
public Set<Explanation> computePreciseJusts(OWLAxiom entailment,int limit) throws OWLException {
  Set<Explanation> regularExplanations=pelletExplanation.getExplanations((OWLAxiom)entailment);
  System.out.println(new StringBuilder().append(""String_Node_Str"").append(regularExplanations.size()).toString());
  lastRegularExplanations.clear();
  lastRegularExplanations.addAll(regularExplanations);
  allPreviouslyFoundExplanations=new HashSet<Explanation>();
  allPreviouslyFoundExplanations.addAll(regularExplanations);
  Set<Explanation> nonLaconicExplanations=new HashSet<Explanation>();
  Set<Explanation> laconicExplanations=new HashSet<Explanation>();
  Set<OWLAxiom> axiomsInPreviousOntology=new HashSet<OWLAxiom>();
  long counter=0L;
  for (; ; ) {
    counter++;
    System.out.println(new StringBuilder().append(""String_Node_Str"").append(counter).toString());
    Set<OWLAxiom> unionOfAllExplanations=new HashSet<OWLAxiom>();
    for (    Explanation expl : allPreviouslyFoundExplanations) {
      unionOfAllExplanations.addAll(expl.getAxioms());
    }
    Set<OWLAxiom> oPlus=computeOPlus(unionOfAllExplanations);
    OWLOntologyManager man2=OWLManager.createOWLOntologyManager();
    OWLOntology extendedOntology=man2.createOntology(oPlus);
    for (    OWLLogicalAxiom logAx : ontology.getLogicalAxioms()) {
      if (!unionOfAllExplanations.contains(logAx) || oPlus.contains(logAx)) {
        man2.addAxiom(extendedOntology,logAx);
      }
    }
    if (extendedOntology.getLogicalAxioms().equals(axiomsInPreviousOntology)) {
      System.out.println(""String_Node_Str"");
      break;
    }
    axiomsInPreviousOntology.clear();
    axiomsInPreviousOntology.addAll(extendedOntology.getLogicalAxioms());
    Set<Explanation> allPrevJustsCopy=new HashSet<Explanation>(allPreviouslyFoundExplanations);
    Set<OWLOntology> ont2=new HashSet<OWLOntology>();
    ont2.add(extendedOntology);
    PelletExplanationGenerator expGen=new PelletExplanationGenerator(man2,ont2);
    Set<Explanation> currentExplanations=expGen.getExplanations((OWLAxiom)entailment);
    allPreviouslyFoundExplanations.addAll(currentExplanations);
    if (allPreviouslyFoundExplanations.equals(allPrevJustsCopy)) {
      break;
    }
    for (    Explanation currentExplanation : currentExplanations) {
      if (!laconicExplanations.contains(currentExplanation) && !nonLaconicExplanations.contains(currentExplanation)) {
        if (isLaconic(currentExplanation)) {
          laconicExplanations.add(currentExplanation);
        }
 else {
          nonLaconicExplanations.add(currentExplanation);
        }
        if (laconicExplanations.size() == limit) {
          return laconicExplanations;
        }
      }
    }
  }
  Set<Explanation> explanations=new HashSet<Explanation>();
  for (  Explanation explanation : allPreviouslyFoundExplanations) {
    if (!nonLaconicExplanations.contains(explanation)) {
      if (laconicExplanations.contains(explanation)) {
        explanations.add(explanation);
      }
 else       if (isLaconic(explanation)) {
        explanations.add(explanation);
      }
    }
  }
  return retrieveAxioms(explanations);
}","/** 
 * Computes the precise explanations
 * @param entailment
 * @param limit
 * @return
 * @throws OWLException
 */
private Set<Explanation> computePreciseJusts(OWLAxiom entailment,int limit) throws OWLException {
  Set<Explanation> regularExplanations=pelletExplanation.getExplanations((OWLAxiom)entailment);
  if (log.isLoggable(Level.CONFIG)) {
    log.config(""String_Node_Str"" + regularExplanations.size() + ""String_Node_Str"");
  }
  lastRegularExplanations.clear();
  lastRegularExplanations.addAll(regularExplanations);
  allPreviouslyFoundExplanations=new HashSet<Explanation>();
  allPreviouslyFoundExplanations.addAll(regularExplanations);
  Set<Explanation> nonLaconicExplanations=new HashSet<Explanation>();
  Set<Explanation> laconicExplanations=new HashSet<Explanation>();
  Set<OWLAxiom> axiomsInPreviousOntology=new HashSet<OWLAxiom>();
  for (; ; ) {
    if (progressMonitor.isCancelled()) {
      return laconicExplanations;
    }
    Set<OWLAxiom> unionOfAllExplanations=new HashSet<OWLAxiom>();
    for (    Explanation expl : allPreviouslyFoundExplanations) {
      unionOfAllExplanations.addAll(expl.getAxioms());
    }
    Set<OWLAxiom> oPlus=computeOPlus(unionOfAllExplanations);
    OWLOntologyManager man2=OWLManager.createOWLOntologyManager();
    OWLOntology extendedOntology=man2.createOntology(oPlus);
    for (    OWLLogicalAxiom logAx : ontology.getLogicalAxioms()) {
      if (!unionOfAllExplanations.contains(logAx) || oPlus.contains(logAx)) {
        man2.addAxiom(extendedOntology,logAx);
      }
    }
    if (extendedOntology.getLogicalAxioms().equals(axiomsInPreviousOntology)) {
      if (log.isLoggable(Level.CONFIG)) {
        log.config(""String_Node_Str"");
      }
      break;
    }
    axiomsInPreviousOntology.clear();
    axiomsInPreviousOntology.addAll(extendedOntology.getLogicalAxioms());
    Set<Explanation> allPrevJustsCopy=new HashSet<Explanation>(allPreviouslyFoundExplanations);
    Set<OWLOntology> ont2=new HashSet<OWLOntology>();
    ont2.add(extendedOntology);
    PelletExplanationGenerator expGen=new PelletExplanationGenerator(man2,ont2);
    Set<Explanation> currentExplanations=expGen.getExplanations((OWLAxiom)entailment);
    allPreviouslyFoundExplanations.addAll(currentExplanations);
    if (allPreviouslyFoundExplanations.equals(allPrevJustsCopy)) {
      break;
    }
    for (    Explanation currentExplanation : currentExplanations) {
      if (!laconicExplanations.contains(currentExplanation) && !nonLaconicExplanations.contains(currentExplanation)) {
        if (isLaconic(currentExplanation)) {
          laconicExplanations.add(currentExplanation);
        }
 else {
          nonLaconicExplanations.add(currentExplanation);
        }
        if (laconicExplanations.size() == limit) {
          return laconicExplanations;
        }
      }
    }
  }
  Set<Explanation> explanations=new HashSet<Explanation>();
  for (  Explanation explanation : allPreviouslyFoundExplanations) {
    if (!nonLaconicExplanations.contains(explanation)) {
      if (laconicExplanations.contains(explanation)) {
        explanations.add(explanation);
      }
 else       if (isLaconic(explanation)) {
        explanations.add(explanation);
      }
    }
  }
  return retrieveAxioms(explanations);
}"
9884,"@Override public boolean equals(Object o){
  return (compareTo((Individual)o) == 0);
}","@Override public boolean equals(Object o){
  if (o == null) {
    return false;
  }
  return (compareTo((Individual)o) == 0);
}"
9885,"/** 
 * This convenience method can be used to store and exchange evaluated descriptions by transforming them to a JSON string.
 * @return A JSON representation of an evaluated description.
 */
@Override public String asJSON(){
  JSONObject object=new JSONObject();
  try {
    object.put(""String_Node_Str"",description.toManchesterSyntaxString(null,null));
    OWLDescription d=OWLAPIDescriptionConvertVisitor.getOWLDescription(description);
    object.put(""String_Node_Str"",OWLAPIRenderers.toOWLXMLSyntax(d));
    object.put(""String_Node_Str"",description.toKBSyntaxString());
    object.put(""String_Node_Str"",score.getAccuracy());
    object.put(""String_Node_Str"",getAdditionalInstances());
    object.put(""String_Node_Str"",getCoveredInstances());
    object.put(""String_Node_Str"",isConsistent());
    object.put(""String_Node_Str"",getCoverage());
    object.put(""String_Node_Str"",getAddition());
    return object.toString(3);
  }
 catch (  JSONException e) {
    e.printStackTrace();
    return null;
  }
}","/** 
 * This convenience method can be used to store and exchange evaluated descriptions by transforming them to a JSON string.
 * @return A JSON representation of an evaluated description.
 */
@Override public String asJSON(){
  JSONObject object=new JSONObject();
  try {
    object.put(""String_Node_Str"",description.toManchesterSyntaxString(null,null));
    OWLDescription d=OWLAPIDescriptionConvertVisitor.getOWLDescription(description);
    object.put(""String_Node_Str"",OWLAPIRenderers.toOWLXMLSyntax(d));
    object.put(""String_Node_Str"",description.toKBSyntaxString());
    object.put(""String_Node_Str"",score.getAccuracy());
    object.put(""String_Node_Str"",new JSONArray(getAdditionalInstances()));
    object.put(""String_Node_Str"",new JSONArray(getCoveredInstances()));
    object.put(""String_Node_Str"",isConsistent());
    object.put(""String_Node_Str"",getCoverage());
    object.put(""String_Node_Str"",getAddition());
    return object.toString(3);
  }
 catch (  JSONException e) {
    e.printStackTrace();
    return null;
  }
}"
9886,"public void loadOntologies(){
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getURI().compareTo(o2.getURI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLIndividual> owlIndividuals=new TreeSet<OWLIndividual>(namedObjectComparator);
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      try {
        if (source instanceof OWLAPIOntology) {
          ontology=((OWLAPIOntology)source).getOWLOntolgy();
        }
 else         if (source instanceof SparqlKnowledgeSource) {
          ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
        }
 else {
          ontology=manager.loadOntologyFromPhysicalURI(url.toURI());
        }
        owlAPIOntologies.add(ontology);
        Set<OWLOntology> imports=manager.getImportsClosure(ontology);
        allImports.addAll(imports);
        for (        OWLOntology ont : imports) {
          classes.addAll(ont.getReferencedClasses());
          owlObjectProperties.addAll(ont.getReferencedObjectProperties());
          owlDatatypeProperties.addAll(ont.getReferencedDataProperties());
          owlIndividuals.addAll(ont.getReferencedIndividuals());
        }
        OWLOntologyFormat format=manager.getOntologyFormat(ontology);
        if (format instanceof NamespaceOWLOntologyFormat) {
          prefixes.putAll(((NamespaceOWLOntologyFormat)format).getNamespacesByPrefixMap());
          baseURI=prefixes.get(""String_Node_Str"");
          prefixes.remove(""String_Node_Str"");
        }
        for (        OWLClass owlClass : classes)         atomicConcepts.add(new NamedClass(owlClass.getURI().toString()));
        for (        OWLObjectProperty owlProperty : owlObjectProperties)         atomicRoles.add(new ObjectProperty(owlProperty.getURI().toString()));
        for (        OWLDataProperty owlProperty : owlDatatypeProperties) {
          DatatypeProperty dtp=new DatatypeProperty(owlProperty.getURI().toString());
          Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
          Iterator<OWLDataRange> it=ranges.iterator();
          if (it.hasNext()) {
            OWLDataRange range=it.next();
            if (range.isDataType()) {
              URI uri=((OWLDataType)range).getURI();
              if (uri.equals(Datatype.BOOLEAN.getURI()))               booleanDatatypeProperties.add(dtp);
 else               if (uri.equals(Datatype.DOUBLE.getURI()))               doubleDatatypeProperties.add(dtp);
 else               if (uri.equals(Datatype.INT.getURI()))               intDatatypeProperties.add(dtp);
            }
          }
          datatypeProperties.add(dtp);
        }
        for (        OWLIndividual owlIndividual : owlIndividuals) {
          individuals.add(new Individual(owlIndividual.getURI().toString()));
        }
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
catch (      URISyntaxException e) {
        e.printStackTrace();
      }
    }
 else {
      KB kb=source.toKB();
      URI ontologyURI=URI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyURI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  try {
    classifier.loadOntologies(allImports);
  }
 catch (  OWLReasonerException e) {
    e.printStackTrace();
  }
}","public void loadOntologies() throws URISyntaxException, OWLOntologyCreationException {
  Comparator<OWLNamedObject> namedObjectComparator=new Comparator<OWLNamedObject>(){
    public int compare(    OWLNamedObject o1,    OWLNamedObject o2){
      return o1.getURI().compareTo(o2.getURI());
    }
  }
;
  Set<OWLClass> classes=new TreeSet<OWLClass>(namedObjectComparator);
  Set<OWLObjectProperty> owlObjectProperties=new TreeSet<OWLObjectProperty>(namedObjectComparator);
  Set<OWLDataProperty> owlDatatypeProperties=new TreeSet<OWLDataProperty>(namedObjectComparator);
  Set<OWLIndividual> owlIndividuals=new TreeSet<OWLIndividual>(namedObjectComparator);
  Set<OWLOntology> allImports=new HashSet<OWLOntology>();
  prefixes=new TreeMap<String,String>();
  for (  KnowledgeSource source : sources) {
    if (source instanceof OWLFile || source instanceof SparqlKnowledgeSource || source instanceof OWLAPIOntology) {
      URL url=null;
      if (source instanceof OWLFile) {
        url=((OWLFile)source).getURL();
      }
      if (source instanceof OWLAPIOntology) {
        ontology=((OWLAPIOntology)source).getOWLOntolgy();
      }
 else       if (source instanceof SparqlKnowledgeSource) {
        ontology=((SparqlKnowledgeSource)source).getOWLAPIOntology();
      }
 else {
        ontology=manager.loadOntologyFromPhysicalURI(url.toURI());
      }
      owlAPIOntologies.add(ontology);
      Set<OWLOntology> imports=manager.getImportsClosure(ontology);
      allImports.addAll(imports);
      for (      OWLOntology ont : imports) {
        classes.addAll(ont.getReferencedClasses());
        owlObjectProperties.addAll(ont.getReferencedObjectProperties());
        owlDatatypeProperties.addAll(ont.getReferencedDataProperties());
        owlIndividuals.addAll(ont.getReferencedIndividuals());
      }
      OWLOntologyFormat format=manager.getOntologyFormat(ontology);
      if (format instanceof NamespaceOWLOntologyFormat) {
        prefixes.putAll(((NamespaceOWLOntologyFormat)format).getNamespacesByPrefixMap());
        baseURI=prefixes.get(""String_Node_Str"");
        prefixes.remove(""String_Node_Str"");
      }
      for (      OWLClass owlClass : classes)       atomicConcepts.add(new NamedClass(owlClass.getURI().toString()));
      for (      OWLObjectProperty owlProperty : owlObjectProperties)       atomicRoles.add(new ObjectProperty(owlProperty.getURI().toString()));
      for (      OWLDataProperty owlProperty : owlDatatypeProperties) {
        DatatypeProperty dtp=new DatatypeProperty(owlProperty.getURI().toString());
        Set<OWLDataRange> ranges=owlProperty.getRanges(allImports);
        Iterator<OWLDataRange> it=ranges.iterator();
        if (it.hasNext()) {
          OWLDataRange range=it.next();
          if (range.isDataType()) {
            URI uri=((OWLDataType)range).getURI();
            if (uri.equals(Datatype.BOOLEAN.getURI()))             booleanDatatypeProperties.add(dtp);
 else             if (uri.equals(Datatype.DOUBLE.getURI()))             doubleDatatypeProperties.add(dtp);
 else             if (uri.equals(Datatype.INT.getURI()))             intDatatypeProperties.add(dtp);
          }
        }
        datatypeProperties.add(dtp);
      }
      for (      OWLIndividual owlIndividual : owlIndividuals) {
        individuals.add(new Individual(owlIndividual.getURI().toString()));
      }
    }
 else {
      KB kb=source.toKB();
      URI ontologyURI=URI.create(""String_Node_Str"");
      ontology=null;
      try {
        ontology=manager.createOntology(ontologyURI);
      }
 catch (      OWLOntologyCreationException e) {
        e.printStackTrace();
      }
      OWLAPIAxiomConvertVisitor.fillOWLOntology(manager,ontology,kb);
      owlAPIOntologies.add(ontology);
      allImports.add(ontology);
      atomicConcepts.addAll(kb.findAllAtomicConcepts());
      atomicRoles.addAll(kb.findAllAtomicRoles());
      individuals.addAll(kb.findAllIndividuals());
    }
  }
  try {
    classifier.loadOntologies(allImports);
  }
 catch (  OWLReasonerException e) {
    e.printStackTrace();
  }
}"
9887,"/** 
 * main method.
 * @param args possible is to use OWL-File as parameter
 */
public static void main(String[] args){
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  UnsupportedLookAndFeelException e) {
    e.printStackTrace();
  }
  Locale.setDefault(Locale.ENGLISH);
  final Wizard wizard=new Wizard();
  wizard.getDialog().setTitle(""String_Node_Str"");
  Dimension dim=java.awt.Toolkit.getDefaultToolkit().getScreenSize();
  wizard.getDialog().setSize(dim);
  WizardPanelDescriptor descriptor1=new IntroductionPanelDescriptor();
  wizard.registerWizardPanel(IntroductionPanelDescriptor.IDENTIFIER,descriptor1);
  WizardPanelDescriptor descriptor2=new KnowledgeSourcePanelDescriptor();
  wizard.registerWizardPanel(KnowledgeSourcePanelDescriptor.IDENTIFIER,descriptor2);
  WizardPanelDescriptor descriptor5=new ClassChoosePanelDescriptor();
  wizard.registerWizardPanel(ClassChoosePanelDescriptor.IDENTIFIER,descriptor5);
  WizardPanelDescriptor descriptor6=new LearningPanelDescriptor();
  wizard.registerWizardPanel(LearningPanelDescriptor.IDENTIFIER,descriptor6);
  WizardPanelDescriptor descriptor7=new RepairPanelDescriptor();
  wizard.registerWizardPanel(RepairPanelDescriptor.IDENTIFIER,descriptor7);
  WizardPanelDescriptor descriptor8=new SavePanelDescriptor();
  wizard.registerWizardPanel(SavePanelDescriptor.IDENTIFIER,descriptor8);
  if (!(args.length == 1)) {
    wizard.setCurrentPanel(IntroductionPanelDescriptor.IDENTIFIER);
  }
 else {
    wizard.setCurrentPanel(KnowledgeSourcePanelDescriptor.IDENTIFIER);
    wizard.setLeftPanel(1);
    ((KnowledgeSourcePanelDescriptor)wizard.getModel().getPanelHashMap().get(KnowledgeSourcePanelDescriptor.IDENTIFIER)).loadOntology(new File(args[0]).toURI());
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      int ret=wizard.showModalDialog();
      System.out.println(""String_Node_Str"" + ret);
      System.exit(0);
    }
  }
);
}","/** 
 * main method.
 * @param args possible is to use URI as parameter
 */
public static void main(String[] args){
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  UnsupportedLookAndFeelException e) {
    e.printStackTrace();
  }
  Locale.setDefault(Locale.ENGLISH);
  final Wizard wizard=new Wizard();
  wizard.getDialog().setTitle(""String_Node_Str"");
  Dimension dim=java.awt.Toolkit.getDefaultToolkit().getScreenSize();
  wizard.getDialog().setSize(dim);
  WizardPanelDescriptor descriptor1=new IntroductionPanelDescriptor();
  wizard.registerWizardPanel(IntroductionPanelDescriptor.IDENTIFIER,descriptor1);
  WizardPanelDescriptor descriptor2=new KnowledgeSourcePanelDescriptor();
  wizard.registerWizardPanel(KnowledgeSourcePanelDescriptor.IDENTIFIER,descriptor2);
  WizardPanelDescriptor descriptor5=new ClassChoosePanelDescriptor();
  wizard.registerWizardPanel(ClassChoosePanelDescriptor.IDENTIFIER,descriptor5);
  WizardPanelDescriptor descriptor6=new LearningPanelDescriptor();
  wizard.registerWizardPanel(LearningPanelDescriptor.IDENTIFIER,descriptor6);
  WizardPanelDescriptor descriptor7=new RepairPanelDescriptor();
  wizard.registerWizardPanel(RepairPanelDescriptor.IDENTIFIER,descriptor7);
  WizardPanelDescriptor descriptor8=new SavePanelDescriptor();
  wizard.registerWizardPanel(SavePanelDescriptor.IDENTIFIER,descriptor8);
  if (!(args.length == 1)) {
    wizard.setCurrentPanel(IntroductionPanelDescriptor.IDENTIFIER);
  }
 else {
    wizard.setCurrentPanel(KnowledgeSourcePanelDescriptor.IDENTIFIER);
    wizard.setLeftPanel(1);
    ((KnowledgeSourcePanelDescriptor)wizard.getModel().getPanelHashMap().get(KnowledgeSourcePanelDescriptor.IDENTIFIER)).loadOntology(new File(args[0]).toURI());
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      System.out.println(""String_Node_Str"");
      int ret=wizard.showModalDialog();
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
  }
);
}"
9888,"@Override public void run(){
  int ret=wizard.showModalDialog();
  System.out.println(""String_Node_Str"" + ret);
  System.exit(0);
}","@Override public void run(){
  System.out.println(""String_Node_Str"");
  int ret=wizard.showModalDialog();
  System.out.println(""String_Node_Str"");
  System.exit(0);
}"
9889,"public void loadOntology(){
  reasoner.loadOntologies();
}","public void loadOntology() throws OWLOntologyCreationException, URISyntaxException {
  reasoner.loadOntologies();
}"
9890,"public void initPelletReasoner(){
  reasoner=cm.reasoner(PelletReasoner.class,ks);
  try {
    reasoner.init();
  }
 catch (  ComponentInitException e) {
    e.printStackTrace();
  }
  reasoner.loadOntologies();
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  modifier=new OntologyModifier(reasoner);
  fireActiveOntologyChanged();
}","public void initPelletReasoner() throws URISyntaxException, OWLOntologyCreationException {
  reasoner=cm.reasoner(PelletReasoner.class,ks);
  try {
    reasoner.init();
  }
 catch (  ComponentInitException e) {
    e.printStackTrace();
  }
  reasoner.loadOntologies();
  baseURI=reasoner.getBaseURI();
  prefixes=reasoner.getPrefixes();
  modifier=new OntologyModifier(reasoner);
  fireActiveOntologyChanged();
}"
9891,"@SuppressWarnings(""String_Node_Str"") private void deserialize(){
  try {
    FileInputStream fileStream=new FileInputStream(file);
    ObjectInputStream inputStream=new ObjectInputStream(new BufferedInputStream(fileStream));
    try {
      List<URI> list=(List<URI>)inputStream.readObject();
      uriList.addAll(list);
    }
  finally {
      inputStream.close();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
}","@SuppressWarnings(""String_Node_Str"") private void deserialize(){
  try {
    FileInputStream fileStream=new FileInputStream(file);
    ObjectInputStream inputStream=new ObjectInputStream(new BufferedInputStream(fileStream));
    try {
      List<URI> list=(List<URI>)inputStream.readObject();
      if (list != null) {
        uriList.addAll(list);
      }
    }
  finally {
      inputStream.close();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
}"
9892,"public Set<OWLAxiom> getRemainingAxioms(OWLAxiom source,OWLAxiom part){
  Set<OWLAxiom> parts=computeOPlus(Collections.singleton(source));
  System.out.println(""String_Node_Str"" + parts);
  parts.remove(part);
  System.out.println(""String_Node_Str"" + part);
  for (  OWLAxiom pa : parts) {
    System.out.println(""String_Node_Str"" + pa + ""String_Node_Str""+ oPlus.getAxiomsMap().get(pa));
    if (oPlus.getAxiomsMap().get(pa).size() == 1) {
      System.out.println(""String_Node_Str"" + pa);
    }
  }
  return rebuildAxioms(parts);
}","public Set<OWLAxiom> getRemainingAxioms(OWLAxiom source,OWLAxiom part){
  Set<OWLAxiom> parts=computeOPlus(Collections.singleton(source));
  for (  OWLAxiom par : parts) {
    System.out.println(""String_Node_Str"" + par);
  }
  for (  OWLAxiom pa : parts) {
    System.out.println(""String_Node_Str"" + pa);
    for (    OWLAxiom ax : oPlus.getAxiomsMap().get(pa)) {
      System.out.println(""String_Node_Str"" + ax);
    }
  }
  return rebuildAxioms(parts);
}"
9893,"private Set<OWLAxiom> rebuildAxioms(Set<OWLAxiom> axioms){
  Map<OWLAxiom,Set<OWLAxiom>> sourceAxioms2OPlus=new HashMap<OWLAxiom,Set<OWLAxiom>>();
  for (  OWLAxiom ax : axioms) {
    if (ontology.containsAxiom(ax)) {
      sourceAxioms2OPlus.put(ax,computeOPlus(Collections.singleton(ax)));
    }
  }
  Map<OWLClass,Map<OWLAxiom,Set<OWLSubClassAxiom>>> lhs2SubClassAxiom=new HashMap<OWLClass,Map<OWLAxiom,Set<OWLSubClassAxiom>>>();
  Set<OWLAxiom> reconstituedAxioms=new HashSet<OWLAxiom>();
  for (  OWLAxiom laconicAx : axioms) {
    if (laconicAx instanceof OWLSubClassAxiom) {
      OWLSubClassAxiom subAx=(OWLSubClassAxiom)laconicAx;
      if (subAx.getSubClass().isAnonymous()) {
        reconstituedAxioms.add(subAx);
      }
 else {
        Map<OWLAxiom,Set<OWLSubClassAxiom>> source2AxiomMap=lhs2SubClassAxiom.get(subAx.getSubClass().asOWLClass());
        if (source2AxiomMap == null) {
          source2AxiomMap=new HashMap<OWLAxiom,Set<OWLSubClassAxiom>>();
          lhs2SubClassAxiom.put(subAx.getSubClass().asOWLClass(),source2AxiomMap);
        }
        for (        OWLAxiom sourceAxiom : sourceAxioms2OPlus.keySet()) {
          if ((sourceAxioms2OPlus.get(sourceAxiom)).contains(subAx)) {
            Set<OWLSubClassAxiom> subClassAxioms=source2AxiomMap.get(sourceAxiom);
            if (subClassAxioms == null) {
              subClassAxioms=new HashSet<OWLSubClassAxiom>();
              source2AxiomMap.put(sourceAxiom,subClassAxioms);
            }
            subClassAxioms.add(subAx);
          }
        }
      }
    }
 else {
      reconstituedAxioms.add(laconicAx);
    }
  }
  Set<OWLAxiom> consumedAxioms=new HashSet<OWLAxiom>();
  for (  OWLClass lhs : lhs2SubClassAxiom.keySet()) {
    Map<OWLAxiom,Set<OWLSubClassAxiom>> source2SubClassAxiom=lhs2SubClassAxiom.get(lhs);
    for (    OWLAxiom source : source2SubClassAxiom.keySet()) {
      Set<OWLDescription> rightHandSides=new HashSet<OWLDescription>();
      for (      OWLSubClassAxiom sub : source2SubClassAxiom.get(source)) {
        if (!consumedAxioms.contains(sub)) {
          rightHandSides.add(sub.getSuperClass());
          consumedAxioms.add(sub);
        }
      }
      if (rightHandSides.size() == 1)       reconstituedAxioms.add(manager.getOWLDataFactory().getOWLSubClassAxiom((OWLDescription)lhs,((OWLDescription)rightHandSides.iterator().next())));
 else       if (rightHandSides.size() > 1) {
        org.semanticweb.owl.model.OWLObjectIntersectionOf conjunction=manager.getOWLDataFactory().getOWLObjectIntersectionOf(rightHandSides);
        reconstituedAxioms.add(manager.getOWLDataFactory().getOWLSubClassAxiom((OWLDescription)lhs,conjunction));
      }
    }
  }
  return reconstituedAxioms;
}","private Set<OWLAxiom> rebuildAxioms(Set<OWLAxiom> axioms){
  Map<OWLAxiom,Set<OWLAxiom>> sourceAxioms2OPlus=new HashMap<OWLAxiom,Set<OWLAxiom>>();
  for (  OWLAxiom ax : axioms) {
    if (ontology.containsAxiom(ax)) {
      sourceAxioms2OPlus.put(ax,computeOPlus(Collections.singleton(ax)));
    }
  }
  Map<OWLClass,Map<OWLAxiom,Set<OWLSubClassAxiom>>> lhs2SubClassAxiom=new HashMap<OWLClass,Map<OWLAxiom,Set<OWLSubClassAxiom>>>();
  Set<OWLAxiom> reconstituedAxioms=new HashSet<OWLAxiom>();
  for (  OWLAxiom laconicAx : axioms) {
    System.out.println(""String_Node_Str"" + laconicAx);
    if (laconicAx instanceof OWLSubClassAxiom) {
      OWLSubClassAxiom subAx=(OWLSubClassAxiom)laconicAx;
      if (subAx.getSubClass().isAnonymous()) {
        reconstituedAxioms.add(subAx);
      }
 else {
        Map<OWLAxiom,Set<OWLSubClassAxiom>> source2AxiomMap=lhs2SubClassAxiom.get(subAx.getSubClass().asOWLClass());
        if (source2AxiomMap == null) {
          source2AxiomMap=new HashMap<OWLAxiom,Set<OWLSubClassAxiom>>();
          lhs2SubClassAxiom.put(subAx.getSubClass().asOWLClass(),source2AxiomMap);
        }
        for (        OWLAxiom sourceAxiom : sourceAxioms2OPlus.keySet()) {
          if ((sourceAxioms2OPlus.get(sourceAxiom)).contains(subAx)) {
            Set<OWLSubClassAxiom> subClassAxioms=source2AxiomMap.get(sourceAxiom);
            if (subClassAxioms == null) {
              subClassAxioms=new HashSet<OWLSubClassAxiom>();
              source2AxiomMap.put(sourceAxiom,subClassAxioms);
            }
            subClassAxioms.add(subAx);
          }
        }
      }
    }
 else {
      reconstituedAxioms.add(laconicAx);
    }
  }
  Set<OWLAxiom> consumedAxioms=new HashSet<OWLAxiom>();
  for (  OWLClass lhs : lhs2SubClassAxiom.keySet()) {
    Map<OWLAxiom,Set<OWLSubClassAxiom>> source2SubClassAxiom=lhs2SubClassAxiom.get(lhs);
    for (    OWLAxiom source : source2SubClassAxiom.keySet()) {
      Set<OWLDescription> rightHandSides=new HashSet<OWLDescription>();
      for (      OWLSubClassAxiom sub : source2SubClassAxiom.get(source)) {
        if (!consumedAxioms.contains(sub)) {
          rightHandSides.add(sub.getSuperClass());
          consumedAxioms.add(sub);
        }
      }
      if (rightHandSides.size() == 1)       reconstituedAxioms.add(manager.getOWLDataFactory().getOWLSubClassAxiom((OWLDescription)lhs,((OWLDescription)rightHandSides.iterator().next())));
 else       if (rightHandSides.size() > 1) {
        org.semanticweb.owl.model.OWLObjectIntersectionOf conjunction=manager.getOWLDataFactory().getOWLObjectIntersectionOf(rightHandSides);
        reconstituedAxioms.add(manager.getOWLDataFactory().getOWLSubClassAxiom((OWLDescription)lhs,conjunction));
      }
    }
  }
  return reconstituedAxioms;
}"
9894,"/** 
 * main method.
 * @param args possible is to use URI as parameter
 */
public static void main(String[] args){
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  UnsupportedLookAndFeelException e) {
    e.printStackTrace();
  }
  Locale.setDefault(Locale.ENGLISH);
  final Wizard wizard=new Wizard();
  wizard.getDialog().setTitle(""String_Node_Str"");
  Dimension dim=java.awt.Toolkit.getDefaultToolkit().getScreenSize();
  wizard.getDialog().setSize(dim);
  WizardPanelDescriptor descriptor1=new IntroductionPanelDescriptor();
  wizard.registerWizardPanel(IntroductionPanelDescriptor.IDENTIFIER,descriptor1);
  WizardPanelDescriptor descriptor2=new KnowledgeSourcePanelDescriptor();
  wizard.registerWizardPanel(KnowledgeSourcePanelDescriptor.IDENTIFIER,descriptor2);
  WizardPanelDescriptor descriptor5=new ClassChoosePanelDescriptor();
  wizard.registerWizardPanel(ClassChoosePanelDescriptor.IDENTIFIER,descriptor5);
  WizardPanelDescriptor descriptor6=new LearningPanelDescriptor();
  wizard.registerWizardPanel(LearningPanelDescriptor.IDENTIFIER,descriptor6);
  WizardPanelDescriptor descriptor7=new RepairPanelDescriptor();
  wizard.registerWizardPanel(RepairPanelDescriptor.IDENTIFIER,descriptor7);
  WizardPanelDescriptor descriptor8=new SavePanelDescriptor();
  wizard.registerWizardPanel(SavePanelDescriptor.IDENTIFIER,descriptor8);
  if (!(args.length == 1)) {
    wizard.setCurrentPanel(IntroductionPanelDescriptor.IDENTIFIER);
  }
 else {
    wizard.setCurrentPanel(KnowledgeSourcePanelDescriptor.IDENTIFIER);
    wizard.setLeftPanel(1);
    ((KnowledgeSourcePanelDescriptor)wizard.getModel().getPanelHashMap().get(KnowledgeSourcePanelDescriptor.IDENTIFIER)).loadOntology(new File(args[0]).toURI());
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      System.out.println(""String_Node_Str"");
      int ret=wizard.showModalDialog();
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
  }
);
}","/** 
 * main method.
 * @param args possible is to use URI as parameter
 */
public static void main(String[] args){
  try {
    PropertyConfigurator.configure(new URL(""String_Node_Str""));
  }
 catch (  MalformedURLException e1) {
    e1.printStackTrace();
  }
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  UnsupportedLookAndFeelException e) {
    e.printStackTrace();
  }
  Locale.setDefault(Locale.ENGLISH);
  final Wizard wizard=new Wizard();
  wizard.getDialog().setTitle(""String_Node_Str"");
  Dimension dim=java.awt.Toolkit.getDefaultToolkit().getScreenSize();
  wizard.getDialog().setSize(dim);
  WizardPanelDescriptor descriptor1=new IntroductionPanelDescriptor();
  wizard.registerWizardPanel(IntroductionPanelDescriptor.IDENTIFIER,descriptor1);
  WizardPanelDescriptor descriptor2=new KnowledgeSourcePanelDescriptor();
  wizard.registerWizardPanel(KnowledgeSourcePanelDescriptor.IDENTIFIER,descriptor2);
  WizardPanelDescriptor descriptor5=new ClassChoosePanelDescriptor();
  wizard.registerWizardPanel(ClassChoosePanelDescriptor.IDENTIFIER,descriptor5);
  WizardPanelDescriptor descriptor6=new LearningPanelDescriptor();
  wizard.registerWizardPanel(LearningPanelDescriptor.IDENTIFIER,descriptor6);
  WizardPanelDescriptor descriptor7=new RepairPanelDescriptor();
  wizard.registerWizardPanel(RepairPanelDescriptor.IDENTIFIER,descriptor7);
  WizardPanelDescriptor descriptor8=new SavePanelDescriptor();
  wizard.registerWizardPanel(SavePanelDescriptor.IDENTIFIER,descriptor8);
  if (!(args.length == 1)) {
    wizard.setCurrentPanel(IntroductionPanelDescriptor.IDENTIFIER);
  }
 else {
    wizard.setCurrentPanel(KnowledgeSourcePanelDescriptor.IDENTIFIER);
    wizard.setLeftPanel(1);
    ((KnowledgeSourcePanelDescriptor)wizard.getModel().getPanelHashMap().get(KnowledgeSourcePanelDescriptor.IDENTIFIER)).loadOntology(new File(args[0]).toURI());
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      System.out.println(""String_Node_Str"");
      wizard.showModalDialog();
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
  }
);
}"
9895,"@Override public void run(){
  System.out.println(""String_Node_Str"");
  int ret=wizard.showModalDialog();
  System.out.println(""String_Node_Str"");
  System.exit(0);
}","@Override public void run(){
  System.out.println(""String_Node_Str"");
  wizard.showModalDialog();
  System.out.println(""String_Node_Str"");
  System.exit(0);
}"
9896,"public static void main(String[] args) throws OWLOntologyCreationException {
  String file=""String_Node_Str"";
  String NS=""String_Node_Str"";
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  OWLDataFactory factory=manager.getOWLDataFactory();
  OWLOntology ontology=manager.loadOntology(URI.create(file));
  Reasoner reasoner=new PelletReasonerFactory().createReasoner(manager);
  reasoner.loadOntology(ontology);
  OWLDataProperty property=factory.getOWLDataProperty(URI.create(NS + ""String_Node_Str""));
  OWLClass domain=factory.getOWLClass(URI.create(NS + ""String_Node_Str""));
  OWLDataPropertyDomainAxiom axiom=factory.getOWLDataPropertyDomainAxiom(property,domain);
  PelletExplanation expGen=new PelletExplanation(manager,Collections.singleton(ontology));
  System.out.println(reasoner.isEntailed(axiom));
}","public static void main(String[] args) throws OWLOntologyCreationException {
  String file=""String_Node_Str"";
  String NS=""String_Node_Str"";
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  OWLDataFactory factory=manager.getOWLDataFactory();
  OWLOntology ontology=manager.loadOntology(URI.create(file));
  Reasoner reasoner=new PelletReasonerFactory().createReasoner(manager);
  reasoner.loadOntology(ontology);
  OWLDataProperty property=factory.getOWLDataProperty(URI.create(NS + ""String_Node_Str""));
  OWLClass domain=factory.getOWLClass(URI.create(NS + ""String_Node_Str""));
  OWLDataPropertyDomainAxiom axiom=factory.getOWLDataPropertyDomainAxiom(property,domain);
  PelletExplanation expGen=new PelletExplanation(manager,Collections.singleton(ontology));
  System.out.println(reasoner.isEntailed(axiom));
  System.out.println(expGen.getEntailmentExplanations(axiom));
  OWLDataRange range=factory.getTopDataType();
  OWLDataSomeRestriction dataSome=factory.getOWLDataSomeRestriction(property,range);
  OWLSubClassAxiom subClass=factory.getOWLSubClassAxiom(dataSome,domain);
  System.out.println(reasoner.isEntailed(subClass));
  System.out.println(expGen.getEntailmentExplanations(subClass));
}"
9897,"public void removeFromRepairPlan(OWLOntologyChange change){
  repairPlan.remove(change);
  fireRepairPlanChanged();
}","public void removeFromRepairPlan(List<OWLOntologyChange> changes){
  repairPlan.removeAll(changes);
  fireRepairPlanChanged();
}"
9898,"public void addToRepairPlan(OWLOntologyChange change){
  repairPlan.add(change);
  fireRepairPlanChanged();
}","public void addToRepairPlan(List<OWLOntologyChange> changes){
  repairPlan.addAll(changes);
  fireRepairPlanChanged();
}"
9899,"private Set<Explanation> computeLaconicExplanations(OWLAxiom entailment,int limit) throws ExplanationException {
  Set<Explanation> explanations=laconicExplanationCache.get(entailment);
  Integer lastRequestedSize=lastRequestedLaconicSize.get(entailment);
  if (lastRequestedSize == null) {
    lastRequestedSize=Integer.valueOf(0);
  }
  if (explanations == null || lastRequestedSize.intValue() != -1 && lastRequestedSize.intValue() < limit) {
    OWLOntology module=axiom2Module.get(entailment);
    if (module == null) {
      module=OntologyUtils.getOntologyFromAxioms(ModularityUtils.extractModule(Collections.singleton(ontology),entailment.getSignature(),ModuleType.TOP_OF_BOT));
    }
    axiom2Module.put(entailment,module);
    laconicExpGen=new LaconicExplanationGenerator(manager,new PelletReasonerFactory(),Collections.singleton(module));
    if (limit == -1) {
      explanations=laconicExpGen.getExplanations(entailment);
    }
 else {
      explanations=laconicExpGen.getExplanations(entailment,limit);
    }
    laconicExplanationCache.put(entailment,explanations);
    lastRequestedLaconicSize.put(entailment,Integer.valueOf(limit));
  }
  return explanations;
}","private Set<Explanation> computeLaconicExplanations(OWLAxiom entailment,int limit) throws ExplanationException {
  Set<Explanation> explanations=laconicExplanationCache.get(entailment);
  Integer lastRequestedSize=lastRequestedLaconicSize.get(entailment);
  if (lastRequestedSize == null) {
    lastRequestedSize=Integer.valueOf(0);
  }
  if (explanations == null || lastRequestedSize.intValue() != -1 && lastRequestedSize.intValue() < limit) {
    OWLOntology module=axiom2Module.get(entailment);
    if (module == null) {
      module=OntologyUtils.getOntologyFromAxioms(ModularityUtils.extractModule(Collections.singleton(ontology),entailment.getSignature(),ModuleType.TOP_OF_BOT));
    }
    axiom2Module.put(entailment,module);
    laconicExpGen=new LaconicExplanationGenerator(manager,new PelletReasonerFactory(),Collections.singleton(module));
    laconicExpGen.setProgressMonitor(TaskManager.getInstance().getStatusBar());
    if (limit == -1) {
      explanations=laconicExpGen.getExplanations(entailment);
    }
 else {
      explanations=laconicExpGen.getExplanations(entailment,limit);
    }
    laconicExplanationCache.put(entailment,explanations);
    lastRequestedLaconicSize.put(entailment,Integer.valueOf(limit));
  }
  return explanations;
}"
9900,"public Set<Set<OWLAxiom>> getExplanations(OWLDescription unsatClass,int maxExplanations){
  if (maxExplanations < 0)   throw new IllegalArgumentException();
  if (log.isLoggable(Level.CONFIG))   log.config(""String_Node_Str"" + (maxExplanations == 0 ? ""String_Node_Str"" : maxExplanations) + ""String_Node_Str""+ unsatClass);
  try {
    Set<OWLAxiom> firstMups=getExplanation(unsatClass);
    if (firstMups.isEmpty()) {
      return Collections.emptySet();
    }
    Set<Set<OWLAxiom>> allMups=new LinkedHashSet<Set<OWLAxiom>>();
    progressMonitor.foundExplanation(firstMups);
    allMups.add(firstMups);
    Set<Set<OWLAxiom>> satPaths=new HashSet<Set<OWLAxiom>>();
    Set<OWLAxiom> currentPathContents=new HashSet<OWLAxiom>();
    singleExplanationGenerator.beginTransaction();
    try {
      constructHittingSetTree(unsatClass,firstMups,allMups,satPaths,currentPathContents,maxExplanations);
    }
  finally {
      singleExplanationGenerator.endTransaction();
    }
    progressMonitor.foundAllExplanations();
    return allMups;
  }
 catch (  OWLException e) {
    throw new OWLRuntimeException(e);
  }
}","public Set<Set<OWLAxiom>> getExplanations(OWLDescription unsatClass,int maxExplanations){
  if (maxExplanations < 0)   throw new IllegalArgumentException();
  logger.debug(""String_Node_Str"" + (maxExplanations == 0 ? ""String_Node_Str"" : maxExplanations) + ""String_Node_Str""+ unsatClass);
  try {
    Set<OWLAxiom> firstMups=getExplanation(unsatClass);
    if (firstMups.isEmpty()) {
      return Collections.emptySet();
    }
    Set<Set<OWLAxiom>> allMups=new LinkedHashSet<Set<OWLAxiom>>();
    progressMonitor.foundExplanation(firstMups);
    allMups.add(firstMups);
    Set<Set<OWLAxiom>> satPaths=new HashSet<Set<OWLAxiom>>();
    Set<OWLAxiom> currentPathContents=new HashSet<OWLAxiom>();
    singleExplanationGenerator.beginTransaction();
    try {
      constructHittingSetTree(unsatClass,firstMups,allMups,satPaths,currentPathContents,maxExplanations);
    }
  finally {
      singleExplanationGenerator.endTransaction();
    }
    progressMonitor.foundAllExplanations();
    return allMups;
  }
 catch (  OWLException e) {
    throw new OWLRuntimeException(e);
  }
}"
9901,"/** 
 * This is a recursive method that builds a hitting set tree to obtain all justifications for an unsatisfiable class.
 * @param mups                The current justification for the current class. Thiscorresponds to a node in the hitting set tree.
 * @param allMups             All of the MUPS that have been found - this set gets populatedover the course of the tree building process. Initially this should just contain the first justification
 * @param satPaths            Paths that have been completed.
 * @param currentPathContents The contents of the current path. Initially this should be anempty set.
 */
private void constructHittingSetTree(OWLDescription unsatClass,Set<OWLAxiom> mups,Set<Set<OWLAxiom>> allMups,Set<Set<OWLAxiom>> satPaths,Set<OWLAxiom> currentPathContents,int maxExplanations) throws OWLException {
  if (log.isLoggable(Level.FINE))   log.fine(""String_Node_Str"" + allMups.size() + ""String_Node_Str""+ mups);
  if (progressMonitor.isCancelled()) {
    return;
  }
  List<OWLAxiom> orderedMups=getOrderedMUPS(new ArrayList<OWLAxiom>(mups),allMups);
  while (!orderedMups.isEmpty()) {
    if (progressMonitor.isCancelled()) {
      return;
    }
    OWLAxiom axiom=orderedMups.get(0);
    orderedMups.remove(0);
    if (allMups.size() == maxExplanations) {
      if (log.isLoggable(Level.FINE))       log.fine(""String_Node_Str"" + maxExplanations + ""String_Node_Str"");
      return;
    }
    if (log.isLoggable(Level.FINE))     log.fine(""String_Node_Str"" + axiom + ""String_Node_Str""+ currentPathContents.size()+ ""String_Node_Str""+ currentPathContents);
    Set<OWLOntology> ontologies=OntologyUtils.removeAxiom(axiom,getReasoner().getLoadedOntologies(),getOntologyManager());
    Set<OWLEntity> sig=getSignature(axiom);
    List<OWLDeclarationAxiom> temporaryDeclarations=new ArrayList<OWLDeclarationAxiom>(sig.size());
    for (    OWLEntity e : sig) {
      boolean referenced=false;
      for (Iterator<OWLOntology> i=ontologies.iterator(); !referenced && i.hasNext(); ) {
        for (Iterator<OWLAxiom> j=i.next().getReferencingAxioms(e).iterator(); !referenced && j.hasNext(); ) {
          OWLAxiom a=j.next();
          referenced=a.isLogicalAxiom() || (a instanceof OWLDeclarationAxiom);
        }
      }
      if (!referenced) {
        OWLDeclarationAxiom declaration=getOntologyManager().getOWLDataFactory().getOWLDeclarationAxiom(e);
        temporaryDeclarations.add(declaration);
      }
    }
    for (    OWLDeclarationAxiom decl : temporaryDeclarations) {
      OntologyUtils.addAxiom(decl,getReasoner().getLoadedOntologies(),getOntologyManager());
    }
    currentPathContents.add(axiom);
    boolean earlyTermination=false;
    for (    Set<OWLAxiom> satPath : satPaths) {
      if (currentPathContents.containsAll(satPath)) {
        earlyTermination=true;
        if (log.isLoggable(Level.FINE))         log.fine(""String_Node_Str"");
        break;
      }
    }
    if (!earlyTermination) {
      Set<OWLAxiom> newMUPS=null;
      for (      Set<OWLAxiom> foundMUPS : allMups) {
        Set<OWLAxiom> foundMUPSCopy=new HashSet<OWLAxiom>(foundMUPS);
        foundMUPSCopy.retainAll(currentPathContents);
        if (foundMUPSCopy.isEmpty()) {
          newMUPS=foundMUPS;
          break;
        }
      }
      if (newMUPS == null) {
        newMUPS=getExplanation(unsatClass);
      }
      if (newMUPS.contains(axiom)) {
        throw new OWLRuntimeException(""String_Node_Str"" + axiom);
      }
      if (!newMUPS.isEmpty()) {
        allMups.add(newMUPS);
        progressMonitor.foundExplanation(newMUPS);
        constructHittingSetTree(unsatClass,newMUPS,allMups,satPaths,currentPathContents,maxExplanations);
        orderedMups=getOrderedMUPS(orderedMups,allMups);
      }
 else {
        if (log.isLoggable(Level.FINE))         log.fine(""String_Node_Str"");
        satPaths.add(new HashSet<OWLAxiom>(currentPathContents));
      }
    }
    currentPathContents.remove(axiom);
    if (log.isLoggable(Level.FINE))     log.fine(""String_Node_Str"" + axiom);
    for (    OWLDeclarationAxiom decl : temporaryDeclarations) {
      OntologyUtils.removeAxiom(decl,getReasoner().getLoadedOntologies(),getOntologyManager());
    }
    OntologyUtils.addAxiom(axiom,ontologies,getOntologyManager());
  }
}","/** 
 * This is a recursive method that builds a hitting set tree to obtain all justifications for an unsatisfiable class.
 * @param mups                The current justification for the current class. Thiscorresponds to a node in the hitting set tree.
 * @param allMups             All of the MUPS that have been found - this set gets populatedover the course of the tree building process. Initially this should just contain the first justification
 * @param satPaths            Paths that have been completed.
 * @param currentPathContents The contents of the current path. Initially this should be anempty set.
 */
private void constructHittingSetTree(OWLDescription unsatClass,Set<OWLAxiom> mups,Set<Set<OWLAxiom>> allMups,Set<Set<OWLAxiom>> satPaths,Set<OWLAxiom> currentPathContents,int maxExplanations) throws OWLException {
  logger.debug(""String_Node_Str"" + allMups.size() + ""String_Node_Str""+ mups);
  if (progressMonitor.isCancelled()) {
    return;
  }
  List<OWLAxiom> orderedMups=getOrderedMUPS(new ArrayList<OWLAxiom>(mups),allMups);
  while (!orderedMups.isEmpty()) {
    if (progressMonitor.isCancelled()) {
      logger.debug(""String_Node_Str"");
      return;
    }
    OWLAxiom axiom=orderedMups.get(0);
    orderedMups.remove(0);
    if (allMups.size() == maxExplanations) {
      logger.debug(""String_Node_Str"" + maxExplanations + ""String_Node_Str"");
      return;
    }
    logger.debug(""String_Node_Str"" + axiom + ""String_Node_Str""+ currentPathContents.size()+ ""String_Node_Str""+ currentPathContents);
    Set<OWLOntology> ontologies=OntologyUtils.removeAxiom(axiom,getReasoner().getLoadedOntologies(),getOntologyManager());
    Set<OWLEntity> sig=getSignature(axiom);
    List<OWLDeclarationAxiom> temporaryDeclarations=new ArrayList<OWLDeclarationAxiom>(sig.size());
    for (    OWLEntity e : sig) {
      boolean referenced=false;
      for (Iterator<OWLOntology> i=ontologies.iterator(); !referenced && i.hasNext(); ) {
        for (Iterator<OWLAxiom> j=i.next().getReferencingAxioms(e).iterator(); !referenced && j.hasNext(); ) {
          OWLAxiom a=j.next();
          referenced=a.isLogicalAxiom() || (a instanceof OWLDeclarationAxiom);
        }
      }
      if (!referenced) {
        OWLDeclarationAxiom declaration=getOntologyManager().getOWLDataFactory().getOWLDeclarationAxiom(e);
        temporaryDeclarations.add(declaration);
      }
    }
    for (    OWLDeclarationAxiom decl : temporaryDeclarations) {
      OntologyUtils.addAxiom(decl,getReasoner().getLoadedOntologies(),getOntologyManager());
    }
    currentPathContents.add(axiom);
    boolean earlyTermination=false;
    for (    Set<OWLAxiom> satPath : satPaths) {
      if (currentPathContents.containsAll(satPath)) {
        earlyTermination=true;
        logger.debug(""String_Node_Str"");
        break;
      }
    }
    if (!earlyTermination) {
      Set<OWLAxiom> newMUPS=null;
      for (      Set<OWLAxiom> foundMUPS : allMups) {
        Set<OWLAxiom> foundMUPSCopy=new HashSet<OWLAxiom>(foundMUPS);
        foundMUPSCopy.retainAll(currentPathContents);
        if (foundMUPSCopy.isEmpty()) {
          newMUPS=foundMUPS;
          break;
        }
      }
      if (newMUPS == null) {
        newMUPS=getExplanation(unsatClass);
      }
      if (newMUPS.contains(axiom)) {
        throw new OWLRuntimeException(""String_Node_Str"" + axiom);
      }
      if (!newMUPS.isEmpty()) {
        allMups.add(newMUPS);
        progressMonitor.foundExplanation(newMUPS);
        constructHittingSetTree(unsatClass,newMUPS,allMups,satPaths,currentPathContents,maxExplanations);
        orderedMups=getOrderedMUPS(orderedMups,allMups);
      }
 else {
        logger.debug(""String_Node_Str"");
        satPaths.add(new HashSet<OWLAxiom>(currentPathContents));
      }
    }
    currentPathContents.remove(axiom);
    logger.debug(""String_Node_Str"" + axiom);
    for (    OWLDeclarationAxiom decl : temporaryDeclarations) {
      OntologyUtils.removeAxiom(decl,getReasoner().getLoadedOntologies(),getOntologyManager());
    }
    OntologyUtils.addAxiom(axiom,ontologies,getOntologyManager());
  }
}"
9902,"public static void test(){
  String file=""String_Node_Str"";
  try {
    OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
    ManchesterSyntaxExplanationRenderer renderer=new ManchesterSyntaxExplanationRenderer();
    PrintWriter pw=new PrintWriter(System.out);
    renderer.startRendering(pw);
    OWLDataFactory dataFactory=manager.getOWLDataFactory();
    PelletReasonerFactory resonerFact=new PelletReasonerFactory();
    OWLOntology ontology=manager.loadOntologyFromPhysicalURI(URI.create(file));
    Set<OWLOntology> ontologies=new HashSet<OWLOntology>();
    Reasoner reasoner=resonerFact.createReasoner(manager);
    reasoner.loadOntologies(Collections.singleton(ontology));
    System.out.println(reasoner.getInconsistentClasses());
    PelletExplanation exp=new PelletExplanation(manager,Collections.singleton(ontology));
    System.out.println(exp.getUnsatisfiableExplanations(dataFactory.getOWLClass(URI.create(""String_Node_Str""))));
    renderer.endRendering();
  }
 catch (  OWLOntologyCreationException e) {
    e.printStackTrace();
  }
catch (  OWLException e) {
    e.printStackTrace();
  }
}","public static void test(){
  String file=""String_Node_Str"";
  try {
    OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
    ManchesterSyntaxExplanationRenderer renderer=new ManchesterSyntaxExplanationRenderer();
    PrintWriter pw=new PrintWriter(System.out);
    renderer.startRendering(pw);
    OWLDataFactory dataFactory=manager.getOWLDataFactory();
    PelletReasonerFactory resonerFact=new PelletReasonerFactory();
    OWLOntology ontology=manager.loadOntologyFromPhysicalURI(URI.create(file));
    Reasoner reasoner=resonerFact.createReasoner(manager);
    reasoner.loadOntologies(Collections.singleton(ontology));
    System.out.println(reasoner.getInconsistentClasses());
    PelletExplanation exp=new PelletExplanation(manager,Collections.singleton(ontology));
    System.out.println(exp.getUnsatisfiableExplanations(dataFactory.getOWLClass(URI.create(""String_Node_Str""))));
    renderer.endRendering();
  }
 catch (  OWLOntologyCreationException e) {
    e.printStackTrace();
  }
catch (  OWLException e) {
    e.printStackTrace();
  }
}"
9903,"public static void main(String[] args){
  miniTest();
}","public static void main(String[] args){
  test();
  miniTest();
  miniEconomyTest();
  universityTest();
}"
9904,"public List<Set<OWLAxiom>> computeClassificationImpact(List<OWLOntologyChange> changes){
  List<Set<OWLAxiom>> impact=new ArrayList<Set<OWLAxiom>>(2);
  Set<OWLAxiom> entailmentsBefore=new HashSet<OWLAxiom>();
  Set<OWLAxiom> entailmentsAfter=new HashSet<OWLAxiom>();
  Set<OWLAxiom> lostEntailments=new HashSet<OWLAxiom>();
  Set<OWLAxiom> addedEntailents=new HashSet<OWLAxiom>();
  try {
    Set<OWLClass> inc=classifier.getInconsistentClasses();
    for (    OWLDescription cl : ontology.getClassesInSignature()) {
      if (!inc.contains(cl) && !cl.isOWLThing()) {
        for (        OWLClass sub : SetUtils.union(classifier.getDescendantClasses(cl))) {
          if (!sub.isOWLNothing() && !inc.contains(sub)) {
            entailmentsBefore.add(factory.getOWLSubClassAxiom(sub,cl));
          }
        }
        for (        OWLClass equ : classifier.getEquivalentClasses(cl)) {
          if (!equ.isOWLNothing() && !inc.contains(equ)) {
            entailmentsBefore.add(factory.getOWLEquivalentClassesAxiom(equ,cl));
          }
        }
      }
    }
    manager.applyChanges(changes);
    classifier.classify();
    inc=classifier.getInconsistentClasses();
    for (    OWLDescription cl : ontology.getClassesInSignature()) {
      if (!inc.contains(cl) && !cl.isOWLThing()) {
        for (        OWLClass sub : SetUtils.union(classifier.getDescendantClasses(cl))) {
          if (!sub.isOWLNothing() && !inc.contains(sub)) {
            entailmentsAfter.add(factory.getOWLSubClassAxiom(sub,cl));
          }
        }
      }
      for (      OWLClass equ : classifier.getEquivalentClasses(cl)) {
        if (!equ.isOWLNothing() && !inc.contains(equ)) {
          entailmentsAfter.add(factory.getOWLEquivalentClassesAxiom(equ,cl));
        }
      }
    }
    lostEntailments=SetUtils.difference(entailmentsBefore,entailmentsAfter);
    addedEntailents=SetUtils.difference(entailmentsAfter,entailmentsBefore);
    impact.add(0,lostEntailments);
    impact.add(1,addedEntailents);
    manager.applyChanges(getInverseChanges(changes));
  }
 catch (  OWLReasonerException e) {
    e.printStackTrace();
  }
catch (  OWLOntologyChangeException e) {
    e.printStackTrace();
  }
  return impact;
}","public List<Set<OWLAxiom>> computeClassificationImpact(List<OWLOntologyChange> changes){
  List<Set<OWLAxiom>> impact=new ArrayList<Set<OWLAxiom>>(2);
  Set<OWLAxiom> entailmentsBefore=new HashSet<OWLAxiom>();
  Set<OWLAxiom> entailmentsAfter=new HashSet<OWLAxiom>();
  Set<OWLAxiom> lostEntailments=new HashSet<OWLAxiom>();
  Set<OWLAxiom> addedEntailents=new HashSet<OWLAxiom>();
  try {
    Set<OWLClass> inc=classifier.getInconsistentClasses();
    for (    OWLDescription cl : ontology.getClassesInSignature()) {
      if (!inc.contains(cl) && !cl.isOWLThing()) {
        for (        OWLClass sub : SetUtils.union(classifier.getDescendantClasses(cl))) {
          if (!sub.isOWLNothing() && !inc.contains(sub)) {
            entailmentsBefore.add(factory.getOWLSubClassAxiom(sub,cl));
          }
        }
        for (        OWLClass equ : classifier.getEquivalentClasses(cl)) {
          if (!equ.isOWLNothing() && !inc.contains(equ)) {
            entailmentsBefore.add(factory.getOWLEquivalentClassesAxiom(equ,cl));
          }
        }
      }
    }
    manager.applyChanges(changes);
    classifier.classify();
    inc=classifier.getInconsistentClasses();
    for (    OWLDescription cl : ontology.getClassesInSignature()) {
      if (!inc.contains(cl) && !cl.isOWLThing()) {
        for (        OWLClass sub : SetUtils.union(classifier.getDescendantClasses(cl))) {
          if (!sub.isOWLNothing() && !inc.contains(sub)) {
            entailmentsAfter.add(factory.getOWLSubClassAxiom(sub,cl));
          }
        }
      }
      for (      OWLClass equ : classifier.getEquivalentClasses(cl)) {
        if (!equ.isOWLNothing() && !inc.contains(equ)) {
          entailmentsAfter.add(factory.getOWLEquivalentClassesAxiom(equ,cl));
        }
      }
    }
    lostEntailments=SetUtils.difference(entailmentsBefore,entailmentsAfter);
    addedEntailents=SetUtils.difference(entailmentsAfter,entailmentsBefore);
    for (    OWLOntologyChange change : changes) {
      if (change instanceof RemoveAxiom) {
        lostEntailments.remove(change.getAxiom());
      }
    }
    impact.add(0,lostEntailments);
    impact.add(1,addedEntailents);
    manager.applyChanges(getInverseChanges(changes));
  }
 catch (  OWLReasonerException e) {
    e.printStackTrace();
  }
catch (  OWLOntologyChangeException e) {
    e.printStackTrace();
  }
  return impact;
}"
9905,"/** 
 * Computes the precise explanations
 * @param entailment
 * @param limit
 * @return
 * @throws OWLException
 */
private Set<Explanation> computePreciseJusts(OWLAxiom entailment,int limit) throws OWLException {
  Set<Explanation> regularExplanations=pelletExplanation.getExplanations((OWLAxiom)entailment);
  logger.debug(""String_Node_Str"" + regularExplanations.size() + ""String_Node_Str"");
  lastRegularExplanations.clear();
  lastRegularExplanations.addAll(regularExplanations);
  allPreviouslyFoundExplanations=new HashSet<Explanation>();
  allPreviouslyFoundExplanations.addAll(regularExplanations);
  Set<Explanation> nonLaconicExplanations=new HashSet<Explanation>();
  Set<Explanation> laconicExplanations=new HashSet<Explanation>();
  Set<OWLAxiom> axiomsInPreviousOntology=new HashSet<OWLAxiom>();
  for (; ; ) {
    if (progressMonitor.isCancelled()) {
      return laconicExplanations;
    }
    Set<OWLAxiom> unionOfAllExplanations=new HashSet<OWLAxiom>();
    for (    Explanation expl : allPreviouslyFoundExplanations) {
      unionOfAllExplanations.addAll(expl.getAxioms());
    }
    Set<OWLAxiom> oPlus=computeOPlus(unionOfAllExplanations);
    OWLOntologyManager man2=OWLManager.createOWLOntologyManager();
    OWLOntology extendedOntology=man2.createOntology(oPlus);
    for (    OWLLogicalAxiom logAx : ontology.getLogicalAxioms()) {
      if (!unionOfAllExplanations.contains(logAx) || oPlus.contains(logAx)) {
        man2.addAxiom(extendedOntology,logAx);
      }
    }
    if (extendedOntology.getLogicalAxioms().equals(axiomsInPreviousOntology)) {
      logger.debug(""String_Node_Str"");
      break;
    }
    axiomsInPreviousOntology.clear();
    axiomsInPreviousOntology.addAll(extendedOntology.getLogicalAxioms());
    Set<Explanation> allPrevJustsCopy=new HashSet<Explanation>(allPreviouslyFoundExplanations);
    Set<OWLOntology> ont2=new HashSet<OWLOntology>();
    ont2.add(extendedOntology);
    PelletExplanationGenerator expGen=new PelletExplanationGenerator(man2,ont2);
    Set<Explanation> currentExplanations=expGen.getExplanations((OWLAxiom)entailment);
    allPreviouslyFoundExplanations.addAll(currentExplanations);
    if (allPreviouslyFoundExplanations.equals(allPrevJustsCopy)) {
      break;
    }
    for (    Explanation currentExplanation : currentExplanations) {
      if (!laconicExplanations.contains(currentExplanation) && !nonLaconicExplanations.contains(currentExplanation)) {
        if (isLaconic(currentExplanation)) {
          laconicExplanations.add(currentExplanation);
        }
 else {
          nonLaconicExplanations.add(currentExplanation);
        }
        if (laconicExplanations.size() == limit) {
          return laconicExplanations;
        }
      }
    }
  }
  Set<Explanation> explanations=new HashSet<Explanation>();
  for (  Explanation explanation : allPreviouslyFoundExplanations) {
    if (!nonLaconicExplanations.contains(explanation)) {
      if (laconicExplanations.contains(explanation)) {
        explanations.add(explanation);
      }
 else       if (isLaconic(explanation)) {
        explanations.add(explanation);
      }
    }
  }
  return laconicExplanations;
}","/** 
 * Computes the precise explanations
 * @param entailment
 * @param limit
 * @return
 * @throws OWLException
 */
private Set<Explanation> computePreciseJusts(OWLAxiom entailment,int limit) throws OWLException {
  Set<Explanation> regularExplanations=pelletExplanation.getExplanations((OWLAxiom)entailment);
  logger.debug(""String_Node_Str"" + regularExplanations.size() + ""String_Node_Str"");
  lastRegularExplanations.clear();
  lastRegularExplanations.addAll(regularExplanations);
  allPreviouslyFoundExplanations=new HashSet<Explanation>();
  allPreviouslyFoundExplanations.addAll(regularExplanations);
  Set<Explanation> nonLaconicExplanations=new HashSet<Explanation>();
  Set<Explanation> laconicExplanations=new HashSet<Explanation>();
  Set<OWLAxiom> axiomsInPreviousOntology=new HashSet<OWLAxiom>();
  for (; ; ) {
    if (progressMonitor.isCancelled()) {
      return laconicExplanations;
    }
    Set<OWLAxiom> unionOfAllExplanations=new HashSet<OWLAxiom>();
    for (    Explanation expl : allPreviouslyFoundExplanations) {
      unionOfAllExplanations.addAll(expl.getAxioms());
    }
    Set<OWLAxiom> oPlus=computeOPlus(unionOfAllExplanations);
    OWLOntologyManager man2=OWLManager.createOWLOntologyManager();
    OWLOntology extendedOntology=man2.createOntology(oPlus);
    for (    OWLLogicalAxiom logAx : ontology.getLogicalAxioms()) {
      if (!unionOfAllExplanations.contains(logAx) || oPlus.contains(logAx)) {
        man2.addAxiom(extendedOntology,logAx);
      }
    }
    if (extendedOntology.getLogicalAxioms().equals(axiomsInPreviousOntology)) {
      logger.debug(""String_Node_Str"");
      break;
    }
    axiomsInPreviousOntology.clear();
    axiomsInPreviousOntology.addAll(extendedOntology.getLogicalAxioms());
    Set<Explanation> allPrevJustsCopy=new HashSet<Explanation>(allPreviouslyFoundExplanations);
    Set<OWLOntology> ont2=new HashSet<OWLOntology>();
    ont2.add(extendedOntology);
    PelletExplanationGenerator expGen=new PelletExplanationGenerator(man2,ont2);
    Set<Explanation> currentExplanations=expGen.getExplanations((OWLAxiom)entailment);
    allPreviouslyFoundExplanations.addAll(currentExplanations);
    if (allPreviouslyFoundExplanations.equals(allPrevJustsCopy)) {
      break;
    }
    for (    Explanation currentExplanation : currentExplanations) {
      if (!laconicExplanations.contains(currentExplanation) && !nonLaconicExplanations.contains(currentExplanation)) {
        if (isLaconic(currentExplanation)) {
          laconicExplanations.add(currentExplanation);
        }
 else {
          nonLaconicExplanations.add(currentExplanation);
        }
        if (laconicExplanations.size() == limit) {
          return laconicExplanations;
        }
      }
    }
  }
  Set<Explanation> explanations=new HashSet<Explanation>();
  for (  Explanation explanation : allPreviouslyFoundExplanations) {
    System.out.println(explanation);
    if (!nonLaconicExplanations.contains(explanation)) {
      if (laconicExplanations.contains(explanation)) {
        explanations.add(explanation);
      }
 else       if (isLaconic(explanation)) {
        explanations.add(explanation);
      }
    }
  }
  return explanations;
}"
9906,"@SuppressWarnings(""String_Node_Str"") public static void main(String[] args) throws ComponentInitException, LearningProblemUnsupportedException, IOException {
  Logger.getRootLogger().setLevel(Level.WARN);
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  ComponentManager cm=ComponentManager.getInstance();
  OWLFile ks=cm.knowledgeSource(OWLFile.class);
  if (args[0].startsWith(""String_Node_Str"")) {
    ks.getConfigurator().setUrl(new URL(args[0]));
  }
 else {
    File owlFile=new File(args[0]);
    ks.getConfigurator().setUrl(owlFile.toURI().toURL());
  }
  ks.init();
  ReasonerComponent reasoner=null;
  if (useFastInstanceChecker) {
    reasoner=cm.reasoner(FastInstanceChecker.class,ks);
  }
 else {
    reasoner=cm.reasoner(OWLAPIReasoner.class,ks);
  }
  reasoner.init();
  System.out.println(""String_Node_Str"" + args[0] + ""String_Node_Str"");
  String baseURI=reasoner.getBaseURI();
  Map<String,String> prefixes=reasoner.getPrefixes();
  String userInputProtocol=""String_Node_Str"";
  int classCandidatesCount=0;
  Stat instanceCountStat=new Stat();
  Stat classExpressionTestsStat=new Stat();
  Stat approxDiffStat=new Stat();
  int candidatesAboveThresholdCount=0;
  int missesCount=0;
  int foundDescriptionCount=0;
  int noSensibleDescriptionCount=0;
  int inconsistencyDetected=0;
  int moreInstancesCount=0;
  int nonPerfectCount=0;
  Stat moreInstancesCountStat=new Stat();
  Stat accStat=new Stat();
  Stat accSelectedStat=new Stat();
  Stat accAboveThresholdStat=new Stat();
  Stat positionStat=new Stat();
  int candidatesAboveThresholdCountSC=0;
  int missesCountSC=0;
  int foundDescriptionCountSC=0;
  int noSensibleDescriptionCountSC=0;
  int inconsistencyDetectedSC=0;
  int moreInstancesCountSC=0;
  int nonPerfectCountSC=0;
  Stat moreInstancesCountStatSC=new Stat();
  Stat accStatSC=new Stat();
  Stat accSelectedStatSC=new Stat();
  Stat accAboveThresholdStatSC=new Stat();
  Stat positionStatSC=new Stat();
  Set<NamedClass> classes=new TreeSet<NamedClass>(reasoner.getNamedClasses());
  classes.remove(new NamedClass(""String_Node_Str""));
  for (  NamedClass nc : classes) {
    int instanceCount=reasoner.getIndividuals(nc).size();
    if (instanceCount < minInstanceCount) {
      System.out.println(""String_Node_Str"" + nc.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ instanceCount+ ""String_Node_Str""+ minInstanceCount+ ""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"" + nc.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ instanceCount+ ""String_Node_Str"");
      classCandidatesCount++;
      instanceCountStat.addNumber(instanceCount);
      TreeSet<EvaluatedDescriptionClass> suggestions;
      for (int i=0; i <= 1; i++) {
        ClassLearningProblem lp=cm.learningProblem(ClassLearningProblem.class,reasoner);
        lp.getConfigurator().setClassToDescribe(nc.getURI().toURL());
        if (i == 0) {
          System.out.println(""String_Node_Str"" + algorithmRuntimeInSeconds + ""String_Node_Str"");
          lp.getConfigurator().setType(""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"" + algorithmRuntimeInSeconds + ""String_Node_Str"");
          lp.getConfigurator().setType(""String_Node_Str"");
        }
        lp.getConfigurator().setUseApproximations(useApproximations);
        lp.init();
        CELOE celoe=cm.learningAlgorithm(CELOE.class,lp,reasoner);
        CELOEConfigurator cf=celoe.getConfigurator();
        cf.setUseNegation(false);
        cf.setValueFrequencyThreshold(3);
        cf.setMaxExecutionTimeInSeconds(algorithmRuntimeInSeconds);
        cf.setNoisePercentage(noisePercent);
        cf.setMaxNrOfResults(10);
        celoe.init();
        celoe.start();
        classExpressionTestsStat.addNumber(celoe.getClassExpressionTests());
        EvaluatedDescription best=celoe.getCurrentlyBestEvaluatedDescription();
        double bestAcc=best.getAccuracy();
        if (i == 0) {
          accStat.addNumber(bestAcc);
        }
 else {
          accStatSC.addNumber(bestAcc);
        }
        if (bestAcc < minAccuracy || (best.getDescription() instanceof Thing)) {
          System.out.println(""String_Node_Str"" + (100 * minAccuracy) + ""String_Node_Str""+ best.getDescription().toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str""+ df.format(bestAcc)+ ""String_Node_Str"");
        }
 else {
          if (i == 0) {
            accAboveThresholdStat.addNumber(bestAcc);
            candidatesAboveThresholdCount++;
          }
 else {
            accAboveThresholdStatSC.addNumber(bestAcc);
            candidatesAboveThresholdCountSC++;
          }
          suggestions=(TreeSet<EvaluatedDescriptionClass>)celoe.getCurrentlyBestEvaluatedDescriptions();
          List<EvaluatedDescriptionClass> suggestionsList=new LinkedList<EvaluatedDescriptionClass>(suggestions.descendingSet());
          if (computeApproxDiff) {
            for (            EvaluatedDescription ed : suggestionsList) {
              Description d=ed.getDescription();
              double approx=lp.getAccuracyOrTooWeakApprox(d,noisePercent / (double)100);
              double exact=lp.getAccuracyOrTooWeakExact(d,noisePercent / (double)100);
              double diff=Math.abs(approx - exact);
              approxDiffStat.addNumber(diff);
            }
          }
          int nr=0;
          for (          EvaluatedDescription suggestion : suggestionsList) {
            System.out.println(nr + ""String_Node_Str"" + suggestion.getDescription().toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str""+ df.format(suggestion.getAccuracy())+ ""String_Node_Str"");
            nr++;
          }
          System.out.println(""String_Node_Str"" + (suggestions.size() - 1) + ""String_Node_Str"");
          String[] inputs=new String[suggestions.size() + 2];
          inputs[0]=""String_Node_Str"";
          inputs[1]=""String_Node_Str"";
          for (int j=0; j < suggestions.size(); j++) {
            inputs[j + 2]=""String_Node_Str"" + j;
          }
          List<String> allowedInputs=Arrays.asList(inputs);
          String input;
          if (autoMode) {
            input=""String_Node_Str"";
          }
 else {
            do {
              BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
              input=br.readLine();
            }
 while (!allowedInputs.contains(input));
          }
          userInputProtocol+=input;
          if (input.equals(""String_Node_Str"")) {
            if (i == 0) {
              missesCount++;
            }
 else {
              missesCountSC++;
            }
            System.out.println(""String_Node_Str"");
          }
 else           if (input.equals(""String_Node_Str"")) {
            if (i == 0) {
              noSensibleDescriptionCount++;
            }
 else {
              noSensibleDescriptionCountSC++;
            }
            System.out.println(""String_Node_Str"");
          }
 else {
            int selectedNr=Integer.parseInt(input);
            EvaluatedDescriptionClass selectedExpression=suggestionsList.get(selectedNr);
            System.out.println(""String_Node_Str"" + selectedExpression.getDescription().toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
            boolean isConsistent=selectedExpression.isConsistent();
            if (!isConsistent) {
              System.out.println(""String_Node_Str"");
            }
            Set<Individual> addInst=selectedExpression.getAdditionalInstances();
            int additionalInstances=addInst.size();
            if (additionalInstances > 0) {
              System.out.println(""String_Node_Str"" + additionalInstances + ""String_Node_Str""+ addInst.iterator().next().toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
            }
            if (i == 0) {
              accSelectedStat.addNumber(bestAcc);
              positionStat.addNumber(selectedNr);
              foundDescriptionCount++;
              if (!isConsistent) {
                inconsistencyDetected++;
              }
              if (additionalInstances > 0) {
                moreInstancesCount++;
                moreInstancesCountStat.addNumber(additionalInstances);
              }
              if (bestAcc < 0.9999) {
                nonPerfectCount++;
              }
            }
 else {
              accSelectedStatSC.addNumber(bestAcc);
              positionStatSC.addNumber(selectedNr);
              foundDescriptionCountSC++;
              if (!isConsistent) {
                inconsistencyDetectedSC++;
              }
              if (additionalInstances > 0) {
                moreInstancesCountSC++;
                moreInstancesCountStatSC.addNumber(additionalInstances);
              }
              if (bestAcc < 0.9999) {
                nonPerfectCountSC++;
              }
            }
          }
        }
        cm.freeComponent(celoe);
        cm.freeComponent(lp);
      }
    }
  }
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"" + args[0]);
  System.out.println(""String_Node_Str"" + minAccuracy + ""String_Node_Str""+ minInstanceCount+ ""String_Node_Str""+ algorithmRuntimeInSeconds+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + userInputProtocol);
  System.out.println(""String_Node_Str"" + classes.size());
  System.out.println(""String_Node_Str"" + minInstanceCount + ""String_Node_Str""+ classCandidatesCount);
  System.out.println(""String_Node_Str"" + classExpressionTestsStat.prettyPrint(""String_Node_Str""));
  if (computeApproxDiff) {
    System.out.println(""String_Node_Str"" + approxDiffStat.prettyPrint());
  }
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (minAccuracy * 100) + ""String_Node_Str""+ candidatesAboveThresholdCount);
  System.out.println(""String_Node_Str"" + foundDescriptionCount);
  System.out.println(""String_Node_Str"" + missesCount);
  System.out.println(""String_Node_Str"" + noSensibleDescriptionCount);
  System.out.println(""String_Node_Str"" + inconsistencyDetected);
  System.out.println(""String_Node_Str"" + moreInstancesCountStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accSelectedStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accAboveThresholdStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + nonPerfectCount);
  System.out.println(""String_Node_Str"" + positionStat.prettyPrint(""String_Node_Str""));
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (minAccuracy * 100) + ""String_Node_Str""+ candidatesAboveThresholdCountSC);
  System.out.println(""String_Node_Str"" + foundDescriptionCountSC);
  System.out.println(""String_Node_Str"" + missesCountSC);
  System.out.println(""String_Node_Str"" + noSensibleDescriptionCountSC);
  System.out.println(""String_Node_Str"" + inconsistencyDetectedSC);
  System.out.println(""String_Node_Str"" + moreInstancesCountStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accSelectedStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accAboveThresholdStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + nonPerfectCountSC);
  System.out.println(""String_Node_Str"" + positionStatSC.prettyPrint(""String_Node_Str""));
}","@SuppressWarnings(""String_Node_Str"") public static void main(String[] args) throws ComponentInitException, LearningProblemUnsupportedException, IOException {
  Logger.getRootLogger().setLevel(Level.WARN);
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  ComponentManager cm=ComponentManager.getInstance();
  OWLFile ks=cm.knowledgeSource(OWLFile.class);
  if (args[0].startsWith(""String_Node_Str"")) {
    ks.getConfigurator().setUrl(new URL(args[0]));
  }
 else {
    File owlFile=new File(args[0]);
    ks.getConfigurator().setUrl(owlFile.toURI().toURL());
  }
  ks.init();
  ReasonerComponent reasoner=null;
  if (useFastInstanceChecker) {
    reasoner=cm.reasoner(FastInstanceChecker.class,ks);
  }
 else {
    reasoner=cm.reasoner(OWLAPIReasoner.class,ks);
  }
  reasoner.init();
  System.out.println(""String_Node_Str"" + args[0] + ""String_Node_Str"");
  String baseURI=reasoner.getBaseURI();
  Map<String,String> prefixes=reasoner.getPrefixes();
  String userInputProtocol=""String_Node_Str"";
  int classCandidatesCount=0;
  Stat instanceCountStat=new Stat();
  Stat classExpressionTestsStat=new Stat();
  Stat approxDiffStat=new Stat();
  int candidatesAboveThresholdCount=0;
  int missesCount=0;
  int foundDescriptionCount=0;
  int noSensibleDescriptionCount=0;
  int inconsistencyDetected=0;
  int moreInstancesCount=0;
  int nonPerfectCount=0;
  Stat moreInstancesCountStat=new Stat();
  Stat accStat=new Stat();
  Stat accSelectedStat=new Stat();
  Stat accAboveThresholdStat=new Stat();
  Stat positionStat=new Stat();
  int candidatesAboveThresholdCountSC=0;
  int missesCountSC=0;
  int foundDescriptionCountSC=0;
  int noSensibleDescriptionCountSC=0;
  int inconsistencyDetectedSC=0;
  int moreInstancesCountSC=0;
  int nonPerfectCountSC=0;
  Stat moreInstancesCountStatSC=new Stat();
  Stat accStatSC=new Stat();
  Stat accSelectedStatSC=new Stat();
  Stat accAboveThresholdStatSC=new Stat();
  Stat positionStatSC=new Stat();
  Set<NamedClass> classes=new TreeSet<NamedClass>(reasoner.getNamedClasses());
  classes.remove(new NamedClass(""String_Node_Str""));
  for (  NamedClass nc : classes) {
    int instanceCount=reasoner.getIndividuals(nc).size();
    if (instanceCount < minInstanceCount) {
      System.out.println(""String_Node_Str"" + nc.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ instanceCount+ ""String_Node_Str""+ minInstanceCount+ ""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"" + nc.toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str""+ instanceCount+ ""String_Node_Str"");
      classCandidatesCount++;
      instanceCountStat.addNumber(instanceCount);
      TreeSet<EvaluatedDescriptionClass> suggestions;
      for (int i=0; i <= 1; i++) {
        ClassLearningProblem lp=cm.learningProblem(ClassLearningProblem.class,reasoner);
        lp.getConfigurator().setClassToDescribe(nc.getURI().toURL());
        if (i == 0) {
          System.out.println(""String_Node_Str"" + algorithmRuntimeInSeconds + ""String_Node_Str"");
          lp.getConfigurator().setType(""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"" + algorithmRuntimeInSeconds + ""String_Node_Str"");
          lp.getConfigurator().setType(""String_Node_Str"");
        }
        lp.getConfigurator().setUseApproximations(useApproximations);
        lp.init();
        CELOE celoe=cm.learningAlgorithm(CELOE.class,lp,reasoner);
        CELOEConfigurator cf=celoe.getConfigurator();
        cf.setUseNegation(false);
        cf.setValueFrequencyThreshold(3);
        cf.setMaxExecutionTimeInSeconds(algorithmRuntimeInSeconds);
        cf.setNoisePercentage(noisePercent);
        cf.setMaxNrOfResults(10);
        celoe.init();
        celoe.start();
        classExpressionTestsStat.addNumber(celoe.getClassExpressionTests());
        EvaluatedDescription best=celoe.getCurrentlyBestEvaluatedDescription();
        double bestAcc=best.getAccuracy();
        if (i == 0) {
          accStat.addNumber(bestAcc);
        }
 else {
          accStatSC.addNumber(bestAcc);
        }
        if (bestAcc < minAccuracy || (best.getDescription() instanceof Thing)) {
          System.out.println(""String_Node_Str"" + (100 * minAccuracy) + ""String_Node_Str""+ best.getDescription().toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str""+ df.format(bestAcc)+ ""String_Node_Str"");
        }
 else {
          if (i == 0) {
            accAboveThresholdStat.addNumber(bestAcc);
            candidatesAboveThresholdCount++;
          }
 else {
            accAboveThresholdStatSC.addNumber(bestAcc);
            candidatesAboveThresholdCountSC++;
          }
          suggestions=(TreeSet<EvaluatedDescriptionClass>)celoe.getCurrentlyBestEvaluatedDescriptions();
          List<EvaluatedDescriptionClass> suggestionsList=new LinkedList<EvaluatedDescriptionClass>(suggestions.descendingSet());
          if (computeApproxDiff) {
            for (            EvaluatedDescription ed : suggestionsList) {
              Description d=ed.getDescription();
              double approx=lp.getAccuracyOrTooWeakApprox(d,noisePercent / (double)100);
              double exact=lp.getAccuracyOrTooWeakExact(d,noisePercent / (double)100);
              double diff=Math.abs(approx - exact);
              if (approx > -0.01 && exact > -0.01) {
                approxDiffStat.addNumber(diff);
              }
            }
          }
          int nr=0;
          for (          EvaluatedDescription suggestion : suggestionsList) {
            System.out.println(nr + ""String_Node_Str"" + suggestion.getDescription().toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str""+ df.format(suggestion.getAccuracy())+ ""String_Node_Str"");
            nr++;
          }
          System.out.println(""String_Node_Str"" + (suggestions.size() - 1) + ""String_Node_Str"");
          String[] inputs=new String[suggestions.size() + 2];
          inputs[0]=""String_Node_Str"";
          inputs[1]=""String_Node_Str"";
          for (int j=0; j < suggestions.size(); j++) {
            inputs[j + 2]=""String_Node_Str"" + j;
          }
          List<String> allowedInputs=Arrays.asList(inputs);
          String input;
          if (autoMode) {
            input=""String_Node_Str"";
          }
 else {
            do {
              BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
              input=br.readLine();
            }
 while (!allowedInputs.contains(input));
          }
          userInputProtocol+=input;
          if (input.equals(""String_Node_Str"")) {
            if (i == 0) {
              missesCount++;
            }
 else {
              missesCountSC++;
            }
            System.out.println(""String_Node_Str"");
          }
 else           if (input.equals(""String_Node_Str"")) {
            if (i == 0) {
              noSensibleDescriptionCount++;
            }
 else {
              noSensibleDescriptionCountSC++;
            }
            System.out.println(""String_Node_Str"");
          }
 else {
            int selectedNr=Integer.parseInt(input);
            EvaluatedDescriptionClass selectedExpression=suggestionsList.get(selectedNr);
            System.out.println(""String_Node_Str"" + selectedExpression.getDescription().toManchesterSyntaxString(baseURI,prefixes) + ""String_Node_Str"");
            boolean isConsistent=selectedExpression.isConsistent();
            if (!isConsistent) {
              System.out.println(""String_Node_Str"");
            }
            Set<Individual> addInst=selectedExpression.getAdditionalInstances();
            int additionalInstances=addInst.size();
            if (additionalInstances > 0) {
              System.out.println(""String_Node_Str"" + additionalInstances + ""String_Node_Str""+ addInst.iterator().next().toManchesterSyntaxString(baseURI,prefixes)+ ""String_Node_Str"");
            }
            if (i == 0) {
              accSelectedStat.addNumber(bestAcc);
              positionStat.addNumber(selectedNr);
              foundDescriptionCount++;
              if (!isConsistent) {
                inconsistencyDetected++;
              }
              if (additionalInstances > 0) {
                moreInstancesCount++;
                moreInstancesCountStat.addNumber(additionalInstances);
              }
              if (bestAcc < 0.9999) {
                nonPerfectCount++;
              }
            }
 else {
              accSelectedStatSC.addNumber(bestAcc);
              positionStatSC.addNumber(selectedNr);
              foundDescriptionCountSC++;
              if (!isConsistent) {
                inconsistencyDetectedSC++;
              }
              if (additionalInstances > 0) {
                moreInstancesCountSC++;
                moreInstancesCountStatSC.addNumber(additionalInstances);
              }
              if (bestAcc < 0.9999) {
                nonPerfectCountSC++;
              }
            }
          }
        }
        cm.freeComponent(celoe);
        cm.freeComponent(lp);
      }
    }
  }
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"" + args[0]);
  System.out.println(""String_Node_Str"" + minAccuracy + ""String_Node_Str""+ minInstanceCount+ ""String_Node_Str""+ algorithmRuntimeInSeconds+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + userInputProtocol);
  System.out.println(""String_Node_Str"" + classes.size());
  System.out.println(""String_Node_Str"" + minInstanceCount + ""String_Node_Str""+ classCandidatesCount);
  System.out.println(""String_Node_Str"" + classExpressionTestsStat.prettyPrint(""String_Node_Str""));
  if (computeApproxDiff) {
    System.out.println(""String_Node_Str"" + approxDiffStat.prettyPrint());
  }
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (minAccuracy * 100) + ""String_Node_Str""+ candidatesAboveThresholdCount);
  System.out.println(""String_Node_Str"" + foundDescriptionCount);
  System.out.println(""String_Node_Str"" + missesCount);
  System.out.println(""String_Node_Str"" + noSensibleDescriptionCount);
  System.out.println(""String_Node_Str"" + inconsistencyDetected);
  System.out.println(""String_Node_Str"" + moreInstancesCountStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accSelectedStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accAboveThresholdStat.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + nonPerfectCount);
  System.out.println(""String_Node_Str"" + positionStat.prettyPrint(""String_Node_Str""));
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (minAccuracy * 100) + ""String_Node_Str""+ candidatesAboveThresholdCountSC);
  System.out.println(""String_Node_Str"" + foundDescriptionCountSC);
  System.out.println(""String_Node_Str"" + missesCountSC);
  System.out.println(""String_Node_Str"" + noSensibleDescriptionCountSC);
  System.out.println(""String_Node_Str"" + inconsistencyDetectedSC);
  System.out.println(""String_Node_Str"" + moreInstancesCountStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accSelectedStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + accAboveThresholdStatSC.prettyPrint(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + nonPerfectCountSC);
  System.out.println(""String_Node_Str"" + positionStatSC.prettyPrint(""String_Node_Str""));
}"
9907,"/** 
 * The main matching method. The matching is directed from DBpedia to LGD, i.e. given a POI in DBpedia, we try to find a match in LGD.
 * @param dbpediaPoint The DBpedia point.
 * @return The URI of the matched LGD point or null if no match was found.
 * @throws IOException Thrown if a query or linked data access does not work.
 */
public static URI findGeoDataMatch(DBpediaPoint dbpediaPoint) throws IOException {
  double distanceThresholdMeters=dbpediaPoint.getPoiClass().getMaxBox();
  boolean quiet=true;
  if (useSparqlForGettingNearbyPoints) {
    double minLat=dbpediaPoint.getGeoLat() - (distanceThresholdMeters / 1000 / 111);
    double maxLat=dbpediaPoint.getGeoLat() + (distanceThresholdMeters / 1000 / 111);
    double minLong=dbpediaPoint.getGeoLong() - (distanceThresholdMeters / 1000) / Math.abs(Math.cos(Math.toRadians(dbpediaPoint.getGeoLat())) * 111);
    double maxLong=dbpediaPoint.getGeoLong() + (distanceThresholdMeters / 1000) / Math.abs(Math.cos(Math.toRadians(dbpediaPoint.getGeoLat())) * 111);
    String queryStr=""String_Node_Str"";
    queryStr+=LGDPoint.getSPARQLRestriction(dbpediaPoint.getPoiClass(),""String_Node_Str"");
    queryStr+=""String_Node_Str"";
    queryStr+=""String_Node_Str"" + usedDatatype + ""String_Node_Str""+ minLat+ ""String_Node_Str"";
    queryStr+=""String_Node_Str"" + usedDatatype + ""String_Node_Str""+ maxLat+ ""String_Node_Str"";
    queryStr+=""String_Node_Str"";
    queryStr+=""String_Node_Str"" + usedDatatype + ""String_Node_Str""+ minLong+ ""String_Node_Str"";
    queryStr+=""String_Node_Str"" + usedDatatype + ""String_Node_Str""+ maxLong+ ""String_Node_Str"";
    queryStr+=""String_Node_Str"";
    queryStr+=""String_Node_Str"";
    queryStr+=""String_Node_Str"";
    queryStr+=""String_Node_Str"";
    queryStr+=""String_Node_Str"";
    ResultSet rs=lgd.queryAsResultSet(queryStr);
    double highestScore=0;
    String bestURI=null;
    String bestLabel=null;
    while (rs.hasNext()) {
      QuerySolution qs=rs.nextSolution();
      String lgdURI=qs.getResource(""String_Node_Str"").toString();
      double stringSimilarity;
      String dbpediaLabel1=dbpediaPoint.getLabel();
      String dbpediaLabel2=dbpediaPoint.getPlainLabel();
      String lgdLabel1=qs.getLiteral(""String_Node_Str"").toString();
      stringSimilarity=distance.score(dbpediaLabel1,lgdLabel1);
      stringSimilarity=Math.max(distance.score(dbpediaLabel2,lgdLabel1),stringSimilarity);
      if (qs.contains(""String_Node_Str"")) {
        String lgdLabel2=qs.getLiteral(""String_Node_Str"").toString();
        stringSimilarity=distance.score(dbpediaLabel1,lgdLabel2);
        stringSimilarity=Math.max(distance.score(dbpediaLabel2,lgdLabel2),stringSimilarity);
        System.out.println(qs.getResource(""String_Node_Str"").getURI());
        System.exit(0);
      }
      if (qs.contains(""String_Node_Str"")) {
        String lgdLabel3=qs.getLiteral(""String_Node_Str"").toString();
        stringSimilarity=distance.score(dbpediaLabel1,lgdLabel3);
        stringSimilarity=Math.max(distance.score(dbpediaLabel2,lgdLabel3),stringSimilarity);
      }
      double lat=qs.getLiteral(""String_Node_Str"").getDouble();
      double lon=qs.getLiteral(""String_Node_Str"").getDouble();
      double distance=spatialDistance(dbpediaPoint.getGeoLat(),dbpediaPoint.getGeoLong(),lat,lon);
      double frac=Math.min(1,distance / dbpediaPoint.getPoiClass().getMaxBox());
      double distanceScore=Math.pow(frac - 1,2);
      double score=0.8 * stringSimilarity + 0.2 * distanceScore;
      if (score > highestScore) {
        highestScore=score;
        bestURI=lgdURI;
        bestLabel=lgdLabel1;
      }
    }
    if (highestScore > scoreThreshold) {
      logger.info(""String_Node_Str"" + highestScore + ""String_Node_Str""+ bestLabel+ ""String_Node_Str""+ dbpediaPoint.getUri()+ ""String_Node_Str""+ bestURI+ ""String_Node_Str"");
      return URI.create(bestURI);
    }
 else {
      logger.info(""String_Node_Str"" + highestScore + ""String_Node_Str""+ bestLabel+ ""String_Node_Str""+ dbpediaPoint.getUri()+ ""String_Node_Str""+ bestURI+ ""String_Node_Str"");
      return null;
    }
  }
 else {
    if (!quiet)     System.out.println(dbpediaPoint.getLabel());
    URL linkedGeoDataURL=new URL(""String_Node_Str"" + dbpediaPoint.getGeoLat() + ""String_Node_Str""+ dbpediaPoint.getGeoLong()+ ""String_Node_Str""+ distanceThresholdMeters);
    double highestScore=0;
    String bestURI=null;
    String bestLabel=null;
    URLConnection conn=linkedGeoDataURL.openConnection();
    BufferedReader rd=new BufferedReader(new InputStreamReader(conn.getInputStream()));
    String line=""String_Node_Str"";
    while ((line=rd.readLine()) != null) {
      if (line.contains(""String_Node_Str"") || line.contains(""String_Node_Str"") || line.contains(""String_Node_Str"")) {
        int first=line.indexOf(""String_Node_Str"") + 1;
        int last=line.lastIndexOf(""String_Node_Str"");
        String label=line.substring(first,last);
        double score=distance.score(label,dbpediaPoint.getLabel());
        if (score > highestScore) {
          highestScore=score;
          bestURI=line.substring(1,line.indexOf(""String_Node_Str"") - 1);
          bestLabel=label;
        }
      }
    }
    rd.close();
    if (!quiet) {
      System.out.println(""String_Node_Str"" + linkedGeoDataURL);
      System.out.println(""String_Node_Str"" + highestScore);
      System.out.println(""String_Node_Str"" + bestURI);
      System.out.println(""String_Node_Str"" + bestLabel);
    }
    if (highestScore > scoreThreshold) {
      return URI.create(bestURI);
    }
 else {
      return null;
    }
  }
}","/** 
 * The main matching method. The matching is directed from DBpedia to LGD, i.e. given a POI in DBpedia, we try to find a match in LGD.
 * @param dbpediaPoint The DBpedia point.
 * @return The URI of the matched LGD point or null if no match was found.
 * @throws IOException Thrown if a query or linked data access does not work.
 */
public static URI findGeoDataMatch(DBpediaPoint dbpediaPoint) throws IOException {
  double distanceThresholdMeters=dbpediaPoint.getPoiClass().getMaxBox();
  boolean quiet=true;
  if (useSparqlForGettingNearbyPoints) {
    double minLat=dbpediaPoint.getGeoLat() - (distanceThresholdMeters / 1000 / 111);
    double maxLat=dbpediaPoint.getGeoLat() + (distanceThresholdMeters / 1000 / 111);
    double minLong=dbpediaPoint.getGeoLong() - (distanceThresholdMeters / 1000) / Math.abs(Math.cos(Math.toRadians(dbpediaPoint.getGeoLat())) * 111);
    double maxLong=dbpediaPoint.getGeoLong() + (distanceThresholdMeters / 1000) / Math.abs(Math.cos(Math.toRadians(dbpediaPoint.getGeoLat())) * 111);
    String queryStr=""String_Node_Str"";
    queryStr+=LGDPoint.getSPARQLRestriction(dbpediaPoint.getPoiClass(),""String_Node_Str"");
    queryStr+=""String_Node_Str"";
    queryStr+=""String_Node_Str"" + usedDatatype + ""String_Node_Str""+ minLat+ ""String_Node_Str"";
    queryStr+=""String_Node_Str"" + usedDatatype + ""String_Node_Str""+ maxLat+ ""String_Node_Str"";
    queryStr+=""String_Node_Str"";
    queryStr+=""String_Node_Str"" + usedDatatype + ""String_Node_Str""+ minLong+ ""String_Node_Str"";
    queryStr+=""String_Node_Str"" + usedDatatype + ""String_Node_Str""+ maxLong+ ""String_Node_Str"";
    queryStr+=""String_Node_Str"";
    queryStr+=""String_Node_Str"";
    queryStr+=""String_Node_Str"";
    queryStr+=""String_Node_Str"";
    ResultSet rs=lgd.queryAsResultSet(queryStr);
    double highestScore=0;
    String bestURI=null;
    String bestLabel=null;
    while (rs.hasNext()) {
      QuerySolution qs=rs.nextSolution();
      String lgdURI=qs.getResource(""String_Node_Str"").toString();
      double stringSimilarity;
      String dbpediaLabel1=dbpediaPoint.getLabel();
      String dbpediaLabel2=dbpediaPoint.getPlainLabel();
      String lgdLabel1=qs.getLiteral(""String_Node_Str"").toString();
      stringSimilarity=distance.score(dbpediaLabel1,lgdLabel1);
      stringSimilarity=Math.max(distance.score(dbpediaLabel2,lgdLabel1),stringSimilarity);
      if (qs.contains(""String_Node_Str"")) {
        String lgdLabel2=qs.getLiteral(""String_Node_Str"").toString();
        stringSimilarity=distance.score(dbpediaLabel1,lgdLabel2);
        stringSimilarity=Math.max(distance.score(dbpediaLabel2,lgdLabel2),stringSimilarity);
        System.out.println(qs.getResource(""String_Node_Str"").getURI());
        System.exit(0);
      }
      if (qs.contains(""String_Node_Str"")) {
        String lgdLabel3=qs.getLiteral(""String_Node_Str"").toString();
        stringSimilarity=distance.score(dbpediaLabel1,lgdLabel3);
        stringSimilarity=Math.max(distance.score(dbpediaLabel2,lgdLabel3),stringSimilarity);
      }
      double lat=qs.getLiteral(""String_Node_Str"").getDouble();
      double lon=qs.getLiteral(""String_Node_Str"").getDouble();
      double distance=spatialDistance(dbpediaPoint.getGeoLat(),dbpediaPoint.getGeoLong(),lat,lon);
      double frac=Math.min(1,distance / dbpediaPoint.getPoiClass().getMaxBox());
      double distanceScore=Math.pow(frac - 1,2);
      double score=0.8 * stringSimilarity + 0.2 * distanceScore;
      if (lgdURI.contains(""String_Node_Str"")) {
        score-=0.02;
      }
      if (score > highestScore) {
        highestScore=score;
        bestURI=lgdURI;
        bestLabel=lgdLabel1;
      }
    }
    if (highestScore > scoreThreshold) {
      logger.info(""String_Node_Str"" + highestScore + ""String_Node_Str""+ bestLabel+ ""String_Node_Str""+ dbpediaPoint.getUri()+ ""String_Node_Str""+ bestURI+ ""String_Node_Str"");
      return URI.create(bestURI);
    }
 else {
      logger.info(""String_Node_Str"" + highestScore + ""String_Node_Str""+ bestLabel+ ""String_Node_Str""+ dbpediaPoint.getUri()+ ""String_Node_Str""+ bestURI+ ""String_Node_Str"");
      return null;
    }
  }
 else {
    if (!quiet)     System.out.println(dbpediaPoint.getLabel());
    URL linkedGeoDataURL=new URL(""String_Node_Str"" + dbpediaPoint.getGeoLat() + ""String_Node_Str""+ dbpediaPoint.getGeoLong()+ ""String_Node_Str""+ distanceThresholdMeters);
    double highestScore=0;
    String bestURI=null;
    String bestLabel=null;
    URLConnection conn=linkedGeoDataURL.openConnection();
    BufferedReader rd=new BufferedReader(new InputStreamReader(conn.getInputStream()));
    String line=""String_Node_Str"";
    while ((line=rd.readLine()) != null) {
      if (line.contains(""String_Node_Str"") || line.contains(""String_Node_Str"") || line.contains(""String_Node_Str"")) {
        int first=line.indexOf(""String_Node_Str"") + 1;
        int last=line.lastIndexOf(""String_Node_Str"");
        String label=line.substring(first,last);
        double score=distance.score(label,dbpediaPoint.getLabel());
        if (score > highestScore) {
          highestScore=score;
          bestURI=line.substring(1,line.indexOf(""String_Node_Str"") - 1);
          bestLabel=label;
        }
      }
    }
    rd.close();
    if (!quiet) {
      System.out.println(""String_Node_Str"" + linkedGeoDataURL);
      System.out.println(""String_Node_Str"" + highestScore);
      System.out.println(""String_Node_Str"" + bestURI);
      System.out.println(""String_Node_Str"" + bestLabel);
    }
    if (highestScore > scoreThreshold) {
      return URI.create(bestURI);
    }
 else {
      return null;
    }
  }
}"
9908,"public static void main(String[] args) throws IOException {
  Logger.getRootLogger().setLevel(Level.WARN);
  if (!dbpediaFile.exists() || regenerateFile) {
    createDBpediaFile();
  }
  for (  POIClass poiClass : POIClass.values()) {
    matchPerClass.put(poiClass,0);
    noMatchPerClass.put(poiClass,0);
  }
  Files.clearFile(matchingFile);
  Files.clearFile(missesFile);
  FileOutputStream fos=new FileOutputStream(matchingFile,true);
  FileOutputStream fosMiss=new FileOutputStream(missesFile,true);
  BufferedReader br=new BufferedReader(new FileReader(dbpediaFile));
  String line;
  int itemCount=0;
  URI uri=null;
  String label=null;
  String[] classes=null;
  int decimalCount=0;
  Double geoLat=null;
  Double geoLong=null;
  startDate=new Date();
  System.out.println(""String_Node_Str"" + startDate);
  while ((line=br.readLine()) != null) {
    if (line.isEmpty()) {
      DBpediaPoint dp=new DBpediaPoint(uri,label,classes,geoLat,geoLong,decimalCount);
      POIClass poiClass=dp.getPoiClass();
      if (poiClass != null) {
        URI matchURI=findGeoDataMatch(dp);
        if (matchURI == null) {
          String missStr=dp.toString() + ""String_Node_Str"";
          fosMiss.write(missStr.getBytes());
          noMatchPerClass.put(poiClass,noMatchPerClass.get(poiClass) + 1);
        }
 else {
          String matchStr=""String_Node_Str"" + dp.getUri() + ""String_Node_Str""+ matchURI+ ""String_Node_Str"";
          fos.write(matchStr.getBytes());
          matches++;
          matchPerClass.put(poiClass,matchPerClass.get(poiClass) + 1);
        }
        counter++;
        if (counter % 1000 == 0) {
          printSummary();
        }
      }
 else {
        skipCount++;
      }
      itemCount=0;
    }
 else {
switch (itemCount) {
case 0:
        uri=URI.create(line);
      break;
case 1:
    label=line;
  break;
case 2:
classes=line.substring(1,line.length()).split(""String_Node_Str"");
break;
case 3:
geoLat=new Double(line);
if (geoLat.toString().contains(""String_Node_Str"")) {
geoLat=0.0;
}
decimalCount=0;
String[] tmp=line.split(""String_Node_Str"");
if (tmp.length == 2) {
decimalCount=tmp[1].length();
}
break;
case 4:
geoLong=new Double(line);
if (geoLong.toString().contains(""String_Node_Str"")) {
geoLong=0.0;
}
}
itemCount++;
}
}
br.close();
fos.close();
printSummary();
System.out.println(""String_Node_Str"");
}","public static void main(String[] args) throws IOException {
  Logger.getRootLogger().setLevel(Level.WARN);
  if (!dbpediaFile.exists() || regenerateFile) {
    createDBpediaFile();
  }
  for (  POIClass poiClass : POIClass.values()) {
    matchPerClass.put(poiClass,0);
    noMatchPerClass.put(poiClass,0);
  }
  Files.clearFile(matchingFile);
  Files.clearFile(missesFile);
  FileOutputStream fos=new FileOutputStream(matchingFile,true);
  FileOutputStream fosMiss=new FileOutputStream(missesFile,true);
  BufferedReader br=new BufferedReader(new FileReader(dbpediaFile));
  String line;
  int itemCount=0;
  URI uri=null;
  String label=null;
  String[] classes=null;
  int decimalCount=0;
  Double geoLat=null;
  Double geoLong=null;
  startDate=new Date();
  System.out.println(""String_Node_Str"" + startDate);
  while ((line=br.readLine()) != null) {
    if (line.isEmpty()) {
      DBpediaPoint dp=new DBpediaPoint(uri,label,classes,geoLat,geoLong,decimalCount);
      POIClass poiClass=dp.getPoiClass();
      if (poiClass != null) {
        URI matchURI=findGeoDataMatch(dp);
        if (matchURI == null) {
          String missStr=dp.toString() + ""String_Node_Str"";
          fosMiss.write(missStr.getBytes());
          noMatchPerClass.put(poiClass,noMatchPerClass.get(poiClass) + 1);
        }
 else {
          String matchStr=""String_Node_Str"" + dp.getUri() + ""String_Node_Str""+ matchURI+ ""String_Node_Str"";
          fos.write(matchStr.getBytes());
          matches++;
          matchPerClass.put(poiClass,matchPerClass.get(poiClass) + 1);
        }
        counter++;
        if (counter % 1000 == 0) {
          printSummary();
        }
      }
 else {
        skipCount++;
      }
      itemCount=0;
    }
 else {
switch (itemCount) {
case 0:
        uri=URI.create(line);
      break;
case 1:
    label=line;
  break;
case 2:
line=line.substring(1,line.length() - 1);
if (line.length() > 1) {
classes=line.split(""String_Node_Str"");
}
 else {
classes=new String[0];
}
break;
case 3:
geoLat=new Double(line);
if (geoLat.toString().contains(""String_Node_Str"")) {
geoLat=0.0;
}
decimalCount=0;
String[] tmp=line.split(""String_Node_Str"");
if (tmp.length == 2) {
decimalCount=tmp[1].length();
}
break;
case 4:
geoLong=new Double(line);
if (geoLong.toString().contains(""String_Node_Str"")) {
geoLong=0.0;
}
}
itemCount++;
}
}
br.close();
fos.close();
printSummary();
System.out.println(""String_Node_Str"");
}"
9909,"@Override public String toString(){
  String str=uri + ""String_Node_Str"" + label+ ""String_Node_Str""+ geoLat+ ""String_Node_Str""+ geoLong+ ""String_Node_Str"";
  for (  String clazz : classes) {
    str+=clazz + ""String_Node_Str"";
  }
  return str + ""String_Node_Str"";
}","@Override public String toString(){
  String str=uri + ""String_Node_Str"" + label+ ""String_Node_Str""+ geoLat+ ""String_Node_Str""+ geoLong+ ""String_Node_Str""+ classes.length+ ""String_Node_Str"";
  for (  String clazz : classes) {
    str+=clazz + ""String_Node_Str"";
  }
  return str + ""String_Node_Str"";
}"
9910,"/** 
 * This is the constructor for DL-Learner model.
 * @param editorKit Editor Kit to get the currently loaded Ontology
 * @param view current view of the DL-Learner tab
 */
public DLLearnerModel(OWLEditorKit editorKit,DLLearnerView view){
  editor=editorKit;
  isReasonerSet=false;
  this.view=view;
  ontologyConsistent=true;
  owlDescription=new HashSet<OWLDescription>();
  ComponentManager.setComponentClasses(componenten);
  cm=ComponentManager.getInstance();
  ds=new HashSet<OWLDescription>();
  suggestModel=new DefaultListModel();
  ontologieURI=new HashSet<String>();
  sources=new HashSet<KnowledgeSource>();
}","/** 
 * This is the constructor for DL-Learner model.
 * @param editorKit Editor Kit to get the currently loaded Ontology
 * @param view current view of the DL-Learner tab
 */
public DLLearnerModel(OWLEditorKit editorKit,DLLearnerView view){
  editor=editorKit;
  isReasonerSet=false;
  this.view=view;
  ontologyConsistent=true;
  knowledgeSourceIsUpdated=false;
  owlDescription=new HashSet<OWLDescription>();
  ComponentManager.setComponentClasses(componenten);
  cm=ComponentManager.getInstance();
  ds=new HashSet<OWLDescription>();
  suggestModel=new DefaultListModel();
  ontologieURI=new HashSet<String>();
  sources=new HashSet<KnowledgeSource>();
}"
9911,"/** 
 * This Method renders the view of the plugin.
 * @param label label if it is an equivalent or superclass
 */
public void makeView(String label){
  run.setEnabled(false);
  String currentConcept=editorKit.getOWLWorkspace().getOWLSelectionModel().getLastSelectedClass().toString();
  if (!labels.equals(currentConcept)) {
    readThread=new ReadingOntologyThread(editorKit,this,model);
  }
  if (!readThread.isAlive() && !labels.equals(currentConcept)) {
    readThread.start();
  }
  if (readThread.hasIndividuals()) {
    run.setEnabled(true);
  }
  labels=currentConcept;
  run.setText(""String_Node_Str"" + label + ""String_Node_Str"");
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(detail);
  model.setID(label);
  runPanel.add(BorderLayout.WEST,run);
  runPanel.add(BorderLayout.EAST,wikiPane);
  c.anchor=GridBagConstraints.FIRST_LINE_START;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=0;
  c.gridwidth=3;
  learner.add(runPanel,c);
  sugPanel.setSuggestList(new DefaultListModel());
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=1;
  c.weightx=1.0;
  c.weighty=1.0;
  c.gridwidth=2;
  sugPanel.setSuggestList(model.getSuggestModel());
  learner.add(sugPanel,c);
  accept.setEnabled(false);
  c.gridx=2;
  c.gridy=1;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=1;
  addButtonPanel.add(""String_Node_Str"",accept);
  learner.add(addButtonPanel,c);
  c.fill=GridBagConstraints.BOTH;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridx=0;
  c.gridy=2;
  hint.setPreferredSize(new Dimension(490,60));
  learner.add(hint,c);
  advancedPanel.add(advanced);
  advancedPanel.add(adv);
  advanced.setIcon(icon);
  advanced.setSelected(false);
  c.fill=GridBagConstraints.NONE;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=3;
  learner.add(advancedPanel,c);
  posPanel.setVisible(false);
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=4;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=3;
  learner.add(posPanel,c);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  detail.setVisible(false);
  isInconsistent=false;
  hint.setVisible(true);
  action.resetToggled();
  detail.setVisible(true);
  sugPanel.setVisible(true);
  learnerScroll.setViewportView(learner);
  this.renderErrorMessage(""String_Node_Str"");
  this.getSuggestClassPanel().getSuggestModel().clear();
  this.getSuggestClassPanel().repaint();
}","/** 
 * This Method renders the view of the plugin.
 * @param label label if it is an equivalent or superclass
 */
public void makeView(String label){
  run.setEnabled(false);
  String currentConcept=editorKit.getOWLWorkspace().getOWLSelectionModel().getLastSelectedClass().toString();
  if (!labels.equals(currentConcept) || individualSize != editorKit.getModelManager().getActiveOntology().getIndividualAxioms().size()) {
    if (individualSize != editorKit.getModelManager().getActiveOntology().getIndividualAxioms().size()) {
      model.setKnowledgeSourceIsUpdated(true);
    }
 else {
      model.setKnowledgeSourceIsUpdated(false);
    }
    readThread=new ReadingOntologyThread(editorKit,this,model);
  }
  if (!readThread.isAlive() && !labels.equals(currentConcept) || individualSize != editorKit.getModelManager().getActiveOntology().getIndividualAxioms().size()) {
    readThread.start();
  }
  if (readThread.hasIndividuals()) {
    run.setEnabled(true);
  }
  individualSize=editorKit.getModelManager().getActiveOntology().getIndividualAxioms().size();
  labels=currentConcept;
  run.setText(""String_Node_Str"" + label + ""String_Node_Str"");
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(detail);
  model.setID(label);
  runPanel.add(BorderLayout.WEST,run);
  runPanel.add(BorderLayout.EAST,wikiPane);
  c.anchor=GridBagConstraints.FIRST_LINE_START;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=0;
  c.gridwidth=3;
  learner.add(runPanel,c);
  sugPanel.setSuggestList(new DefaultListModel());
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=1;
  c.weightx=1.0;
  c.weighty=1.0;
  c.gridwidth=2;
  sugPanel.setSuggestList(model.getSuggestModel());
  learner.add(sugPanel,c);
  accept.setEnabled(false);
  c.gridx=2;
  c.gridy=1;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=1;
  addButtonPanel.add(""String_Node_Str"",accept);
  learner.add(addButtonPanel,c);
  c.fill=GridBagConstraints.BOTH;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridx=0;
  c.gridy=2;
  hint.setPreferredSize(new Dimension(490,60));
  learner.add(hint,c);
  advancedPanel.add(advanced);
  advancedPanel.add(adv);
  advanced.setIcon(icon);
  advanced.setSelected(false);
  c.fill=GridBagConstraints.NONE;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=3;
  learner.add(advancedPanel,c);
  posPanel.setVisible(false);
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=4;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=3;
  learner.add(posPanel,c);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  detail.setVisible(false);
  isInconsistent=false;
  hint.setVisible(true);
  action.resetToggled();
  detail.setVisible(true);
  sugPanel.setVisible(true);
  learnerScroll.setViewportView(learner);
  this.renderErrorMessage(""String_Node_Str"");
  this.getSuggestClassPanel().getSuggestModel().clear();
  this.getSuggestClassPanel().repaint();
}"
9912,"/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  labels=""String_Node_Str"";
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel(model,this);
  learnerPanel=new JPanel();
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  sugPanel.addSuggestPanelMouseListener(action);
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.setPreferredSize(new Dimension(485,30));
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(260,30));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}","/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  labels=""String_Node_Str"";
  individualSize=0;
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel(model,this);
  learnerPanel=new JPanel();
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  sugPanel.addSuggestPanelMouseListener(action);
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.setPreferredSize(new Dimension(485,30));
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(260,30));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}"
9913,"@Override public void run(){
  String loading=""String_Node_Str"";
  view.getHintPanel().setForeground(Color.RED);
  view.setHintMessage(loading);
  if (!model.isReasonerSet()) {
    model.setKnowledgeSource();
    model.setReasoner();
  }
  reasoner=model.getReasoner();
  isInconsistent=view.getIsInconsistent();
  if (!isInconsistent) {
    this.checkURI();
    this.setPositiveConcept();
    if (this.hasIndividuals()) {
      view.getRunButton().setEnabled(true);
      view.getHintPanel().setForeground(Color.BLACK);
      view.setHintMessage(""String_Node_Str"");
    }
 else {
      view.getRunButton().setEnabled(false);
      view.getHintPanel().setVisible(true);
      String message=""String_Node_Str"" + current + ""String_Node_Str"";
      view.getHintPanel().setForeground(Color.RED);
      view.setHintMessage(message);
    }
  }
 else {
    view.getHintPanel().setForeground(Color.RED);
    view.getRunButton().setEnabled(false);
    view.setHintMessage(""String_Node_Str"");
  }
}","@Override public void run(){
  String loading=""String_Node_Str"";
  view.getHintPanel().setForeground(Color.RED);
  view.setHintMessage(loading);
  if (!model.isReasonerSet() || model.getIsKnowledgeSourceIsUpdated() == true) {
    model.setKnowledgeSource();
    model.setReasoner();
  }
  reasoner=model.getReasoner();
  isInconsistent=view.getIsInconsistent();
  if (!isInconsistent) {
    this.checkURI();
    this.setPositiveConcept();
    if (this.hasIndividuals()) {
      view.getRunButton().setEnabled(true);
      view.getHintPanel().setForeground(Color.BLACK);
      view.setHintMessage(""String_Node_Str"");
    }
 else {
      view.getRunButton().setEnabled(false);
      view.getHintPanel().setVisible(true);
      String message=""String_Node_Str"" + current + ""String_Node_Str"";
      view.getHintPanel().setForeground(Color.RED);
      view.setHintMessage(message);
    }
  }
 else {
    view.getHintPanel().setForeground(Color.RED);
    view.getRunButton().setEnabled(false);
    view.setHintMessage(""String_Node_Str"");
  }
}"
9914,"private void computeImpactSOS(OWLAxiom ax){
}","public Set<OWLAxiom> computeImpactSOS(OWLAxiom axiom){
  Set<OWLAxiom> result=new HashSet<OWLAxiom>();
  if (axiom instanceof OWLSubClassAxiom) {
    OWLSubClassAxiom subAx=(OWLSubClassAxiom)axiom;
    if (subAx.getSubClass() instanceof OWLClass && subAx.getSuperClass() instanceof OWLClass) {
      OWLClass sub=(OWLClass)subAx.getSubClass();
      OWLClass sup=(OWLClass)subAx.getSuperClass();
      for (      OWLClass desc : SetUtils.union(reasoner.getDescendantClasses(sub))) {
        for (        OWLClass anc : SetUtils.union(reasoner.getAncestorClasses(sup))) {
          if (!anc.equals(factory.getOWLThing()) && !desc.equals(factory.getOWLNothing())) {
            OWLSubClassAxiom ax=factory.getOWLSubClassAxiom(desc,anc);
            result.add(ax);
          }
        }
      }
    }
  }
 else   if (axiom instanceof OWLDisjointClassesAxiom) {
    Set<OWLDescription> disjointClasses=((OWLDisjointClassesAxiom)axiom).getDescriptions();
    boolean complex=false;
    for (    OWLDescription dis : disjointClasses) {
      if (dis.isAnonymous()) {
        complex=true;
        break;
      }
    }
    if (!complex) {
      List<OWLDescription> disjoints=new ArrayList<OWLDescription>(disjointClasses);
      for (      OWLDescription dis : new ArrayList<OWLDescription>(disjoints)) {
        if (!dis.equals(factory.getOWLNothing())) {
          disjoints.remove(dis);
          Set<? extends OWLDescription> descendants=SetUtils.union(reasoner.getDescendantClasses(dis.asOWLClass()));
          descendants.removeAll(reasoner.getEquivalentClasses(factory.getOWLNothing()));
          for (          OWLDescription desc1 : descendants) {
            if (!desc1.equals(factory.getOWLNothing())) {
              if (enableImpactUnsat || !reasoner.getEquivalentClasses((desc1)).contains(factory.getOWLNothing())) {
                for (                OWLDescription desc2 : disjoints) {
                  if (!desc2.equals(desc1)) {
                    Set<OWLDescription> newDis=new HashSet<OWLDescription>();
                    newDis.add(desc1);
                    newDis.add(desc2);
                    OWLDisjointClassesAxiom ax=factory.getOWLDisjointClassesAxiom(newDis);
                    result.add(ax);
                  }
                }
              }
            }
          }
          disjoints.add(dis);
        }
      }
      return result;
    }
  }
 else   if (axiom instanceof OWLObjectPropertyDomainAxiom) {
    OWLObjectPropertyDomainAxiom pd=(OWLObjectPropertyDomainAxiom)axiom;
    if (pd.getDomain() instanceof OWLClass) {
      OWLClass dom=(OWLClass)pd.getDomain();
      Set<OWLClass> superClasses=SetUtils.union(reasoner.getSuperClasses(dom));
      for (      OWLClass sup : superClasses) {
        OWLObjectPropertyDomainAxiom ax=factory.getOWLObjectPropertyDomainAxiom(pd.getProperty(),sup);
        result.add(ax);
      }
    }
  }
 else   if (axiom instanceof OWLDataPropertyDomainAxiom) {
    OWLDataPropertyDomainAxiom pd=(OWLDataPropertyDomainAxiom)axiom;
    if (pd.getDomain() instanceof OWLClass) {
      OWLClass dom=(OWLClass)pd.getDomain();
      Set<OWLClass> superClasses=SetUtils.union(reasoner.getSuperClasses(dom));
      for (      OWLClass sup : superClasses) {
        OWLDataPropertyDomainAxiom ax=factory.getOWLDataPropertyDomainAxiom(pd.getProperty(),sup);
        result.add(ax);
      }
    }
  }
 else   if (axiom instanceof OWLObjectPropertyRangeAxiom) {
    OWLObjectPropertyRangeAxiom pd=(OWLObjectPropertyRangeAxiom)axiom;
    if (pd.getRange() instanceof OWLClass) {
      OWLClass ran=(OWLClass)pd.getRange();
      Set<OWLClass> superClasses=SetUtils.union(reasoner.getSuperClasses(ran));
      for (      OWLClass sup : superClasses) {
        OWLObjectPropertyRangeAxiom ax=factory.getOWLObjectPropertyRangeAxiom(pd.getProperty(),sup);
        result.add(ax);
      }
    }
  }
  return result;
}"
9915,"/** 
 * This method sets the reasoner. Only FastInstanceChecker is available.
 */
public void setReasoner(){
  this.reasoner=cm.reasoner(FastInstanceChecker.class,sources);
  try {
    reasoner.init();
    reasoner.isSatisfiable();
    view.setIsInconsistent(false);
    isReasonerSet=true;
  }
 catch (  ComponentInitException e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
catch (  InconsistentOntologyException incon) {
    view.setIsInconsistent(true);
  }
}","/** 
 * This method sets the reasoner. Only FastInstanceChecker is available.
 */
public void setReasoner(){
  this.reasoner=cm.reasoner(FastInstanceChecker.class,sources);
  try {
    reasoner.init();
    reasoner.isSatisfiable();
    view.setIsInconsistent(false);
    isReasonerSet=true;
  }
 catch (  ComponentInitException e) {
    System.out.println(""String_Node_Str"");
    view.setIsInconsistent(true);
  }
catch (  InconsistentOntologyException incon) {
    System.out.println(""String_Node_Str"");
    view.setIsInconsistent(true);
  }
}"
9916,"/** 
 * This Method renders the view of the plugin.
 * @param label label if it is an equivalent or superclass
 */
public void makeView(String label){
  run.setEnabled(false);
  String currentConcept=editorKit.getOWLWorkspace().getOWLSelectionModel().getLastSelectedClass().toString();
  if (!labels.equals(currentConcept)) {
    readThread=new ReadingOntologyThread(editorKit,this,model);
  }
  if (!readThread.isAlive() && !labels.equals(currentConcept)) {
    readThread.start();
  }
  if (readThread.hasIndividuals()) {
    run.setEnabled(true);
  }
  labels=currentConcept;
  run.setText(""String_Node_Str"" + label + ""String_Node_Str"");
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(detail);
  model.setID(label);
  runPanel.add(BorderLayout.WEST,run);
  runPanel.add(BorderLayout.EAST,wikiPane);
  c.anchor=GridBagConstraints.FIRST_LINE_START;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=0;
  c.gridwidth=3;
  learner.add(runPanel,c);
  sugPanel.setSuggestList(new DefaultListModel());
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=1;
  c.weightx=1.0;
  c.weighty=1.0;
  c.gridwidth=2;
  sugPanel.setSuggestList(model.getSuggestModel());
  learner.add(sugPanel,c);
  accept.setEnabled(false);
  c.gridx=2;
  c.gridy=1;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=1;
  addButtonPanel.add(""String_Node_Str"",accept);
  learner.add(addButtonPanel,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.gridx=0;
  c.gridy=2;
  learner.add(hint,c);
  advancedPanel.add(advanced);
  advancedPanel.add(adv);
  advanced.setIcon(icon);
  advanced.setSelected(false);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=3;
  learner.add(advancedPanel,c);
  posPanel.setVisible(false);
  c.fill=GridBagConstraints.BOTH;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridheight=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.gridy=4;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=3;
  learner.add(posPanel,c);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  detail.setVisible(false);
  isInconsistent=false;
  hint.setVisible(true);
  action.resetToggled();
  detail.setVisible(true);
  sugPanel.setVisible(true);
  learnerScroll.setViewportView(learner);
  this.renderErrorMessage(""String_Node_Str"");
  this.getSuggestClassPanel().getSuggestModel().clear();
  this.getSuggestClassPanel().repaint();
}","/** 
 * This Method renders the view of the plugin.
 * @param label label if it is an equivalent or superclass
 */
public void makeView(String label){
  run.setEnabled(false);
  String currentConcept=editorKit.getOWLWorkspace().getOWLSelectionModel().getLastSelectedClass().toString();
  if (!labels.equals(currentConcept)) {
    readThread=new ReadingOntologyThread(editorKit,this,model);
  }
  if (!readThread.isAlive() && !labels.equals(currentConcept)) {
    readThread.start();
  }
  if (readThread.hasIndividuals()) {
    run.setEnabled(true);
  }
  labels=currentConcept;
  run.setText(""String_Node_Str"" + label + ""String_Node_Str"");
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(detail);
  model.setID(label);
  runPanel.add(BorderLayout.WEST,run);
  runPanel.add(BorderLayout.EAST,wikiPane);
  c.anchor=GridBagConstraints.FIRST_LINE_START;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=0;
  c.gridwidth=3;
  learner.add(runPanel,c);
  sugPanel.setSuggestList(new DefaultListModel());
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=1;
  c.weightx=1.0;
  c.weighty=1.0;
  c.gridwidth=2;
  sugPanel.setSuggestList(model.getSuggestModel());
  learner.add(sugPanel,c);
  accept.setEnabled(false);
  c.gridx=2;
  c.gridy=1;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=1;
  addButtonPanel.add(""String_Node_Str"",accept);
  learner.add(addButtonPanel,c);
  c.fill=GridBagConstraints.BOTH;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridx=0;
  c.gridy=2;
  hint.setPreferredSize(new Dimension(490,60));
  learner.add(hint,c);
  advancedPanel.add(advanced);
  advancedPanel.add(adv);
  advanced.setIcon(icon);
  advanced.setSelected(false);
  c.fill=GridBagConstraints.NONE;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=3;
  learner.add(advancedPanel,c);
  posPanel.setVisible(false);
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=4;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=3;
  learner.add(posPanel,c);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  detail.setVisible(false);
  isInconsistent=false;
  hint.setVisible(true);
  action.resetToggled();
  detail.setVisible(true);
  sugPanel.setVisible(true);
  learnerScroll.setViewportView(learner);
  this.renderErrorMessage(""String_Node_Str"");
  this.getSuggestClassPanel().getSuggestModel().clear();
  this.getSuggestClassPanel().repaint();
}"
9917,"@Override public void run(){
  String loading=""String_Node_Str"";
  view.getHintPanel().setForeground(Color.RED);
  view.setHintMessage(loading);
  if (!model.isReasonerSet()) {
    model.setKnowledgeSource();
    model.setReasoner();
  }
  reasoner=model.getReasoner();
  isInconsistent=false;
  if (!isInconsistent) {
    this.checkURI();
    this.setPositiveConcept();
    if (this.hasIndividuals()) {
      view.getRunButton().setEnabled(true);
      view.getHintPanel().setForeground(Color.BLACK);
      view.setHintMessage(""String_Node_Str"");
    }
 else {
      view.getRunButton().setEnabled(false);
      view.getHintPanel().setVisible(true);
      String message=""String_Node_Str"" + current + ""String_Node_Str"";
      view.getHintPanel().setForeground(Color.RED);
      view.setHintMessage(message);
    }
  }
 else {
    view.getHintPanel().setForeground(Color.RED);
    view.getRunButton().setEnabled(false);
    view.setHintMessage(""String_Node_Str"");
  }
}","@Override public void run(){
  String loading=""String_Node_Str"";
  view.getHintPanel().setForeground(Color.RED);
  view.setHintMessage(loading);
  if (!model.isReasonerSet()) {
    model.setKnowledgeSource();
    model.setReasoner();
  }
  reasoner=model.getReasoner();
  isInconsistent=view.getIsInconsistent();
  if (!isInconsistent) {
    this.checkURI();
    this.setPositiveConcept();
    if (this.hasIndividuals()) {
      view.getRunButton().setEnabled(true);
      view.getHintPanel().setForeground(Color.BLACK);
      view.setHintMessage(""String_Node_Str"");
    }
 else {
      view.getRunButton().setEnabled(false);
      view.getHintPanel().setVisible(true);
      String message=""String_Node_Str"" + current + ""String_Node_Str"";
      view.getHintPanel().setForeground(Color.RED);
      view.setHintMessage(message);
    }
  }
 else {
    view.getHintPanel().setForeground(Color.RED);
    view.getRunButton().setEnabled(false);
    view.setHintMessage(""String_Node_Str"");
  }
}"
9918,"/** 
 * This is the constructor for DL-Learner model.
 * @param editorKit Editor Kit to get the currently loaded Ontology
 * @param id String if it learns a subclass or a superclass.
 * @param view current view of the DL-Learner tab
 */
public DLLearnerModel(OWLEditorKit editorKit,DLLearnerView view){
  editor=editorKit;
  this.view=view;
  ontologyConsistent=true;
  owlDescription=new HashSet<OWLDescription>();
  ComponentManager.setComponentClasses(componenten);
  cm=ComponentManager.getInstance();
  ds=new HashSet<OWLDescription>();
  suggestModel=new DefaultListModel();
  ontologieURI=new HashSet<String>();
  sources=new HashSet<KnowledgeSource>();
}","/** 
 * This is the constructor for DL-Learner model.
 * @param editorKit Editor Kit to get the currently loaded Ontology
 * @param id String if it learns a subclass or a superclass.
 * @param view current view of the DL-Learner tab
 */
public DLLearnerModel(OWLEditorKit editorKit,DLLearnerView view){
  editor=editorKit;
  isReasonerSet=false;
  this.view=view;
  ontologyConsistent=true;
  owlDescription=new HashSet<OWLDescription>();
  ComponentManager.setComponentClasses(componenten);
  cm=ComponentManager.getInstance();
  ds=new HashSet<OWLDescription>();
  suggestModel=new DefaultListModel();
  ontologieURI=new HashSet<String>();
  sources=new HashSet<KnowledgeSource>();
}"
9919,"/** 
 * This method sets the reasoner. Only FastInstanceChecker is available.
 */
public void setReasoner(){
  this.reasoner=cm.reasoner(FastInstanceChecker.class,sources);
  try {
    reasoner.init();
    reasoner.isSatisfiable();
    view.setIsInconsistent(false);
  }
 catch (  ComponentInitException e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
catch (  InconsistentOntologyException incon) {
    view.setIsInconsistent(true);
  }
}","/** 
 * This method sets the reasoner. Only FastInstanceChecker is available.
 */
public void setReasoner(){
  this.reasoner=cm.reasoner(FastInstanceChecker.class,sources);
  try {
    reasoner.init();
    reasoner.isSatisfiable();
    view.setIsInconsistent(false);
    isReasonerSet=true;
  }
 catch (  ComponentInitException e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
catch (  InconsistentOntologyException incon) {
    view.setIsInconsistent(true);
  }
}"
9920,"/** 
 * This Method renders the view of the plugin.
 */
public void makeView(String label){
  run.setText(""String_Node_Str"" + label + ""String_Node_Str"");
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(detail);
  model.setID(label);
  runPanel.add(BorderLayout.WEST,run);
  runPanel.add(BorderLayout.EAST,wikiPane);
  run.setEnabled(false);
  c.anchor=GridBagConstraints.FIRST_LINE_START;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=0;
  c.gridwidth=3;
  learner.add(runPanel,c);
  sugPanel.setSuggestList(new DefaultListModel());
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=1;
  c.weightx=1.0;
  c.weighty=1.0;
  c.gridwidth=2;
  sugPanel.setSuggestList(model.getSuggestModel());
  learner.add(sugPanel,c);
  accept.setEnabled(false);
  c.gridx=2;
  c.gridy=1;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=1;
  addButtonPanel.add(""String_Node_Str"",accept);
  learner.add(addButtonPanel,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.gridx=0;
  c.gridy=2;
  learner.add(hint,c);
  advancedPanel.add(advanced);
  advancedPanel.add(adv);
  advanced.setIcon(icon);
  advanced.setSelected(false);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=3;
  learner.add(advancedPanel,c);
  posPanel.setVisible(false);
  c.fill=GridBagConstraints.BOTH;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridheight=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.gridy=4;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=3;
  learner.add(posPanel,c);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  detail.setVisible(false);
  hint.setText(""String_Node_Str"");
  isInconsistent=false;
  readThread=new ReadingOntologyThread(editorKit,this,model);
  readThread.start();
  hint.setVisible(true);
  action.resetToggled();
  detail.setVisible(true);
  sugPanel.setVisible(true);
  learnerScroll.setViewportView(learner);
  this.renderErrorMessage(""String_Node_Str"");
}","/** 
 * This Method renders the view of the plugin.
 */
public void makeView(String label){
  run.setEnabled(false);
  String currentConcept=editorKit.getOWLWorkspace().getOWLSelectionModel().getLastSelectedClass().toString();
  if (!labels.equals(currentConcept)) {
    readThread=new ReadingOntologyThread(editorKit,this,model);
  }
  if (!readThread.isAlive() && !labels.equals(currentConcept)) {
    readThread.start();
  }
  if (readThread.hasIndividuals()) {
    run.setEnabled(true);
  }
  labels=currentConcept;
  run.setText(""String_Node_Str"" + label + ""String_Node_Str"");
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(detail);
  model.setID(label);
  runPanel.add(BorderLayout.WEST,run);
  runPanel.add(BorderLayout.EAST,wikiPane);
  c.anchor=GridBagConstraints.FIRST_LINE_START;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=0;
  c.gridwidth=3;
  learner.add(runPanel,c);
  sugPanel.setSuggestList(new DefaultListModel());
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=1;
  c.weightx=1.0;
  c.weighty=1.0;
  c.gridwidth=2;
  sugPanel.setSuggestList(model.getSuggestModel());
  learner.add(sugPanel,c);
  accept.setEnabled(false);
  c.gridx=2;
  c.gridy=1;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=1;
  addButtonPanel.add(""String_Node_Str"",accept);
  learner.add(addButtonPanel,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.gridx=0;
  c.gridy=2;
  learner.add(hint,c);
  advancedPanel.add(advanced);
  advancedPanel.add(adv);
  advanced.setIcon(icon);
  advanced.setSelected(false);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=3;
  learner.add(advancedPanel,c);
  posPanel.setVisible(false);
  c.fill=GridBagConstraints.BOTH;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridheight=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.gridy=4;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=3;
  learner.add(posPanel,c);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  detail.setVisible(false);
  isInconsistent=false;
  hint.setVisible(true);
  action.resetToggled();
  detail.setVisible(true);
  sugPanel.setVisible(true);
  learnerScroll.setViewportView(learner);
  this.renderErrorMessage(""String_Node_Str"");
}"
9921,"/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 * @param label String
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel();
  learnerPanel=new JPanel();
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  sugPanel.addSuggestPanelMouseListener(action);
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.setPreferredSize(new Dimension(485,30));
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(260,30));
  advanced.setName(""String_Node_Str"");
  model.initReasoner();
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}","/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 * @param label String
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  labels=""String_Node_Str"";
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel();
  learnerPanel=new JPanel();
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  sugPanel.addSuggestPanelMouseListener(action);
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.setPreferredSize(new Dimension(485,30));
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(260,30));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}"
9922,"@Override public void initialise() throws Exception {
  view=new DLLearnerView(super.getOWLEditorKit());
  if (this.getAxiomType().toString().equals(EQUIVALENT_CLASS_STRING)) {
    view.makeView(""String_Node_Str"");
  }
 else   if (this.getAxiomType().toString().equals(SUPERCLASS_STRING)) {
    view.makeView(""String_Node_Str"");
  }
}","@Override public void initialise() throws Exception {
  view=new DLLearnerView(super.getOWLEditorKit());
}"
9923,"@Override public void run(){
  model.getSuggestModel().removeAllElements();
  reasoner=model.getReasoner();
  isInconsistent=false;
  if (!isInconsistent) {
    this.checkURI();
    this.setPositiveConcept();
    if (this.hasIndividuals()) {
      view.getRunButton().setEnabled(true);
      view.getHintPanel().setForeground(Color.BLACK);
      view.setHintMessage(""String_Node_Str"");
    }
 else {
      view.getRunButton().setEnabled(false);
      view.getHintPanel().setVisible(true);
      String message=""String_Node_Str"" + current + ""String_Node_Str"";
      view.getHintPanel().setForeground(Color.RED);
      view.setHintMessage(message);
    }
  }
 else {
    view.getHintPanel().setForeground(Color.RED);
    view.getRunButton().setEnabled(false);
    view.setHintMessage(""String_Node_Str"");
  }
}","@Override public void run(){
  String loading=""String_Node_Str"";
  view.getHintPanel().setForeground(Color.RED);
  view.setHintMessage(loading);
  if (!model.isReasonerSet()) {
    model.setKnowledgeSource();
    model.setReasoner();
  }
  reasoner=model.getReasoner();
  isInconsistent=false;
  if (!isInconsistent) {
    this.checkURI();
    this.setPositiveConcept();
    if (this.hasIndividuals()) {
      view.getRunButton().setEnabled(true);
      view.getHintPanel().setForeground(Color.BLACK);
      view.setHintMessage(""String_Node_Str"");
    }
 else {
      view.getRunButton().setEnabled(false);
      view.getHintPanel().setVisible(true);
      String message=""String_Node_Str"" + current + ""String_Node_Str"";
      view.getHintPanel().setForeground(Color.RED);
      view.setHintMessage(message);
    }
  }
 else {
    view.getHintPanel().setForeground(Color.RED);
    view.getRunButton().setEnabled(false);
    view.setHintMessage(""String_Node_Str"");
  }
}"
9924,"/** 
 * Adds the wrong negative and positive examples to the lists.
 */
public void refreshExampleLists(){
  this.ore=getWizardModel().getOre();
  repairPanel.setCellRenderers(ore);
  DefaultListModel negModel=repairPanel.getNegFailureModel();
  negModel.clear();
  for (  Individual ind : ore.getNewClassDescription().getCoveredNegatives()) {
    negModel.addElement(ind);
  }
  DefaultListModel posModel=repairPanel.getPosFailureModel();
  posModel.clear();
  for (  Individual ind : ore.getNewClassDescription().getNotCoveredPositives()) {
    posModel.addElement(ind);
  }
}","/** 
 * Adds the wrong negative and positive examples to the lists.
 */
public void refreshExampleLists(){
  this.ore=getWizardModel().getOre();
  repairPanel.setCellRenderers(ore);
  DefaultListModel negModel=repairPanel.getNegFailureModel();
  negModel.clear();
  for (  Individual ind : ore.getNewClassDescription().getAdditionalInstances()) {
    negModel.addElement(ind);
  }
  DefaultListModel posModel=repairPanel.getPosFailureModel();
  posModel.clear();
  System.out.println(ore.getNewClassDescription().getCoveredInstances());
  Set<Individual> posNotCovered=ore.getOwlReasoner().getIndividuals(ore.getIgnoredConcept());
  posNotCovered.removeAll(ore.getNewClassDescription().getCoveredInstances());
  for (  Individual ind : posNotCovered) {
    posModel.addElement(ind);
  }
}"
9925,"private JPanel getContentPanel(){
  JPanel contentPanel1=new JPanel();
  JScrollPane scroll=new JScrollPane();
  conceptList=new JList(model);
  scroll.setPreferredSize(new Dimension(400,400));
  scroll.setViewportView(conceptList);
  contentPanel1.add(scroll);
  return contentPanel1;
}","private JPanel getContentPanel(){
  JPanel contentPanel1=new JPanel();
  JScrollPane scroll=new JScrollPane();
  conceptList=new JXList(model);
  conceptList.setFilterEnabled(true);
  conceptList.setFilters(new FilterPipeline(new ShuttleSorter(0,true)));
  conceptList.setHighlighters(HighlighterFactory.createSimpleStriping(HighlighterFactory.CLASSIC_LINE_PRINTER));
  conceptList.addHighlighter(new ColorHighlighter(HighlightPredicate.ROLLOVER_ROW));
  conceptList.setRolloverEnabled(true);
  scroll.setPreferredSize(new Dimension(400,400));
  scroll.setViewportView(conceptList);
  contentPanel1.add(scroll);
  return contentPanel1;
}"
9926,"public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  removeAll();
  JLabel cor=new JLabel();
  JLabel desc=new JLabel();
  setLayout(new GridBagLayout());
  desc.setText(((EvaluatedDescriptionPosNeg)value).getDescription().toManchesterSyntaxString(ore.getBaseURI(),ore.getPrefixes()));
  double accuracy=((EvaluatedDescriptionPosNeg)value).getAccuracy();
  BigDecimal roundedAccuracy=new BigDecimal(accuracy * 100);
  roundedAccuracy=roundedAccuracy.setScale(2,BigDecimal.ROUND_HALF_UP);
  cor.setText(roundedAccuracy.toString());
  add(cor,new GridBagConstraints(0,0,1,1,0.1,0.0,GridBagConstraints.LINE_END,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  add(desc,new GridBagConstraints(1,0,1,1,0.8,0.0,GridBagConstraints.LINE_START,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  Color background;
  Color foreground;
  if (index % 2 == 0 && !isSelected) {
    background=new Color(242,242,242);
    foreground=Color.BLACK;
  }
 else   if (isSelected) {
    background=Color.LIGHT_GRAY;
    foreground=Color.WHITE;
  }
 else {
    background=Color.WHITE;
    foreground=Color.BLACK;
  }
  setForeground(foreground);
  setBackground(background);
  return this;
}","public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  removeAll();
  JLabel cor=new JLabel();
  JLabel desc=new JLabel();
  setLayout(new GridBagLayout());
  desc.setText(((EvaluatedDescriptionClass)value).getDescription().toManchesterSyntaxString(ore.getBaseURI(),ore.getPrefixes()));
  double accuracy=((EvaluatedDescriptionClass)value).getAccuracy();
  BigDecimal roundedAccuracy=new BigDecimal(accuracy * 100);
  roundedAccuracy=roundedAccuracy.setScale(2,BigDecimal.ROUND_HALF_UP);
  cor.setText(String.valueOf(roundedAccuracy));
  add(cor,new GridBagConstraints(0,0,1,1,0.1,0.0,GridBagConstraints.LINE_END,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  add(desc,new GridBagConstraints(1,0,1,1,0.8,0.0,GridBagConstraints.LINE_START,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  Color background;
  Color foreground;
  if (index % 2 == 0 && !isSelected) {
    background=new Color(242,242,242);
    foreground=Color.BLACK;
  }
 else   if (isSelected) {
    background=Color.LIGHT_GRAY;
    foreground=Color.WHITE;
  }
 else {
    background=Color.WHITE;
    foreground=Color.BLACK;
  }
  setForeground(foreground);
  setBackground(background);
  return this;
}"
9927,"/** 
 * Updates the panel.
 */
public void updatePanel(){
  for (  Component c : getComponents()) {
    if (c instanceof JLabel) {
      remove(c);
    }
  }
  ore.updateReasoner();
  correct=true;
  if (mode.equals(""String_Node_Str"")) {
    for (    JLabel jL : ore.descriptionToJLabelNeg(ind,newClassDescription)) {
      add(jL);
      if (jL instanceof DescriptionLabel) {
        ((DescriptionLabel)jL).setIndOre(ore,ind);
        ((DescriptionLabel)jL).init();
        ((DescriptionLabel)jL).addActionListeners(aL);
        correct=false;
      }
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    for (    JLabel jL : ore.descriptionToJLabelPos(ind,newClassDescription)) {
      add(jL);
      if (jL instanceof DescriptionLabel) {
        ((DescriptionLabel)jL).setIndOre(ore,ind);
        ((DescriptionLabel)jL).init();
        ((DescriptionLabel)jL).addActionListeners(aL);
        correct=false;
      }
    }
  }
  SwingUtilities.updateComponentTreeUI(this);
}","/** 
 * Updates the panel.
 */
public void updatePanel(){
  for (  Component c : getComponents()) {
    if (c instanceof JLabel) {
      remove(c);
    }
  }
  correct=true;
  if (mode.equals(""String_Node_Str"")) {
    for (    JLabel jL : ore.descriptionToJLabelNeg(ind,newClassDescription)) {
      add(jL);
      if (jL instanceof DescriptionLabel) {
        ((DescriptionLabel)jL).setIndOre(ore,ind);
        ((DescriptionLabel)jL).init();
        ((DescriptionLabel)jL).addActionListeners(aL);
        correct=false;
      }
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    for (    JLabel jL : ore.descriptionToJLabelPos(ind,newClassDescription)) {
      add(jL);
      if (jL instanceof DescriptionLabel) {
        ((DescriptionLabel)jL).setIndOre(ore,ind);
        ((DescriptionLabel)jL).init();
        ((DescriptionLabel)jL).addActionListeners(aL);
        correct=false;
      }
    }
  }
  SwingUtilities.updateComponentTreeUI(this);
}"
9928,"public void addListeners(ActionListener l,DocumentListener d){
  browseButton.addActionListener(l);
  fileURL.addActionListener(l);
  sparqlURL.addActionListener(l);
  owl.addActionListener(l);
  sparql.addActionListener(l);
  fileURL.getDocument().addDocumentListener(d);
}","public void addListeners(ActionListener l,DocumentListener d){
  browseButton.addActionListener(l);
  fileURL.addActionListener(l);
  sparqlURL.addActionListener(l);
  connectButton.addActionListener(l);
  owl.addActionListener(l);
  sparql.addActionListener(l);
  fileURL.getDocument().addDocumentListener(d);
}"
9929,"public LearningPanel(){
  super();
  listModel=new DefaultListModel();
  JPanel statusPanel=new JPanel();
  statusLabel=new JLabel();
  loadingLabel=new JXBusyLabel(new Dimension(15,15));
  BusyPainter<Object> painter=new BusyPainter<Object>(new RoundRectangle2D.Float(0,0,6.0f,2.6f,10.0f,10.0f),new Ellipse2D.Float(2.0f,2.0f,11.0f,11.0f));
  painter.setTrailLength(2);
  painter.setPoints(7);
  painter.setFrame(-1);
  loadingLabel.setPreferredSize(new Dimension(15,15));
  loadingLabel.setIcon(new EmptyIcon(15,15));
  loadingLabel.setBusyPainter(painter);
  statusPanel.add(loadingLabel);
  statusPanel.add(statusLabel);
  contentPanel=getContentPanel();
  setLayout(new java.awt.BorderLayout());
  add(contentPanel,BorderLayout.CENTER);
  add(statusPanel,BorderLayout.SOUTH);
{
    buttonSliderPanel=new JPanel();
    this.add(buttonSliderPanel,BorderLayout.EAST);
    GridBagLayout buttonSliderPanelLayout=new GridBagLayout();
    buttonSliderPanelLayout.rowWeights=new double[]{0.0,0.0};
    buttonSliderPanelLayout.rowHeights=new int[]{126,7};
    buttonSliderPanelLayout.columnWeights=new double[]{0.1};
    buttonSliderPanelLayout.columnWidths=new int[]{7};
    buttonSliderPanel.setLayout(buttonSliderPanelLayout);
{
      buttonPanel=new JPanel();
      BoxLayout buttonPanelLayout=new BoxLayout(buttonPanel,javax.swing.BoxLayout.X_AXIS);
      buttonPanel.setLayout(buttonPanelLayout);
      buttonSliderPanel.add(buttonPanel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
{
        startButton=new JButton();
        buttonPanel.add(startButton);
        startButton.setText(""String_Node_Str"");
      }
{
        stopButton=new JButton();
        buttonPanel.add(stopButton);
        stopButton.setText(""String_Node_Str"");
      }
    }
{
      noisePanel=new JPanel();
      BoxLayout noisePanelLayout=new BoxLayout(noisePanel,javax.swing.BoxLayout.Y_AXIS);
      noisePanel.setLayout(noisePanelLayout);
      buttonSliderPanel.add(noisePanel,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
{
        noiseLabel=new JLabel();
        noisePanel.add(noiseLabel);
        noiseLabel.setText(""String_Node_Str"");
      }
{
        noiseSlider=new JSlider(0,100,0);
        noiseSlider.setPaintTicks(true);
        noiseSlider.setMajorTickSpacing(10);
        noiseSlider.setMinorTickSpacing(5);
        Dictionary<Integer,JLabel> map=new Hashtable<Integer,JLabel>();
        map.put(new Integer(0),new JLabel(""String_Node_Str""));
        map.put(new Integer(50),new JLabel(""String_Node_Str""));
        map.put(new Integer(100),new JLabel(""String_Node_Str""));
        noiseSlider.setLabelTable(map);
        noiseSlider.setPaintLabels(true);
        noisePanel.add(noiseSlider);
      }
    }
  }
}","public LearningPanel(){
  super();
  listModel=new DefaultListModel();
  JPanel statusPanel=new JPanel();
  statusLabel=new JLabel();
  loadingLabel=new JXBusyLabel(new Dimension(15,15));
  BusyPainter painter=new BusyPainter(new RoundRectangle2D.Float(0,0,6.0f,2.6f,10.0f,10.0f),new Ellipse2D.Float(2.0f,2.0f,11.0f,11.0f));
  painter.setTrailLength(2);
  painter.setPoints(7);
  painter.setFrame(-1);
  loadingLabel.setPreferredSize(new Dimension(15,15));
  loadingLabel.setIcon(new EmptyIcon(15,15));
  loadingLabel.setBusyPainter(painter);
  statusPanel.add(loadingLabel);
  statusPanel.add(statusLabel);
  contentPanel=getContentPanel();
  setLayout(new java.awt.BorderLayout());
  add(contentPanel,BorderLayout.CENTER);
  add(statusPanel,BorderLayout.SOUTH);
{
    buttonSliderPanel=new JPanel();
    this.add(buttonSliderPanel,BorderLayout.EAST);
    GridBagLayout buttonSliderPanelLayout=new GridBagLayout();
    buttonSliderPanelLayout.rowWeights=new double[]{0.0,0.0};
    buttonSliderPanelLayout.rowHeights=new int[]{126,7};
    buttonSliderPanelLayout.columnWeights=new double[]{0.1};
    buttonSliderPanelLayout.columnWidths=new int[]{7};
    buttonSliderPanel.setLayout(buttonSliderPanelLayout);
{
      buttonPanel=new JPanel();
      BoxLayout buttonPanelLayout=new BoxLayout(buttonPanel,javax.swing.BoxLayout.X_AXIS);
      buttonPanel.setLayout(buttonPanelLayout);
      buttonSliderPanel.add(buttonPanel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
{
        startButton=new JButton();
        buttonPanel.add(startButton);
        startButton.setText(""String_Node_Str"");
      }
{
        stopButton=new JButton();
        buttonPanel.add(stopButton);
        stopButton.setText(""String_Node_Str"");
      }
    }
{
      noisePanel=new JPanel();
      BoxLayout noisePanelLayout=new BoxLayout(noisePanel,javax.swing.BoxLayout.Y_AXIS);
      noisePanel.setLayout(noisePanelLayout);
      buttonSliderPanel.add(noisePanel,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
{
        noiseLabel=new JLabel();
        noisePanel.add(noiseLabel);
        noiseLabel.setText(""String_Node_Str"");
      }
{
        noiseSlider=new JSlider(0,100,0);
        noiseSlider.setPaintTicks(true);
        noiseSlider.setMajorTickSpacing(10);
        noiseSlider.setMinorTickSpacing(5);
        Dictionary<Integer,JLabel> map=new Hashtable<Integer,JLabel>();
        map.put(new Integer(0),new JLabel(""String_Node_Str""));
        map.put(new Integer(50),new JLabel(""String_Node_Str""));
        map.put(new Integer(100),new JLabel(""String_Node_Str""));
        noiseSlider.setLabelTable(map);
        noiseSlider.setPaintLabels(true);
        noisePanel.add(noiseSlider);
      }
    }
  }
}"
9930,"public void valueChanged(ListSelectionEvent e){
  setNextButtonAccordingToConceptSelected();
  if (!e.getValueIsAdjusting()) {
    getWizardModel().getOre().setNewClassDescription(((EvaluatedDescriptionPosNeg)(learnPanel.getResultList().getSelectedValue())));
  }
}","public void valueChanged(ListSelectionEvent e){
  setNextButtonAccordingToConceptSelected();
  if (!e.getValueIsAdjusting()) {
    getWizardModel().getOre().setNewClassDescription(((EvaluatedDescriptionClass)(learnPanel.getResultList().getSelectedValue())));
  }
}"
9931,"public static Collection<ConfigOption<?>> createConfigOptions(){
  Collection<ConfigOption<?>> options=new LinkedList<ConfigOption<?>>();
  options.add(new IntegerConfigOption(""String_Node_Str"",""String_Node_Str"",5));
  options.add(new IntegerConfigOption(""String_Node_Str"",""String_Node_Str"",5));
  return options;
}","public static Collection<ConfigOption<?>> createConfigOptions(){
  Collection<ConfigOption<?>> options=new LinkedList<ConfigOption<?>>();
  options.add(new IntegerConfigOption(""String_Node_Str"",""String_Node_Str"",100));
  options.add(new IntegerConfigOption(""String_Node_Str"",""String_Node_Str"",5));
  return options;
}"
9932,"/** 
 * This method stores the new concept learned by the DL-Learner in the Ontology.
 * @param descript Description learn by the DL-Learner
 */
public void changeDLLearnerDescriptionsToOWLDescriptions(Description descript){
  setNewConceptOWLAPI(descript);
  oldConceptOWLAPI=OWLAPIDescriptionConvertVisitor.getOWLDescription(currentConcept);
  ds.add(oldConceptOWLAPI);
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  OWLDataFactory factory=manager.getOWLDataFactory();
  if (id.equals(EQUIVALENT_CLASS_AXIOM_STRING)) {
    axiomOWLAPI=factory.getOWLEquivalentClassesAxiom(ds);
  }
 else {
    axiomOWLAPI=factory.getOWLSubClassAxiom(oldConceptOWLAPI,newConceptOWLAPI);
  }
  OWLOntology onto=editor.getModelManager().getActiveOntology();
  AddAxiom axiom=new AddAxiom(onto,axiomOWLAPI);
  try {
    manager.applyChange(axiom);
  }
 catch (  OWLOntologyChangeException e) {
    e.printStackTrace();
  }
}","/** 
 * This method stores the new concept learned by the DL-Learner in the Ontology.
 * @param descript Description learn by the DL-Learner
 */
public void changeDLLearnerDescriptionsToOWLDescriptions(Description descript){
  ds.clear();
  owlDescription.clear();
  setNewConceptOWLAPI(descript);
  oldConceptOWLAPI=OWLAPIDescriptionConvertVisitor.getOWLDescription(currentConcept);
  ds.add(oldConceptOWLAPI);
  System.out.println(""String_Node_Str"" + ds);
  OWLOntologyManager manager=OWLManager.createOWLOntologyManager();
  OWLDataFactory factory=manager.getOWLDataFactory();
  if (id.equals(EQUIVALENT_CLASS_AXIOM_STRING)) {
    axiomOWLAPI=factory.getOWLEquivalentClassesAxiom(ds);
  }
 else {
    axiomOWLAPI=factory.getOWLSubClassAxiom(oldConceptOWLAPI,newConceptOWLAPI);
  }
  OWLOntology onto=editor.getModelManager().getActiveOntology();
  AddAxiom axiom=new AddAxiom(onto,axiomOWLAPI);
  try {
    manager.applyChange(axiom);
  }
 catch (  OWLOntologyChangeException e) {
    e.printStackTrace();
  }
}"
9933,"@Override public SortedSet<? extends EvaluatedDescription> getCurrentlyBestEvaluatedDescriptions(){
  return bestEvaluatedDescriptions.getSet();
}","@Override public TreeSet<? extends EvaluatedDescription> getCurrentlyBestEvaluatedDescriptions(){
  return bestEvaluatedDescriptions.getSet();
}"
9934,"@Override public SortedSet<? extends EvaluatedDescription> getCurrentlyBestEvaluatedDescriptions(){
  return bestEvaluatedDescriptions.getSet();
}","@Override public TreeSet<? extends EvaluatedDescription> getCurrentlyBestEvaluatedDescriptions(){
  return bestEvaluatedDescriptions.getSet();
}"
9935,"@Override public SortedSet<EvaluatedDescriptionPosNeg> getCurrentlyBestEvaluatedDescriptions(){
  int count=0;
  SortedSet<Node> rev=candidatesStable.descendingSet();
  SortedSet<EvaluatedDescriptionPosNeg> cbd=new TreeSet<EvaluatedDescriptionPosNeg>(edComparator);
  for (  Node eb : rev) {
    cbd.add(new EvaluatedDescriptionPosNeg(eb.getConcept(),getSolutionScore(eb.getConcept())));
    if (count > 200)     return cbd;
    count++;
  }
  return cbd;
}","@Override public TreeSet<EvaluatedDescriptionPosNeg> getCurrentlyBestEvaluatedDescriptions(){
  int count=0;
  SortedSet<Node> rev=candidatesStable.descendingSet();
  TreeSet<EvaluatedDescriptionPosNeg> cbd=new TreeSet<EvaluatedDescriptionPosNeg>(edComparator);
  for (  Node eb : rev) {
    cbd.add(new EvaluatedDescriptionPosNeg(eb.getConcept(),getSolutionScore(eb.getConcept())));
    if (count > 200)     return cbd;
    count++;
  }
  return cbd;
}"
9936,"@Override public synchronized SortedSet<EvaluatedDescriptionPosNeg> getCurrentlyBestEvaluatedDescriptions(){
  return algorithm.getCurrentlyBestEvaluatedDescriptions();
}","@Override public synchronized TreeSet<EvaluatedDescriptionPosNeg> getCurrentlyBestEvaluatedDescriptions(){
  return algorithm.getCurrentlyBestEvaluatedDescriptions();
}"
9937,"/** 
 * In this function it is calculated whether the algorithm should stop. This is not always depends whether an actual solution was found The algorithm stops if: 1. the object attribute stop is set to true (possibly by an outside source) 2. the maximimum execution time is reached 3. the maximum number of class description tests is reached Continuation criteria and result improvement The algorithm continues (although it would normally stop) if 1. Minimum execution time is not reached (default 0) 2. not enough good solutions are found (default 1) otherwise it stops
 * @return true if the algorithm should stop, this is mostly indepent of the question if a solution was found
 */
private boolean isTerminationCriteriaReached(){
  if (this.stop) {
    return true;
  }
  System.out.println(""String_Node_Str"");
  long totalTimeNeeded=System.currentTimeMillis() - this.runtime;
  long maxMilliSeconds=maxExecutionTimeInSeconds * 1000;
  long minMilliSeconds=minExecutionTimeInSeconds * 1000;
  int conceptTests=conceptTestsReasoner + conceptTestsTooWeakList + conceptTestsOverlyGeneralList;
  boolean result=false;
  if (maxExecutionTimeInSeconds == 0)   result=false;
 else   if (maxExecutionTimeAlreadyReached)   return true;
 else   if (maxMilliSeconds < totalTimeNeeded) {
    this.stop();
    logger.info(""String_Node_Str"" + maxExecutionTimeInSeconds + ""String_Node_Str"");
    maxExecutionTimeAlreadyReached=true;
    return true;
  }
  if (maxClassDescriptionTests == 0)   result=false;
 else   if (conceptTests >= maxClassDescriptionTests) {
    logger.info(""String_Node_Str"" + maxClassDescriptionTests + ""String_Node_Str""+ conceptTests+ ""String_Node_Str"");
    return true;
  }
  if (guaranteeXgoodAlreadyReached) {
    result=true;
  }
 else   if (solutions.size() >= guaranteeXgoodDescriptions) {
    if (guaranteeXgoodDescriptions != 1) {
      logger.info(""String_Node_Str"" + guaranteeXgoodDescriptions + ""String_Node_Str"");
    }
    guaranteeXgoodAlreadyReached=true;
    result=true;
  }
  if (minExecutionTimeAlreadyReached) {
    result=result && true;
  }
 else   if (minMilliSeconds < totalTimeNeeded) {
    if (minExecutionTimeInSeconds != 0) {
      logger.info(""String_Node_Str"" + minExecutionTimeInSeconds + ""String_Node_Str"");
    }
    minExecutionTimeAlreadyReached=true;
    result=result && true;
  }
 else {
    result=false;
  }
  return result;
}","/** 
 * In this function it is calculated whether the algorithm should stop. This is not always depends whether an actual solution was found The algorithm stops if: 1. the object attribute stop is set to true (possibly by an outside source) 2. the maximimum execution time is reached 3. the maximum number of class description tests is reached Continuation criteria and result improvement The algorithm continues (although it would normally stop) if 1. Minimum execution time is not reached (default 0) 2. not enough good solutions are found (default 1) otherwise it stops
 * @return true if the algorithm should stop, this is mostly indepent of the question if a solution was found
 */
private boolean isTerminationCriteriaReached(){
  if (this.stop) {
    return true;
  }
  long totalTimeNeeded=System.currentTimeMillis() - this.runtime;
  long maxMilliSeconds=maxExecutionTimeInSeconds * 1000;
  long minMilliSeconds=minExecutionTimeInSeconds * 1000;
  int conceptTests=conceptTestsReasoner + conceptTestsTooWeakList + conceptTestsOverlyGeneralList;
  boolean result=false;
  if (maxExecutionTimeInSeconds == 0)   result=false;
 else   if (maxExecutionTimeAlreadyReached)   return true;
 else   if (maxMilliSeconds < totalTimeNeeded) {
    this.stop();
    logger.info(""String_Node_Str"" + maxExecutionTimeInSeconds + ""String_Node_Str"");
    maxExecutionTimeAlreadyReached=true;
    return true;
  }
  if (maxClassDescriptionTests == 0)   result=false;
 else   if (conceptTests >= maxClassDescriptionTests) {
    logger.info(""String_Node_Str"" + maxClassDescriptionTests + ""String_Node_Str""+ conceptTests+ ""String_Node_Str"");
    return true;
  }
  if (guaranteeXgoodAlreadyReached) {
    result=true;
  }
 else   if (solutions.size() >= guaranteeXgoodDescriptions) {
    if (guaranteeXgoodDescriptions != 1) {
      logger.info(""String_Node_Str"" + guaranteeXgoodDescriptions + ""String_Node_Str"");
    }
    guaranteeXgoodAlreadyReached=true;
    result=true;
  }
  if (minExecutionTimeAlreadyReached) {
    result=result && true;
  }
 else   if (minMilliSeconds < totalTimeNeeded) {
    if (minExecutionTimeInSeconds != 0) {
      logger.info(""String_Node_Str"" + minExecutionTimeInSeconds + ""String_Node_Str"");
    }
    minExecutionTimeAlreadyReached=true;
    result=result && true;
  }
 else {
    result=false;
  }
  return result;
}"
9938,"public SortedSet<EvaluatedDescriptionPosNeg> getCurrentlyBestEvaluatedDescriptions(){
  Iterator<ExampleBasedNode> it=candidatesStable.descendingIterator();
  int count=0;
  SortedSet<EvaluatedDescriptionPosNeg> cbd=new TreeSet<EvaluatedDescriptionPosNeg>(edComparator);
  while (it.hasNext()) {
    ExampleBasedNode eb=it.next();
    cbd.add(new EvaluatedDescriptionPosNeg(eb.getConcept(),getScore(eb.getConcept())));
    if (count > 200)     return cbd;
    count++;
  }
  return cbd;
}","public TreeSet<EvaluatedDescriptionPosNeg> getCurrentlyBestEvaluatedDescriptions(){
  Iterator<ExampleBasedNode> it=candidatesStable.descendingIterator();
  int count=0;
  TreeSet<EvaluatedDescriptionPosNeg> cbd=new TreeSet<EvaluatedDescriptionPosNeg>(edComparator);
  while (it.hasNext()) {
    ExampleBasedNode eb=it.next();
    cbd.add(new EvaluatedDescriptionPosNeg(eb.getConcept(),getScore(eb.getConcept())));
    if (count > 200)     return cbd;
    count++;
  }
  return cbd;
}"
9939,"/** 
 * type Whether to learn an equivalence class or super class axiom.. mandatory: false| reinit necessary: true default value: equivalence
 * @return String 
 */
public String getType(){
  return (String)ComponentManager.getInstance().getConfigOptionValue(classLearningProblem,""String_Node_Str"");
}","/** 
 * type Whether to learn an equivalence class or super class axiom or domain/range of a property.. mandatory: false| reinit necessary: true default value: equivalence
 * @return String 
 */
public String getType(){
  return (String)ComponentManager.getInstance().getConfigOptionValue(classLearningProblem,""String_Node_Str"");
}"
9940,"/** 
 * @param type Whether to learn an equivalence class or super class axiom..mandatory: false| reinit necessary: true default value: equivalence
 */
public void setType(String type){
  ComponentManager.getInstance().applyConfigEntry(classLearningProblem,""String_Node_Str"",type);
  reinitNecessary=true;
}","/** 
 * @param type Whether to learn an equivalence class or super class axiom or domain/range of a property..mandatory: false| reinit necessary: true default value: equivalence
 */
public void setType(String type){
  ComponentManager.getInstance().applyConfigEntry(classLearningProblem,""String_Node_Str"",type);
  reinitNecessary=true;
}"
9941,"protected OWLClass getLimit(){
  return getDataFactory().getOWLNothing();
}","@Override protected OWLClass getLimit(){
  return getDataFactory().getOWLNothing();
}"
9942,"public Set<OWLDescription> visit(OWLDataValueRestriction desc){
  return Collections.singleton((OWLDescription)desc);
}","@Override public Set<OWLDescription> visit(OWLDataValueRestriction desc){
  return Collections.singleton((OWLDescription)desc);
}"
9943,"protected OWLDataRange getDataLimit(){
  return getDataFactory().getOWLDataComplementOf(getDataFactory().getTopDataType());
}","@Override protected OWLDataRange getDataLimit(){
  return getDataFactory().getOWLDataComplementOf(getDataFactory().getTopDataType());
}"
9944,"protected OWLClass getLimit(){
  return getDataFactory().getOWLNothing();
}","@Override protected OWLClass getLimit(){
  return getDataFactory().getOWLNothing();
}"
9945,"public Set<OWLDescription> visit(OWLDataValueRestriction desc){
  return Collections.singleton((OWLDescription)desc);
}","@Override public Set<OWLDescription> visit(OWLDataValueRestriction desc){
  return Collections.singleton((OWLDescription)desc);
}"
9946,"protected OWLDataRange getDataLimit(){
  return getDataFactory().getOWLDataComplementOf(getDataFactory().getTopDataType());
}","@Override protected OWLDataRange getDataLimit(){
  return getDataFactory().getOWLDataComplementOf(getDataFactory().getTopDataType());
}"
9947,"protected OWLClass getLimit(){
  return getDataFactory().getOWLThing();
}","@Override protected OWLClass getLimit(){
  return getDataFactory().getOWLThing();
}"
9948,"protected OWLDataRange getDataLimit(){
  return getDataFactory().getTopDataType();
}","@Override protected OWLDataRange getDataLimit(){
  return getDataFactory().getTopDataType();
}"
9949,"protected OWLClass getLimit(){
  return getDataFactory().getOWLThing();
}","@Override protected OWLClass getLimit(){
  return getDataFactory().getOWLThing();
}"
9950,"protected OWLDataRange getDataLimit(){
  return getDataFactory().getTopDataType();
}","@Override protected OWLDataRange getDataLimit(){
  return getDataFactory().getTopDataType();
}"
9951,"@Override public int compare(EvaluatedDescriptionPosNeg ed1,EvaluatedDescriptionPosNeg ed2){
  double acc1=ed1.getAccuracy();
  double acc2=ed2.getAccuracy();
  if (acc1 > acc2)   return -1;
 else   if (acc1 < acc2)   return 1;
 else {
    int length1=ed1.getDescriptionLength();
    int length2=ed2.getDescriptionLength();
    if (length1 < length2)     return -1;
 else     if (length1 > length2)     return 1;
 else     return cc.compare(ed1.getDescription(),ed2.getDescription());
  }
}","@Override public int compare(EvaluatedDescriptionPosNeg ed1,EvaluatedDescriptionPosNeg ed2){
  double acc1=ed1.getAccuracy();
  double acc2=ed2.getAccuracy();
  if (acc1 > acc2)   return 1;
 else   if (acc1 < acc2)   return -1;
 else {
    int length1=ed1.getDescriptionLength();
    int length2=ed2.getDescriptionLength();
    if (length1 < length2)     return 1;
 else     if (length1 > length2)     return -1;
 else     return cc.compare(ed1.getDescription(),ed2.getDescription());
  }
}"
9952,"public void run(){
  model.setSuggestList(result);
  dm.clear();
  int i=0;
  for (  EvaluatedDescription eval : result) {
    Set<String> ont=model.getOntologyURIString();
    for (    String ontology : ont) {
      if (eval.getDescription().toString().contains(ontology)) {
        if (((EvaluatedDescriptionClass)eval).isConsistent()) {
          dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          break;
        }
 else {
          dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          view.setIsInconsistent(true);
          break;
        }
      }
    }
  }
  view.getSuggestClassPanel().setSuggestList(dm);
}","public void run(){
  model.setSuggestList(result);
  dm.clear();
  int i=0;
  for (  EvaluatedDescription eval : result) {
    Set<String> ont=model.getOntologyURIString();
    for (    String ontology : ont) {
      if (eval.getDescription().toString().contains(ontology)) {
        if (((EvaluatedDescriptionClass)eval).isConsistent()) {
          dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          break;
        }
 else {
          dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          view.setIsInconsistent(true);
          break;
        }
      }
    }
  }
  view.getSuggestClassPanel().setSuggestList(dm);
  view.getLearnerView().repaint();
}"
9953,"private void updateList(final List<? extends EvaluatedDescription> result){
  Runnable doUpdateList=new Runnable(){
    public void run(){
      model.setSuggestList(result);
      dm.clear();
      int i=0;
      for (      EvaluatedDescription eval : result) {
        Set<String> ont=model.getOntologyURIString();
        for (        String ontology : ont) {
          if (eval.getDescription().toString().contains(ontology)) {
            if (((EvaluatedDescriptionClass)eval).isConsistent()) {
              dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              break;
            }
 else {
              dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              view.setIsInconsistent(true);
              break;
            }
          }
        }
      }
      view.getSuggestClassPanel().setSuggestList(dm);
    }
  }
;
  SwingUtilities.invokeLater(doUpdateList);
}","private void updateList(final List<? extends EvaluatedDescription> result){
  Runnable doUpdateList=new Runnable(){
    public void run(){
      model.setSuggestList(result);
      dm.clear();
      int i=0;
      for (      EvaluatedDescription eval : result) {
        Set<String> ont=model.getOntologyURIString();
        for (        String ontology : ont) {
          if (eval.getDescription().toString().contains(ontology)) {
            if (((EvaluatedDescriptionClass)eval).isConsistent()) {
              dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              break;
            }
 else {
              dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              view.setIsInconsistent(true);
              break;
            }
          }
        }
      }
      view.getSuggestClassPanel().setSuggestList(dm);
      view.getLearnerView().repaint();
    }
  }
;
  SwingUtilities.invokeLater(doUpdateList);
}"
9954,"/** 
 * This Method renders the view of the plugin.
 */
public void makeView(String label){
  run.setText(""String_Node_Str"" + label + ""String_Node_Str"");
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(detail);
  model.setID(label);
  runPanel.add(BorderLayout.WEST,run);
  runPanel.add(BorderLayout.EAST,wikiPane);
  run.setEnabled(false);
  c.anchor=GridBagConstraints.FIRST_LINE_START;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=0;
  c.gridwidth=3;
  learner.add(runPanel,c);
  sugPanel.setSuggestList(new DefaultListModel());
  c.fill=GridBagConstraints.NONE;
  c.gridx=0;
  c.gridy=1;
  c.weightx=1.0;
  c.weighty=1.0;
  c.gridwidth=2;
  sugPanel.setSuggestList(model.getSuggestModel());
  learner.add(sugPanel,c);
  accept.setEnabled(false);
  c.gridx=2;
  c.gridy=1;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=1;
  addButtonPanel.add(""String_Node_Str"",accept);
  learner.add(addButtonPanel,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=2;
  learner.add(hint,c);
  advancedPanel.add(advanced);
  advancedPanel.add(adv);
  advanced.setIcon(icon);
  advanced.setSelected(false);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=3;
  learner.add(advancedPanel,c);
  posPanel.setVisible(false);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridheight=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.gridy=4;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=3;
  learner.add(posPanel,c);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  detail.setVisible(false);
  hint.setText(""String_Node_Str"");
  isInconsistent=false;
  readThread=new ReadingOntologyThread(editorKit,this,model);
  readThread.start();
  hint.setVisible(true);
  action.resetToggled();
  detail.setVisible(true);
  sugPanel.setVisible(true);
  learnerScroll.setViewportView(learner);
  this.renderErrorMessage(""String_Node_Str"");
}","/** 
 * This Method renders the view of the plugin.
 */
public void makeView(String label){
  run.setText(""String_Node_Str"" + label + ""String_Node_Str"");
  run.setPreferredSize(new Dimension(200,40));
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(detail);
  model.setID(label);
  runPanel.add(BorderLayout.WEST,run);
  runPanel.add(BorderLayout.EAST,wikiPane);
  run.setEnabled(false);
  c.anchor=GridBagConstraints.FIRST_LINE_START;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=0;
  c.gridwidth=3;
  learner.add(runPanel,c);
  sugPanel.setSuggestList(new DefaultListModel());
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=1;
  c.weightx=1.0;
  c.weighty=1.0;
  c.gridwidth=2;
  sugPanel.setSuggestList(model.getSuggestModel());
  learner.add(sugPanel,c);
  accept.setEnabled(false);
  c.gridx=2;
  c.gridy=1;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=1;
  addButtonPanel.add(""String_Node_Str"",accept);
  learner.add(addButtonPanel,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.gridx=0;
  c.gridy=2;
  learner.add(hint,c);
  advancedPanel.add(advanced);
  advancedPanel.add(adv);
  advanced.setIcon(icon);
  advanced.setSelected(false);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=3;
  learner.add(advancedPanel,c);
  posPanel.setVisible(false);
  c.fill=GridBagConstraints.BOTH;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridheight=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.gridy=4;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=3;
  learner.add(posPanel,c);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  detail.setVisible(false);
  hint.setText(""String_Node_Str"");
  isInconsistent=false;
  readThread=new ReadingOntologyThread(editorKit,this,model);
  readThread.start();
  hint.setVisible(true);
  action.resetToggled();
  detail.setVisible(true);
  sugPanel.setVisible(true);
  learnerScroll.setViewportView(learner);
  this.renderErrorMessage(""String_Node_Str"");
}"
9955,"/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 * @param label String
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel();
  learnerPanel=new JPanel();
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  sugPanel.addSuggestPanelMouseListener(action);
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.setPreferredSize(new Dimension(485,30));
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(90,50));
  run.setPreferredSize(new Dimension(220,50));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}","/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 * @param label String
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel();
  learnerPanel=new JPanel();
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  sugPanel.addSuggestPanelMouseListener(action);
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.setPreferredSize(new Dimension(485,30));
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(220,50));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}"
9956,"public void setGraphicalPanel(){
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(posPanel);
  learner.remove(advancedPanel);
  detail.setVisible(true);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.gridy=3;
  c.weightx=0.0;
  c.weighty=0.0;
  learner.add(detail,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.LINE_START;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.gridx=0;
  c.gridy=4;
  learner.add(advancedPanel,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=0;
  c.gridy=5;
  c.gridwidth=GridBagConstraints.REMAINDER;
  learner.add(posPanel,c);
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.setViewportView(learner);
  learnerScroll.repaint();
}","public void setGraphicalPanel(){
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(posPanel);
  learner.remove(advancedPanel);
  detail.setVisible(true);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=0;
  c.gridy=3;
  c.weightx=0.0;
  c.weighty=0.0;
  learner.add(detail,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.LINE_START;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.gridx=0;
  c.gridy=4;
  learner.add(advancedPanel,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=0;
  c.gridy=5;
  c.gridwidth=GridBagConstraints.REMAINDER;
  learner.add(posPanel,c);
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.setViewportView(learner);
  learnerScroll.repaint();
}"
9957,"/** 
 * This is the constructor for the GraphicalCoveragePanel.
 * @param desc EvaluatedDescription
 * @param m DLLearnerModel
 * @param concept String
 * @param p MoreDetailForSuggestedConceptsPanel
 */
public GraphicalCoveragePanel(EvaluatedDescription desc,DLLearnerModel m,String concept,MoreDetailForSuggestedConceptsPanel p){
  this.setPreferredSize(new Dimension(600,220));
  this.setVisible(false);
  this.setForeground(Color.GREEN);
  this.repaint();
  eval=desc;
  model=m;
  panel=p;
  id=model.getID();
  darkGreen=new Color(0,100,0);
  darkRed=new Color(205,0,0);
  random=new Random();
  conceptNew=concept;
  conceptVector=new Vector<String>();
  posCovIndVector=new Vector<IndividualPoint>();
  posNotCovIndVector=new Vector<IndividualPoint>();
  additionalIndividuals=new Vector<IndividualPoint>();
  points=new Vector<IndividualPoint>();
  this.computeGraphics(0,0);
  handler=new GraphicalCoveragePanelHandler(this,desc,model);
  if (shiftXAxis == 0) {
    oldConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + (2 * adjustment) + 3,ELLIPSE_Y_AXIS + 3,WIDTH,HEIGHT);
  }
 else {
    oldConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + (2 * adjustment),ELLIPSE_Y_AXIS,WIDTH,HEIGHT);
  }
  if (shiftXAxis == 0) {
    newConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + shiftXAxis + adjustment,ELLIPSE_Y_AXIS,WIDTH + distortionOld + 6,HEIGHT + distortionOld + 6);
  }
 else {
    newConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + shiftXAxis + adjustment,ELLIPSE_Y_AXIS,WIDTH + distortionOld,HEIGHT + distortionOld);
  }
  this.computeIndividualPoints(300);
  this.addMouseMotionListener(handler);
  this.addMouseListener(handler);
}","/** 
 * This is the constructor for the GraphicalCoveragePanel.
 * @param desc EvaluatedDescription
 * @param m DLLearnerModel
 * @param concept String
 * @param p MoreDetailForSuggestedConceptsPanel
 */
public GraphicalCoveragePanel(EvaluatedDescription desc,DLLearnerModel m,String concept,MoreDetailForSuggestedConceptsPanel p){
  this.setVisible(false);
  this.setForeground(Color.GREEN);
  this.setPreferredSize(new Dimension(500,230));
  eval=desc;
  model=m;
  panel=p;
  this.repaint();
  id=model.getID();
  darkGreen=new Color(0,100,0);
  darkRed=new Color(205,0,0);
  random=new Random();
  conceptNew=concept;
  conceptVector=new Vector<String>();
  posCovIndVector=new Vector<IndividualPoint>();
  posNotCovIndVector=new Vector<IndividualPoint>();
  additionalIndividuals=new Vector<IndividualPoint>();
  points=new Vector<IndividualPoint>();
  this.computeGraphics(0,0);
  handler=new GraphicalCoveragePanelHandler(this,desc,model);
  if (shiftXAxis == 0) {
    oldConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + (2 * adjustment) + 3,ELLIPSE_Y_AXIS + 3,WIDTH,HEIGHT);
  }
 else {
    oldConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + (2 * adjustment),ELLIPSE_Y_AXIS,WIDTH,HEIGHT);
  }
  if (shiftXAxis == 0) {
    newConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + shiftXAxis + adjustment,ELLIPSE_Y_AXIS,WIDTH + distortionOld + 6,HEIGHT + distortionOld + 6);
  }
 else {
    newConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + shiftXAxis + adjustment,ELLIPSE_Y_AXIS,WIDTH + distortionOld,HEIGHT + distortionOld);
  }
  this.computeIndividualPoints(300);
  this.addMouseMotionListener(handler);
  this.addMouseListener(handler);
}"
9958,"@Override protected void paintComponent(Graphics g){
  if (eval != null) {
    Graphics2D g2D;
    g2D=(Graphics2D)g;
    AlphaComposite ac=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.5f);
    g2D.setColor(Color.BLACK);
    g2D.drawString(model.getOldConceptOWLAPI().toString(),320,10);
    g2D.setColor(Color.ORANGE);
    g2D.fillOval(310,20,9,9);
    g2D.setColor(Color.black);
    int p=30;
    for (int i=0; i < conceptVector.size(); i++) {
      g2D.drawString(conceptVector.get(i),320,p);
      p=p + 20;
    }
    g2D.setColor(darkGreen);
    Ellipse2D circlePoint=new Ellipse2D.Double(315 - 1,p - 6,3,3);
    g2D.draw(circlePoint);
    g2D.setColor(Color.BLACK);
    g2D.drawString(""String_Node_Str"",320,p);
    p=p + 20;
    g2D.drawString(""String_Node_Str"",320,p);
    p=p + 20;
    if (id.equals(EQUI_STRING)) {
      g2D.setColor(darkRed);
      Ellipse2D circlePoint2=new Ellipse2D.Double(315 - 1,p - 6,3,3);
      g2D.draw(circlePoint2);
      g2D.setColor(Color.BLACK);
      g2D.drawString(""String_Node_Str"",320,p);
      p=p + 20;
      g2D.drawString(""String_Node_Str"",320,p);
    }
 else {
      g2D.setColor(darkRed);
      Ellipse2D circlePoint2=new Ellipse2D.Double(315 - 1,p - 6,3,3);
      g2D.draw(circlePoint2);
      g2D.setColor(Color.BLACK);
      g2D.drawString(""String_Node_Str"",320,p);
      p=p + 20;
      g2D.setColor(Color.BLACK);
      Ellipse2D circlePoint3=new Ellipse2D.Double(315 - 1,p - 6,3,3);
      g2D.draw(circlePoint3);
      g2D.setColor(Color.BLACK);
      g2D.drawString(""String_Node_Str"",320,p);
    }
    g2D.setColor(Color.YELLOW);
    g2D.fill(oldConcept);
    g2D.fillOval(310,0,9,9);
    g2D.setColor(Color.ORANGE);
    g2D.setComposite(ac);
    g2D.fill(newConcept);
    g2D.setColor(Color.BLACK);
    if (coveredIndividualSize != model.getReasoner().getIndividuals(model.getCurrentConcept()).size() && coveredIndividualSize != 0) {
      g2D.drawLine(x1 - 1 - shiftOldConcept,y1 - 1,x2 + 1 - shiftOldConcept,y1 - 1);
      g2D.drawLine(x1 - shiftOldConcept,centerY - 1,x2 - shiftOldConcept,centerY - 1);
      g2D.drawLine(x1 - shiftOldConcept,centerY,x2 - shiftOldConcept,centerY);
      g2D.drawLine(x1 - shiftOldConcept,centerY + 1,x2 - shiftOldConcept,centerY + 1);
      g2D.drawLine(x1 - 1 - shiftOldConcept,y2 + 1,x2 + 1 - shiftOldConcept,y2 + 1);
      g2D.drawLine(x1 - 1 - shiftOldConcept,y1 - 1,x1 - 1 - shiftOldConcept,y2 + 1);
      g2D.drawLine(centerX - 1 - shiftOldConcept,y1,centerX - 1 - shiftOldConcept,y2);
      g2D.drawLine(centerX - shiftOldConcept,y1,centerX - shiftOldConcept,y2);
      g2D.drawLine(centerX + 1 - shiftOldConcept,y1,centerX + 1 - shiftOldConcept,y2);
      g2D.drawLine(x2 + 1 - shiftOldConcept,y1 - 1,x2 + 1 - shiftOldConcept,y2 + 1);
    }
    g2D.drawLine(x1 - 1 + shiftCovered,y1 - 1,x2 + 1 + shiftCovered,y1 - 1);
    g2D.drawLine(x1 + shiftCovered,centerY - 1,x2 + shiftCovered,centerY - 1);
    g2D.drawLine(x1 + shiftCovered,centerY,x2 + shiftCovered,centerY);
    g2D.drawLine(x1 + shiftCovered,centerY + 1,x2 + shiftCovered,centerY + 1);
    g2D.drawLine(x1 - 1 + shiftCovered,y2 + 1,x2 + 1 + shiftCovered,y2 + 1);
    g2D.drawLine(x1 - 1 + shiftCovered,y1 - 1,x1 - 1 + shiftCovered,y2 + 1);
    g2D.drawLine(centerX - 1 + shiftCovered,y1,centerX - 1 + shiftCovered,y2);
    g2D.drawLine(centerX + shiftCovered,y1,centerX + shiftCovered,y2);
    g2D.drawLine(centerX + 1 + shiftCovered,y1,centerX + 1 + shiftCovered,y2);
    g2D.drawLine(x2 + 1 + shiftCovered,y1 - 1,x2 + 1 + shiftCovered,y2 + 1);
    if (coveredIndividualSize != model.getReasoner().getIndividuals(model.getCurrentConcept()).size()) {
      g2D.drawLine(x1 - 1 + shiftNewConcept,y1 - 1,x2 + 1 + shiftNewConcept,y1 - 1);
      g2D.drawLine(x1 + shiftNewConcept,centerY - 1,x2 + shiftNewConcept,centerY - 1);
      g2D.drawLine(x1 + shiftNewConcept,centerY,x2 + shiftNewConcept,centerY);
      g2D.drawLine(x1 + shiftNewConcept,centerY + 1,x2 + shiftNewConcept,centerY + 1);
      g2D.drawLine(x1 - 1 + shiftNewConcept,y2 + 1,x2 + 1 + shiftNewConcept,y2 + 1);
      g2D.drawLine(x1 - 1 + shiftNewConcept,y1 - 1,x1 - 1 + shiftNewConcept,y2 + 1);
      g2D.drawLine(centerX - 1 + shiftNewConcept,y1,centerX - 1 + shiftNewConcept,y2);
      g2D.drawLine(centerX + shiftNewConcept,y1,centerX + shiftNewConcept,y2);
      g2D.drawLine(centerX + 1 + shiftNewConcept,y1,centerX + 1 + shiftNewConcept,y2);
      g2D.drawLine(x2 + 1 + shiftNewConcept,y1 - 1,x2 + 1 + shiftNewConcept,y2 + 1);
    }
    if (((EvaluatedDescriptionClass)eval).getAddition() != 1.0 && ((EvaluatedDescriptionClass)eval).getCoverage() == 1.0) {
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY - 1 + shiftNewConcept,x2 + shiftNewConceptX,centerY - 1 + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY + shiftNewConcept,x2 + shiftNewConceptX,centerY + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY + 1 + shiftNewConcept,x2 + shiftNewConceptX,centerY + 1 + shiftNewConcept);
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x1 - 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
      g2D.drawLine(centerX - 1 + shiftNewConceptX,y1 + shiftNewConcept,centerX - 1 + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(centerX + shiftNewConceptX,y1 + shiftNewConcept,centerX + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(centerX + 1 + shiftNewConceptX,y1 + shiftNewConcept,centerX + 1 + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(x2 + 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
    }
    for (int i=0; i < posCovIndVector.size(); i++) {
      g2D.setColor(darkGreen);
      g2D.draw(posCovIndVector.get(i).getIndividualPoint());
    }
    for (int i=0; i < posNotCovIndVector.size(); i++) {
      g2D.setColor(darkRed);
      g2D.draw(posNotCovIndVector.get(i).getIndividualPoint());
    }
    for (int i=0; i < additionalIndividuals.size(); i++) {
      g2D.setColor(Color.BLACK);
      g2D.draw(additionalIndividuals.get(i).getIndividualPoint());
    }
    this.setVisible(true);
    panel.repaint();
  }
}","@Override protected void paintComponent(Graphics g){
  if (eval != null) {
    Graphics2D g2D;
    g2D=(Graphics2D)g;
    Composite original=g2D.getComposite();
    AlphaComposite ac=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.5f);
    g2D.setColor(Color.BLACK);
    g2D.drawString(model.getOldConceptOWLAPI().toString(),320,10);
    g2D.setColor(Color.ORANGE);
    g2D.fillOval(310,20,9,9);
    g2D.setColor(Color.black);
    int p=30;
    for (int i=0; i < conceptVector.size(); i++) {
      g2D.drawString(conceptVector.get(i),320,p);
      p=p + 20;
    }
    g2D.setColor(darkGreen);
    Ellipse2D circlePoint=new Ellipse2D.Double(315 - 1,p - 6,3,3);
    g2D.fill(circlePoint);
    g2D.setColor(Color.BLACK);
    g2D.drawString(""String_Node_Str"",320,p);
    g2D.setColor(Color.ORANGE);
    g2D.fillOval(445,p - 9,9,9);
    g2D.setColor(Color.BLACK);
    g2D.drawString(""String_Node_Str"",460,p);
    g2D.setColor(Color.YELLOW);
    g2D.fillOval(490,p - 9,9,9);
    p=p + 20;
    if (id.equals(EQUI_STRING)) {
      g2D.setColor(darkRed);
      Ellipse2D circlePoint2=new Ellipse2D.Double(315 - 1,p - 6,3,3);
      g2D.fill(circlePoint2);
      g2D.setColor(Color.BLACK);
      g2D.drawString(""String_Node_Str"",320,p);
      g2D.setColor(Color.ORANGE);
      g2D.fillOval(445,p - 9,9,9);
      p=p + 20;
      g2D.setColor(darkRed);
      Ellipse2D circlePoint3=new Ellipse2D.Double(315 - 1,p - 6,3,3);
      g2D.fill(circlePoint3);
      g2D.setColor(Color.BLACK);
      g2D.drawString(""String_Node_Str"",320,p);
      g2D.setColor(Color.YELLOW);
      g2D.fillOval(445,p - 9,9,9);
    }
 else {
      g2D.setColor(Color.BLACK);
      Ellipse2D circlePoint2=new Ellipse2D.Double(315 - 1,p - 6,3,3);
      g2D.fill(circlePoint2);
      g2D.drawString(""String_Node_Str"",320,p);
      g2D.setColor(Color.ORANGE);
      g2D.fillOval(445,p - 9,9,9);
      p=p + 20;
      g2D.setColor(darkRed);
      Ellipse2D circlePoint3=new Ellipse2D.Double(315 - 1,p - 6,3,3);
      g2D.fill(circlePoint3);
      g2D.setColor(Color.BLACK);
      g2D.drawString(""String_Node_Str"",320,p);
      g2D.setColor(Color.YELLOW);
      g2D.fillOval(445,p - 9,9,9);
    }
    g2D.setColor(Color.YELLOW);
    g2D.fill(oldConcept);
    g2D.fillOval(310,0,9,9);
    g2D.setColor(Color.ORANGE);
    g2D.setComposite(ac);
    g2D.fill(newConcept);
    g2D.setColor(Color.BLACK);
    if (coveredIndividualSize != model.getReasoner().getIndividuals(model.getCurrentConcept()).size() && coveredIndividualSize != 0) {
      g2D.drawLine(x1 - 1 - shiftOldConcept,y1 - 1,x2 + 1 - shiftOldConcept,y1 - 1);
      g2D.drawLine(x1 - shiftOldConcept,centerY - 1,x2 - shiftOldConcept,centerY - 1);
      g2D.drawLine(x1 - shiftOldConcept,centerY,x2 - shiftOldConcept,centerY);
      g2D.drawLine(x1 - shiftOldConcept,centerY + 1,x2 - shiftOldConcept,centerY + 1);
      g2D.drawLine(x1 - 1 - shiftOldConcept,y2 + 1,x2 + 1 - shiftOldConcept,y2 + 1);
      g2D.drawLine(x1 - 1 - shiftOldConcept,y1 - 1,x1 - 1 - shiftOldConcept,y2 + 1);
      g2D.drawLine(centerX - 1 - shiftOldConcept,y1,centerX - 1 - shiftOldConcept,y2);
      g2D.drawLine(centerX - shiftOldConcept,y1,centerX - shiftOldConcept,y2);
      g2D.drawLine(centerX + 1 - shiftOldConcept,y1,centerX + 1 - shiftOldConcept,y2);
      g2D.drawLine(x2 + 1 - shiftOldConcept,y1 - 1,x2 + 1 - shiftOldConcept,y2 + 1);
    }
    g2D.drawLine(x1 - 1 + shiftCovered,y1 - 1,x2 + 1 + shiftCovered,y1 - 1);
    g2D.drawLine(x1 + shiftCovered,centerY - 1,x2 + shiftCovered,centerY - 1);
    g2D.drawLine(x1 + shiftCovered,centerY,x2 + shiftCovered,centerY);
    g2D.drawLine(x1 + shiftCovered,centerY + 1,x2 + shiftCovered,centerY + 1);
    g2D.drawLine(x1 - 1 + shiftCovered,y2 + 1,x2 + 1 + shiftCovered,y2 + 1);
    g2D.drawLine(x1 - 1 + shiftCovered,y1 - 1,x1 - 1 + shiftCovered,y2 + 1);
    g2D.drawLine(centerX - 1 + shiftCovered,y1,centerX - 1 + shiftCovered,y2);
    g2D.drawLine(centerX + shiftCovered,y1,centerX + shiftCovered,y2);
    g2D.drawLine(centerX + 1 + shiftCovered,y1,centerX + 1 + shiftCovered,y2);
    g2D.drawLine(x2 + 1 + shiftCovered,y1 - 1,x2 + 1 + shiftCovered,y2 + 1);
    if (coveredIndividualSize != model.getReasoner().getIndividuals(model.getCurrentConcept()).size()) {
      g2D.drawLine(x1 - 1 + shiftNewConcept,y1 - 1,x2 + 1 + shiftNewConcept,y1 - 1);
      g2D.drawLine(x1 + shiftNewConcept,centerY - 1,x2 + shiftNewConcept,centerY - 1);
      g2D.drawLine(x1 + shiftNewConcept,centerY,x2 + shiftNewConcept,centerY);
      g2D.drawLine(x1 + shiftNewConcept,centerY + 1,x2 + shiftNewConcept,centerY + 1);
      g2D.drawLine(x1 - 1 + shiftNewConcept,y2 + 1,x2 + 1 + shiftNewConcept,y2 + 1);
      g2D.drawLine(x1 - 1 + shiftNewConcept,y1 - 1,x1 - 1 + shiftNewConcept,y2 + 1);
      g2D.drawLine(centerX - 1 + shiftNewConcept,y1,centerX - 1 + shiftNewConcept,y2);
      g2D.drawLine(centerX + shiftNewConcept,y1,centerX + shiftNewConcept,y2);
      g2D.drawLine(centerX + 1 + shiftNewConcept,y1,centerX + 1 + shiftNewConcept,y2);
      g2D.drawLine(x2 + 1 + shiftNewConcept,y1 - 1,x2 + 1 + shiftNewConcept,y2 + 1);
    }
    if (((EvaluatedDescriptionClass)eval).getAddition() != 1.0 && ((EvaluatedDescriptionClass)eval).getCoverage() == 1.0) {
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY - 1 + shiftNewConcept,x2 + shiftNewConceptX,centerY - 1 + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY + shiftNewConcept,x2 + shiftNewConceptX,centerY + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY + 1 + shiftNewConcept,x2 + shiftNewConceptX,centerY + 1 + shiftNewConcept);
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x1 - 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
      g2D.drawLine(centerX - 1 + shiftNewConceptX,y1 + shiftNewConcept,centerX - 1 + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(centerX + shiftNewConceptX,y1 + shiftNewConcept,centerX + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(centerX + 1 + shiftNewConceptX,y1 + shiftNewConcept,centerX + 1 + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(x2 + 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
    }
    for (int i=0; i < posCovIndVector.size(); i++) {
      g2D.setColor(darkGreen);
      g2D.fill(posCovIndVector.get(i).getIndividualPoint());
    }
    for (int i=0; i < posNotCovIndVector.size(); i++) {
      g2D.setColor(darkRed);
      g2D.fill(posNotCovIndVector.get(i).getIndividualPoint());
    }
    for (int i=0; i < additionalIndividuals.size(); i++) {
      g2D.setColor(Color.BLACK);
      g2D.fill(additionalIndividuals.get(i).getIndividualPoint());
    }
    if (!((EvaluatedDescriptionClass)eval).isConsistent()) {
      g2D.setComposite(original);
      g2D.setColor(darkRed);
      g2D.drawString(""String_Node_Str"",0,220);
    }
    this.setVisible(true);
    panel.repaint();
  }
}"
9959,"/** 
 * This method renders the output for the detail panel.
 * @param desc selected description
 */
public void renderDetailPanel(EvaluatedDescription desc){
  accuracy.setVisible(false);
  accuracyText.setVisible(false);
  concept.setVisible(false);
  conceptText.setVisible(false);
  eval=desc;
  this.setInformation();
  p=new GraphicalCoveragePanel(eval,model,conceptText.getText(),this);
  p.setBounds(5,0,600,350);
  unsetEverything();
  conceptPanel.removeAll();
  conceptPanel.add(concept);
  conceptPanel.add(accuracy);
  conceptPanel.add(conceptText);
  conceptPanel.add(accuracyText);
  conceptPanel.setVisible(true);
  this.add(p);
  this.addPropertyChangeListener(handler);
  this.repaint();
}","/** 
 * This method renders the output for the detail panel.
 * @param desc selected description
 */
public void renderDetailPanel(EvaluatedDescription desc){
  accuracy.setVisible(false);
  accuracyText.setVisible(false);
  concept.setVisible(false);
  conceptText.setVisible(false);
  eval=desc;
  this.setInformation();
  p=new GraphicalCoveragePanel(eval,model,conceptText.getText(),this);
  p.setBounds(5,0,600,700);
  unsetEverything();
  conceptPanel.removeAll();
  conceptPanel.add(concept);
  conceptPanel.add(accuracy);
  conceptPanel.add(conceptText);
  conceptPanel.add(accuracyText);
  conceptPanel.setVisible(true);
  this.add(p);
  this.addPropertyChangeListener(handler);
  this.repaint();
}"
9960,"/** 
 * Constructor for the Option Panel. 
 */
public OptionPanel(){
  setPreferredSize(new Dimension(490,150));
  setLayout(null);
  minAccuracyLabel=new JLabel(""String_Node_Str"");
  minAccuracyLabel.setBounds(5,0,150,40);
  maxExecutionTimeLabel=new JLabel(""String_Node_Str"");
  maxExecutionTimeLabel.setBounds(5,60,150,40);
  nrOfConceptsLabel=new JLabel(""String_Node_Str"");
  nrOfConceptsLabel.setBounds(5,120,150,40);
  minAccuracy=new JSlider(0,50,5);
  minAccuracy.setPaintTicks(true);
  minAccuracy.setMajorTickSpacing(10);
  minAccuracy.setMinorTickSpacing(1);
  minAccuracy.setPaintLabels(true);
  minAccuracy.setBounds(200,0,200,40);
  maxExecutionTime=new JSlider(0,40,8);
  maxExecutionTime.setPaintTicks(true);
  maxExecutionTime.setMajorTickSpacing(10);
  maxExecutionTime.setMinorTickSpacing(1);
  maxExecutionTime.setPaintLabels(true);
  maxExecutionTime.setBounds(200,60,200,40);
  nrOfConcepts=new JSlider(2,20,10);
  nrOfConcepts.setPaintTicks(true);
  nrOfConcepts.setMajorTickSpacing(2);
  nrOfConcepts.setMinorTickSpacing(1);
  nrOfConcepts.setPaintLabels(true);
  nrOfConcepts.setBounds(200,120,200,40);
  add(minAccuracyLabel);
  add(minAccuracy);
  add(maxExecutionTimeLabel);
  add(maxExecutionTime);
  add(nrOfConceptsLabel);
  add(nrOfConcepts);
}","/** 
 * Constructor for the Option Panel. 
 */
public OptionPanel(){
  setLayout(new BorderLayout());
  labelPanel=new JPanel();
  labelPanel.setLayout(new GridLayout(0,1));
  sliderPanel=new JPanel();
  sliderPanel.setLayout(new GridLayout(0,1));
  minAccuracyLabel=new JLabel(""String_Node_Str"");
  maxExecutionTimeLabel=new JLabel(""String_Node_Str"");
  nrOfConceptsLabel=new JLabel(""String_Node_Str"");
  minAccuracy=new JSlider(0,50,5);
  minAccuracy.setPaintTicks(true);
  minAccuracy.setMajorTickSpacing(10);
  minAccuracy.setMinorTickSpacing(1);
  minAccuracy.setPaintLabels(true);
  maxExecutionTime=new JSlider(0,40,8);
  maxExecutionTime.setPaintTicks(true);
  maxExecutionTime.setMajorTickSpacing(10);
  maxExecutionTime.setMinorTickSpacing(1);
  maxExecutionTime.setPaintLabels(true);
  nrOfConcepts=new JSlider(2,20,10);
  nrOfConcepts.setPaintTicks(true);
  nrOfConcepts.setMajorTickSpacing(2);
  nrOfConcepts.setMinorTickSpacing(1);
  nrOfConcepts.setPaintLabels(true);
  labelPanel.add(minAccuracyLabel);
  labelPanel.add(maxExecutionTimeLabel);
  labelPanel.add(nrOfConceptsLabel);
  sliderPanel.add(minAccuracy);
  sliderPanel.add(maxExecutionTime);
  sliderPanel.add(nrOfConcepts);
  add(BorderLayout.WEST,labelPanel);
  add(BorderLayout.CENTER,sliderPanel);
}"
9961,"/** 
 * This method is called after the model for the suggest list is updated.
 * @param desc List model of descriptions made by the DL-Learner
 */
public void setSuggestList(DefaultListModel desc){
  descriptions.setModel(desc);
  repaint();
}","/** 
 * This method is called after the model for the suggest list is updated.
 * @param desc List model of descriptions made by the DL-Learner
 */
public void setSuggestList(DefaultListModel desc){
  descriptions.setModel(desc);
  descriptions.repaint();
  repaint();
}"
9962,"/** 
 * This is the constructor for the suggest panel. It creates a new Scroll panel and puts the Suggest List in it. 
 */
public SuggestClassPanel(){
  super();
  this.setPreferredSize(new Dimension(470,120));
  suggestScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  descriptions=new JList();
  descriptions.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  suggestPanel=new JPanel();
  descriptions.setVisible(true);
  suggestPanel.add(descriptions);
  suggestScroll.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  suggestScroll.setViewportView(descriptions);
  descriptions.setCellRenderer(new SuggestListCellRenderer());
  add(suggestScroll);
}","/** 
 * This is the constructor for the suggest panel. It creates a new Scroll panel and puts the Suggest List in it. 
 */
public SuggestClassPanel(){
  super();
  this.setLayout(new BorderLayout());
  suggestScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  descriptions=new JList();
  descriptions.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  suggestPanel=new JPanel();
  descriptions.setVisible(true);
  descriptions.setVisibleRowCount(6);
  descriptions.getPreferredScrollableViewportSize();
  suggestPanel.add(descriptions);
  suggestScroll.setViewportView(descriptions);
  descriptions.setCellRenderer(new SuggestListCellRenderer());
  add(BorderLayout.CENTER,suggestScroll);
}"
9963,"private boolean isDescriptionAllowed(Description description,OENode parentNode){
  if (isClassLearningProblem) {
    if (isEquivalenceProblem) {
      if (occursOnFirstLevel(description,classToDescribe)) {
        return false;
      }
    }
 else {
      TreeSet<Description> toTest=new TreeSet<Description>();
      toTest.add(classToDescribe);
      while (!toTest.isEmpty()) {
        Description d=toTest.pollFirst();
        if (occursOnFirstLevel(description,d)) {
          return false;
        }
        toTest.addAll(reasoner.getClassHierarchy().getSuperClasses(d));
      }
    }
  }
  if (parentNode != null && ConceptTransformation.getForallOccurences(description) > ConceptTransformation.getForallOccurences(parentNode.getDescription())) {
    SortedSet<PropertyContext> contexts=ConceptTransformation.getForallContexts(description);
    SortedSet<PropertyContext> parentContexts=ConceptTransformation.getForallContexts(parentNode.getDescription());
    contexts.removeAll(parentContexts);
    for (    PropertyContext context : contexts) {
      Description existentialContext=context.toExistentialContext();
      boolean fillerFound=false;
      for (      Individual instance : examples) {
        if (reasoner.hasType(existentialContext,instance)) {
          fillerFound=true;
          break;
        }
      }
      if (!fillerFound) {
        return false;
      }
    }
  }
  return true;
}","private boolean isDescriptionAllowed(Description description,OENode parentNode){
  if (isClassLearningProblem) {
    if (isEquivalenceProblem) {
      if (occursOnFirstLevel(description,classToDescribe)) {
        return false;
      }
    }
 else {
      TreeSet<Description> toTest=new TreeSet<Description>(descriptionComparator);
      toTest.add(classToDescribe);
      while (!toTest.isEmpty()) {
        Description d=toTest.pollFirst();
        if (occursOnFirstLevel(description,d)) {
          return false;
        }
        toTest.addAll(reasoner.getClassHierarchy().getSuperClasses(d));
      }
    }
  }
  if (parentNode != null && ConceptTransformation.getForallOccurences(description) > ConceptTransformation.getForallOccurences(parentNode.getDescription())) {
    SortedSet<PropertyContext> contexts=ConceptTransformation.getForallContexts(description);
    SortedSet<PropertyContext> parentContexts=ConceptTransformation.getForallContexts(parentNode.getDescription());
    contexts.removeAll(parentContexts);
    for (    PropertyContext context : contexts) {
      Description existentialContext=context.toExistentialContext();
      boolean fillerFound=false;
      for (      Individual instance : examples) {
        if (reasoner.hasType(existentialContext,instance)) {
          fillerFound=true;
          break;
        }
      }
      if (!fillerFound) {
        return false;
      }
    }
  }
  return true;
}"
9964,"public static int getForallOccurences(Description description){
  int count=0;
  if (description instanceof ObjectAllRestriction) {
    count++;
  }
  for (  Description child : description.getChildren()) {
    count+=getForallOccurences(child);
  }
  return count;
}","/** 
 * Counts occurrences of \forall in description.
 * @param description A description.
 * @return Number of \forall occurrences.
 */
public static int getForallOccurences(Description description){
  int count=0;
  if (description instanceof ObjectAllRestriction) {
    count++;
  }
  for (  Description child : description.getChildren()) {
    count+=getForallOccurences(child);
  }
  return count;
}"
9965,"private static SortedSet<PropertyContext> getForallContexts(Description description,PropertyContext currentContext){
  if (description instanceof Restriction) {
    ObjectProperty op=(ObjectProperty)((Restriction)description).getRestrictedPropertyExpression();
    currentContext.add(op);
    if (description instanceof ObjectAllRestriction) {
      TreeSet<PropertyContext> contexts=new TreeSet<PropertyContext>();
      contexts.add(currentContext);
      contexts.addAll(getForallContexts(description.getChild(0),currentContext));
      return contexts;
    }
 else {
      return getForallContexts(description.getChild(0),currentContext);
    }
  }
 else {
    TreeSet<PropertyContext> contexts=new TreeSet<PropertyContext>();
    for (    Description child : description.getChildren()) {
      contexts.addAll(getForallContexts(child,currentContext));
    }
    return contexts;
  }
}","private static SortedSet<PropertyContext> getForallContexts(Description description,PropertyContext currentContext){
  if (description instanceof Restriction) {
    Property op=(Property)((Restriction)description).getRestrictedPropertyExpression();
    if (op instanceof ObjectProperty) {
      currentContext.add((ObjectProperty)op);
      if (description instanceof ObjectAllRestriction) {
        TreeSet<PropertyContext> contexts=new TreeSet<PropertyContext>();
        contexts.add(currentContext);
        contexts.addAll(getForallContexts(description.getChild(0),currentContext));
        return contexts;
      }
 else {
        return getForallContexts(description.getChild(0),currentContext);
      }
    }
 else {
      return new TreeSet<PropertyContext>();
    }
  }
 else {
    TreeSet<PropertyContext> contexts=new TreeSet<PropertyContext>();
    for (    Description child : description.getChildren()) {
      contexts.addAll(getForallContexts(child,currentContext));
    }
    return contexts;
  }
}"
9966,"public void run(){
  model.setSuggestList(result);
  dm.clear();
  int i=0;
  for (  EvaluatedDescription eval : result) {
    Set<String> ont=model.getOntologyURIString();
    for (    String ontology : ont) {
      if (eval.getDescription().toString().contains(ontology)) {
        if (((EvaluatedDescriptionClass)eval).isConsistent()) {
          dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          break;
        }
 else {
          dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          view.setIsInconsistent(true);
          break;
        }
      }
    }
  }
  view.getSuggestClassPanel().setSuggestList(dm);
  view.getLearnerView().repaint();
}","public void run(){
  model.setSuggestList(result);
  dm.clear();
  int i=0;
  for (  EvaluatedDescription eval : result) {
    Set<String> ont=model.getOntologyURIString();
    for (    String ontology : ont) {
      if (eval.getDescription().toString().contains(ontology)) {
        if (((EvaluatedDescriptionClass)eval).isConsistent()) {
          dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          i++;
          break;
        }
 else {
          dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          view.setIsInconsistent(true);
          i++;
          break;
        }
      }
    }
  }
  view.getSuggestClassPanel().setSuggestList(dm);
  view.getLearnerView().repaint();
}"
9967,"/** 
 * When a Button is pressed this method select the right.
 * @param z ActionEvent
 */
public void actionPerformed(ActionEvent z){
  if (z.getActionCommand().equals(""String_Node_Str"") || z.getActionCommand().equals(""String_Node_Str"")) {
    model.setKnowledgeSource();
    model.setReasoner();
    model.setLearningProblem();
    model.setLearningAlgorithm();
    view.getRunButton().setEnabled(false);
    view.renderErrorMessage(""String_Node_Str"");
    retriever=new SuggestionRetriever();
    retriever.execute();
  }
  if (z.getActionCommand().equals(""String_Node_Str"")) {
    if (evaluatedDescription != null) {
      model.changeDLLearnerDescriptionsToOWLDescriptions(evaluatedDescription.getDescription());
    }
 else {
      model.changeDLLearnerDescriptionsToOWLDescriptions((Description)view.getSuggestClassPanel().getSuggestList().getSelectedValue());
    }
    String message=""String_Node_Str"";
    view.renderErrorMessage(message);
  }
  if (z.getActionCommand().equals(""String_Node_Str"")) {
    if (!toggled) {
      toggled=true;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
 else {
      toggled=false;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
  }
}","/** 
 * When a Button is pressed this method select the right.
 * @param z ActionEvent
 */
public void actionPerformed(ActionEvent z){
  if (z.getActionCommand().equals(""String_Node_Str"") || z.getActionCommand().equals(""String_Node_Str"")) {
    model.setKnowledgeSource();
    model.setLearningProblem();
    model.setLearningAlgorithm();
    view.getRunButton().setEnabled(false);
    view.renderErrorMessage(""String_Node_Str"");
    retriever=new SuggestionRetriever();
    retriever.execute();
  }
  if (z.getActionCommand().equals(""String_Node_Str"")) {
    if (evaluatedDescription != null) {
      model.changeDLLearnerDescriptionsToOWLDescriptions(evaluatedDescription.getDescription());
    }
 else {
      model.changeDLLearnerDescriptionsToOWLDescriptions((Description)view.getSuggestClassPanel().getSuggestList().getSelectedValue());
    }
    String message=""String_Node_Str"";
    view.renderErrorMessage(message);
  }
  if (z.getActionCommand().equals(""String_Node_Str"")) {
    if (!toggled) {
      toggled=true;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
 else {
      toggled=false;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
  }
}"
9968,"private void updateList(final List<? extends EvaluatedDescription> result){
  Runnable doUpdateList=new Runnable(){
    public void run(){
      model.setSuggestList(result);
      dm.clear();
      int i=0;
      for (      EvaluatedDescription eval : result) {
        Set<String> ont=model.getOntologyURIString();
        for (        String ontology : ont) {
          if (eval.getDescription().toString().contains(ontology)) {
            if (((EvaluatedDescriptionClass)eval).isConsistent()) {
              dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              break;
            }
 else {
              dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              view.setIsInconsistent(true);
              break;
            }
          }
        }
      }
      view.getSuggestClassPanel().setSuggestList(dm);
      view.getLearnerView().repaint();
    }
  }
;
  SwingUtilities.invokeLater(doUpdateList);
}","private void updateList(final List<? extends EvaluatedDescription> result){
  Runnable doUpdateList=new Runnable(){
    public void run(){
      model.setSuggestList(result);
      dm.clear();
      int i=0;
      for (      EvaluatedDescription eval : result) {
        Set<String> ont=model.getOntologyURIString();
        for (        String ontology : ont) {
          if (eval.getDescription().toString().contains(ontology)) {
            if (((EvaluatedDescriptionClass)eval).isConsistent()) {
              dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              i++;
              break;
            }
 else {
              dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              view.setIsInconsistent(true);
              i++;
              break;
            }
          }
        }
      }
      view.getSuggestClassPanel().setSuggestList(dm);
      view.getLearnerView().repaint();
    }
  }
;
  SwingUtilities.invokeLater(doUpdateList);
}"
9969,"/** 
 * This Method renders the view of the plugin.
 */
public void makeView(String label){
  run.setText(""String_Node_Str"" + label + ""String_Node_Str"");
  run.setPreferredSize(new Dimension(200,40));
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(detail);
  model.setID(label);
  runPanel.add(BorderLayout.WEST,run);
  runPanel.add(BorderLayout.EAST,wikiPane);
  run.setEnabled(false);
  c.anchor=GridBagConstraints.FIRST_LINE_START;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=0;
  c.gridwidth=3;
  learner.add(runPanel,c);
  sugPanel.setSuggestList(new DefaultListModel());
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=1;
  c.weightx=1.0;
  c.weighty=1.0;
  c.gridwidth=2;
  sugPanel.setSuggestList(model.getSuggestModel());
  learner.add(sugPanel,c);
  accept.setEnabled(false);
  c.gridx=2;
  c.gridy=1;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=1;
  addButtonPanel.add(""String_Node_Str"",accept);
  learner.add(addButtonPanel,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.gridx=0;
  c.gridy=2;
  learner.add(hint,c);
  advancedPanel.add(advanced);
  advancedPanel.add(adv);
  advanced.setIcon(icon);
  advanced.setSelected(false);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=3;
  learner.add(advancedPanel,c);
  posPanel.setVisible(false);
  c.fill=GridBagConstraints.BOTH;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridheight=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.gridy=4;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=3;
  learner.add(posPanel,c);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  detail.setVisible(false);
  hint.setText(""String_Node_Str"");
  isInconsistent=false;
  readThread=new ReadingOntologyThread(editorKit,this,model);
  readThread.start();
  hint.setVisible(true);
  action.resetToggled();
  detail.setVisible(true);
  sugPanel.setVisible(true);
  learnerScroll.setViewportView(learner);
  this.renderErrorMessage(""String_Node_Str"");
}","/** 
 * This Method renders the view of the plugin.
 */
public void makeView(String label){
  run.setText(""String_Node_Str"" + label + ""String_Node_Str"");
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(detail);
  model.setID(label);
  runPanel.add(BorderLayout.WEST,run);
  runPanel.add(BorderLayout.EAST,wikiPane);
  run.setEnabled(false);
  c.anchor=GridBagConstraints.FIRST_LINE_START;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=0;
  c.gridwidth=3;
  learner.add(runPanel,c);
  sugPanel.setSuggestList(new DefaultListModel());
  c.fill=GridBagConstraints.BOTH;
  c.gridx=0;
  c.gridy=1;
  c.weightx=1.0;
  c.weighty=1.0;
  c.gridwidth=2;
  sugPanel.setSuggestList(model.getSuggestModel());
  learner.add(sugPanel,c);
  accept.setEnabled(false);
  c.gridx=2;
  c.gridy=1;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=1;
  addButtonPanel.add(""String_Node_Str"",accept);
  learner.add(addButtonPanel,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.gridx=0;
  c.gridy=2;
  learner.add(hint,c);
  advancedPanel.add(advanced);
  advancedPanel.add(adv);
  advanced.setIcon(icon);
  advanced.setSelected(false);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridy=3;
  learner.add(advancedPanel,c);
  posPanel.setVisible(false);
  c.fill=GridBagConstraints.BOTH;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridheight=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.gridy=4;
  c.weightx=0.0;
  c.weighty=0.0;
  c.gridwidth=3;
  learner.add(posPanel,c);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  detail.setVisible(false);
  hint.setText(""String_Node_Str"");
  isInconsistent=false;
  readThread=new ReadingOntologyThread(editorKit,this,model);
  readThread.start();
  hint.setVisible(true);
  action.resetToggled();
  detail.setVisible(true);
  sugPanel.setVisible(true);
  learnerScroll.setViewportView(learner);
  this.renderErrorMessage(""String_Node_Str"");
}"
9970,"/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 * @param label String
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel();
  learnerPanel=new JPanel();
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  sugPanel.addSuggestPanelMouseListener(action);
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.setPreferredSize(new Dimension(485,30));
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(220,50));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}","/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 * @param label String
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel();
  learnerPanel=new JPanel();
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  advancedPanel=new JPanel();
  run=new JButton();
  runPanel=new JPanel(new FlowLayout());
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  sugPanel.addSuggestPanelMouseListener(action);
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  hint.setPreferredSize(new Dimension(485,30));
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(70,40));
  run.setPreferredSize(new Dimension(260,30));
  advanced.setName(""String_Node_Str"");
  model.initReasoner();
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}"
9971,"/** 
 * This is the constructor for the GraphicalCoveragePanel.
 * @param desc EvaluatedDescription
 * @param m DLLearnerModel
 * @param concept String
 * @param p MoreDetailForSuggestedConceptsPanel
 */
public GraphicalCoveragePanel(EvaluatedDescription desc,DLLearnerModel m,String concept,MoreDetailForSuggestedConceptsPanel p){
  this.setVisible(false);
  this.setForeground(Color.GREEN);
  this.setPreferredSize(new Dimension(500,230));
  eval=desc;
  model=m;
  panel=p;
  this.repaint();
  id=model.getID();
  darkGreen=new Color(0,100,0);
  darkRed=new Color(205,0,0);
  random=new Random();
  conceptNew=concept;
  conceptVector=new Vector<String>();
  posCovIndVector=new Vector<IndividualPoint>();
  posNotCovIndVector=new Vector<IndividualPoint>();
  additionalIndividuals=new Vector<IndividualPoint>();
  points=new Vector<IndividualPoint>();
  this.computeGraphics(0,0);
  handler=new GraphicalCoveragePanelHandler(this,desc,model);
  if (shiftXAxis == 0) {
    oldConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + (2 * adjustment) + 3,ELLIPSE_Y_AXIS + 3,WIDTH,HEIGHT);
  }
 else {
    oldConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + (2 * adjustment),ELLIPSE_Y_AXIS,WIDTH,HEIGHT);
  }
  if (shiftXAxis == 0) {
    newConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + shiftXAxis + adjustment,ELLIPSE_Y_AXIS,WIDTH + distortionOld + 6,HEIGHT + distortionOld + 6);
  }
 else {
    newConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + shiftXAxis + adjustment,ELLIPSE_Y_AXIS,WIDTH + distortionOld,HEIGHT + distortionOld);
  }
  this.computeIndividualPoints(300);
  this.addMouseMotionListener(handler);
  this.addMouseListener(handler);
}","/** 
 * This is the constructor for the GraphicalCoveragePanel.
 * @param desc EvaluatedDescription
 * @param m DLLearnerModel
 * @param concept String
 * @param p MoreDetailForSuggestedConceptsPanel
 */
public GraphicalCoveragePanel(EvaluatedDescription desc,DLLearnerModel m,String concept,MoreDetailForSuggestedConceptsPanel p){
  this.setVisible(false);
  this.setForeground(Color.GREEN);
  this.setPreferredSize(new Dimension(540,230));
  eval=desc;
  model=m;
  panel=p;
  this.repaint();
  id=model.getID();
  darkGreen=new Color(0,100,0);
  darkRed=new Color(205,0,0);
  random=new Random();
  conceptNew=concept;
  conceptVector=new Vector<String>();
  posCovIndVector=new Vector<IndividualPoint>();
  posNotCovIndVector=new Vector<IndividualPoint>();
  additionalIndividuals=new Vector<IndividualPoint>();
  points=new Vector<IndividualPoint>();
  this.computeGraphics(0,0);
  handler=new GraphicalCoveragePanelHandler(this,desc,model);
  if (shiftXAxis == 0) {
    oldConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + (2 * adjustment) + 3,ELLIPSE_Y_AXIS + 3,WIDTH,HEIGHT);
  }
 else {
    oldConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + (2 * adjustment),ELLIPSE_Y_AXIS,WIDTH,HEIGHT);
  }
  if (shiftXAxis == 0) {
    newConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + shiftXAxis + adjustment,ELLIPSE_Y_AXIS,WIDTH + distortionOld + 6,HEIGHT + distortionOld + 6);
  }
 else {
    newConcept=new Ellipse2D.Double(ELLIPSE_X_AXIS + shiftXAxis + adjustment,ELLIPSE_Y_AXIS,WIDTH + distortionOld,HEIGHT + distortionOld);
  }
  this.computeIndividualPoints(300);
  this.addMouseMotionListener(handler);
  this.addMouseListener(handler);
}"
9972,"@Override protected void paintComponent(Graphics g){
  if (eval != null) {
    Graphics2D g2D;
    g2D=(Graphics2D)g;
    Composite original=g2D.getComposite();
    AlphaComposite ac=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.5f);
    g2D.setColor(Color.BLACK);
    g2D.drawString(model.getOldConceptOWLAPI().toString(),320,10);
    g2D.setColor(Color.ORANGE);
    g2D.fillOval(310,20,9,9);
    g2D.setColor(Color.black);
    int p=30;
    for (int i=0; i < conceptVector.size(); i++) {
      g2D.drawString(conceptVector.get(i),320,p);
      p=p + 20;
    }
    g2D.setColor(darkGreen);
    Ellipse2D circlePoint=new Ellipse2D.Double(315 - 1,p - 6,3,3);
    g2D.fill(circlePoint);
    g2D.setColor(Color.BLACK);
    g2D.drawString(""String_Node_Str"",320,p);
    g2D.setColor(Color.ORANGE);
    g2D.fillOval(445,p - 9,9,9);
    g2D.setColor(Color.BLACK);
    g2D.drawString(""String_Node_Str"",460,p);
    g2D.setColor(Color.YELLOW);
    g2D.fillOval(490,p - 9,9,9);
    p=p + 20;
    if (id.equals(EQUI_STRING)) {
      g2D.setColor(darkRed);
      Ellipse2D circlePoint2=new Ellipse2D.Double(315 - 1,p - 6,3,3);
      g2D.fill(circlePoint2);
      g2D.setColor(Color.BLACK);
      g2D.drawString(""String_Node_Str"",320,p);
      g2D.setColor(Color.ORANGE);
      g2D.fillOval(445,p - 9,9,9);
      p=p + 20;
      g2D.setColor(darkRed);
      Ellipse2D circlePoint3=new Ellipse2D.Double(315 - 1,p - 6,3,3);
      g2D.fill(circlePoint3);
      g2D.setColor(Color.BLACK);
      g2D.drawString(""String_Node_Str"",320,p);
      g2D.setColor(Color.YELLOW);
      g2D.fillOval(445,p - 9,9,9);
    }
 else {
      g2D.setColor(Color.BLACK);
      Ellipse2D circlePoint2=new Ellipse2D.Double(315 - 1,p - 6,3,3);
      g2D.fill(circlePoint2);
      g2D.drawString(""String_Node_Str"",320,p);
      g2D.setColor(Color.ORANGE);
      g2D.fillOval(445,p - 9,9,9);
      p=p + 20;
      g2D.setColor(darkRed);
      Ellipse2D circlePoint3=new Ellipse2D.Double(315 - 1,p - 6,3,3);
      g2D.fill(circlePoint3);
      g2D.setColor(Color.BLACK);
      g2D.drawString(""String_Node_Str"",320,p);
      g2D.setColor(Color.YELLOW);
      g2D.fillOval(445,p - 9,9,9);
    }
    g2D.setColor(Color.YELLOW);
    g2D.fill(oldConcept);
    g2D.fillOval(310,0,9,9);
    g2D.setColor(Color.ORANGE);
    g2D.setComposite(ac);
    g2D.fill(newConcept);
    g2D.setColor(Color.BLACK);
    if (coveredIndividualSize != model.getReasoner().getIndividuals(model.getCurrentConcept()).size() && coveredIndividualSize != 0) {
      g2D.drawLine(x1 - 1 - shiftOldConcept,y1 - 1,x2 + 1 - shiftOldConcept,y1 - 1);
      g2D.drawLine(x1 - shiftOldConcept,centerY - 1,x2 - shiftOldConcept,centerY - 1);
      g2D.drawLine(x1 - shiftOldConcept,centerY,x2 - shiftOldConcept,centerY);
      g2D.drawLine(x1 - shiftOldConcept,centerY + 1,x2 - shiftOldConcept,centerY + 1);
      g2D.drawLine(x1 - 1 - shiftOldConcept,y2 + 1,x2 + 1 - shiftOldConcept,y2 + 1);
      g2D.drawLine(x1 - 1 - shiftOldConcept,y1 - 1,x1 - 1 - shiftOldConcept,y2 + 1);
      g2D.drawLine(centerX - 1 - shiftOldConcept,y1,centerX - 1 - shiftOldConcept,y2);
      g2D.drawLine(centerX - shiftOldConcept,y1,centerX - shiftOldConcept,y2);
      g2D.drawLine(centerX + 1 - shiftOldConcept,y1,centerX + 1 - shiftOldConcept,y2);
      g2D.drawLine(x2 + 1 - shiftOldConcept,y1 - 1,x2 + 1 - shiftOldConcept,y2 + 1);
    }
    g2D.drawLine(x1 - 1 + shiftCovered,y1 - 1,x2 + 1 + shiftCovered,y1 - 1);
    g2D.drawLine(x1 + shiftCovered,centerY - 1,x2 + shiftCovered,centerY - 1);
    g2D.drawLine(x1 + shiftCovered,centerY,x2 + shiftCovered,centerY);
    g2D.drawLine(x1 + shiftCovered,centerY + 1,x2 + shiftCovered,centerY + 1);
    g2D.drawLine(x1 - 1 + shiftCovered,y2 + 1,x2 + 1 + shiftCovered,y2 + 1);
    g2D.drawLine(x1 - 1 + shiftCovered,y1 - 1,x1 - 1 + shiftCovered,y2 + 1);
    g2D.drawLine(centerX - 1 + shiftCovered,y1,centerX - 1 + shiftCovered,y2);
    g2D.drawLine(centerX + shiftCovered,y1,centerX + shiftCovered,y2);
    g2D.drawLine(centerX + 1 + shiftCovered,y1,centerX + 1 + shiftCovered,y2);
    g2D.drawLine(x2 + 1 + shiftCovered,y1 - 1,x2 + 1 + shiftCovered,y2 + 1);
    if (coveredIndividualSize != model.getReasoner().getIndividuals(model.getCurrentConcept()).size()) {
      g2D.drawLine(x1 - 1 + shiftNewConcept,y1 - 1,x2 + 1 + shiftNewConcept,y1 - 1);
      g2D.drawLine(x1 + shiftNewConcept,centerY - 1,x2 + shiftNewConcept,centerY - 1);
      g2D.drawLine(x1 + shiftNewConcept,centerY,x2 + shiftNewConcept,centerY);
      g2D.drawLine(x1 + shiftNewConcept,centerY + 1,x2 + shiftNewConcept,centerY + 1);
      g2D.drawLine(x1 - 1 + shiftNewConcept,y2 + 1,x2 + 1 + shiftNewConcept,y2 + 1);
      g2D.drawLine(x1 - 1 + shiftNewConcept,y1 - 1,x1 - 1 + shiftNewConcept,y2 + 1);
      g2D.drawLine(centerX - 1 + shiftNewConcept,y1,centerX - 1 + shiftNewConcept,y2);
      g2D.drawLine(centerX + shiftNewConcept,y1,centerX + shiftNewConcept,y2);
      g2D.drawLine(centerX + 1 + shiftNewConcept,y1,centerX + 1 + shiftNewConcept,y2);
      g2D.drawLine(x2 + 1 + shiftNewConcept,y1 - 1,x2 + 1 + shiftNewConcept,y2 + 1);
    }
    if (((EvaluatedDescriptionClass)eval).getAddition() != 1.0 && ((EvaluatedDescriptionClass)eval).getCoverage() == 1.0) {
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY - 1 + shiftNewConcept,x2 + shiftNewConceptX,centerY - 1 + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY + shiftNewConcept,x2 + shiftNewConceptX,centerY + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY + 1 + shiftNewConcept,x2 + shiftNewConceptX,centerY + 1 + shiftNewConcept);
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x1 - 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
      g2D.drawLine(centerX - 1 + shiftNewConceptX,y1 + shiftNewConcept,centerX - 1 + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(centerX + shiftNewConceptX,y1 + shiftNewConcept,centerX + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(centerX + 1 + shiftNewConceptX,y1 + shiftNewConcept,centerX + 1 + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(x2 + 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
    }
    for (int i=0; i < posCovIndVector.size(); i++) {
      g2D.setColor(darkGreen);
      g2D.fill(posCovIndVector.get(i).getIndividualPoint());
    }
    for (int i=0; i < posNotCovIndVector.size(); i++) {
      g2D.setColor(darkRed);
      g2D.fill(posNotCovIndVector.get(i).getIndividualPoint());
    }
    for (int i=0; i < additionalIndividuals.size(); i++) {
      g2D.setColor(Color.BLACK);
      g2D.fill(additionalIndividuals.get(i).getIndividualPoint());
    }
    if (!((EvaluatedDescriptionClass)eval).isConsistent()) {
      g2D.setComposite(original);
      g2D.setColor(darkRed);
      g2D.drawString(""String_Node_Str"",0,220);
    }
    this.setVisible(true);
    panel.repaint();
  }
}","@Override protected void paintComponent(Graphics g){
  if (eval != null) {
    Graphics2D g2D;
    g2D=(Graphics2D)g;
    Composite original=g2D.getComposite();
    AlphaComposite ac=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.5f);
    g2D.setColor(Color.BLACK);
    g2D.drawString(model.getOldConceptOWLAPI().toString(),320,10);
    g2D.setColor(Color.ORANGE);
    g2D.fillOval(310,20,9,9);
    g2D.setColor(Color.black);
    int p=30;
    for (int i=0; i < conceptVector.size(); i++) {
      g2D.drawString(conceptVector.get(i),320,p);
      p=p + 20;
    }
    g2D.setColor(darkGreen);
    Ellipse2D circlePoint=new Ellipse2D.Double(315 - 1,p - 6,4,4);
    g2D.fill(circlePoint);
    g2D.setColor(Color.BLACK);
    g2D.drawString(""String_Node_Str"",320,p);
    g2D.setColor(Color.ORANGE);
    g2D.fillOval(455,p - 9,9,9);
    g2D.setColor(Color.BLACK);
    g2D.drawString(""String_Node_Str"",485,p);
    g2D.setColor(Color.YELLOW);
    g2D.fillOval(525,p - 9,9,9);
    g2D.setColor(Color.BLACK);
    p=p + 20;
    g2D.drawString(""String_Node_Str"",320,p);
    p=p + 20;
    if (id.equals(EQUI_STRING)) {
      g2D.setColor(darkRed);
      Ellipse2D circlePoint2=new Ellipse2D.Double(315 - 1,p - 6,4,4);
      g2D.fill(circlePoint2);
      g2D.setColor(Color.BLACK);
      g2D.drawString(""String_Node_Str"",320,p);
      g2D.setColor(Color.ORANGE);
      g2D.fillOval(455,p - 9,9,9);
      g2D.setColor(Color.BLACK);
      p=p + 20;
      g2D.drawString(""String_Node_Str"",320,p);
      p=p + 20;
      g2D.setColor(darkRed);
      Ellipse2D circlePoint3=new Ellipse2D.Double(315 - 1,p - 6,4,4);
      g2D.fill(circlePoint3);
      g2D.setColor(Color.BLACK);
      g2D.drawString(""String_Node_Str"",320,p);
      g2D.setColor(Color.YELLOW);
      g2D.fillOval(455,p - 9,9,9);
      g2D.setColor(Color.BLACK);
      p=p + 20;
      g2D.drawString(""String_Node_Str"",320,p);
    }
 else {
      g2D.setColor(Color.BLACK);
      Ellipse2D circlePoint2=new Ellipse2D.Double(315 - 1,p - 6,4,4);
      g2D.fill(circlePoint2);
      g2D.drawString(""String_Node_Str"",320,p);
      g2D.setColor(Color.ORANGE);
      g2D.fillOval(455,p - 9,9,9);
      g2D.setColor(Color.BLACK);
      p=p + 20;
      g2D.drawString(""String_Node_Str"",320,p);
      p=p + 20;
      g2D.setColor(darkRed);
      Ellipse2D circlePoint3=new Ellipse2D.Double(315 - 1,p - 6,4,4);
      g2D.fill(circlePoint3);
      g2D.setColor(Color.BLACK);
      g2D.drawString(""String_Node_Str"",320,p);
      g2D.setColor(Color.YELLOW);
      g2D.fillOval(455,p - 9,9,9);
      g2D.setColor(Color.BLACK);
      p=p + 20;
      g2D.drawString(""String_Node_Str"",320,p);
    }
    g2D.setColor(Color.YELLOW);
    g2D.fill(oldConcept);
    g2D.fillOval(310,0,9,9);
    g2D.setColor(Color.ORANGE);
    g2D.setComposite(ac);
    g2D.fill(newConcept);
    g2D.setColor(Color.BLACK);
    if (coveredIndividualSize != model.getReasoner().getIndividuals(model.getCurrentConcept()).size() && notCoveredInd != 0) {
      g2D.drawLine(x1 - 1 - shiftOldConcept,y1 - 1,x2 + 1 - shiftOldConcept,y1 - 1);
      g2D.drawLine(x1 - shiftOldConcept,centerY - 1,x2 - shiftOldConcept,centerY - 1);
      g2D.drawLine(x1 - shiftOldConcept,centerY,x2 - shiftOldConcept,centerY);
      g2D.drawLine(x1 - shiftOldConcept,centerY + 1,x2 - shiftOldConcept,centerY + 1);
      g2D.drawLine(x1 - 1 - shiftOldConcept,y2 + 1,x2 + 1 - shiftOldConcept,y2 + 1);
      g2D.drawLine(x1 - 1 - shiftOldConcept,y1 - 1,x1 - 1 - shiftOldConcept,y2 + 1);
      g2D.drawLine(centerX - 1 - shiftOldConcept,y1,centerX - 1 - shiftOldConcept,y2);
      g2D.drawLine(centerX - shiftOldConcept,y1,centerX - shiftOldConcept,y2);
      g2D.drawLine(centerX + 1 - shiftOldConcept,y1,centerX + 1 - shiftOldConcept,y2);
      g2D.drawLine(x2 + 1 - shiftOldConcept,y1 - 1,x2 + 1 - shiftOldConcept,y2 + 1);
    }
    g2D.drawLine(x1 - 1 + shiftCovered,y1 - 1,x2 + 1 + shiftCovered,y1 - 1);
    g2D.drawLine(x1 + shiftCovered,centerY - 1,x2 + shiftCovered,centerY - 1);
    g2D.drawLine(x1 + shiftCovered,centerY,x2 + shiftCovered,centerY);
    g2D.drawLine(x1 + shiftCovered,centerY + 1,x2 + shiftCovered,centerY + 1);
    g2D.drawLine(x1 - 1 + shiftCovered,y2 + 1,x2 + 1 + shiftCovered,y2 + 1);
    g2D.drawLine(x1 - 1 + shiftCovered,y1 - 1,x1 - 1 + shiftCovered,y2 + 1);
    g2D.drawLine(centerX - 1 + shiftCovered,y1,centerX - 1 + shiftCovered,y2);
    g2D.drawLine(centerX + shiftCovered,y1,centerX + shiftCovered,y2);
    g2D.drawLine(centerX + 1 + shiftCovered,y1,centerX + 1 + shiftCovered,y2);
    g2D.drawLine(x2 + 1 + shiftCovered,y1 - 1,x2 + 1 + shiftCovered,y2 + 1);
    if (coveredIndividualSize != model.getReasoner().getIndividuals(model.getCurrentConcept()).size() && ((EvaluatedDescriptionClass)eval).getAdditionalInstances().size() != 0) {
      g2D.drawLine(x1 - 1 + shiftNewConcept,y1 - 1,x2 + 1 + shiftNewConcept,y1 - 1);
      g2D.drawLine(x1 + shiftNewConcept,centerY - 1,x2 + shiftNewConcept,centerY - 1);
      g2D.drawLine(x1 + shiftNewConcept,centerY,x2 + shiftNewConcept,centerY);
      g2D.drawLine(x1 + shiftNewConcept,centerY + 1,x2 + shiftNewConcept,centerY + 1);
      g2D.drawLine(x1 - 1 + shiftNewConcept,y2 + 1,x2 + 1 + shiftNewConcept,y2 + 1);
      g2D.drawLine(x1 - 1 + shiftNewConcept,y1 - 1,x1 - 1 + shiftNewConcept,y2 + 1);
      g2D.drawLine(centerX - 1 + shiftNewConcept,y1,centerX - 1 + shiftNewConcept,y2);
      g2D.drawLine(centerX + shiftNewConcept,y1,centerX + shiftNewConcept,y2);
      g2D.drawLine(centerX + 1 + shiftNewConcept,y1,centerX + 1 + shiftNewConcept,y2);
      g2D.drawLine(x2 + 1 + shiftNewConcept,y1 - 1,x2 + 1 + shiftNewConcept,y2 + 1);
    }
    if (((EvaluatedDescriptionClass)eval).getAddition() != 1.0 && ((EvaluatedDescriptionClass)eval).getCoverage() == 1.0) {
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY - 1 + shiftNewConcept,x2 + shiftNewConceptX,centerY - 1 + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY + shiftNewConcept,x2 + shiftNewConceptX,centerY + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY + 1 + shiftNewConcept,x2 + shiftNewConceptX,centerY + 1 + shiftNewConcept);
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x1 - 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
      g2D.drawLine(centerX - 1 + shiftNewConceptX,y1 + shiftNewConcept,centerX - 1 + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(centerX + shiftNewConceptX,y1 + shiftNewConcept,centerX + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(centerX + 1 + shiftNewConceptX,y1 + shiftNewConcept,centerX + 1 + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(x2 + 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
    }
    for (int i=0; i < posCovIndVector.size(); i++) {
      g2D.setColor(darkGreen);
      g2D.fill(posCovIndVector.get(i).getIndividualPoint());
    }
    for (int i=0; i < posNotCovIndVector.size(); i++) {
      g2D.setColor(darkRed);
      g2D.fill(posNotCovIndVector.get(i).getIndividualPoint());
    }
    for (int i=0; i < additionalIndividuals.size(); i++) {
      g2D.setColor(Color.BLACK);
      g2D.fill(additionalIndividuals.get(i).getIndividualPoint());
    }
    if (!((EvaluatedDescriptionClass)eval).isConsistent()) {
      g2D.setComposite(original);
      g2D.setColor(darkRed);
      g2D.drawString(""String_Node_Str"",0,220);
    }
    if (eval.getAccuracy() == 1.0) {
      g2D.setComposite(original);
      g2D.setColor(Color.ORANGE);
      g2D.fillOval(0,211,9,9);
      g2D.setColor(darkRed);
      g2D.drawString(""String_Node_Str"",25,220);
      g2D.setColor(Color.YELLOW);
      g2D.fillOval(65,211,9,9);
      g2D.setColor(darkRed);
      g2D.drawString(""String_Node_Str"",95,220);
    }
    this.setVisible(true);
    panel.repaint();
  }
}"
9973,"private void computeIndividualPoints(int n){
  if (eval != null) {
    Set<Individual> posInd=((EvaluatedDescriptionClass)eval).getCoveredInstances();
    int i=0;
    double x=random.nextInt(n);
    double y=random.nextInt(n);
    boolean flag=true;
    for (    Individual ind : posInd) {
      flag=true;
      if (i < MAX_NUMBER_OF_INDIVIDUAL_POINTS) {
        while (flag) {
          if (newConcept.contains(x,y) && oldConcept.contains(x,y) && !(x >= this.getX1() + this.getShiftCovered() && x <= this.getX2() + this.getShiftCovered() && y >= this.getY1() && y <= this.getY2())) {
            Set<String> uriString=model.getOntologyURIString();
            for (            String uri : uriString) {
              if (ind.toString().contains(uri)) {
                posCovIndVector.add(new IndividualPoint(""String_Node_Str"",(int)x,(int)y,ind.toManchesterSyntaxString(uri,null)));
              }
            }
            i++;
            flag=false;
            x=random.nextInt(n);
            y=random.nextInt(n);
            break;
          }
 else {
            x=random.nextInt(n);
            y=random.nextInt(n);
          }
        }
      }
    }
    Set<Individual> posNotCovInd=((EvaluatedDescriptionClass)eval).getAdditionalInstances();
    int j=0;
    x=random.nextInt(n);
    y=random.nextInt(n);
    for (    Individual ind : posNotCovInd) {
      flag=true;
      if (j < MAX_NUMBER_OF_INDIVIDUAL_POINTS) {
        while (flag) {
          if (!oldConcept.contains(x,y) && newConcept.contains(x,y) && !(x >= this.getX1() + this.getShiftNewConcept() && x <= this.getX2() + this.getShiftNewConcept() && y >= this.getY1() && y <= this.getY2())&& !(x >= this.getX1() + this.getShiftNewConceptX() && x <= this.getX2() + this.getShiftNewConceptX() && y >= this.getY1() + this.getShiftNewConcept() && y <= this.getY2() + this.getShiftNewConcept())) {
            if (id.equals(EQUI_STRING)) {
              Set<String> uriString=model.getOntologyURIString();
              for (              String uri : uriString) {
                if (ind.toString().contains(uri)) {
                  posNotCovIndVector.add(new IndividualPoint(""String_Node_Str"",(int)x,(int)y,ind.toManchesterSyntaxString(uri,null)));
                }
              }
            }
 else {
              Set<String> uriString=model.getOntologyURIString();
              for (              String uri : uriString) {
                if (ind.toString().contains(uri)) {
                  additionalIndividuals.add(new IndividualPoint(""String_Node_Str"",(int)x,(int)y,ind.toManchesterSyntaxString(uri,null)));
                }
              }
            }
            j++;
            flag=false;
            x=random.nextInt(n);
            y=random.nextInt(n);
            break;
          }
 else {
            x=random.nextInt(n);
            y=random.nextInt(n);
          }
        }
      }
    }
    Set<Individual> notCovInd=model.getReasoner().getIndividuals(model.getCurrentConcept());
    notCovInd.removeAll(posInd);
    int k=0;
    x=random.nextInt(n);
    y=random.nextInt(n);
    for (    Individual ind : notCovInd) {
      flag=true;
      if (k < MAX_NUMBER_OF_INDIVIDUAL_POINTS) {
        while (flag) {
          if (oldConcept.contains(x,y) && !newConcept.contains(x,y) && !(x >= this.getX1() - this.getShiftOldConcept() && x <= this.getX2() - this.getShiftOldConcept() && y >= this.getY1() && y <= this.getY2())) {
            Set<String> uriString=model.getOntologyURIString();
            for (            String uri : uriString) {
              if (ind.toString().contains(uri)) {
                posNotCovIndVector.add(new IndividualPoint(""String_Node_Str"",(int)x,(int)y,ind.toManchesterSyntaxString(uri,null)));
              }
            }
            k++;
            flag=false;
            x=random.nextInt(n);
            y=random.nextInt(n);
            break;
          }
 else {
            x=random.nextInt(n);
            y=random.nextInt(n);
          }
        }
      }
    }
    points.addAll(posCovIndVector);
    points.addAll(posNotCovIndVector);
    points.addAll(additionalIndividuals);
  }
}","private void computeIndividualPoints(int n){
  if (eval != null) {
    Set<Individual> posInd=((EvaluatedDescriptionClass)eval).getCoveredInstances();
    int i=0;
    double x=random.nextInt(n);
    double y=random.nextInt(n);
    boolean flag=true;
    for (    Individual ind : posInd) {
      flag=true;
      if (i < MAX_NUMBER_OF_INDIVIDUAL_POINTS) {
        while (flag) {
          if (newConcept.contains(x,y) && oldConcept.contains(x,y) && !(x >= this.getX1() + this.getShiftCovered() && x <= this.getX2() + this.getShiftCovered() && y >= this.getY1() && y <= this.getY2())) {
            Set<String> uriString=model.getOntologyURIString();
            for (            String uri : uriString) {
              if (ind.toString().contains(uri)) {
                posCovIndVector.add(new IndividualPoint(""String_Node_Str"",(int)x,(int)y,ind.toManchesterSyntaxString(uri,null)));
              }
            }
            i++;
            flag=false;
            x=random.nextInt(n);
            y=random.nextInt(n);
            break;
          }
 else {
            x=random.nextInt(n);
            y=random.nextInt(n);
          }
        }
      }
    }
    Set<Individual> posNotCovInd=((EvaluatedDescriptionClass)eval).getAdditionalInstances();
    int j=0;
    x=random.nextInt(n);
    y=random.nextInt(n);
    for (    Individual ind : posNotCovInd) {
      flag=true;
      if (j < MAX_NUMBER_OF_INDIVIDUAL_POINTS) {
        while (flag) {
          if (!oldConcept.contains(x,y) && newConcept.contains(x,y) && !(x >= this.getX1() + this.getShiftNewConcept() && x <= this.getX2() + this.getShiftNewConcept() && y >= this.getY1() && y <= this.getY2())&& !(x >= this.getX1() + this.getShiftNewConceptX() && x <= this.getX2() + this.getShiftNewConceptX() && y >= this.getY1() + this.getShiftNewConcept() && y <= this.getY2() + this.getShiftNewConcept())) {
            if (id.equals(EQUI_STRING)) {
              Set<String> uriString=model.getOntologyURIString();
              for (              String uri : uriString) {
                if (ind.toString().contains(uri)) {
                  posNotCovIndVector.add(new IndividualPoint(""String_Node_Str"",(int)x,(int)y,ind.toManchesterSyntaxString(uri,null)));
                }
              }
            }
 else {
              Set<String> uriString=model.getOntologyURIString();
              for (              String uri : uriString) {
                if (ind.toString().contains(uri)) {
                  additionalIndividuals.add(new IndividualPoint(""String_Node_Str"",(int)x,(int)y,ind.toManchesterSyntaxString(uri,null)));
                }
              }
            }
            j++;
            flag=false;
            x=random.nextInt(n);
            y=random.nextInt(n);
            break;
          }
 else {
            x=random.nextInt(n);
            y=random.nextInt(n);
          }
        }
      }
    }
    Set<Individual> notCovInd=model.getReasoner().getIndividuals(model.getCurrentConcept());
    notCovInd.removeAll(posInd);
    notCoveredInd=notCovInd.size();
    int k=0;
    x=random.nextInt(n);
    y=random.nextInt(n);
    for (    Individual ind : notCovInd) {
      flag=true;
      if (k < MAX_NUMBER_OF_INDIVIDUAL_POINTS) {
        while (flag) {
          if (oldConcept.contains(x,y) && !newConcept.contains(x,y) && !(x >= this.getX1() - this.getShiftOldConcept() && x <= this.getX2() - this.getShiftOldConcept() && y >= this.getY1() && y <= this.getY2())) {
            Set<String> uriString=model.getOntologyURIString();
            for (            String uri : uriString) {
              if (ind.toString().contains(uri)) {
                posNotCovIndVector.add(new IndividualPoint(""String_Node_Str"",(int)x,(int)y,ind.toManchesterSyntaxString(uri,null)));
              }
            }
            k++;
            flag=false;
            x=random.nextInt(n);
            y=random.nextInt(n);
            break;
          }
 else {
            x=random.nextInt(n);
            y=random.nextInt(n);
          }
        }
      }
    }
    points.addAll(posCovIndVector);
    points.addAll(posNotCovIndVector);
    points.addAll(additionalIndividuals);
  }
}"
9974,"private void renderPlus(int w){
  if (eval != null) {
    coveredIndividualSize=((EvaluatedDescriptionClass)eval).getCoveredInstances().size();
    double newConcepts=((EvaluatedDescriptionClass)eval).getAddition();
    double oldConcepts=((EvaluatedDescriptionClass)eval).getCoverage();
    shiftNewConcept=0;
    shiftOldConcept=0;
    shiftNewConceptX=0;
    shiftCovered=0;
    if (coveredIndividualSize == 0) {
      shiftNewConcept=(int)Math.round(((WIDTH + w) / 2.0) * newConcepts);
    }
 else     if (additionalIndividualSize != coveredIndividualSize) {
      shiftNewConcept=(int)Math.round(((WIDTH + w) / 2.0) * (1.0 + (1.0 - oldConcepts)));
      shiftOldConcept=(int)Math.round(((WIDTH + w) / 2.0) * oldConcepts);
      shiftCovered=(int)Math.round(((WIDTH + w) / 2.0) * (1 - oldConcepts));
    }
    if (((EvaluatedDescriptionClass)eval).getAddition() != 1.0 && ((EvaluatedDescriptionClass)eval).getCoverage() == 1.0) {
      shiftCovered=(int)Math.round(((WIDTH + w) / 2.0) * 0.625);
      shiftNewConceptX=shiftCovered;
      shiftNewConcept=2 * shiftNewConceptX;
    }
  }
  int i=conceptNew.length();
  while (i > 0) {
    int sub=conceptNew.indexOf(""String_Node_Str"");
    String subString=conceptNew.substring(0,sub) + ""String_Node_Str"";
    conceptNew=conceptNew.replace(conceptNew.substring(0,sub + 1),""String_Node_Str"");
    while (sub < SUBSTRING_SIZE) {
      if (conceptNew.length() > 0 && conceptNew.contains(""String_Node_Str"")) {
        sub=conceptNew.indexOf(""String_Node_Str"");
        if (subString.length() + sub < SUBSTRING_SIZE) {
          subString=subString + conceptNew.substring(0,sub) + ""String_Node_Str"";
          conceptNew=conceptNew.replace(conceptNew.substring(0,sub + 1),""String_Node_Str"");
          sub=subString.length();
        }
 else {
          break;
        }
      }
 else {
        if (subString.length() + conceptNew.length() > SUBSTRING_SIZE + SPACE_SIZE) {
          conceptVector.add(subString);
          subString=conceptNew;
          conceptNew=""String_Node_Str"";
          break;
        }
 else {
          subString=subString + conceptNew;
          conceptNew=""String_Node_Str"";
          break;
        }
      }
    }
    conceptVector.add(subString);
    i=conceptNew.length();
  }
}","private void renderPlus(int w){
  if (eval != null) {
    coveredIndividualSize=((EvaluatedDescriptionClass)eval).getCoveredInstances().size();
    double newConcepts=((EvaluatedDescriptionClass)eval).getAddition();
    double oldConcepts=((EvaluatedDescriptionClass)eval).getCoverage();
    shiftNewConcept=0;
    shiftOldConcept=0;
    shiftNewConceptX=0;
    shiftCovered=0;
    if (coveredIndividualSize == 0) {
      shiftNewConcept=(int)Math.round(((WIDTH + w) / 2.0) * newConcepts);
    }
 else     if (additionalIndividualSize != coveredIndividualSize) {
      shiftNewConcept=(int)Math.round(((WIDTH + w) / 2.0) * (1.0 + (1.0 - oldConcepts)));
      shiftOldConcept=(int)Math.round(((WIDTH + w) / 2.0) * oldConcepts);
      shiftCovered=(int)Math.round(((WIDTH + w) / 2.0) * (1 - oldConcepts));
    }
    if (((EvaluatedDescriptionClass)eval).getAddition() != 1.0 && ((EvaluatedDescriptionClass)eval).getCoverage() == 1.0) {
      shiftCovered=(int)Math.round(((WIDTH + w) / 2.0) * 0.625);
      shiftNewConceptX=shiftCovered;
      shiftNewConcept=2 * shiftNewConceptX;
    }
  }
  int i=conceptNew.length();
  while (i > 0) {
    int sub=0;
    String subString=""String_Node_Str"";
    if (conceptNew.contains(""String_Node_Str"")) {
      sub=conceptNew.indexOf(""String_Node_Str"");
      subString=conceptNew.substring(0,sub) + ""String_Node_Str"";
      conceptNew=conceptNew.replace(conceptNew.substring(0,sub + 1),""String_Node_Str"");
    }
 else {
      subString=conceptNew;
      conceptNew=""String_Node_Str"";
    }
    while (sub < SUBSTRING_SIZE) {
      if (conceptNew.length() > 0 && conceptNew.contains(""String_Node_Str"")) {
        sub=conceptNew.indexOf(""String_Node_Str"");
        if (subString.length() + sub < SUBSTRING_SIZE) {
          subString=subString + conceptNew.substring(0,sub) + ""String_Node_Str"";
          conceptNew=conceptNew.replace(conceptNew.substring(0,sub + 1),""String_Node_Str"");
          sub=subString.length();
        }
 else {
          break;
        }
      }
 else {
        if (subString.length() + conceptNew.length() > SUBSTRING_SIZE + SPACE_SIZE) {
          conceptVector.add(subString);
          subString=conceptNew;
          conceptNew=""String_Node_Str"";
          break;
        }
 else {
          subString=subString + conceptNew;
          conceptNew=""String_Node_Str"";
          break;
        }
      }
    }
    conceptVector.add(subString);
    i=conceptNew.length();
  }
}"
9975,"/** 
 * Constructor of the class.
 * @param p display String 
 * @param x coordinate on the x axis
 * @param y coordinate on the y axis
 * @param ind Name of the Individual
 */
public IndividualPoint(String p,int x,int y,String ind){
  this.point=p;
  this.xAxis=x;
  this.yAxis=y;
  this.circlePoint=new Ellipse2D.Double(x - 1,y - 1,3,3);
  this.individual=ind;
}","/** 
 * Constructor of the class.
 * @param p display String 
 * @param x coordinate on the x axis
 * @param y coordinate on the y axis
 * @param ind Name of the Individual
 */
public IndividualPoint(String p,int x,int y,String ind){
  this.point=p;
  this.xAxis=x;
  this.yAxis=y;
  this.circlePoint=new Ellipse2D.Double(x - 1,y - 1,4,4);
  this.individual=ind;
}"
9976,"@Override public void run(){
  model.getSuggestModel().removeAllElements();
  model.initReasoner();
  reasoner=model.getReasoner();
  isInconsistent=false;
  if (!isInconsistent) {
    this.checkURI();
    this.setPositiveConcept();
    if (this.hasIndividuals()) {
      view.getRunButton().setEnabled(true);
      view.getHintPanel().setForeground(Color.BLACK);
      view.setHintMessage(""String_Node_Str"");
    }
 else {
      view.getRunButton().setEnabled(false);
      view.getHintPanel().setVisible(true);
      String message=""String_Node_Str"" + current + ""String_Node_Str"";
      view.getHintPanel().setForeground(Color.RED);
      view.setHintMessage(message);
    }
  }
 else {
    view.getHintPanel().setForeground(Color.RED);
    view.getRunButton().setEnabled(false);
    view.setHintMessage(""String_Node_Str"");
  }
}","@Override public void run(){
  model.getSuggestModel().removeAllElements();
  reasoner=model.getReasoner();
  isInconsistent=false;
  if (!isInconsistent) {
    this.checkURI();
    this.setPositiveConcept();
    if (this.hasIndividuals()) {
      view.getRunButton().setEnabled(true);
      view.getHintPanel().setForeground(Color.BLACK);
      view.setHintMessage(""String_Node_Str"");
    }
 else {
      view.getRunButton().setEnabled(false);
      view.getHintPanel().setVisible(true);
      String message=""String_Node_Str"" + current + ""String_Node_Str"";
      view.getHintPanel().setForeground(Color.RED);
      view.setHintMessage(message);
    }
  }
 else {
    view.getHintPanel().setForeground(Color.RED);
    view.getRunButton().setEnabled(false);
    view.setHintMessage(""String_Node_Str"");
  }
}"
9977,"public void run(){
  model.setSuggestList(result);
  dm.clear();
  int i=0;
  for (  EvaluatedDescription eval : result) {
    Set<String> ont=model.getOntologyURIString();
    for (    String ontology : ont) {
      if (eval.getDescription().toString().contains(ontology)) {
        if (model.isConsistent(eval)) {
          dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          break;
        }
 else {
          dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          view.setIsInconsistent(true);
          break;
        }
      }
    }
  }
  view.getSuggestClassPanel().setSuggestList(dm);
}","public void run(){
  model.setSuggestList(result);
  dm.clear();
  int i=0;
  for (  EvaluatedDescription eval : result) {
    Set<String> ont=model.getOntologyURIString();
    for (    String ontology : ont) {
      if (eval.getDescription().toString().contains(ontology)) {
        if (((EvaluatedDescriptionClass)eval).isConsistent()) {
          dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          break;
        }
 else {
          dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
          view.setIsInconsistent(true);
          break;
        }
      }
    }
  }
  view.getSuggestClassPanel().setSuggestList(dm);
}"
9978,"/** 
 * This is the constructor for the action handler.
 * @param a ActionHandler
 * @param m DLLearnerModel
 * @param view DLlearner tab
 * @param i id if it is a subclass or an equivalent class
 */
public ActionHandler(DLLearnerModel m,DLLearnerView view,String i){
  this.view=view;
  this.id=i;
  this.model=m;
  toggled=false;
}","/** 
 * This is the constructor for the action handler.
 * @param a ActionHandler
 * @param m DLLearnerModel
 * @param view DLlearner tab
 * @param i id if it is a subclass or an equivalent class
 */
public ActionHandler(DLLearnerModel m,DLLearnerView view){
  this.view=view;
  this.model=m;
  toggled=false;
}"
9979,"private void updateList(final List<? extends EvaluatedDescription> result){
  Runnable doUpdateList=new Runnable(){
    public void run(){
      model.setSuggestList(result);
      dm.clear();
      int i=0;
      for (      EvaluatedDescription eval : result) {
        Set<String> ont=model.getOntologyURIString();
        for (        String ontology : ont) {
          if (eval.getDescription().toString().contains(ontology)) {
            if (model.isConsistent(eval)) {
              dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              break;
            }
 else {
              dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              view.setIsInconsistent(true);
              break;
            }
          }
        }
      }
      view.getSuggestClassPanel().setSuggestList(dm);
    }
  }
;
  SwingUtilities.invokeLater(doUpdateList);
}","private void updateList(final List<? extends EvaluatedDescription> result){
  Runnable doUpdateList=new Runnable(){
    public void run(){
      model.setSuggestList(result);
      dm.clear();
      int i=0;
      for (      EvaluatedDescription eval : result) {
        Set<String> ont=model.getOntologyURIString();
        for (        String ontology : ont) {
          if (eval.getDescription().toString().contains(ontology)) {
            if (((EvaluatedDescriptionClass)eval).isConsistent()) {
              dm.add(i,new SuggestListItem(colorGreen,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              break;
            }
 else {
              dm.add(i,new SuggestListItem(colorRed,eval.getDescription().toManchesterSyntaxString(ontology,null),((EvaluatedDescriptionClass)eval).getAccuracy() * 100));
              view.setIsInconsistent(true);
              break;
            }
          }
        }
      }
      view.getSuggestClassPanel().setSuggestList(dm);
    }
  }
;
  SwingUtilities.invokeLater(doUpdateList);
}"
9980,"/** 
 * This is the constructor for DL-Learner model.
 * @param editorKit Editor Kit to get the currently loaded Ontology
 * @param id String if it learns a subclass or a superclass.
 * @param view current view of the DL-Learner tab
 */
public DLLearnerModel(OWLEditorKit editorKit,DLLearnerView view){
  editor=editorKit;
  this.view=view;
  ontologyConsistent=true;
  instancesCount=0;
  owlDescription=new HashSet<OWLDescription>();
  ComponentManager.setComponentClasses(componenten);
  cm=ComponentManager.getInstance();
  ds=new HashSet<OWLDescription>();
  suggestModel=new DefaultListModel();
  ontologieURI=new HashSet<String>();
  sources=new HashSet<KnowledgeSource>();
}","/** 
 * This is the constructor for DL-Learner model.
 * @param editorKit Editor Kit to get the currently loaded Ontology
 * @param id String if it learns a subclass or a superclass.
 * @param view current view of the DL-Learner tab
 */
public DLLearnerModel(OWLEditorKit editorKit,DLLearnerView view){
  editor=editorKit;
  this.view=view;
  ontologyConsistent=true;
  owlDescription=new HashSet<OWLDescription>();
  ComponentManager.setComponentClasses(componenten);
  cm=ComponentManager.getInstance();
  ds=new HashSet<OWLDescription>();
  suggestModel=new DefaultListModel();
  ontologieURI=new HashSet<String>();
  sources=new HashSet<KnowledgeSource>();
}"
9981,"/** 
 * This Method renders the view of the plugin.
 */
public void makeView(){
  learner.remove(detail);
  run.setEnabled(false);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(575,350));
  detail.setVisible(false);
  hint.setText(""String_Node_Str"");
  isInconsistent=false;
  readThread=new ReadingOntologyThread(editorKit,this,model);
  readThread.start();
  hint.setVisible(true);
  advanced.setIcon(icon);
  accept.setEnabled(false);
  action.resetToggled();
  addButtonPanel.add(""String_Node_Str"",accept);
  sugPanel.setSuggestList(new DefaultListModel());
  sugPanel=sugPanel.updateSuggestClassList();
  advanced.setSelected(false);
  sugPanel.setBounds(10,35,470,110);
  adv.setBounds(40,195,200,20);
  wikiPane.setBounds(220,0,350,30);
  addButtonPanel.setBounds(485,40,80,70);
  run.setBounds(10,0,200,30);
  advanced.setBounds(10,195,20,20);
  detail.setBounds(10,195,600,300);
  detail.setVisible(true);
  sugPanel.setVisible(true);
  posPanel.setVisible(false);
  posPanel.setBounds(10,225,490,250);
  accept.setBounds(510,40,80,80);
  hint.setBounds(10,150,490,35);
  errorMessage.setBounds(485,110,80,80);
  learner.add(run);
  learner.add(wikiPane);
  learner.add(adv);
  learner.add(advanced);
  learner.add(sugPanel);
  learner.add(addButtonPanel);
  learner.add(hint);
  learner.add(errorMessage);
  learner.add(posPanel);
  learnerPanel.add(learner);
  learnerScroll.setViewportView(learnerPanel);
  this.renderErrorMessage(""String_Node_Str"");
}","/** 
 * This Method renders the view of the plugin.
 */
public void makeView(String label){
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(detail);
  model.setID(label);
  run.setEnabled(false);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.anchor=GridBagConstraints.FIRST_LINE_START;
  learner.add(run,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridwidth=GridBagConstraints.REMAINDER;
  learner.add(wikiPane,c);
  sugPanel.setSuggestList(new DefaultListModel());
  sugPanel=sugPanel.updateSuggestClassList();
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.fill=GridBagConstraints.NONE;
  learner.add(sugPanel,c);
  accept.setEnabled(false);
  addButtonPanel.add(""String_Node_Str"",accept);
  c.gridwidth=GridBagConstraints.REMAINDER;
  learner.add(addButtonPanel,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.ipady=20;
  learner.add(hint,c);
  advanced.setIcon(icon);
  advanced.setSelected(false);
  c.ipady=0;
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.RELATIVE;
  learner.add(advanced,c);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.REMAINDER;
  c.ipady=20;
  learner.add(adv,c);
  posPanel.setVisible(false);
  c.fill=GridBagConstraints.NONE;
  c.gridwidth=GridBagConstraints.RELATIVE;
  c.gridx=0;
  c.gridy=4;
  c.gridwidth=3;
  c.ipady=80;
  learner.add(posPanel,c);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  detail.setVisible(false);
  hint.setText(""String_Node_Str"");
  isInconsistent=false;
  readThread=new ReadingOntologyThread(editorKit,this,model);
  readThread.start();
  hint.setVisible(true);
  action.resetToggled();
  addButtonPanel.setBounds(485,40,80,70);
  detail.setBounds(10,195,600,300);
  detail.setVisible(true);
  sugPanel.setVisible(true);
  learnerScroll.setViewportView(learner);
  this.renderErrorMessage(""String_Node_Str"");
}"
9982,"/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 * @param label String
 */
public DLLearnerView(String label,OWLEditorKit editor){
  editorKit=editor;
  model=new DLLearnerModel(editorKit,this);
  model.setID(label);
  sugPanel=new SuggestClassPanel();
  learnerPanel=new JPanel();
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this,label);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  run=new JButton(""String_Node_Str"");
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  sugPanel.addSuggestPanelMouseListener(action);
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(null);
  accept.setPreferredSize(new Dimension(260,50));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(600,400));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPPED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}","/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 * @param label String
 */
public DLLearnerView(OWLEditorKit editor){
  editorKit=editor;
  model=new DLLearnerModel(editorKit,this);
  sugPanel=new SuggestClassPanel();
  learnerPanel=new JPanel();
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  run=new JButton(""String_Node_Str"");
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  sugPanel.addSuggestPanelMouseListener(action);
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(new GridBagLayout());
  accept.setPreferredSize(new Dimension(90,50));
  run.setPreferredSize(new Dimension(130,30));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED);
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}"
9983,"public void setGraphicalPanel(){
  learner.remove(posPanel);
  learner.remove(advanced);
  learner.remove(adv);
  learner.repaint();
  posPanel.setBounds(10,435,490,250);
  adv.setBounds(40,405,200,20);
  advanced.setBounds(10,405,20,20);
  detail.setBounds(10,195,590,200);
  detail.setVisible(true);
  learner.add(adv);
  learner.add(advanced);
  learner.add(posPanel);
  learner.add(detail);
  learnerPanel.setPreferredSize(new Dimension(575,620));
  learnerPanel.removeAll();
  learnerPanel.add(learner);
  learnerScroll.setViewportView(learnerPanel);
  learnerScroll.repaint();
}","public void setGraphicalPanel(){
  GridBagConstraints c=new GridBagConstraints();
  learner.remove(posPanel);
  learner.remove(advanced);
  learner.remove(adv);
  learner.repaint();
  detail.setVisible(true);
  c.fill=GridBagConstraints.NONE;
  c.gridx=0;
  c.gridy=3;
  c.gridwidth=3;
  c.ipady=80;
  learner.add(detail,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=4;
  c.gridwidth=1;
  learner.add(advanced,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=1;
  c.gridy=4;
  c.gridwidth=GridBagConstraints.REMAINDER;
  learner.add(adv,c);
  c.fill=GridBagConstraints.NONE;
  c.gridx=0;
  c.gridy=5;
  c.gridwidth=3;
  c.ipady=80;
  learner.add(posPanel,c);
  learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  learnerScroll.setViewportView(learner);
  learnerScroll.repaint();
}"
9984,"/** 
 * This method sets the right icon for the advanced Panel.
 * @param toggled boolean
 */
public void setIconToggled(boolean toggled){
  if (toggled) {
    advanced.setIcon(toggledIcon);
    learnerPanel.setPreferredSize(new Dimension(575,400));
  }
  if (!toggled) {
    advanced.setIcon(icon);
    learnerPanel.setPreferredSize(new Dimension(575,350));
  }
}","/** 
 * This method sets the right icon for the advanced Panel.
 * @param toggled boolean
 */
public void setIconToggled(boolean toggled){
  this.toogled=toggled;
  if (this.toogled) {
    advanced.setIcon(toggledIcon);
    learnerPanel.setPreferredSize(new Dimension(WIDTH,OPTION_HEIGHT));
    learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  }
  if (!this.toogled) {
    advanced.setIcon(icon);
    learnerPanel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
    learnerScroll.setPreferredSize(new Dimension(SCROLL_WIDTH,SCROLL_HEIGHT));
  }
}"
9985,"/** 
 * When a Button is pressed this method select the right.
 * @param z ActionEvent
 */
public void actionPerformed(ActionEvent z){
  if (z.getActionCommand().equals(""String_Node_Str"" + id + ""String_Node_Str"")) {
    model.setKnowledgeSource();
    model.setReasoner();
    model.setLearningProblem();
    model.setLearningAlgorithm();
    view.getRunButton().setEnabled(false);
    view.renderErrorMessage(""String_Node_Str"");
    retriever=new SuggestionRetriever();
    retriever.execute();
  }
  if (z.getActionCommand().equals(""String_Node_Str"")) {
    view.getMoreDetailForSuggestedConceptsPanel().repaint();
    if (evaluatedDescription != null) {
      model.changeDLLearnerDescriptionsToOWLDescriptions(evaluatedDescription.getDescription());
    }
 else {
      model.changeDLLearnerDescriptionsToOWLDescriptions((Description)view.getSuggestClassPanel().getSuggestList().getSelectedValue());
    }
    String message=""String_Node_Str"";
    view.renderErrorMessage(message);
  }
  if (z.getActionCommand().equals(""String_Node_Str"")) {
    if (!toggled) {
      toggled=true;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
 else {
      toggled=false;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
  }
}","/** 
 * When a Button is pressed this method select the right.
 * @param z ActionEvent
 */
public void actionPerformed(ActionEvent z){
  if (z.getActionCommand().equals(""String_Node_Str"" + id + ""String_Node_Str"")) {
    model.setKnowledgeSource();
    model.setReasoner();
    model.setLearningProblem();
    model.setLearningAlgorithm();
    view.getRunButton().setEnabled(false);
    view.renderErrorMessage(""String_Node_Str"");
    retriever=new SuggestionRetriever();
    retriever.execute();
  }
  if (z.getActionCommand().equals(""String_Node_Str"")) {
    if (evaluatedDescription != null) {
      model.changeDLLearnerDescriptionsToOWLDescriptions(evaluatedDescription.getDescription());
    }
 else {
      model.changeDLLearnerDescriptionsToOWLDescriptions((Description)view.getSuggestClassPanel().getSuggestList().getSelectedValue());
    }
    String message=""String_Node_Str"";
    view.renderErrorMessage(message);
  }
  if (z.getActionCommand().equals(""String_Node_Str"")) {
    if (!toggled) {
      toggled=true;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
 else {
      toggled=false;
      view.setIconToggled(toggled);
      view.setExamplePanelVisible(toggled);
    }
  }
}"
9986,"/** 
 * This method sets the Learning problem for the learning process. PosNegDefinitonLp for equivalent classes and PosNegInclusionLP for super classes.
 */
public void setLearningProblem(){
  lp=cm.learningProblem(ClassLearningProblem.class,reasoner);
  cm.applyConfigEntry(lp,""String_Node_Str"",currentConcept.toString());
  System.out.println(""String_Node_Str"" + currentConcept);
  if (id.equals(EQUIVALENT_CLASS_AXIOM_STRING)) {
    cm.applyConfigEntry(lp,""String_Node_Str"",EQUIVALENT_CLASS_LEARNING);
  }
  if (id.equals(SUPER_CLASS_AXIOM_STRING)) {
    cm.applyConfigEntry(lp,""String_Node_Str"",SUPER_CLASS_LEARNING);
  }
  try {
    lp.init();
  }
 catch (  ComponentInitException e) {
    e.printStackTrace();
  }
}","/** 
 * This method sets the Learning problem for the learning process. PosNegDefinitonLp for equivalent classes and PosNegInclusionLP for super classes.
 */
public void setLearningProblem(){
  lp=cm.learningProblem(ClassLearningProblem.class,reasoner);
  cm.applyConfigEntry(lp,""String_Node_Str"",currentConcept.toString());
  if (id.equals(EQUIVALENT_CLASS_AXIOM_STRING)) {
    cm.applyConfigEntry(lp,""String_Node_Str"",EQUIVALENT_CLASS_LEARNING);
  }
  if (id.equals(SUPER_CLASS_AXIOM_STRING)) {
    cm.applyConfigEntry(lp,""String_Node_Str"",SUPER_CLASS_LEARNING);
  }
  try {
    lp.init();
  }
 catch (  ComponentInitException e) {
    e.printStackTrace();
  }
}"
9987,"/** 
 * This Method renders the view of the plugin.
 */
public void makeView(){
  learner.remove(detail);
  run.setEnabled(false);
  System.out.println(""String_Node_Str"");
  detail.unsetPanel();
  detail.setVisible(false);
  hint.setText(""String_Node_Str"");
  isInconsistent=false;
  readThread=new ReadingOntologyThread(editorKit,this,model);
  readThread.start();
  hint.setVisible(true);
  advanced.setIcon(icon);
  accept.setEnabled(false);
  action.resetToggled();
  addButtonPanel.add(""String_Node_Str"",accept);
  sugPanel.setSuggestList(new DefaultListModel());
  sugPanel=sugPanel.updateSuggestClassList();
  advanced.setSelected(false);
  sugPanel.setBounds(10,35,490,110);
  adv.setBounds(40,195,200,20);
  wikiPane.setBounds(220,0,350,30);
  addButtonPanel.setBounds(510,40,80,70);
  run.setBounds(10,0,200,30);
  advanced.setBounds(10,195,20,20);
  detail.setBounds(10,195,600,300);
  detail.setVisible(true);
  sugPanel.setVisible(true);
  posPanel.setVisible(false);
  posPanel.setBounds(10,225,490,250);
  accept.setBounds(510,40,80,80);
  hint.setBounds(10,150,490,35);
  errorMessage.setBounds(510,100,490,50);
  learner.add(run);
  learner.add(wikiPane);
  learner.add(adv);
  learner.add(advanced);
  learner.add(sugPanel);
  learner.add(addButtonPanel);
  learner.add(hint);
  learner.add(errorMessage);
  learner.add(posPanel);
  learnerPanel.add(learner);
  learnerScroll.setViewportView(learnerPanel);
  this.renderErrorMessage(""String_Node_Str"");
}","/** 
 * This Method renders the view of the plugin.
 */
public void makeView(){
  learner.remove(detail);
  run.setEnabled(false);
  detail.unsetPanel();
  learnerPanel.setPreferredSize(new Dimension(575,350));
  detail.setVisible(false);
  hint.setText(""String_Node_Str"");
  isInconsistent=false;
  readThread=new ReadingOntologyThread(editorKit,this,model);
  readThread.start();
  hint.setVisible(true);
  advanced.setIcon(icon);
  accept.setEnabled(false);
  action.resetToggled();
  addButtonPanel.add(""String_Node_Str"",accept);
  sugPanel.setSuggestList(new DefaultListModel());
  sugPanel=sugPanel.updateSuggestClassList();
  advanced.setSelected(false);
  sugPanel.setBounds(10,35,470,110);
  adv.setBounds(40,195,200,20);
  wikiPane.setBounds(220,0,350,30);
  addButtonPanel.setBounds(485,40,80,70);
  run.setBounds(10,0,200,30);
  advanced.setBounds(10,195,20,20);
  detail.setBounds(10,195,600,300);
  detail.setVisible(true);
  sugPanel.setVisible(true);
  posPanel.setVisible(false);
  posPanel.setBounds(10,225,490,250);
  accept.setBounds(510,40,80,80);
  hint.setBounds(10,150,490,35);
  errorMessage.setBounds(485,110,80,80);
  learner.add(run);
  learner.add(wikiPane);
  learner.add(adv);
  learner.add(advanced);
  learner.add(sugPanel);
  learner.add(addButtonPanel);
  learner.add(hint);
  learner.add(errorMessage);
  learner.add(posPanel);
  learnerPanel.add(learner);
  learnerScroll.setViewportView(learnerPanel);
  this.renderErrorMessage(""String_Node_Str"");
}"
9988,"/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 * @param label String
 */
public DLLearnerView(String label,OWLEditorKit editor){
  editorKit=editor;
  model=new DLLearnerModel(editorKit,this);
  model.setID(label);
  sugPanel=new SuggestClassPanel();
  learnerPanel=new JPanel();
  learnerPanel.setLayout(new BorderLayout());
  learnerPanel.setPreferredSize(new Dimension(585,350));
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this,label);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  run=new JButton(""String_Node_Str"" + label + ""String_Node_Str"");
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  sugPanel.addSuggestPanelMouseListener(action);
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(null);
  accept.setPreferredSize(new Dimension(260,50));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(600,400));
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}","/** 
 * The constructor for the DL-Learner tab in the class description editor.
 * @param editor OWLEditorKit
 * @param label String
 */
public DLLearnerView(String label,OWLEditorKit editor){
  editorKit=editor;
  model=new DLLearnerModel(editorKit,this);
  model.setID(label);
  sugPanel=new SuggestClassPanel();
  learnerPanel=new JPanel();
  learnerPanel.setLayout(new BorderLayout());
  learnerScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  action=new ActionHandler(model,this,label);
  wikiPane=new JLabel(""String_Node_Str"");
  URL iconUrl=this.getClass().getResource(""String_Node_Str"");
  icon=new ImageIcon(iconUrl);
  URL toggledIconUrl=this.getClass().getResource(""String_Node_Str"");
  toggledIcon=new ImageIcon(toggledIconUrl);
  adv=new JLabel(""String_Node_Str"");
  advanced=new JToggleButton(icon);
  advanced.setVisible(true);
  run=new JButton(""String_Node_Str"" + label + ""String_Node_Str"");
  accept=new JButton(""String_Node_Str"");
  addButtonPanel=new JPanel(new BorderLayout());
  sugPanel.addSuggestPanelMouseListener(action);
  errorMessage=new JTextArea();
  errorMessage.setEditable(false);
  hint=new JTextArea();
  hint.setEditable(false);
  hint.setText(""String_Node_Str"");
  learner=new JPanel();
  advanced.setSize(20,20);
  learner.setLayout(null);
  accept.setPreferredSize(new Dimension(260,50));
  advanced.setName(""String_Node_Str"");
  learnerScroll.setPreferredSize(new Dimension(600,400));
  posPanel=new PosAndNegSelectPanel(model,action);
  detail=new MoreDetailForSuggestedConceptsPanel(model);
  this.addAcceptButtonListener(this.action);
  this.addRunButtonListener(this.action);
  this.addAdvancedButtonListener(this.action);
}"
9989,"public void setGraphicalPanel(){
  learner.remove(posPanel);
  learner.remove(advanced);
  learner.remove(adv);
  learner.repaint();
  posPanel.setBounds(10,535,490,250);
  adv.setBounds(40,505,200,20);
  advanced.setBounds(10,505,20,20);
  detail.setBounds(10,195,600,300);
  detail.setVisible(true);
  learner.add(adv);
  learner.add(advanced);
  learner.add(posPanel);
  learner.add(detail);
  learnerPanel.setPreferredSize(new Dimension(600,660));
  learnerPanel.removeAll();
  learnerPanel.add(learner);
  learnerScroll.setViewportView(learnerPanel);
  learnerScroll.repaint();
}","public void setGraphicalPanel(){
  learner.remove(posPanel);
  learner.remove(advanced);
  learner.remove(adv);
  learner.repaint();
  posPanel.setBounds(10,435,490,250);
  adv.setBounds(40,405,200,20);
  advanced.setBounds(10,405,20,20);
  detail.setBounds(10,195,590,200);
  detail.setVisible(true);
  learner.add(adv);
  learner.add(advanced);
  learner.add(posPanel);
  learner.add(detail);
  learnerPanel.setPreferredSize(new Dimension(575,560));
  learnerPanel.removeAll();
  learnerPanel.add(learner);
  learnerScroll.setViewportView(learnerPanel);
  learnerScroll.repaint();
}"
9990,"@Override protected void paintComponent(Graphics g){
  if (eval != null) {
    Graphics2D g2D;
    g2D=(Graphics2D)g;
    AlphaComposite ac=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.5f);
    g2D.setColor(Color.YELLOW);
    g2D.fill(oldConcept);
    g2D.drawString(model.getOldConceptOWLAPI().toString(),310,10);
    g2D.setColor(Color.ORANGE);
    int p=30;
    for (int i=0; i < conceptVector.size(); i++) {
      g2D.drawString(conceptVector.get(i),310,p);
      p=p + 20;
    }
    g2D.setComposite(ac);
    g2D.fill(newConcept);
    g2D.setColor(Color.BLACK);
    if (coveredIndividualSize != model.getReasoner().getIndividuals(model.getCurrentConcept()).size() && coveredIndividualSize != 0) {
      g2D.drawLine(x1 - 1 - shiftOldConcept,y1 - 1,x2 + 1 - shiftOldConcept,y1 - 1);
      g2D.drawLine(x1 - shiftOldConcept,centerY - 1,x2 - shiftOldConcept,centerY - 1);
      g2D.drawLine(x1 - shiftOldConcept,centerY,x2 - shiftOldConcept,centerY);
      g2D.drawLine(x1 - shiftOldConcept,centerY + 1,x2 - shiftOldConcept,centerY + 1);
      g2D.drawLine(x1 - 1 - shiftOldConcept,y2 + 1,x2 + 1 - shiftOldConcept,y2 + 1);
      g2D.drawLine(x1 - 1 - shiftOldConcept,y1 - 1,x1 - 1 - shiftOldConcept,y2 + 1);
      g2D.drawLine(centerX - 1 - shiftOldConcept,y1,centerX - 1 - shiftOldConcept,y2);
      g2D.drawLine(centerX - shiftOldConcept,y1,centerX - shiftOldConcept,y2);
      g2D.drawLine(centerX + 1 - shiftOldConcept,y1,centerX + 1 - shiftOldConcept,y2);
      g2D.drawLine(x2 + 1 - shiftOldConcept,y1 - 1,x2 + 1 - shiftOldConcept,y2 + 1);
    }
    g2D.drawLine(x1 - 1 + shiftCovered,y1 - 1,x2 + 1 + shiftCovered,y1 - 1);
    g2D.drawLine(x1 + shiftCovered,centerY - 1,x2 + shiftCovered,centerY - 1);
    g2D.drawLine(x1 + shiftCovered,centerY,x2 + shiftCovered,centerY);
    g2D.drawLine(x1 + shiftCovered,centerY + 1,x2 + shiftCovered,centerY + 1);
    g2D.drawLine(x1 - 1 + shiftCovered,y2 + 1,x2 + 1 + shiftCovered,y2 + 1);
    g2D.drawLine(x1 - 1 + shiftCovered,y1 - 1,x1 - 1 + shiftCovered,y2 + 1);
    g2D.drawLine(centerX - 1 + shiftCovered,y1,centerX - 1 + shiftCovered,y2);
    g2D.drawLine(centerX + shiftCovered,y1,centerX + shiftCovered,y2);
    g2D.drawLine(centerX + 1 + shiftCovered,y1,centerX + 1 + shiftCovered,y2);
    g2D.drawLine(x2 + 1 + shiftCovered,y1 - 1,x2 + 1 + shiftCovered,y2 + 1);
    if (coveredIndividualSize != model.getReasoner().getIndividuals(model.getCurrentConcept()).size()) {
      g2D.drawLine(x1 - 1 + shiftNewConcept,y1 - 1,x2 + 1 + shiftNewConcept,y1 - 1);
      g2D.drawLine(x1 + shiftNewConcept,centerY - 1,x2 + shiftNewConcept,centerY - 1);
      g2D.drawLine(x1 + shiftNewConcept,centerY,x2 + shiftNewConcept,centerY);
      g2D.drawLine(x1 + shiftNewConcept,centerY + 1,x2 + shiftNewConcept,centerY + 1);
      g2D.drawLine(x1 - 1 + shiftNewConcept,y2 + 1,x2 + 1 + shiftNewConcept,y2 + 1);
      g2D.drawLine(x1 - 1 + shiftNewConcept,y1 - 1,x1 - 1 + shiftNewConcept,y2 + 1);
      g2D.drawLine(centerX - 1 + shiftNewConcept,y1,centerX - 1 + shiftNewConcept,y2);
      g2D.drawLine(centerX + shiftNewConcept,y1,centerX + shiftNewConcept,y2);
      g2D.drawLine(centerX + 1 + shiftNewConcept,y1,centerX + 1 + shiftNewConcept,y2);
      g2D.drawLine(x2 + 1 + shiftNewConcept,y1 - 1,x2 + 1 + shiftNewConcept,y2 + 1);
    }
    if (((EvaluatedDescriptionClass)eval).getAddition() != 1.0) {
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY - 1 + shiftNewConcept,x2 + shiftNewConceptX,centerY - 1 + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY + shiftNewConcept,x2 + shiftNewConceptX,centerY + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY + 1 + shiftNewConcept,x2 + shiftNewConceptX,centerY + 1 + shiftNewConcept);
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x1 - 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
      g2D.drawLine(centerX - 1 + shiftNewConceptX,y1 + shiftNewConcept,centerX - 1 + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(centerX + shiftNewConceptX,y1 + shiftNewConcept,centerX + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(centerX + 1 + shiftNewConceptX,y1 + shiftNewConcept,centerX + 1 + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(x2 + 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
    }
    for (int i=0; i < posCovIndVector.size(); i++) {
      g2D.setColor(Color.GREEN);
      g2D.drawString(posCovIndVector.get(i).getPoint(),posCovIndVector.get(i).getXAxis(),posCovIndVector.get(i).getYAxis());
    }
    for (int i=0; i < posNotCovIndVector.size(); i++) {
      g2D.setColor(Color.RED);
      g2D.drawString(posNotCovIndVector.get(i).getPoint(),posNotCovIndVector.get(i).getXAxis(),posNotCovIndVector.get(i).getYAxis());
    }
    for (int i=0; i < additionalIndividuals.size(); i++) {
      g2D.setColor(Color.BLACK);
      g2D.drawString(additionalIndividuals.get(i).getPoint(),additionalIndividuals.get(i).getXAxis(),additionalIndividuals.get(i).getYAxis());
    }
    this.setVisible(true);
    panel.repaint();
  }
}","@Override protected void paintComponent(Graphics g){
  if (eval != null) {
    Graphics2D g2D;
    g2D=(Graphics2D)g;
    AlphaComposite ac=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.5f);
    g2D.setColor(Color.YELLOW);
    g2D.fill(oldConcept);
    g2D.drawString(model.getOldConceptOWLAPI().toString(),310,10);
    g2D.setColor(Color.ORANGE);
    int p=30;
    for (int i=0; i < conceptVector.size(); i++) {
      g2D.drawString(conceptVector.get(i),310,p);
      p=p + 20;
    }
    g2D.setComposite(ac);
    g2D.fill(newConcept);
    g2D.setColor(Color.BLACK);
    if (coveredIndividualSize != model.getReasoner().getIndividuals(model.getCurrentConcept()).size() && coveredIndividualSize != 0) {
      g2D.drawLine(x1 - 1 - shiftOldConcept,y1 - 1,x2 + 1 - shiftOldConcept,y1 - 1);
      g2D.drawLine(x1 - shiftOldConcept,centerY - 1,x2 - shiftOldConcept,centerY - 1);
      g2D.drawLine(x1 - shiftOldConcept,centerY,x2 - shiftOldConcept,centerY);
      g2D.drawLine(x1 - shiftOldConcept,centerY + 1,x2 - shiftOldConcept,centerY + 1);
      g2D.drawLine(x1 - 1 - shiftOldConcept,y2 + 1,x2 + 1 - shiftOldConcept,y2 + 1);
      g2D.drawLine(x1 - 1 - shiftOldConcept,y1 - 1,x1 - 1 - shiftOldConcept,y2 + 1);
      g2D.drawLine(centerX - 1 - shiftOldConcept,y1,centerX - 1 - shiftOldConcept,y2);
      g2D.drawLine(centerX - shiftOldConcept,y1,centerX - shiftOldConcept,y2);
      g2D.drawLine(centerX + 1 - shiftOldConcept,y1,centerX + 1 - shiftOldConcept,y2);
      g2D.drawLine(x2 + 1 - shiftOldConcept,y1 - 1,x2 + 1 - shiftOldConcept,y2 + 1);
    }
    g2D.drawLine(x1 - 1 + shiftCovered,y1 - 1,x2 + 1 + shiftCovered,y1 - 1);
    g2D.drawLine(x1 + shiftCovered,centerY - 1,x2 + shiftCovered,centerY - 1);
    g2D.drawLine(x1 + shiftCovered,centerY,x2 + shiftCovered,centerY);
    g2D.drawLine(x1 + shiftCovered,centerY + 1,x2 + shiftCovered,centerY + 1);
    g2D.drawLine(x1 - 1 + shiftCovered,y2 + 1,x2 + 1 + shiftCovered,y2 + 1);
    g2D.drawLine(x1 - 1 + shiftCovered,y1 - 1,x1 - 1 + shiftCovered,y2 + 1);
    g2D.drawLine(centerX - 1 + shiftCovered,y1,centerX - 1 + shiftCovered,y2);
    g2D.drawLine(centerX + shiftCovered,y1,centerX + shiftCovered,y2);
    g2D.drawLine(centerX + 1 + shiftCovered,y1,centerX + 1 + shiftCovered,y2);
    g2D.drawLine(x2 + 1 + shiftCovered,y1 - 1,x2 + 1 + shiftCovered,y2 + 1);
    if (coveredIndividualSize != model.getReasoner().getIndividuals(model.getCurrentConcept()).size()) {
      g2D.drawLine(x1 - 1 + shiftNewConcept,y1 - 1,x2 + 1 + shiftNewConcept,y1 - 1);
      g2D.drawLine(x1 + shiftNewConcept,centerY - 1,x2 + shiftNewConcept,centerY - 1);
      g2D.drawLine(x1 + shiftNewConcept,centerY,x2 + shiftNewConcept,centerY);
      g2D.drawLine(x1 + shiftNewConcept,centerY + 1,x2 + shiftNewConcept,centerY + 1);
      g2D.drawLine(x1 - 1 + shiftNewConcept,y2 + 1,x2 + 1 + shiftNewConcept,y2 + 1);
      g2D.drawLine(x1 - 1 + shiftNewConcept,y1 - 1,x1 - 1 + shiftNewConcept,y2 + 1);
      g2D.drawLine(centerX - 1 + shiftNewConcept,y1,centerX - 1 + shiftNewConcept,y2);
      g2D.drawLine(centerX + shiftNewConcept,y1,centerX + shiftNewConcept,y2);
      g2D.drawLine(centerX + 1 + shiftNewConcept,y1,centerX + 1 + shiftNewConcept,y2);
      g2D.drawLine(x2 + 1 + shiftNewConcept,y1 - 1,x2 + 1 + shiftNewConcept,y2 + 1);
    }
    if (((EvaluatedDescriptionClass)eval).getAddition() != 1.0 && ((EvaluatedDescriptionClass)eval).getCoverage() == 1.0) {
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY - 1 + shiftNewConcept,x2 + shiftNewConceptX,centerY - 1 + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY + shiftNewConcept,x2 + shiftNewConceptX,centerY + shiftNewConcept);
      g2D.drawLine(x1 + shiftNewConceptX,centerY + 1 + shiftNewConcept,x2 + shiftNewConceptX,centerY + 1 + shiftNewConcept);
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
      g2D.drawLine(x1 - 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x1 - 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
      g2D.drawLine(centerX - 1 + shiftNewConceptX,y1 + shiftNewConcept,centerX - 1 + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(centerX + shiftNewConceptX,y1 + shiftNewConcept,centerX + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(centerX + 1 + shiftNewConceptX,y1 + shiftNewConcept,centerX + 1 + shiftNewConceptX,y2 + shiftNewConcept);
      g2D.drawLine(x2 + 1 + shiftNewConceptX,y1 - 1 + shiftNewConcept,x2 + 1 + shiftNewConceptX,y2 + 1 + shiftNewConcept);
    }
    for (int i=0; i < posCovIndVector.size(); i++) {
      g2D.setColor(Color.GREEN);
      g2D.drawString(posCovIndVector.get(i).getPoint(),posCovIndVector.get(i).getXAxis(),posCovIndVector.get(i).getYAxis());
    }
    for (int i=0; i < posNotCovIndVector.size(); i++) {
      g2D.setColor(Color.RED);
      g2D.drawString(posNotCovIndVector.get(i).getPoint(),posNotCovIndVector.get(i).getXAxis(),posNotCovIndVector.get(i).getYAxis());
    }
    for (int i=0; i < additionalIndividuals.size(); i++) {
      g2D.setColor(Color.BLACK);
      g2D.drawString(additionalIndividuals.get(i).getPoint(),additionalIndividuals.get(i).getXAxis(),additionalIndividuals.get(i).getYAxis());
    }
    this.setVisible(true);
    panel.repaint();
  }
}"
9991,"@Override public void mouseClicked(MouseEvent arg0){
  if (panel.getEvaluateddescription() != null) {
    if (arg0.getX() >= panel.getX1() + panel.getShiftCovered() && arg0.getX() <= panel.getX2() + panel.getShiftCovered() && arg0.getY() >= panel.getY1() && arg0.getY() <= panel.getY2()) {
      individualComboBox.clear();
      Set<Individual> covInd=((EvaluatedDescriptionClass)description).getCoveredInstances();
      for (      Individual ind : covInd) {
        individualComboBox.add(ind.toString());
      }
      indiBox=new JComboBox(individualComboBox);
      scrollPopup=new BasicComboPopup(indiBox);
      scrollPopup.setAutoscrolls(true);
      scrollPopup.show(panel,arg0.getX(),arg0.getY());
    }
    if (arg0.getX() >= panel.getX1() + panel.getShiftNewConcept() && arg0.getX() <= panel.getX2() + panel.getShiftNewConcept() && arg0.getY() >= panel.getY1() && arg0.getY() <= panel.getY2() || arg0.getX() >= panel.getX1() + panel.getShiftNewConceptX() && arg0.getX() <= panel.getX2() + panel.getShiftNewConceptX() && arg0.getY() >= panel.getY1() + panel.getShiftNewConcept() && arg0.getY() <= panel.getY2() + panel.getShiftNewConcept()) {
      individualComboBox.clear();
      Set<Individual> addInd=((EvaluatedDescriptionClass)description).getAdditionalInstances();
      for (      Individual ind : addInd) {
        individualComboBox.add(ind.toString());
      }
      indiBox=new JComboBox(individualComboBox);
      scrollPopup=new BasicComboPopup(indiBox);
      scrollPopup.setAutoscrolls(true);
      scrollPopup.show(panel,arg0.getX(),arg0.getY());
    }
    if (arg0.getX() >= panel.getX1() - panel.getShiftOldConcept() && arg0.getX() <= panel.getX2() - panel.getShiftOldConcept() && arg0.getY() >= panel.getY1() && arg0.getY() <= panel.getY2()) {
      individualComboBox.clear();
      Set<Individual> notCovInd=model.getReasoner().getIndividuals(model.getCurrentConcept());
      notCovInd.removeAll(((EvaluatedDescriptionClass)description).getCoveredInstances());
      for (      Individual ind : notCovInd) {
        individualComboBox.add(ind.toString());
      }
      indiBox=new JComboBox(individualComboBox);
      scrollPopup=new BasicComboPopup(indiBox);
      scrollPopup.setAutoscrolls(true);
      scrollPopup.show(panel,arg0.getX(),arg0.getY());
    }
  }
}","@Override public void mouseClicked(MouseEvent arg0){
  if (panel.getEvaluateddescription() != null) {
    if (arg0.getX() >= panel.getX1() + panel.getShiftCovered() && arg0.getX() <= panel.getX2() + panel.getShiftCovered() && arg0.getY() >= panel.getY1() && arg0.getY() <= panel.getY2()) {
      individualComboBox.clear();
      Set<Individual> covInd=((EvaluatedDescriptionClass)description).getCoveredInstances();
      int i=covInd.size();
      if (i > 0) {
        for (        Individual ind : covInd) {
          individualComboBox.add(ind.toString());
        }
        indiBox=new JComboBox(individualComboBox);
        scrollPopup=new BasicComboPopup(indiBox);
        scrollPopup.setAutoscrolls(true);
        scrollPopup.show(panel,arg0.getX(),arg0.getY());
      }
    }
    if (arg0.getX() >= panel.getX1() + panel.getShiftNewConcept() && arg0.getX() <= panel.getX2() + panel.getShiftNewConcept() && arg0.getY() >= panel.getY1() && arg0.getY() <= panel.getY2() || arg0.getX() >= panel.getX1() + panel.getShiftNewConceptX() && arg0.getX() <= panel.getX2() + panel.getShiftNewConceptX() && arg0.getY() >= panel.getY1() + panel.getShiftNewConcept() && arg0.getY() <= panel.getY2() + panel.getShiftNewConcept()) {
      individualComboBox.clear();
      Set<Individual> addInd=((EvaluatedDescriptionClass)description).getAdditionalInstances();
      int i=addInd.size();
      if (i > 0) {
        for (        Individual ind : addInd) {
          individualComboBox.add(ind.toString());
        }
        indiBox=new JComboBox(individualComboBox);
        scrollPopup=new BasicComboPopup(indiBox);
        scrollPopup.setAutoscrolls(true);
        scrollPopup.show(panel,arg0.getX(),arg0.getY());
      }
    }
    if (arg0.getX() >= panel.getX1() - panel.getShiftOldConcept() && arg0.getX() <= panel.getX2() - panel.getShiftOldConcept() && arg0.getY() >= panel.getY1() && arg0.getY() <= panel.getY2()) {
      individualComboBox.clear();
      Set<Individual> notCovInd=model.getReasoner().getIndividuals(model.getCurrentConcept());
      notCovInd.removeAll(((EvaluatedDescriptionClass)description).getCoveredInstances());
      int i=notCovInd.size();
      if (i > 0) {
        for (        Individual ind : notCovInd) {
          individualComboBox.add(ind.toString());
        }
        indiBox=new JComboBox(individualComboBox);
        scrollPopup=new BasicComboPopup(indiBox);
        scrollPopup.setAutoscrolls(true);
        scrollPopup.show(panel,arg0.getX(),arg0.getY());
      }
    }
  }
}"
9992,"/** 
 * This method renders the output for the detail panel.
 * @param desc selected description
 */
public void renderDetailPanel(EvaluatedDescription desc){
  accuracy.setVisible(false);
  accuracyText.setVisible(false);
  concept.setVisible(false);
  conceptText.setVisible(false);
  eval=desc;
  this.setInformation();
  p=new GraphicalCoveragePanel(eval,model,conceptText.getText(),this);
  p.setBounds(5,0,600,350);
  unsetEverything();
  conceptPanel.removeAll();
  conceptPanel.add(concept);
  conceptPanel.add(accuracy);
  conceptPanel.add(conceptText);
  conceptPanel.add(accuracyText);
  conceptPanel.setVisible(true);
  this.add(p);
  this.addPropertyChangeListener(handler);
  conceptPanel.addPropertyChangeListener(handler);
  this.repaint();
}","/** 
 * This method renders the output for the detail panel.
 * @param desc selected description
 */
public void renderDetailPanel(EvaluatedDescription desc){
  accuracy.setVisible(false);
  accuracyText.setVisible(false);
  concept.setVisible(false);
  conceptText.setVisible(false);
  eval=desc;
  this.setInformation();
  p=new GraphicalCoveragePanel(eval,model,conceptText.getText(),this);
  p.setBounds(5,0,600,350);
  unsetEverything();
  conceptPanel.removeAll();
  conceptPanel.add(concept);
  conceptPanel.add(accuracy);
  conceptPanel.add(conceptText);
  conceptPanel.add(accuracyText);
  conceptPanel.setVisible(true);
  this.add(p);
  this.addPropertyChangeListener(handler);
  this.repaint();
}"
9993,"/** 
 * Constructor for the Option Panel. 
 */
public OptionPanel(){
  setPreferredSize(new Dimension(490,100));
  setLayout(null);
  minAccuracyLabel=new JLabel(""String_Node_Str"");
  minAccuracyLabel.setBounds(5,0,150,40);
  maxExecutionTimeLabel=new JLabel(""String_Node_Str"");
  maxExecutionTimeLabel.setBounds(5,40,150,40);
  nrOfConceptsLabel=new JLabel(""String_Node_Str"");
  nrOfConceptsLabel.setBounds(5,80,150,40);
  minAccuracy=new JSlider(50,100,90);
  minAccuracy.setPaintTicks(true);
  minAccuracy.setMajorTickSpacing(10);
  minAccuracy.setMinorTickSpacing(1);
  minAccuracy.setPaintLabels(true);
  minAccuracy.setBounds(160,0,200,40);
  maxExecutionTime=new JSlider(2,20,5);
  maxExecutionTime.setPaintTicks(true);
  maxExecutionTime.setMajorTickSpacing(5);
  maxExecutionTime.setMinorTickSpacing(1);
  maxExecutionTime.setPaintLabels(true);
  maxExecutionTime.setBounds(160,40,200,40);
  nrOfConcepts=new JSlider(2,20,10);
  nrOfConcepts.setPaintTicks(true);
  nrOfConcepts.setMajorTickSpacing(2);
  nrOfConcepts.setMinorTickSpacing(1);
  nrOfConcepts.setPaintLabels(true);
  nrOfConcepts.setBounds(160,80,200,40);
  add(minAccuracyLabel);
  add(minAccuracy);
  add(maxExecutionTimeLabel);
  add(maxExecutionTime);
  add(nrOfConceptsLabel);
  add(nrOfConcepts);
}","/** 
 * Constructor for the Option Panel. 
 */
public OptionPanel(){
  setPreferredSize(new Dimension(490,100));
  setLayout(null);
  minAccuracyLabel=new JLabel(""String_Node_Str"");
  minAccuracyLabel.setBounds(5,0,150,40);
  maxExecutionTimeLabel=new JLabel(""String_Node_Str"");
  maxExecutionTimeLabel.setBounds(5,40,150,40);
  nrOfConceptsLabel=new JLabel(""String_Node_Str"");
  nrOfConceptsLabel.setBounds(5,80,150,40);
  minAccuracy=new JSlider(50,100,90);
  minAccuracy.setPaintTicks(true);
  minAccuracy.setMajorTickSpacing(10);
  minAccuracy.setMinorTickSpacing(1);
  minAccuracy.setPaintLabels(true);
  minAccuracy.setBounds(160,0,200,40);
  maxExecutionTime=new JSlider(2,20,8);
  maxExecutionTime.setPaintTicks(true);
  maxExecutionTime.setMajorTickSpacing(5);
  maxExecutionTime.setMinorTickSpacing(1);
  maxExecutionTime.setPaintLabels(true);
  maxExecutionTime.setBounds(160,40,200,40);
  nrOfConcepts=new JSlider(2,20,10);
  nrOfConcepts.setPaintTicks(true);
  nrOfConcepts.setMajorTickSpacing(2);
  nrOfConcepts.setMinorTickSpacing(1);
  nrOfConcepts.setPaintLabels(true);
  nrOfConcepts.setBounds(160,80,200,40);
  add(minAccuracyLabel);
  add(minAccuracy);
  add(maxExecutionTimeLabel);
  add(maxExecutionTime);
  add(nrOfConceptsLabel);
  add(nrOfConcepts);
}"
9994,"/** 
 * This method sets the individuals that belong to the concept which is chosen in protege.
 */
private void setPositiveConcept(){
  current=editor.getOWLWorkspace().getOWLSelectionModel().getLastSelectedClass();
  if (current != null) {
    SortedSet<Individual> individuals=null;
    hasIndividuals=false;
    if (!(current.toString().equals(""String_Node_Str""))) {
      List<NamedClass> classList=reasoner.getAtomicConceptsList();
      for (      NamedClass concept : classList) {
        if (individuals == null) {
          for (          String onto : ontologieURI) {
            if (concept.toString().contains(onto)) {
              if (concept.toString().equals(onto + current.toString())) {
                currentConcept=concept;
                if (reasoner.getIndividuals(concept) != null) {
                  if (reasoner.getIndividuals(concept).size() > 0) {
                    model.setInstancesCount(reasoner.getIndividuals(concept).size());
                    hasIndividuals=true;
                  }
                  individual=reasoner.getIndividuals(concept);
                  model.setIndividuals(individual);
                  model.setHasIndividuals(hasIndividuals);
                  System.out.println(""String_Node_Str"" + currentConcept);
                  model.setCurrentConcept(currentConcept);
                  view.getRunButton().setEnabled(true);
                  break;
                }
              }
            }
          }
        }
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      if (reasoner.getIndividuals().size() > 0) {
        hasIndividuals=true;
      }
      individual=reasoner.getIndividuals();
      model.setIndividuals(individual);
      model.setHasIndividuals(hasIndividuals);
    }
  }
}","/** 
 * This method sets the individuals that belong to the concept which is chosen in protege.
 */
private void setPositiveConcept(){
  current=editor.getOWLWorkspace().getOWLSelectionModel().getLastSelectedClass();
  if (current != null) {
    SortedSet<Individual> individuals=null;
    hasIndividuals=false;
    if (!(current.toString().equals(""String_Node_Str""))) {
      List<NamedClass> classList=reasoner.getAtomicConceptsList();
      for (      NamedClass concept : classList) {
        if (individuals == null) {
          for (          String onto : ontologieURI) {
            if (concept.toString().contains(onto)) {
              if (concept.toString().equals(onto + current.toString())) {
                currentConcept=concept;
                if (reasoner.getIndividuals(concept) != null) {
                  if (reasoner.getIndividuals(concept).size() > 0) {
                    model.setInstancesCount(reasoner.getIndividuals(concept).size());
                    hasIndividuals=true;
                  }
                  individual=reasoner.getIndividuals(concept);
                  model.setIndividuals(individual);
                  model.setHasIndividuals(hasIndividuals);
                  System.out.println(""String_Node_Str"" + currentConcept);
                  model.setCurrentConcept(currentConcept);
                  view.getRunButton().setEnabled(true);
                  break;
                }
              }
            }
          }
        }
      }
    }
 else {
      if (reasoner.getIndividuals().size() > 0) {
        hasIndividuals=true;
      }
      individual=reasoner.getIndividuals();
      model.setIndividuals(individual);
      model.setHasIndividuals(hasIndividuals);
    }
  }
}"
9995,"@Override public void run(){
  model.getSuggestModel().removeAllElements();
  model.initReasoner();
  reasoner=model.getReasoner();
  isInconsistent=false;
  if (!isInconsistent) {
    this.checkURI();
    this.setPositiveConcept();
    if (this.hasIndividuals()) {
      view.getRunButton().setEnabled(true);
    }
 else {
      view.getRunButton().setEnabled(false);
      view.getHintPanel().setVisible(false);
      String message=""String_Node_Str"";
      view.renderErrorMessage(message);
    }
  }
 else {
    view.getHintPanel().setForeground(Color.RED);
    view.getRunButton().setEnabled(false);
    view.setHintMessage(""String_Node_Str"");
  }
}","@Override public void run(){
  model.getSuggestModel().removeAllElements();
  model.initReasoner();
  reasoner=model.getReasoner();
  isInconsistent=false;
  if (!isInconsistent) {
    this.checkURI();
    this.setPositiveConcept();
    if (this.hasIndividuals()) {
      view.getRunButton().setEnabled(true);
      view.getHintPanel().setForeground(Color.BLACK);
      view.setHintMessage(""String_Node_Str"");
    }
 else {
      view.getRunButton().setEnabled(false);
      view.getHintPanel().setVisible(true);
      String message=""String_Node_Str"" + current + ""String_Node_Str"";
      view.getHintPanel().setForeground(Color.RED);
      view.setHintMessage(message);
    }
  }
 else {
    view.getHintPanel().setForeground(Color.RED);
    view.getRunButton().setEnabled(false);
    view.setHintMessage(""String_Node_Str"");
  }
}"
9996,"/** 
 * This is the constructor for the suggest panel. It creates a new Scroll panel and puts the Suggest List in it. 
 */
public SuggestClassPanel(){
  super();
  suggestScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  descriptions=new JList();
  descriptions.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  suggestPanel=new JPanel();
  descriptions.setVisible(true);
  suggestPanel.add(descriptions);
  suggestScroll.setPreferredSize(new Dimension(490,108));
  suggestScroll.setViewportView(descriptions);
  descriptions.setCellRenderer(new SuggestListCellRenderer());
  add(suggestScroll);
}","/** 
 * This is the constructor for the suggest panel. It creates a new Scroll panel and puts the Suggest List in it. 
 */
public SuggestClassPanel(){
  super();
  suggestScroll=new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  descriptions=new JList();
  descriptions.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  suggestPanel=new JPanel();
  descriptions.setVisible(true);
  suggestPanel.add(descriptions);
  suggestScroll.setPreferredSize(new Dimension(460,108));
  suggestScroll.setViewportView(descriptions);
  descriptions.setCellRenderer(new SuggestListCellRenderer());
  add(suggestScroll);
}"
9997,"@Override public boolean isSuperClassOfImpl(Description superConcept,Description subConcept){
  return rs.isSuperClassOf(superConcept,subConcept);
}","@Override public boolean isSuperClassOfImpl(Description superConcept,Description subConcept){
  return rc.isSuperClassOf(superConcept,subConcept);
}"
9998,"@Override public boolean isSatisfiableImpl(){
  return rs.isSatisfiable();
}","@Override public boolean isSatisfiableImpl(){
  return rc.isSatisfiable();
}"
9999,"public static void main(String[] args){
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  Logger logger=Logger.getRootLogger();
  logger.removeAllAppenders();
  logger.addAppender(consoleAppender);
  logger.setLevel(Level.INFO);
  JUnitCore.main(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","public static void main(String[] args){
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  Logger logger=Logger.getRootLogger();
  logger.removeAllAppenders();
  logger.addAppender(consoleAppender);
  logger.setLevel(Level.INFO);
  JUnitCore.main(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}"
10000,"@Test public void cloneTest() throws ParseException {
  ReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.EMPTY);
  Description d=KBParser.parseConcept(""String_Node_Str"");
  ConceptTransformation.cleanConcept(d);
  ELDescriptionTree tree=new ELDescriptionTree(rs,d);
  boolean testPerformance=true;
  ELDescriptionTree treeCloned=null;
  if (testPerformance) {
    int runs=1000000;
    long startTime=System.nanoTime();
    for (int i=0; i < runs; i++) {
      treeCloned=tree.clone();
    }
    long runTime=System.nanoTime() - startTime;
    System.out.println(Helper.prettyPrintNanoSeconds(runTime / runs,true,true) + ""String_Node_Str"");
  }
 else {
    treeCloned=tree.clone();
  }
  ELDescriptionTreeComparator comparator=new ELDescriptionTreeComparator();
  assertTrue(comparator.compare(tree,treeCloned) == 0);
}","@Test public void cloneTest() throws ParseException {
  ReasonerComponent rs=TestOntologies.getTestOntology(TestOntology.EMPTY);
  Description d=KBParser.parseConcept(""String_Node_Str"");
  ConceptTransformation.cleanConcept(d);
  ELDescriptionTree tree=new ELDescriptionTree(rs,d);
  boolean testPerformance=false;
  ELDescriptionTree treeCloned=null;
  if (testPerformance) {
    int runs=1000000;
    long startTime=System.nanoTime();
    for (int i=0; i < runs; i++) {
      treeCloned=tree.clone();
    }
    long runTime=System.nanoTime() - startTime;
    System.out.println(Helper.prettyPrintNanoSeconds(runTime / runs,true,true) + ""String_Node_Str"");
  }
 else {
    treeCloned=tree.clone();
  }
  ELDescriptionTreeComparator comparator=new ELDescriptionTreeComparator();
  assertTrue(comparator.compare(tree,treeCloned) == 0);
}"
